var mf = Object.defineProperty;
var gf = (r, e, n) => e in r ? mf(r, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : r[e] = n;
var Lt = (r, e, n) => gf(r, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function _l(r) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of r.split(",")) e[n] = 1;
  return (n) => n in e;
}
const se = {}, li = [], Dn = () => {
}, $u = () => !1, Wo = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // uppercase letter
(r.charCodeAt(2) > 122 || r.charCodeAt(2) < 97), xl = (r) => r.startsWith("onUpdate:"), Le = Object.assign, wl = (r, e) => {
  const n = r.indexOf(e);
  n > -1 && r.splice(n, 1);
}, vf = Object.prototype.hasOwnProperty, Zt = (r, e) => vf.call(r, e), Rt = Array.isArray, ci = (r) => gr(r) === "[object Map]", Si = (r) => gr(r) === "[object Set]", ic = (r) => gr(r) === "[object Date]", $t = (r) => typeof r == "function", xe = (r) => typeof r == "string", _n = (r) => typeof r == "symbol", ie = (r) => r !== null && typeof r == "object", Nu = (r) => (ie(r) || $t(r)) && $t(r.then) && $t(r.catch), Wu = Object.prototype.toString, gr = (r) => Wu.call(r), yf = (r) => gr(r).slice(8, -1), Uu = (r) => gr(r) === "[object Object]", Uo = (r) => xe(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, Hi = /* @__PURE__ */ _l(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Ho = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = r(n));
}, bf = /-\w/g, on = Ho(
  (r) => r.replace(bf, (e) => e.slice(1).toUpperCase())
), _f = /\B([A-Z])/g, ks = Ho(
  (r) => r.replace(_f, "-$1").toLowerCase()
), Xo = Ho((r) => r.charAt(0).toUpperCase() + r.slice(1)), ba = Ho(
  (r) => r ? `on${Xo(r)}` : ""
), xs = (r, e) => !Object.is(r, e), lo = (r, ...e) => {
  for (let n = 0; n < r.length; n++)
    r[n](...e);
}, Hu = (r, e, n, s = !1) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    writable: s,
    value: n
  });
}, Go = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
};
let rc;
const Yo = () => rc || (rc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function ne(r) {
  if (Rt(r)) {
    const e = {};
    for (let n = 0; n < r.length; n++) {
      const s = r[n], i = xe(s) ? Cf(s) : ne(s);
      if (i)
        for (const o in i)
          e[o] = i[o];
    }
    return e;
  } else if (xe(r) || ie(r))
    return r;
}
const xf = /;(?![^(]*\))/g, wf = /:([^]+)/, Sf = /\/\*[^]*?\*\//g;
function Cf(r) {
  const e = {};
  return r.replace(Sf, "").split(xf).forEach((n) => {
    if (n) {
      const s = n.split(wf);
      s.length > 1 && (e[s[0].trim()] = s[1].trim());
    }
  }), e;
}
function wt(r) {
  let e = "";
  if (xe(r))
    e = r;
  else if (Rt(r))
    for (let n = 0; n < r.length; n++) {
      const s = wt(r[n]);
      s && (e += s + " ");
    }
  else if (ie(r))
    for (const n in r)
      r[n] && (e += n + " ");
  return e.trim();
}
const kf = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Tf = /* @__PURE__ */ _l(kf);
function Xu(r) {
  return !!r || r === "";
}
function Mf(r, e) {
  if (r.length !== e.length) return !1;
  let n = !0;
  for (let s = 0; n && s < r.length; s++)
    n = vr(r[s], e[s]);
  return n;
}
function vr(r, e) {
  if (r === e) return !0;
  let n = ic(r), s = ic(e);
  if (n || s)
    return n && s ? r.getTime() === e.getTime() : !1;
  if (n = _n(r), s = _n(e), n || s)
    return r === e;
  if (n = Rt(r), s = Rt(e), n || s)
    return n && s ? Mf(r, e) : !1;
  if (n = ie(r), s = ie(e), n || s) {
    if (!n || !s)
      return !1;
    const i = Object.keys(r).length, o = Object.keys(e).length;
    if (i !== o)
      return !1;
    for (const a in r) {
      const l = r.hasOwnProperty(a), c = e.hasOwnProperty(a);
      if (l && !c || !l && c || !vr(r[a], e[a]))
        return !1;
    }
  }
  return String(r) === String(e);
}
function Sl(r, e) {
  return r.findIndex((n) => vr(n, e));
}
const Gu = (r) => !!(r && r.__v_isRef === !0), ct = (r) => xe(r) ? r : r == null ? "" : Rt(r) || ie(r) && (r.toString === Wu || !$t(r.toString)) ? Gu(r) ? ct(r.value) : JSON.stringify(r, Yu, 2) : String(r), Yu = (r, e) => Gu(e) ? Yu(r, e.value) : ci(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [s, i], o) => (n[_a(s, o) + " =>"] = i, n),
    {}
  )
} : Si(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => _a(n))
} : _n(e) ? _a(e) : ie(e) && !Rt(e) && !Uu(e) ? String(e) : e, _a = (r, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    _n(r) ? `Symbol(${(n = r.description) != null ? n : e})` : r
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let De;
class Ku {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = De, !e && De && (this.index = (De.scopes || (De.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = De;
      try {
        return De = this, e();
      } finally {
        De = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = De, De = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (De = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, s;
      for (n = 0, s = this.effects.length; n < s; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, s = this.scopes.length; n < s; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function qu(r) {
  return new Ku(r);
}
function Zu() {
  return De;
}
function Of(r, e = !1) {
  De && De.cleanups.push(r);
}
let oe;
const xa = /* @__PURE__ */ new WeakSet();
class Ju {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, De && De.active && De.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, xa.has(this) && (xa.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || th(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, oc(this), eh(this);
    const e = oe, n = yn;
    oe = this, yn = !0;
    try {
      return this.fn();
    } finally {
      nh(this), oe = e, yn = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Tl(e);
      this.deps = this.depsTail = void 0, oc(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? xa.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Ga(this) && this.run();
  }
  get dirty() {
    return Ga(this);
  }
}
let Qu = 0, Xi, Gi;
function th(r, e = !1) {
  if (r.flags |= 8, e) {
    r.next = Gi, Gi = r;
    return;
  }
  r.next = Xi, Xi = r;
}
function Cl() {
  Qu++;
}
function kl() {
  if (--Qu > 0)
    return;
  if (Gi) {
    let e = Gi;
    for (Gi = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let r;
  for (; Xi; ) {
    let e = Xi;
    for (Xi = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (s) {
          r || (r = s);
        }
      e = n;
    }
  }
  if (r) throw r;
}
function eh(r) {
  for (let e = r.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function nh(r) {
  let e, n = r.depsTail, s = n;
  for (; s; ) {
    const i = s.prevDep;
    s.version === -1 ? (s === n && (n = i), Tl(s), Ef(s)) : e = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = i;
  }
  r.deps = e, r.depsTail = n;
}
function Ga(r) {
  for (let e = r.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (sh(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!r._dirty;
}
function sh(r) {
  if (r.flags & 4 && !(r.flags & 16) || (r.flags &= -17, r.globalVersion === sr) || (r.globalVersion = sr, !r.isSSR && r.flags & 128 && (!r.deps && !r._dirty || !Ga(r))))
    return;
  r.flags |= 2;
  const e = r.dep, n = oe, s = yn;
  oe = r, yn = !0;
  try {
    eh(r);
    const i = r.fn(r._value);
    (e.version === 0 || xs(i, r._value)) && (r.flags |= 128, r._value = i, e.version++);
  } catch (i) {
    throw e.version++, i;
  } finally {
    oe = n, yn = s, nh(r), r.flags &= -3;
  }
}
function Tl(r, e = !1) {
  const { dep: n, prevSub: s, nextSub: i } = r;
  if (s && (s.nextSub = i, r.prevSub = void 0), i && (i.prevSub = s, r.nextSub = void 0), n.subs === r && (n.subs = s, !s && n.computed)) {
    n.computed.flags &= -5;
    for (let o = n.computed.deps; o; o = o.nextDep)
      Tl(o, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function Ef(r) {
  const { prevDep: e, nextDep: n } = r;
  e && (e.nextDep = n, r.prevDep = void 0), n && (n.prevDep = e, r.nextDep = void 0);
}
let yn = !0;
const ih = [];
function Qn() {
  ih.push(yn), yn = !1;
}
function ts() {
  const r = ih.pop();
  yn = r === void 0 ? !0 : r;
}
function oc(r) {
  const { cleanup: e } = r;
  if (r.cleanup = void 0, e) {
    const n = oe;
    oe = void 0;
    try {
      e();
    } finally {
      oe = n;
    }
  }
}
let sr = 0;
class Pf {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Ml {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!oe || !yn || oe === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== oe)
      n = this.activeLink = new Pf(oe, this), oe.deps ? (n.prevDep = oe.depsTail, oe.depsTail.nextDep = n, oe.depsTail = n) : oe.deps = oe.depsTail = n, rh(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const s = n.nextDep;
      s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = oe.depsTail, n.nextDep = void 0, oe.depsTail.nextDep = n, oe.depsTail = n, oe.deps === n && (oe.deps = s);
    }
    return n;
  }
  trigger(e) {
    this.version++, sr++, this.notify(e);
  }
  notify(e) {
    Cl();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      kl();
    }
  }
}
function rh(r) {
  if (r.dep.sc++, r.sub.flags & 4) {
    const e = r.dep.computed;
    if (e && !r.dep.subs) {
      e.flags |= 20;
      for (let s = e.deps; s; s = s.nextDep)
        rh(s);
    }
    const n = r.dep.subs;
    n !== r && (r.prevSub = n, n && (n.nextSub = r)), r.dep.subs = r;
  }
}
const yo = /* @__PURE__ */ new WeakMap(), Ns = Symbol(
  ""
), Ya = Symbol(
  ""
), ir = Symbol(
  ""
);
function Ae(r, e, n) {
  if (yn && oe) {
    let s = yo.get(r);
    s || yo.set(r, s = /* @__PURE__ */ new Map());
    let i = s.get(n);
    i || (s.set(n, i = new Ml()), i.map = s, i.key = n), i.track();
  }
}
function Nn(r, e, n, s, i, o) {
  const a = yo.get(r);
  if (!a) {
    sr++;
    return;
  }
  const l = (c) => {
    c && c.trigger();
  };
  if (Cl(), e === "clear")
    a.forEach(l);
  else {
    const c = Rt(r), u = c && Uo(n);
    if (c && n === "length") {
      const h = Number(s);
      a.forEach((f, m) => {
        (m === "length" || m === ir || !_n(m) && m >= h) && l(f);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && l(a.get(n)), u && l(a.get(ir)), e) {
        case "add":
          c ? u && l(a.get("length")) : (l(a.get(Ns)), ci(r) && l(a.get(Ya)));
          break;
        case "delete":
          c || (l(a.get(Ns)), ci(r) && l(a.get(Ya)));
          break;
        case "set":
          ci(r) && l(a.get(Ns));
          break;
      }
  }
  kl();
}
function Df(r, e) {
  const n = yo.get(r);
  return n && n.get(e);
}
function qs(r) {
  const e = Kt(r);
  return e === r ? e : (Ae(e, "iterate", ir), tn(r) ? e : e.map(xn));
}
function Ko(r) {
  return Ae(r = Kt(r), "iterate", ir), r;
}
function gs(r, e) {
  return es(r) ? Gn(r) ? vi(xn(e)) : vi(e) : xn(e);
}
const Af = {
  __proto__: null,
  [Symbol.iterator]() {
    return wa(this, Symbol.iterator, (r) => gs(this, r));
  },
  concat(...r) {
    return qs(this).concat(
      ...r.map((e) => Rt(e) ? qs(e) : e)
    );
  },
  entries() {
    return wa(this, "entries", (r) => (r[1] = gs(this, r[1]), r));
  },
  every(r, e) {
    return Rn(this, "every", r, e, void 0, arguments);
  },
  filter(r, e) {
    return Rn(
      this,
      "filter",
      r,
      e,
      (n) => n.map((s) => gs(this, s)),
      arguments
    );
  },
  find(r, e) {
    return Rn(
      this,
      "find",
      r,
      e,
      (n) => gs(this, n),
      arguments
    );
  },
  findIndex(r, e) {
    return Rn(this, "findIndex", r, e, void 0, arguments);
  },
  findLast(r, e) {
    return Rn(
      this,
      "findLast",
      r,
      e,
      (n) => gs(this, n),
      arguments
    );
  },
  findLastIndex(r, e) {
    return Rn(this, "findLastIndex", r, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(r, e) {
    return Rn(this, "forEach", r, e, void 0, arguments);
  },
  includes(...r) {
    return Sa(this, "includes", r);
  },
  indexOf(...r) {
    return Sa(this, "indexOf", r);
  },
  join(r) {
    return qs(this).join(r);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...r) {
    return Sa(this, "lastIndexOf", r);
  },
  map(r, e) {
    return Rn(this, "map", r, e, void 0, arguments);
  },
  pop() {
    return Ai(this, "pop");
  },
  push(...r) {
    return Ai(this, "push", r);
  },
  reduce(r, ...e) {
    return ac(this, "reduce", r, e);
  },
  reduceRight(r, ...e) {
    return ac(this, "reduceRight", r, e);
  },
  shift() {
    return Ai(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(r, e) {
    return Rn(this, "some", r, e, void 0, arguments);
  },
  splice(...r) {
    return Ai(this, "splice", r);
  },
  toReversed() {
    return qs(this).toReversed();
  },
  toSorted(r) {
    return qs(this).toSorted(r);
  },
  toSpliced(...r) {
    return qs(this).toSpliced(...r);
  },
  unshift(...r) {
    return Ai(this, "unshift", r);
  },
  values() {
    return wa(this, "values", (r) => gs(this, r));
  }
};
function wa(r, e, n) {
  const s = Ko(r), i = s[e]();
  return s !== r && !tn(r) && (i._next = i.next, i.next = () => {
    const o = i._next();
    return o.done || (o.value = n(o.value)), o;
  }), i;
}
const Ff = Array.prototype;
function Rn(r, e, n, s, i, o) {
  const a = Ko(r), l = a !== r && !tn(r), c = a[e];
  if (c !== Ff[e]) {
    const f = c.apply(r, o);
    return l ? xn(f) : f;
  }
  let u = n;
  a !== r && (l ? u = function(f, m) {
    return n.call(this, gs(r, f), m, r);
  } : n.length > 2 && (u = function(f, m) {
    return n.call(this, f, m, r);
  }));
  const h = c.call(a, u, s);
  return l && i ? i(h) : h;
}
function ac(r, e, n, s) {
  const i = Ko(r);
  let o = n;
  return i !== r && (tn(r) ? n.length > 3 && (o = function(a, l, c) {
    return n.call(this, a, l, c, r);
  }) : o = function(a, l, c) {
    return n.call(this, a, gs(r, l), c, r);
  }), i[e](o, ...s);
}
function Sa(r, e, n) {
  const s = Kt(r);
  Ae(s, "iterate", ir);
  const i = s[e](...n);
  return (i === -1 || i === !1) && qo(n[0]) ? (n[0] = Kt(n[0]), s[e](...n)) : i;
}
function Ai(r, e, n = []) {
  Qn(), Cl();
  const s = Kt(r)[e].apply(r, n);
  return kl(), ts(), s;
}
const If = /* @__PURE__ */ _l("__proto__,__v_isRef,__isVue"), oh = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(_n)
);
function Lf(r) {
  _n(r) || (r = String(r));
  const e = Kt(this);
  return Ae(e, "has", r), e.hasOwnProperty(r);
}
class ah {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, s) {
    if (n === "__v_skip") return e.__v_skip;
    const i = this._isReadonly, o = this._isShallow;
    if (n === "__v_isReactive")
      return !i;
    if (n === "__v_isReadonly")
      return i;
    if (n === "__v_isShallow")
      return o;
    if (n === "__v_raw")
      return s === (i ? o ? Hf : hh : o ? uh : ch).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(s) ? e : void 0;
    const a = Rt(e);
    if (!i) {
      let c;
      if (a && (c = Af[n]))
        return c;
      if (n === "hasOwnProperty")
        return Lf;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      ve(e) ? e : s
    );
    if ((_n(n) ? oh.has(n) : If(n)) || (i || Ae(e, "get", n), o))
      return l;
    if (ve(l)) {
      const c = a && Uo(n) ? l : l.value;
      return i && ie(c) ? qa(c) : c;
    }
    return ie(l) ? i ? qa(l) : Xs(l) : l;
  }
}
class lh extends ah {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, s, i) {
    let o = e[n];
    const a = Rt(e) && Uo(n);
    if (!this._isShallow) {
      const u = es(o);
      if (!tn(s) && !es(s) && (o = Kt(o), s = Kt(s)), !a && ve(o) && !ve(s))
        return u || (o.value = s), !0;
    }
    const l = a ? Number(n) < e.length : Zt(e, n), c = Reflect.set(
      e,
      n,
      s,
      ve(e) ? e : i
    );
    return e === Kt(i) && (l ? xs(s, o) && Nn(e, "set", n, s) : Nn(e, "add", n, s)), c;
  }
  deleteProperty(e, n) {
    const s = Zt(e, n);
    e[n];
    const i = Reflect.deleteProperty(e, n);
    return i && s && Nn(e, "delete", n, void 0), i;
  }
  has(e, n) {
    const s = Reflect.has(e, n);
    return (!_n(n) || !oh.has(n)) && Ae(e, "has", n), s;
  }
  ownKeys(e) {
    return Ae(
      e,
      "iterate",
      Rt(e) ? "length" : Ns
    ), Reflect.ownKeys(e);
  }
}
class Rf extends ah {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return !0;
  }
  deleteProperty(e, n) {
    return !0;
  }
}
const zf = /* @__PURE__ */ new lh(), jf = /* @__PURE__ */ new Rf(), Bf = /* @__PURE__ */ new lh(!0);
const Ka = (r) => r, Er = (r) => Reflect.getPrototypeOf(r);
function Vf(r, e, n) {
  return function(...s) {
    const i = this.__v_raw, o = Kt(i), a = ci(o), l = r === "entries" || r === Symbol.iterator && a, c = r === "keys" && a, u = i[r](...s), h = n ? Ka : e ? vi : xn;
    return !e && Ae(
      o,
      "iterate",
      c ? Ya : Ns
    ), {
      // iterator protocol
      next() {
        const { value: f, done: m } = u.next();
        return m ? { value: f, done: m } : {
          value: l ? [h(f[0]), h(f[1])] : h(f),
          done: m
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Pr(r) {
  return function(...e) {
    return r === "delete" ? !1 : r === "clear" ? void 0 : this;
  };
}
function $f(r, e) {
  const n = {
    get(i) {
      const o = this.__v_raw, a = Kt(o), l = Kt(i);
      r || (xs(i, l) && Ae(a, "get", i), Ae(a, "get", l));
      const { has: c } = Er(a), u = e ? Ka : r ? vi : xn;
      if (c.call(a, i))
        return u(o.get(i));
      if (c.call(a, l))
        return u(o.get(l));
      o !== a && o.get(i);
    },
    get size() {
      const i = this.__v_raw;
      return !r && Ae(Kt(i), "iterate", Ns), i.size;
    },
    has(i) {
      const o = this.__v_raw, a = Kt(o), l = Kt(i);
      return r || (xs(i, l) && Ae(a, "has", i), Ae(a, "has", l)), i === l ? o.has(i) : o.has(i) || o.has(l);
    },
    forEach(i, o) {
      const a = this, l = a.__v_raw, c = Kt(l), u = e ? Ka : r ? vi : xn;
      return !r && Ae(c, "iterate", Ns), l.forEach((h, f) => i.call(o, u(h), u(f), a));
    }
  };
  return Le(
    n,
    r ? {
      add: Pr("add"),
      set: Pr("set"),
      delete: Pr("delete"),
      clear: Pr("clear")
    } : {
      add(i) {
        !e && !tn(i) && !es(i) && (i = Kt(i));
        const o = Kt(this);
        return Er(o).has.call(o, i) || (o.add(i), Nn(o, "add", i, i)), this;
      },
      set(i, o) {
        !e && !tn(o) && !es(o) && (o = Kt(o));
        const a = Kt(this), { has: l, get: c } = Er(a);
        let u = l.call(a, i);
        u || (i = Kt(i), u = l.call(a, i));
        const h = c.call(a, i);
        return a.set(i, o), u ? xs(o, h) && Nn(a, "set", i, o) : Nn(a, "add", i, o), this;
      },
      delete(i) {
        const o = Kt(this), { has: a, get: l } = Er(o);
        let c = a.call(o, i);
        c || (i = Kt(i), c = a.call(o, i)), l && l.call(o, i);
        const u = o.delete(i);
        return c && Nn(o, "delete", i, void 0), u;
      },
      clear() {
        const i = Kt(this), o = i.size !== 0, a = i.clear();
        return o && Nn(
          i,
          "clear",
          void 0,
          void 0
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((i) => {
    n[i] = Vf(i, r, e);
  }), n;
}
function Ol(r, e) {
  const n = $f(r, e);
  return (s, i, o) => i === "__v_isReactive" ? !r : i === "__v_isReadonly" ? r : i === "__v_raw" ? s : Reflect.get(
    Zt(n, i) && i in s ? n : s,
    i,
    o
  );
}
const Nf = {
  get: /* @__PURE__ */ Ol(!1, !1)
}, Wf = {
  get: /* @__PURE__ */ Ol(!1, !0)
}, Uf = {
  get: /* @__PURE__ */ Ol(!0, !1)
};
const ch = /* @__PURE__ */ new WeakMap(), uh = /* @__PURE__ */ new WeakMap(), hh = /* @__PURE__ */ new WeakMap(), Hf = /* @__PURE__ */ new WeakMap();
function Xf(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Gf(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : Xf(yf(r));
}
function Xs(r) {
  return es(r) ? r : El(
    r,
    !1,
    zf,
    Nf,
    ch
  );
}
function Yf(r) {
  return El(
    r,
    !1,
    Bf,
    Wf,
    uh
  );
}
function qa(r) {
  return El(
    r,
    !0,
    jf,
    Uf,
    hh
  );
}
function El(r, e, n, s, i) {
  if (!ie(r) || r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const o = Gf(r);
  if (o === 0)
    return r;
  const a = i.get(r);
  if (a)
    return a;
  const l = new Proxy(
    r,
    o === 2 ? s : n
  );
  return i.set(r, l), l;
}
function Gn(r) {
  return es(r) ? Gn(r.__v_raw) : !!(r && r.__v_isReactive);
}
function es(r) {
  return !!(r && r.__v_isReadonly);
}
function tn(r) {
  return !!(r && r.__v_isShallow);
}
function qo(r) {
  return r ? !!r.__v_raw : !1;
}
function Kt(r) {
  const e = r && r.__v_raw;
  return e ? Kt(e) : r;
}
function ui(r) {
  return !Zt(r, "__v_skip") && Object.isExtensible(r) && Hu(r, "__v_skip", !0), r;
}
const xn = (r) => ie(r) ? Xs(r) : r, vi = (r) => ie(r) ? qa(r) : r;
function ve(r) {
  return r ? r.__v_isRef === !0 : !1;
}
function ut(r) {
  return Kf(r, !1);
}
function Kf(r, e) {
  return ve(r) ? r : new qf(r, e);
}
class qf {
  constructor(e, n) {
    this.dep = new Ml(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : Kt(e), this._value = n ? e : xn(e), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, s = this.__v_isShallow || tn(e) || es(e);
    e = s ? e : Kt(e), xs(e, n) && (this._rawValue = e, this._value = s ? e : xn(e), this.dep.trigger());
  }
}
function At(r) {
  return ve(r) ? r.value : r;
}
const Zf = {
  get: (r, e, n) => e === "__v_raw" ? r : At(Reflect.get(r, e, n)),
  set: (r, e, n, s) => {
    const i = r[e];
    return ve(i) && !ve(n) ? (i.value = n, !0) : Reflect.set(r, e, n, s);
  }
};
function dh(r) {
  return Gn(r) ? r : new Proxy(r, Zf);
}
function Jf(r) {
  const e = Rt(r) ? new Array(r.length) : {};
  for (const n in r)
    e[n] = tp(r, n);
  return e;
}
class Qf {
  constructor(e, n, s) {
    this._object = e, this._key = n, this._defaultValue = s, this.__v_isRef = !0, this._value = void 0, this._raw = Kt(e);
    let i = !0, o = e;
    if (!Rt(e) || !Uo(String(n)))
      do
        i = !qo(o) || tn(o);
      while (i && (o = o.__v_raw));
    this._shallow = i;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = At(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && ve(this._raw[this._key])) {
      const n = this._object[this._key];
      if (ve(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return Df(this._raw, this._key);
  }
}
function tp(r, e, n) {
  return new Qf(r, e, n);
}
class ep {
  constructor(e, n, s) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new Ml(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = sr - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    oe !== this)
      return th(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return sh(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function np(r, e, n = !1) {
  let s, i;
  return $t(r) ? s = r : (s = r.get, i = r.set), new ep(s, i, n);
}
const Dr = {}, bo = /* @__PURE__ */ new WeakMap();
let Is;
function sp(r, e = !1, n = Is) {
  if (n) {
    let s = bo.get(n);
    s || bo.set(n, s = []), s.push(r);
  }
}
function ip(r, e, n = se) {
  const { immediate: s, deep: i, once: o, scheduler: a, augmentJob: l, call: c } = n, u = (k) => i ? k : tn(k) || i === !1 || i === 0 ? Wn(k, 1) : Wn(k);
  let h, f, m, p, y = !1, v = !1;
  if (ve(r) ? (f = () => r.value, y = tn(r)) : Gn(r) ? (f = () => u(r), y = !0) : Rt(r) ? (v = !0, y = r.some((k) => Gn(k) || tn(k)), f = () => r.map((k) => {
    if (ve(k))
      return k.value;
    if (Gn(k))
      return u(k);
    if ($t(k))
      return c ? c(k, 2) : k();
  })) : $t(r) ? e ? f = c ? () => c(r, 2) : r : f = () => {
    if (m) {
      Qn();
      try {
        m();
      } finally {
        ts();
      }
    }
    const k = Is;
    Is = h;
    try {
      return c ? c(r, 3, [p]) : r(p);
    } finally {
      Is = k;
    }
  } : f = Dn, e && i) {
    const k = f, w = i === !0 ? 1 / 0 : i;
    f = () => Wn(k(), w);
  }
  const _ = Zu(), g = () => {
    h.stop(), _ && _.active && wl(_.effects, h);
  };
  if (o && e) {
    const k = e;
    e = (...w) => {
      k(...w), g();
    };
  }
  let C = v ? new Array(r.length).fill(Dr) : Dr;
  const x = (k) => {
    if (!(!(h.flags & 1) || !h.dirty && !k))
      if (e) {
        const w = h.run();
        if (i || y || (v ? w.some((T, P) => xs(T, C[P])) : xs(w, C))) {
          m && m();
          const T = Is;
          Is = h;
          try {
            const P = [
              w,
              // pass undefined as the old value when it's changed for the first time
              C === Dr ? void 0 : v && C[0] === Dr ? [] : C,
              p
            ];
            C = w, c ? c(e, 3, P) : (
              // @ts-expect-error
              e(...P)
            );
          } finally {
            Is = T;
          }
        }
      } else
        h.run();
  };
  return l && l(x), h = new Ju(f), h.scheduler = a ? () => a(x, !1) : x, p = (k) => sp(k, !1, h), m = h.onStop = () => {
    const k = bo.get(h);
    if (k) {
      if (c)
        c(k, 4);
      else
        for (const w of k) w();
      bo.delete(h);
    }
  }, e ? s ? x(!0) : C = h.run() : a ? a(x.bind(null, !0), !0) : h.run(), g.pause = h.pause.bind(h), g.resume = h.resume.bind(h), g.stop = g, g;
}
function Wn(r, e = 1 / 0, n) {
  if (e <= 0 || !ie(r) || r.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(r) || 0) >= e))
    return r;
  if (n.set(r, e), e--, ve(r))
    Wn(r.value, e, n);
  else if (Rt(r))
    for (let s = 0; s < r.length; s++)
      Wn(r[s], e, n);
  else if (Si(r) || ci(r))
    r.forEach((s) => {
      Wn(s, e, n);
    });
  else if (Uu(r)) {
    for (const s in r)
      Wn(r[s], e, n);
    for (const s of Object.getOwnPropertySymbols(r))
      Object.prototype.propertyIsEnumerable.call(r, s) && Wn(r[s], e, n);
  }
  return r;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function yr(r, e, n, s) {
  try {
    return s ? r(...s) : r();
  } catch (i) {
    Zo(i, e, n);
  }
}
function An(r, e, n, s) {
  if ($t(r)) {
    const i = yr(r, e, n, s);
    return i && Nu(i) && i.catch((o) => {
      Zo(o, e, n);
    }), i;
  }
  if (Rt(r)) {
    const i = [];
    for (let o = 0; o < r.length; o++)
      i.push(An(r[o], e, n, s));
    return i;
  }
}
function Zo(r, e, n, s = !0) {
  const i = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: a } = e && e.appContext.config || se;
  if (e) {
    let l = e.parent;
    const c = e.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const h = l.ec;
      if (h) {
        for (let f = 0; f < h.length; f++)
          if (h[f](r, c, u) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      Qn(), yr(o, null, 10, [
        r,
        c,
        u
      ]), ts();
      return;
    }
  }
  rp(r, n, i, s, a);
}
function rp(r, e, n, s = !0, i = !1) {
  if (i)
    throw r;
  console.error(r);
}
const Be = [];
let Tn = -1;
const hi = [];
let vs = null, ei = 0;
const fh = /* @__PURE__ */ Promise.resolve();
let _o = null;
function ws(r) {
  const e = _o || fh;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function op(r) {
  let e = Tn + 1, n = Be.length;
  for (; e < n; ) {
    const s = e + n >>> 1, i = Be[s], o = rr(i);
    o < r || o === r && i.flags & 2 ? e = s + 1 : n = s;
  }
  return e;
}
function Pl(r) {
  if (!(r.flags & 1)) {
    const e = rr(r), n = Be[Be.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(r.flags & 2) && e >= rr(n) ? Be.push(r) : Be.splice(op(e), 0, r), r.flags |= 1, ph();
  }
}
function ph() {
  _o || (_o = fh.then(gh));
}
function ap(r) {
  Rt(r) ? hi.push(...r) : vs && r.id === -1 ? vs.splice(ei + 1, 0, r) : r.flags & 1 || (hi.push(r), r.flags |= 1), ph();
}
function lc(r, e, n = Tn + 1) {
  for (; n < Be.length; n++) {
    const s = Be[n];
    if (s && s.flags & 2) {
      if (r && s.id !== r.uid)
        continue;
      Be.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2);
    }
  }
}
function mh(r) {
  if (hi.length) {
    const e = [...new Set(hi)].sort(
      (n, s) => rr(n) - rr(s)
    );
    if (hi.length = 0, vs) {
      vs.push(...e);
      return;
    }
    for (vs = e, ei = 0; ei < vs.length; ei++) {
      const n = vs[ei];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    vs = null, ei = 0;
  }
}
const rr = (r) => r.id == null ? r.flags & 2 ? -1 : 1 / 0 : r.id;
function gh(r) {
  try {
    for (Tn = 0; Tn < Be.length; Tn++) {
      const e = Be[Tn];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), yr(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; Tn < Be.length; Tn++) {
      const e = Be[Tn];
      e && (e.flags &= -2);
    }
    Tn = -1, Be.length = 0, mh(), _o = null, (Be.length || hi.length) && gh();
  }
}
let Ee = null, vh = null;
function xo(r) {
  const e = Ee;
  return Ee = r, vh = r && r.type.__scopeId || null, e;
}
function un(r, e = Ee, n) {
  if (!e || r._n)
    return r;
  const s = (...i) => {
    s._d && Co(-1);
    const o = xo(e);
    let a;
    try {
      a = r(...i);
    } finally {
      xo(o), s._d && Co(1);
    }
    return a;
  };
  return s._n = !0, s._c = !0, s._d = !0, s;
}
function Wt(r, e) {
  if (Ee === null)
    return r;
  const n = na(Ee), s = r.dirs || (r.dirs = []);
  for (let i = 0; i < e.length; i++) {
    let [o, a, l, c = se] = e[i];
    o && ($t(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Wn(a), s.push({
      dir: o,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: c
    }));
  }
  return r;
}
function Es(r, e, n, s) {
  const i = r.dirs, o = e && e.dirs;
  for (let a = 0; a < i.length; a++) {
    const l = i[a];
    o && (l.oldValue = o[a].value);
    let c = l.dir[s];
    c && (Qn(), An(c, n, 8, [
      r.el,
      l,
      r,
      e
    ]), ts());
  }
}
const lp = Symbol("_vte"), cp = (r) => r.__isTeleport, up = Symbol("_leaveCb");
function Dl(r, e) {
  r.shapeFlag & 6 && r.component ? (r.transition = e, Dl(r.component.subTree, e)) : r.shapeFlag & 128 ? (r.ssContent.transition = e.clone(r.ssContent), r.ssFallback.transition = e.clone(r.ssFallback)) : r.transition = e;
}
// @__NO_SIDE_EFFECTS__
function ye(r, e) {
  return $t(r) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Le({ name: r.name }, e, { setup: r })
  ) : r;
}
function yh(r) {
  r.ids = [r.ids[0] + r.ids[2]++ + "-", 0, 0];
}
const wo = /* @__PURE__ */ new WeakMap();
function Yi(r, e, n, s, i = !1) {
  if (Rt(r)) {
    r.forEach(
      (y, v) => Yi(
        y,
        e && (Rt(e) ? e[v] : e),
        n,
        s,
        i
      )
    );
    return;
  }
  if (di(s) && !i) {
    s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && Yi(r, e, n, s.component.subTree);
    return;
  }
  const o = s.shapeFlag & 4 ? na(s.component) : s.el, a = i ? null : o, { i: l, r: c } = r, u = e && e.r, h = l.refs === se ? l.refs = {} : l.refs, f = l.setupState, m = Kt(f), p = f === se ? $u : (y) => Zt(m, y);
  if (u != null && u !== c) {
    if (cc(e), xe(u))
      h[u] = null, p(u) && (f[u] = null);
    else if (ve(u)) {
      u.value = null;
      const y = e;
      y.k && (h[y.k] = null);
    }
  }
  if ($t(c))
    yr(c, l, 12, [a, h]);
  else {
    const y = xe(c), v = ve(c);
    if (y || v) {
      const _ = () => {
        if (r.f) {
          const g = y ? p(c) ? f[c] : h[c] : c.value;
          if (i)
            Rt(g) && wl(g, o);
          else if (Rt(g))
            g.includes(o) || g.push(o);
          else if (y)
            h[c] = [o], p(c) && (f[c] = h[c]);
          else {
            const C = [o];
            c.value = C, r.k && (h[r.k] = C);
          }
        } else y ? (h[c] = a, p(c) && (f[c] = a)) : v && (c.value = a, r.k && (h[r.k] = a));
      };
      if (a) {
        const g = () => {
          _(), wo.delete(r);
        };
        g.id = -1, wo.set(r, g), Je(g, n);
      } else
        cc(r), _();
    }
  }
}
function cc(r) {
  const e = wo.get(r);
  e && (e.flags |= 8, wo.delete(r));
}
Yo().requestIdleCallback;
Yo().cancelIdleCallback;
const di = (r) => !!r.type.__asyncLoader, bh = (r) => r.type.__isKeepAlive;
function hp(r, e) {
  _h(r, "a", e);
}
function dp(r, e) {
  _h(r, "da", e);
}
function _h(r, e, n = Fe) {
  const s = r.__wdc || (r.__wdc = () => {
    let i = n;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return r();
  });
  if (Jo(e, s, n), n) {
    let i = n.parent;
    for (; i && i.parent; )
      bh(i.parent.vnode) && fp(s, e, n, i), i = i.parent;
  }
}
function fp(r, e, n, s) {
  const i = Jo(
    e,
    r,
    s,
    !0
    /* prepend */
  );
  wn(() => {
    wl(s[e], i);
  }, n);
}
function Jo(r, e, n = Fe, s = !1) {
  if (n) {
    const i = n[r] || (n[r] = []), o = e.__weh || (e.__weh = (...a) => {
      Qn();
      const l = br(n), c = An(e, n, r, a);
      return l(), ts(), c;
    });
    return s ? i.unshift(o) : i.push(o), o;
  }
}
const as = (r) => (e, n = Fe) => {
  (!lr || r === "sp") && Jo(r, (...s) => e(...s), n);
}, pp = as("bm"), Ne = as("m"), mp = as(
  "bu"
), gp = as("u"), Al = as(
  "bum"
), wn = as("um"), vp = as(
  "sp"
), yp = as("rtg"), bp = as("rtc");
function _p(r, e = Fe) {
  Jo("ec", r, e);
}
const xp = "components", xh = Symbol.for("v-ndc");
function wh(r) {
  return xe(r) ? wp(xp, r, !1) || r : r || xh;
}
function wp(r, e, n = !0, s = !1) {
  const i = Ee || Fe;
  if (i) {
    const o = i.type;
    {
      const l = dm(
        o,
        !1
      );
      if (l && (l === e || l === on(e) || l === Xo(on(e))))
        return o;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      uc(i[r] || o[r], e) || // global registration
      uc(i.appContext[r], e)
    );
    return !a && s ? o : a;
  }
}
function uc(r, e) {
  return r && (r[e] || r[on(e)] || r[Xo(on(e))]);
}
function jt(r, e, n, s) {
  let i;
  const o = n, a = Rt(r);
  if (a || xe(r)) {
    const l = a && Gn(r);
    let c = !1, u = !1;
    l && (c = !tn(r), u = es(r), r = Ko(r)), i = new Array(r.length);
    for (let h = 0, f = r.length; h < f; h++)
      i[h] = e(
        c ? u ? vi(xn(r[h])) : xn(r[h]) : r[h],
        h,
        void 0,
        o
      );
  } else if (typeof r == "number") {
    i = new Array(r);
    for (let l = 0; l < r; l++)
      i[l] = e(l + 1, l, void 0, o);
  } else if (ie(r))
    if (r[Symbol.iterator])
      i = Array.from(
        r,
        (l, c) => e(l, c, void 0, o)
      );
    else {
      const l = Object.keys(r);
      i = new Array(l.length);
      for (let c = 0, u = l.length; c < u; c++) {
        const h = l[c];
        i[c] = e(r[h], h, c, o);
      }
    }
  else
    i = [];
  return i;
}
function Sp(r, e, n = {}, s, i) {
  if (Ee.ce || Ee.parent && di(Ee.parent) && Ee.parent.ce) {
    const u = Object.keys(n).length > 0;
    return H(), ce(
      Dt,
      null,
      [Pt("slot", n, s)],
      u ? -2 : 64
    );
  }
  let o = r[e];
  o && o._c && (o._d = !1), H();
  const a = o && Sh(o(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, c = ce(
    Dt,
    {
      key: (l && !_n(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && s ? "_fb" : "")
    },
    a || [],
    a && r._ === 1 ? 64 : -2
  );
  return c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), o && o._c && (o._d = !0), c;
}
function Sh(r) {
  return r.some((e) => ar(e) ? !(e.type === ns || e.type === Dt && !Sh(e.children)) : !0) ? r : null;
}
const Za = (r) => r ? Wh(r) ? na(r) : Za(r.parent) : null, Ki = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Le(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => r.props,
    $attrs: (r) => r.attrs,
    $slots: (r) => r.slots,
    $refs: (r) => r.refs,
    $parent: (r) => Za(r.parent),
    $root: (r) => Za(r.root),
    $host: (r) => r.ce,
    $emit: (r) => r.emit,
    $options: (r) => kh(r),
    $forceUpdate: (r) => r.f || (r.f = () => {
      Pl(r.update);
    }),
    $nextTick: (r) => r.n || (r.n = ws.bind(r.proxy)),
    $watch: (r) => zp.bind(r)
  })
), Ca = (r, e) => r !== se && !r.__isScriptSetup && Zt(r, e), Cp = {
  get({ _: r }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: s, data: i, props: o, accessCache: a, type: l, appContext: c } = r;
    if (e[0] !== "$") {
      const m = a[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return s[e];
          case 2:
            return i[e];
          case 4:
            return n[e];
          case 3:
            return o[e];
        }
      else {
        if (Ca(s, e))
          return a[e] = 1, s[e];
        if (i !== se && Zt(i, e))
          return a[e] = 2, i[e];
        if (Zt(o, e))
          return a[e] = 3, o[e];
        if (n !== se && Zt(n, e))
          return a[e] = 4, n[e];
        Ja && (a[e] = 0);
      }
    }
    const u = Ki[e];
    let h, f;
    if (u)
      return e === "$attrs" && Ae(r.attrs, "get", ""), u(r);
    if (
      // css module (injected by vue-loader)
      (h = l.__cssModules) && (h = h[e])
    )
      return h;
    if (n !== se && Zt(n, e))
      return a[e] = 4, n[e];
    if (
      // global properties
      f = c.config.globalProperties, Zt(f, e)
    )
      return f[e];
  },
  set({ _: r }, e, n) {
    const { data: s, setupState: i, ctx: o } = r;
    return Ca(i, e) ? (i[e] = n, !0) : s !== se && Zt(s, e) ? (s[e] = n, !0) : Zt(r.props, e) || e[0] === "$" && e.slice(1) in r ? !1 : (o[e] = n, !0);
  },
  has({
    _: { data: r, setupState: e, accessCache: n, ctx: s, appContext: i, props: o, type: a }
  }, l) {
    let c;
    return !!(n[l] || r !== se && l[0] !== "$" && Zt(r, l) || Ca(e, l) || Zt(o, l) || Zt(s, l) || Zt(Ki, l) || Zt(i.config.globalProperties, l) || (c = a.__cssModules) && c[l]);
  },
  defineProperty(r, e, n) {
    return n.get != null ? r._.accessCache[e] = 0 : Zt(n, "value") && this.set(r, e, n.value, null), Reflect.defineProperty(r, e, n);
  }
};
function kp() {
  return Tp().slots;
}
function Tp(r) {
  const e = ea();
  return e.setupContext || (e.setupContext = Hh(e));
}
function hc(r) {
  return Rt(r) ? r.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : r;
}
let Ja = !0;
function Mp(r) {
  const e = kh(r), n = r.proxy, s = r.ctx;
  Ja = !1, e.beforeCreate && dc(e.beforeCreate, r, "bc");
  const {
    // state
    data: i,
    computed: o,
    methods: a,
    watch: l,
    provide: c,
    inject: u,
    // lifecycle
    created: h,
    beforeMount: f,
    mounted: m,
    beforeUpdate: p,
    updated: y,
    activated: v,
    deactivated: _,
    beforeDestroy: g,
    beforeUnmount: C,
    destroyed: x,
    unmounted: k,
    render: w,
    renderTracked: T,
    renderTriggered: P,
    errorCaptured: z,
    serverPrefetch: j,
    // public API
    expose: ot,
    inheritAttrs: vt,
    // assets
    components: L,
    directives: Y,
    filters: M
  } = e;
  if (u && Op(u, s, null), a)
    for (const U in a) {
      const W = a[U];
      $t(W) && (s[U] = W.bind(n));
    }
  if (i) {
    const U = i.call(n, n);
    ie(U) && (r.data = Xs(U));
  }
  if (Ja = !0, o)
    for (const U in o) {
      const W = o[U], Z = $t(W) ? W.bind(n, n) : $t(W.get) ? W.get.bind(n, n) : Dn, yt = !$t(W) && $t(W.set) ? W.set.bind(n) : Dn, Q = St({
        get: Z,
        set: yt
      });
      Object.defineProperty(s, U, {
        enumerable: !0,
        configurable: !0,
        get: () => Q.value,
        set: (at) => Q.value = at
      });
    }
  if (l)
    for (const U in l)
      Ch(l[U], s, n, U);
  if (c) {
    const U = $t(c) ? c.call(n) : c;
    Reflect.ownKeys(U).forEach((W) => {
      ps(W, U[W]);
    });
  }
  h && dc(h, r, "c");
  function tt(U, W) {
    Rt(W) ? W.forEach((Z) => U(Z.bind(n))) : W && U(W.bind(n));
  }
  if (tt(pp, f), tt(Ne, m), tt(mp, p), tt(gp, y), tt(hp, v), tt(dp, _), tt(_p, z), tt(bp, T), tt(yp, P), tt(Al, C), tt(wn, k), tt(vp, j), Rt(ot))
    if (ot.length) {
      const U = r.exposed || (r.exposed = {});
      ot.forEach((W) => {
        Object.defineProperty(U, W, {
          get: () => n[W],
          set: (Z) => n[W] = Z,
          enumerable: !0
        });
      });
    } else r.exposed || (r.exposed = {});
  w && r.render === Dn && (r.render = w), vt != null && (r.inheritAttrs = vt), L && (r.components = L), Y && (r.directives = Y), j && yh(r);
}
function Op(r, e, n = Dn) {
  Rt(r) && (r = Qa(r));
  for (const s in r) {
    const i = r[s];
    let o;
    ie(i) ? "default" in i ? o = pn(
      i.from || s,
      i.default,
      !0
    ) : o = pn(i.from || s) : o = pn(i), ve(o) ? Object.defineProperty(e, s, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (a) => o.value = a
    }) : e[s] = o;
  }
}
function dc(r, e, n) {
  An(
    Rt(r) ? r.map((s) => s.bind(e.proxy)) : r.bind(e.proxy),
    e,
    n
  );
}
function Ch(r, e, n, s) {
  let i = s.includes(".") ? Oh(n, s) : () => n[s];
  if (xe(r)) {
    const o = e[r];
    $t(o) && ae(i, o);
  } else if ($t(r))
    ae(i, r.bind(n));
  else if (ie(r))
    if (Rt(r))
      r.forEach((o) => Ch(o, e, n, s));
    else {
      const o = $t(r.handler) ? r.handler.bind(n) : e[r.handler];
      $t(o) && ae(i, o, r);
    }
}
function kh(r) {
  const e = r.type, { mixins: n, extends: s } = e, {
    mixins: i,
    optionsCache: o,
    config: { optionMergeStrategies: a }
  } = r.appContext, l = o.get(e);
  let c;
  return l ? c = l : !i.length && !n && !s ? c = e : (c = {}, i.length && i.forEach(
    (u) => So(c, u, a, !0)
  ), So(c, e, a)), ie(e) && o.set(e, c), c;
}
function So(r, e, n, s = !1) {
  const { mixins: i, extends: o } = e;
  o && So(r, o, n, !0), i && i.forEach(
    (a) => So(r, a, n, !0)
  );
  for (const a in e)
    if (!(s && a === "expose")) {
      const l = Ep[a] || n && n[a];
      r[a] = l ? l(r[a], e[a]) : e[a];
    }
  return r;
}
const Ep = {
  data: fc,
  props: pc,
  emits: pc,
  // objects
  methods: Wi,
  computed: Wi,
  // lifecycle
  beforeCreate: ze,
  created: ze,
  beforeMount: ze,
  mounted: ze,
  beforeUpdate: ze,
  updated: ze,
  beforeDestroy: ze,
  beforeUnmount: ze,
  destroyed: ze,
  unmounted: ze,
  activated: ze,
  deactivated: ze,
  errorCaptured: ze,
  serverPrefetch: ze,
  // assets
  components: Wi,
  directives: Wi,
  // watch
  watch: Dp,
  // provide / inject
  provide: fc,
  inject: Pp
};
function fc(r, e) {
  return e ? r ? function() {
    return Le(
      $t(r) ? r.call(this, this) : r,
      $t(e) ? e.call(this, this) : e
    );
  } : e : r;
}
function Pp(r, e) {
  return Wi(Qa(r), Qa(e));
}
function Qa(r) {
  if (Rt(r)) {
    const e = {};
    for (let n = 0; n < r.length; n++)
      e[r[n]] = r[n];
    return e;
  }
  return r;
}
function ze(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function Wi(r, e) {
  return r ? Le(/* @__PURE__ */ Object.create(null), r, e) : e;
}
function pc(r, e) {
  return r ? Rt(r) && Rt(e) ? [.../* @__PURE__ */ new Set([...r, ...e])] : Le(
    /* @__PURE__ */ Object.create(null),
    hc(r),
    hc(e ?? {})
  ) : e;
}
function Dp(r, e) {
  if (!r) return e;
  if (!e) return r;
  const n = Le(/* @__PURE__ */ Object.create(null), r);
  for (const s in e)
    n[s] = ze(r[s], e[s]);
  return n;
}
function Th() {
  return {
    app: null,
    config: {
      isNativeTag: $u,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Ap = 0;
function Fp(r, e) {
  return function(s, i = null) {
    $t(s) || (s = Le({}, s)), i != null && !ie(i) && (i = null);
    const o = Th(), a = /* @__PURE__ */ new WeakSet(), l = [];
    let c = !1;
    const u = o.app = {
      _uid: Ap++,
      _component: s,
      _props: i,
      _container: null,
      _context: o,
      _instance: null,
      version: mm,
      get config() {
        return o.config;
      },
      set config(h) {
      },
      use(h, ...f) {
        return a.has(h) || (h && $t(h.install) ? (a.add(h), h.install(u, ...f)) : $t(h) && (a.add(h), h(u, ...f))), u;
      },
      mixin(h) {
        return o.mixins.includes(h) || o.mixins.push(h), u;
      },
      component(h, f) {
        return f ? (o.components[h] = f, u) : o.components[h];
      },
      directive(h, f) {
        return f ? (o.directives[h] = f, u) : o.directives[h];
      },
      mount(h, f, m) {
        if (!c) {
          const p = u._ceVNode || Pt(s, i);
          return p.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), r(p, h, m), c = !0, u._container = h, h.__vue_app__ = u, na(p.component);
        }
      },
      onUnmount(h) {
        l.push(h);
      },
      unmount() {
        c && (An(
          l,
          u._instance,
          16
        ), r(null, u._container), delete u._container.__vue_app__);
      },
      provide(h, f) {
        return o.provides[h] = f, u;
      },
      runWithContext(h) {
        const f = Ws;
        Ws = u;
        try {
          return h();
        } finally {
          Ws = f;
        }
      }
    };
    return u;
  };
}
let Ws = null;
function ps(r, e) {
  if (Fe) {
    let n = Fe.provides;
    const s = Fe.parent && Fe.parent.provides;
    s === n && (n = Fe.provides = Object.create(s)), n[r] = e;
  }
}
function pn(r, e, n = !1) {
  const s = ea();
  if (s || Ws) {
    let i = Ws ? Ws._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (i && r in i)
      return i[r];
    if (arguments.length > 1)
      return n && $t(e) ? e.call(s && s.proxy) : e;
  }
}
function Ip() {
  return !!(ea() || Ws);
}
const Lp = Symbol.for("v-scx"), Rp = () => pn(Lp);
function ae(r, e, n) {
  return Mh(r, e, n);
}
function Mh(r, e, n = se) {
  const { immediate: s, deep: i, flush: o, once: a } = n, l = Le({}, n), c = e && s || !e && o !== "post";
  let u;
  if (lr) {
    if (o === "sync") {
      const p = Rp();
      u = p.__watcherHandles || (p.__watcherHandles = []);
    } else if (!c) {
      const p = () => {
      };
      return p.stop = Dn, p.resume = Dn, p.pause = Dn, p;
    }
  }
  const h = Fe;
  l.call = (p, y, v) => An(p, h, y, v);
  let f = !1;
  o === "post" ? l.scheduler = (p) => {
    Je(p, h && h.suspense);
  } : o !== "sync" && (f = !0, l.scheduler = (p, y) => {
    y ? p() : Pl(p);
  }), l.augmentJob = (p) => {
    e && (p.flags |= 4), f && (p.flags |= 2, h && (p.id = h.uid, p.i = h));
  };
  const m = ip(r, e, l);
  return lr && (u ? u.push(m) : c && m()), m;
}
function zp(r, e, n) {
  const s = this.proxy, i = xe(r) ? r.includes(".") ? Oh(s, r) : () => s[r] : r.bind(s, s);
  let o;
  $t(e) ? o = e : (o = e.handler, n = e);
  const a = br(this), l = Mh(i, o.bind(s), n);
  return a(), l;
}
function Oh(r, e) {
  const n = e.split(".");
  return () => {
    let s = r;
    for (let i = 0; i < n.length && s; i++)
      s = s[n[i]];
    return s;
  };
}
const jp = (r, e) => e === "modelValue" || e === "model-value" ? r.modelModifiers : r[`${e}Modifiers`] || r[`${on(e)}Modifiers`] || r[`${ks(e)}Modifiers`];
function Bp(r, e, ...n) {
  if (r.isUnmounted) return;
  const s = r.vnode.props || se;
  let i = n;
  const o = e.startsWith("update:"), a = o && jp(s, e.slice(7));
  a && (a.trim && (i = n.map((h) => xe(h) ? h.trim() : h)), a.number && (i = n.map(Go)));
  let l, c = s[l = ba(e)] || // also try camelCase event handler (#2249)
  s[l = ba(on(e))];
  !c && o && (c = s[l = ba(ks(e))]), c && An(
    c,
    r,
    6,
    i
  );
  const u = s[l + "Once"];
  if (u) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[l])
      return;
    r.emitted[l] = !0, An(
      u,
      r,
      6,
      i
    );
  }
}
const Vp = /* @__PURE__ */ new WeakMap();
function Eh(r, e, n = !1) {
  const s = n ? Vp : e.emitsCache, i = s.get(r);
  if (i !== void 0)
    return i;
  const o = r.emits;
  let a = {}, l = !1;
  if (!$t(r)) {
    const c = (u) => {
      const h = Eh(u, e, !0);
      h && (l = !0, Le(a, h));
    };
    !n && e.mixins.length && e.mixins.forEach(c), r.extends && c(r.extends), r.mixins && r.mixins.forEach(c);
  }
  return !o && !l ? (ie(r) && s.set(r, null), null) : (Rt(o) ? o.forEach((c) => a[c] = null) : Le(a, o), ie(r) && s.set(r, a), a);
}
function Qo(r, e) {
  return !r || !Wo(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Zt(r, e[0].toLowerCase() + e.slice(1)) || Zt(r, ks(e)) || Zt(r, e));
}
function mc(r) {
  const {
    type: e,
    vnode: n,
    proxy: s,
    withProxy: i,
    propsOptions: [o],
    slots: a,
    attrs: l,
    emit: c,
    render: u,
    renderCache: h,
    props: f,
    data: m,
    setupState: p,
    ctx: y,
    inheritAttrs: v
  } = r, _ = xo(r);
  let g, C;
  try {
    if (n.shapeFlag & 4) {
      const k = i || s, w = k;
      g = Mn(
        u.call(
          w,
          k,
          h,
          f,
          p,
          m,
          y
        )
      ), C = l;
    } else {
      const k = e;
      g = Mn(
        k.length > 1 ? k(
          f,
          { attrs: l, slots: a, emit: c }
        ) : k(
          f,
          null
        )
      ), C = e.props ? l : $p(l);
    }
  } catch (k) {
    qi.length = 0, Zo(k, r, 1), g = Pt(ns);
  }
  let x = g;
  if (C && v !== !1) {
    const k = Object.keys(C), { shapeFlag: w } = x;
    k.length && w & 7 && (o && k.some(xl) && (C = Np(
      C,
      o
    )), x = yi(x, C, !1, !0));
  }
  return n.dirs && (x = yi(x, null, !1, !0), x.dirs = x.dirs ? x.dirs.concat(n.dirs) : n.dirs), n.transition && Dl(x, n.transition), g = x, xo(_), g;
}
const $p = (r) => {
  let e;
  for (const n in r)
    (n === "class" || n === "style" || Wo(n)) && ((e || (e = {}))[n] = r[n]);
  return e;
}, Np = (r, e) => {
  const n = {};
  for (const s in r)
    (!xl(s) || !(s.slice(9) in e)) && (n[s] = r[s]);
  return n;
};
function Wp(r, e, n) {
  const { props: s, children: i, component: o } = r, { props: a, children: l, patchFlag: c } = e, u = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && c >= 0) {
    if (c & 1024)
      return !0;
    if (c & 16)
      return s ? gc(s, a, u) : !!a;
    if (c & 8) {
      const h = e.dynamicProps;
      for (let f = 0; f < h.length; f++) {
        const m = h[f];
        if (a[m] !== s[m] && !Qo(u, m))
          return !0;
      }
    }
  } else
    return (i || l) && (!l || !l.$stable) ? !0 : s === a ? !1 : s ? a ? gc(s, a, u) : !0 : !!a;
  return !1;
}
function gc(r, e, n) {
  const s = Object.keys(e);
  if (s.length !== Object.keys(r).length)
    return !0;
  for (let i = 0; i < s.length; i++) {
    const o = s[i];
    if (e[o] !== r[o] && !Qo(n, o))
      return !0;
  }
  return !1;
}
function Up({ vnode: r, parent: e }, n) {
  for (; e; ) {
    const s = e.subTree;
    if (s.suspense && s.suspense.activeBranch === r && (s.el = r.el), s === r)
      (r = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const Ph = {}, Dh = () => Object.create(Ph), Ah = (r) => Object.getPrototypeOf(r) === Ph;
function Hp(r, e, n, s = !1) {
  const i = {}, o = Dh();
  r.propsDefaults = /* @__PURE__ */ Object.create(null), Fh(r, e, i, o);
  for (const a in r.propsOptions[0])
    a in i || (i[a] = void 0);
  n ? r.props = s ? i : Yf(i) : r.type.props ? r.props = i : r.props = o, r.attrs = o;
}
function Xp(r, e, n, s) {
  const {
    props: i,
    attrs: o,
    vnode: { patchFlag: a }
  } = r, l = Kt(i), [c] = r.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (s || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const h = r.vnode.dynamicProps;
      for (let f = 0; f < h.length; f++) {
        let m = h[f];
        if (Qo(r.emitsOptions, m))
          continue;
        const p = e[m];
        if (c)
          if (Zt(o, m))
            p !== o[m] && (o[m] = p, u = !0);
          else {
            const y = on(m);
            i[y] = tl(
              c,
              l,
              y,
              p,
              r,
              !1
            );
          }
        else
          p !== o[m] && (o[m] = p, u = !0);
      }
    }
  } else {
    Fh(r, e, i, o) && (u = !0);
    let h;
    for (const f in l)
      (!e || // for camelCase
      !Zt(e, f) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((h = ks(f)) === f || !Zt(e, h))) && (c ? n && // for camelCase
      (n[f] !== void 0 || // for kebab-case
      n[h] !== void 0) && (i[f] = tl(
        c,
        l,
        f,
        void 0,
        r,
        !0
      )) : delete i[f]);
    if (o !== l)
      for (const f in o)
        (!e || !Zt(e, f)) && (delete o[f], u = !0);
  }
  u && Nn(r.attrs, "set", "");
}
function Fh(r, e, n, s) {
  const [i, o] = r.propsOptions;
  let a = !1, l;
  if (e)
    for (let c in e) {
      if (Hi(c))
        continue;
      const u = e[c];
      let h;
      i && Zt(i, h = on(c)) ? !o || !o.includes(h) ? n[h] = u : (l || (l = {}))[h] = u : Qo(r.emitsOptions, c) || (!(c in s) || u !== s[c]) && (s[c] = u, a = !0);
    }
  if (o) {
    const c = Kt(n), u = l || se;
    for (let h = 0; h < o.length; h++) {
      const f = o[h];
      n[f] = tl(
        i,
        c,
        f,
        u[f],
        r,
        !Zt(u, f)
      );
    }
  }
  return a;
}
function tl(r, e, n, s, i, o) {
  const a = r[n];
  if (a != null) {
    const l = Zt(a, "default");
    if (l && s === void 0) {
      const c = a.default;
      if (a.type !== Function && !a.skipFactory && $t(c)) {
        const { propsDefaults: u } = i;
        if (n in u)
          s = u[n];
        else {
          const h = br(i);
          s = u[n] = c.call(
            null,
            e
          ), h();
        }
      } else
        s = c;
      i.ce && i.ce._setProp(n, s);
    }
    a[
      0
      /* shouldCast */
    ] && (o && !l ? s = !1 : a[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === ks(n)) && (s = !0));
  }
  return s;
}
const Gp = /* @__PURE__ */ new WeakMap();
function Ih(r, e, n = !1) {
  const s = n ? Gp : e.propsCache, i = s.get(r);
  if (i)
    return i;
  const o = r.props, a = {}, l = [];
  let c = !1;
  if (!$t(r)) {
    const h = (f) => {
      c = !0;
      const [m, p] = Ih(f, e, !0);
      Le(a, m), p && l.push(...p);
    };
    !n && e.mixins.length && e.mixins.forEach(h), r.extends && h(r.extends), r.mixins && r.mixins.forEach(h);
  }
  if (!o && !c)
    return ie(r) && s.set(r, li), li;
  if (Rt(o))
    for (let h = 0; h < o.length; h++) {
      const f = on(o[h]);
      vc(f) && (a[f] = se);
    }
  else if (o)
    for (const h in o) {
      const f = on(h);
      if (vc(f)) {
        const m = o[h], p = a[f] = Rt(m) || $t(m) ? { type: m } : Le({}, m), y = p.type;
        let v = !1, _ = !0;
        if (Rt(y))
          for (let g = 0; g < y.length; ++g) {
            const C = y[g], x = $t(C) && C.name;
            if (x === "Boolean") {
              v = !0;
              break;
            } else x === "String" && (_ = !1);
          }
        else
          v = $t(y) && y.name === "Boolean";
        p[
          0
          /* shouldCast */
        ] = v, p[
          1
          /* shouldCastTrue */
        ] = _, (v || Zt(p, "default")) && l.push(f);
      }
    }
  const u = [a, l];
  return ie(r) && s.set(r, u), u;
}
function vc(r) {
  return r[0] !== "$" && !Hi(r);
}
const Fl = (r) => r === "_" || r === "_ctx" || r === "$stable", Il = (r) => Rt(r) ? r.map(Mn) : [Mn(r)], Yp = (r, e, n) => {
  if (e._n)
    return e;
  const s = un((...i) => Il(e(...i)), n);
  return s._c = !1, s;
}, Lh = (r, e, n) => {
  const s = r._ctx;
  for (const i in r) {
    if (Fl(i)) continue;
    const o = r[i];
    if ($t(o))
      e[i] = Yp(i, o, s);
    else if (o != null) {
      const a = Il(o);
      e[i] = () => a;
    }
  }
}, Rh = (r, e) => {
  const n = Il(e);
  r.slots.default = () => n;
}, zh = (r, e, n) => {
  for (const s in e)
    (n || !Fl(s)) && (r[s] = e[s]);
}, Kp = (r, e, n) => {
  const s = r.slots = Dh();
  if (r.vnode.shapeFlag & 32) {
    const i = e._;
    i ? (zh(s, e, n), n && Hu(s, "_", i, !0)) : Lh(e, s);
  } else e && Rh(r, e);
}, qp = (r, e, n) => {
  const { vnode: s, slots: i } = r;
  let o = !0, a = se;
  if (s.shapeFlag & 32) {
    const l = e._;
    l ? n && l === 1 ? o = !1 : zh(i, e, n) : (o = !e.$stable, Lh(e, i)), a = e;
  } else e && (Rh(r, e), a = { default: 1 });
  if (o)
    for (const l in i)
      !Fl(l) && a[l] == null && delete i[l];
}, Je = em;
function Zp(r) {
  return Jp(r);
}
function Jp(r, e) {
  const n = Yo();
  n.__VUE__ = !0;
  const {
    insert: s,
    remove: i,
    patchProp: o,
    createElement: a,
    createText: l,
    createComment: c,
    setText: u,
    setElementText: h,
    parentNode: f,
    nextSibling: m,
    setScopeId: p = Dn,
    insertStaticContent: y
  } = r, v = (S, F, b, B = null, R = null, D = null, A = void 0, N = null, q = !!F.dynamicChildren) => {
    if (S === F)
      return;
    S && !Fi(S, F) && (B = lt(S), at(S, R, D, !0), S = null), F.patchFlag === -2 && (q = !1, F.dynamicChildren = null);
    const { type: J, ref: V, shapeFlag: $ } = F;
    switch (J) {
      case ta:
        _(S, F, b, B);
        break;
      case ns:
        g(S, F, b, B);
        break;
      case co:
        S == null && C(F, b, B, A);
        break;
      case Dt:
        L(
          S,
          F,
          b,
          B,
          R,
          D,
          A,
          N,
          q
        );
        break;
      default:
        $ & 1 ? w(
          S,
          F,
          b,
          B,
          R,
          D,
          A,
          N,
          q
        ) : $ & 6 ? Y(
          S,
          F,
          b,
          B,
          R,
          D,
          A,
          N,
          q
        ) : ($ & 64 || $ & 128) && J.process(
          S,
          F,
          b,
          B,
          R,
          D,
          A,
          N,
          q,
          E
        );
    }
    V != null && R ? Yi(V, S && S.ref, D, F || S, !F) : V == null && S && S.ref != null && Yi(S.ref, null, D, S, !0);
  }, _ = (S, F, b, B) => {
    if (S == null)
      s(
        F.el = l(F.children),
        b,
        B
      );
    else {
      const R = F.el = S.el;
      F.children !== S.children && u(R, F.children);
    }
  }, g = (S, F, b, B) => {
    S == null ? s(
      F.el = c(F.children || ""),
      b,
      B
    ) : F.el = S.el;
  }, C = (S, F, b, B) => {
    [S.el, S.anchor] = y(
      S.children,
      F,
      b,
      B,
      S.el,
      S.anchor
    );
  }, x = ({ el: S, anchor: F }, b, B) => {
    let R;
    for (; S && S !== F; )
      R = m(S), s(S, b, B), S = R;
    s(F, b, B);
  }, k = ({ el: S, anchor: F }) => {
    let b;
    for (; S && S !== F; )
      b = m(S), i(S), S = b;
    i(F);
  }, w = (S, F, b, B, R, D, A, N, q) => {
    if (F.type === "svg" ? A = "svg" : F.type === "math" && (A = "mathml"), S == null)
      T(
        F,
        b,
        B,
        R,
        D,
        A,
        N,
        q
      );
    else {
      const J = S.el && S.el._isVueCE ? S.el : null;
      try {
        J && J._beginPatch(), j(
          S,
          F,
          R,
          D,
          A,
          N,
          q
        );
      } finally {
        J && J._endPatch();
      }
    }
  }, T = (S, F, b, B, R, D, A, N) => {
    let q, J;
    const { props: V, shapeFlag: $, transition: rt, dirs: ft } = S;
    if (q = S.el = a(
      S.type,
      D,
      V && V.is,
      V
    ), $ & 8 ? h(q, S.children) : $ & 16 && z(
      S.children,
      q,
      null,
      B,
      R,
      ka(S, D),
      A,
      N
    ), ft && Es(S, null, B, "created"), P(q, S, S.scopeId, A, B), V) {
      for (const Ft in V)
        Ft !== "value" && !Hi(Ft) && o(q, Ft, null, V[Ft], D, B);
      "value" in V && o(q, "value", null, V.value, D), (J = V.onVnodeBeforeMount) && Sn(J, B, S);
    }
    ft && Es(S, null, B, "beforeMount");
    const bt = Qp(R, rt);
    bt && rt.beforeEnter(q), s(q, F, b), ((J = V && V.onVnodeMounted) || bt || ft) && Je(() => {
      J && Sn(J, B, S), bt && rt.enter(q), ft && Es(S, null, B, "mounted");
    }, R);
  }, P = (S, F, b, B, R) => {
    if (b && p(S, b), B)
      for (let D = 0; D < B.length; D++)
        p(S, B[D]);
    if (R) {
      let D = R.subTree;
      if (F === D || Vh(D.type) && (D.ssContent === F || D.ssFallback === F)) {
        const A = R.vnode;
        P(
          S,
          A,
          A.scopeId,
          A.slotScopeIds,
          R.parent
        );
      }
    }
  }, z = (S, F, b, B, R, D, A, N, q = 0) => {
    for (let J = q; J < S.length; J++) {
      const V = S[J] = N ? ys(S[J]) : Mn(S[J]);
      v(
        null,
        V,
        F,
        b,
        B,
        R,
        D,
        A,
        N
      );
    }
  }, j = (S, F, b, B, R, D, A) => {
    const N = F.el = S.el;
    let { patchFlag: q, dynamicChildren: J, dirs: V } = F;
    q |= S.patchFlag & 16;
    const $ = S.props || se, rt = F.props || se;
    let ft;
    if (b && Ps(b, !1), (ft = rt.onVnodeBeforeUpdate) && Sn(ft, b, F, S), V && Es(F, S, b, "beforeUpdate"), b && Ps(b, !0), ($.innerHTML && rt.innerHTML == null || $.textContent && rt.textContent == null) && h(N, ""), J ? ot(
      S.dynamicChildren,
      J,
      N,
      b,
      B,
      ka(F, R),
      D
    ) : A || W(
      S,
      F,
      N,
      null,
      b,
      B,
      ka(F, R),
      D,
      !1
    ), q > 0) {
      if (q & 16)
        vt(N, $, rt, b, R);
      else if (q & 2 && $.class !== rt.class && o(N, "class", null, rt.class, R), q & 4 && o(N, "style", $.style, rt.style, R), q & 8) {
        const bt = F.dynamicProps;
        for (let Ft = 0; Ft < bt.length; Ft++) {
          const Ot = bt[Ft], Xt = $[Ot], de = rt[Ot];
          (de !== Xt || Ot === "value") && o(N, Ot, Xt, de, R, b);
        }
      }
      q & 1 && S.children !== F.children && h(N, F.children);
    } else !A && J == null && vt(N, $, rt, b, R);
    ((ft = rt.onVnodeUpdated) || V) && Je(() => {
      ft && Sn(ft, b, F, S), V && Es(F, S, b, "updated");
    }, B);
  }, ot = (S, F, b, B, R, D, A) => {
    for (let N = 0; N < F.length; N++) {
      const q = S[N], J = F[N], V = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        q.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (q.type === Dt || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Fi(q, J) || // - In the case of a component, it could contain anything.
        q.shapeFlag & 198) ? f(q.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          b
        )
      );
      v(
        q,
        J,
        V,
        null,
        B,
        R,
        D,
        A,
        !0
      );
    }
  }, vt = (S, F, b, B, R) => {
    if (F !== b) {
      if (F !== se)
        for (const D in F)
          !Hi(D) && !(D in b) && o(
            S,
            D,
            F[D],
            null,
            R,
            B
          );
      for (const D in b) {
        if (Hi(D)) continue;
        const A = b[D], N = F[D];
        A !== N && D !== "value" && o(S, D, N, A, R, B);
      }
      "value" in b && o(S, "value", F.value, b.value, R);
    }
  }, L = (S, F, b, B, R, D, A, N, q) => {
    const J = F.el = S ? S.el : l(""), V = F.anchor = S ? S.anchor : l("");
    let { patchFlag: $, dynamicChildren: rt, slotScopeIds: ft } = F;
    ft && (N = N ? N.concat(ft) : ft), S == null ? (s(J, b, B), s(V, b, B), z(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      F.children || [],
      b,
      V,
      R,
      D,
      A,
      N,
      q
    )) : $ > 0 && $ & 64 && rt && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    S.dynamicChildren ? (ot(
      S.dynamicChildren,
      rt,
      b,
      R,
      D,
      A,
      N
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (F.key != null || R && F === R.subTree) && jh(
      S,
      F,
      !0
      /* shallow */
    )) : W(
      S,
      F,
      b,
      V,
      R,
      D,
      A,
      N,
      q
    );
  }, Y = (S, F, b, B, R, D, A, N, q) => {
    F.slotScopeIds = N, S == null ? F.shapeFlag & 512 ? R.ctx.activate(
      F,
      b,
      B,
      A,
      q
    ) : M(
      F,
      b,
      B,
      R,
      D,
      A,
      q
    ) : I(S, F, q);
  }, M = (S, F, b, B, R, D, A) => {
    const N = S.component = lm(
      S,
      B,
      R
    );
    if (bh(S) && (N.ctx.renderer = E), cm(N, !1, A), N.asyncDep) {
      if (R && R.registerDep(N, tt, A), !S.el) {
        const q = N.subTree = Pt(ns);
        g(null, q, F, b), S.placeholder = q.el;
      }
    } else
      tt(
        N,
        S,
        F,
        b,
        R,
        D,
        A
      );
  }, I = (S, F, b) => {
    const B = F.component = S.component;
    if (Wp(S, F, b))
      if (B.asyncDep && !B.asyncResolved) {
        U(B, F, b);
        return;
      } else
        B.next = F, B.update();
    else
      F.el = S.el, B.vnode = F;
  }, tt = (S, F, b, B, R, D, A) => {
    const N = () => {
      if (S.isMounted) {
        let { next: $, bu: rt, u: ft, parent: bt, vnode: Ft } = S;
        {
          const Ce = Bh(S);
          if (Ce) {
            $ && ($.el = Ft.el, U(S, $, A)), Ce.asyncDep.then(() => {
              S.isUnmounted || N();
            });
            return;
          }
        }
        let Ot = $, Xt;
        Ps(S, !1), $ ? ($.el = Ft.el, U(S, $, A)) : $ = Ft, rt && lo(rt), (Xt = $.props && $.props.onVnodeBeforeUpdate) && Sn(Xt, bt, $, Ft), Ps(S, !0);
        const de = mc(S), he = S.subTree;
        S.subTree = de, v(
          he,
          de,
          // parent may have changed if it's in a teleport
          f(he.el),
          // anchor may have changed if it's in a fragment
          lt(he),
          S,
          R,
          D
        ), $.el = de.el, Ot === null && Up(S, de.el), ft && Je(ft, R), (Xt = $.props && $.props.onVnodeUpdated) && Je(
          () => Sn(Xt, bt, $, Ft),
          R
        );
      } else {
        let $;
        const { el: rt, props: ft } = F, { bm: bt, m: Ft, parent: Ot, root: Xt, type: de } = S, he = di(F);
        Ps(S, !1), bt && lo(bt), !he && ($ = ft && ft.onVnodeBeforeMount) && Sn($, Ot, F), Ps(S, !0);
        {
          Xt.ce && // @ts-expect-error _def is private
          Xt.ce._def.shadowRoot !== !1 && Xt.ce._injectChildStyle(de);
          const Ce = S.subTree = mc(S);
          v(
            null,
            Ce,
            b,
            B,
            S,
            R,
            D
          ), F.el = Ce.el;
        }
        if (Ft && Je(Ft, R), !he && ($ = ft && ft.onVnodeMounted)) {
          const Ce = F;
          Je(
            () => Sn($, Ot, Ce),
            R
          );
        }
        (F.shapeFlag & 256 || Ot && di(Ot.vnode) && Ot.vnode.shapeFlag & 256) && S.a && Je(S.a, R), S.isMounted = !0, F = b = B = null;
      }
    };
    S.scope.on();
    const q = S.effect = new Ju(N);
    S.scope.off();
    const J = S.update = q.run.bind(q), V = S.job = q.runIfDirty.bind(q);
    V.i = S, V.id = S.uid, q.scheduler = () => Pl(V), Ps(S, !0), J();
  }, U = (S, F, b) => {
    F.component = S;
    const B = S.vnode.props;
    S.vnode = F, S.next = null, Xp(S, F.props, B, b), qp(S, F.children, b), Qn(), lc(S), ts();
  }, W = (S, F, b, B, R, D, A, N, q = !1) => {
    const J = S && S.children, V = S ? S.shapeFlag : 0, $ = F.children, { patchFlag: rt, shapeFlag: ft } = F;
    if (rt > 0) {
      if (rt & 128) {
        yt(
          J,
          $,
          b,
          B,
          R,
          D,
          A,
          N,
          q
        );
        return;
      } else if (rt & 256) {
        Z(
          J,
          $,
          b,
          B,
          R,
          D,
          A,
          N,
          q
        );
        return;
      }
    }
    ft & 8 ? (V & 16 && kt(J, R, D), $ !== J && h(b, $)) : V & 16 ? ft & 16 ? yt(
      J,
      $,
      b,
      B,
      R,
      D,
      A,
      N,
      q
    ) : kt(J, R, D, !0) : (V & 8 && h(b, ""), ft & 16 && z(
      $,
      b,
      B,
      R,
      D,
      A,
      N,
      q
    ));
  }, Z = (S, F, b, B, R, D, A, N, q) => {
    S = S || li, F = F || li;
    const J = S.length, V = F.length, $ = Math.min(J, V);
    let rt;
    for (rt = 0; rt < $; rt++) {
      const ft = F[rt] = q ? ys(F[rt]) : Mn(F[rt]);
      v(
        S[rt],
        ft,
        b,
        null,
        R,
        D,
        A,
        N,
        q
      );
    }
    J > V ? kt(
      S,
      R,
      D,
      !0,
      !1,
      $
    ) : z(
      F,
      b,
      B,
      R,
      D,
      A,
      N,
      q,
      $
    );
  }, yt = (S, F, b, B, R, D, A, N, q) => {
    let J = 0;
    const V = F.length;
    let $ = S.length - 1, rt = V - 1;
    for (; J <= $ && J <= rt; ) {
      const ft = S[J], bt = F[J] = q ? ys(F[J]) : Mn(F[J]);
      if (Fi(ft, bt))
        v(
          ft,
          bt,
          b,
          null,
          R,
          D,
          A,
          N,
          q
        );
      else
        break;
      J++;
    }
    for (; J <= $ && J <= rt; ) {
      const ft = S[$], bt = F[rt] = q ? ys(F[rt]) : Mn(F[rt]);
      if (Fi(ft, bt))
        v(
          ft,
          bt,
          b,
          null,
          R,
          D,
          A,
          N,
          q
        );
      else
        break;
      $--, rt--;
    }
    if (J > $) {
      if (J <= rt) {
        const ft = rt + 1, bt = ft < V ? F[ft].el : B;
        for (; J <= rt; )
          v(
            null,
            F[J] = q ? ys(F[J]) : Mn(F[J]),
            b,
            bt,
            R,
            D,
            A,
            N,
            q
          ), J++;
      }
    } else if (J > rt)
      for (; J <= $; )
        at(S[J], R, D, !0), J++;
    else {
      const ft = J, bt = J, Ft = /* @__PURE__ */ new Map();
      for (J = bt; J <= rt; J++) {
        const ke = F[J] = q ? ys(F[J]) : Mn(F[J]);
        ke.key != null && Ft.set(ke.key, J);
      }
      let Ot, Xt = 0;
      const de = rt - bt + 1;
      let he = !1, Ce = 0;
      const Qt = new Array(de);
      for (J = 0; J < de; J++) Qt[J] = 0;
      for (J = ft; J <= $; J++) {
        const ke = S[J];
        if (Xt >= de) {
          at(ke, R, D, !0);
          continue;
        }
        let pe;
        if (ke.key != null)
          pe = Ft.get(ke.key);
        else
          for (Ot = bt; Ot <= rt; Ot++)
            if (Qt[Ot - bt] === 0 && Fi(ke, F[Ot])) {
              pe = Ot;
              break;
            }
        pe === void 0 ? at(ke, R, D, !0) : (Qt[pe - bt] = J + 1, pe >= Ce ? Ce = pe : he = !0, v(
          ke,
          F[pe],
          b,
          null,
          R,
          D,
          A,
          N,
          q
        ), Xt++);
      }
      const Ln = he ? tm(Qt) : li;
      for (Ot = Ln.length - 1, J = de - 1; J >= 0; J--) {
        const ke = bt + J, pe = F[ke], Ms = F[ke + 1], Ys = ke + 1 < V ? (
          // #13559, fallback to el placeholder for unresolved async component
          Ms.el || Ms.placeholder
        ) : B;
        Qt[J] === 0 ? v(
          null,
          pe,
          b,
          Ys,
          R,
          D,
          A,
          N,
          q
        ) : he && (Ot < 0 || J !== Ln[Ot] ? Q(pe, b, Ys, 2) : Ot--);
      }
    }
  }, Q = (S, F, b, B, R = null) => {
    const { el: D, type: A, transition: N, children: q, shapeFlag: J } = S;
    if (J & 6) {
      Q(S.component.subTree, F, b, B);
      return;
    }
    if (J & 128) {
      S.suspense.move(F, b, B);
      return;
    }
    if (J & 64) {
      A.move(S, F, b, E);
      return;
    }
    if (A === Dt) {
      s(D, F, b);
      for (let $ = 0; $ < q.length; $++)
        Q(q[$], F, b, B);
      s(S.anchor, F, b);
      return;
    }
    if (A === co) {
      x(S, F, b);
      return;
    }
    if (B !== 2 && J & 1 && N)
      if (B === 0)
        N.beforeEnter(D), s(D, F, b), Je(() => N.enter(D), R);
      else {
        const { leave: $, delayLeave: rt, afterLeave: ft } = N, bt = () => {
          S.ctx.isUnmounted ? i(D) : s(D, F, b);
        }, Ft = () => {
          D._isLeaving && D[up](
            !0
            /* cancelled */
          ), $(D, () => {
            bt(), ft && ft();
          });
        };
        rt ? rt(D, bt, Ft) : Ft();
      }
    else
      s(D, F, b);
  }, at = (S, F, b, B = !1, R = !1) => {
    const {
      type: D,
      props: A,
      ref: N,
      children: q,
      dynamicChildren: J,
      shapeFlag: V,
      patchFlag: $,
      dirs: rt,
      cacheIndex: ft
    } = S;
    if ($ === -2 && (R = !1), N != null && (Qn(), Yi(N, null, b, S, !0), ts()), ft != null && (F.renderCache[ft] = void 0), V & 256) {
      F.ctx.deactivate(S);
      return;
    }
    const bt = V & 1 && rt, Ft = !di(S);
    let Ot;
    if (Ft && (Ot = A && A.onVnodeBeforeUnmount) && Sn(Ot, F, S), V & 6)
      X(S.component, b, B);
    else {
      if (V & 128) {
        S.suspense.unmount(b, B);
        return;
      }
      bt && Es(S, null, F, "beforeUnmount"), V & 64 ? S.type.remove(
        S,
        F,
        b,
        E,
        B
      ) : J && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !J.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (D !== Dt || $ > 0 && $ & 64) ? kt(
        J,
        F,
        b,
        !1,
        !0
      ) : (D === Dt && $ & 384 || !R && V & 16) && kt(q, F, b), B && _t(S);
    }
    (Ft && (Ot = A && A.onVnodeUnmounted) || bt) && Je(() => {
      Ot && Sn(Ot, F, S), bt && Es(S, null, F, "unmounted");
    }, b);
  }, _t = (S) => {
    const { type: F, el: b, anchor: B, transition: R } = S;
    if (F === Dt) {
      ht(b, B);
      return;
    }
    if (F === co) {
      k(S);
      return;
    }
    const D = () => {
      i(b), R && !R.persisted && R.afterLeave && R.afterLeave();
    };
    if (S.shapeFlag & 1 && R && !R.persisted) {
      const { leave: A, delayLeave: N } = R, q = () => A(b, D);
      N ? N(S.el, D, q) : q();
    } else
      D();
  }, ht = (S, F) => {
    let b;
    for (; S !== F; )
      b = m(S), i(S), S = b;
    i(F);
  }, X = (S, F, b) => {
    const { bum: B, scope: R, job: D, subTree: A, um: N, m: q, a: J } = S;
    yc(q), yc(J), B && lo(B), R.stop(), D && (D.flags |= 8, at(A, S, F, b)), N && Je(N, F), Je(() => {
      S.isUnmounted = !0;
    }, F);
  }, kt = (S, F, b, B = !1, R = !1, D = 0) => {
    for (let A = D; A < S.length; A++)
      at(S[A], F, b, B, R);
  }, lt = (S) => {
    if (S.shapeFlag & 6)
      return lt(S.component.subTree);
    if (S.shapeFlag & 128)
      return S.suspense.next();
    const F = m(S.anchor || S.el), b = F && F[lp];
    return b ? m(b) : F;
  };
  let pt = !1;
  const it = (S, F, b) => {
    S == null ? F._vnode && at(F._vnode, null, null, !0) : v(
      F._vnode || null,
      S,
      F,
      null,
      null,
      null,
      b
    ), F._vnode = S, pt || (pt = !0, lc(), mh(), pt = !1);
  }, E = {
    p: v,
    um: at,
    m: Q,
    r: _t,
    mt: M,
    mc: z,
    pc: W,
    pbc: ot,
    n: lt,
    o: r
  };
  return {
    render: it,
    hydrate: void 0,
    createApp: Fp(it)
  };
}
function ka({ type: r, props: e }, n) {
  return n === "svg" && r === "foreignObject" || n === "mathml" && r === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function Ps({ effect: r, job: e }, n) {
  n ? (r.flags |= 32, e.flags |= 4) : (r.flags &= -33, e.flags &= -5);
}
function Qp(r, e) {
  return (!r || r && !r.pendingBranch) && e && !e.persisted;
}
function jh(r, e, n = !1) {
  const s = r.children, i = e.children;
  if (Rt(s) && Rt(i))
    for (let o = 0; o < s.length; o++) {
      const a = s[o];
      let l = i[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = i[o] = ys(i[o]), l.el = a.el), !n && l.patchFlag !== -2 && jh(a, l)), l.type === ta && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = a.el), l.type === ns && !l.el && (l.el = a.el);
    }
}
function tm(r) {
  const e = r.slice(), n = [0];
  let s, i, o, a, l;
  const c = r.length;
  for (s = 0; s < c; s++) {
    const u = r[s];
    if (u !== 0) {
      if (i = n[n.length - 1], r[i] < u) {
        e[s] = i, n.push(s);
        continue;
      }
      for (o = 0, a = n.length - 1; o < a; )
        l = o + a >> 1, r[n[l]] < u ? o = l + 1 : a = l;
      u < r[n[o]] && (o > 0 && (e[s] = n[o - 1]), n[o] = s);
    }
  }
  for (o = n.length, a = n[o - 1]; o-- > 0; )
    n[o] = a, a = e[a];
  return n;
}
function Bh(r) {
  const e = r.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : Bh(e);
}
function yc(r) {
  if (r)
    for (let e = 0; e < r.length; e++)
      r[e].flags |= 8;
}
const Vh = (r) => r.__isSuspense;
function em(r, e) {
  e && e.pendingBranch ? Rt(r) ? e.effects.push(...r) : e.effects.push(r) : ap(r);
}
const Dt = Symbol.for("v-fgt"), ta = Symbol.for("v-txt"), ns = Symbol.for("v-cmt"), co = Symbol.for("v-stc"), qi = [];
let Qe = null;
function H(r = !1) {
  qi.push(Qe = r ? null : []);
}
function nm() {
  qi.pop(), Qe = qi[qi.length - 1] || null;
}
let or = 1;
function Co(r, e = !1) {
  or += r, r < 0 && Qe && e && (Qe.hasOnce = !0);
}
function $h(r) {
  return r.dynamicChildren = or > 0 ? Qe || li : null, nm(), or > 0 && Qe && Qe.push(r), r;
}
function G(r, e, n, s, i, o) {
  return $h(
    d(
      r,
      e,
      n,
      s,
      i,
      o,
      !0
    )
  );
}
function ce(r, e, n, s, i) {
  return $h(
    Pt(
      r,
      e,
      n,
      s,
      i,
      !0
    )
  );
}
function ar(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function Fi(r, e) {
  return r.type === e.type && r.key === e.key;
}
const Nh = ({ key: r }) => r ?? null, uo = ({
  ref: r,
  ref_key: e,
  ref_for: n
}) => (typeof r == "number" && (r = "" + r), r != null ? xe(r) || ve(r) || $t(r) ? { i: Ee, r, k: e, f: !!n } : r : null);
function d(r, e = null, n = null, s = 0, i = null, o = r === Dt ? 0 : 1, a = !1, l = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && Nh(e),
    ref: e && uo(e),
    scopeId: vh,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: s,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: Ee
  };
  return l ? (Ll(c, n), o & 128 && r.normalize(c)) : n && (c.shapeFlag |= xe(n) ? 8 : 16), or > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  Qe && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (c.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  c.patchFlag !== 32 && Qe.push(c), c;
}
const Pt = sm;
function sm(r, e = null, n = null, s = 0, i = null, o = !1) {
  if ((!r || r === xh) && (r = ns), ar(r)) {
    const l = yi(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return n && Ll(l, n), or > 0 && !o && Qe && (l.shapeFlag & 6 ? Qe[Qe.indexOf(r)] = l : Qe.push(l)), l.patchFlag = -2, l;
  }
  if (fm(r) && (r = r.__vccOpts), e) {
    e = im(e);
    let { class: l, style: c } = e;
    l && !xe(l) && (e.class = wt(l)), ie(c) && (qo(c) && !Rt(c) && (c = Le({}, c)), e.style = ne(c));
  }
  const a = xe(r) ? 1 : Vh(r) ? 128 : cp(r) ? 64 : ie(r) ? 4 : $t(r) ? 2 : 0;
  return d(
    r,
    e,
    n,
    s,
    i,
    a,
    o,
    !0
  );
}
function im(r) {
  return r ? qo(r) || Ah(r) ? Le({}, r) : r : null;
}
function yi(r, e, n = !1, s = !1) {
  const { props: i, ref: o, patchFlag: a, children: l, transition: c } = r, u = e ? rm(i || {}, e) : i, h = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: u,
    key: u && Nh(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && o ? Rt(o) ? o.concat(uo(e)) : [o, uo(e)] : uo(e)
    ) : o,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: l,
    target: r.target,
    targetStart: r.targetStart,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== Dt ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: c,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && yi(r.ssContent),
    ssFallback: r.ssFallback && yi(r.ssFallback),
    placeholder: r.placeholder,
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce
  };
  return c && s && Dl(
    h,
    c.clone(h)
  ), h;
}
function qt(r = " ", e = 0) {
  return Pt(ta, null, r, e);
}
function bi(r, e) {
  const n = Pt(co, null, r);
  return n.staticCount = e, n;
}
function xt(r = "", e = !1) {
  return e ? (H(), ce(ns, null, r)) : Pt(ns, null, r);
}
function Mn(r) {
  return r == null || typeof r == "boolean" ? Pt(ns) : Rt(r) ? Pt(
    Dt,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : ar(r) ? ys(r) : Pt(ta, null, String(r));
}
function ys(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : yi(r);
}
function Ll(r, e) {
  let n = 0;
  const { shapeFlag: s } = r;
  if (e == null)
    e = null;
  else if (Rt(e))
    n = 16;
  else if (typeof e == "object")
    if (s & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), Ll(r, i()), i._c && (i._d = !0));
      return;
    } else {
      n = 32;
      const i = e._;
      !i && !Ah(e) ? e._ctx = Ee : i === 3 && Ee && (Ee.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else $t(e) ? (e = { default: e, _ctx: Ee }, n = 32) : (e = String(e), s & 64 ? (n = 16, e = [qt(e)]) : n = 8);
  r.children = e, r.shapeFlag |= n;
}
function rm(...r) {
  const e = {};
  for (let n = 0; n < r.length; n++) {
    const s = r[n];
    for (const i in s)
      if (i === "class")
        e.class !== s.class && (e.class = wt([e.class, s.class]));
      else if (i === "style")
        e.style = ne([e.style, s.style]);
      else if (Wo(i)) {
        const o = e[i], a = s[i];
        a && o !== a && !(Rt(o) && o.includes(a)) && (e[i] = o ? [].concat(o, a) : a);
      } else i !== "" && (e[i] = s[i]);
  }
  return e;
}
function Sn(r, e, n, s = null) {
  An(r, e, 7, [
    n,
    s
  ]);
}
const om = Th();
let am = 0;
function lm(r, e, n) {
  const s = r.type, i = (e ? e.appContext : r.appContext) || om, o = {
    uid: am++,
    vnode: r,
    type: s,
    parent: e,
    appContext: i,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Ku(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Ih(s, i),
    emitsOptions: Eh(s, i),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: se,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: se,
    data: se,
    props: se,
    attrs: se,
    slots: se,
    refs: se,
    setupState: se,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = Bp.bind(null, o), r.ce && r.ce(o), o;
}
let Fe = null;
const ea = () => Fe || Ee;
let ko, el;
{
  const r = Yo(), e = (n, s) => {
    let i;
    return (i = r[n]) || (i = r[n] = []), i.push(s), (o) => {
      i.length > 1 ? i.forEach((a) => a(o)) : i[0](o);
    };
  };
  ko = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => Fe = n
  ), el = e(
    "__VUE_SSR_SETTERS__",
    (n) => lr = n
  );
}
const br = (r) => {
  const e = Fe;
  return ko(r), r.scope.on(), () => {
    r.scope.off(), ko(e);
  };
}, bc = () => {
  Fe && Fe.scope.off(), ko(null);
};
function Wh(r) {
  return r.vnode.shapeFlag & 4;
}
let lr = !1;
function cm(r, e = !1, n = !1) {
  e && el(e);
  const { props: s, children: i } = r.vnode, o = Wh(r);
  Hp(r, s, o, e), Kp(r, i, n || e);
  const a = o ? um(r, e) : void 0;
  return e && el(!1), a;
}
function um(r, e) {
  const n = r.type;
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = new Proxy(r.ctx, Cp);
  const { setup: s } = n;
  if (s) {
    Qn();
    const i = r.setupContext = s.length > 1 ? Hh(r) : null, o = br(r), a = yr(
      s,
      r,
      0,
      [
        r.props,
        i
      ]
    ), l = Nu(a);
    if (ts(), o(), (l || r.sp) && !di(r) && yh(r), l) {
      if (a.then(bc, bc), e)
        return a.then((c) => {
          _c(r, c);
        }).catch((c) => {
          Zo(c, r, 0);
        });
      r.asyncDep = a;
    } else
      _c(r, a);
  } else
    Uh(r);
}
function _c(r, e, n) {
  $t(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : ie(e) && (r.setupState = dh(e)), Uh(r);
}
function Uh(r, e, n) {
  const s = r.type;
  r.render || (r.render = s.render || Dn);
  {
    const i = br(r);
    Qn();
    try {
      Mp(r);
    } finally {
      ts(), i();
    }
  }
}
const hm = {
  get(r, e) {
    return Ae(r, "get", ""), r[e];
  }
};
function Hh(r) {
  const e = (n) => {
    r.exposed = n || {};
  };
  return {
    attrs: new Proxy(r.attrs, hm),
    slots: r.slots,
    emit: r.emit,
    expose: e
  };
}
function na(r) {
  return r.exposed ? r.exposeProxy || (r.exposeProxy = new Proxy(dh(ui(r.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in Ki)
        return Ki[n](r);
    },
    has(e, n) {
      return n in e || n in Ki;
    }
  })) : r.proxy;
}
function dm(r, e = !0) {
  return $t(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function fm(r) {
  return $t(r) && "__vccOpts" in r;
}
const St = (r, e) => np(r, e, lr);
function pm(r, e, n) {
  try {
    Co(-1);
    const s = arguments.length;
    return s === 2 ? ie(e) && !Rt(e) ? ar(e) ? Pt(r, null, [e]) : Pt(r, e) : Pt(r, null, e) : (s > 3 ? n = Array.prototype.slice.call(arguments, 2) : s === 3 && ar(n) && (n = [n]), Pt(r, e, n));
  } finally {
    Co(1);
  }
}
const mm = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let nl;
const xc = typeof window < "u" && window.trustedTypes;
if (xc)
  try {
    nl = /* @__PURE__ */ xc.createPolicy("vue", {
      createHTML: (r) => r
    });
  } catch {
  }
const Xh = nl ? (r) => nl.createHTML(r) : (r) => r, gm = "http://www.w3.org/2000/svg", vm = "http://www.w3.org/1998/Math/MathML", Bn = typeof document < "u" ? document : null, wc = Bn && /* @__PURE__ */ Bn.createElement("template"), ym = {
  insert: (r, e, n) => {
    e.insertBefore(r, n || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, n, s) => {
    const i = e === "svg" ? Bn.createElementNS(gm, r) : e === "mathml" ? Bn.createElementNS(vm, r) : n ? Bn.createElement(r, { is: n }) : Bn.createElement(r);
    return r === "select" && s && s.multiple != null && i.setAttribute("multiple", s.multiple), i;
  },
  createText: (r) => Bn.createTextNode(r),
  createComment: (r) => Bn.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => Bn.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, n, s, i, o) {
    const a = n ? n.previousSibling : e.lastChild;
    if (i && (i === o || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), n), !(i === o || !(i = i.nextSibling)); )
        ;
    else {
      wc.innerHTML = Xh(
        s === "svg" ? `<svg>${r}</svg>` : s === "mathml" ? `<math>${r}</math>` : r
      );
      const l = wc.content;
      if (s === "svg" || s === "mathml") {
        const c = l.firstChild;
        for (; c.firstChild; )
          l.appendChild(c.firstChild);
        l.removeChild(c);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, bm = Symbol("_vtc");
function _m(r, e, n) {
  const s = r[bm];
  s && (e = (e ? [e, ...s] : [...s]).join(" ")), e == null ? r.removeAttribute("class") : n ? r.setAttribute("class", e) : r.className = e;
}
const To = Symbol("_vod"), Gh = Symbol("_vsh"), Ds = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(r, { value: e }, { transition: n }) {
    r[To] = r.style.display === "none" ? "" : r.style.display, n && e ? n.beforeEnter(r) : Ii(r, e);
  },
  mounted(r, { value: e }, { transition: n }) {
    n && e && n.enter(r);
  },
  updated(r, { value: e, oldValue: n }, { transition: s }) {
    !e != !n && (s ? e ? (s.beforeEnter(r), Ii(r, !0), s.enter(r)) : s.leave(r, () => {
      Ii(r, !1);
    }) : Ii(r, e));
  },
  beforeUnmount(r, { value: e }) {
    Ii(r, e);
  }
};
function Ii(r, e) {
  r.style.display = e ? r[To] : "none", r[Gh] = !e;
}
const xm = Symbol(""), wm = /(?:^|;)\s*display\s*:/;
function Sm(r, e, n) {
  const s = r.style, i = xe(n);
  let o = !1;
  if (n && !i) {
    if (e)
      if (xe(e))
        for (const a of e.split(";")) {
          const l = a.slice(0, a.indexOf(":")).trim();
          n[l] == null && ho(s, l, "");
        }
      else
        for (const a in e)
          n[a] == null && ho(s, a, "");
    for (const a in n)
      a === "display" && (o = !0), ho(s, a, n[a]);
  } else if (i) {
    if (e !== n) {
      const a = s[xm];
      a && (n += ";" + a), s.cssText = n, o = wm.test(n);
    }
  } else e && r.removeAttribute("style");
  To in r && (r[To] = o ? s.display : "", r[Gh] && (s.display = "none"));
}
const Sc = /\s*!important$/;
function ho(r, e, n) {
  if (Rt(n))
    n.forEach((s) => ho(r, e, s));
  else if (n == null && (n = ""), e.startsWith("--"))
    r.setProperty(e, n);
  else {
    const s = Cm(r, e);
    Sc.test(n) ? r.setProperty(
      ks(s),
      n.replace(Sc, ""),
      "important"
    ) : r[s] = n;
  }
}
const Cc = ["Webkit", "Moz", "ms"], Ta = {};
function Cm(r, e) {
  const n = Ta[e];
  if (n)
    return n;
  let s = on(e);
  if (s !== "filter" && s in r)
    return Ta[e] = s;
  s = Xo(s);
  for (let i = 0; i < Cc.length; i++) {
    const o = Cc[i] + s;
    if (o in r)
      return Ta[e] = o;
  }
  return e;
}
const kc = "http://www.w3.org/1999/xlink";
function Tc(r, e, n, s, i, o = Tf(e)) {
  s && e.startsWith("xlink:") ? n == null ? r.removeAttributeNS(kc, e.slice(6, e.length)) : r.setAttributeNS(kc, e, n) : n == null || o && !Xu(n) ? r.removeAttribute(e) : r.setAttribute(
    e,
    o ? "" : _n(n) ? String(n) : n
  );
}
function Mc(r, e, n, s, i) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (r[e] = e === "innerHTML" ? Xh(n) : n);
    return;
  }
  const o = r.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? r.getAttribute("value") || "" : r.value, c = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      r.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== c || !("_value" in r)) && (r.value = c), n == null && r.removeAttribute(e), r._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const l = typeof r[e];
    l === "boolean" ? n = Xu(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0);
  }
  try {
    r[e] = n;
  } catch {
  }
  a && r.removeAttribute(i || e);
}
function bs(r, e, n, s) {
  r.addEventListener(e, n, s);
}
function km(r, e, n, s) {
  r.removeEventListener(e, n, s);
}
const Oc = Symbol("_vei");
function Tm(r, e, n, s, i = null) {
  const o = r[Oc] || (r[Oc] = {}), a = o[e];
  if (s && a)
    a.value = s;
  else {
    const [l, c] = Mm(e);
    if (s) {
      const u = o[e] = Pm(
        s,
        i
      );
      bs(r, l, u, c);
    } else a && (km(r, l, a, c), o[e] = void 0);
  }
}
const Ec = /(?:Once|Passive|Capture)$/;
function Mm(r) {
  let e;
  if (Ec.test(r)) {
    e = {};
    let s;
    for (; s = r.match(Ec); )
      r = r.slice(0, r.length - s[0].length), e[s[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : ks(r.slice(2)), e];
}
let Ma = 0;
const Om = /* @__PURE__ */ Promise.resolve(), Em = () => Ma || (Om.then(() => Ma = 0), Ma = Date.now());
function Pm(r, e) {
  const n = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= n.attached)
      return;
    An(
      Dm(s, n.value),
      e,
      5,
      [s]
    );
  };
  return n.value = r, n.attached = Em(), n;
}
function Dm(r, e) {
  if (Rt(e)) {
    const n = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      n.call(r), r._stopped = !0;
    }, e.map(
      (s) => (i) => !i._stopped && s && s(i)
    );
  } else
    return e;
}
const Pc = (r) => r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && // lowercase letter
r.charCodeAt(2) > 96 && r.charCodeAt(2) < 123, Am = (r, e, n, s, i, o) => {
  const a = i === "svg";
  e === "class" ? _m(r, s, a) : e === "style" ? Sm(r, n, s) : Wo(e) ? xl(e) || Tm(r, e, n, s, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : Fm(r, e, s, a)) ? (Mc(r, e, s), !r.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Tc(r, e, s, a, o, e !== "value")) : /* #11081 force set props for possible async custom element */ r._isVueCE && (/[A-Z]/.test(e) || !xe(s)) ? Mc(r, on(e), s, o, e) : (e === "true-value" ? r._trueValue = s : e === "false-value" && (r._falseValue = s), Tc(r, e, s, a));
};
function Fm(r, e, n, s) {
  if (s)
    return !!(e === "innerHTML" || e === "textContent" || e in r && Pc(e) && $t(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && r.tagName === "IFRAME" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const i = r.tagName;
    if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
      return !1;
  }
  return Pc(e) && xe(n) ? !1 : e in r;
}
const _i = (r) => {
  const e = r.props["onUpdate:modelValue"] || !1;
  return Rt(e) ? (n) => lo(e, n) : e;
};
function Im(r) {
  r.target.composing = !0;
}
function Dc(r) {
  const e = r.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const Yn = Symbol("_assign");
function Ac(r, e, n) {
  return e && (r = r.trim()), n && (r = Go(r)), r;
}
const ge = {
  created(r, { modifiers: { lazy: e, trim: n, number: s } }, i) {
    r[Yn] = _i(i);
    const o = s || i.props && i.props.type === "number";
    bs(r, e ? "change" : "input", (a) => {
      a.target.composing || r[Yn](Ac(r.value, n, o));
    }), (n || o) && bs(r, "change", () => {
      r.value = Ac(r.value, n, o);
    }), e || (bs(r, "compositionstart", Im), bs(r, "compositionend", Dc), bs(r, "change", Dc));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(r, { value: e }) {
    r.value = e ?? "";
  },
  beforeUpdate(r, { value: e, oldValue: n, modifiers: { lazy: s, trim: i, number: o } }, a) {
    if (r[Yn] = _i(a), r.composing) return;
    const l = (o || r.type === "number") && !/^0\d/.test(r.value) ? Go(r.value) : r.value, c = e ?? "";
    l !== c && (document.activeElement === r && r.type !== "range" && (s && e === n || i && r.value.trim() === c) || (r.value = c));
  }
}, Lm = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(r, e, n) {
    r[Yn] = _i(n), bs(r, "change", () => {
      const s = r._modelValue, i = cr(r), o = r.checked, a = r[Yn];
      if (Rt(s)) {
        const l = Sl(s, i), c = l !== -1;
        if (o && !c)
          a(s.concat(i));
        else if (!o && c) {
          const u = [...s];
          u.splice(l, 1), a(u);
        }
      } else if (Si(s)) {
        const l = new Set(s);
        o ? l.add(i) : l.delete(i), a(l);
      } else
        a(Yh(r, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Fc,
  beforeUpdate(r, e, n) {
    r[Yn] = _i(n), Fc(r, e, n);
  }
};
function Fc(r, { value: e, oldValue: n }, s) {
  r._modelValue = e;
  let i;
  if (Rt(e))
    i = Sl(e, s.props.value) > -1;
  else if (Si(e))
    i = e.has(s.props.value);
  else {
    if (e === n) return;
    i = vr(e, Yh(r, !0));
  }
  r.checked !== i && (r.checked = i);
}
const Kn = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(r, { value: e, modifiers: { number: n } }, s) {
    const i = Si(e);
    bs(r, "change", () => {
      const o = Array.prototype.filter.call(r.options, (a) => a.selected).map(
        (a) => n ? Go(cr(a)) : cr(a)
      );
      r[Yn](
        r.multiple ? i ? new Set(o) : o : o[0]
      ), r._assigning = !0, ws(() => {
        r._assigning = !1;
      });
    }), r[Yn] = _i(s);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(r, { value: e }) {
    Ic(r, e);
  },
  beforeUpdate(r, e, n) {
    r[Yn] = _i(n);
  },
  updated(r, { value: e }) {
    r._assigning || Ic(r, e);
  }
};
function Ic(r, e) {
  const n = r.multiple, s = Rt(e);
  if (!(n && !s && !Si(e))) {
    for (let i = 0, o = r.options.length; i < o; i++) {
      const a = r.options[i], l = cr(a);
      if (n)
        if (s) {
          const c = typeof l;
          c === "string" || c === "number" ? a.selected = e.some((u) => String(u) === String(l)) : a.selected = Sl(e, l) > -1;
        } else
          a.selected = e.has(l);
      else if (vr(cr(a), e)) {
        r.selectedIndex !== i && (r.selectedIndex = i);
        return;
      }
    }
    !n && r.selectedIndex !== -1 && (r.selectedIndex = -1);
  }
}
function cr(r) {
  return "_value" in r ? r._value : r.value;
}
function Yh(r, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in r ? r[n] : e;
}
const Rm = ["ctrl", "shift", "alt", "meta"], zm = {
  stop: (r) => r.stopPropagation(),
  prevent: (r) => r.preventDefault(),
  self: (r) => r.target !== r.currentTarget,
  ctrl: (r) => !r.ctrlKey,
  shift: (r) => !r.shiftKey,
  alt: (r) => !r.altKey,
  meta: (r) => !r.metaKey,
  left: (r) => "button" in r && r.button !== 0,
  middle: (r) => "button" in r && r.button !== 1,
  right: (r) => "button" in r && r.button !== 2,
  exact: (r, e) => Rm.some((n) => r[`${n}Key`] && !e.includes(n))
}, Bt = (r, e) => {
  const n = r._withMods || (r._withMods = {}), s = e.join(".");
  return n[s] || (n[s] = (i, ...o) => {
    for (let a = 0; a < e.length; a++) {
      const l = zm[e[a]];
      if (l && l(i, e)) return;
    }
    return r(i, ...o);
  });
}, jm = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, sl = (r, e) => {
  const n = r._withKeys || (r._withKeys = {}), s = e.join(".");
  return n[s] || (n[s] = (i) => {
    if (!("key" in i))
      return;
    const o = ks(i.key);
    if (e.some(
      (a) => a === o || jm[a] === o
    ))
      return r(i);
  });
}, Bm = /* @__PURE__ */ Le({ patchProp: Am }, ym);
let Lc;
function Vm() {
  return Lc || (Lc = Zp(Bm));
}
const $m = (...r) => {
  const e = Vm().createApp(...r), { mount: n } = e;
  return e.mount = (s) => {
    const i = Wm(s);
    if (!i) return;
    const o = e._component;
    !$t(o) && !o.render && !o.template && (o.template = i.innerHTML), i.nodeType === 1 && (i.textContent = "");
    const a = n(i, !1, Nm(i));
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), a;
  }, e;
};
function Nm(r) {
  if (r instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && r instanceof MathMLElement)
    return "mathml";
}
function Wm(r) {
  return xe(r) ? document.querySelector(r) : r;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let Kh;
const sa = (r) => Kh = r, qh = (
  /* istanbul ignore next */
  Symbol()
);
function il(r) {
  return r && typeof r == "object" && Object.prototype.toString.call(r) === "[object Object]" && typeof r.toJSON != "function";
}
var Zi;
(function(r) {
  r.direct = "direct", r.patchObject = "patch object", r.patchFunction = "patch function";
})(Zi || (Zi = {}));
function Um() {
  const r = qu(!0), e = r.run(() => ut({}));
  let n = [], s = [];
  const i = ui({
    install(o) {
      sa(i), i._a = o, o.provide(qh, i), o.config.globalProperties.$pinia = i, s.forEach((a) => n.push(a)), s = [];
    },
    use(o) {
      return this._a ? n.push(o) : s.push(o), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: r,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return i;
}
const Zh = () => {
};
function Rc(r, e, n, s = Zh) {
  r.push(e);
  const i = () => {
    const o = r.indexOf(e);
    o > -1 && (r.splice(o, 1), s());
  };
  return !n && Zu() && Of(i), i;
}
function Zs(r, ...e) {
  r.slice().forEach((n) => {
    n(...e);
  });
}
const Hm = (r) => r(), zc = Symbol(), Oa = Symbol();
function rl(r, e) {
  r instanceof Map && e instanceof Map ? e.forEach((n, s) => r.set(s, n)) : r instanceof Set && e instanceof Set && e.forEach(r.add, r);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const s = e[n], i = r[n];
    il(i) && il(s) && r.hasOwnProperty(n) && !ve(s) && !Gn(s) ? r[n] = rl(i, s) : r[n] = s;
  }
  return r;
}
const Xm = (
  /* istanbul ignore next */
  Symbol()
);
function Gm(r) {
  return !il(r) || !r.hasOwnProperty(Xm);
}
const { assign: ms } = Object;
function Ym(r) {
  return !!(ve(r) && r.effect);
}
function Km(r, e, n, s) {
  const { state: i, actions: o, getters: a } = e, l = n.state.value[r];
  let c;
  function u() {
    l || (n.state.value[r] = i ? i() : {});
    const h = Jf(n.state.value[r]);
    return ms(h, o, Object.keys(a || {}).reduce((f, m) => (f[m] = ui(St(() => {
      sa(n);
      const p = n._s.get(r);
      return a[m].call(p, p);
    })), f), {}));
  }
  return c = Jh(r, u, e, n, s, !0), c;
}
function Jh(r, e, n = {}, s, i, o) {
  let a;
  const l = ms({ actions: {} }, n), c = { deep: !0 };
  let u, h, f = [], m = [], p;
  const y = s.state.value[r];
  !o && !y && (s.state.value[r] = {}), ut({});
  let v;
  function _(z) {
    let j;
    u = h = !1, typeof z == "function" ? (z(s.state.value[r]), j = {
      type: Zi.patchFunction,
      storeId: r,
      events: p
    }) : (rl(s.state.value[r], z), j = {
      type: Zi.patchObject,
      payload: z,
      storeId: r,
      events: p
    });
    const ot = v = Symbol();
    ws().then(() => {
      v === ot && (u = !0);
    }), h = !0, Zs(f, j, s.state.value[r]);
  }
  const g = o ? function() {
    const { state: j } = n, ot = j ? j() : {};
    this.$patch((vt) => {
      ms(vt, ot);
    });
  } : (
    /* istanbul ignore next */
    Zh
  );
  function C() {
    a.stop(), f = [], m = [], s._s.delete(r);
  }
  const x = (z, j = "") => {
    if (zc in z)
      return z[Oa] = j, z;
    const ot = function() {
      sa(s);
      const vt = Array.from(arguments), L = [], Y = [];
      function M(U) {
        L.push(U);
      }
      function I(U) {
        Y.push(U);
      }
      Zs(m, {
        args: vt,
        name: ot[Oa],
        store: w,
        after: M,
        onError: I
      });
      let tt;
      try {
        tt = z.apply(this && this.$id === r ? this : w, vt);
      } catch (U) {
        throw Zs(Y, U), U;
      }
      return tt instanceof Promise ? tt.then((U) => (Zs(L, U), U)).catch((U) => (Zs(Y, U), Promise.reject(U))) : (Zs(L, tt), tt);
    };
    return ot[zc] = !0, ot[Oa] = j, ot;
  }, k = {
    _p: s,
    // _s: scope,
    $id: r,
    $onAction: Rc.bind(null, m),
    $patch: _,
    $reset: g,
    $subscribe(z, j = {}) {
      const ot = Rc(f, z, j.detached, () => vt()), vt = a.run(() => ae(() => s.state.value[r], (L) => {
        (j.flush === "sync" ? h : u) && z({
          storeId: r,
          type: Zi.direct,
          events: p
        }, L);
      }, ms({}, c, j)));
      return ot;
    },
    $dispose: C
  }, w = Xs(k);
  s._s.set(r, w);
  const P = (s._a && s._a.runWithContext || Hm)(() => s._e.run(() => (a = qu()).run(() => e({ action: x }))));
  for (const z in P) {
    const j = P[z];
    if (ve(j) && !Ym(j) || Gn(j))
      o || (y && Gm(j) && (ve(j) ? j.value = y[z] : rl(j, y[z])), s.state.value[r][z] = j);
    else if (typeof j == "function") {
      const ot = x(j, z);
      P[z] = ot, l.actions[z] = j;
    }
  }
  return ms(w, P), ms(Kt(w), P), Object.defineProperty(w, "$state", {
    get: () => s.state.value[r],
    set: (z) => {
      _((j) => {
        ms(j, z);
      });
    }
  }), s._p.forEach((z) => {
    ms(w, a.run(() => z({
      store: w,
      app: s._a,
      pinia: s,
      options: l
    })));
  }), y && o && n.hydrate && n.hydrate(w.$state, y), u = !0, h = !0, w;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function qm(r, e, n) {
  let s, i;
  const o = typeof e == "function";
  s = r, i = o ? n : e;
  function a(l, c) {
    const u = Ip();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (u ? pn(qh, null) : null), l && sa(l), l = Kh, l._s.has(s) || (o ? Jh(s, e, i, l) : Km(s, i, l)), l._s.get(s);
  }
  return a.$id = s, a;
}
const Ea = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: !1 },
    pushOtherPanes: { type: Boolean, default: !0 },
    maximizePanes: { type: Boolean, default: !0 },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: !1 }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(r, { emit: e }) {
    const n = e, s = r, i = kp(), o = ut([]), a = St(() => o.value.reduce((lt, pt) => (lt[~~pt.id] = pt) && lt, {})), l = St(() => o.value.length), c = ut(null), u = ut(!1), h = ut({
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), f = ut({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), m = St(() => ({
      [`splitpanes splitpanes--${s.horizontal ? "horizontal" : "vertical"}`]: !0,
      "splitpanes--dragging": h.value.dragging
    })), p = () => {
      document.addEventListener("mousemove", _, { passive: !1 }), document.addEventListener("mouseup", g), "ontouchstart" in window && (document.addEventListener("touchmove", _, { passive: !1 }), document.addEventListener("touchend", g));
    }, y = () => {
      document.removeEventListener("mousemove", _, { passive: !1 }), document.removeEventListener("mouseup", g), "ontouchstart" in window && (document.removeEventListener("touchmove", _, { passive: !1 }), document.removeEventListener("touchend", g));
    }, v = (lt, pt) => {
      const it = lt.target.closest(".splitpanes__splitter");
      if (it) {
        const { left: E, top: O } = it.getBoundingClientRect(), { clientX: S, clientY: F } = "ontouchstart" in window && lt.touches ? lt.touches[0] : lt;
        h.value.cursorOffset = s.horizontal ? F - O : S - E;
      }
      p(), h.value.mouseDown = !0, h.value.activeSplitter = pt;
    }, _ = (lt) => {
      h.value.mouseDown && (lt.preventDefault(), h.value.dragging = !0, requestAnimationFrame(() => {
        P(w(lt)), X("resize", { event: lt }, !0);
      }));
    }, g = (lt) => {
      h.value.dragging && (window.getSelection().removeAllRanges(), X("resized", { event: lt }, !0)), h.value.mouseDown = !1, h.value.activeSplitter = null, setTimeout(() => {
        h.value.dragging = !1, y();
      }, 100);
    }, C = (lt, pt) => {
      "ontouchstart" in window && (lt.preventDefault(), f.value.splitter === pt ? (clearTimeout(f.value.timeoutId), f.value.timeoutId = null, x(lt, pt), f.value.splitter = null) : (f.value.splitter = pt, f.value.timeoutId = setTimeout(() => f.value.splitter = null, 500))), h.value.dragging || X("splitter-click", { event: lt, index: pt }, !0);
    }, x = (lt, pt) => {
      if (X("splitter-dblclick", { event: lt, index: pt }, !0), s.maximizePanes) {
        let it = 0;
        o.value = o.value.map((E, O) => (E.size = O === pt ? E.max : E.min, O !== pt && (it += E.min), E)), o.value[pt].size -= it, X("pane-maximize", { event: lt, index: pt, pane: o.value[pt] }), X("resized", { event: lt, index: pt }, !0);
      }
    }, k = (lt, pt) => {
      X("pane-click", {
        event: lt,
        index: a.value[pt].index,
        pane: a.value[pt]
      });
    }, w = (lt) => {
      const pt = c.value.getBoundingClientRect(), { clientX: it, clientY: E } = "ontouchstart" in window && lt.touches ? lt.touches[0] : lt;
      return {
        x: it - (s.horizontal ? 0 : h.value.cursorOffset) - pt.left,
        y: E - (s.horizontal ? h.value.cursorOffset : 0) - pt.top
      };
    }, T = (lt) => {
      lt = lt[s.horizontal ? "y" : "x"];
      const pt = c.value[s.horizontal ? "clientHeight" : "clientWidth"];
      return s.rtl && !s.horizontal && (lt = pt - lt), lt * 100 / pt;
    }, P = (lt) => {
      const pt = h.value.activeSplitter;
      let it = {
        prevPanesSize: j(pt),
        nextPanesSize: ot(pt),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const E = 0 + (s.pushOtherPanes ? 0 : it.prevPanesSize), O = 100 - (s.pushOtherPanes ? 0 : it.nextPanesSize), S = Math.max(Math.min(T(lt), O), E);
      let F = [pt, pt + 1], b = o.value[F[0]] || null, B = o.value[F[1]] || null;
      const R = b.max < 100 && S >= b.max + it.prevPanesSize, D = B.max < 100 && S <= 100 - (B.max + ot(pt + 1));
      if (R || D) {
        R ? (b.size = b.max, B.size = Math.max(100 - b.max - it.prevPanesSize - it.nextPanesSize, 0)) : (b.size = Math.max(100 - B.max - it.prevPanesSize - ot(pt + 1), 0), B.size = B.max);
        return;
      }
      if (s.pushOtherPanes) {
        const A = z(it, S);
        if (!A) return;
        ({ sums: it, panesToResize: F } = A), b = o.value[F[0]] || null, B = o.value[F[1]] || null;
      }
      b !== null && (b.size = Math.min(Math.max(S - it.prevPanesSize - it.prevReachedMinPanes, b.min), b.max)), B !== null && (B.size = Math.min(Math.max(100 - S - it.nextPanesSize - it.nextReachedMinPanes, B.min), B.max));
    }, z = (lt, pt) => {
      const it = h.value.activeSplitter, E = [it, it + 1];
      return pt < lt.prevPanesSize + o.value[E[0]].min && (E[0] = vt(it).index, lt.prevReachedMinPanes = 0, E[0] < it && o.value.forEach((O, S) => {
        S > E[0] && S <= it && (O.size = O.min, lt.prevReachedMinPanes += O.min);
      }), lt.prevPanesSize = j(E[0]), E[0] === void 0) ? (lt.prevReachedMinPanes = 0, o.value[0].size = o.value[0].min, o.value.forEach((O, S) => {
        S > 0 && S <= it && (O.size = O.min, lt.prevReachedMinPanes += O.min);
      }), o.value[E[1]].size = 100 - lt.prevReachedMinPanes - o.value[0].min - lt.prevPanesSize - lt.nextPanesSize, null) : pt > 100 - lt.nextPanesSize - o.value[E[1]].min && (E[1] = L(it).index, lt.nextReachedMinPanes = 0, E[1] > it + 1 && o.value.forEach((O, S) => {
        S > it && S < E[1] && (O.size = O.min, lt.nextReachedMinPanes += O.min);
      }), lt.nextPanesSize = ot(E[1] - 1), E[1] === void 0) ? (lt.nextReachedMinPanes = 0, o.value.forEach((O, S) => {
        S < l.value - 1 && S >= it + 1 && (O.size = O.min, lt.nextReachedMinPanes += O.min);
      }), o.value[E[0]].size = 100 - lt.prevPanesSize - ot(E[0] - 1), null) : { sums: lt, panesToResize: E };
    }, j = (lt) => o.value.reduce((pt, it, E) => pt + (E < lt ? it.size : 0), 0), ot = (lt) => o.value.reduce((pt, it, E) => pt + (E > lt + 1 ? it.size : 0), 0), vt = (lt) => [...o.value].reverse().find((pt) => pt.index < lt && pt.size > pt.min) || {}, L = (lt) => o.value.find((pt) => pt.index > lt + 1 && pt.size > pt.min) || {}, Y = () => {
      var lt;
      const pt = Array.from(((lt = c.value) == null ? void 0 : lt.children) || []);
      for (const it of pt) {
        const E = it.classList.contains("splitpanes__pane"), O = it.classList.contains("splitpanes__splitter");
        !E && !O && (it.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, M = (lt, pt, it = !1) => {
      const E = lt - 1, O = document.createElement("div");
      O.classList.add("splitpanes__splitter"), it || (O.onmousedown = (S) => v(S, E), typeof window < "u" && "ontouchstart" in window && (O.ontouchstart = (S) => v(S, E)), O.onclick = (S) => C(S, E + 1)), O.ondblclick = (S) => x(S, E + 1), pt.parentNode.insertBefore(O, pt);
    }, I = (lt) => {
      lt.onmousedown = void 0, lt.onclick = void 0, lt.ondblclick = void 0, lt.remove();
    }, tt = () => {
      var lt;
      const pt = Array.from(((lt = c.value) == null ? void 0 : lt.children) || []);
      for (const E of pt)
        E.className.includes("splitpanes__splitter") && I(E);
      let it = 0;
      for (const E of pt)
        E.className.includes("splitpanes__pane") && (!it && s.firstSplitter ? M(it, E, !0) : it && M(it, E), it++);
    }, U = ({ uid: lt, ...pt }) => {
      const it = a.value[lt];
      for (const [E, O] of Object.entries(pt)) it[E] = O;
    }, W = (lt) => {
      var pt;
      let it = -1;
      Array.from(((pt = c.value) == null ? void 0 : pt.children) || []).some((E) => (E.className.includes("splitpanes__pane") && it++, E.isSameNode(lt.el))), o.value.splice(it, 0, { ...lt, index: it }), o.value.forEach((E, O) => E.index = O), u.value && ws(() => {
        tt(), yt({ addedPane: o.value[it] }), X("pane-add", { pane: o.value[it] });
      });
    }, Z = (lt) => {
      const pt = o.value.findIndex((E) => E.id === lt);
      o.value[pt].el = null;
      const it = o.value.splice(pt, 1)[0];
      o.value.forEach((E, O) => E.index = O), ws(() => {
        tt(), X("pane-remove", { pane: it }), yt({ removedPane: { ...it } });
      });
    }, yt = (lt = {}) => {
      !lt.addedPane && !lt.removedPane ? at() : o.value.some((pt) => pt.givenSize !== null || pt.min || pt.max < 100) ? _t(lt) : Q(), u.value && X("resized");
    }, Q = () => {
      const lt = 100 / l.value;
      let pt = 0;
      const it = [], E = [];
      for (const O of o.value)
        O.size = Math.max(Math.min(lt, O.max), O.min), pt -= O.size, O.size >= O.max && it.push(O.id), O.size <= O.min && E.push(O.id);
      pt > 0.1 && ht(pt, it, E);
    }, at = () => {
      let lt = 100;
      const pt = [], it = [];
      let E = 0;
      for (const S of o.value)
        lt -= S.size, S.givenSize !== null && E++, S.size >= S.max && pt.push(S.id), S.size <= S.min && it.push(S.id);
      let O = 100;
      if (lt > 0.1) {
        for (const S of o.value)
          S.givenSize === null && (S.size = Math.max(Math.min(lt / (l.value - E), S.max), S.min)), O -= S.size;
        O > 0.1 && ht(O, pt, it);
      }
    }, _t = ({ addedPane: lt, removedPane: pt } = {}) => {
      let it = 100 / l.value, E = 0;
      const O = [], S = [];
      ((lt == null ? void 0 : lt.givenSize) ?? null) !== null && (it = (100 - lt.givenSize) / (l.value - 1));
      for (const F of o.value)
        E -= F.size, F.size >= F.max && O.push(F.id), F.size <= F.min && S.push(F.id);
      if (!(Math.abs(E) < 0.1)) {
        for (const F of o.value)
          (lt == null ? void 0 : lt.givenSize) !== null && (lt == null ? void 0 : lt.id) === F.id || (F.size = Math.max(Math.min(it, F.max), F.min)), E -= F.size, F.size >= F.max && O.push(F.id), F.size <= F.min && S.push(F.id);
        E > 0.1 && ht(E, O, S);
      }
    }, ht = (lt, pt, it) => {
      let E;
      lt > 0 ? E = lt / (l.value - pt.length) : E = lt / (l.value - it.length), o.value.forEach((O, S) => {
        if (lt > 0 && !pt.includes(O.id)) {
          const F = Math.max(Math.min(O.size + E, O.max), O.min), b = F - O.size;
          lt -= b, O.size = F;
        } else if (!it.includes(O.id)) {
          const F = Math.max(Math.min(O.size + E, O.max), O.min), b = F - O.size;
          lt -= b, O.size = F;
        }
      }), Math.abs(lt) > 0.1 && ws(() => {
        u.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, X = (lt, pt = void 0, it = !1) => {
      const E = (pt == null ? void 0 : pt.index) ?? h.value.activeSplitter ?? null;
      n(lt, {
        ...pt,
        ...E !== null && { index: E },
        ...it && E !== null && {
          prevPane: o.value[E - (s.firstSplitter ? 1 : 0)],
          nextPane: o.value[E + (s.firstSplitter ? 0 : 1)]
        },
        panes: o.value.map((O) => ({ min: O.min, max: O.max, size: O.size }))
      });
    };
    ae(() => s.firstSplitter, () => tt()), Ne(() => {
      Y(), tt(), yt(), X("ready"), u.value = !0;
    }), Al(() => u.value = !1);
    const kt = () => {
      var lt;
      return pm(
        "div",
        { ref: c, class: m.value },
        (lt = i.default) == null ? void 0 : lt.call(i)
      );
    };
    return ps("panes", o), ps("indexedPanes", a), ps("horizontal", St(() => s.horizontal)), ps("requestUpdate", U), ps("onPaneAdd", W), ps("onPaneRemove", Z), ps("onPaneClick", k), (lt, pt) => (H(), ce(wh(kt)));
  }
}, As = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(r) {
    var e;
    const n = r, s = pn("requestUpdate"), i = pn("onPaneAdd"), o = pn("horizontal"), a = pn("onPaneRemove"), l = pn("onPaneClick"), c = (e = ea()) == null ? void 0 : e.uid, u = pn("indexedPanes"), h = St(() => u.value[c]), f = ut(null), m = St(() => {
      const _ = isNaN(n.size) || n.size === void 0 ? 0 : parseFloat(n.size);
      return Math.max(Math.min(_, y.value), p.value);
    }), p = St(() => {
      const _ = parseFloat(n.minSize);
      return isNaN(_) ? 0 : _;
    }), y = St(() => {
      const _ = parseFloat(n.maxSize);
      return isNaN(_) ? 100 : _;
    }), v = St(() => {
      var _;
      return `${o.value ? "height" : "width"}: ${(_ = h.value) == null ? void 0 : _.size}%`;
    });
    return ae(() => m.value, (_) => s({ uid: c, size: _ })), ae(() => p.value, (_) => s({ uid: c, min: _ })), ae(() => y.value, (_) => s({ uid: c, max: _ })), Ne(() => {
      i({
        id: c,
        el: f.value,
        min: p.value,
        max: y.value,
        // The given size (useful to know the user intention).
        givenSize: n.size === void 0 ? null : m.value,
        size: m.value
        // The computed current size at any time.
      });
    }), Al(() => a(c)), (_, g) => (H(), G("div", {
      ref_key: "paneEl",
      ref: f,
      class: "splitpanes__pane",
      onClick: g[0] || (g[0] = (C) => At(l)(C, _._.uid)),
      style: ne(v.value)
    }, [
      Sp(_.$slots, "default")
    ], 4));
  }
}, Un = 2048, Zm = {
  sub: [20, 60],
  bass: [60, 250],
  lowMid: [250, 500],
  mid: [500, 2e3],
  highMid: [2e3, 4e3],
  high: [4e3, 2e4]
};
async function Jm(r) {
  const e = await r.arrayBuffer(), n = new AudioContext();
  try {
    const s = await n.decodeAudioData(e);
    return await n.close(), s;
  } catch (s) {
    throw await n.close(), new Error(`Failed to decode audio file: ${s}`);
  }
}
async function Qm(r, e) {
  const n = r.duration, s = Math.ceil(n * e), i = r.sampleRate, o = tg(r, e), a = eg(r, e), l = await ng(r, e), c = await sg(r, e), u = ig(r, e), h = og(r);
  return {
    sampleRate: i,
    duration: n,
    frameCount: s,
    amplitudeEnvelope: o,
    rmsEnergy: a,
    spectralCentroid: c,
    frequencyBands: l,
    onsets: u,
    bpm: h
  };
}
function tg(r, e) {
  const n = r.getChannelData(0), s = Math.floor(r.sampleRate / e), i = Math.ceil(r.duration * e), o = [];
  for (let l = 0; l < i; l++) {
    const c = l * s, u = Math.min(c + s, n.length);
    let h = 0;
    for (let f = c; f < u; f++) {
      const m = Math.abs(n[f]);
      m > h && (h = m);
    }
    o.push(h);
  }
  const a = Math.max(...o, 1e-4);
  return o.map((l) => l / a);
}
function eg(r, e) {
  const n = r.getChannelData(0), s = Math.floor(r.sampleRate / e), i = Math.ceil(r.duration * e), o = [];
  for (let l = 0; l < i; l++) {
    const c = l * s, u = Math.min(c + s, n.length);
    let h = 0, f = 0;
    for (let p = c; p < u; p++)
      h += n[p] * n[p], f++;
    const m = f > 0 ? Math.sqrt(h / f) : 0;
    o.push(m);
  }
  const a = Math.max(...o, 1e-4);
  return o.map((l) => l / a);
}
async function ng(r, e) {
  const n = r.duration, s = Math.ceil(n * e), i = r.sampleRate, o = new OfflineAudioContext(
    1,
    r.length,
    i
  ), a = o.createBufferSource();
  a.buffer = r;
  const l = o.createAnalyser();
  l.fftSize = Un, l.smoothingTimeConstant = 0, a.connect(l), l.connect(o.destination);
  const c = {
    sub: [],
    bass: [],
    lowMid: [],
    mid: [],
    highMid: [],
    high: []
  }, u = i / Un, h = Object.entries(Zm).reduce((p, [y, [v, _]]) => (p[y] = {
    start: Math.floor(v / u),
    end: Math.ceil(_ / u)
  }, p), {}), f = Math.floor(i / e), m = r.getChannelData(0);
  for (let p = 0; p < s; p++) {
    const y = p * f;
    if (Math.min(y + Un, m.length) - y < 64) {
      Object.keys(c).forEach((C) => {
        const x = c[C];
        x.push(x.length > 0 ? x[x.length - 1] : 0);
      });
      continue;
    }
    const g = Rl(m.slice(y, y + Un));
    for (const [C, { start: x, end: k }] of Object.entries(h)) {
      let w = 0, T = 0;
      for (let P = x; P < Math.min(k, g.length); P++)
        w += g[P], T++;
      c[C].push(T > 0 ? w / T : 0);
    }
  }
  for (const p of Object.keys(c)) {
    const y = Math.max(...c[p], 1e-4);
    c[p] = c[p].map((v) => v / y);
  }
  return c;
}
function Rl(r) {
  const e = r.length, n = [], s = new Float32Array(e);
  for (let o = 0; o < e; o++) {
    const a = 0.5 * (1 - Math.cos(2 * Math.PI * o / (e - 1)));
    s[o] = (r[o] || 0) * a;
  }
  const i = Math.floor(e / 2);
  for (let o = 0; o < i; o++) {
    let a = 0, l = 0;
    for (let c = 0; c < e; c++) {
      const u = 2 * Math.PI * o * c / e;
      a += s[c] * Math.cos(u), l -= s[c] * Math.sin(u);
    }
    n.push(Math.sqrt(a * a + l * l) / e);
  }
  return n;
}
async function sg(r, e) {
  const n = Math.ceil(r.duration * e), s = r.sampleRate, i = r.getChannelData(0), o = Math.floor(s / e), a = [], l = s / Un;
  for (let u = 0; u < n; u++) {
    const h = u * o;
    if (h + Un > i.length) {
      a.push(a.length > 0 ? a[a.length - 1] : 0);
      continue;
    }
    const f = Rl(i.slice(h, h + Un));
    let m = 0, p = 0;
    for (let v = 0; v < f.length; v++) {
      const _ = v * l;
      m += _ * f[v], p += f[v];
    }
    const y = p > 0 ? m / p : 0;
    a.push(y);
  }
  const c = Math.max(...a, 1e-4);
  return a.map((u) => u / c);
}
function ig(r, e, n = 0.5) {
  const s = r.getChannelData(0), i = r.sampleRate, o = Math.floor(i / e), a = Math.ceil(r.duration * e), l = [];
  let c = null;
  for (let f = 0; f < a; f++) {
    const m = f * o;
    if (m + Un > s.length) {
      l.push(0);
      continue;
    }
    const p = Rl(s.slice(m, m + Un));
    if (c) {
      let y = 0;
      for (let v = 0; v < p.length; v++) {
        const _ = p[v] - c[v];
        _ > 0 && (y += _);
      }
      l.push(y);
    } else
      l.push(0);
    c = p;
  }
  const u = [], h = rg(l, n);
  for (let f = 1; f < l.length - 1; f++)
    l[f] > l[f - 1] && l[f] > l[f + 1] && l[f] > h[f] && u.push(f);
  return u;
}
function rg(r, e) {
  const s = [];
  for (let i = 0; i < r.length; i++) {
    const o = Math.max(0, i - 10), a = Math.min(r.length, i + 10 + 1), l = r.slice(o, a), c = l.reduce((h, f) => h + f, 0) / l.length, u = Math.sqrt(
      l.reduce((h, f) => h + (f - c) ** 2, 0) / l.length
    );
    s.push(c + (1 - e) * 2 * u);
  }
  return s;
}
function og(r) {
  const e = r.getChannelData(0), n = r.sampleRate, s = 4, i = [];
  for (let _ = 0; _ < e.length; _ += s)
    i.push(Math.abs(e[_]));
  const o = ag(i, 0.1), a = 60, l = 200, c = n / s, u = Math.floor(60 / l * c), h = Math.floor(60 / a * c);
  let f = 0, m = u;
  const p = Math.min(o.length, c * 10), y = o.slice(0, p);
  for (let _ = u; _ <= h; _++) {
    let g = 0, C = 0;
    for (let x = 0; x < y.length - _; x++)
      g += y[x] * y[x + _], C++;
    C > 0 && (g /= C, g > f && (f = g, m = _));
  }
  const v = 60 * c / m;
  return Math.round(Math.max(a, Math.min(l, v)));
}
function ag(r, e) {
  const n = [];
  let s = 0;
  for (const i of r)
    i > s ? s = i : s = s * (1 - e) + i * e, n.push(s);
  return n;
}
function ol(r, e, n) {
  const s = Math.max(0, Math.min(n, r.frameCount - 1));
  switch (e) {
    case "amplitude":
      return r.amplitudeEnvelope[s] ?? 0;
    case "rms":
      return r.rmsEnergy[s] ?? 0;
    case "spectralCentroid":
      return r.spectralCentroid[s] ?? 0;
    case "sub":
      return r.frequencyBands.sub[s] ?? 0;
    case "bass":
      return r.frequencyBands.bass[s] ?? 0;
    case "lowMid":
      return r.frequencyBands.lowMid[s] ?? 0;
    case "mid":
      return r.frequencyBands.mid[s] ?? 0;
    case "highMid":
      return r.frequencyBands.highMid[s] ?? 0;
    case "high":
      return r.frequencyBands.high[s] ?? 0;
    case "onsets":
      return r.onsets.includes(s) ? 1 : 0;
    default:
      return 0;
  }
}
function lg(r, e) {
  const { threshold: n, minPeaksDistance: s, multiply: i } = e, o = r.map((h) => Math.min(1, h * i)), a = [];
  for (let h = 1; h < o.length - 1; h++) {
    const f = o[h - 1], m = o[h], p = o[h + 1];
    m > f && m > p && m >= n && a.push({ index: h, value: m });
  }
  const l = [];
  for (const h of a) {
    const f = l.findIndex(
      (m) => Math.abs(m.index - h.index) < s
    );
    f === -1 ? l.push(h) : h.value > l[f].value && (l[f] = h);
  }
  l.sort((h, f) => h.index - f.index);
  const c = new Array(r.length).fill(0);
  let u = 0;
  for (let h = 0; h < r.length; h++)
    l.some((m) => m.index === h) && (u = 1 - u), c[h] = u;
  return {
    indices: l.map((h) => h.index),
    values: l.map((h) => h.value),
    count: l.length,
    alternating: c
  };
}
function jc(r, e) {
  return r.onsets.includes(e);
}
function cg(r, e) {
  return r.indices.includes(e);
}
function sn(r, e, n = "number") {
  return {
    id: `prop_${r}_${Date.now()}`,
    name: r,
    type: n,
    value: e,
    animated: !1,
    keyframes: []
  };
}
function ug() {
  return {
    position: sn("position", { x: 0, y: 0 }, "position"),
    anchor: { x: 0, y: 0 },
    scale: sn("scale", { x: 1, y: 1 }, "position"),
    rotation: sn("rotation", 0, "number")
  };
}
function hg(r, e) {
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    composition: {
      width: r,
      height: e,
      frameCount: 81,
      fps: 16,
      duration: 81 / 16,
      backgroundColor: "#000000"
    },
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
function ni(r, e) {
  if (!r.animated || r.keyframes.length === 0)
    return r.value;
  const n = r.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  let s = n[0], i = n[1];
  for (let c = 0; c < n.length - 1; c++)
    if (e >= n[c].frame && e <= n[c + 1].frame) {
      s = n[c], i = n[c + 1];
      break;
    }
  const o = i.frame - s.frame, a = e - s.frame;
  let l = o > 0 ? a / o : 0;
  switch (s.interpolation) {
    case "hold":
      return s.value;
    case "bezier":
      l = dg(l, s.outHandle, i.inHandle);
      break;
  }
  return pg(s.value, i.value, l);
}
function dg(r, e, n) {
  const s = e.x, i = e.y, o = 1 - n.x, a = 1 - n.y;
  let l = r;
  for (let c = 0; c < 8; c++) {
    const u = Mo(l, 0, s, o, 1), h = fg(l, 0, s, o, 1);
    if (Math.abs(h) < 1e-6) break;
    const f = u - r;
    l -= f / h, l = Math.max(0, Math.min(1, l));
  }
  return Mo(l, 0, i, a, 1);
}
function Mo(r, e, n, s, i) {
  const o = 1 - r;
  return o * o * o * e + 3 * o * o * r * n + 3 * o * r * r * s + r * r * r * i;
}
function fg(r, e, n, s, i) {
  const o = 1 - r;
  return 3 * o * o * (n - e) + 6 * o * r * (s - n) + 3 * r * r * (i - s);
}
function pg(r, e, n) {
  return typeof r == "number" && typeof e == "number" ? r + (e - r) * n : typeof r == "object" && r !== null && "x" in r && "y" in r && typeof e == "object" && e !== null && "x" in e && "y" in e ? {
    x: r.x + (e.x - r.x) * n,
    y: r.y + (e.y - r.y) * n
  } : typeof r == "string" && typeof e == "string" && r.startsWith("#") && e.startsWith("#") ? mg(r, e, n) : n < 0.5 ? r : e;
}
function mg(r, e, n) {
  const s = parseInt(r.slice(1, 3), 16), i = parseInt(r.slice(3, 5), 16), o = parseInt(r.slice(5, 7), 16), a = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), c = parseInt(e.slice(5, 7), 16), u = Math.round(s + (a - s) * n), h = Math.round(i + (l - i) * n), f = Math.round(o + (c - o) * n);
  return `#${u.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}${f.toString(16).padStart(2, "0")}`;
}
const Oo = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
};
function gg(r, e, n) {
  const s = e.x, i = e.y, o = 1 - n.x, a = 1 - n.y;
  return {
    x: Mo(r, 0, s, o, 1),
    y: Mo(r, 0, i, a, 1)
  };
}
function vg(r, e) {
  const n = Math.max(0, Math.min(1, r));
  return gg(n, e.outHandle, e.inHandle).y;
}
class yg {
  constructor(e) {
    Lt(this, "analysis");
    Lt(this, "mappings", /* @__PURE__ */ new Map());
    Lt(this, "smoothedValues", /* @__PURE__ */ new Map());
    Lt(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const s = this.mappings.get(e);
    s && Object.assign(s, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && cg(this.peakData, n) ? 1 : 0 : ol(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const s = this.mappings.get(e);
    if (!s || !s.enabled) return 0;
    let i = this.getFeatureAtFrame(s.feature, n);
    i < s.threshold && (i = 0), s.invert && (i = 1 - i), i *= s.sensitivity, i += s.offset, i = Math.max(s.min, Math.min(s.max, i));
    const a = (this.smoothedValues.get(e) || 0) * s.smoothing + i * (1 - s.smoothing);
    return this.smoothedValues.set(e, a), a;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const s of this.mappings.values()) {
      if (!s.enabled) continue;
      const i = this.getValueAtFrame(s.id, e), o = n.get(s.target);
      o !== void 0 ? n.set(s.target, o + i) : n.set(s.target, i);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of this.mappings.values()) {
      if (!i.enabled || i.targetLayerId && i.targetLayerId !== e) continue;
      const o = this.getValueAtFrame(i.id, n), a = s.get(i.target);
      a !== void 0 ? s.set(i.target, a + o) : s.set(i.target, o);
    }
    return s;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
const bg = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class _g {
  // For amplitude mode release tracking
  constructor(e = {}) {
    Lt(this, "config");
    Lt(this, "state");
    Lt(this, "pathSegments", []);
    Lt(this, "totalLength", 0);
    Lt(this, "releaseState", 0);
    this.config = { ...bg, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], s = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let i = 0, o = 0;
    for (const a of s) {
      const l = a[0].toUpperCase(), c = a.slice(1).trim().split(/[\s,]+/).map(Number).filter((u) => !isNaN(u));
      switch (l) {
        case "M":
          i = c[0] || 0, o = c[1] || 0, n.push({
            type: "M",
            points: [i, o],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [i, o, c[0], c[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), i = c[0], o = c[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [i, o, c[0], c[1], c[2], c[3], c[4], c[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), i = c[4], o = c[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [i, o, c[0], c[1], c[2], c[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), i = c[2], o = c[3];
          break;
        case "Z":
          const u = n.find((h) => h.type === "M");
          u && n.push({
            type: "L",
            points: [i, o, u.points[0], u.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], s = e[3] - e[1];
    return Math.sqrt(n * n + s * s);
  }
  bezierLength(e, n) {
    let i = 0, o = e[0], a = e[1];
    for (let l = 1; l <= 20; l++) {
      const c = l / 20, { x: u, y: h } = this.getBezierPoint(e, c, n), f = u - o, m = h - a;
      i += Math.sqrt(f * f + m * m), o = u, a = h;
    }
    return i;
  }
  getBezierPoint(e, n, s) {
    if (s === 2) {
      const i = 1 - n;
      return {
        x: i * i * e[0] + 2 * i * n * e[2] + n * n * e[4],
        y: i * i * e[1] + 2 * i * n * e[3] + n * n * e[5]
      };
    } else {
      const i = 1 - n, o = i * i, a = n * n;
      return {
        x: o * i * e[0] + 3 * o * n * e[2] + 3 * i * a * e[4] + a * n * e[6],
        y: o * i * e[1] + 3 * o * n * e[3] + 3 * i * a * e[5] + a * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const s = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = s, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(s) : this.updateAccumulateMode(s, n);
    const i = this.getPositionOnPath(this.state.position);
    return this.state.x = i.x, this.state.y = i.y, this.state.angle = i.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const i = 1 - this.config.release * 0.95;
      this.releaseState *= i;
    }
    const s = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, s * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const s = e * this.config.sensitivity * 0.02 * this.state.direction;
    let i = this.state.position + s;
    i > 1 ? (i = 2 - i, this.state.direction = -1) : i < 0 && (i = -i, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, i));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const u of this.pathSegments)
      if (u.type !== "M" && e >= u.startT && e <= u.endT) {
        n = u;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const s = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let i, o, a, l;
    switch (n.type) {
      case "L":
        i = n.points[0] + (n.points[2] - n.points[0]) * s, o = n.points[1] + (n.points[3] - n.points[1]) * s, a = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const u = this.getBezierPoint(n.points, s, 2);
        i = u.x, o = u.y;
        const h = 1 - s;
        a = 2 * h * (n.points[2] - n.points[0]) + 2 * s * (n.points[4] - n.points[2]), l = 2 * h * (n.points[3] - n.points[1]) + 2 * s * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const u = this.getBezierPoint(n.points, s, 3);
        i = u.x, o = u.y;
        const h = 1 - s, f = h * h, m = s * s;
        a = 3 * f * (n.points[2] - n.points[0]) + 6 * h * s * (n.points[4] - n.points[2]) + 3 * m * (n.points[6] - n.points[4]), l = 3 * f * (n.points[3] - n.points[1]) + 6 * h * s * (n.points[5] - n.points[3]) + 3 * m * (n.points[7] - n.points[5]);
        break;
      }
      default:
        i = 0, o = 0, a = 1, l = 0;
    }
    const c = Math.atan2(l, a);
    return { x: i, y: o, angle: c };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], s = this.state.previousPosition, i = this.state.position;
    for (let o = 0; o <= e; o++) {
      const a = s + (i - s) * (o / e), l = this.getPositionOnPath(a), c = o / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: c });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
const qe = /* @__PURE__ */ qm("compositor", {
  state: () => ({
    project: hg(1024, 1024),
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    currentTool: "select",
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map()
  }),
  getters: {
    // Project info
    hasProject: (r) => r.sourceImage !== null,
    width: (r) => r.project.composition.width,
    height: (r) => r.project.composition.height,
    frameCount: (r) => r.project.composition.frameCount,
    fps: (r) => r.project.composition.fps,
    duration: (r) => r.project.composition.duration,
    // Current frame
    currentFrame: (r) => r.project.currentFrame,
    currentTime: (r) => r.project.currentFrame / r.project.composition.fps,
    // Layers
    layers: (r) => r.project.layers,
    visibleLayers: (r) => r.project.layers.filter((e) => e.visible),
    // Selection
    selectedLayers: (r) => r.project.layers.filter((e) => r.selectedLayerIds.includes(e.id)),
    selectedLayer: (r) => r.selectedLayerIds.length !== 1 ? null : r.project.layers.find((e) => e.id === r.selectedLayerIds[0]) || null,
    // Assets
    assets: (r) => r.project.assets,
    // History
    canUndo: (r) => r.historyIndex > 0,
    canRedo: (r) => r.historyIndex < r.historyStack.length - 1
  },
  actions: {
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(r) {
      this.comfyuiNodeId = r.node_id, this.sourceImage = r.source_image, this.depthMap = r.depth_map, this.project.composition.width = r.width, this.project.composition.height = r.height, this.project.composition.frameCount = r.frame_count, this.project.composition.duration = r.frame_count / this.project.composition.fps, r.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: r.node_id,
        width: r.width,
        height: r.height,
        data: r.source_image
      }), r.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: r.node_id,
        width: r.width,
        height: r.height,
        data: r.depth_map
      }), this.project.currentFrame = 0, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[Weyl] Loaded inputs from ComfyUI:", {
        width: r.width,
        height: r.height,
        frameCount: r.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(r, e) {
      const s = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: e || `${r.charAt(0).toUpperCase() + r.slice(1)} ${this.project.layers.length + 1}`,
        type: r,
        visible: !0,
        locked: !1,
        solo: !1,
        inPoint: 0,
        outPoint: this.project.composition.frameCount - 1,
        parentId: null,
        blendMode: "normal",
        opacity: sn("opacity", 100, "number"),
        transform: ug(),
        properties: [],
        data: null
      };
      return this.project.layers.unshift(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), s;
    },
    /**
     * Delete a layer
     */
    deleteLayer(r) {
      const e = this.project.layers.findIndex((n) => n.id === r);
      e !== -1 && (this.project.layers.splice(e, 1), this.selectedLayerIds = this.selectedLayerIds.filter((n) => n !== r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update layer properties
     */
    updateLayer(r, e) {
      const n = this.project.layers.find((s) => s.id === r);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder layers
     */
    moveLayer(r, e) {
      const n = this.project.layers.findIndex((i) => i.id === r);
      if (n === -1) return;
      const [s] = this.project.layers.splice(n, 1);
      this.project.layers.splice(e, 0, s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(r, e = !1) {
      e ? this.selectedLayerIds.includes(r) || this.selectedLayerIds.push(r) : this.selectedLayerIds = [r];
    },
    deselectLayer(r) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== r);
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [];
    },
    /**
     * Playback controls
     */
    play() {
      this.isPlaying || (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = this.project.currentFrame, this.playbackLoop());
    },
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const r = performance.now() - (this.playbackStartTime || 0), e = this.project.composition.fps, n = this.project.composition.frameCount, s = Math.floor(r / 1e3 * e);
      let i = this.playbackStartFrame + s;
      i >= n && (i = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), this.project.currentFrame = i, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    setFrame(r) {
      this.project.currentFrame = Math.max(0, Math.min(r, this.project.composition.frameCount - 1));
    },
    nextFrame() {
      this.project.currentFrame < this.project.composition.frameCount - 1 && this.project.currentFrame++;
    },
    prevFrame() {
      this.project.currentFrame > 0 && this.project.currentFrame--;
    },
    goToStart() {
      this.project.currentFrame = 0;
    },
    goToEnd() {
      this.project.currentFrame = this.project.composition.frameCount - 1;
    },
    /**
     * Tool selection
     */
    setTool(r) {
      this.currentTool = r;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const r = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(r), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(r) {
      try {
        const e = JSON.parse(r);
        this.project = e, this.pushHistory();
      } catch (e) {
        console.error("[Weyl] Failed to import project:", e);
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(r) {
      return ni(r, this.project.currentFrame);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(r, e, n) {
      const s = this.project.layers.find((l) => l.id === r);
      if (!s) return null;
      let i;
      if (e === "position" ? i = s.transform.position : e === "scale" ? i = s.transform.scale : e === "rotation" ? i = s.transform.rotation : e === "opacity" ? i = s.opacity : i = s.properties.find((l) => l.name === e), !i) return null;
      i.animated = !0;
      const o = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: this.project.currentFrame,
        value: n,
        interpolation: "bezier",
        inHandle: { x: 0.33, y: 0.33 },
        outHandle: { x: 0.33, y: 0.33 },
        handlesBroken: !1
      }, a = i.keyframes.findIndex((l) => l.frame === this.project.currentFrame);
      return a >= 0 ? i.keyframes[a] = o : (i.keyframes.push(o), i.keyframes.sort((l, c) => l.frame - c.frame)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), o;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(r, e, n) {
      const s = this.project.layers.find((a) => a.id === r);
      if (!s) return;
      let i;
      if (e === "position" ? i = s.transform.position : e === "scale" ? i = s.transform.scale : e === "rotation" ? i = s.transform.rotation : e === "opacity" ? i = s.opacity : i = s.properties.find((a) => a.name === e), !i) return;
      const o = i.keyframes.findIndex((a) => a.id === n);
      o >= 0 && (i.keyframes.splice(o, 1), i.keyframes.length === 0 && (i.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(r = "Text") {
      const e = this.createLayer("text", r.substring(0, 20)), n = {
        text: r,
        fontFamily: "Arial",
        fontSize: 48,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        pathLayerId: null,
        pathOffset: 0,
        pathAlign: "left"
      };
      return e.data = n, e.properties.push(sn("fontSize", 48, "number")), e.properties.push(sn("pathOffset", 0, "number")), e.properties.push(sn("letterSpacing", 0, "number")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const r = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return r.data = e, r;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const r = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return r.data = e, r;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(r, e) {
      const n = this.project.layers.find((i) => i.id === r);
      if (!n || n.type !== "particles") return;
      const s = n.data;
      Object.assign(s, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(r, e) {
      const n = this.project.layers.find((i) => i.id === r);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(r, e, n) {
      const s = this.project.layers.find((a) => a.id === r);
      if (!s || s.type !== "particles") return;
      const o = s.data.emitters.find((a) => a.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(r, e) {
      const n = this.project.layers.find((i) => i.id === r);
      if (!n || n.type !== "particles") return;
      const s = n.data;
      s.emitters = s.emitters.filter((i) => i.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(r = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), s = {
        sourceLayerId: r,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: sn("zoom", 1, "number"),
        animatedOffsetX: sn("offsetX", 0, "number"),
        animatedOffsetY: sn("offsetY", 0, "number"),
        animatedRotation: sn("rotation", 0, "number"),
        animatedDepthScale: sn("depthScale", 1, "number")
      };
      return n.data = s, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(r, e) {
      const n = this.project.layers.find((i) => i.id === r);
      if (!n || n.type !== "depthflow") return;
      const s = n.data;
      Object.assign(s.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file for analysis
     */
    async loadAudio(r) {
      try {
        this.audioFile = r, this.audioBuffer = await Jm(r), this.audioAnalysis = await Qm(this.audioBuffer, this.project.composition.fps), this.initializeAudioReactiveMapper(), console.log("[Weyl] Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        console.error("[Weyl] Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null;
      }
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(r, e) {
      return this.audioAnalysis ? ol(this.audioAnalysis, r, e ?? this.project.currentFrame) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(r, e) {
      const n = this.audioMappings.get(r) || [];
      n.push(e), this.audioMappings.set(r, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(r, e) {
      const n = this.audioMappings.get(r);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(r));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(r) {
      return this.audioMappings.get(r) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(r) {
      this.peakData = r, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(r);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(r) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = lg(e, r);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(r) {
      this.audioReactiveMappings.push(r), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(r);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(r) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === r);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(r);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(r, e) {
      const n = this.audioReactiveMappings.find((s) => s.id === r);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(r, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(r, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(r, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(r) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(r ?? this.project.currentFrame) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(r) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === r || e.targetLayerId === void 0)
      );
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      return this.audioAnalysis ? jc(this.audioAnalysis, this.project.currentFrame) : !1;
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(r, e = {}) {
      const n = new _g(e);
      this.pathAnimators.set(r, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(r, e) {
      const n = this.pathAnimators.get(r);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(r, e) {
      const n = this.pathAnimators.get(r);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(r) {
      this.pathAnimators.delete(r);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(r) {
      return this.pathAnimators.get(r);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      if (!this.audioAnalysis) return;
      const r = this.project.currentFrame, e = ol(this.audioAnalysis, "amplitude", r), n = jc(this.audioAnalysis, r);
      for (const [s, i] of this.pathAnimators)
        i.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const r of this.pathAnimators.values())
        r.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new yg(this.audioAnalysis);
        for (const r of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(r);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    }
  }
});
async function Bc(r) {
  try {
    const e = await r.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function xg() {
  if ("gpu" in navigator)
    try {
      const s = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (s) {
        let i = "";
        if ("info" in s) {
          const o = s.info;
          i = (o == null ? void 0 : o.device) || (o == null ? void 0 : o.description) || "";
        }
        return i.includes("RTX 50") || i.toLowerCase().includes("blackwell") || i.includes("B100") || i.includes("B200") ? {
          tier: "blackwell",
          vram: await Bc(s),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await Bc(s),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      console.warn("[Weyl] WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), s = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return console.log("[Weyl] WebGL renderer:", s), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const wg = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function Sg(r, e, n) {
  const s = e / 2, i = n / 2;
  return {
    id: r,
    name: "Camera 1",
    type: "two-node",
    position: { x: s, y: i, z: -1500 },
    pointOfInterest: { x: s, y: i, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function Cg() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
const kg = { class: "project-panel" }, Tg = { class: "panel-header" }, Mg = { class: "header-actions" }, Og = {
  key: 0,
  class: "search-bar"
}, Eg = { class: "panel-content" }, Pg = { class: "folder-tree" }, Dg = ["onClick", "onDblclick"], Ag = ["onClick"], Fg = { class: "folder-name" }, Ig = { class: "item-count" }, Lg = {
  key: 0,
  class: "folder-contents"
}, Rg = ["onClick", "onDblclick", "onDragstart"], zg = { class: "item-icon" }, jg = { class: "item-name" }, Bg = { class: "item-info" }, Vg = ["onClick", "onDblclick", "onDragstart"], $g = { class: "item-icon" }, Ng = { class: "item-name" }, Wg = { class: "item-info" }, Ug = {
  key: 0,
  class: "empty-state"
}, Hg = {
  key: 1,
  class: "panel-footer"
}, Xg = { class: "item-details" }, Gg = { class: "detail-label" }, Yg = { class: "detail-info" }, Kg = /* @__PURE__ */ ye({
  __name: "ProjectPanel",
  setup(r) {
    qe();
    const e = ut(!1), n = ut(""), s = ut(null), i = ut(["compositions", "footage"]), o = ut([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), a = ut([]), l = St(() => {
      if (!n.value) return o.value;
      const g = n.value.toLowerCase();
      return o.value.map((C) => ({
        ...C,
        items: C.items.filter(
          (x) => x.name.toLowerCase().includes(g)
        )
      })).filter((C) => C.items.length > 0 || C.name.toLowerCase().includes(g));
    }), c = St(() => {
      if (!n.value) return a.value;
      const g = n.value.toLowerCase();
      return a.value.filter(
        (C) => C.name.toLowerCase().includes(g)
      );
    }), u = St(() => {
      if (!s.value) return null;
      for (const C of o.value) {
        const x = C.items.find((k) => k.id === s.value);
        if (x)
          return {
            name: x.name,
            info: v(x)
          };
      }
      const g = a.value.find((C) => C.id === s.value);
      return g ? {
        name: g.name,
        info: v(g)
      } : null;
    });
    function h(g) {
      const C = i.value.indexOf(g);
      C >= 0 ? i.value.splice(C, 1) : i.value.push(g);
    }
    function f(g) {
      s.value = g;
    }
    function m(g) {
      g.type === "composition" && console.log("Opening composition:", g.name);
    }
    function p() {
      console.log("Create new item");
    }
    function y(g) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[g] || "";
    }
    function v(g) {
      if (g.type === "composition" || g.type === "footage") {
        const C = [];
        if (g.width && g.height && C.push(`${g.width}${g.height}`), g.fps && C.push(`${g.fps}fps`), g.duration) {
          const x = g.duration / (g.fps || 30);
          C.push(`${x.toFixed(1)}s`);
        }
        return C.join("  ");
      }
      return "";
    }
    function _(g, C) {
      var x;
      (x = C.dataTransfer) == null || x.setData("application/project-item", JSON.stringify(g));
    }
    return (g, C) => (H(), G("div", kg, [
      d("div", Tg, [
        C[2] || (C[2] = d("span", { class: "panel-title" }, "Project", -1)),
        d("div", Mg, [
          d("button", {
            onClick: p,
            title: "New Item"
          }, "+"),
          d("button", {
            onClick: C[0] || (C[0] = (x) => e.value = !e.value),
            title: "Search"
          }, "")
        ])
      ]),
      e.value ? (H(), G("div", Og, [
        Wt(d("input", {
          type: "text",
          "onUpdate:modelValue": C[1] || (C[1] = (x) => n.value = x),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [ge, n.value]
        ])
      ])) : xt("", !0),
      d("div", Eg, [
        d("div", Pg, [
          (H(!0), G(Dt, null, jt(l.value, (x) => (H(), G("div", {
            key: x.id,
            class: "folder-item"
          }, [
            d("div", {
              class: wt(["folder-header", { selected: s.value === x.id }]),
              onClick: (k) => f(x.id),
              onDblclick: (k) => h(x.id)
            }, [
              d("span", {
                class: "expand-icon",
                onClick: Bt((k) => h(x.id), ["stop"])
              }, ct(i.value.includes(x.id) ? "" : ""), 9, Ag),
              C[3] || (C[3] = d("span", { class: "folder-icon" }, "", -1)),
              d("span", Fg, ct(x.name), 1),
              d("span", Ig, ct(x.items.length), 1)
            ], 42, Dg),
            i.value.includes(x.id) ? (H(), G("div", Lg, [
              (H(!0), G(Dt, null, jt(x.items, (k) => (H(), G("div", {
                key: k.id,
                class: wt(["project-item", { selected: s.value === k.id }]),
                onClick: (w) => f(k.id),
                onDblclick: (w) => m(k),
                draggable: "true",
                onDragstart: (w) => _(k, w)
              }, [
                d("span", zg, ct(y(k.type)), 1),
                d("span", jg, ct(k.name), 1),
                d("span", Bg, ct(v(k)), 1)
              ], 42, Rg))), 128))
            ])) : xt("", !0)
          ]))), 128)),
          (H(!0), G(Dt, null, jt(c.value, (x) => (H(), G("div", {
            key: x.id,
            class: wt(["project-item", { selected: s.value === x.id }]),
            onClick: (k) => f(x.id),
            onDblclick: (k) => m(x),
            draggable: "true",
            onDragstart: (k) => _(x, k)
          }, [
            d("span", $g, ct(y(x.type)), 1),
            d("span", Ng, ct(x.name), 1),
            d("span", Wg, ct(v(x)), 1)
          ], 42, Vg))), 128))
        ]),
        a.value.length === 0 ? (H(), G("div", Ug, [...C[4] || (C[4] = [
          d("p", null, "No items in project", -1),
          d("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : xt("", !0)
      ]),
      u.value ? (H(), G("div", Hg, [
        d("div", Xg, [
          d("span", Gg, ct(u.value.name), 1),
          d("span", Yg, ct(u.value.info), 1)
        ])
      ])) : xt("", !0)
    ]));
  }
}), we = (r, e) => {
  const n = r.__vccOpts || r;
  for (const [s, i] of e)
    n[s] = i;
  return n;
}, qg = /* @__PURE__ */ we(Kg, [["__scopeId", "data-v-44ad51d4"]]), Qh = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, Vc = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function Zg(r) {
  const e = Qh[r];
  return e ? {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: e.parameters.map((n, s) => ({
      ...n,
      id: `param-${s}`,
      value: n.defaultValue
    })),
    fragmentShader: e.fragmentShader
  } : null;
}
const Jg = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
], Qg = { class: "effects-panel" }, tv = { class: "panel-header" }, ev = { class: "header-actions" }, nv = { class: "panel-content" }, sv = { class: "tabs" }, iv = {
  key: 0,
  class: "effects-list"
}, rv = ["onClick"], ov = { class: "expand-icon" }, av = { class: "category-icon" }, lv = { class: "category-name" }, cv = { class: "effect-count" }, uv = {
  key: 0,
  class: "category-effects"
}, hv = ["onDblclick", "onDragstart"], dv = { class: "effect-name" }, fv = ["onClick", "title"], pv = {
  key: 1,
  class: "presets-list"
}, mv = ["onClick"], gv = { class: "expand-icon" }, vv = { class: "category-name" }, yv = { class: "preset-count" }, bv = {
  key: 0,
  class: "category-presets"
}, _v = ["onDblclick", "onDragstart"], xv = { class: "preset-info" }, wv = { class: "preset-name" }, Sv = { class: "preset-description" }, Cv = {
  key: 2,
  class: "favorites-list"
}, kv = {
  key: 0,
  class: "empty-favorites"
}, Tv = ["onDblclick", "onDragstart"], Mv = { class: "category-badge" }, Ov = { class: "effect-name" }, Ev = ["onClick"], Pv = /* @__PURE__ */ ye({
  __name: "EffectsPanel",
  setup(r) {
    const e = qe(), n = ut("effects"), s = ut(""), i = ut(["blur-sharpen", "color-correction"]), o = ut(["Fade", "Scale"]), a = ut([]);
    Ne(() => {
      const k = localStorage.getItem("effect-favorites");
      if (k)
        try {
          a.value = JSON.parse(k);
        } catch {
          a.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(a.value));
    }
    const c = St(() => Object.entries(Qh).map(([k, w]) => ({
      key: k,
      name: w.name,
      category: w.category,
      description: w.description
    }))), u = St(() => {
      const k = s.value.toLowerCase();
      return Object.entries(Vc).map(([w, T]) => {
        const P = c.value.filter((z) => !(z.category !== w || k && !z.name.toLowerCase().includes(k)));
        return {
          key: w,
          label: T.label,
          icon: T.icon,
          effects: P
        };
      }).filter((w) => w.effects.length > 0);
    }), h = St(() => {
      const k = s.value.toLowerCase(), w = {};
      for (const T of Jg)
        k && !T.name.toLowerCase().includes(k) || (w[T.category] || (w[T.category] = []), w[T.category].push(T));
      return Object.entries(w).map(([T, P]) => ({
        category: T,
        presets: P
      }));
    }), f = St(() => c.value.filter((k) => a.value.includes(k.key)));
    function m(k) {
      const w = i.value.indexOf(k);
      w >= 0 ? i.value.splice(w, 1) : i.value.push(k);
    }
    function p(k) {
      const w = o.value.indexOf(k);
      w >= 0 ? o.value.splice(w, 1) : o.value.push(k);
    }
    function y(k) {
      const w = a.value.indexOf(k);
      w >= 0 ? a.value.splice(w, 1) : a.value.push(k), l();
    }
    function v(k) {
      var w;
      return ((w = Vc[k]) == null ? void 0 : w.icon) || "?";
    }
    function _(k) {
      const w = Zg(k);
      if (!w) return;
      const T = e.selectedLayer;
      if (!T) {
        console.warn("No layer selected to apply effect");
        return;
      }
      T.effects || (T.effects = []), T.effects.push(w);
    }
    function g(k) {
      if (!e.selectedLayer) {
        console.warn("No layer selected to apply preset");
        return;
      }
      console.log("Applying preset:", k.name);
    }
    function C(k, w) {
      var T;
      (T = w.dataTransfer) == null || T.setData("application/effect", k);
    }
    function x(k, w) {
      var T;
      (T = w.dataTransfer) == null || T.setData("application/preset", JSON.stringify(k));
    }
    return (k, w) => (H(), G("div", Qg, [
      d("div", tv, [
        w[4] || (w[4] = d("span", { class: "panel-title" }, "Effects & Presets", -1)),
        d("div", ev, [
          Wt(d("input", {
            type: "text",
            "onUpdate:modelValue": w[0] || (w[0] = (T) => s.value = T),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [ge, s.value]
          ])
        ])
      ]),
      d("div", nv, [
        d("div", sv, [
          d("button", {
            class: wt({ active: n.value === "effects" }),
            onClick: w[1] || (w[1] = (T) => n.value = "effects")
          }, " Effects ", 2),
          d("button", {
            class: wt({ active: n.value === "presets" }),
            onClick: w[2] || (w[2] = (T) => n.value = "presets")
          }, " Presets ", 2),
          d("button", {
            class: wt({ active: n.value === "favorites" }),
            onClick: w[3] || (w[3] = (T) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? (H(), G("div", iv, [
          (H(!0), G(Dt, null, jt(u.value, (T) => (H(), G("div", {
            key: T.key,
            class: "effect-category"
          }, [
            d("div", {
              class: "category-header",
              onClick: (P) => m(T.key)
            }, [
              d("span", ov, ct(i.value.includes(T.key) ? "" : ""), 1),
              d("span", av, ct(T.icon), 1),
              d("span", lv, ct(T.label), 1),
              d("span", cv, ct(T.effects.length), 1)
            ], 8, rv),
            i.value.includes(T.key) ? (H(), G("div", uv, [
              (H(!0), G(Dt, null, jt(T.effects, (P) => (H(), G("div", {
                key: P.key,
                class: wt(["effect-item", { favorite: a.value.includes(P.key) }]),
                onDblclick: (z) => _(P.key),
                onDragstart: (z) => C(P.key, z),
                draggable: "true"
              }, [
                d("span", dv, ct(P.name), 1),
                d("button", {
                  class: "favorite-btn",
                  onClick: Bt((z) => y(P.key), ["stop"]),
                  title: a.value.includes(P.key) ? "Remove from favorites" : "Add to favorites"
                }, ct(a.value.includes(P.key) ? "" : ""), 9, fv)
              ], 42, hv))), 128))
            ])) : xt("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? (H(), G("div", pv, [
          (H(!0), G(Dt, null, jt(h.value, (T) => (H(), G("div", {
            key: T.category,
            class: "preset-category"
          }, [
            d("div", {
              class: "category-header",
              onClick: (P) => p(T.category)
            }, [
              d("span", gv, ct(o.value.includes(T.category) ? "" : ""), 1),
              d("span", vv, ct(T.category), 1),
              d("span", yv, ct(T.presets.length), 1)
            ], 8, mv),
            o.value.includes(T.category) ? (H(), G("div", bv, [
              (H(!0), G(Dt, null, jt(T.presets, (P) => (H(), G("div", {
                key: P.id,
                class: "preset-item",
                onDblclick: (z) => g(P),
                onDragstart: (z) => x(P, z),
                draggable: "true"
              }, [
                w[5] || (w[5] = d("div", { class: "preset-preview" }, [
                  d("span", { class: "preview-icon" }, "")
                ], -1)),
                d("div", xv, [
                  d("span", wv, ct(P.name), 1),
                  d("span", Sv, ct(P.description), 1)
                ])
              ], 40, _v))), 128))
            ])) : xt("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? (H(), G("div", Cv, [
          f.value.length === 0 ? (H(), G("div", kv, [...w[6] || (w[6] = [
            d("p", null, "No favorites yet", -1),
            d("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : xt("", !0),
          (H(!0), G(Dt, null, jt(f.value, (T) => (H(), G("div", {
            key: T.key,
            class: "effect-item",
            onDblclick: (P) => _(T.key),
            onDragstart: (P) => C(T.key, P),
            draggable: "true"
          }, [
            d("span", Mv, ct(v(T.category)), 1),
            d("span", Ov, ct(T.name), 1),
            d("button", {
              class: "favorite-btn active",
              onClick: Bt((P) => y(T.key), ["stop"])
            }, "  ", 8, Ev)
          ], 40, Tv))), 128))
        ])) : xt("", !0)
      ]),
      w[7] || (w[7] = d("div", { class: "panel-footer" }, [
        d("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), Dv = /* @__PURE__ */ we(Pv, [["__scopeId", "data-v-b66ebaa1"]]), Av = ["value", "min", "max", "step", "disabled"], Fv = {
  key: 1,
  class: "scrub-unit"
}, Iv = /* @__PURE__ */ ye({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = ut(!1), o = ut(0), a = ut(0), l = St(() => n.default ?? n.modelValue), c = St(() => n.default !== void 0), u = St(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function h(x) {
      return Math.max(n.min, Math.min(n.max, x));
    }
    function f(x) {
      const k = Math.pow(10, n.precision);
      return Math.round(x * k) / k;
    }
    function m(x) {
      n.disabled || (i.value = !0, o.value = x.clientX, a.value = n.modelValue, document.addEventListener("mousemove", p), document.addEventListener("mouseup", y), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function p(x) {
      const k = x.clientX - o.value;
      let w = n.sensitivity;
      x.shiftKey && (w *= 10), (x.ctrlKey || x.metaKey) && (w *= 0.1);
      const T = k * n.step * w * 0.5, P = f(h(a.value + T));
      P !== n.modelValue && s("update:modelValue", P);
    }
    function y() {
      i.value = !1, document.removeEventListener("mousemove", p), document.removeEventListener("mouseup", y), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function v(x) {
      const k = x.target, w = parseFloat(k.value);
      isNaN(w) || s("update:modelValue", f(h(w)));
    }
    function _(x) {
      if (n.disabled) return;
      let k = 0;
      x.key === "ArrowUp" ? k = n.step : x.key === "ArrowDown" && (k = -n.step), k !== 0 && (x.preventDefault(), x.shiftKey && (k *= 10), (x.ctrlKey || x.metaKey) && (k *= 0.1), s("update:modelValue", f(h(n.modelValue + k))));
    }
    function g(x) {
      const k = x.target, w = parseFloat(k.value);
      isNaN(w) && (k.value = u.value.toString());
    }
    function C() {
      n.default !== void 0 && s("update:modelValue", n.default);
    }
    return (x, k) => (H(), G("div", {
      class: wt(["scrubable-number", { disabled: r.disabled }])
    }, [
      r.label ? (H(), G("label", {
        key: 0,
        class: wt(["scrub-label", { scrubbing: i.value }]),
        onMousedown: m
      }, ct(r.label), 35)) : xt("", !0),
      d("input", {
        type: "number",
        class: "scrub-input",
        value: u.value,
        min: r.min,
        max: r.max,
        step: r.step,
        disabled: r.disabled,
        onInput: v,
        onKeydown: _,
        onBlur: g
      }, null, 40, Av),
      r.unit ? (H(), G("span", Fv, ct(r.unit), 1)) : xt("", !0),
      c.value && r.modelValue !== l.value ? (H(), G("button", {
        key: 2,
        class: "reset-btn",
        onClick: C,
        title: "Reset to default"
      }, [...k[0] || (k[0] = [
        d("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : xt("", !0)
    ], 2));
  }
}), re = /* @__PURE__ */ we(Iv, [["__scopeId", "data-v-2a930cf0"]]), Lv = ["value", "min", "max", "step", "disabled"], Rv = {
  key: 2,
  class: "slider-unit"
}, zv = /* @__PURE__ */ ye({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = ut(null), o = ut(!1), a = ut(!1), l = ut(0), c = ut(0), u = St(() => {
      const T = n.max - n.min;
      return T === 0 ? 0 : (n.modelValue - n.min) / T * 100;
    }), h = St(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function f(T) {
      return Math.max(n.min, Math.min(n.max, T));
    }
    function m(T) {
      const P = Math.pow(10, n.precision);
      return Math.round(T * P) / P;
    }
    function p(T) {
      n.disabled || (o.value = !0, l.value = T.clientX, c.value = n.modelValue, document.addEventListener("mousemove", y), document.addEventListener("mouseup", v), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function y(T) {
      const P = T.clientX - l.value, z = n.max - n.min;
      let j = 1;
      T.shiftKey && (j *= 10), (T.ctrlKey || T.metaKey) && (j *= 0.1);
      const ot = P / 200 * z * j, vt = m(f(c.value + ot));
      vt !== n.modelValue && s("update:modelValue", vt);
    }
    function v() {
      o.value = !1, document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", v), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function _(T) {
      if (n.disabled || !i.value) return;
      const P = i.value.getBoundingClientRect(), z = (T.clientX - P.left) / P.width, j = n.min + z * (n.max - n.min);
      s("update:modelValue", m(f(j)));
    }
    function g(T) {
      n.disabled || (a.value = !0, document.addEventListener("mousemove", C), document.addEventListener("mouseup", x), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function C(T) {
      if (!i.value) return;
      const P = i.value.getBoundingClientRect(), z = (T.clientX - P.left) / P.width, j = n.min + Math.max(0, Math.min(1, z)) * (n.max - n.min);
      s("update:modelValue", m(f(j)));
    }
    function x() {
      a.value = !1, document.removeEventListener("mousemove", C), document.removeEventListener("mouseup", x), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function k(T) {
      const P = T.target, z = parseFloat(P.value);
      isNaN(z) || s("update:modelValue", m(f(z)));
    }
    function w(T) {
      const P = T.target, z = parseFloat(P.value);
      isNaN(z) && (P.value = h.value.toString());
    }
    return (T, P) => (H(), G("div", {
      class: wt(["slider-input", { disabled: r.disabled }])
    }, [
      r.label ? (H(), G("label", {
        key: 0,
        class: wt(["slider-label", { scrubbing: o.value }]),
        onMousedown: p
      }, ct(r.label), 35)) : xt("", !0),
      d("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: i,
        onMousedown: _
      }, [
        d("div", {
          class: "slider-fill",
          style: ne({ width: u.value + "%", background: r.gradient || void 0 })
        }, null, 4),
        d("div", {
          class: "slider-thumb",
          style: ne({ left: u.value + "%" }),
          onMousedown: Bt(g, ["stop"])
        }, null, 36)
      ], 544),
      r.showValue ? (H(), G("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: h.value,
        min: r.min,
        max: r.max,
        step: r.step,
        disabled: r.disabled,
        onInput: k,
        onBlur: w
      }, null, 40, Lv)) : xt("", !0),
      r.unit ? (H(), G("span", Rv, ct(r.unit), 1)) : xt("", !0)
    ], 2));
  }
}), We = /* @__PURE__ */ we(zv, [["__scopeId", "data-v-9dd40416"]]), jv = { class: "dial-marks" }, Bv = {
  key: 0,
  class: "angle-value"
}, Vv = ["value", "disabled"], $v = /* @__PURE__ */ ye({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = ut(null), o = ut(!1), a = St(() => Math.round(n.modelValue * 10) / 10);
    function l(y) {
      return (y % 360 + 360) % 360;
    }
    function c(y) {
      n.disabled || (o.value = !0, h(y), document.addEventListener("mousemove", u), document.addEventListener("mouseup", f), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function u(y) {
      o.value && h(y);
    }
    function h(y) {
      if (!i.value) return;
      const v = i.value.getBoundingClientRect(), _ = v.left + v.width / 2, g = v.top + v.height / 2, C = y.clientX - _, x = y.clientY - g;
      let k = Math.atan2(C, -x) * (180 / Math.PI);
      k = l(k), y.shiftKey && (k = Math.round(k / 45) * 45), s("update:modelValue", k);
    }
    function f() {
      o.value = !1, document.removeEventListener("mousemove", u), document.removeEventListener("mouseup", f), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function m(y) {
      const v = y.target, _ = parseFloat(v.value);
      isNaN(_) || s("update:modelValue", l(_));
    }
    function p(y) {
      const v = y.target, _ = parseFloat(v.value);
      isNaN(_) && (v.value = a.value.toString());
    }
    return (y, v) => (H(), G("div", {
      class: wt(["angle-dial", { disabled: r.disabled }])
    }, [
      d("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: i,
        style: ne({ width: r.size + "px", height: r.size + "px" }),
        onMousedown: c
      }, [
        v[0] || (v[0] = d("div", { class: "dial-ring" }, null, -1)),
        v[1] || (v[1] = d("div", { class: "dial-center" }, null, -1)),
        d("div", {
          class: "dial-indicator",
          style: ne({ transform: `rotate(${r.modelValue}deg)` })
        }, null, 4),
        d("div", jv, [
          (H(), G(Dt, null, jt(8, (_) => d("div", {
            class: "dial-mark",
            key: _,
            style: ne({ transform: `rotate(${_ * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      r.showValue ? (H(), G("div", Bv, [
        d("input", {
          type: "number",
          class: "angle-input",
          value: a.value,
          disabled: r.disabled,
          onInput: m,
          onBlur: p
        }, null, 40, Vv),
        v[2] || (v[2] = d("span", { class: "angle-unit" }, "", -1))
      ])) : xt("", !0)
    ], 2));
  }
}), Nv = /* @__PURE__ */ we($v, [["__scopeId", "data-v-04a5caf6"]]), Ar = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], Fr = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class Wv {
  constructor() {
    Lt(this, "systemFonts", []);
    Lt(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    Lt(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const s of e)
        (!n.has(s.family) || s.style === "Regular") && n.set(s.family, {
          family: s.family,
          fullName: s.fullName,
          style: s.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((s, i) => s.family.localeCompare(i.family)), console.log(`[FontService] Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? console.log("[FontService] User denied font access permission") : console.error("[FontService] Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: Ar
    }), e.push({
      name: "Google Fonts",
      fonts: Fr.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return Ar.forEach((n) => e.add(n.family)), Fr.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const s = n.join(";"), i = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${s}&display=swap`, o = document.createElement("link");
    o.rel = "stylesheet", o.href = i, document.head.appendChild(o);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), console.log(`[FontService] Loaded Google Font: ${e}`);
    } catch (a) {
      console.error(`[FontService] Failed to load Google Font: ${e}`, a);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return Ar.some((n) => n.family === e) ? !0 : Fr.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", i = document.createElement("canvas").getContext("2d");
    i.font = "72px monospace";
    const o = i.measureText(n).width;
    i.font = `72px "${e}", monospace`;
    const a = i.measureText(n).width;
    return o !== a;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return Ar;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return Fr;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (console.log("[FontService] Local Font Access API not available"), !1);
  }
}
const dn = new Wv(), Uv = ["title"], Hv = /* @__PURE__ */ ye({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = qe(), o = St(() => n.property.animated ? n.property.keyframes.some((m) => m.frame === i.currentFrame) : !1), a = St(() => n.property.animated && n.property.keyframes.find((m) => m.frame === i.currentFrame) || null), l = St(() => o.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), c = St(() => o.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function u() {
      o.value ? f() : h();
    }
    function h() {
      const m = { x: 0.33, y: 0.33 }, p = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: i.currentFrame,
        value: n.property.value,
        interpolation: "bezier",
        inHandle: { ...m },
        outHandle: { ...m },
        handlesBroken: !1
      };
      n.property.animated || (n.property.animated = !0, s("animationToggled", !0)), n.property.keyframes.push(p), n.property.keyframes.sort((y, v) => y.frame - v.frame), s("keyframeAdded", p);
    }
    function f() {
      const m = a.value;
      if (!m) return;
      const p = n.property.keyframes.findIndex((y) => y.id === m.id);
      p >= 0 && (n.property.keyframes.splice(p, 1), s("keyframeRemoved", m.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, s("animationToggled", !1));
    }
    return (m, p) => (H(), G("button", {
      class: wt(["keyframe-toggle", {
        animated: r.property.animated,
        "has-keyframe": o.value
      }]),
      onClick: u,
      title: c.value
    }, [
      d("i", {
        class: wt(["pi", l.value])
      }, null, 2)
    ], 10, Uv));
  }
}), Ls = /* @__PURE__ */ we(Hv, [["__scopeId", "data-v-cb2aab3f"]]), Xv = { class: "font-picker" }, Gv = { class: "picker-header" }, Yv = { class: "search-row" }, Kv = { class: "font-categories" }, qv = ["onClick"], Zv = { class: "font-count" }, Jv = {
  key: 0,
  class: "category-fonts"
}, Qv = ["onClick"], t0 = { class: "font-source" }, e0 = { class: "preview-section" }, n0 = { class: "picker-actions" }, s0 = ["disabled"], i0 = /* @__PURE__ */ ye({
  __name: "FontPicker",
  props: {
    currentFont: {}
  },
  emits: ["select", "close"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = ut(null), o = ut(""), a = ut(n.currentFont), l = ut("The quick brown fox jumps over the lazy dog"), c = ut(/* @__PURE__ */ new Set(["Web Safe"])), u = ut([]), h = ut(null), f = St(() => {
      if (!o.value.trim())
        return u.value;
      const _ = o.value.toLowerCase();
      return u.value.map((g) => ({
        ...g,
        fonts: g.fonts.filter(
          (C) => C.family.toLowerCase().includes(_)
        )
      })).filter((g) => g.fonts.length > 0);
    });
    Ne(async () => {
      var _;
      await dn.initialize(), u.value = dn.getFontCategories(), h.value = dn.hasSystemFonts(), await ws(), (_ = i.value) == null || _.focus(), n.currentFont && await dn.ensureFont(n.currentFont);
    });
    function m(_) {
      c.value.has(_) ? c.value.delete(_) : c.value.add(_);
    }
    async function p(_) {
      a.value = _, await dn.ensureFont(_);
    }
    function y() {
      a.value && s("select", a.value);
    }
    async function v() {
      await dn.requestSystemFontAccess() && (u.value = dn.getFontCategories(), h.value = !0, c.value.add("System Fonts"));
    }
    return (_, g) => (H(), G("div", {
      class: "font-picker-overlay",
      onClick: g[4] || (g[4] = Bt((C) => s("close"), ["self"]))
    }, [
      d("div", Xv, [
        d("div", Gv, [
          g[6] || (g[6] = d("h3", null, "Select Font", -1)),
          d("button", {
            class: "close-btn",
            onClick: g[0] || (g[0] = (C) => s("close"))
          }, [...g[5] || (g[5] = [
            d("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        d("div", Yv, [
          g[7] || (g[7] = d("i", { class: "pi pi-search search-icon" }, null, -1)),
          Wt(d("input", {
            "onUpdate:modelValue": g[1] || (g[1] = (C) => o.value = C),
            type: "text",
            placeholder: "Search fonts...",
            class: "search-input",
            ref_key: "searchInputRef",
            ref: i
          }, null, 512), [
            [ge, o.value]
          ])
        ]),
        d("div", Kv, [
          (H(!0), G(Dt, null, jt(f.value, (C) => (H(), G("div", {
            key: C.name,
            class: "font-category"
          }, [
            d("div", {
              class: "category-header",
              onClick: (x) => m(C.name)
            }, [
              d("i", {
                class: wt(["pi", c.value.has(C.name) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              d("span", null, ct(C.name), 1),
              d("span", Zv, ct(C.fonts.length), 1)
            ], 8, qv),
            c.value.has(C.name) ? (H(), G("div", Jv, [
              (H(!0), G(Dt, null, jt(C.fonts, (x) => (H(), G("div", {
                key: x.family,
                class: wt(["font-item", { selected: x.family === r.currentFont }]),
                onClick: (k) => p(x.family)
              }, [
                d("span", {
                  class: "font-preview",
                  style: ne({ fontFamily: `'${x.family}', sans-serif` })
                }, ct(x.family), 5),
                d("span", t0, ct(x.source), 1)
              ], 10, Qv))), 128))
            ])) : xt("", !0)
          ]))), 128))
        ]),
        d("div", e0, [
          g[8] || (g[8] = d("label", null, "Preview:", -1)),
          d("div", {
            class: "preview-text",
            style: ne({ fontFamily: `'${a.value}', sans-serif` })
          }, ct(l.value), 5),
          Wt(d("input", {
            "onUpdate:modelValue": g[2] || (g[2] = (C) => l.value = C),
            type: "text",
            class: "preview-input",
            placeholder: "Type preview text..."
          }, null, 512), [
            [ge, l.value]
          ])
        ]),
        d("div", n0, [
          h.value === !1 ? (H(), G("button", {
            key: 0,
            class: "system-fonts-btn",
            onClick: v
          }, [...g[9] || (g[9] = [
            d("i", { class: "pi pi-desktop" }, null, -1),
            qt(" Load System Fonts ", -1)
          ])])) : xt("", !0),
          d("button", {
            class: "cancel-btn",
            onClick: g[3] || (g[3] = (C) => s("close"))
          }, "Cancel"),
          d("button", {
            class: "select-btn",
            onClick: y,
            disabled: !a.value
          }, " Select ", 8, s0)
        ])
      ])
    ]));
  }
}), r0 = /* @__PURE__ */ we(i0, [["__scopeId", "data-v-b3c36b6f"]]), o0 = { class: "text-properties" }, a0 = { class: "property-group" }, l0 = { class: "property-group" }, c0 = { class: "font-select-row" }, u0 = { label: "Web Safe" }, h0 = ["value"], d0 = { label: "Google Fonts" }, f0 = ["value"], p0 = { class: "property-group" }, m0 = { class: "property-header" }, g0 = { class: "slider-row" }, v0 = { class: "property-group" }, y0 = { class: "color-row" }, b0 = { class: "property-group" }, _0 = ["value"], x0 = {
  key: 0,
  class: "property-group"
}, w0 = { class: "property-header" }, S0 = { class: "slider-row" }, C0 = { class: "value-display" }, k0 = { class: "property-group" }, T0 = { class: "slider-row" }, M0 = /* @__PURE__ */ ye({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = qe(), o = ut(!1), a = ut([]), l = ut([]), c = St(() => n.layer.data || {
      text: "Text",
      fontFamily: "Arial",
      fontSize: 48,
      fontWeight: "400",
      fontStyle: "normal",
      fill: "#ffffff",
      stroke: "",
      strokeWidth: 0,
      letterSpacing: 0,
      lineHeight: 1.2,
      textAlign: "left",
      pathLayerId: null,
      pathOffset: 0,
      pathAlign: "left"
    }), u = St(() => i.layers.filter((w) => w.type === "spline" && w.id !== n.layer.id)), h = St(() => n.layer.properties.find((w) => w.name === "fontSize")), f = St(() => n.layer.properties.find((w) => w.name === "pathOffset")), m = St({
      get: () => (c.value.pathOffset || 0) * 100,
      set: (w) => {
        c.value.pathOffset = w / 100;
      }
    });
    Ne(async () => {
      await dn.initialize(), a.value = dn.getWebSafeFonts().map((w) => w.family), l.value = dn.getGoogleFonts();
    });
    function p() {
      s("update");
    }
    function y() {
      dn.ensureFont(c.value.fontFamily), s("update");
    }
    function v() {
      h.value && (h.value.value = c.value.fontSize), s("update");
    }
    function _() {
      s("update");
    }
    function g() {
      c.value.pathLayerId || (c.value.pathOffset = 0), s("update");
    }
    function C() {
      f.value && (f.value.value = c.value.pathOffset), s("update");
    }
    function x() {
      s("update");
    }
    function k(w) {
      c.value.fontFamily = w, o.value = !1, y();
    }
    return ae(() => n.layer, (w) => {
      w.type === "text" && (w.properties.find((T) => T.name === "fontSize") || w.properties.push({
        id: `prop_fontSize_${Date.now()}`,
        name: "fontSize",
        type: "number",
        value: c.value.fontSize,
        animated: !1,
        keyframes: []
      }), w.properties.find((T) => T.name === "pathOffset") || w.properties.push({
        id: `prop_pathOffset_${Date.now()}`,
        name: "pathOffset",
        type: "number",
        value: 0,
        animated: !1,
        keyframes: []
      }));
    }, { immediate: !0 }), (w, T) => (H(), G("div", o0, [
      T[21] || (T[21] = d("h4", null, "Text Properties", -1)),
      d("div", a0, [
        T[12] || (T[12] = d("label", null, "Text", -1)),
        Wt(d("textarea", {
          "onUpdate:modelValue": T[0] || (T[0] = (P) => c.value.text = P),
          class: "text-input",
          rows: "2",
          onInput: p
        }, null, 544), [
          [ge, c.value.text]
        ])
      ]),
      d("div", l0, [
        T[14] || (T[14] = d("label", null, "Font Family", -1)),
        d("div", c0, [
          Wt(d("select", {
            "onUpdate:modelValue": T[1] || (T[1] = (P) => c.value.fontFamily = P),
            class: "font-select",
            onChange: y
          }, [
            d("optgroup", u0, [
              (H(!0), G(Dt, null, jt(a.value, (P) => (H(), G("option", {
                key: P,
                value: P
              }, ct(P), 9, h0))), 128))
            ]),
            d("optgroup", d0, [
              (H(!0), G(Dt, null, jt(l.value, (P) => (H(), G("option", {
                key: P,
                value: P
              }, ct(P), 9, f0))), 128))
            ])
          ], 544), [
            [Kn, c.value.fontFamily]
          ]),
          d("button", {
            class: "picker-btn",
            onClick: T[2] || (T[2] = (P) => o.value = !0),
            title: "Browse fonts"
          }, [...T[13] || (T[13] = [
            d("i", { class: "pi pi-search" }, null, -1)
          ])])
        ])
      ]),
      d("div", p0, [
        d("div", m0, [
          T[15] || (T[15] = d("label", null, "Font Size", -1)),
          h.value ? (H(), ce(Ls, {
            key: 0,
            property: h.value,
            layerId: r.layer.id
          }, null, 8, ["property", "layerId"])) : xt("", !0)
        ]),
        d("div", g0, [
          Wt(d("input", {
            type: "range",
            "onUpdate:modelValue": T[3] || (T[3] = (P) => c.value.fontSize = P),
            min: 8,
            max: 200,
            class: "slider",
            onInput: v
          }, null, 544), [
            [
              ge,
              c.value.fontSize,
              void 0,
              { number: !0 }
            ]
          ]),
          Wt(d("input", {
            type: "number",
            "onUpdate:modelValue": T[4] || (T[4] = (P) => c.value.fontSize = P),
            min: 8,
            max: 200,
            class: "number-input",
            onChange: v
          }, null, 544), [
            [
              ge,
              c.value.fontSize,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      d("div", v0, [
        T[16] || (T[16] = d("label", null, "Fill Color", -1)),
        d("div", y0, [
          Wt(d("input", {
            type: "color",
            "onUpdate:modelValue": T[5] || (T[5] = (P) => c.value.fill = P),
            class: "color-input",
            onInput: _
          }, null, 544), [
            [ge, c.value.fill]
          ]),
          Wt(d("input", {
            type: "text",
            "onUpdate:modelValue": T[6] || (T[6] = (P) => c.value.fill = P),
            class: "color-text",
            onChange: _
          }, null, 544), [
            [ge, c.value.fill]
          ])
        ])
      ]),
      d("div", b0, [
        T[18] || (T[18] = d("label", null, "Attach to Path", -1)),
        Wt(d("select", {
          "onUpdate:modelValue": T[7] || (T[7] = (P) => c.value.pathLayerId = P),
          class: "path-select",
          onChange: g
        }, [
          T[17] || (T[17] = d("option", { value: null }, "None", -1)),
          (H(!0), G(Dt, null, jt(u.value, (P) => (H(), G("option", {
            key: P.id,
            value: P.id
          }, ct(P.name), 9, _0))), 128))
        ], 544), [
          [Kn, c.value.pathLayerId]
        ])
      ]),
      c.value.pathLayerId ? (H(), G("div", x0, [
        d("div", w0, [
          T[19] || (T[19] = d("label", null, "Path Offset", -1)),
          f.value ? (H(), ce(Ls, {
            key: 0,
            property: f.value,
            layerId: r.layer.id
          }, null, 8, ["property", "layerId"])) : xt("", !0)
        ]),
        d("div", S0, [
          Wt(d("input", {
            type: "range",
            "onUpdate:modelValue": T[8] || (T[8] = (P) => m.value = P),
            min: 0,
            max: 100,
            class: "slider",
            onInput: C
          }, null, 544), [
            [
              ge,
              m.value,
              void 0,
              { number: !0 }
            ]
          ]),
          d("span", C0, ct(Math.round(m.value)) + "%", 1)
        ])
      ])) : xt("", !0),
      d("div", k0, [
        T[20] || (T[20] = d("label", null, "Letter Spacing", -1)),
        d("div", T0, [
          Wt(d("input", {
            type: "range",
            "onUpdate:modelValue": T[9] || (T[9] = (P) => c.value.letterSpacing = P),
            min: -20,
            max: 50,
            class: "slider",
            onInput: x
          }, null, 544), [
            [
              ge,
              c.value.letterSpacing,
              void 0,
              { number: !0 }
            ]
          ]),
          Wt(d("input", {
            type: "number",
            "onUpdate:modelValue": T[10] || (T[10] = (P) => c.value.letterSpacing = P),
            class: "number-input",
            onChange: x
          }, null, 544), [
            [
              ge,
              c.value.letterSpacing,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      o.value ? (H(), ce(r0, {
        key: 1,
        "current-font": c.value.fontFamily,
        onSelect: k,
        onClose: T[11] || (T[11] = (P) => o.value = !1)
      }, null, 8, ["current-font"])) : xt("", !0)
    ]));
  }
}), O0 = /* @__PURE__ */ we(M0, [["__scopeId", "data-v-39d880c9"]]), E0 = { class: "particle-properties" }, P0 = { class: "property-section" }, D0 = {
  key: 0,
  class: "section-content"
}, A0 = { class: "property-row" }, F0 = ["value"], I0 = { class: "value-display" }, L0 = { class: "property-row" }, R0 = ["value"], z0 = { class: "value-display" }, j0 = { class: "property-row" }, B0 = ["value"], V0 = { class: "value-display" }, $0 = { class: "property-row" }, N0 = ["value"], W0 = { class: "value-display" }, U0 = { class: "property-row" }, H0 = ["value"], X0 = { class: "value-display" }, G0 = { class: "property-row" }, Y0 = ["value"], K0 = { class: "property-section" }, q0 = {
  key: 0,
  class: "section-content"
}, Z0 = ["onClick"], J0 = ["value", "onInput"], Q0 = { class: "enabled-toggle" }, ty = ["checked", "onChange"], ey = ["onClick"], ny = {
  key: 0,
  class: "emitter-content"
}, sy = { class: "property-row" }, iy = ["value", "onInput"], ry = { class: "value-display" }, oy = { class: "property-row" }, ay = ["value", "onInput"], ly = { class: "value-display" }, cy = { class: "property-row" }, uy = ["value", "onInput"], hy = { class: "value-display" }, dy = { class: "property-row" }, fy = ["value", "onInput"], py = { class: "value-display" }, my = { class: "property-row" }, gy = ["value", "onInput"], vy = { class: "value-display" }, yy = { class: "property-row" }, by = ["value", "onInput"], _y = { class: "value-display" }, xy = { class: "property-row" }, wy = ["value", "onInput"], Sy = { class: "value-display" }, Cy = { class: "property-row" }, ky = ["value", "onInput"], Ty = { class: "value-display" }, My = { class: "property-row" }, Oy = ["value", "onInput"], Ey = { class: "property-row" }, Py = ["value", "onInput"], Dy = { class: "value-display" }, Ay = { class: "property-row" }, Fy = ["value", "onInput"], Iy = { class: "value-display" }, Ly = { class: "property-row" }, Ry = ["value", "onInput"], zy = { class: "value-display" }, jy = { class: "property-row checkbox-row" }, By = ["checked", "onChange"], Vy = {
  key: 0,
  class: "property-row"
}, $y = ["value", "onInput"], Ny = { class: "value-display" }, Wy = {
  key: 0,
  class: "empty-message"
}, Uy = { class: "property-section" }, Hy = {
  key: 0,
  class: "section-content"
}, Xy = { class: "force-tabs" }, Gy = {
  key: 0,
  class: "force-list"
}, Yy = { class: "force-header" }, Ky = ["value", "onInput"], qy = { class: "enabled-toggle" }, Zy = ["checked", "onChange"], Jy = ["onClick"], Qy = { class: "property-row" }, t1 = ["value", "onInput"], e1 = { class: "value-display" }, n1 = { class: "property-row" }, s1 = ["value", "onInput"], i1 = { class: "value-display" }, r1 = { class: "property-row" }, o1 = ["value", "onInput"], a1 = { class: "value-display" }, l1 = { class: "property-row" }, c1 = ["value", "onInput"], u1 = { class: "value-display" }, h1 = { class: "property-row" }, d1 = ["value", "onChange"], f1 = {
  key: 1,
  class: "force-list"
}, p1 = { class: "force-header" }, m1 = ["value", "onInput"], g1 = { class: "enabled-toggle" }, v1 = ["checked", "onChange"], y1 = ["onClick"], b1 = { class: "property-row" }, _1 = ["value", "onInput"], x1 = { class: "value-display" }, w1 = { class: "property-row" }, S1 = ["value", "onInput"], C1 = { class: "value-display" }, k1 = { class: "property-row" }, T1 = ["value", "onInput"], M1 = { class: "value-display" }, O1 = { class: "property-row" }, E1 = ["value", "onInput"], P1 = { class: "value-display" }, D1 = { class: "property-row" }, A1 = ["value", "onInput"], F1 = { class: "value-display" }, I1 = { class: "property-row" }, L1 = ["value", "onInput"], R1 = { class: "value-display" }, z1 = { class: "property-section" }, j1 = {
  key: 0,
  class: "section-content"
}, B1 = { class: "force-header" }, V1 = { class: "enabled-toggle" }, $1 = ["checked", "onChange"], N1 = ["onClick"], W1 = { class: "property-row" }, U1 = ["value", "onInput"], H1 = { class: "value-display" }, X1 = { class: "property-row" }, G1 = ["value", "onInput"], Y1 = { class: "value-display" }, K1 = { class: "property-row" }, q1 = ["value", "onInput"], Z1 = { class: "value-display" }, J1 = {
  key: 0,
  class: "empty-message"
}, Q1 = { class: "property-section" }, tb = {
  key: 0,
  class: "section-content"
}, eb = { class: "force-header" }, nb = ["value", "onChange"], sb = ["value"], ib = { class: "enabled-toggle" }, rb = ["checked", "onChange"], ob = ["onClick"], ab = { class: "property-row" }, lb = ["value", "onChange"], cb = { class: "property-row" }, ub = ["value", "onInput"], hb = { class: "value-display" }, db = { class: "property-row" }, fb = ["value", "onInput"], pb = { class: "value-display" }, mb = { class: "property-row" }, gb = ["value", "onInput"], vb = { class: "value-display" }, yb = { class: "property-row" }, bb = ["value", "onInput"], _b = { class: "value-display" }, xb = { class: "property-row" }, wb = ["value", "onInput"], Sb = { class: "value-display" }, Cb = { class: "property-row" }, kb = ["value", "onInput"], Tb = { class: "value-display" }, Mb = { class: "property-row" }, Ob = ["value", "onInput"], Eb = {
  key: 0,
  class: "empty-message"
}, Pb = { class: "property-section" }, Db = {
  key: 0,
  class: "section-content"
}, Ab = { class: "modulation-header" }, Fb = ["value", "onChange"], Ib = ["value"], Lb = ["onClick"], Rb = { class: "property-row" }, zb = ["value", "onChange"], jb = { class: "property-row" }, Bb = ["value", "onInput"], Vb = { class: "property-row" }, $b = ["value", "onInput"], Nb = { class: "property-row" }, Wb = ["value", "onChange"], Ub = {
  key: 0,
  class: "empty-message"
}, Hb = { class: "property-section" }, Xb = {
  key: 0,
  class: "section-content"
}, Gb = { class: "property-row" }, Yb = ["value"], Kb = { class: "property-row" }, qb = ["value"], Zb = { class: "property-row checkbox-row" }, Jb = ["checked"], Qb = {
  key: 0,
  class: "property-row"
}, t_ = ["value"], e_ = { class: "value-display" }, n_ = { class: "property-row checkbox-row" }, s_ = ["checked"], i_ = {
  key: 1,
  class: "property-row"
}, r_ = ["value"], o_ = { class: "value-display" }, a_ = {
  key: 2,
  class: "property-row"
}, l_ = ["value"], c_ = { class: "value-display" }, u_ = { class: "property-row checkbox-row" }, h_ = ["checked"], d_ = {
  key: 3,
  class: "property-row"
}, f_ = ["value"], p_ = { class: "value-display" }, m_ = {
  key: 4,
  class: "property-row"
}, g_ = ["value"], v_ = { class: "value-display" }, y_ = {
  key: 5,
  class: "property-row"
}, b_ = ["value"], __ = { class: "value-display" }, x_ = {
  key: 6,
  class: "property-row"
}, w_ = ["value"], S_ = { class: "value-display" }, C_ = {
  key: 7,
  class: "property-row checkbox-row"
}, k_ = ["checked"], T_ = { class: "particle-count" }, M_ = /* @__PURE__ */ ye({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = ut(/* @__PURE__ */ new Set(["system", "emitters"])), o = ut(/* @__PURE__ */ new Set()), a = ut("wells"), l = St(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), c = St(() => l.value.systemConfig), u = St(() => l.value.emitters), h = St(() => l.value.gravityWells), f = St(() => l.value.vortices), m = St(() => l.value.modulations), p = St(() => l.value.renderOptions), y = St(() => l.value.turbulenceFields || []), v = St(() => l.value.subEmitters || []), _ = St(() => p.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), g = St(() => n.particleCount);
    function C(it) {
      i.value.has(it) ? i.value.delete(it) : i.value.add(it);
    }
    function x(it) {
      o.value.has(it) ? o.value.delete(it) : o.value.add(it);
    }
    function k(it, E) {
      s("update", {
        systemConfig: { ...c.value, [it]: E }
      });
    }
    function w(it, E, O) {
      const S = u.value.map(
        (F) => F.id === it ? { ...F, [E]: O } : F
      );
      s("update", { emitters: S });
    }
    function T(it, E) {
      const O = pt(E);
      w(it, "color", O);
    }
    function P() {
      const it = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${u.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      s("update", { emitters: [...u.value, it] }), o.value.add(it.id);
    }
    function z(it) {
      s("update", { emitters: u.value.filter((E) => E.id !== it) });
    }
    function j(it, E, O) {
      const S = h.value.map(
        (F) => F.id === it ? { ...F, [E]: O } : F
      );
      s("update", { gravityWells: S });
    }
    function ot() {
      const it = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${h.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      s("update", { gravityWells: [...h.value, it] });
    }
    function vt(it) {
      s("update", { gravityWells: h.value.filter((E) => E.id !== it) });
    }
    function L(it, E, O) {
      const S = f.value.map(
        (F) => F.id === it ? { ...F, [E]: O } : F
      );
      s("update", { vortices: S });
    }
    function Y() {
      const it = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${f.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      s("update", { vortices: [...f.value, it] });
    }
    function M(it) {
      s("update", { vortices: f.value.filter((E) => E.id !== it) });
    }
    function I(it, E, O) {
      const S = m.value.map(
        (F) => F.id === it ? { ...F, [E]: O } : F
      );
      s("update", { modulations: S });
    }
    function tt() {
      const it = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      s("update", { modulations: [...m.value, it] });
    }
    function U(it) {
      s("update", { modulations: m.value.filter((E) => E.id !== it) });
    }
    function W(it, E) {
      s("update", {
        renderOptions: { ...p.value, [it]: E }
      });
    }
    function Z(it, E) {
      s("update", {
        renderOptions: {
          ...p.value,
          connections: { ..._.value, [it]: E }
        }
      });
    }
    function yt(it, E, O) {
      const S = y.value.map(
        (F) => F.id === it ? { ...F, [E]: O } : F
      );
      s("update", { turbulenceFields: S });
    }
    function Q() {
      const it = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      s("update", { turbulenceFields: [...y.value, it] });
    }
    function at(it) {
      s("update", { turbulenceFields: y.value.filter((E) => E.id !== it) });
    }
    function _t(it, E, O) {
      const S = v.value.map(
        (F) => F.id === it ? { ...F, [E]: O } : F
      );
      s("update", { subEmitters: S });
    }
    function ht(it, E) {
      const O = pt(E);
      _t(it, "color", O);
    }
    function X() {
      const it = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      s("update", { subEmitters: [...v.value, it] });
    }
    function kt(it) {
      s("update", { subEmitters: v.value.filter((E) => E.id !== it) });
    }
    function lt(it) {
      return "#" + it.map((E) => E.toString(16).padStart(2, "0")).join("");
    }
    function pt(it) {
      const E = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(it);
      return E ? [parseInt(E[1], 16), parseInt(E[2], 16), parseInt(E[3], 16)] : [255, 255, 255];
    }
    return (it, E) => (H(), G("div", E0, [
      d("div", P0, [
        d("div", {
          class: "section-header",
          onClick: E[0] || (E[0] = (O) => C("system"))
        }, [
          d("i", {
            class: wt(["pi", i.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          E[30] || (E[30] = d("span", null, "System Settings", -1))
        ]),
        i.value.has("system") ? (H(), G("div", D0, [
          d("div", A0, [
            E[31] || (E[31] = d("label", null, "Max Particles", -1)),
            d("input", {
              type: "range",
              value: c.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: E[1] || (E[1] = (O) => k("maxParticles", Number(O.target.value)))
            }, null, 40, F0),
            d("span", I0, ct(c.value.maxParticles), 1)
          ]),
          d("div", L0, [
            E[32] || (E[32] = d("label", null, "Gravity", -1)),
            d("input", {
              type: "range",
              value: c.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: E[2] || (E[2] = (O) => k("gravity", Number(O.target.value)))
            }, null, 40, R0),
            d("span", z0, ct(c.value.gravity), 1)
          ]),
          d("div", j0, [
            E[33] || (E[33] = d("label", null, "Wind Strength", -1)),
            d("input", {
              type: "range",
              value: c.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: E[3] || (E[3] = (O) => k("windStrength", Number(O.target.value)))
            }, null, 40, B0),
            d("span", V0, ct(c.value.windStrength), 1)
          ]),
          d("div", $0, [
            E[34] || (E[34] = d("label", null, "Wind Direction", -1)),
            d("input", {
              type: "range",
              value: c.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: E[4] || (E[4] = (O) => k("windDirection", Number(O.target.value)))
            }, null, 40, N0),
            d("span", W0, ct(c.value.windDirection) + "", 1)
          ]),
          d("div", U0, [
            E[35] || (E[35] = d("label", null, "Friction", -1)),
            d("input", {
              type: "range",
              value: c.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: E[5] || (E[5] = (O) => k("friction", Number(O.target.value)))
            }, null, 40, H0),
            d("span", X0, ct(c.value.friction.toFixed(2)), 1)
          ]),
          d("div", G0, [
            E[37] || (E[37] = d("label", null, "Boundary", -1)),
            d("select", {
              value: c.value.boundaryBehavior,
              onChange: E[6] || (E[6] = (O) => k("boundaryBehavior", O.target.value))
            }, [...E[36] || (E[36] = [
              d("option", { value: "kill" }, "Kill", -1),
              d("option", { value: "bounce" }, "Bounce", -1),
              d("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, Y0)
          ])
        ])) : xt("", !0)
      ]),
      d("div", K0, [
        d("div", {
          class: "section-header",
          onClick: E[7] || (E[7] = (O) => C("emitters"))
        }, [
          d("i", {
            class: wt(["pi", i.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          E[39] || (E[39] = d("span", null, "Emitters", -1)),
          d("button", {
            class: "add-btn",
            onClick: Bt(P, ["stop"]),
            title: "Add Emitter"
          }, [...E[38] || (E[38] = [
            d("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        i.value.has("emitters") ? (H(), G("div", q0, [
          (H(!0), G(Dt, null, jt(u.value, (O) => (H(), G("div", {
            key: O.id,
            class: "emitter-item"
          }, [
            d("div", {
              class: "emitter-header",
              onClick: (S) => x(O.id)
            }, [
              d("i", {
                class: wt(["pi", o.value.has(O.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              d("input", {
                type: "text",
                value: O.name,
                onInput: (S) => w(O.id, "name", S.target.value),
                onClick: E[8] || (E[8] = Bt(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, J0),
              d("label", Q0, [
                d("input", {
                  type: "checkbox",
                  checked: O.enabled,
                  onChange: (S) => w(O.id, "enabled", S.target.checked),
                  onClick: E[9] || (E[9] = Bt(() => {
                  }, ["stop"]))
                }, null, 40, ty)
              ]),
              d("button", {
                class: "remove-btn",
                onClick: Bt((S) => z(O.id), ["stop"]),
                title: "Remove"
              }, [...E[40] || (E[40] = [
                d("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, ey)
            ], 8, Z0),
            o.value.has(O.id) ? (H(), G("div", ny, [
              d("div", sy, [
                E[41] || (E[41] = d("label", null, "Position X", -1)),
                d("input", {
                  type: "range",
                  value: O.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => w(O.id, "x", Number(S.target.value))
                }, null, 40, iy),
                d("span", ry, ct(O.x.toFixed(2)), 1)
              ]),
              d("div", oy, [
                E[42] || (E[42] = d("label", null, "Position Y", -1)),
                d("input", {
                  type: "range",
                  value: O.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => w(O.id, "y", Number(S.target.value))
                }, null, 40, ay),
                d("span", ly, ct(O.y.toFixed(2)), 1)
              ]),
              d("div", cy, [
                E[43] || (E[43] = d("label", null, "Direction", -1)),
                d("input", {
                  type: "range",
                  value: O.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (S) => w(O.id, "direction", Number(S.target.value))
                }, null, 40, uy),
                d("span", hy, ct(O.direction) + "", 1)
              ]),
              d("div", dy, [
                E[44] || (E[44] = d("label", null, "Spread", -1)),
                d("input", {
                  type: "range",
                  value: O.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (S) => w(O.id, "spread", Number(S.target.value))
                }, null, 40, fy),
                d("span", py, ct(O.spread) + "", 1)
              ]),
              d("div", my, [
                E[45] || (E[45] = d("label", null, "Speed", -1)),
                d("input", {
                  type: "range",
                  value: O.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (S) => w(O.id, "speed", Number(S.target.value))
                }, null, 40, gy),
                d("span", vy, ct(O.speed), 1)
              ]),
              d("div", yy, [
                E[46] || (E[46] = d("label", null, "Speed Variance", -1)),
                d("input", {
                  type: "range",
                  value: O.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (S) => w(O.id, "speedVariance", Number(S.target.value))
                }, null, 40, by),
                d("span", _y, ct(O.speedVariance), 1)
              ]),
              d("div", xy, [
                E[47] || (E[47] = d("label", null, "Size", -1)),
                d("input", {
                  type: "range",
                  value: O.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (S) => w(O.id, "size", Number(S.target.value))
                }, null, 40, wy),
                d("span", Sy, ct(O.size) + "px", 1)
              ]),
              d("div", Cy, [
                E[48] || (E[48] = d("label", null, "Size Variance", -1)),
                d("input", {
                  type: "range",
                  value: O.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (S) => w(O.id, "sizeVariance", Number(S.target.value))
                }, null, 40, ky),
                d("span", Ty, ct(O.sizeVariance), 1)
              ]),
              d("div", My, [
                E[49] || (E[49] = d("label", null, "Color", -1)),
                d("input", {
                  type: "color",
                  value: lt(O.color),
                  onInput: (S) => T(O.id, S.target.value)
                }, null, 40, Oy)
              ]),
              d("div", Ey, [
                E[50] || (E[50] = d("label", null, "Emission Rate", -1)),
                d("input", {
                  type: "range",
                  value: O.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (S) => w(O.id, "emissionRate", Number(S.target.value))
                }, null, 40, Py),
                d("span", Dy, ct(O.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              d("div", Ay, [
                E[51] || (E[51] = d("label", null, "Lifetime", -1)),
                d("input", {
                  type: "range",
                  value: O.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (S) => w(O.id, "particleLifetime", Number(S.target.value))
                }, null, 40, Fy),
                d("span", Iy, ct(O.particleLifetime) + "f", 1)
              ]),
              d("div", Ly, [
                E[52] || (E[52] = d("label", null, "Initial Burst", -1)),
                d("input", {
                  type: "range",
                  value: O.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (S) => w(O.id, "initialBurst", Number(S.target.value))
                }, null, 40, Ry),
                d("span", zy, ct((O.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              d("div", jy, [
                d("label", null, [
                  d("input", {
                    type: "checkbox",
                    checked: O.burstOnBeat,
                    onChange: (S) => w(O.id, "burstOnBeat", S.target.checked)
                  }, null, 40, By),
                  E[53] || (E[53] = qt(" Burst on Beat ", -1))
                ])
              ]),
              O.burstOnBeat ? (H(), G("div", Vy, [
                E[54] || (E[54] = d("label", null, "Burst Count", -1)),
                d("input", {
                  type: "range",
                  value: O.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (S) => w(O.id, "burstCount", Number(S.target.value))
                }, null, 40, $y),
                d("span", Ny, ct(O.burstCount), 1)
              ])) : xt("", !0)
            ])) : xt("", !0)
          ]))), 128)),
          u.value.length === 0 ? (H(), G("div", Wy, " No emitters. Click + to add one. ")) : xt("", !0)
        ])) : xt("", !0)
      ]),
      d("div", Uy, [
        d("div", {
          class: "section-header",
          onClick: E[10] || (E[10] = (O) => C("forces"))
        }, [
          d("i", {
            class: wt(["pi", i.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          E[55] || (E[55] = d("span", null, "Force Fields", -1))
        ]),
        i.value.has("forces") ? (H(), G("div", Hy, [
          d("div", Xy, [
            d("button", {
              class: wt({ active: a.value === "wells" }),
              onClick: E[11] || (E[11] = (O) => a.value = "wells")
            }, " Gravity Wells ", 2),
            d("button", {
              class: wt({ active: a.value === "vortices" }),
              onClick: E[12] || (E[12] = (O) => a.value = "vortices")
            }, " Vortices ", 2)
          ]),
          a.value === "wells" ? (H(), G("div", Gy, [
            d("button", {
              class: "add-btn full-width",
              onClick: ot
            }, [...E[56] || (E[56] = [
              d("i", { class: "pi pi-plus" }, null, -1),
              qt(" Add Gravity Well ", -1)
            ])]),
            (H(!0), G(Dt, null, jt(h.value, (O) => (H(), G("div", {
              key: O.id,
              class: "force-item"
            }, [
              d("div", Yy, [
                d("input", {
                  type: "text",
                  value: O.name,
                  onInput: (S) => j(O.id, "name", S.target.value),
                  class: "force-name"
                }, null, 40, Ky),
                d("label", qy, [
                  d("input", {
                    type: "checkbox",
                    checked: O.enabled,
                    onChange: (S) => j(O.id, "enabled", S.target.checked)
                  }, null, 40, Zy)
                ]),
                d("button", {
                  class: "remove-btn",
                  onClick: (S) => vt(O.id)
                }, [...E[57] || (E[57] = [
                  d("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, Jy)
              ]),
              d("div", Qy, [
                E[58] || (E[58] = d("label", null, "Position X", -1)),
                d("input", {
                  type: "range",
                  value: O.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => j(O.id, "x", Number(S.target.value))
                }, null, 40, t1),
                d("span", e1, ct(O.x.toFixed(2)), 1)
              ]),
              d("div", n1, [
                E[59] || (E[59] = d("label", null, "Position Y", -1)),
                d("input", {
                  type: "range",
                  value: O.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => j(O.id, "y", Number(S.target.value))
                }, null, 40, s1),
                d("span", i1, ct(O.y.toFixed(2)), 1)
              ]),
              d("div", r1, [
                E[60] || (E[60] = d("label", null, "Strength", -1)),
                d("input", {
                  type: "range",
                  value: O.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (S) => j(O.id, "strength", Number(S.target.value))
                }, null, 40, o1),
                d("span", a1, ct(O.strength), 1)
              ]),
              d("div", l1, [
                E[61] || (E[61] = d("label", null, "Radius", -1)),
                d("input", {
                  type: "range",
                  value: O.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => j(O.id, "radius", Number(S.target.value))
                }, null, 40, c1),
                d("span", u1, ct(O.radius.toFixed(2)), 1)
              ]),
              d("div", h1, [
                E[63] || (E[63] = d("label", null, "Falloff", -1)),
                d("select", {
                  value: O.falloff,
                  onChange: (S) => j(O.id, "falloff", S.target.value)
                }, [...E[62] || (E[62] = [
                  d("option", { value: "linear" }, "Linear", -1),
                  d("option", { value: "quadratic" }, "Quadratic", -1),
                  d("option", { value: "constant" }, "Constant", -1)
                ])], 40, d1)
              ])
            ]))), 128))
          ])) : xt("", !0),
          a.value === "vortices" ? (H(), G("div", f1, [
            d("button", {
              class: "add-btn full-width",
              onClick: Y
            }, [...E[64] || (E[64] = [
              d("i", { class: "pi pi-plus" }, null, -1),
              qt(" Add Vortex ", -1)
            ])]),
            (H(!0), G(Dt, null, jt(f.value, (O) => (H(), G("div", {
              key: O.id,
              class: "force-item"
            }, [
              d("div", p1, [
                d("input", {
                  type: "text",
                  value: O.name,
                  onInput: (S) => L(O.id, "name", S.target.value),
                  class: "force-name"
                }, null, 40, m1),
                d("label", g1, [
                  d("input", {
                    type: "checkbox",
                    checked: O.enabled,
                    onChange: (S) => L(O.id, "enabled", S.target.checked)
                  }, null, 40, v1)
                ]),
                d("button", {
                  class: "remove-btn",
                  onClick: (S) => M(O.id)
                }, [...E[65] || (E[65] = [
                  d("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, y1)
              ]),
              d("div", b1, [
                E[66] || (E[66] = d("label", null, "Position X", -1)),
                d("input", {
                  type: "range",
                  value: O.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => L(O.id, "x", Number(S.target.value))
                }, null, 40, _1),
                d("span", x1, ct(O.x.toFixed(2)), 1)
              ]),
              d("div", w1, [
                E[67] || (E[67] = d("label", null, "Position Y", -1)),
                d("input", {
                  type: "range",
                  value: O.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => L(O.id, "y", Number(S.target.value))
                }, null, 40, S1),
                d("span", C1, ct(O.y.toFixed(2)), 1)
              ]),
              d("div", k1, [
                E[68] || (E[68] = d("label", null, "Strength", -1)),
                d("input", {
                  type: "range",
                  value: O.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (S) => L(O.id, "strength", Number(S.target.value))
                }, null, 40, T1),
                d("span", M1, ct(O.strength), 1)
              ]),
              d("div", O1, [
                E[69] || (E[69] = d("label", null, "Radius", -1)),
                d("input", {
                  type: "range",
                  value: O.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (S) => L(O.id, "radius", Number(S.target.value))
                }, null, 40, E1),
                d("span", P1, ct(O.radius.toFixed(2)), 1)
              ]),
              d("div", D1, [
                E[70] || (E[70] = d("label", null, "Rotation Speed", -1)),
                d("input", {
                  type: "range",
                  value: O.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (S) => L(O.id, "rotationSpeed", Number(S.target.value))
                }, null, 40, A1),
                d("span", F1, ct(O.rotationSpeed) + "/f", 1)
              ]),
              d("div", I1, [
                E[71] || (E[71] = d("label", null, "Inward Pull", -1)),
                d("input", {
                  type: "range",
                  value: O.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (S) => L(O.id, "inwardPull", Number(S.target.value))
                }, null, 40, L1),
                d("span", R1, ct(O.inwardPull), 1)
              ])
            ]))), 128))
          ])) : xt("", !0)
        ])) : xt("", !0)
      ]),
      d("div", z1, [
        d("div", {
          class: "section-header",
          onClick: E[13] || (E[13] = (O) => C("turbulence"))
        }, [
          d("i", {
            class: wt(["pi", i.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          E[73] || (E[73] = d("span", null, "Turbulence", -1)),
          d("button", {
            class: "add-btn",
            onClick: Bt(Q, ["stop"]),
            title: "Add Turbulence Field"
          }, [...E[72] || (E[72] = [
            d("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        i.value.has("turbulence") ? (H(), G("div", j1, [
          (H(!0), G(Dt, null, jt(y.value, (O) => (H(), G("div", {
            key: O.id,
            class: "force-item"
          }, [
            d("div", B1, [
              E[75] || (E[75] = d("span", { class: "force-label" }, "Turbulence Field", -1)),
              d("label", V1, [
                d("input", {
                  type: "checkbox",
                  checked: O.enabled,
                  onChange: (S) => yt(O.id, "enabled", S.target.checked)
                }, null, 40, $1)
              ]),
              d("button", {
                class: "remove-btn",
                onClick: (S) => at(O.id)
              }, [...E[74] || (E[74] = [
                d("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, N1)
            ]),
            d("div", W1, [
              E[76] || (E[76] = d("label", null, "Scale", -1)),
              d("input", {
                type: "range",
                value: O.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (S) => yt(O.id, "scale", Number(S.target.value))
              }, null, 40, U1),
              d("span", H1, ct(O.scale.toFixed(3)), 1)
            ]),
            d("div", X1, [
              E[77] || (E[77] = d("label", null, "Strength", -1)),
              d("input", {
                type: "range",
                value: O.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (S) => yt(O.id, "strength", Number(S.target.value))
              }, null, 40, G1),
              d("span", Y1, ct(O.strength), 1)
            ]),
            d("div", K1, [
              E[78] || (E[78] = d("label", null, "Evolution", -1)),
              d("input", {
                type: "range",
                value: O.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (S) => yt(O.id, "evolutionSpeed", Number(S.target.value))
              }, null, 40, q1),
              d("span", Z1, ct(O.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          y.value.length === 0 ? (H(), G("div", J1, " No turbulence fields. Add one for organic particle motion. ")) : xt("", !0)
        ])) : xt("", !0)
      ]),
      d("div", Q1, [
        d("div", {
          class: "section-header",
          onClick: E[14] || (E[14] = (O) => C("subEmitters"))
        }, [
          d("i", {
            class: wt(["pi", i.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          E[80] || (E[80] = d("span", null, "Sub-Emitters", -1)),
          d("button", {
            class: "add-btn",
            onClick: Bt(X, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...E[79] || (E[79] = [
            d("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        i.value.has("subEmitters") ? (H(), G("div", tb, [
          (H(!0), G(Dt, null, jt(v.value, (O) => (H(), G("div", {
            key: O.id,
            class: "force-item"
          }, [
            d("div", eb, [
              d("select", {
                value: O.parentEmitterId,
                onChange: (S) => _t(O.id, "parentEmitterId", S.target.value),
                class: "sub-emitter-parent"
              }, [
                E[81] || (E[81] = d("option", { value: "*" }, "All Emitters", -1)),
                (H(!0), G(Dt, null, jt(u.value, (S) => (H(), G("option", {
                  key: S.id,
                  value: S.id
                }, ct(S.name), 9, sb))), 128))
              ], 40, nb),
              d("label", ib, [
                d("input", {
                  type: "checkbox",
                  checked: O.enabled,
                  onChange: (S) => _t(O.id, "enabled", S.target.checked)
                }, null, 40, rb)
              ]),
              d("button", {
                class: "remove-btn",
                onClick: (S) => kt(O.id)
              }, [...E[82] || (E[82] = [
                d("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, ob)
            ]),
            d("div", ab, [
              E[84] || (E[84] = d("label", null, "Trigger", -1)),
              d("select", {
                value: O.trigger,
                onChange: (S) => _t(O.id, "trigger", S.target.value)
              }, [...E[83] || (E[83] = [
                d("option", { value: "death" }, "On Death", -1)
              ])], 40, lb)
            ]),
            d("div", cb, [
              E[85] || (E[85] = d("label", null, "Spawn Count", -1)),
              d("input", {
                type: "range",
                value: O.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (S) => _t(O.id, "spawnCount", Number(S.target.value))
              }, null, 40, ub),
              d("span", hb, ct(O.spawnCount), 1)
            ]),
            d("div", db, [
              E[86] || (E[86] = d("label", null, "Inherit Velocity", -1)),
              d("input", {
                type: "range",
                value: O.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (S) => _t(O.id, "inheritVelocity", Number(S.target.value))
              }, null, 40, fb),
              d("span", pb, ct((O.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            d("div", mb, [
              E[87] || (E[87] = d("label", null, "Size", -1)),
              d("input", {
                type: "range",
                value: O.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (S) => _t(O.id, "size", Number(S.target.value))
              }, null, 40, gb),
              d("span", vb, ct(O.size) + "px", 1)
            ]),
            d("div", yb, [
              E[88] || (E[88] = d("label", null, "Lifetime", -1)),
              d("input", {
                type: "range",
                value: O.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (S) => _t(O.id, "lifetime", Number(S.target.value))
              }, null, 40, bb),
              d("span", _b, ct(O.lifetime) + "f", 1)
            ]),
            d("div", xb, [
              E[89] || (E[89] = d("label", null, "Speed", -1)),
              d("input", {
                type: "range",
                value: O.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (S) => _t(O.id, "speed", Number(S.target.value))
              }, null, 40, wb),
              d("span", Sb, ct(O.speed), 1)
            ]),
            d("div", Cb, [
              E[90] || (E[90] = d("label", null, "Spread", -1)),
              d("input", {
                type: "range",
                value: O.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (S) => _t(O.id, "spread", Number(S.target.value))
              }, null, 40, kb),
              d("span", Tb, ct(O.spread) + "", 1)
            ]),
            d("div", Mb, [
              E[91] || (E[91] = d("label", null, "Color", -1)),
              d("input", {
                type: "color",
                value: lt(O.color),
                onInput: (S) => ht(O.id, S.target.value)
              }, null, 40, Ob)
            ])
          ]))), 128)),
          v.value.length === 0 ? (H(), G("div", Eb, " No sub-emitters. Add one for particle death effects. ")) : xt("", !0)
        ])) : xt("", !0)
      ]),
      d("div", Pb, [
        d("div", {
          class: "section-header",
          onClick: E[15] || (E[15] = (O) => C("modulations"))
        }, [
          d("i", {
            class: wt(["pi", i.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          E[93] || (E[93] = d("span", null, "Modulations", -1)),
          d("button", {
            class: "add-btn",
            onClick: Bt(tt, ["stop"]),
            title: "Add Modulation"
          }, [...E[92] || (E[92] = [
            d("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        i.value.has("modulations") ? (H(), G("div", Db, [
          (H(!0), G(Dt, null, jt(m.value, (O) => (H(), G("div", {
            key: O.id,
            class: "modulation-item"
          }, [
            d("div", Ab, [
              d("select", {
                value: O.emitterId,
                onChange: (S) => I(O.id, "emitterId", S.target.value)
              }, [
                E[94] || (E[94] = d("option", { value: "*" }, "All Emitters", -1)),
                (H(!0), G(Dt, null, jt(u.value, (S) => (H(), G("option", {
                  key: S.id,
                  value: S.id
                }, ct(S.name), 9, Ib))), 128))
              ], 40, Fb),
              d("button", {
                class: "remove-btn",
                onClick: (S) => U(O.id)
              }, [...E[95] || (E[95] = [
                d("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, Lb)
            ]),
            d("div", Rb, [
              E[97] || (E[97] = d("label", null, "Property", -1)),
              d("select", {
                value: O.property,
                onChange: (S) => I(O.id, "property", S.target.value)
              }, [...E[96] || (E[96] = [
                bi('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, zb)
            ]),
            d("div", jb, [
              E[98] || (E[98] = d("label", null, "Start Value", -1)),
              d("input", {
                type: "number",
                value: O.startValue,
                step: "0.1",
                onInput: (S) => I(O.id, "startValue", Number(S.target.value))
              }, null, 40, Bb)
            ]),
            d("div", Vb, [
              E[99] || (E[99] = d("label", null, "End Value", -1)),
              d("input", {
                type: "number",
                value: O.endValue,
                step: "0.1",
                onInput: (S) => I(O.id, "endValue", Number(S.target.value))
              }, null, 40, $b)
            ]),
            d("div", Nb, [
              E[101] || (E[101] = d("label", null, "Easing", -1)),
              d("select", {
                value: O.easing,
                onChange: (S) => I(O.id, "easing", S.target.value)
              }, [...E[100] || (E[100] = [
                bi('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, Wb)
            ])
          ]))), 128)),
          m.value.length === 0 ? (H(), G("div", Ub, " No modulations. Add one to animate particle properties over lifetime. ")) : xt("", !0)
        ])) : xt("", !0)
      ]),
      d("div", Hb, [
        d("div", {
          class: "section-header",
          onClick: E[16] || (E[16] = (O) => C("render"))
        }, [
          d("i", {
            class: wt(["pi", i.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          E[102] || (E[102] = d("span", null, "Render Options", -1))
        ]),
        i.value.has("render") ? (H(), G("div", Xb, [
          d("div", Gb, [
            E[104] || (E[104] = d("label", null, "Blend Mode", -1)),
            d("select", {
              value: p.value.blendMode,
              onChange: E[17] || (E[17] = (O) => W("blendMode", O.target.value))
            }, [...E[103] || (E[103] = [
              d("option", { value: "normal" }, "Normal", -1),
              d("option", { value: "additive" }, "Additive", -1),
              d("option", { value: "multiply" }, "Multiply", -1),
              d("option", { value: "screen" }, "Screen", -1)
            ])], 40, Yb)
          ]),
          d("div", Kb, [
            E[106] || (E[106] = d("label", null, "Shape", -1)),
            d("select", {
              value: p.value.particleShape,
              onChange: E[18] || (E[18] = (O) => W("particleShape", O.target.value))
            }, [...E[105] || (E[105] = [
              d("option", { value: "circle" }, "Circle", -1),
              d("option", { value: "square" }, "Square", -1),
              d("option", { value: "triangle" }, "Triangle", -1),
              d("option", { value: "star" }, "Star", -1)
            ])], 40, qb)
          ]),
          d("div", Zb, [
            d("label", null, [
              d("input", {
                type: "checkbox",
                checked: p.value.renderTrails,
                onChange: E[19] || (E[19] = (O) => W("renderTrails", O.target.checked))
              }, null, 40, Jb),
              E[107] || (E[107] = qt(" Render Trails ", -1))
            ])
          ]),
          p.value.renderTrails ? (H(), G("div", Qb, [
            E[108] || (E[108] = d("label", null, "Trail Length", -1)),
            d("input", {
              type: "range",
              value: p.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: E[20] || (E[20] = (O) => W("trailLength", Number(O.target.value)))
            }, null, 40, t_),
            d("span", e_, ct(p.value.trailLength), 1)
          ])) : xt("", !0),
          d("div", n_, [
            d("label", null, [
              d("input", {
                type: "checkbox",
                checked: p.value.glowEnabled,
                onChange: E[21] || (E[21] = (O) => W("glowEnabled", O.target.checked))
              }, null, 40, s_),
              E[109] || (E[109] = qt(" Enable Glow ", -1))
            ])
          ]),
          p.value.glowEnabled ? (H(), G("div", i_, [
            E[110] || (E[110] = d("label", null, "Glow Radius", -1)),
            d("input", {
              type: "range",
              value: p.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: E[22] || (E[22] = (O) => W("glowRadius", Number(O.target.value)))
            }, null, 40, r_),
            d("span", o_, ct(p.value.glowRadius) + "px", 1)
          ])) : xt("", !0),
          p.value.glowEnabled ? (H(), G("div", a_, [
            E[111] || (E[111] = d("label", null, "Glow Intensity", -1)),
            d("input", {
              type: "range",
              value: p.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: E[23] || (E[23] = (O) => W("glowIntensity", Number(O.target.value)))
            }, null, 40, l_),
            d("span", c_, ct(p.value.glowIntensity.toFixed(2)), 1)
          ])) : xt("", !0),
          E[118] || (E[118] = d("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          d("div", u_, [
            d("label", null, [
              d("input", {
                type: "checkbox",
                checked: _.value.enabled,
                onChange: E[24] || (E[24] = (O) => Z("enabled", O.target.checked))
              }, null, 40, h_),
              E[112] || (E[112] = qt(" Enable Connections ", -1))
            ])
          ]),
          _.value.enabled ? (H(), G("div", d_, [
            E[113] || (E[113] = d("label", null, "Max Distance", -1)),
            d("input", {
              type: "range",
              value: _.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: E[25] || (E[25] = (O) => Z("maxDistance", Number(O.target.value)))
            }, null, 40, f_),
            d("span", p_, ct(_.value.maxDistance) + "px", 1)
          ])) : xt("", !0),
          _.value.enabled ? (H(), G("div", m_, [
            E[114] || (E[114] = d("label", null, "Max Connections", -1)),
            d("input", {
              type: "range",
              value: _.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: E[26] || (E[26] = (O) => Z("maxConnections", Number(O.target.value)))
            }, null, 40, g_),
            d("span", v_, ct(_.value.maxConnections), 1)
          ])) : xt("", !0),
          _.value.enabled ? (H(), G("div", y_, [
            E[115] || (E[115] = d("label", null, "Line Width", -1)),
            d("input", {
              type: "range",
              value: _.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: E[27] || (E[27] = (O) => Z("lineWidth", Number(O.target.value)))
            }, null, 40, b_),
            d("span", __, ct(_.value.lineWidth.toFixed(1)), 1)
          ])) : xt("", !0),
          _.value.enabled ? (H(), G("div", x_, [
            E[116] || (E[116] = d("label", null, "Line Opacity", -1)),
            d("input", {
              type: "range",
              value: _.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: E[28] || (E[28] = (O) => Z("lineOpacity", Number(O.target.value)))
            }, null, 40, w_),
            d("span", S_, ct(_.value.lineOpacity.toFixed(2)), 1)
          ])) : xt("", !0),
          _.value.enabled ? (H(), G("div", C_, [
            d("label", null, [
              d("input", {
                type: "checkbox",
                checked: _.value.fadeByDistance,
                onChange: E[29] || (E[29] = (O) => Z("fadeByDistance", O.target.checked))
              }, null, 40, k_),
              E[117] || (E[117] = qt(" Fade by Distance ", -1))
            ])
          ])) : xt("", !0)
        ])) : xt("", !0)
      ]),
      d("div", T_, [
        E[119] || (E[119] = d("i", { class: "pi pi-circle-fill" }, null, -1)),
        d("span", null, ct(g.value) + " particles", 1)
      ])
    ]));
  }
}), O_ = /* @__PURE__ */ we(M_, [["__scopeId", "data-v-60b9bdc8"]]), E_ = { class: "depthflow-properties" }, P_ = { class: "property-section" }, D_ = {
  key: 0,
  class: "section-content"
}, A_ = { class: "property-row" }, F_ = ["value"], I_ = ["value"], L_ = { class: "property-row" }, R_ = ["value"], z_ = ["value"], j_ = { class: "property-section" }, B_ = {
  key: 0,
  class: "section-content"
}, V_ = { class: "preset-grid" }, $_ = ["onClick"], N_ = {
  key: 0,
  class: "property-row"
}, W_ = ["value"], U_ = { class: "value-display" }, H_ = { class: "property-section" }, X_ = {
  key: 0,
  class: "section-content"
}, G_ = { class: "property-row" }, Y_ = ["value"], K_ = { class: "value-display" }, q_ = { class: "property-row" }, Z_ = ["value"], J_ = { class: "value-display" }, Q_ = { class: "property-row" }, tx = ["value"], ex = { class: "value-display" }, nx = { class: "property-row" }, sx = ["value"], ix = { class: "value-display" }, rx = { class: "property-section" }, ox = {
  key: 0,
  class: "section-content"
}, ax = { class: "property-row" }, lx = ["value"], cx = { class: "value-display" }, ux = { class: "property-row" }, hx = ["value"], dx = { class: "value-display" }, fx = {
  key: 0,
  class: "property-section"
}, px = {
  key: 0,
  class: "section-content"
}, mx = { class: "property-row" }, gx = ["value"], vx = { class: "value-display" }, yx = { class: "property-row" }, bx = ["value"], _x = { class: "value-display" }, xx = { class: "property-row" }, wx = ["value"], Sx = { class: "value-display" }, Cx = { class: "property-row" }, kx = ["value"], Tx = { class: "value-display" }, Mx = {
  key: 2,
  class: "property-row"
}, Ox = ["value"], Ex = { class: "value-display" }, Px = { class: "property-section" }, Dx = {
  key: 0,
  class: "section-content"
}, Ax = { class: "property-row" }, Fx = ["value"], Ix = { class: "value-display" }, Lx = { class: "property-row checkbox-row" }, Rx = ["checked"], zx = { class: "property-section" }, jx = {
  key: 0,
  class: "section-content"
}, Bx = { class: "preview-container" }, Vx = { class: "preview-controls" }, $x = { class: "frame-indicator" }, Cn = 200, Nx = /* @__PURE__ */ ye({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = qe(), o = ut(null), a = ut(!1), l = ut(0), c = ut(null), u = ut(/* @__PURE__ */ new Set(["source", "preset", "camera"])), h = ut(1), f = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], m = St(() => n.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), p = St(() => m.value.config), y = St(() => i.frameCount), v = St(
      () => i.layers.filter((M) => M.type === "image" || M.type === "generated")
    ), _ = St(
      () => i.layers.filter((M) => M.type === "depth" || M.type === "generated")
    ), g = St(
      () => ["circle_cw", "circle_ccw"].includes(p.value.preset)
    ), C = St(
      () => ["horizontal_swing", "vertical_swing"].includes(p.value.preset)
    ), x = St(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(p.value.preset)
    ), k = St(
      () => g.value || C.value || x.value
    ), w = St(() => g.value ? "Orbit Settings" : C.value ? "Swing Settings" : x.value ? "Dolly Zoom Settings" : "Preset Settings");
    function T(M) {
      u.value.has(M) ? u.value.delete(M) : u.value.add(M);
    }
    function P(M, I) {
      s("update", { [M]: I });
    }
    function z(M, I) {
      s("update", {
        config: { ...p.value, [M]: I }
      });
    }
    function j(M) {
      z("preset", M);
    }
    function ot(M) {
      h.value = M, g.value ? z("orbitRadius", 0.1 * M) : C.value ? z("swingAmplitude", 0.1 * M) : z("depthScale", 1 * M);
    }
    function vt() {
      a.value = !a.value, a.value ? L() : c.value !== null && (cancelAnimationFrame(c.value), c.value = null);
    }
    function L() {
      a.value && (l.value = (l.value + 1) % y.value, Y(), c.value = requestAnimationFrame(() => {
        setTimeout(L, 1e3 / i.fps);
      }));
    }
    function Y() {
      const M = o.value;
      if (!M) return;
      const I = M.getContext("2d");
      I && (I.fillStyle = "#1e1e1e", I.fillRect(0, 0, Cn, Cn), I.fillStyle = "#333", I.fillRect(10, 10, Cn - 20, Cn - 20), I.fillStyle = "#666", I.font = "12px sans-serif", I.textAlign = "center", I.fillText("Depthflow Preview", Cn / 2, Cn / 2), I.fillText(`Frame ${l.value}`, Cn / 2, Cn / 2 + 16));
    }
    return Ne(() => {
      Y();
    }), wn(() => {
      c.value !== null && cancelAnimationFrame(c.value);
    }), (M, I) => (H(), G("div", E_, [
      d("div", P_, [
        d("div", {
          class: "section-header",
          onClick: I[0] || (I[0] = (tt) => T("source"))
        }, [
          d("i", {
            class: wt(["pi", u.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[23] || (I[23] = d("span", null, "Source Selection", -1))
        ]),
        u.value.has("source") ? (H(), G("div", D_, [
          d("div", A_, [
            I[25] || (I[25] = d("label", null, "Source Layer", -1)),
            d("select", {
              value: m.value.sourceLayerId,
              onChange: I[1] || (I[1] = (tt) => P("sourceLayerId", tt.target.value))
            }, [
              I[24] || (I[24] = d("option", { value: "" }, "Select source...", -1)),
              (H(!0), G(Dt, null, jt(v.value, (tt) => (H(), G("option", {
                key: tt.id,
                value: tt.id
              }, ct(tt.name), 9, I_))), 128))
            ], 40, F_)
          ]),
          d("div", L_, [
            I[27] || (I[27] = d("label", null, "Depth Layer", -1)),
            d("select", {
              value: m.value.depthLayerId,
              onChange: I[2] || (I[2] = (tt) => P("depthLayerId", tt.target.value))
            }, [
              I[26] || (I[26] = d("option", { value: "" }, "Select depth map...", -1)),
              (H(!0), G(Dt, null, jt(_.value, (tt) => (H(), G("option", {
                key: tt.id,
                value: tt.id
              }, ct(tt.name), 9, z_))), 128))
            ], 40, R_)
          ])
        ])) : xt("", !0)
      ]),
      d("div", j_, [
        d("div", {
          class: "section-header",
          onClick: I[3] || (I[3] = (tt) => T("preset"))
        }, [
          d("i", {
            class: wt(["pi", u.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[28] || (I[28] = d("span", null, "Motion Preset", -1))
        ]),
        u.value.has("preset") ? (H(), G("div", B_, [
          d("div", V_, [
            (H(), G(Dt, null, jt(f, (tt) => d("button", {
              key: tt.value,
              class: wt(["preset-btn", { active: p.value.preset === tt.value }]),
              onClick: (U) => j(tt.value)
            }, [
              d("i", {
                class: wt(tt.icon)
              }, null, 2),
              d("span", null, ct(tt.label), 1)
            ], 10, $_)), 64))
          ]),
          p.value.preset !== "static" ? (H(), G("div", N_, [
            I[29] || (I[29] = d("label", null, "Intensity", -1)),
            d("input", {
              type: "range",
              value: h.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: I[4] || (I[4] = (tt) => ot(Number(tt.target.value)))
            }, null, 40, W_),
            d("span", U_, ct(h.value.toFixed(1)) + "x", 1)
          ])) : xt("", !0)
        ])) : xt("", !0)
      ]),
      d("div", H_, [
        d("div", {
          class: "section-header",
          onClick: I[5] || (I[5] = (tt) => T("camera"))
        }, [
          d("i", {
            class: wt(["pi", u.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[30] || (I[30] = d("span", null, "Camera Controls", -1))
        ]),
        u.value.has("camera") ? (H(), G("div", X_, [
          d("div", G_, [
            I[31] || (I[31] = d("label", null, "Zoom", -1)),
            m.value.animatedZoom ? (H(), ce(Ls, {
              key: 0,
              property: m.value.animatedZoom,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : xt("", !0),
            d("input", {
              type: "range",
              value: p.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: I[6] || (I[6] = (tt) => z("zoom", Number(tt.target.value)))
            }, null, 40, Y_),
            d("span", K_, ct(p.value.zoom.toFixed(2)), 1)
          ]),
          d("div", q_, [
            I[32] || (I[32] = d("label", null, "Offset X", -1)),
            m.value.animatedOffsetX ? (H(), ce(Ls, {
              key: 0,
              property: m.value.animatedOffsetX,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : xt("", !0),
            d("input", {
              type: "range",
              value: p.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: I[7] || (I[7] = (tt) => z("offsetX", Number(tt.target.value)))
            }, null, 40, Z_),
            d("span", J_, ct(p.value.offsetX.toFixed(2)), 1)
          ]),
          d("div", Q_, [
            I[33] || (I[33] = d("label", null, "Offset Y", -1)),
            m.value.animatedOffsetY ? (H(), ce(Ls, {
              key: 0,
              property: m.value.animatedOffsetY,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : xt("", !0),
            d("input", {
              type: "range",
              value: p.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: I[8] || (I[8] = (tt) => z("offsetY", Number(tt.target.value)))
            }, null, 40, tx),
            d("span", ex, ct(p.value.offsetY.toFixed(2)), 1)
          ]),
          d("div", nx, [
            I[34] || (I[34] = d("label", null, "Rotation", -1)),
            m.value.animatedRotation ? (H(), ce(Ls, {
              key: 0,
              property: m.value.animatedRotation,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : xt("", !0),
            d("input", {
              type: "range",
              value: p.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: I[9] || (I[9] = (tt) => z("rotation", Number(tt.target.value)))
            }, null, 40, sx),
            d("span", ix, ct(p.value.rotation) + "", 1)
          ])
        ])) : xt("", !0)
      ]),
      d("div", rx, [
        d("div", {
          class: "section-header",
          onClick: I[10] || (I[10] = (tt) => T("depth"))
        }, [
          d("i", {
            class: wt(["pi", u.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[35] || (I[35] = d("span", null, "Depth Settings", -1))
        ]),
        u.value.has("depth") ? (H(), G("div", ox, [
          d("div", ax, [
            I[36] || (I[36] = d("label", null, "Depth Scale", -1)),
            m.value.animatedDepthScale ? (H(), ce(Ls, {
              key: 0,
              property: m.value.animatedDepthScale,
              "layer-id": r.layer.id
            }, null, 8, ["property", "layer-id"])) : xt("", !0),
            d("input", {
              type: "range",
              value: p.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: I[11] || (I[11] = (tt) => z("depthScale", Number(tt.target.value)))
            }, null, 40, lx),
            d("span", cx, ct(p.value.depthScale.toFixed(2)), 1)
          ]),
          d("div", ux, [
            I[37] || (I[37] = d("label", null, "Focus Depth", -1)),
            d("input", {
              type: "range",
              value: p.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: I[12] || (I[12] = (tt) => z("focusDepth", Number(tt.target.value)))
            }, null, 40, hx),
            d("span", dx, ct(p.value.focusDepth.toFixed(2)), 1)
          ]),
          I[38] || (I[38] = d("div", { class: "depth-hint" }, [
            qt(" Objects at focus depth stay stationary."),
            d("br"),
            qt(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : xt("", !0)
      ]),
      k.value ? (H(), G("div", fx, [
        d("div", {
          class: "section-header",
          onClick: I[13] || (I[13] = (tt) => T("presetSettings"))
        }, [
          d("i", {
            class: wt(["pi", u.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          d("span", null, ct(w.value), 1)
        ]),
        u.value.has("presetSettings") ? (H(), G("div", px, [
          g.value ? (H(), G(Dt, { key: 0 }, [
            d("div", mx, [
              I[39] || (I[39] = d("label", null, "Orbit Radius", -1)),
              d("input", {
                type: "range",
                value: p.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: I[14] || (I[14] = (tt) => z("orbitRadius", Number(tt.target.value)))
              }, null, 40, gx),
              d("span", vx, ct(p.value.orbitRadius.toFixed(2)), 1)
            ]),
            d("div", yx, [
              I[40] || (I[40] = d("label", null, "Orbit Speed", -1)),
              d("input", {
                type: "range",
                value: p.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: I[15] || (I[15] = (tt) => z("orbitSpeed", Number(tt.target.value)))
              }, null, 40, bx),
              d("span", _x, ct(p.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : xt("", !0),
          C.value ? (H(), G(Dt, { key: 1 }, [
            d("div", xx, [
              I[41] || (I[41] = d("label", null, "Amplitude", -1)),
              d("input", {
                type: "range",
                value: p.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: I[16] || (I[16] = (tt) => z("swingAmplitude", Number(tt.target.value)))
              }, null, 40, wx),
              d("span", Sx, ct(p.value.swingAmplitude.toFixed(2)), 1)
            ]),
            d("div", Cx, [
              I[42] || (I[42] = d("label", null, "Frequency", -1)),
              d("input", {
                type: "range",
                value: p.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: I[17] || (I[17] = (tt) => z("swingFrequency", Number(tt.target.value)))
              }, null, 40, kx),
              d("span", Tx, ct(p.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : xt("", !0),
          x.value ? (H(), G("div", Mx, [
            I[43] || (I[43] = d("label", null, "Dolly Rate", -1)),
            d("input", {
              type: "range",
              value: p.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: I[18] || (I[18] = (tt) => z("dollyZoom", Number(tt.target.value)))
            }, null, 40, Ox),
            d("span", Ex, ct(p.value.dollyZoom.toFixed(2)), 1)
          ])) : xt("", !0)
        ])) : xt("", !0)
      ])) : xt("", !0),
      d("div", Px, [
        d("div", {
          class: "section-header",
          onClick: I[19] || (I[19] = (tt) => T("quality"))
        }, [
          d("i", {
            class: wt(["pi", u.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[44] || (I[44] = d("span", null, "Quality", -1))
        ]),
        u.value.has("quality") ? (H(), G("div", Dx, [
          d("div", Ax, [
            I[45] || (I[45] = d("label", null, "Edge Dilation", -1)),
            d("input", {
              type: "range",
              value: p.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: I[20] || (I[20] = (tt) => z("edgeDilation", Number(tt.target.value)))
            }, null, 40, Fx),
            d("span", Ix, ct(p.value.edgeDilation) + "px", 1)
          ]),
          d("div", Lx, [
            d("label", null, [
              d("input", {
                type: "checkbox",
                checked: p.value.inpaintEdges,
                onChange: I[21] || (I[21] = (tt) => z("inpaintEdges", tt.target.checked))
              }, null, 40, Rx),
              I[46] || (I[46] = qt(" Inpaint Edges ", -1))
            ])
          ])
        ])) : xt("", !0)
      ]),
      d("div", zx, [
        d("div", {
          class: "section-header",
          onClick: I[22] || (I[22] = (tt) => T("preview"))
        }, [
          d("i", {
            class: wt(["pi", u.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[47] || (I[47] = d("span", null, "Preview", -1))
        ]),
        u.value.has("preview") ? (H(), G("div", jx, [
          d("div", Bx, [
            d("canvas", {
              ref_key: "previewCanvas",
              ref: o,
              class: "preview-canvas",
              width: Cn,
              height: Cn
            }, null, 512)
          ]),
          d("div", Vx, [
            d("button", {
              class: wt(["preview-btn", { active: a.value }]),
              onClick: vt
            }, [
              d("i", {
                class: wt(a.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              qt(" " + ct(a.value ? "Pause" : "Play"), 1)
            ], 2),
            d("span", $x, " Frame " + ct(l.value) + " / " + ct(y.value - 1), 1)
          ])
        ])) : xt("", !0)
      ])
    ]));
  }
}), Wx = /* @__PURE__ */ we(Nx, [["__scopeId", "data-v-ffaf4c8a"]]), Ux = { class: "properties-panel" }, Hx = {
  key: 0,
  class: "panel-content"
}, Xx = { class: "property-section" }, Gx = { class: "property-row" }, Yx = { class: "property-section" }, Kx = { class: "expand-icon" }, qx = {
  key: 0,
  class: "section-content"
}, Zx = { class: "property-row" }, Jx = { class: "multi-value" }, Qx = { class: "property-row" }, tw = { class: "multi-value" }, ew = { class: "property-row" }, nw = { class: "single-value" }, sw = { class: "property-row" }, iw = { class: "multi-value" }, rw = { class: "property-row" }, ow = { class: "single-value" }, aw = { class: "property-section" }, lw = { class: "property-row" }, cw = ["value"], uw = {
  key: 0,
  class: "property-section"
}, hw = { class: "expand-icon" }, dw = { class: "effect-count" }, fw = {
  key: 0,
  class: "section-content"
}, pw = { class: "effect-header" }, mw = ["checked", "onChange"], gw = { class: "effect-name" }, vw = ["onClick"], yw = {
  key: 1,
  class: "empty-state"
}, bw = /* @__PURE__ */ ye({
  __name: "PropertiesPanel",
  setup(r) {
    const e = qe(), n = ut(["transform"]), s = ut(!0), i = ut(""), o = ut({
      position: { x: 0, y: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100
    }), a = ut("normal"), l = ut([]), c = ut([]), u = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], h = St(() => e.selectedLayer), f = St(() => {
      if (!h.value) return null;
      switch (h.value.type) {
        case "text":
          return ui(O0);
        case "particles":
          return ui(O_);
        case "depthflow":
          return ui(Wx);
        default:
          return null;
      }
    });
    ae(h, (w) => {
      var T, P, z, j, ot, vt, L, Y, M, I, tt, U, W, Z;
      w && (i.value = w.name, o.value = {
        position: { x: ((P = (T = w.position) == null ? void 0 : T.value) == null ? void 0 : P[0]) || 0, y: ((j = (z = w.position) == null ? void 0 : z.value) == null ? void 0 : j[1]) || 0 },
        scale: { x: ((vt = (ot = w.scale) == null ? void 0 : ot.value) == null ? void 0 : vt[0]) || 100, y: ((Y = (L = w.scale) == null ? void 0 : L.value) == null ? void 0 : Y[1]) || 100 },
        rotation: ((M = w.rotation) == null ? void 0 : M.value) || 0,
        anchorPoint: { x: ((tt = (I = w.anchorPoint) == null ? void 0 : I.value) == null ? void 0 : tt[0]) || 0, y: ((W = (U = w.anchorPoint) == null ? void 0 : U.value) == null ? void 0 : W[1]) || 0 },
        opacity: ((Z = w.opacity) == null ? void 0 : Z.value) || 100
      }, a.value = w.blendMode || "normal", l.value = w.effects || []);
    }, { immediate: !0 }), ae(() => o.value.scale.x, (w, T) => {
      if (s.value && w !== T) {
        const P = w / T;
        o.value.scale.y = Math.round(o.value.scale.y * P * 10) / 10;
      }
    });
    function m(w) {
      const T = n.value.indexOf(w);
      T >= 0 ? n.value.splice(T, 1) : n.value.push(w);
    }
    function p() {
      h.value && i.value && (h.value.name = i.value);
    }
    function y() {
      h.value && (h.value.position && (h.value.position.value = [o.value.position.x, o.value.position.y]), h.value.scale && (h.value.scale.value = [o.value.scale.x, o.value.scale.y]), h.value.rotation && (h.value.rotation.value = o.value.rotation), h.value.anchorPoint && (h.value.anchorPoint.value = [o.value.anchorPoint.x, o.value.anchorPoint.y]), h.value.opacity && (h.value.opacity.value = o.value.opacity));
    }
    function v() {
      h.value && (h.value.blendMode = a.value);
    }
    function _(w) {
      return c.value.includes(w);
    }
    function g(w) {
      const T = c.value.indexOf(w);
      T >= 0 ? c.value.splice(T, 1) : (c.value.push(w), console.log(`Added keyframe for ${w} at frame ${e.currentFrame}`));
    }
    function C(w) {
      l.value[w] && (l.value[w].enabled = !l.value[w].enabled);
    }
    function x(w) {
      l.value.splice(w, 1), h.value && h.value.effects && h.value.effects.splice(w, 1);
    }
    function k() {
      e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    }
    return (w, T) => (H(), G("div", Ux, [
      T[28] || (T[28] = d("div", { class: "panel-header" }, [
        d("span", { class: "panel-title" }, "Properties")
      ], -1)),
      h.value ? (H(), G("div", Hx, [
        d("div", Xx, [
          d("div", Gx, [
            Wt(d("input", {
              type: "text",
              "onUpdate:modelValue": T[0] || (T[0] = (P) => i.value = P),
              class: "layer-name-input",
              onBlur: p,
              onKeydown: T[1] || (T[1] = sl((P) => P.target.blur(), ["enter"]))
            }, null, 544), [
              [ge, i.value]
            ])
          ])
        ]),
        d("div", Yx, [
          d("div", {
            class: "section-header",
            onClick: T[2] || (T[2] = (P) => m("transform"))
          }, [
            d("span", Kx, ct(n.value.includes("transform") ? "" : ""), 1),
            T[19] || (T[19] = d("span", { class: "section-title" }, "Transform", -1))
          ]),
          n.value.includes("transform") ? (H(), G("div", qx, [
            d("div", Zx, [
              T[20] || (T[20] = d("label", null, "Position", -1)),
              d("div", Jx, [
                Pt(At(re), {
                  modelValue: o.value.position.x,
                  "onUpdate:modelValue": [
                    T[3] || (T[3] = (P) => o.value.position.x = P),
                    y
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"]),
                Pt(At(re), {
                  modelValue: o.value.position.y,
                  "onUpdate:modelValue": [
                    T[4] || (T[4] = (P) => o.value.position.y = P),
                    y
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              d("button", {
                class: wt(["keyframe-btn", { active: _("position") }]),
                onClick: T[5] || (T[5] = (P) => g("position"))
              }, "", 2)
            ]),
            d("div", Qx, [
              T[21] || (T[21] = d("label", null, "Scale", -1)),
              d("div", tw, [
                Pt(At(re), {
                  modelValue: o.value.scale.x,
                  "onUpdate:modelValue": [
                    T[6] || (T[6] = (P) => o.value.scale.x = P),
                    y
                  ],
                  min: 0,
                  max: 1e3,
                  precision: 1,
                  unit: "%"
                }, null, 8, ["modelValue"]),
                d("button", {
                  class: wt(["link-btn", { active: s.value }]),
                  onClick: T[7] || (T[7] = (P) => s.value = !s.value),
                  title: "Link scale values"
                }, "  ", 2),
                Pt(At(re), {
                  modelValue: o.value.scale.y,
                  "onUpdate:modelValue": [
                    T[8] || (T[8] = (P) => o.value.scale.y = P),
                    y
                  ],
                  min: 0,
                  max: 1e3,
                  precision: 1,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              d("button", {
                class: wt(["keyframe-btn", { active: _("scale") }]),
                onClick: T[9] || (T[9] = (P) => g("scale"))
              }, "", 2)
            ]),
            d("div", ew, [
              T[22] || (T[22] = d("label", null, "Rotation", -1)),
              d("div", nw, [
                Pt(At(re), {
                  modelValue: o.value.rotation,
                  "onUpdate:modelValue": [
                    T[10] || (T[10] = (P) => o.value.rotation = P),
                    y
                  ],
                  min: -180,
                  max: 180,
                  precision: 1,
                  wrap: !0,
                  unit: ""
                }, null, 8, ["modelValue"])
              ]),
              d("button", {
                class: wt(["keyframe-btn", { active: _("rotation") }]),
                onClick: T[11] || (T[11] = (P) => g("rotation"))
              }, "", 2)
            ]),
            d("div", sw, [
              T[23] || (T[23] = d("label", null, "Anchor Point", -1)),
              d("div", iw, [
                Pt(At(re), {
                  modelValue: o.value.anchorPoint.x,
                  "onUpdate:modelValue": [
                    T[12] || (T[12] = (P) => o.value.anchorPoint.x = P),
                    y
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"]),
                Pt(At(re), {
                  modelValue: o.value.anchorPoint.y,
                  "onUpdate:modelValue": [
                    T[13] || (T[13] = (P) => o.value.anchorPoint.y = P),
                    y
                  ],
                  min: -1e4,
                  max: 1e4,
                  precision: 1,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              d("button", {
                class: wt(["keyframe-btn", { active: _("anchorPoint") }]),
                onClick: T[14] || (T[14] = (P) => g("anchorPoint"))
              }, "", 2)
            ]),
            d("div", rw, [
              T[24] || (T[24] = d("label", null, "Opacity", -1)),
              d("div", ow, [
                Pt(At(We), {
                  modelValue: o.value.opacity,
                  "onUpdate:modelValue": [
                    T[15] || (T[15] = (P) => o.value.opacity = P),
                    y
                  ],
                  min: 0,
                  max: 100,
                  precision: 0,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              d("button", {
                class: wt(["keyframe-btn", { active: _("opacity") }]),
                onClick: T[16] || (T[16] = (P) => g("opacity"))
              }, "", 2)
            ])
          ])) : xt("", !0)
        ]),
        d("div", aw, [
          d("div", lw, [
            T[25] || (T[25] = d("label", null, "Blend Mode", -1)),
            Wt(d("select", {
              "onUpdate:modelValue": T[17] || (T[17] = (P) => a.value = P),
              class: "blend-select",
              onChange: v
            }, [
              (H(), G(Dt, null, jt(u, (P) => d("option", {
                key: P.value,
                value: P.value
              }, ct(P.label), 9, cw)), 64))
            ], 544), [
              [Kn, a.value]
            ])
          ])
        ]),
        l.value.length > 0 ? (H(), G("div", uw, [
          d("div", {
            class: "section-header",
            onClick: T[18] || (T[18] = (P) => m("effects"))
          }, [
            d("span", hw, ct(n.value.includes("effects") ? "" : ""), 1),
            T[26] || (T[26] = d("span", { class: "section-title" }, "Effects", -1)),
            d("span", dw, ct(l.value.length), 1)
          ]),
          n.value.includes("effects") ? (H(), G("div", fw, [
            (H(!0), G(Dt, null, jt(l.value, (P, z) => (H(), G("div", {
              key: P.id,
              class: "effect-item"
            }, [
              d("div", pw, [
                d("input", {
                  type: "checkbox",
                  checked: P.enabled,
                  onChange: (j) => C(z),
                  class: "effect-toggle"
                }, null, 40, mw),
                d("span", gw, ct(P.name), 1),
                d("button", {
                  class: "effect-delete",
                  onClick: (j) => x(z)
                }, "", 8, vw)
              ])
            ]))), 128))
          ])) : xt("", !0)
        ])) : xt("", !0),
        f.value ? (H(), ce(wh(f.value), {
          key: 1,
          layer: h.value,
          onUpdate: k
        }, null, 40, ["layer"])) : xt("", !0)
      ])) : (H(), G("div", yw, [...T[27] || (T[27] = [
        d("p", null, "No layer selected", -1),
        d("p", { class: "hint" }, "Select a layer to edit its properties", -1)
      ])]))
    ]));
  }
}), _w = /* @__PURE__ */ we(bw, [["__scopeId", "data-v-f71a36c8"]]);
function zt(r, e, n) {
  return { x: r, y: e, z: n };
}
function Nt(r, e) {
  return { x: r.x + e.x, y: r.y + e.y, z: r.z + e.z };
}
function zl(r, e) {
  return { x: r.x - e.x, y: r.y - e.y, z: r.z - e.z };
}
function Ht(r, e) {
  return { x: r.x * e, y: r.y * e, z: r.z * e };
}
function xw(r) {
  return Math.sqrt(r.x * r.x + r.y * r.y + r.z * r.z);
}
function qn(r) {
  const e = xw(r);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: r.x / e, y: r.y / e, z: r.z / e };
}
function xi(r, e) {
  return {
    x: r.y * e.z - r.z * e.y,
    y: r.z * e.x - r.x * e.z,
    z: r.x * e.y - r.y * e.x
  };
}
function Pa(r, e) {
  return r.x * e.x + r.y * e.y + r.z * e.z;
}
function ww(r, e, n, s) {
  const i = new Float32Array(16), o = 1 / Math.tan(r / 2), a = 1 / (n - s);
  return i[0] = o / e, i[1] = 0, i[2] = 0, i[3] = 0, i[4] = 0, i[5] = o, i[6] = 0, i[7] = 0, i[8] = 0, i[9] = 0, i[10] = (s + n) * a, i[11] = -1, i[12] = 0, i[13] = 0, i[14] = 2 * s * n * a, i[15] = 0, { elements: i };
}
function Sw(r, e, n, s, i, o) {
  const a = new Float32Array(16), l = 1 / (e - r), c = 1 / (s - n), u = 1 / (o - i);
  return a[0] = 2 * l, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * c, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = -2 * u, a[11] = 0, a[12] = -(e + r) * l, a[13] = -(s + n) * c, a[14] = -10001 * u, a[15] = 1, { elements: a };
}
function kn(r, e, n) {
  const s = new Float32Array(16);
  let i = r.x - e.x, o = r.y - e.y, a = r.z - e.z, l = Math.sqrt(i * i + o * o + a * a);
  l === 0 ? a = 1 : (l = 1 / l, i *= l, o *= l, a *= l);
  let c = n.y * a - n.z * o, u = n.z * i - n.x * a, h = n.x * o - n.y * i;
  l = Math.sqrt(c * c + u * u + h * h), l === 0 ? (c = 0, u = 0, h = 0) : (l = 1 / l, c *= l, u *= l, h *= l);
  let f = o * h - a * u, m = a * c - i * h, p = i * u - o * c;
  return l = Math.sqrt(f * f + m * m + p * p), l === 0 ? (f = 0, m = 0, p = 0) : (l = 1 / l, f *= l, m *= l, p *= l), s[0] = c, s[4] = u, s[8] = h, s[12] = -Pa({ x: c, y: u, z: h }, r), s[1] = f, s[5] = m, s[9] = p, s[13] = -Pa({ x: f, y: m, z: p }, r), s[2] = i, s[6] = o, s[10] = a, s[14] = -Pa({ x: i, y: o, z: a }, r), s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, { elements: s };
}
function Cw(r, e) {
  const n = r.elements, s = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / s,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / s,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / s
  };
}
function jl(r, e) {
  return 2 * Math.atan(e / (2 * r));
}
function kw(r, e) {
  return e / (2 * Math.tan(r / 2));
}
const Tw = { class: "camera-properties" }, Mw = { class: "panel-header" }, Ow = { class: "camera-name" }, Ew = {
  key: 0,
  class: "properties-content"
}, Pw = { class: "property-section" }, Dw = { class: "property-row" }, Aw = ["value"], Fw = { class: "property-section" }, Iw = { class: "toggle-icon" }, Lw = { class: "section-content" }, Rw = { class: "property-group" }, zw = { class: "xyz-inputs" }, jw = {
  key: 0,
  class: "property-group"
}, Bw = { class: "xyz-inputs" }, Vw = { class: "property-group" }, $w = { class: "xyz-inputs" }, Nw = { class: "property-group" }, Ww = { class: "property-group" }, Uw = { class: "property-group" }, Hw = { class: "property-section" }, Xw = { class: "toggle-icon" }, Gw = { class: "section-content" }, Yw = { class: "preset-row" }, Kw = ["onClick"], qw = { class: "property-group" }, Zw = { class: "property-group" }, Jw = { class: "property-group" }, Qw = { class: "property-group" }, t2 = ["value"], e2 = { class: "property-section" }, n2 = { class: "toggle-icon" }, s2 = { class: "section-content" }, i2 = { class: "property-group checkbox-group" }, r2 = ["checked"], o2 = { class: "property-group" }, a2 = { class: "property-group" }, l2 = { class: "property-group" }, c2 = { class: "property-group checkbox-group" }, u2 = ["checked"], h2 = { class: "property-section" }, d2 = { class: "toggle-icon" }, f2 = { class: "section-content" }, p2 = { class: "property-group" }, m2 = { class: "property-group" }, g2 = { class: "property-group" }, v2 = { class: "property-group" }, y2 = { class: "property-group" }, b2 = { class: "property-section" }, _2 = { class: "toggle-icon" }, x2 = { class: "section-content" }, w2 = { class: "property-group" }, S2 = { class: "property-group" }, C2 = { class: "property-group" }, k2 = { class: "property-section" }, T2 = { class: "toggle-icon" }, M2 = { class: "section-content" }, O2 = { class: "property-group" }, E2 = ["value"], P2 = { class: "property-section" }, D2 = { class: "toggle-icon" }, A2 = { class: "section-content" }, F2 = { class: "property-group" }, I2 = { class: "property-group" }, L2 = {
  key: 1,
  class: "no-camera"
}, R2 = /* @__PURE__ */ ye({
  __name: "CameraProperties",
  props: {
    camera: {}
  },
  emits: ["update:camera", "createCamera"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = Xs({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1
    });
    function o(_) {
      i[_] = !i[_];
    }
    function a(_, g) {
      n.camera && s("update:camera", { ...n.camera, [_]: g });
    }
    function l(_, g) {
      n.camera && s("update:camera", {
        ...n.camera,
        position: { ...n.camera.position, [_]: g }
      });
    }
    function c(_, g) {
      n.camera && s("update:camera", {
        ...n.camera,
        pointOfInterest: { ...n.camera.pointOfInterest, [_]: g }
      });
    }
    function u(_, g) {
      n.camera && s("update:camera", {
        ...n.camera,
        orientation: { ...n.camera.orientation, [_]: g }
      });
    }
    function h(_) {
      if (!n.camera) return;
      const g = jl(_, n.camera.filmSize);
      s("update:camera", {
        ...n.camera,
        focalLength: _,
        angleOfView: g
      });
    }
    function f(_) {
      if (!n.camera) return;
      const g = kw(_, n.camera.filmSize);
      s("update:camera", {
        ...n.camera,
        angleOfView: _,
        focalLength: g
      });
    }
    function m(_, g) {
      n.camera && s("update:camera", {
        ...n.camera,
        depthOfField: { ...n.camera.depthOfField, [_]: g }
      });
    }
    function p(_, g) {
      n.camera && s("update:camera", {
        ...n.camera,
        iris: { ...n.camera.iris, [_]: g }
      });
    }
    function y(_, g) {
      n.camera && s("update:camera", {
        ...n.camera,
        highlight: { ...n.camera.highlight, [_]: g }
      });
    }
    function v(_) {
      n.camera && s("update:camera", {
        ...n.camera,
        focalLength: _.focalLength,
        angleOfView: _.angleOfView,
        zoom: _.zoom
      });
    }
    return (_, g) => {
      var C;
      return H(), G("div", Tw, [
        d("div", Mw, [
          g[39] || (g[39] = d("span", { class: "panel-title" }, "Camera", -1)),
          d("span", Ow, ct(((C = r.camera) == null ? void 0 : C.name) ?? "No Camera"), 1)
        ]),
        r.camera ? (H(), G("div", Ew, [
          d("div", Pw, [
            g[41] || (g[41] = d("div", { class: "section-header" }, "Type", -1)),
            d("div", Dw, [
              d("select", {
                value: r.camera.type,
                onChange: g[0] || (g[0] = (x) => a("type", x.target.value)),
                class: "type-select"
              }, [...g[40] || (g[40] = [
                d("option", { value: "one-node" }, "One-Node Camera", -1),
                d("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, Aw)
            ])
          ]),
          d("div", Fw, [
            d("div", {
              class: "section-header",
              onClick: g[1] || (g[1] = (x) => o("transform"))
            }, [
              d("span", Iw, ct(i.transform ? "" : ""), 1),
              g[42] || (g[42] = qt(" Transform ", -1))
            ]),
            Wt(d("div", Lw, [
              d("div", Rw, [
                g[43] || (g[43] = d("label", null, "Position", -1)),
                d("div", zw, [
                  Pt(At(re), {
                    modelValue: r.camera.position.x,
                    "onUpdate:modelValue": g[2] || (g[2] = (x) => l("x", x)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Pt(At(re), {
                    modelValue: r.camera.position.y,
                    "onUpdate:modelValue": g[3] || (g[3] = (x) => l("y", x)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Pt(At(re), {
                    modelValue: r.camera.position.z,
                    "onUpdate:modelValue": g[4] || (g[4] = (x) => l("z", x)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              r.camera.type === "two-node" ? (H(), G("div", jw, [
                g[44] || (g[44] = d("label", null, "Point of Interest", -1)),
                d("div", Bw, [
                  Pt(At(re), {
                    modelValue: r.camera.pointOfInterest.x,
                    "onUpdate:modelValue": g[5] || (g[5] = (x) => c("x", x)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Pt(At(re), {
                    modelValue: r.camera.pointOfInterest.y,
                    "onUpdate:modelValue": g[6] || (g[6] = (x) => c("y", x)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Pt(At(re), {
                    modelValue: r.camera.pointOfInterest.z,
                    "onUpdate:modelValue": g[7] || (g[7] = (x) => c("z", x)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : xt("", !0),
              d("div", Vw, [
                g[45] || (g[45] = d("label", null, "Orientation", -1)),
                d("div", $w, [
                  Pt(At(re), {
                    modelValue: r.camera.orientation.x,
                    "onUpdate:modelValue": g[8] || (g[8] = (x) => u("x", x)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Pt(At(re), {
                    modelValue: r.camera.orientation.y,
                    "onUpdate:modelValue": g[9] || (g[9] = (x) => u("y", x)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Pt(At(re), {
                    modelValue: r.camera.orientation.z,
                    "onUpdate:modelValue": g[10] || (g[10] = (x) => u("z", x)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              d("div", Nw, [
                g[46] || (g[46] = d("label", null, "X Rotation", -1)),
                Pt(At(re), {
                  modelValue: r.camera.xRotation,
                  "onUpdate:modelValue": g[11] || (g[11] = (x) => a("xRotation", x)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              d("div", Ww, [
                g[47] || (g[47] = d("label", null, "Y Rotation", -1)),
                Pt(At(re), {
                  modelValue: r.camera.yRotation,
                  "onUpdate:modelValue": g[12] || (g[12] = (x) => a("yRotation", x)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              d("div", Uw, [
                g[48] || (g[48] = d("label", null, "Z Rotation", -1)),
                Pt(At(re), {
                  modelValue: r.camera.zRotation,
                  "onUpdate:modelValue": g[13] || (g[13] = (x) => a("zRotation", x)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Ds, i.transform]
            ])
          ]),
          d("div", Hw, [
            d("div", {
              class: "section-header",
              onClick: g[14] || (g[14] = (x) => o("lens"))
            }, [
              d("span", Xw, ct(i.lens ? "" : ""), 1),
              g[49] || (g[49] = qt(" Lens ", -1))
            ]),
            Wt(d("div", Gw, [
              d("div", Yw, [
                (H(!0), G(Dt, null, jt(At(wg), (x) => (H(), G("button", {
                  key: x.name,
                  class: wt({ active: Math.abs(r.camera.focalLength - x.focalLength) < 0.5 }),
                  onClick: (k) => v(x)
                }, ct(x.name), 11, Kw))), 128))
              ]),
              d("div", qw, [
                g[50] || (g[50] = d("label", null, "Focal Length", -1)),
                Pt(At(re), {
                  modelValue: r.camera.focalLength,
                  "onUpdate:modelValue": h,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              d("div", Zw, [
                g[51] || (g[51] = d("label", null, "Angle of View", -1)),
                Pt(At(re), {
                  modelValue: r.camera.angleOfView,
                  "onUpdate:modelValue": f,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              d("div", Jw, [
                g[52] || (g[52] = d("label", null, "Film Size", -1)),
                Pt(At(re), {
                  modelValue: r.camera.filmSize,
                  "onUpdate:modelValue": g[15] || (g[15] = (x) => a("filmSize", x)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              d("div", Qw, [
                g[54] || (g[54] = d("label", null, "Measure Film Size", -1)),
                d("select", {
                  value: r.camera.measureFilmSize,
                  onChange: g[16] || (g[16] = (x) => a("measureFilmSize", x.target.value))
                }, [...g[53] || (g[53] = [
                  d("option", { value: "horizontal" }, "Horizontal", -1),
                  d("option", { value: "vertical" }, "Vertical", -1),
                  d("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, t2)
              ])
            ], 512), [
              [Ds, i.lens]
            ])
          ]),
          d("div", e2, [
            d("div", {
              class: "section-header",
              onClick: g[17] || (g[17] = (x) => o("dof"))
            }, [
              d("span", n2, ct(i.dof ? "" : ""), 1),
              g[55] || (g[55] = qt(" Depth of Field ", -1))
            ]),
            Wt(d("div", s2, [
              d("div", i2, [
                d("label", null, [
                  d("input", {
                    type: "checkbox",
                    checked: r.camera.depthOfField.enabled,
                    onChange: g[18] || (g[18] = (x) => m("enabled", x.target.checked))
                  }, null, 40, r2),
                  g[56] || (g[56] = qt(" Enable DOF ", -1))
                ])
              ]),
              r.camera.depthOfField.enabled ? (H(), G(Dt, { key: 0 }, [
                d("div", o2, [
                  g[57] || (g[57] = d("label", null, "Focus Distance", -1)),
                  Pt(At(re), {
                    modelValue: r.camera.depthOfField.focusDistance,
                    "onUpdate:modelValue": g[19] || (g[19] = (x) => m("focusDistance", x)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                d("div", a2, [
                  g[58] || (g[58] = d("label", null, "f-Stop", -1)),
                  Pt(At(re), {
                    modelValue: r.camera.depthOfField.fStop,
                    "onUpdate:modelValue": g[20] || (g[20] = (x) => m("fStop", x)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                d("div", l2, [
                  g[59] || (g[59] = d("label", null, "Blur Level", -1)),
                  Pt(At(We), {
                    modelValue: r.camera.depthOfField.blurLevel,
                    "onUpdate:modelValue": g[21] || (g[21] = (x) => m("blurLevel", x)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                d("div", c2, [
                  d("label", null, [
                    d("input", {
                      type: "checkbox",
                      checked: r.camera.depthOfField.lockToZoom,
                      onChange: g[22] || (g[22] = (x) => m("lockToZoom", x.target.checked))
                    }, null, 40, u2),
                    g[60] || (g[60] = qt(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : xt("", !0)
            ], 512), [
              [Ds, i.dof]
            ])
          ]),
          d("div", h2, [
            d("div", {
              class: "section-header",
              onClick: g[23] || (g[23] = (x) => o("iris"))
            }, [
              d("span", d2, ct(i.iris ? "" : ""), 1),
              g[61] || (g[61] = qt(" Iris ", -1))
            ]),
            Wt(d("div", f2, [
              d("div", p2, [
                d("label", null, "Shape (" + ct(Math.round(r.camera.iris.shape)) + "-gon)", 1),
                Pt(At(We), {
                  modelValue: r.camera.iris.shape,
                  "onUpdate:modelValue": g[24] || (g[24] = (x) => p("shape", x)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              d("div", m2, [
                g[62] || (g[62] = d("label", null, "Rotation", -1)),
                Pt(At(Nv), {
                  modelValue: r.camera.iris.rotation,
                  "onUpdate:modelValue": g[25] || (g[25] = (x) => p("rotation", x)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              d("div", g2, [
                g[63] || (g[63] = d("label", null, "Roundness", -1)),
                Pt(At(We), {
                  modelValue: r.camera.iris.roundness,
                  "onUpdate:modelValue": g[26] || (g[26] = (x) => p("roundness", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              d("div", v2, [
                g[64] || (g[64] = d("label", null, "Aspect Ratio", -1)),
                Pt(At(We), {
                  modelValue: r.camera.iris.aspectRatio,
                  "onUpdate:modelValue": g[27] || (g[27] = (x) => p("aspectRatio", x)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              d("div", y2, [
                g[65] || (g[65] = d("label", null, "Diffraction Fringe", -1)),
                Pt(At(We), {
                  modelValue: r.camera.iris.diffractionFringe,
                  "onUpdate:modelValue": g[28] || (g[28] = (x) => p("diffractionFringe", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Ds, i.iris]
            ])
          ]),
          d("div", b2, [
            d("div", {
              class: "section-header",
              onClick: g[29] || (g[29] = (x) => o("highlight"))
            }, [
              d("span", _2, ct(i.highlight ? "" : ""), 1),
              g[66] || (g[66] = qt(" Highlight ", -1))
            ]),
            Wt(d("div", x2, [
              d("div", w2, [
                g[67] || (g[67] = d("label", null, "Gain", -1)),
                Pt(At(We), {
                  modelValue: r.camera.highlight.gain,
                  "onUpdate:modelValue": g[30] || (g[30] = (x) => y("gain", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              d("div", S2, [
                g[68] || (g[68] = d("label", null, "Threshold", -1)),
                Pt(At(We), {
                  modelValue: r.camera.highlight.threshold,
                  "onUpdate:modelValue": g[31] || (g[31] = (x) => y("threshold", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              d("div", C2, [
                g[69] || (g[69] = d("label", null, "Saturation", -1)),
                Pt(At(We), {
                  modelValue: r.camera.highlight.saturation,
                  "onUpdate:modelValue": g[32] || (g[32] = (x) => y("saturation", x)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Ds, i.highlight]
            ])
          ]),
          d("div", k2, [
            d("div", {
              class: "section-header",
              onClick: g[33] || (g[33] = (x) => o("autoOrient"))
            }, [
              d("span", T2, ct(i.autoOrient ? "" : ""), 1),
              g[70] || (g[70] = qt(" Auto-Orient ", -1))
            ]),
            Wt(d("div", M2, [
              d("div", O2, [
                d("select", {
                  value: r.camera.autoOrient,
                  onChange: g[34] || (g[34] = (x) => a("autoOrient", x.target.value))
                }, [...g[71] || (g[71] = [
                  d("option", { value: "off" }, "Off", -1),
                  d("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  d("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, E2)
              ])
            ], 512), [
              [Ds, i.autoOrient]
            ])
          ]),
          d("div", P2, [
            d("div", {
              class: "section-header",
              onClick: g[35] || (g[35] = (x) => o("clipping"))
            }, [
              d("span", D2, ct(i.clipping ? "" : ""), 1),
              g[72] || (g[72] = qt(" Clipping ", -1))
            ]),
            Wt(d("div", A2, [
              d("div", F2, [
                g[73] || (g[73] = d("label", null, "Near Clip", -1)),
                Pt(At(re), {
                  modelValue: r.camera.nearClip,
                  "onUpdate:modelValue": g[36] || (g[36] = (x) => a("nearClip", x)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              d("div", I2, [
                g[74] || (g[74] = d("label", null, "Far Clip", -1)),
                Pt(At(re), {
                  modelValue: r.camera.farClip,
                  "onUpdate:modelValue": g[37] || (g[37] = (x) => a("farClip", x)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Ds, i.clipping]
            ])
          ])
        ])) : (H(), G("div", L2, [
          g[75] || (g[75] = d("p", null, "No camera selected", -1)),
          d("button", {
            onClick: g[38] || (g[38] = (x) => _.$emit("createCamera"))
          }, "Create Camera")
        ]))
      ]);
    };
  }
}), z2 = /* @__PURE__ */ we(R2, [["__scopeId", "data-v-746aa734"]]), j2 = { class: "audio-panel" }, B2 = {
  key: 0,
  class: "panel-content"
}, V2 = { class: "audio-info" }, $2 = { class: "file-info" }, N2 = { class: "file-details" }, W2 = { class: "file-name" }, U2 = { class: "file-meta" }, H2 = { class: "control-section" }, X2 = { class: "control-row" }, G2 = { class: "waveform-section" }, Y2 = { class: "section-header" }, K2 = { class: "waveform-controls" }, q2 = { class: "waveform-display" }, Z2 = { class: "control-section" }, J2 = { class: "expand-icon" }, Q2 = {
  key: 0,
  class: "section-content"
}, tS = { class: "control-row" }, eS = { class: "control-row" }, nS = { class: "beat-indicator" }, sS = { class: "beat-value" }, iS = { class: "control-section" }, rS = { class: "expand-icon" }, oS = {
  key: 0,
  class: "section-content"
}, aS = { class: "frequency-bands" }, lS = { class: "band-name" }, cS = { class: "band-meter" }, uS = { class: "band-value" }, hS = { class: "control-section" }, dS = { class: "expand-icon" }, fS = {
  key: 0,
  class: "section-content"
}, pS = { class: "control-row" }, mS = ["value"], gS = {
  key: 0,
  class: "reactivity-options"
}, vS = { class: "control-row" }, yS = { class: "control-row" }, bS = { class: "control-row" }, _S = { class: "control-row" }, xS = {
  key: 1,
  class: "empty-state"
}, wS = /* @__PURE__ */ ye({
  __name: "AudioPanel",
  setup(r) {
    const e = qe(), n = ut(null), s = ut(null), i = ut(["beats", "bands"]), o = ut("waveform"), a = ut(80), l = ut(!1), c = ut(70), u = ut(50), h = ut(120), f = ut(!1), m = ut([
      { name: "Bass", level: 45 },
      { name: "Low", level: 60 },
      { name: "Mid", level: 75 },
      { name: "High", level: 55 },
      { name: "Treble", level: 40 }
    ]), p = ut(""), y = ut("opacity"), v = ut("bass"), _ = ut(100), g = ut(50), C = St(() => !!e.audioBuffer), x = St(() => {
      var U;
      return ((U = e.audioFile) == null ? void 0 : U.name) || "Unknown";
    }), k = St(() => {
      if (!e.audioBuffer) return "0:00";
      const U = e.audioBuffer.duration, W = Math.floor(U / 60), Z = Math.floor(U % 60);
      return `${W}:${String(Z).padStart(2, "0")}`;
    }), w = St(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : "0 Hz"), T = St(() => {
      var U, W;
      return ((W = (U = e.project) == null ? void 0 : U.composition) == null ? void 0 : W.layers) || [];
    });
    function P() {
      var U;
      (U = n.value) == null || U.click();
    }
    async function z(U) {
      var yt;
      const W = U.target;
      if (!((yt = W.files) != null && yt.length)) return;
      const Z = W.files[0];
      await e.loadAudio(Z), W.value = "";
    }
    function j() {
      e.clearAudio();
    }
    function ot() {
      l.value = !l.value;
    }
    function vt(U) {
      const W = i.value.indexOf(U);
      W >= 0 ? i.value.splice(W, 1) : i.value.push(U);
    }
    function L() {
      if (!s.value || !e.audioBuffer) return;
      const U = s.value, W = U.getContext("2d");
      if (!W) return;
      const Z = U.getBoundingClientRect();
      U.width = Z.width * window.devicePixelRatio, U.height = Z.height * window.devicePixelRatio, W.scale(window.devicePixelRatio, window.devicePixelRatio), Y(W, Z.width, Z.height);
    }
    function Y(U, W, Z) {
      if (!e.audioBuffer) return;
      const yt = e.audioBuffer.getChannelData(0), Q = Math.ceil(yt.length / W), at = Z / 2;
      U.fillStyle = "#1a1a1a", U.fillRect(0, 0, W, Z), U.beginPath(), U.strokeStyle = "#4a90d9", U.lineWidth = 1;
      for (let ht = 0; ht < W; ht++) {
        let X = 1, kt = -1;
        for (let it = 0; it < Q; it++) {
          const E = yt[ht * Q + it];
          E < X && (X = E), E > kt && (kt = E);
        }
        const lt = (1 + X) * at, pt = (1 + kt) * at;
        U.moveTo(ht, lt), U.lineTo(ht, pt);
      }
      U.stroke();
      const _t = e.currentFrame / e.frameCount * W;
      U.beginPath(), U.strokeStyle = "#fff", U.lineWidth = 1, U.moveTo(_t, 0), U.lineTo(_t, Z), U.stroke();
    }
    let M;
    function I() {
      const W = 6e4 / h.value;
      M = window.setInterval(() => {
        f.value = !0, setTimeout(() => {
          f.value = !1;
        }, 100), m.value = m.value.map((Z) => ({
          ...Z,
          level: Math.min(100, Math.max(10, Z.level + (Math.random() - 0.5) * 30))
        }));
      }, W);
    }
    function tt() {
      clearInterval(M);
    }
    return Ne(() => {
      C.value && (L(), I());
    }), wn(() => {
      tt();
    }), ae(C, (U) => {
      U ? setTimeout(() => {
        L(), I();
      }, 100) : tt();
    }), ae(() => e.currentFrame, () => {
      if (C.value && s.value) {
        const U = s.value.getContext("2d");
        if (U) {
          const W = s.value.getBoundingClientRect();
          Y(U, W.width, W.height);
        }
      }
    }), (U, W) => (H(), G("div", j2, [
      d("div", { class: "panel-header" }, [
        W[14] || (W[14] = d("span", { class: "panel-title" }, "Audio", -1)),
        d("div", { class: "header-actions" }, [
          d("button", {
            onClick: P,
            title: "Load Audio"
          }, [...W[13] || (W[13] = [
            d("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      C.value ? (H(), G("div", B2, [
        d("div", V2, [
          d("div", $2, [
            W[15] || (W[15] = d("span", { class: "file-icon" }, "", -1)),
            d("div", N2, [
              d("span", W2, ct(x.value), 1),
              d("span", U2, ct(k.value) + "  " + ct(w.value), 1)
            ]),
            d("button", {
              class: "remove-btn",
              onClick: j,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        d("div", H2, [
          d("div", X2, [
            W[16] || (W[16] = d("label", null, "Master Volume", -1)),
            Pt(At(We), {
              modelValue: a.value,
              "onUpdate:modelValue": W[0] || (W[0] = (Z) => a.value = Z),
              min: 0,
              max: 100,
              precision: 0,
              unit: "%"
            }, null, 8, ["modelValue"]),
            d("button", {
              class: wt(["mute-btn", { active: l.value }]),
              onClick: ot,
              title: "Mute"
            }, ct(l.value ? "" : ""), 3)
          ])
        ]),
        d("div", G2, [
          d("div", Y2, [
            W[17] || (W[17] = d("span", { class: "section-title" }, "Waveform", -1)),
            d("div", K2, [
              d("button", {
                class: wt({ active: o.value === "waveform" }),
                onClick: W[1] || (W[1] = (Z) => o.value = "waveform")
              }, " Wave ", 2),
              d("button", {
                class: wt({ active: o.value === "spectrum" }),
                onClick: W[2] || (W[2] = (Z) => o.value = "spectrum")
              }, " Spectrum ", 2)
            ])
          ]),
          d("div", q2, [
            d("canvas", {
              ref_key: "waveformCanvas",
              ref: s,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        d("div", Z2, [
          d("div", {
            class: "section-header",
            onClick: W[3] || (W[3] = (Z) => vt("beats"))
          }, [
            d("span", J2, ct(i.value.includes("beats") ? "" : ""), 1),
            W[18] || (W[18] = d("span", { class: "section-title" }, "Beat Detection", -1))
          ]),
          i.value.includes("beats") ? (H(), G("div", Q2, [
            d("div", tS, [
              W[19] || (W[19] = d("label", null, "Sensitivity", -1)),
              Pt(At(We), {
                modelValue: c.value,
                "onUpdate:modelValue": W[4] || (W[4] = (Z) => c.value = Z),
                min: 0,
                max: 100,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            d("div", eS, [
              W[20] || (W[20] = d("label", null, "Threshold", -1)),
              Pt(At(We), {
                modelValue: u.value,
                "onUpdate:modelValue": W[5] || (W[5] = (Z) => u.value = Z),
                min: 0,
                max: 100,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            d("div", nS, [
              W[21] || (W[21] = d("span", { class: "beat-label" }, "BPM:", -1)),
              d("span", sS, ct(h.value), 1),
              d("span", {
                class: wt(["beat-pulse", { active: f.value }])
              }, null, 2)
            ])
          ])) : xt("", !0)
        ]),
        d("div", iS, [
          d("div", {
            class: "section-header",
            onClick: W[6] || (W[6] = (Z) => vt("bands"))
          }, [
            d("span", rS, ct(i.value.includes("bands") ? "" : ""), 1),
            W[22] || (W[22] = d("span", { class: "section-title" }, "Frequency Bands", -1))
          ]),
          i.value.includes("bands") ? (H(), G("div", oS, [
            d("div", aS, [
              (H(!0), G(Dt, null, jt(m.value, (Z, yt) => (H(), G("div", {
                key: Z.name,
                class: "band-item"
              }, [
                d("span", lS, ct(Z.name), 1),
                d("div", cS, [
                  d("div", {
                    class: "band-fill",
                    style: ne({ height: `${Z.level}%` })
                  }, null, 4)
                ]),
                d("span", uS, ct(Math.round(Z.level)), 1)
              ]))), 128))
            ])
          ])) : xt("", !0)
        ]),
        d("div", hS, [
          d("div", {
            class: "section-header",
            onClick: W[7] || (W[7] = (Z) => vt("reactivity"))
          }, [
            d("span", dS, ct(i.value.includes("reactivity") ? "" : ""), 1),
            W[23] || (W[23] = d("span", { class: "section-title" }, "Audio Reactivity", -1))
          ]),
          i.value.includes("reactivity") ? (H(), G("div", fS, [
            d("div", pS, [
              W[25] || (W[25] = d("label", null, "Link to Layer", -1)),
              Wt(d("select", {
                "onUpdate:modelValue": W[8] || (W[8] = (Z) => p.value = Z),
                class: "layer-select"
              }, [
                W[24] || (W[24] = d("option", { value: "" }, "None", -1)),
                (H(!0), G(Dt, null, jt(T.value, (Z) => (H(), G("option", {
                  key: Z.id,
                  value: Z.id
                }, ct(Z.name), 9, mS))), 128))
              ], 512), [
                [Kn, p.value]
              ])
            ]),
            p.value ? (H(), G("div", gS, [
              d("div", vS, [
                W[27] || (W[27] = d("label", null, "Property", -1)),
                Wt(d("select", {
                  "onUpdate:modelValue": W[9] || (W[9] = (Z) => y.value = Z),
                  class: "property-select"
                }, [...W[26] || (W[26] = [
                  bi('<option value="opacity" data-v-589b649c>Opacity</option><option value="scale" data-v-589b649c>Scale</option><option value="rotation" data-v-589b649c>Rotation</option><option value="position.x" data-v-589b649c>Position X</option><option value="position.y" data-v-589b649c>Position Y</option>', 5)
                ])], 512), [
                  [Kn, y.value]
                ])
              ]),
              d("div", yS, [
                W[29] || (W[29] = d("label", null, "Band", -1)),
                Wt(d("select", {
                  "onUpdate:modelValue": W[10] || (W[10] = (Z) => v.value = Z),
                  class: "band-select"
                }, [...W[28] || (W[28] = [
                  bi('<option value="bass" data-v-589b649c>Bass</option><option value="lowMid" data-v-589b649c>Low Mid</option><option value="mid" data-v-589b649c>Mid</option><option value="highMid" data-v-589b649c>High Mid</option><option value="treble" data-v-589b649c>Treble</option><option value="overall" data-v-589b649c>Overall</option>', 6)
                ])], 512), [
                  [Kn, v.value]
                ])
              ]),
              d("div", bS, [
                W[30] || (W[30] = d("label", null, "Intensity", -1)),
                Pt(At(We), {
                  modelValue: _.value,
                  "onUpdate:modelValue": W[11] || (W[11] = (Z) => _.value = Z),
                  min: 0,
                  max: 200,
                  precision: 0,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ]),
              d("div", _S, [
                W[31] || (W[31] = d("label", null, "Smoothing", -1)),
                Pt(At(We), {
                  modelValue: g.value,
                  "onUpdate:modelValue": W[12] || (W[12] = (Z) => g.value = Z),
                  min: 0,
                  max: 100,
                  precision: 0,
                  unit: "%"
                }, null, 8, ["modelValue"])
              ])
            ])) : xt("", !0)
          ])) : xt("", !0)
        ])
      ])) : (H(), G("div", xS, [
        W[32] || (W[32] = d("div", { class: "empty-icon" }, "", -1)),
        W[33] || (W[33] = d("p", null, "No audio loaded", -1)),
        d("button", {
          class: "load-btn",
          onClick: P
        }, " Load Audio File "),
        W[34] || (W[34] = d("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      d("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: z
      }, null, 544)
    ]));
  }
}), SS = /* @__PURE__ */ we(wS, [["__scopeId", "data-v-589b649c"]]), $c = 40, CS = 30;
function kS(r) {
  const e = [], n = "#ffcc00", s = r.position;
  let i;
  if (r.type === "two-node")
    i = qn(zl(r.pointOfInterest, s));
  else {
    const p = r.orientation.x * Math.PI / 180, y = r.orientation.y * Math.PI / 180;
    i = zt(
      Math.sin(y) * Math.cos(p),
      -Math.sin(p),
      Math.cos(y) * Math.cos(p)
    );
  }
  const o = zt(0, -1, 0);
  let a = qn(xi(i, o));
  isNaN(a.x) && (a = zt(1, 0, 0));
  const l = qn(xi(a, i)), c = $c / 2, u = Nt(s, Ht(i, -$c)), h = [];
  for (let p = 0; p < 2; p++) {
    const y = p === 0 ? s : u;
    for (let v = -1; v <= 1; v += 2)
      for (let _ = -1; _ <= 1; _ += 2)
        h.push(Nt(
          Nt(y, Ht(a, v * c)),
          Ht(l, _ * c)
        ));
  }
  e.push({ start: h[0], end: h[1], color: n }), e.push({ start: h[1], end: h[3], color: n }), e.push({ start: h[3], end: h[2], color: n }), e.push({ start: h[2], end: h[0], color: n }), e.push({ start: h[4], end: h[5], color: n }), e.push({ start: h[5], end: h[7], color: n }), e.push({ start: h[7], end: h[6], color: n }), e.push({ start: h[6], end: h[4], color: n }), e.push({ start: h[0], end: h[4], color: n }), e.push({ start: h[1], end: h[5], color: n }), e.push({ start: h[2], end: h[6], color: n }), e.push({ start: h[3], end: h[7], color: n });
  const f = Nt(s, Ht(i, CS)), m = 8;
  for (let p = 0; p < m; p++) {
    const y = p / m * Math.PI * 2, v = (p + 1) / m * Math.PI * 2, _ = Nt(
      Nt(s, Ht(a, Math.cos(y) * c * 0.5)),
      Ht(l, Math.sin(y) * c * 0.5)
    ), g = Nt(
      Nt(s, Ht(a, Math.cos(v) * c * 0.5)),
      Ht(l, Math.sin(v) * c * 0.5)
    );
    e.push({ start: _, end: g, color: n }), e.push({ start: _, end: f, color: n });
  }
  return e;
}
function TS(r, e, n, s = 2e3) {
  const i = [], o = "#7c9cff", a = jl(r.focalLength, r.filmSize), l = e / n, c = r.position;
  let u;
  if (r.type === "two-node")
    u = qn(zl(r.pointOfInterest, c));
  else {
    const P = r.orientation.x * Math.PI / 180, z = r.orientation.y * Math.PI / 180;
    u = zt(
      Math.sin(z) * Math.cos(P),
      -Math.sin(P),
      Math.cos(z) * Math.cos(P)
    );
  }
  const h = zt(0, -1, 0);
  let f = qn(xi(u, h));
  isNaN(f.x) && (f = zt(1, 0, 0));
  const m = qn(xi(f, u)), p = r.nearClip, y = Math.min(r.farClip, s), v = p * Math.tan(a * Math.PI / 360), _ = v * l, g = y * Math.tan(a * Math.PI / 360), C = g * l, x = Nt(c, Ht(u, p)), k = [
    Nt(Nt(x, Ht(f, -_)), Ht(m, v)),
    Nt(Nt(x, Ht(f, _)), Ht(m, v)),
    Nt(Nt(x, Ht(f, _)), Ht(m, -v)),
    Nt(Nt(x, Ht(f, -_)), Ht(m, -v))
  ], w = Nt(c, Ht(u, y)), T = [
    Nt(Nt(w, Ht(f, -C)), Ht(m, g)),
    Nt(Nt(w, Ht(f, C)), Ht(m, g)),
    Nt(Nt(w, Ht(f, C)), Ht(m, -g)),
    Nt(Nt(w, Ht(f, -C)), Ht(m, -g))
  ];
  for (let P = 0; P < 4; P++)
    i.push({ start: k[P], end: k[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    i.push({ start: T[P], end: T[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    i.push({ start: k[P], end: T[P], color: o });
  return i;
}
function MS(r, e) {
  const n = "#00ff88", s = [
    zt(0, 0, 0),
    zt(r, 0, 0),
    zt(r, e, 0),
    zt(0, e, 0)
  ], i = [];
  for (let o = 0; o < 4; o++)
    i.push({ start: s[o], end: s[(o + 1) % 4], color: n });
  return i.push({ start: s[0], end: s[2], color: "#005533" }), i.push({ start: s[1], end: s[3], color: "#005533" }), i;
}
function OS(r) {
  return r.type !== "two-node" ? null : {
    start: r.position,
    end: r.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function ES(r, e, n) {
  if (!r.depthOfField.enabled)
    return [];
  const s = "#ff00ff", i = [], o = r.position, a = r.depthOfField.focusDistance;
  let l;
  if (r.type === "two-node")
    l = qn(zl(r.pointOfInterest, o));
  else {
    const v = r.orientation.x * Math.PI / 180, _ = r.orientation.y * Math.PI / 180;
    l = zt(
      Math.sin(_) * Math.cos(v),
      -Math.sin(v),
      Math.cos(_) * Math.cos(v)
    );
  }
  const c = zt(0, -1, 0);
  let u = qn(xi(l, c));
  isNaN(u.x) && (u = zt(1, 0, 0));
  const h = qn(xi(u, l)), f = Nt(o, Ht(l, a)), m = e / 4, p = n / 4, y = [
    Nt(Nt(f, Ht(u, -m)), Ht(h, p)),
    Nt(Nt(f, Ht(u, m)), Ht(h, p)),
    Nt(Nt(f, Ht(u, m)), Ht(h, -p)),
    Nt(Nt(f, Ht(u, -m)), Ht(h, -p))
  ];
  for (let v = 0; v < 4; v++)
    i.push({ start: y[v], end: y[(v + 1) % 4], color: s });
  return i;
}
function Nc(r, e, n, s = !0, i = !0, o = !1) {
  return {
    body: kS(r),
    frustum: s ? TS(r, e, n) : [],
    compositionBounds: i ? MS(e, n) : [],
    poiLine: OS(r),
    focalPlane: o ? ES(r, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function PS(r, e, n) {
  const s = e / n, i = jl(r.focalLength, r.filmSize);
  let o;
  if (r.type === "two-node")
    o = r.pointOfInterest;
  else {
    const u = r.orientation.x * Math.PI / 180, h = r.orientation.y * Math.PI / 180, f = zt(
      Math.sin(h) * Math.cos(u),
      -Math.sin(u),
      Math.cos(h) * Math.cos(u)
    );
    o = Nt(r.position, Ht(f, 1e3));
  }
  const a = kn(r.position, o, zt(0, -1, 0)), l = ww(i, s, r.nearClip, r.farClip), c = td(l, a);
  return { view: a, projection: l, viewProjection: c };
}
function Wc(r, e, n, s) {
  const i = e / n;
  let o, a = 1e3;
  const l = e / 2, c = n / 2;
  switch (r) {
    case "front":
      o = kn(
        zt(l, c, -2e3),
        zt(l, c, 0),
        zt(0, -1, 0)
      );
      break;
    case "back":
      o = kn(
        zt(l, c, 2e3),
        zt(l, c, 0),
        zt(0, -1, 0)
      );
      break;
    case "left":
      o = kn(
        zt(-2e3, c, 0),
        zt(l, c, 0),
        zt(0, -1, 0)
      );
      break;
    case "right":
      o = kn(
        zt(l + 2e3, c, 0),
        zt(l, c, 0),
        zt(0, -1, 0)
      );
      break;
    case "top":
      o = kn(
        zt(l, -2e3, 0),
        zt(l, c, 0),
        zt(0, 0, 1)
      );
      break;
    case "bottom":
      o = kn(
        zt(l, c + 2e3, 0),
        zt(l, c, 0),
        zt(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (s) {
        const f = s.orbitPhi * Math.PI / 180, m = s.orbitTheta * Math.PI / 180, p = s.orbitDistance, y = zt(
          s.orbitCenter.x + p * Math.sin(f) * Math.sin(m),
          s.orbitCenter.y + p * Math.cos(f),
          s.orbitCenter.z + p * Math.sin(f) * Math.cos(m)
        );
        o = kn(
          y,
          s.orbitCenter,
          zt(0, -1, 0)
        ), a = 1e3 / s.orthoZoom;
      } else
        o = kn(
          zt(l, c, -2e3),
          zt(l, c, 0),
          zt(0, -1, 0)
        );
      break;
    default:
      o = kn(
        zt(l, c, -2e3),
        zt(l, c, 0),
        zt(0, -1, 0)
      );
  }
  const u = Sw(
    -a * i,
    a * i,
    -a,
    a,
    1,
    1e4
  ), h = td(u, o);
  return { view: o, projection: u, viewProjection: h };
}
function td(r, e) {
  const n = r.elements, s = e.elements, i = new Float32Array(16);
  for (let o = 0; o < 4; o++)
    for (let a = 0; a < 4; a++) {
      let l = 0;
      for (let c = 0; c < 4; c++)
        l += n[o + c * 4] * s[c + a * 4];
      i[o + a * 4] = l;
    }
  return { elements: i };
}
function Da(r, e, n, s) {
  const i = Cw(e, r), o = e.elements, a = r.x * o[3] + r.y * o[7] + r.z * o[11] + o[15];
  if (a <= 0)
    return { x: 0, y: 0, z: i.z, visible: !1 };
  const l = (i.x / a * 0.5 + 0.5) * n, c = (-i.y / a * 0.5 + 0.5) * s;
  return {
    x: l,
    y: c,
    z: i.z / a,
    visible: !0
  };
}
function DS(r, e = 100) {
  return [
    { start: r, end: Nt(r, zt(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: r, end: Nt(r, zt(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: r, end: Nt(r, zt(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function AS(r, e, n = 100) {
  const s = [], i = "#333333", o = "#444444", a = r / 2, l = e / 2, c = Math.max(r, e);
  for (let u = -c; u <= c + r; u += n) {
    const h = Math.abs(u - a) < n / 2;
    s.push({
      start: zt(u, -c, 0),
      end: zt(u, c + e, 0),
      color: h ? o : i
    });
  }
  for (let u = -c; u <= c + e; u += n) {
    const h = Math.abs(u - l) < n / 2;
    s.push({
      start: zt(-c, u, 0),
      end: zt(c + r, u, 0),
      color: h ? o : i
    });
  }
  return s;
}
const FS = ["onClick"], IS = { class: "view-header" }, LS = ["value", "onChange"], RS = { class: "view-tools" }, zS = ["onClick"], jS = ["onMousedown", "onWheel"], BS = { class: "view-info" }, VS = { class: "view-name" }, $S = {
  key: 0,
  class: "view-coords"
}, NS = { class: "layout-controls" }, WS = ["onClick", "title"], US = /* @__PURE__ */ ye({
  __name: "ViewportRenderer",
  props: {
    camera: {},
    compWidth: {},
    compHeight: {},
    viewportState: {},
    viewOptions: {},
    layers: { default: () => [] }
  },
  emits: ["update:viewportState", "selectLayer"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = ut([null, null, null, null]), o = ut([null, null, null, null]), a = ut(!1), l = ut({ x: 0, y: 0 }), c = ut(0), u = ut(0), h = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], f = St(() => n.viewportState.layout), m = St(() => n.viewportState.activeViewIndex), p = St(() => n.viewportState.customViews), y = St(() => {
      switch (n.viewportState.layout) {
        case "1-view":
          return [n.viewportState.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return n.viewportState.views.slice(0, 2);
        case "4-view":
          return n.viewportState.views.slice(0, 4);
        default:
          return [n.viewportState.views[0]];
      }
    });
    function v(I, tt) {
      i.value[tt] = I, I && (o.value[tt] = I.getContext("2d"));
    }
    function _(I) {
      return I.startsWith("custom-");
    }
    function g(I) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[I];
    }
    function C(I) {
      s("update:viewportState", {
        ...n.viewportState,
        activeViewIndex: I
      });
    }
    function x(I, tt) {
      const U = [...n.viewportState.views];
      U[I] = tt, s("update:viewportState", {
        ...n.viewportState,
        views: U
      });
    }
    function k(I) {
      let tt = [...n.viewportState.views];
      for (; tt.length < 4; )
        tt.push("front");
      s("update:viewportState", {
        ...n.viewportState,
        layout: I,
        views: tt,
        activeViewIndex: Math.min(n.viewportState.activeViewIndex, w(I) - 1)
      });
    }
    function w(I) {
      switch (I) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function T(I) {
      const tt = {
        orbitCenter: { x: n.compWidth / 2, y: n.compHeight / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      s("update:viewportState", {
        ...n.viewportState,
        customViews: {
          ...n.viewportState.customViews,
          [I]: tt
        }
      });
    }
    function P(I, tt) {
      a.value = !0, l.value = { x: I.clientX, y: I.clientY }, c.value = tt, u.value = I.button, document.addEventListener("mousemove", z), document.addEventListener("mouseup", j);
    }
    function z(I) {
      if (!a.value) return;
      const tt = I.clientX - l.value.x, U = I.clientY - l.value.y;
      l.value = { x: I.clientX, y: I.clientY };
      const W = y.value[c.value];
      if (_(W)) {
        const Z = p.value[W];
        if (u.value === 0) {
          const yt = Z.orbitTheta + tt * 0.5, Q = Math.max(1, Math.min(179, Z.orbitPhi + U * 0.5));
          s("update:viewportState", {
            ...n.viewportState,
            customViews: {
              ...n.viewportState.customViews,
              [W]: {
                ...Z,
                orbitTheta: yt,
                orbitPhi: Q
              }
            }
          });
        } else (u.value === 1 || u.value === 2) && s("update:viewportState", {
          ...n.viewportState,
          customViews: {
            ...n.viewportState.customViews,
            [W]: {
              ...Z,
              orthoOffset: {
                x: Z.orthoOffset.x + tt,
                y: Z.orthoOffset.y + U
              }
            }
          }
        });
      }
    }
    function j() {
      a.value = !1, document.removeEventListener("mousemove", z), document.removeEventListener("mouseup", j);
    }
    function ot(I, tt) {
      I.preventDefault();
      const U = y.value[tt];
      if (_(U)) {
        const W = p.value[U], Z = I.deltaY > 0 ? 1.1 : 0.9;
        s("update:viewportState", {
          ...n.viewportState,
          customViews: {
            ...n.viewportState.customViews,
            [U]: {
              ...W,
              orbitDistance: W.orbitDistance * Z
            }
          }
        });
      }
    }
    function vt() {
      y.value.forEach((I, tt) => {
        const U = i.value[tt], W = o.value[tt];
        if (!U || !W) return;
        const Z = U.getBoundingClientRect(), yt = window.devicePixelRatio || 1;
        U.width = Z.width * yt, U.height = Z.height * yt, W.scale(yt, yt), W.fillStyle = "#1a1a1a", W.fillRect(0, 0, Z.width, Z.height);
        let Q;
        I === "active-camera" && n.camera ? Q = PS(n.camera, n.compWidth, n.compHeight) : _(I) ? Q = Wc(I, n.compWidth, n.compHeight, p.value[I]) : Q = Wc(I, n.compWidth, n.compHeight);
        const at = [];
        if (n.viewOptions.showGrid && at.push(...AS(n.compWidth, n.compHeight)), n.viewOptions.show3DReferenceAxes && at.push(...DS(zt(n.compWidth / 2, n.compHeight / 2, 0))), n.viewOptions.showCompositionBounds) {
          const _t = Nc(
            n.camera ?? L(),
            n.compWidth,
            n.compHeight,
            !1,
            !0,
            !1
          );
          at.push(..._t.compositionBounds);
        }
        if (I !== "active-camera" && n.camera && (n.viewOptions.cameraWireframes === "always" || n.viewOptions.cameraWireframes === "selected")) {
          const ht = Nc(
            n.camera,
            n.compWidth,
            n.compHeight,
            !0,
            !1,
            n.viewOptions.showFocalPlane
          );
          at.push(...ht.body), at.push(...ht.frustum), at.push(...ht.focalPlane), ht.poiLine && at.push(ht.poiLine);
        }
        for (const _t of at) {
          const ht = Da(_t.start, Q.viewProjection, Z.width, Z.height), X = Da(_t.end, Q.viewProjection, Z.width, Z.height);
          !ht.visible && !X.visible || (W.beginPath(), W.strokeStyle = _t.color, W.lineWidth = 1, W.moveTo(ht.x, ht.y), W.lineTo(X.x, X.y), W.stroke());
        }
        if (n.viewOptions.showLayerHandles)
          for (const _t of n.layers) {
            const ht = Da(_t.position, Q.viewProjection, Z.width, Z.height);
            ht.visible && (W.beginPath(), W.fillStyle = _t.selected ? "#ffcc00" : "#888888", W.arc(ht.x, ht.y, _t.selected ? 6 : 4, 0, Math.PI * 2), W.fill(), W.fillStyle = "#ffffff", W.font = "10px sans-serif", W.fillText(_t.name, ht.x + 8, ht.y + 4));
          }
      });
    }
    function L() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: n.compWidth / 2, y: n.compHeight / 2, z: -1500 },
        pointOfInterest: { x: n.compWidth / 2, y: n.compHeight / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let Y;
    function M() {
      vt(), Y = requestAnimationFrame(M);
    }
    return Ne(() => {
      M();
    }), wn(() => {
      cancelAnimationFrame(Y);
    }), ae(() => [n.camera, n.viewportState, n.viewOptions, n.layers], () => {
    }, { deep: !0 }), (I, tt) => (H(), G("div", {
      class: wt(["viewport-renderer", [`layout-${f.value}`]])
    }, [
      (H(!0), G(Dt, null, jt(y.value, (U, W) => {
        var Z, yt;
        return H(), G("div", {
          key: W,
          class: wt(["view-panel", { active: W === m.value }]),
          onClick: (Q) => C(W)
        }, [
          d("div", IS, [
            d("select", {
              value: U,
              onChange: (Q) => x(W, Q.target.value),
              class: "view-select"
            }, [...tt[1] || (tt[1] = [
              bi('<option value="active-camera" data-v-570e989a>Active Camera</option><option value="custom-1" data-v-570e989a>Custom View 1</option><option value="custom-2" data-v-570e989a>Custom View 2</option><option value="custom-3" data-v-570e989a>Custom View 3</option><option value="front" data-v-570e989a>Front</option><option value="back" data-v-570e989a>Back</option><option value="left" data-v-570e989a>Left</option><option value="right" data-v-570e989a>Right</option><option value="top" data-v-570e989a>Top</option><option value="bottom" data-v-570e989a>Bottom</option>', 10)
            ])], 40, LS),
            d("div", RS, [
              _(U) ? (H(), G("button", {
                key: 0,
                onClick: Bt((Q) => T(U), ["stop"]),
                title: "Reset View"
              }, [...tt[2] || (tt[2] = [
                d("span", { class: "icon" }, "", -1)
              ])], 8, zS)) : xt("", !0)
            ])
          ]),
          d("canvas", {
            ref_for: !0,
            ref: (Q) => v(Q, W),
            class: "view-canvas",
            onMousedown: (Q) => P(Q, W),
            onWheel: (Q) => ot(Q, W),
            onContextmenu: tt[0] || (tt[0] = Bt(() => {
            }, ["prevent"]))
          }, null, 40, jS),
          d("div", BS, [
            d("span", VS, ct(g(U)), 1),
            _(U) ? (H(), G("span", $S, " : " + ct(Math.round(((Z = p.value[U]) == null ? void 0 : Z.orbitTheta) ?? 0)) + " : " + ct(Math.round(((yt = p.value[U]) == null ? void 0 : yt.orbitPhi) ?? 0)) + " ", 1)) : xt("", !0)
          ])
        ], 10, FS);
      }), 128)),
      d("div", NS, [
        (H(), G(Dt, null, jt(h, (U) => d("button", {
          key: U.value,
          class: wt({ active: f.value === U.value }),
          onClick: (W) => k(U.value),
          title: U.label
        }, ct(U.icon), 11, WS)), 64))
      ])
    ], 2));
  }
}), HS = /* @__PURE__ */ we(US, [["__scopeId", "data-v-570e989a"]]);
function nt(r, e, n) {
  return (e = function(s) {
    var i = function(o, a) {
      if (typeof o != "object" || !o) return o;
      var l = o[Symbol.toPrimitive];
      if (l !== void 0) {
        var c = l.call(o, a);
        if (typeof c != "object") return c;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (a === "string" ? String : Number)(o);
    }(s, "string");
    return typeof i == "symbol" ? i : i + "";
  }(e)) in r ? Object.defineProperty(r, e, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : r[e] = n, r;
}
function Uc(r, e) {
  var n = Object.keys(r);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(r);
    e && (s = s.filter(function(i) {
      return Object.getOwnPropertyDescriptor(r, i).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function st(r) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Uc(Object(n), !0).forEach(function(s) {
      nt(r, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(n)) : Uc(Object(n)).forEach(function(s) {
      Object.defineProperty(r, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return r;
}
function ue(r, e) {
  if (r == null) return {};
  var n, s, i = function(a, l) {
    if (a == null) return {};
    var c = {};
    for (var u in a) if ({}.hasOwnProperty.call(a, u)) {
      if (l.indexOf(u) >= 0) continue;
      c[u] = a[u];
    }
    return c;
  }(r, e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(r);
    for (s = 0; s < o.length; s++) n = o[s], e.indexOf(n) >= 0 || {}.propertyIsEnumerable.call(r, n) && (i[n] = r[n]);
  }
  return i;
}
function In(r, e) {
  return e || (e = r.slice(0)), Object.freeze(Object.defineProperties(r, { raw: { value: Object.freeze(e) } }));
}
class Hc {
  constructor() {
    nt(this, "browserShadowBlurConstant", 1), nt(this, "DPI", 96), nt(this, "devicePixelRatio", typeof window < "u" ? window.devicePixelRatio : 1), nt(this, "perfLimitSizeTotal", 2097152), nt(this, "maxCacheSideLimit", 4096), nt(this, "minCacheSideLimit", 256), nt(this, "disableStyleCopyPaste", !1), nt(this, "enableGLFiltering", !0), nt(this, "textureSize", 4096), nt(this, "forceGLPutImageData", !1), nt(this, "cachesBoundsOfCurve", !1), nt(this, "fontPaths", {}), nt(this, "NUM_FRACTION_DIGITS", 4);
  }
}
const Gt = new class extends Hc {
  constructor(r) {
    super(), this.configure(r);
  }
  configure() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.assign(this, r);
  }
  addFonts() {
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.fontPaths = st(st({}, this.fontPaths), r);
  }
  removeFonts() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((r) => {
      delete this.fontPaths[r];
    });
  }
  clearFonts() {
    this.fontPaths = {};
  }
  restoreDefaults(r) {
    const e = new Hc(), n = (r == null ? void 0 : r.reduce((s, i) => (s[i] = e[i], s), {})) || e;
    this.configure(n);
  }
}(), Ss = function(r) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) n[s - 1] = arguments[s];
  return console[r]("fabric", ...n);
};
class Pn extends Error {
  constructor(e, n) {
    super("fabric: ".concat(e), n);
  }
}
class XS extends Pn {
  constructor(e) {
    super("".concat(e, " 'options.signal' is in 'aborted' state"));
  }
}
class GS {
}
class YS extends GS {
  testPrecision(e, n) {
    const s = "precision ".concat(n, ` float;
void main(){}`), i = e.createShader(e.FRAGMENT_SHADER);
    return !!i && (e.shaderSource(i, s), e.compileShader(i), !!e.getShaderParameter(i, e.COMPILE_STATUS));
  }
  queryWebGL(e) {
    const n = e.getContext("webgl");
    n && (this.maxTextureSize = n.getParameter(n.MAX_TEXTURE_SIZE), this.GLPrecision = ["highp", "mediump", "lowp"].find((s) => this.testPrecision(n, s)), n.getExtension("WEBGL_lose_context").loseContext(), Ss("log", "WebGL: max texture size ".concat(this.maxTextureSize)));
  }
  isSupported(e) {
    return !!this.maxTextureSize && this.maxTextureSize >= e;
  }
}
const KS = {};
let Xc;
const Fn = () => Xc || (Xc = { document, window, isTouchSupported: "ontouchstart" in window || "ontouchstart" in document || window && window.navigator && window.navigator.maxTouchPoints > 0, WebGLProbe: new YS(), dispose() {
}, copyPasteData: KS }), Ci = () => Fn().document, ia = () => Fn().window, ed = () => {
  var r;
  return Math.max((r = Gt.devicePixelRatio) !== null && r !== void 0 ? r : ia().devicePixelRatio, 1);
}, Ji = new class {
  constructor() {
    nt(this, "boundsOfCurveCache", {}), this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  getFontCache(r) {
    let { fontFamily: e, fontStyle: n, fontWeight: s } = r;
    e = e.toLowerCase();
    const i = this.charWidthsCache;
    i.has(e) || i.set(e, /* @__PURE__ */ new Map());
    const o = i.get(e), a = "".concat(n.toLowerCase(), "_").concat((s + "").toLowerCase());
    return o.has(a) || o.set(a, /* @__PURE__ */ new Map()), o.get(a);
  }
  clearFontCache(r) {
    r ? this.charWidthsCache.delete((r || "").toLowerCase()) : this.charWidthsCache = /* @__PURE__ */ new Map();
  }
  limitDimsByArea(r) {
    const { perfLimitSizeTotal: e } = Gt, n = Math.sqrt(e * r);
    return [Math.floor(n), Math.floor(e / n)];
  }
}(), al = "6.9.0";
function fo() {
}
const _r = Math.PI / 2, Eo = 2 * Math.PI, Bl = Math.PI / 180, $e = Object.freeze([1, 0, 0, 1, 0, 0]), Vl = 16, us = 0.4477152502, Ut = "center", Jt = "left", Xe = "top", ll = "bottom", be = "right", Ge = "none", $l = /\r?\n/, nd = "moving", ra = "scaling", sd = "rotating", Nl = "rotate", id = "skewing", ur = "resizing", qS = "modifyPoly", ZS = "modifyPath", Po = "changed", oa = "scale", Ke = "scaleX", an = "scaleY", ki = "skewX", Ti = "skewY", Te = "fill", Ye = "stroke", Do = "modified", Js = "json", Aa = "svg", Et = new class {
  constructor() {
    this[Js] = /* @__PURE__ */ new Map(), this[Aa] = /* @__PURE__ */ new Map();
  }
  has(r) {
    return this[Js].has(r);
  }
  getClass(r) {
    const e = this[Js].get(r);
    if (!e) throw new Pn("No class registered for ".concat(r));
    return e;
  }
  setClass(r, e) {
    e ? this[Js].set(e, r) : (this[Js].set(r.type, r), this[Js].set(r.type.toLowerCase(), r));
  }
  getSVGClass(r) {
    return this[Aa].get(r);
  }
  setSVGClass(r, e) {
    this[Aa].set(e ?? r.type.toLowerCase(), r);
  }
}(), Ao = new class extends Array {
  remove(r) {
    const e = this.indexOf(r);
    e > -1 && this.splice(e, 1);
  }
  cancelAll() {
    const r = this.splice(0);
    return r.forEach((e) => e.abort()), r;
  }
  cancelByCanvas(r) {
    if (!r) return [];
    const e = this.filter((n) => {
      var s;
      return n.target === r || typeof n.target == "object" && ((s = n.target) === null || s === void 0 ? void 0 : s.canvas) === r;
    });
    return e.forEach((n) => n.abort()), e;
  }
  cancelByTarget(r) {
    if (!r) return [];
    const e = this.filter((n) => n.target === r);
    return e.forEach((n) => n.abort()), e;
  }
}();
class JS {
  constructor() {
    nt(this, "__eventListeners", {});
  }
  on(e, n) {
    if (this.__eventListeners || (this.__eventListeners = {}), typeof e == "object") return Object.entries(e).forEach((s) => {
      let [i, o] = s;
      this.on(i, o);
    }), () => this.off(e);
    if (n) {
      const s = e;
      return this.__eventListeners[s] || (this.__eventListeners[s] = []), this.__eventListeners[s].push(n), () => this.off(s, n);
    }
    return () => !1;
  }
  once(e, n) {
    if (typeof e == "object") {
      const s = [];
      return Object.entries(e).forEach((i) => {
        let [o, a] = i;
        s.push(this.once(o, a));
      }), () => s.forEach((i) => i());
    }
    if (n) {
      const s = this.on(e, function() {
        for (var i = arguments.length, o = new Array(i), a = 0; a < i; a++) o[a] = arguments[a];
        n.call(this, ...o), s();
      });
      return s;
    }
    return () => !1;
  }
  _removeEventListener(e, n) {
    if (this.__eventListeners[e]) if (n) {
      const s = this.__eventListeners[e], i = s.indexOf(n);
      i > -1 && s.splice(i, 1);
    } else this.__eventListeners[e] = [];
  }
  off(e, n) {
    if (this.__eventListeners) if (e === void 0) for (const s in this.__eventListeners) this._removeEventListener(s);
    else typeof e == "object" ? Object.entries(e).forEach((s) => {
      let [i, o] = s;
      this._removeEventListener(i, o);
    }) : this._removeEventListener(e, n);
  }
  fire(e, n) {
    var s;
    if (!this.__eventListeners) return;
    const i = (s = this.__eventListeners[e]) === null || s === void 0 ? void 0 : s.concat();
    if (i) for (let o = 0; o < i.length; o++) i[o].call(this, n || {});
  }
}
const si = (r, e) => {
  const n = r.indexOf(e);
  return n !== -1 && r.splice(n, 1), r;
}, ss = (r) => {
  if (r === 0) return 1;
  switch (Math.abs(r) / _r) {
    case 1:
    case 3:
      return 0;
    case 2:
      return -1;
  }
  return Math.cos(r);
}, is = (r) => {
  if (r === 0) return 0;
  const e = r / _r, n = Math.sign(r);
  switch (e) {
    case 1:
      return n;
    case 2:
      return 0;
    case 3:
      return -n;
  }
  return Math.sin(r);
};
class mt {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    typeof e == "object" ? (this.x = e.x, this.y = e.y) : (this.x = e, this.y = n);
  }
  add(e) {
    return new mt(this.x + e.x, this.y + e.y);
  }
  addEquals(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  scalarAdd(e) {
    return new mt(this.x + e, this.y + e);
  }
  scalarAddEquals(e) {
    return this.x += e, this.y += e, this;
  }
  subtract(e) {
    return new mt(this.x - e.x, this.y - e.y);
  }
  subtractEquals(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  scalarSubtract(e) {
    return new mt(this.x - e, this.y - e);
  }
  scalarSubtractEquals(e) {
    return this.x -= e, this.y -= e, this;
  }
  multiply(e) {
    return new mt(this.x * e.x, this.y * e.y);
  }
  scalarMultiply(e) {
    return new mt(this.x * e, this.y * e);
  }
  scalarMultiplyEquals(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return new mt(this.x / e.x, this.y / e.y);
  }
  scalarDivide(e) {
    return new mt(this.x / e, this.y / e);
  }
  scalarDivideEquals(e) {
    return this.x /= e, this.y /= e, this;
  }
  eq(e) {
    return this.x === e.x && this.y === e.y;
  }
  lt(e) {
    return this.x < e.x && this.y < e.y;
  }
  lte(e) {
    return this.x <= e.x && this.y <= e.y;
  }
  gt(e) {
    return this.x > e.x && this.y > e.y;
  }
  gte(e) {
    return this.x >= e.x && this.y >= e.y;
  }
  lerp(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
    return n = Math.max(Math.min(1, n), 0), new mt(this.x + (e.x - this.x) * n, this.y + (e.y - this.y) * n);
  }
  distanceFrom(e) {
    const n = this.x - e.x, s = this.y - e.y;
    return Math.sqrt(n * n + s * s);
  }
  midPointFrom(e) {
    return this.lerp(e);
  }
  min(e) {
    return new mt(Math.min(this.x, e.x), Math.min(this.y, e.y));
  }
  max(e) {
    return new mt(Math.max(this.x, e.x), Math.max(this.y, e.y));
  }
  toString() {
    return "".concat(this.x, ",").concat(this.y);
  }
  setXY(e, n) {
    return this.x = e, this.y = n, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setFromPoint(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  swap(e) {
    const n = this.x, s = this.y;
    this.x = e.x, this.y = e.y, e.x = n, e.y = s;
  }
  clone() {
    return new mt(this.x, this.y);
  }
  rotate(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Wl;
    const s = is(e), i = ss(e), o = this.subtract(n);
    return new mt(o.x * i - o.y * s, o.x * s + o.y * i).add(n);
  }
  transform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    return new mt(e[0] * this.x + e[2] * this.y + (n ? 0 : e[4]), e[1] * this.x + e[3] * this.y + (n ? 0 : e[5]));
  }
}
const Wl = new mt(0, 0), po = (r) => !!r && Array.isArray(r._objects);
function rd(r) {
  class e extends r {
    constructor() {
      super(...arguments), nt(this, "_objects", []);
    }
    _onObjectAdded(s) {
    }
    _onObjectRemoved(s) {
    }
    _onStackOrderChanged(s) {
    }
    add() {
      for (var s = arguments.length, i = new Array(s), o = 0; o < s; o++) i[o] = arguments[o];
      const a = this._objects.push(...i);
      return i.forEach((l) => this._onObjectAdded(l)), a;
    }
    insertAt(s) {
      for (var i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++) o[a - 1] = arguments[a];
      return this._objects.splice(s, 0, ...o), o.forEach((l) => this._onObjectAdded(l)), this._objects.length;
    }
    remove() {
      const s = this._objects, i = [];
      for (var o = arguments.length, a = new Array(o), l = 0; l < o; l++) a[l] = arguments[l];
      return a.forEach((c) => {
        const u = s.indexOf(c);
        u !== -1 && (s.splice(u, 1), i.push(c), this._onObjectRemoved(c));
      }), i;
    }
    forEachObject(s) {
      this.getObjects().forEach((i, o, a) => s(i, o, a));
    }
    getObjects() {
      for (var s = arguments.length, i = new Array(s), o = 0; o < s; o++) i[o] = arguments[o];
      return i.length === 0 ? [...this._objects] : this._objects.filter((a) => a.isType(...i));
    }
    item(s) {
      return this._objects[s];
    }
    isEmpty() {
      return this._objects.length === 0;
    }
    size() {
      return this._objects.length;
    }
    contains(s, i) {
      return !!this._objects.includes(s) || !!i && this._objects.some((o) => o instanceof e && o.contains(s, !0));
    }
    complexity() {
      return this._objects.reduce((s, i) => s += i.complexity ? i.complexity() : 0, 0);
    }
    sendObjectToBack(s) {
      return !(!s || s === this._objects[0]) && (si(this._objects, s), this._objects.unshift(s), this._onStackOrderChanged(s), !0);
    }
    bringObjectToFront(s) {
      return !(!s || s === this._objects[this._objects.length - 1]) && (si(this._objects, s), this._objects.push(s), this._onStackOrderChanged(s), !0);
    }
    sendObjectBackwards(s, i) {
      if (!s) return !1;
      const o = this._objects.indexOf(s);
      if (o !== 0) {
        const a = this.findNewLowerIndex(s, o, i);
        return si(this._objects, s), this._objects.splice(a, 0, s), this._onStackOrderChanged(s), !0;
      }
      return !1;
    }
    bringObjectForward(s, i) {
      if (!s) return !1;
      const o = this._objects.indexOf(s);
      if (o !== this._objects.length - 1) {
        const a = this.findNewUpperIndex(s, o, i);
        return si(this._objects, s), this._objects.splice(a, 0, s), this._onStackOrderChanged(s), !0;
      }
      return !1;
    }
    moveObjectTo(s, i) {
      return s !== this._objects[i] && (si(this._objects, s), this._objects.splice(i, 0, s), this._onStackOrderChanged(s), !0);
    }
    findNewLowerIndex(s, i, o) {
      let a;
      if (o) {
        a = i;
        for (let l = i - 1; l >= 0; --l) if (s.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = i - 1;
      return a;
    }
    findNewUpperIndex(s, i, o) {
      let a;
      if (o) {
        a = i;
        for (let l = i + 1; l < this._objects.length; ++l) if (s.isOverlapping(this._objects[l])) {
          a = l;
          break;
        }
      } else a = i + 1;
      return a;
    }
    collectObjects(s) {
      let { left: i, top: o, width: a, height: l } = s, { includeIntersecting: c = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const u = [], h = new mt(i, o), f = h.add(new mt(a, l));
      for (let m = this._objects.length - 1; m >= 0; m--) {
        const p = this._objects[m];
        p.selectable && p.visible && (c && p.intersectsWithRect(h, f) || p.isContainedWithinRect(h, f) || c && p.containsPoint(h) || c && p.containsPoint(f)) && u.push(p);
      }
      return u;
    }
  }
  return e;
}
class od extends JS {
  _setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    for (const n in e) this.set(n, e[n]);
  }
  _setObject(e) {
    for (const n in e) this._set(n, e[n]);
  }
  set(e, n) {
    return typeof e == "object" ? this._setObject(e) : this._set(e, n), this;
  }
  _set(e, n) {
    this[e] = n;
  }
  toggle(e) {
    const n = this.get(e);
    return typeof n == "boolean" && this.set(e, !n), this;
  }
  get(e) {
    return this[e];
  }
}
function mo(r) {
  return ia().requestAnimationFrame(r);
}
function QS(r) {
  return ia().cancelAnimationFrame(r);
}
let tC = 0;
const Cs = () => tC++, rs = () => {
  const r = Ci().createElement("canvas");
  if (!r || r.getContext === void 0) throw new Pn("Failed to create `canvas` element");
  return r;
}, eC = () => Ci().createElement("img"), ln = (r) => {
  const e = rs();
  return e.width = r.width, e.height = r.height, e;
}, ad = (r, e, n) => r.toDataURL("image/".concat(e), n), ld = (r, e, n) => new Promise((s, i) => {
  r.toBlob(s, "image/".concat(e), n);
}), _e = (r) => r * Bl, os = (r) => r / Bl, nC = (r) => r.every((e, n) => e === $e[n]), Ue = (r, e, n) => new mt(r).transform(e, n), gn = (r) => {
  const e = 1 / (r[0] * r[3] - r[1] * r[2]), n = [e * r[3], -e * r[1], -e * r[2], e * r[0], 0, 0], { x: s, y: i } = new mt(r[4], r[5]).transform(n, !0);
  return n[4] = -s, n[5] = -i, n;
}, Pe = (r, e, n) => [r[0] * e[0] + r[2] * e[1], r[1] * e[0] + r[3] * e[1], r[0] * e[2] + r[2] * e[3], r[1] * e[2] + r[3] * e[3], n ? 0 : r[0] * e[4] + r[2] * e[5] + r[4], n ? 0 : r[1] * e[4] + r[3] * e[5] + r[5]], Ul = (r, e) => r.reduceRight((n, s) => s && n ? Pe(s, n, e) : s || n, void 0) || $e.concat(), cd = (r) => {
  let [e, n] = r;
  return Math.atan2(n, e);
}, Fo = (r) => {
  const e = cd(r), n = Math.pow(r[0], 2) + Math.pow(r[1], 2), s = Math.sqrt(n), i = (r[0] * r[3] - r[2] * r[1]) / s, o = Math.atan2(r[0] * r[2] + r[1] * r[3], n);
  return { angle: os(e), scaleX: s, scaleY: i, skewX: os(o), skewY: 0, translateX: r[4] || 0, translateY: r[5] || 0 };
}, xr = function(r) {
  return [1, 0, 0, 1, r, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0];
};
function Mi() {
  let { angle: r = 0 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { x: e = 0, y: n = 0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const s = _e(r), i = ss(s), o = is(s);
  return [i, o, -o, i, e ? e - (i * e - o * n) : 0, n ? n - (o * e + i * n) : 0];
}
const Hl = function(r) {
  return [r, 0, 0, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : r, 0, 0];
}, ud = (r) => Math.tan(_e(r)), hd = (r) => [1, 0, ud(r), 1, 0, 0], dd = (r) => [1, ud(r), 0, 1, 0, 0], aa = (r) => {
  let { scaleX: e = 1, scaleY: n = 1, flipX: s = !1, flipY: i = !1, skewX: o = 0, skewY: a = 0 } = r, l = Hl(s ? -e : e, i ? -n : n);
  return o && (l = Pe(l, hd(o), !0)), a && (l = Pe(l, dd(a), !0)), l;
}, sC = (r) => {
  const { translateX: e = 0, translateY: n = 0, angle: s = 0 } = r;
  let i = xr(e, n);
  s && (i = Pe(i, Mi({ angle: s })));
  const o = aa(r);
  return nC(o) || (i = Pe(i, o)), i;
}, go = function(r) {
  let { signal: e, crossOrigin: n = null } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise(function(s, i) {
    if (e && e.aborted) return i(new XS("loadImage"));
    const o = eC();
    let a;
    e && (a = function(c) {
      o.src = "", i(c);
    }, e.addEventListener("abort", a, { once: !0 }));
    const l = function() {
      o.onload = o.onerror = null, a && (e == null || e.removeEventListener("abort", a)), s(o);
    };
    r ? (o.onload = l, o.onerror = function() {
      a && (e == null || e.removeEventListener("abort", a)), i(new Pn("Error loading ".concat(o.src)));
    }, n && (o.crossOrigin = n), o.src = r) : l();
  });
}, hr = function(r) {
  let { signal: e, reviver: n = fo } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((s, i) => {
    const o = [];
    e && e.addEventListener("abort", i, { once: !0 }), Promise.all(r.map((a) => Et.getClass(a.type).fromObject(a, { signal: e }).then((l) => (n(a, l), o.push(l), l)))).then(s).catch((a) => {
      o.forEach((l) => {
        l.dispose && l.dispose();
      }), i(a);
    }).finally(() => {
      e && e.removeEventListener("abort", i);
    });
  });
}, la = function(r) {
  let { signal: e } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Promise((n, s) => {
    const i = [];
    e && e.addEventListener("abort", s, { once: !0 });
    const o = Object.values(r).map((l) => l && l.type && Et.has(l.type) ? hr([l], { signal: e }).then((c) => {
      let [u] = c;
      return i.push(u), u;
    }) : l), a = Object.keys(r);
    Promise.all(o).then((l) => l.reduce((c, u, h) => (c[a[h]] = u, c), {})).then(n).catch((l) => {
      i.forEach((c) => {
        c.dispose && c.dispose();
      }), s(l);
    }).finally(() => {
      e && e.removeEventListener("abort", s);
    });
  });
}, Oi = function(r) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []).reduce((e, n) => (n in r && (e[n] = r[n]), e), {});
}, Xl = (r, e) => Object.keys(r).reduce((n, s) => (e(r[s], s, r) && (n[s] = r[s]), n), {}), le = (r, e) => parseFloat(Number(r).toFixed(e)), dr = (r) => "matrix(" + r.map((e) => le(e, Gt.NUM_FRACTION_DIGITS)).join(" ") + ")", rn = (r) => !!r && r.toLive !== void 0, Gc = (r) => !!r && typeof r.toObject == "function", Yc = (r) => !!r && r.offsetX !== void 0 && "source" in r, Rs = (r) => !!r && "multiSelectionStacking" in r;
function fd(r) {
  const e = r && mn(r);
  let n = 0, s = 0;
  if (!r || !e) return { left: n, top: s };
  let i = r;
  const o = e.documentElement, a = e.body || { scrollLeft: 0, scrollTop: 0 };
  for (; i && (i.parentNode || i.host) && (i = i.parentNode || i.host, i === e ? (n = a.scrollLeft || o.scrollLeft || 0, s = a.scrollTop || o.scrollTop || 0) : (n += i.scrollLeft || 0, s += i.scrollTop || 0), i.nodeType !== 1 || i.style.position !== "fixed"); ) ;
  return { left: n, top: s };
}
const mn = (r) => r.ownerDocument || null, pd = (r) => {
  var e;
  return ((e = r.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView) || null;
}, md = function(r, e, n) {
  let { width: s, height: i } = n, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  r.width = s, r.height = i, o > 1 && (r.setAttribute("width", (s * o).toString()), r.setAttribute("height", (i * o).toString()), e.scale(o, o));
}, cl = (r, e) => {
  let { width: n, height: s } = e;
  n && (r.style.width = typeof n == "number" ? "".concat(n, "px") : n), s && (r.style.height = typeof s == "number" ? "".concat(s, "px") : s);
};
function Kc(r) {
  return r.onselectstart !== void 0 && (r.onselectstart = () => !1), r.style.userSelect = Ge, r;
}
class gd {
  constructor(e) {
    nt(this, "_originalCanvasStyle", void 0), nt(this, "lower", void 0);
    const n = this.createLowerCanvas(e);
    this.lower = { el: n, ctx: n.getContext("2d") };
  }
  createLowerCanvas(e) {
    const n = (s = e) && s.getContext !== void 0 ? e : e && Ci().getElementById(e) || rs();
    var s;
    if (n.hasAttribute("data-fabric")) throw new Pn("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");
    return this._originalCanvasStyle = n.style.cssText, n.setAttribute("data-fabric", "main"), n.classList.add("lower-canvas"), n;
  }
  cleanupDOM(e) {
    let { width: n, height: s } = e;
    const { el: i } = this.lower;
    i.classList.remove("lower-canvas"), i.removeAttribute("data-fabric"), i.setAttribute("width", "".concat(n)), i.setAttribute("height", "".concat(s)), i.style.cssText = this._originalCanvasStyle || "", this._originalCanvasStyle = void 0;
  }
  setDimensions(e, n) {
    const { el: s, ctx: i } = this.lower;
    md(s, i, e, n);
  }
  setCSSDimensions(e) {
    cl(this.lower.el, e);
  }
  calcOffset() {
    return function(e) {
      var n;
      const s = e && mn(e), i = { left: 0, top: 0 };
      if (!s) return i;
      const o = ((n = pd(e)) === null || n === void 0 ? void 0 : n.getComputedStyle(e, null)) || {};
      i.left += parseInt(o.borderLeftWidth, 10) || 0, i.top += parseInt(o.borderTopWidth, 10) || 0, i.left += parseInt(o.paddingLeft, 10) || 0, i.top += parseInt(o.paddingTop, 10) || 0;
      let a = { left: 0, top: 0 };
      const l = s.documentElement;
      e.getBoundingClientRect !== void 0 && (a = e.getBoundingClientRect());
      const c = fd(e);
      return { left: a.left + c.left - (l.clientLeft || 0) + i.left, top: a.top + c.top - (l.clientTop || 0) + i.top };
    }(this.lower.el);
  }
  dispose() {
    Fn().dispose(this.lower.el), delete this.lower;
  }
}
const iC = { backgroundVpt: !0, backgroundColor: "", overlayVpt: !0, overlayColor: "", includeDefaultValues: !0, svgViewportTransformation: !0, renderOnAddRemove: !0, skipOffscreen: !0, enableRetinaScaling: !0, imageSmoothingEnabled: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, viewportTransform: [...$e] }, rC = ["objects"];
class wr extends rd(od) {
  get lowerCanvasEl() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.el;
  }
  get contextContainer() {
    var e;
    return (e = this.elements.lower) === null || e === void 0 ? void 0 : e.ctx;
  }
  static getDefaults() {
    return wr.ownDefaults;
  }
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, this.constructor.getDefaults()), this.set(n), this.initElements(e), this._setDimensionsImpl({ width: this.width || this.elements.lower.el.width || 0, height: this.height || this.elements.lower.el.height || 0 }), this.skipControlsDrawing = !1, this.viewportTransform = [...this.viewportTransform], this.calcViewportBoundaries();
  }
  initElements(e) {
    this.elements = new gd(e);
  }
  add() {
    const e = super.add(...arguments);
    return arguments.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  insertAt(e) {
    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) s[i - 1] = arguments[i];
    const o = super.insertAt(e, ...s);
    return s.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), o;
  }
  remove() {
    const e = super.remove(...arguments);
    return e.length > 0 && this.renderOnAddRemove && this.requestRenderAll(), e;
  }
  _onObjectAdded(e) {
    e.canvas && e.canvas !== this && (Ss("warn", `Canvas is trying to add an object that belongs to a different canvas.
Resulting to default behavior: removing object from previous canvas and adding to new canvas`), e.canvas.remove(e)), e._set("canvas", this), e.setCoords(), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e) {
    e._set("canvas", void 0), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onStackOrderChanged() {
    this.renderOnAddRemove && this.requestRenderAll();
  }
  getRetinaScaling() {
    return this.enableRetinaScaling ? ed() : 1;
  }
  calcOffset() {
    return this._offset = this.elements.calcOffset();
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  setWidth(e, n) {
    return this.setDimensions({ width: e }, n);
  }
  setHeight(e, n) {
    return this.setDimensions({ height: e }, n);
  }
  _setDimensionsImpl(e) {
    let { cssOnly: n = !1, backstoreOnly: s = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!n) {
      const i = st({ width: this.width, height: this.height }, e);
      this.elements.setDimensions(i, this.getRetinaScaling()), this.hasLostContext = !0, this.width = i.width, this.height = i.height;
    }
    s || this.elements.setCSSDimensions(e), this.calcOffset();
  }
  setDimensions(e, n) {
    this._setDimensionsImpl(e, n), n && n.cssOnly || this.requestRenderAll();
  }
  getZoom() {
    return this.viewportTransform[0];
  }
  setViewportTransform(e) {
    this.viewportTransform = e, this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll();
  }
  zoomToPoint(e, n) {
    const s = e, i = [...this.viewportTransform], o = Ue(e, gn(i));
    i[0] = n, i[3] = n;
    const a = Ue(o, i);
    i[4] += s.x - a.x, i[5] += s.y - a.y, this.setViewportTransform(i);
  }
  setZoom(e) {
    this.zoomToPoint(new mt(0, 0), e);
  }
  absolutePan(e) {
    const n = [...this.viewportTransform];
    return n[4] = -e.x, n[5] = -e.y, this.setViewportTransform(n);
  }
  relativePan(e) {
    return this.absolutePan(new mt(-e.x - this.viewportTransform[4], -e.y - this.viewportTransform[5]));
  }
  getElement() {
    return this.elements.lower.el;
  }
  clearContext(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  getContext() {
    return this.elements.lower.ctx;
  }
  clear() {
    this.remove(...this.getObjects()), this.backgroundImage = void 0, this.overlayImage = void 0, this.backgroundColor = "", this.overlayColor = "", this.clearContext(this.getContext()), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll();
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || this.renderCanvas(this.getContext(), this._objects);
  }
  renderAndReset() {
    this.nextRenderHandle = 0, this.renderAll();
  }
  requestRenderAll() {
    this.nextRenderHandle || this.disposed || this.destroyed || (this.nextRenderHandle = mo(() => this.renderAndReset()));
  }
  calcViewportBoundaries() {
    const e = this.width, n = this.height, s = gn(this.viewportTransform), i = Ue({ x: 0, y: 0 }, s), o = Ue({ x: e, y: n }, s), a = i.min(o), l = i.max(o);
    return this.vptCoords = { tl: a, tr: new mt(l.x, a.y), bl: new mt(a.x, l.y), br: l };
  }
  cancelRequestedRender() {
    this.nextRenderHandle && (QS(this.nextRenderHandle), this.nextRenderHandle = 0);
  }
  drawControls(e) {
  }
  renderCanvas(e, n) {
    if (this.destroyed) return;
    const s = this.viewportTransform, i = this.clipPath;
    this.calcViewportBoundaries(), this.clearContext(e), e.imageSmoothingEnabled = this.imageSmoothingEnabled, e.patternQuality = "best", this.fire("before:render", { ctx: e }), this._renderBackground(e), e.save(), e.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this._renderObjects(e, n), e.restore(), this.controlsAboveOverlay || this.skipControlsDrawing || this.drawControls(e), i && (i._set("canvas", this), i.shouldCache(), i._transformDone = !0, i.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(e, i)), this._renderOverlay(e), this.controlsAboveOverlay && !this.skipControlsDrawing && this.drawControls(e), this.fire("after:render", { ctx: e }), this.__cleanupTask && (this.__cleanupTask(), this.__cleanupTask = void 0);
  }
  drawClipPathOnCanvas(e, n) {
    const s = this.viewportTransform;
    e.save(), e.transform(...s), e.globalCompositeOperation = "destination-in", n.transform(e), e.scale(1 / n.zoomX, 1 / n.zoomY), e.drawImage(n._cacheCanvas, -n.cacheTranslationX, -n.cacheTranslationY), e.restore();
  }
  _renderObjects(e, n) {
    for (let s = 0, i = n.length; s < i; ++s) n[s] && n[s].render(e);
  }
  _renderBackgroundOrOverlay(e, n) {
    const s = this["".concat(n, "Color")], i = this["".concat(n, "Image")], o = this.viewportTransform, a = this["".concat(n, "Vpt")];
    if (!s && !i) return;
    const l = rn(s);
    if (s) {
      if (e.save(), e.beginPath(), e.moveTo(0, 0), e.lineTo(this.width, 0), e.lineTo(this.width, this.height), e.lineTo(0, this.height), e.closePath(), e.fillStyle = l ? s.toLive(e) : s, a && e.transform(...o), l) {
        e.transform(1, 0, 0, 1, s.offsetX || 0, s.offsetY || 0);
        const c = s.gradientTransform || s.patternTransform;
        c && e.transform(...c);
      }
      e.fill(), e.restore();
    }
    if (i) {
      e.save();
      const { skipOffscreen: c } = this;
      this.skipOffscreen = a, a && e.transform(...o), i.render(e), this.skipOffscreen = c, e.restore();
    }
  }
  _renderBackground(e) {
    this._renderBackgroundOrOverlay(e, "background");
  }
  _renderOverlay(e) {
    this._renderBackgroundOrOverlay(e, "overlay");
  }
  getCenter() {
    return { top: this.height / 2, left: this.width / 2 };
  }
  getCenterPoint() {
    return new mt(this.width / 2, this.height / 2);
  }
  centerObjectH(e) {
    return this._centerObject(e, new mt(this.getCenterPoint().x, e.getCenterPoint().y));
  }
  centerObjectV(e) {
    return this._centerObject(e, new mt(e.getCenterPoint().x, this.getCenterPoint().y));
  }
  centerObject(e) {
    return this._centerObject(e, this.getCenterPoint());
  }
  viewportCenterObject(e) {
    return this._centerObject(e, this.getVpCenter());
  }
  viewportCenterObjectH(e) {
    return this._centerObject(e, new mt(this.getVpCenter().x, e.getCenterPoint().y));
  }
  viewportCenterObjectV(e) {
    return this._centerObject(e, new mt(e.getCenterPoint().x, this.getVpCenter().y));
  }
  getVpCenter() {
    return Ue(this.getCenterPoint(), gn(this.viewportTransform));
  }
  _centerObject(e, n) {
    e.setXY(n, Ut, Ut), e.setCoords(), this.renderOnAddRemove && this.requestRenderAll();
  }
  toDatalessJSON(e) {
    return this.toDatalessObject(e);
  }
  toObject(e) {
    return this._toObjectMethod("toObject", e);
  }
  toJSON() {
    return this.toObject();
  }
  toDatalessObject(e) {
    return this._toObjectMethod("toDatalessObject", e);
  }
  _toObjectMethod(e, n) {
    const s = this.clipPath, i = s && !s.excludeFromExport ? this._toObject(s, e, n) : null;
    return st(st(st({ version: al }, Oi(this, n)), {}, { objects: this._objects.filter((o) => !o.excludeFromExport).map((o) => this._toObject(o, e, n)) }, this.__serializeBgOverlay(e, n)), i ? { clipPath: i } : null);
  }
  _toObject(e, n, s) {
    let i;
    this.includeDefaultValues || (i = e.includeDefaultValues, e.includeDefaultValues = !1);
    const o = e[n](s);
    return this.includeDefaultValues || (e.includeDefaultValues = !!i), o;
  }
  __serializeBgOverlay(e, n) {
    const s = {}, i = this.backgroundImage, o = this.overlayImage, a = this.backgroundColor, l = this.overlayColor;
    return rn(a) ? a.excludeFromExport || (s.background = a.toObject(n)) : a && (s.background = a), rn(l) ? l.excludeFromExport || (s.overlay = l.toObject(n)) : l && (s.overlay = l), i && !i.excludeFromExport && (s.backgroundImage = this._toObject(i, e, n)), o && !o.excludeFromExport && (s.overlayImage = this._toObject(o, e, n)), s;
  }
  toSVG() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    e.reviver = n;
    const s = [];
    return this._setSVGPreamble(s, e), this._setSVGHeader(s, e), this.clipPath && s.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId, `)" >
`)), this._setSVGBgOverlayColor(s, "background"), this._setSVGBgOverlayImage(s, "backgroundImage", n), this._setSVGObjects(s, n), this.clipPath && s.push(`</g>
`), this._setSVGBgOverlayColor(s, "overlay"), this._setSVGBgOverlayImage(s, "overlayImage", n), s.push("</svg>"), s.join("");
  }
  _setSVGPreamble(e, n) {
    n.suppressPreamble || e.push('<?xml version="1.0" encoding="', n.encoding || "UTF-8", `" standalone="no" ?>
`, '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', `"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
`);
  }
  _setSVGHeader(e, n) {
    const s = n.width || "".concat(this.width), i = n.height || "".concat(this.height), o = Gt.NUM_FRACTION_DIGITS, a = n.viewBox;
    let l;
    if (a) l = 'viewBox="'.concat(a.x, " ").concat(a.y, " ").concat(a.width, " ").concat(a.height, '" ');
    else if (this.svgViewportTransformation) {
      const c = this.viewportTransform;
      l = 'viewBox="'.concat(le(-c[4] / c[0], o), " ").concat(le(-c[5] / c[3], o), " ").concat(le(this.width / c[0], o), " ").concat(le(this.height / c[3], o), '" ');
    } else l = 'viewBox="0 0 '.concat(this.width, " ").concat(this.height, '" ');
    e.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', s, '" ', 'height="', i, '" ', l, `xml:space="preserve">
`, "<desc>Created with Fabric.js ", al, `</desc>
`, `<defs>
`, this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(n), `</defs>
`);
  }
  createSVGClipPathMarkup(e) {
    const n = this.clipPath;
    return n ? (n.clipPathId = "CLIPPATH_".concat(Cs()), '<clipPath id="'.concat(n.clipPathId, `" >
`).concat(n.toClipPathSVG(e.reviver), `</clipPath>
`)) : "";
  }
  createSVGRefElementsMarkup() {
    return ["background", "overlay"].map((e) => {
      const n = this["".concat(e, "Color")];
      if (rn(n)) {
        const s = this["".concat(e, "Vpt")], i = this.viewportTransform, o = { isType: () => !1, width: this.width / (s ? i[0] : 1), height: this.height / (s ? i[3] : 1) };
        return n.toSVG(o, { additionalTransform: s ? dr(i) : "" });
      }
    }).join("");
  }
  createSVGFontFacesMarkup() {
    const e = [], n = {}, s = Gt.fontPaths;
    this._objects.forEach(function o(a) {
      e.push(a), po(a) && a._objects.forEach(o);
    }), e.forEach((o) => {
      if (!(a = o) || typeof a._renderText != "function") return;
      var a;
      const { styles: l, fontFamily: c } = o;
      !n[c] && s[c] && (n[c] = !0, l && Object.values(l).forEach((u) => {
        Object.values(u).forEach((h) => {
          let { fontFamily: f = "" } = h;
          !n[f] && s[f] && (n[f] = !0);
        });
      }));
    });
    const i = Object.keys(n).map((o) => `		@font-face {
			font-family: '`.concat(o, `';
			src: url('`).concat(s[o], `');
		}
`)).join("");
    return i ? `	<style type="text/css"><![CDATA[
`.concat(i, `]]></style>
`) : "";
  }
  _setSVGObjects(e, n) {
    this.forEachObject((s) => {
      s.excludeFromExport || this._setSVGObject(e, s, n);
    });
  }
  _setSVGObject(e, n, s) {
    e.push(n.toSVG(s));
  }
  _setSVGBgOverlayImage(e, n, s) {
    const i = this[n];
    i && !i.excludeFromExport && i.toSVG && e.push(i.toSVG(s));
  }
  _setSVGBgOverlayColor(e, n) {
    const s = this["".concat(n, "Color")];
    if (s) if (rn(s)) {
      const i = s.repeat || "", o = this.width, a = this.height, l = this["".concat(n, "Vpt")] ? dr(gn(this.viewportTransform)) : "";
      e.push('<rect transform="'.concat(l, " translate(").concat(o / 2, ",").concat(a / 2, ')" x="').concat(s.offsetX - o / 2, '" y="').concat(s.offsetY - a / 2, '" width="').concat(i !== "repeat-y" && i !== "no-repeat" || !Yc(s) ? o : s.source.width, '" height="').concat(i !== "repeat-x" && i !== "no-repeat" || !Yc(s) ? a : s.source.height, '" fill="url(#SVGID_').concat(s.id, `)"></rect>
`));
    } else e.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', s, '"', `></rect>
`);
  }
  loadFromJSON(e, n) {
    let { signal: s } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return Promise.reject(new Pn("`json` is undefined"));
    const i = typeof e == "string" ? JSON.parse(e) : e, { objects: o = [] } = i, a = ue(i, rC), { backgroundImage: l, background: c, overlayImage: u, overlay: h, clipPath: f } = a, m = this.renderOnAddRemove;
    return this.renderOnAddRemove = !1, Promise.all([hr(o, { reviver: n, signal: s }), la({ backgroundImage: l, backgroundColor: c, overlayImage: u, overlayColor: h, clipPath: f }, { signal: s })]).then((p) => {
      let [y, v] = p;
      return this.clear(), this.add(...y), this.set(a), this.set(v), this.renderOnAddRemove = m, this;
    });
  }
  clone(e) {
    const n = this.toObject(e);
    return this.cloneWithoutData().loadFromJSON(n);
  }
  cloneWithoutData() {
    const e = ln(this);
    return new this.constructor(e);
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: s = 1, multiplier: i = 1, enableRetinaScaling: o = !1 } = e, a = i * (o ? this.getRetinaScaling() : 1);
    return ad(this.toCanvasElement(a, e), n, s);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { format: n = "png", quality: s = 1, multiplier: i = 1, enableRetinaScaling: o = !1 } = e, a = i * (o ? this.getRetinaScaling() : 1);
    return ld(this.toCanvasElement(a, e), n, s);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, { width: n, height: s, left: i, top: o, filter: a } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const l = (n || this.width) * e, c = (s || this.height) * e, u = this.getZoom(), h = this.width, f = this.height, m = this.skipControlsDrawing, p = u * e, y = this.viewportTransform, v = [p, 0, 0, p, (y[4] - (i || 0)) * e, (y[5] - (o || 0)) * e], _ = this.enableRetinaScaling, g = ln({ width: l, height: c }), C = a ? this._objects.filter((x) => a(x)) : this._objects;
    return this.enableRetinaScaling = !1, this.viewportTransform = v, this.width = l, this.height = c, this.skipControlsDrawing = !0, this.calcViewportBoundaries(), this.renderCanvas(g.getContext("2d"), C), this.viewportTransform = y, this.width = h, this.height = f, this.calcViewportBoundaries(), this.enableRetinaScaling = _, this.skipControlsDrawing = m, g;
  }
  dispose() {
    return !this.disposed && this.elements.cleanupDOM({ width: this.width, height: this.height }), Ao.cancelByCanvas(this), this.disposed = !0, new Promise((e, n) => {
      const s = () => {
        this.destroy(), e(!0);
      };
      s.kill = n, this.__cleanupTask && this.__cleanupTask.kill("aborted"), this.destroyed ? e(!1) : this.nextRenderHandle ? this.__cleanupTask = s : s();
    });
  }
  destroy() {
    this.destroyed = !0, this.cancelRequestedRender(), this.forEachObject((e) => e.dispose()), this._objects = [], this.backgroundImage && this.backgroundImage.dispose(), this.backgroundImage = void 0, this.overlayImage && this.overlayImage.dispose(), this.overlayImage = void 0, this.elements.dispose();
  }
  toString() {
    return "#<Canvas (".concat(this.complexity(), "): { objects: ").concat(this._objects.length, " }>");
  }
}
nt(wr, "ownDefaults", iC);
const oC = ["touchstart", "touchmove", "touchend"], aC = (r) => {
  const e = fd(r.target), n = function(s) {
    const i = s.changedTouches;
    return i && i[0] ? i[0] : s;
  }(r);
  return new mt(n.clientX + e.left, n.clientY + e.top);
}, ul = (r) => oC.includes(r.type) || r.pointerType === "touch", qc = (r) => {
  r.preventDefault(), r.stopPropagation();
}, Zn = (r) => {
  let e = 0, n = 0, s = 0, i = 0;
  for (let o = 0, a = r.length; o < a; o++) {
    const { x: l, y: c } = r[o];
    (l > s || !o) && (s = l), (l < e || !o) && (e = l), (c > i || !o) && (i = c), (c < n || !o) && (n = c);
  }
  return { left: e, top: n, width: s - e, height: i - n };
}, lC = ["translateX", "translateY", "scaleX", "scaleY"], cC = (r, e) => Io(r, Pe(e, r.calcOwnMatrix())), Io = (r, e) => {
  const n = Fo(e), { translateX: s, translateY: i, scaleX: o, scaleY: a } = n, l = ue(n, lC), c = new mt(s, i);
  r.flipX = !1, r.flipY = !1, Object.assign(r, l), r.set({ scaleX: o, scaleY: a }), r.setPositionByOrigin(c, Ut, Ut);
}, uC = (r) => {
  r.scaleX = 1, r.scaleY = 1, r.skewX = 0, r.skewY = 0, r.flipX = !1, r.flipY = !1, r.rotate(0);
}, vd = (r) => ({ scaleX: r.scaleX, scaleY: r.scaleY, skewX: r.skewX, skewY: r.skewY, angle: r.angle, left: r.left, flipX: r.flipX, flipY: r.flipY, top: r.top }), Gl = (r, e, n) => {
  const s = r / 2, i = e / 2, o = [new mt(-s, -i), new mt(s, -i), new mt(-s, i), new mt(s, i)].map((l) => l.transform(n)), a = Zn(o);
  return new mt(a.width, a.height);
}, ca = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : $e;
  return Pe(gn(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $e), r);
}, fi = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $e, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : $e;
  return r.transform(ca(e, n));
}, hC = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $e, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : $e;
  return r.transform(ca(e, n), !0);
}, dC = (r, e, n) => {
  const s = ca(e, n);
  return Io(r, Pe(s, r.calcOwnMatrix())), s;
}, yd = (r, e) => {
  var n;
  const { transform: { target: s } } = e;
  (n = s.canvas) === null || n === void 0 || n.fire("object:".concat(r), st(st({}, e), {}, { target: s })), s.fire(r, e);
}, fC = { left: -0.5, top: -0.5, center: 0, bottom: 0.5, right: 0.5 }, Se = (r) => typeof r == "string" ? fC[r] : r - 0.5, Lo = "not-allowed";
function bd(r) {
  return Se(r.originX) === Se(Ut) && Se(r.originY) === Se(Ut);
}
function Zc(r) {
  return 0.5 - Se(r);
}
const bn = (r, e) => r[e], _d = (r, e, n, s) => ({ e: r, transform: e, pointer: new mt(n, s) });
function xd(r, e) {
  const n = r.getTotalAngle() + os(Math.atan2(e.y, e.x)) + 360;
  return Math.round(n % 360 / 45);
}
function Yl(r, e, n, s, i) {
  var o;
  let { target: a, corner: l } = r;
  const c = a.controls[l], u = ((o = a.canvas) === null || o === void 0 ? void 0 : o.getZoom()) || 1, h = a.padding / u, f = function(m, p, y, v) {
    const _ = m.getRelativeCenterPoint(), g = y !== void 0 && v !== void 0 ? m.translateToGivenOrigin(_, Ut, Ut, y, v) : new mt(m.left, m.top);
    return (m.angle ? p.rotate(-_e(m.angle), _) : p).subtract(g);
  }(a, new mt(s, i), e, n);
  return f.x >= h && (f.x -= h), f.x <= -h && (f.x += h), f.y >= h && (f.y -= h), f.y <= h && (f.y += h), f.x -= c.offsetX, f.y -= c.offsetY, f;
}
const pC = (r, e, n, s) => {
  const { target: i, offsetX: o, offsetY: a } = e, l = n - o, c = s - a, u = !bn(i, "lockMovementX") && i.left !== l, h = !bn(i, "lockMovementY") && i.top !== c;
  return u && i.set(Jt, l), h && i.set(Xe, c), (u || h) && yd(nd, _d(r, e, n, s)), u || h;
}, Ro = (r) => r.replace(/\s+/g, " "), Jc = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#0FF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000", blanchedalmond: "#FFEBCD", blue: "#00F", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#0FF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#F0F", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#789", lightslategrey: "#789", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#0F0", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#F0F", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#639", red: "#F00", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFF", whitesmoke: "#F5F5F5", yellow: "#FF0", yellowgreen: "#9ACD32" }, Fa = (r, e, n) => (n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? r + 6 * (e - r) * n : n < 0.5 ? e : n < 2 / 3 ? r + (e - r) * (2 / 3 - n) * 6 : r), Qc = (r, e, n, s) => {
  r /= 255, e /= 255, n /= 255;
  const i = Math.max(r, e, n), o = Math.min(r, e, n);
  let a, l;
  const c = (i + o) / 2;
  if (i === o) a = l = 0;
  else {
    const u = i - o;
    switch (l = c > 0.5 ? u / (2 - i - o) : u / (i + o), i) {
      case r:
        a = (e - n) / u + (e < n ? 6 : 0);
        break;
      case e:
        a = (n - r) / u + 2;
        break;
      case n:
        a = (r - e) / u + 4;
    }
    a /= 6;
  }
  return [Math.round(360 * a), Math.round(100 * l), Math.round(100 * c), s];
}, tu = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "1";
  return parseFloat(r) / (r.endsWith("%") ? 100 : 1);
}, Ir = (r) => Math.min(Math.round(r), 255).toString(16).toUpperCase().padStart(2, "0"), eu = (r) => {
  let [e, n, s, i = 1] = r;
  const o = Math.round(0.3 * e + 0.59 * n + 0.11 * s);
  return [o, o, o, i];
};
class ee {
  constructor(e) {
    if (nt(this, "isUnrecognised", !1), e) if (e instanceof ee) this.setSource([...e._source]);
    else if (Array.isArray(e)) {
      const [n, s, i, o = 1] = e;
      this.setSource([n, s, i, o]);
    } else this.setSource(this._tryParsingColor(e));
    else this.setSource([0, 0, 0, 1]);
  }
  _tryParsingColor(e) {
    return (e = e.toLowerCase()) in Jc && (e = Jc[e]), e === "transparent" ? [255, 255, 255, 0] : ee.sourceFromHex(e) || ee.sourceFromRgb(e) || ee.sourceFromHsl(e) || (this.isUnrecognised = !0) && [0, 0, 0, 1];
  }
  getSource() {
    return this._source;
  }
  setSource(e) {
    this._source = e;
  }
  toRgb() {
    const [e, n, s] = this.getSource();
    return "rgb(".concat(e, ",").concat(n, ",").concat(s, ")");
  }
  toRgba() {
    return "rgba(".concat(this.getSource().join(","), ")");
  }
  toHsl() {
    const [e, n, s] = Qc(...this.getSource());
    return "hsl(".concat(e, ",").concat(n, "%,").concat(s, "%)");
  }
  toHsla() {
    const [e, n, s, i] = Qc(...this.getSource());
    return "hsla(".concat(e, ",").concat(n, "%,").concat(s, "%,").concat(i, ")");
  }
  toHex() {
    return this.toHexa().slice(0, 6);
  }
  toHexa() {
    const [e, n, s, i] = this.getSource();
    return "".concat(Ir(e)).concat(Ir(n)).concat(Ir(s)).concat(Ir(Math.round(255 * i)));
  }
  getAlpha() {
    return this.getSource()[3];
  }
  setAlpha(e) {
    return this._source[3] = e, this;
  }
  toGrayscale() {
    return this.setSource(eu(this.getSource())), this;
  }
  toBlackWhite(e) {
    const [n, , , s] = eu(this.getSource()), i = n < (e || 127) ? 0 : 255;
    return this.setSource([i, i, i, s]), this;
  }
  overlayWith(e) {
    e instanceof ee || (e = new ee(e));
    const n = this.getSource(), s = e.getSource(), [i, o, a] = n.map((l, c) => Math.round(0.5 * l + 0.5 * s[c]));
    return this.setSource([i, o, a, n[3]]), this;
  }
  static fromRgb(e) {
    return ee.fromRgba(e);
  }
  static fromRgba(e) {
    return new ee(ee.sourceFromRgb(e));
  }
  static sourceFromRgb(e) {
    const n = Ro(e).match(/^rgba?\(\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d{0,3}(?:\.\d+)?%?)\s?)?\)$/i);
    if (n) {
      const [s, i, o] = n.slice(1, 4).map((a) => {
        const l = parseFloat(a);
        return a.endsWith("%") ? Math.round(2.55 * l) : l;
      });
      return [s, i, o, tu(n[4])];
    }
  }
  static fromHsl(e) {
    return ee.fromHsla(e);
  }
  static fromHsla(e) {
    return new ee(ee.sourceFromHsl(e));
  }
  static sourceFromHsl(e) {
    const n = Ro(e).match(/^hsla?\(\s?([+-]?\d{0,3}(?:\.\d+)?(?:deg|turn|rad)?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?[\s|,]\s?(\d{0,3}(?:\.\d+)?%?)\s?(?:\s?[,/]\s?(\d*(?:\.\d+)?%?)\s?)?\)$/i);
    if (!n) return;
    const s = (ee.parseAngletoDegrees(n[1]) % 360 + 360) % 360 / 360, i = parseFloat(n[2]) / 100, o = parseFloat(n[3]) / 100;
    let a, l, c;
    if (i === 0) a = l = c = o;
    else {
      const u = o <= 0.5 ? o * (i + 1) : o + i - o * i, h = 2 * o - u;
      a = Fa(h, u, s + 1 / 3), l = Fa(h, u, s), c = Fa(h, u, s - 1 / 3);
    }
    return [Math.round(255 * a), Math.round(255 * l), Math.round(255 * c), tu(n[4])];
  }
  static fromHex(e) {
    return new ee(ee.sourceFromHex(e));
  }
  static sourceFromHex(e) {
    if (e.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)) {
      const n = e.slice(e.indexOf("#") + 1);
      let s;
      s = n.length <= 4 ? n.split("").map((c) => c + c) : n.match(/.{2}/g);
      const [i, o, a, l = 255] = s.map((c) => parseInt(c, 16));
      return [i, o, a, l / 255];
    }
  }
  static parseAngletoDegrees(e) {
    const n = e.toLowerCase(), s = parseFloat(n);
    return n.includes("rad") ? os(s) : n.includes("turn") ? 360 * s : s;
  }
}
const pi = function(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Vl;
  const n = /\D{0,2}$/.exec(r), s = parseFloat(r), i = Gt.DPI;
  switch (n == null ? void 0 : n[0]) {
    case "mm":
      return s * i / 25.4;
    case "cm":
      return s * i / 2.54;
    case "in":
      return s * i;
    case "pt":
      return s * i / 72;
    case "pc":
      return s * i / 72 * 12;
    case "em":
      return s * e;
    default:
      return s;
  }
}, mC = (r) => {
  const [e, n] = r.trim().split(" "), [s, i] = (o = e) && o !== Ge ? [o.slice(1, 4), o.slice(5, 8)] : o === Ge ? [o, o] : ["Mid", "Mid"];
  var o;
  return { meetOrSlice: n || "meet", alignX: s, alignY: i };
}, fr = function(r, e) {
  let n, s, i = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
  if (e) if (e.toLive) n = "url(#SVGID_".concat(e.id, ")");
  else {
    const o = new ee(e), a = o.getAlpha();
    n = o.toRgb(), a !== 1 && (s = a.toString());
  }
  else n = "none";
  return i ? "".concat(r, ": ").concat(n, "; ").concat(s ? "".concat(r, "-opacity: ").concat(s, "; ") : "") : "".concat(r, '="').concat(n, '" ').concat(s ? "".concat(r, '-opacity="').concat(s, '" ') : "");
};
class wd {
  getSvgStyles(e) {
    const n = this.fillRule ? this.fillRule : "nonzero", s = this.strokeWidth ? this.strokeWidth : "0", i = this.strokeDashArray ? this.strokeDashArray.join(" ") : Ge, o = this.strokeDashOffset ? this.strokeDashOffset : "0", a = this.strokeLineCap ? this.strokeLineCap : "butt", l = this.strokeLineJoin ? this.strokeLineJoin : "miter", c = this.strokeMiterLimit ? this.strokeMiterLimit : "4", u = this.opacity !== void 0 ? this.opacity : "1", h = this.visible ? "" : " visibility: hidden;", f = e ? "" : this.getSvgFilter(), m = fr(Te, this.fill);
    return [fr(Ye, this.stroke), "stroke-width: ", s, "; ", "stroke-dasharray: ", i, "; ", "stroke-linecap: ", a, "; ", "stroke-dashoffset: ", o, "; ", "stroke-linejoin: ", l, "; ", "stroke-miterlimit: ", c, "; ", m, "fill-rule: ", n, "; ", "opacity: ", u, ";", f, h].join("");
  }
  getSvgFilter() {
    return this.shadow ? "filter: url(#SVGID_".concat(this.shadow.id, ");") : "";
  }
  getSvgCommons() {
    return [this.id ? 'id="'.concat(this.id, '" ') : "", this.clipPath ? 'clip-path="url(#'.concat(this.clipPath.clipPathId, ')" ') : ""].join("");
  }
  getSvgTransform(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = e ? this.calcTransformMatrix() : this.calcOwnMatrix(), i = 'transform="'.concat(dr(s));
    return "".concat(i).concat(n, '" ');
  }
  _toSVG(e) {
    return [""];
  }
  toSVG(e) {
    return this._createBaseSVGMarkup(this._toSVG(e), { reviver: e });
  }
  toClipPathSVG(e) {
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(e), { reviver: e });
  }
  _createBaseClipPathSVGMarkup(e) {
    let { reviver: n, additionalTransform: s = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = [this.getSvgTransform(!0, s), this.getSvgCommons()].join(""), o = e.indexOf("COMMON_PARTS");
    return e[o] = i, n ? n(e.join("")) : e.join("");
  }
  _createBaseSVGMarkup(e) {
    let { noStyle: n, reviver: s, withShadow: i, additionalTransform: o } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const a = n ? "" : 'style="'.concat(this.getSvgStyles(), '" '), l = i ? 'style="'.concat(this.getSvgFilter(), '" ') : "", c = this.clipPath, u = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", h = c && c.absolutePositioned, f = this.stroke, m = this.fill, p = this.shadow, y = [], v = e.indexOf("COMMON_PARTS");
    let _;
    c && (c.clipPathId = "CLIPPATH_".concat(Cs()), _ = '<clipPath id="'.concat(c.clipPathId, `" >
`).concat(c.toClipPathSVG(s), `</clipPath>
`)), h && y.push("<g ", l, this.getSvgCommons(), ` >
`), y.push("<g ", this.getSvgTransform(!1), h ? "" : l + this.getSvgCommons(), ` >
`);
    const g = [a, u, n ? "" : this.addPaintOrder(), " ", o ? 'transform="'.concat(o, '" ') : ""].join("");
    return e[v] = g, rn(m) && y.push(m.toSVG(this)), rn(f) && y.push(f.toSVG(this)), p && y.push(p.toSVG(this)), c && y.push(_), y.push(e.join("")), y.push(`</g>
`), h && y.push(`</g>
`), s ? s(y.join("")) : y.join("");
  }
  addPaintOrder() {
    return this.paintFirst !== Te ? ' paint-order="'.concat(this.paintFirst, '" ') : "";
  }
}
function ua(r) {
  return new RegExp("^(" + r.join("|") + ")\\b", "i");
}
const Hs = "textDecorationThickness", Sd = ["fontSize", "fontWeight", "fontFamily", "fontStyle"], Cd = ["underline", "overline", "linethrough"], kd = [...Sd, "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], Td = [...kd, ...Cd, "textBackgroundColor", "direction", Hs], gC = [...Sd, ...Cd, Ye, "strokeWidth", Te, "deltaY", "textBackgroundColor", Hs], vC = { _reNewline: $l, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: Jt, fontStyle: "normal", lineHeight: 1.16, textBackgroundColor: "", stroke: null, shadow: null, path: void 0, pathStartOffset: 0, pathSide: Jt, pathAlign: "baseline", charSpacing: 0, deltaY: 0, direction: "ltr", CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, superscript: { size: 0.6, baseline: -0.35 }, subscript: { size: 0.6, baseline: 0.11 }, _fontSizeFraction: 0.222, offsets: { underline: 0.1, linethrough: -0.28167, overline: -0.81333 }, _fontSizeMult: 1.13, [Hs]: 66.667 }, En = "justify", zo = "justify-left", Qi = "justify-right", tr = "justify-center";
var nu, su, iu;
const vn = String.raw(nu || (nu = In(["[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?"], ["[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?"]))), Ia = String.raw(su || (su = In(["(?:s*,?s+|s*,s*)"], ["(?:\\s*,?\\s+|\\s*,\\s*)"]))), yC = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + vn + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + vn + "))?\\s+(.*)"), bC = { cx: Jt, x: Jt, r: "radius", cy: Xe, y: Xe, display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing", "text-decoration-thickness": Hs }, La = "font-size", Ra = "clip-path";
ua(["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"]);
ua(["symbol", "image", "marker", "pattern", "view", "svg"]);
const ru = ua(["symbol", "g", "a", "svg", "clipPath", "defs"]);
new RegExp(String.raw(iu || (iu = In(["^s*(", ")", "(", ")", "(", ")", "(", ")s*$"], ["^\\s*(", ")", "(", ")", "(", ")", "(", ")\\s*$"])), vn, Ia, vn, Ia, vn, Ia, vn));
const _C = new mt(1, 0), Md = new mt(), Od = (r, e) => r.rotate(e), hl = (r, e) => new mt(e).subtract(r), dl = (r) => r.distanceFrom(Md), fl = (r, e) => Math.atan2(er(r, e), wC(r, e)), xC = (r) => fl(_C, r), Kl = (r) => r.eq(Md) ? r : r.scalarDivide(dl(r)), Ed = function(r) {
  let e = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
  return Kl(new mt(-r.y, r.x).scalarMultiply(e ? 1 : -1));
}, er = (r, e) => r.x * e.y - r.y * e.x, wC = (r, e) => r.x * e.x + r.y * e.y, ou = (r, e, n) => {
  if (r.eq(e) || r.eq(n)) return !0;
  const s = er(e, n), i = er(e, r), o = er(n, r);
  return s >= 0 ? i >= 0 && o <= 0 : !(i <= 0 && o >= 0);
}, au = "(-?\\d+(?:\\.\\d*)?(?:px)?(?:\\s?|$))?", lu = new RegExp("(?:\\s|^)" + au + au + "(" + vn + "?(?:px)?)?(?:\\s?|$)(?:$|\\s)");
class Jn {
  constructor(e) {
    const n = typeof e == "string" ? Jn.parseShadow(e) : e;
    Object.assign(this, Jn.ownDefaults, n), this.id = Cs();
  }
  static parseShadow(e) {
    const n = e.trim(), [, s = 0, i = 0, o = 0] = (lu.exec(n) || []).map((a) => parseFloat(a) || 0);
    return { color: (n.replace(lu, "") || "rgb(0,0,0)").trim(), offsetX: s, offsetY: i, blur: o };
  }
  toString() {
    return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
  }
  toSVG(e) {
    const n = Od(new mt(this.offsetX, this.offsetY), _e(-e.angle)), s = new ee(this.color);
    let i = 40, o = 40;
    return e.width && e.height && (i = 100 * le((Math.abs(n.x) + this.blur) / e.width, Gt.NUM_FRACTION_DIGITS) + 20, o = 100 * le((Math.abs(n.y) + this.blur) / e.height, Gt.NUM_FRACTION_DIGITS) + 20), e.flipX && (n.x *= -1), e.flipY && (n.y *= -1), '<filter id="SVGID_'.concat(this.id, '" y="-').concat(o, '%" height="').concat(100 + 2 * o, '%" x="-').concat(i, '%" width="').concat(100 + 2 * i, `%" >
	<feGaussianBlur in="SourceAlpha" stdDeviation="`).concat(le(this.blur ? this.blur / 2 : 0, Gt.NUM_FRACTION_DIGITS), `"></feGaussianBlur>
	<feOffset dx="`).concat(le(n.x, Gt.NUM_FRACTION_DIGITS), '" dy="').concat(le(n.y, Gt.NUM_FRACTION_DIGITS), `" result="oBlur" ></feOffset>
	<feFlood flood-color="`).concat(s.toRgb(), '" flood-opacity="').concat(s.getAlpha(), `"/>
	<feComposite in2="oBlur" operator="in" />
	<feMerge>
		<feMergeNode></feMergeNode>
		<feMergeNode in="SourceGraphic"></feMergeNode>
	</feMerge>
</filter>
`);
  }
  toObject() {
    const e = { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling, type: this.constructor.type }, n = Jn.ownDefaults;
    return this.includeDefaultValues ? e : Xl(e, (s, i) => s !== n[i]);
  }
  static async fromObject(e) {
    return new this(e);
  }
}
nt(Jn, "ownDefaults", { color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1 }), nt(Jn, "type", "shadow"), Et.setClass(Jn, "shadow");
const wi = (r, e, n) => Math.max(r, Math.min(e, n)), SC = [Xe, Jt, Ke, an, "flipX", "flipY", "originX", "originY", "angle", "opacity", "globalCompositeOperation", "shadow", "visible", ki, Ti], ls = [Te, Ye, "strokeWidth", "strokeDashArray", "width", "height", "paintFirst", "strokeUniform", "strokeLineCap", "strokeDashOffset", "strokeLineJoin", "strokeMiterLimit", "backgroundColor", "clipPath"], CC = { top: 0, left: 0, width: 0, height: 0, angle: 0, flipX: !1, flipY: !1, scaleX: 1, scaleY: 1, minScaleLimit: 0, skewX: 0, skewY: 0, originX: Jt, originY: Xe, strokeWidth: 1, strokeUniform: !1, padding: 0, opacity: 1, paintFirst: Te, fill: "rgb(0,0,0)", fillRule: "nonzero", stroke: null, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, globalCompositeOperation: "source-over", backgroundColor: "", shadow: null, visible: !0, includeDefaultValues: !0, excludeFromExport: !1, objectCaching: !0, clipPath: void 0, inverted: !1, absolutePositioned: !1, centeredRotation: !0, centeredScaling: !1, dirty: !0 }, kC = (r, e, n, s) => -n * Math.cos(r / s * _r) + n + e, TC = () => !1;
class ql {
  constructor(e) {
    let { startValue: n, byValue: s, duration: i = 500, delay: o = 0, easing: a = kC, onStart: l = fo, onChange: c = fo, onComplete: u = fo, abort: h = TC, target: f } = e;
    nt(this, "_state", "pending"), nt(this, "durationProgress", 0), nt(this, "valueProgress", 0), this.tick = this.tick.bind(this), this.duration = i, this.delay = o, this.easing = a, this._onStart = l, this._onChange = c, this._onComplete = u, this._abort = h, this.target = f, this.startValue = n, this.byValue = s, this.value = this.startValue, this.endValue = Object.freeze(this.calculate(this.duration).value);
  }
  get state() {
    return this._state;
  }
  isDone() {
    return this._state === "aborted" || this._state === "completed";
  }
  start() {
    const e = (n) => {
      this._state === "pending" && (this.startTime = n || +/* @__PURE__ */ new Date(), this._state = "running", this._onStart(), this.tick(this.startTime));
    };
    this.register(), this.delay > 0 ? setTimeout(() => mo(e), this.delay) : mo(e);
  }
  tick(e) {
    const n = (e || +/* @__PURE__ */ new Date()) - this.startTime, s = Math.min(n, this.duration);
    this.durationProgress = s / this.duration;
    const { value: i, valueProgress: o } = this.calculate(s);
    this.value = Object.freeze(i), this.valueProgress = o, this._state !== "aborted" && (this._abort(this.value, this.valueProgress, this.durationProgress) ? (this._state = "aborted", this.unregister()) : n >= this.duration ? (this.durationProgress = this.valueProgress = 1, this._onChange(this.endValue, this.valueProgress, this.durationProgress), this._state = "completed", this._onComplete(this.endValue, this.valueProgress, this.durationProgress), this.unregister()) : (this._onChange(this.value, this.valueProgress, this.durationProgress), mo(this.tick)));
  }
  register() {
    Ao.push(this);
  }
  unregister() {
    Ao.remove(this);
  }
  abort() {
    this._state = "aborted", this.unregister();
  }
}
const MC = ["startValue", "endValue"];
class OC extends ql {
  constructor(e) {
    let { startValue: n = 0, endValue: s = 100 } = e;
    super(st(st({}, ue(e, MC)), {}, { startValue: n, byValue: s - n }));
  }
  calculate(e) {
    const n = this.easing(e, this.startValue, this.byValue, this.duration);
    return { value: n, valueProgress: Math.abs((n - this.startValue) / this.byValue) };
  }
}
const EC = ["startValue", "endValue"];
class PC extends ql {
  constructor(e) {
    let { startValue: n = [0], endValue: s = [100] } = e;
    super(st(st({}, ue(e, EC)), {}, { startValue: n, byValue: s.map((i, o) => i - n[o]) }));
  }
  calculate(e) {
    const n = this.startValue.map((s, i) => this.easing(e, s, this.byValue[i], this.duration, i));
    return { value: n, valueProgress: Math.abs((n[0] - this.startValue[0]) / this.byValue[0]) };
  }
}
const DC = ["startValue", "endValue", "easing", "onChange", "onComplete", "abort"], AC = (r, e, n, s) => e + n * (1 - Math.cos(r / s * _r)), za = (r) => r && ((e, n, s) => r(new ee(e).toRgba(), n, s));
class FC extends ql {
  constructor(e) {
    let { startValue: n, endValue: s, easing: i = AC, onChange: o, onComplete: a, abort: l } = e, c = ue(e, DC);
    const u = new ee(n).getSource(), h = new ee(s).getSource();
    super(st(st({}, c), {}, { startValue: u, byValue: h.map((f, m) => f - u[m]), easing: i, onChange: za(o), onComplete: za(a), abort: za(l) }));
  }
  calculate(e) {
    const [n, s, i, o] = this.startValue.map((l, c) => this.easing(e, l, this.byValue[c], this.duration, c)), a = [...[n, s, i].map(Math.round), wi(0, o, 1)];
    return { value: a, valueProgress: a.map((l, c) => this.byValue[c] !== 0 ? Math.abs((l - this.startValue[c]) / this.byValue[c]) : 0).find((l) => l !== 0) || 0 };
  }
}
function Pd(r) {
  const e = ((n) => Array.isArray(n.startValue) || Array.isArray(n.endValue))(r) ? new PC(r) : new OC(r);
  return e.start(), e;
}
function IC(r) {
  const e = new FC(r);
  return e.start(), e;
}
class fe {
  constructor(e) {
    this.status = e, this.points = [];
  }
  includes(e) {
    return this.points.some((n) => n.eq(e));
  }
  append() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    return this.points = this.points.concat(n.filter((i) => !this.includes(i))), this;
  }
  static isPointContained(e, n, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
    if (n.eq(s)) return e.eq(n);
    if (n.x === s.x) return e.x === n.x && (i || e.y >= Math.min(n.y, s.y) && e.y <= Math.max(n.y, s.y));
    if (n.y === s.y) return e.y === n.y && (i || e.x >= Math.min(n.x, s.x) && e.x <= Math.max(n.x, s.x));
    {
      const o = hl(n, s), a = hl(n, e).divide(o);
      return i ? Math.abs(a.x) === Math.abs(a.y) : a.x === a.y && a.x >= 0 && a.x <= 1;
    }
  }
  static isPointInPolygon(e, n) {
    const s = new mt(e).setX(Math.min(e.x - 1, ...n.map((o) => o.x)));
    let i = 0;
    for (let o = 0; o < n.length; o++) {
      const a = this.intersectSegmentSegment(n[o], n[(o + 1) % n.length], e, s);
      if (a.includes(e)) return !0;
      i += +(a.status === "Intersection");
    }
    return i % 2 == 1;
  }
  static intersectLineLine(e, n, s, i) {
    let o = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4], a = !(arguments.length > 5 && arguments[5] !== void 0) || arguments[5];
    const l = n.x - e.x, c = n.y - e.y, u = i.x - s.x, h = i.y - s.y, f = e.x - s.x, m = e.y - s.y, p = u * m - h * f, y = l * m - c * f, v = h * l - u * c;
    if (v !== 0) {
      const _ = p / v, g = y / v;
      return (o || 0 <= _ && _ <= 1) && (a || 0 <= g && g <= 1) ? new fe("Intersection").append(new mt(e.x + _ * l, e.y + _ * c)) : new fe();
    }
    if (p === 0 || y === 0) {
      const _ = o || a || fe.isPointContained(e, s, i) || fe.isPointContained(n, s, i) || fe.isPointContained(s, e, n) || fe.isPointContained(i, e, n);
      return new fe(_ ? "Coincident" : void 0);
    }
    return new fe("Parallel");
  }
  static intersectSegmentLine(e, n, s, i) {
    return fe.intersectLineLine(e, n, s, i, !1, !0);
  }
  static intersectSegmentSegment(e, n, s, i) {
    return fe.intersectLineLine(e, n, s, i, !1, !1);
  }
  static intersectLinePolygon(e, n, s) {
    let i = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
    const o = new fe(), a = s.length;
    for (let l, c, u, h = 0; h < a; h++) {
      if (l = s[h], c = s[(h + 1) % a], u = fe.intersectLineLine(e, n, l, c, i, !1), u.status === "Coincident") return u;
      o.append(...u.points);
    }
    return o.points.length > 0 && (o.status = "Intersection"), o;
  }
  static intersectSegmentPolygon(e, n, s) {
    return fe.intersectLinePolygon(e, n, s, !1);
  }
  static intersectPolygonPolygon(e, n) {
    const s = new fe(), i = e.length, o = [];
    for (let a = 0; a < i; a++) {
      const l = e[a], c = e[(a + 1) % i], u = fe.intersectSegmentPolygon(l, c, n);
      u.status === "Coincident" ? (o.push(u), s.append(l, c)) : s.append(...u.points);
    }
    return o.length > 0 && o.length === e.length ? new fe("Coincident") : (s.points.length > 0 && (s.status = "Intersection"), s);
  }
  static intersectPolygonRectangle(e, n, s) {
    const i = n.min(s), o = n.max(s), a = new mt(o.x, i.y), l = new mt(i.x, o.y);
    return fe.intersectPolygonPolygon(e, [i, a, o, l]);
  }
}
class LC extends od {
  getX() {
    return this.getXY().x;
  }
  setX(e) {
    this.setXY(this.getXY().setX(e));
  }
  getY() {
    return this.getXY().y;
  }
  setY(e) {
    this.setXY(this.getXY().setY(e));
  }
  getRelativeX() {
    return this.left;
  }
  setRelativeX(e) {
    this.left = e;
  }
  getRelativeY() {
    return this.top;
  }
  setRelativeY(e) {
    this.top = e;
  }
  getXY() {
    const e = this.getRelativeXY();
    return this.group ? Ue(e, this.group.calcTransformMatrix()) : e;
  }
  setXY(e, n, s) {
    this.group && (e = Ue(e, gn(this.group.calcTransformMatrix()))), this.setRelativeXY(e, n, s);
  }
  getRelativeXY() {
    return new mt(this.left, this.top);
  }
  setRelativeXY(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.originX, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.originY;
    this.setPositionByOrigin(e, n, s);
  }
  isStrokeAccountedForInDimensions() {
    return !1;
  }
  getCoords() {
    const { tl: e, tr: n, br: s, bl: i } = this.aCoords || (this.aCoords = this.calcACoords()), o = [e, n, s, i];
    if (this.group) {
      const a = this.group.calcTransformMatrix();
      return o.map((l) => Ue(l, a));
    }
    return o;
  }
  intersectsWithRect(e, n) {
    return fe.intersectPolygonRectangle(this.getCoords(), e, n).status === "Intersection";
  }
  intersectsWithObject(e) {
    const n = fe.intersectPolygonPolygon(this.getCoords(), e.getCoords());
    return n.status === "Intersection" || n.status === "Coincident" || e.isContainedWithinObject(this) || this.isContainedWithinObject(e);
  }
  isContainedWithinObject(e) {
    return this.getCoords().every((n) => e.containsPoint(n));
  }
  isContainedWithinRect(e, n) {
    const { left: s, top: i, width: o, height: a } = this.getBoundingRect();
    return s >= e.x && s + o <= n.x && i >= e.y && i + a <= n.y;
  }
  isOverlapping(e) {
    return this.intersectsWithObject(e) || this.isContainedWithinObject(e) || e.isContainedWithinObject(this);
  }
  containsPoint(e) {
    return fe.isPointInPolygon(e, this.getCoords());
  }
  isOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return !!this.getCoords().some((s) => s.x <= n.x && s.x >= e.x && s.y <= n.y && s.y >= e.y) || !!this.intersectsWithRect(e, n) || this.containsPoint(e.midPointFrom(n));
  }
  isPartiallyOnScreen() {
    if (!this.canvas) return !1;
    const { tl: e, br: n } = this.canvas.vptCoords;
    return this.intersectsWithRect(e, n) ? !0 : this.getCoords().every((s) => (s.x >= n.x || s.x <= e.x) && (s.y >= n.y || s.y <= e.y)) && this.containsPoint(e.midPointFrom(n));
  }
  getBoundingRect() {
    return Zn(this.getCoords());
  }
  getScaledWidth() {
    return this._getTransformedDimensions().x;
  }
  getScaledHeight() {
    return this._getTransformedDimensions().y;
  }
  scale(e) {
    this._set(Ke, e), this._set(an, e), this.setCoords();
  }
  scaleToWidth(e) {
    const n = this.getBoundingRect().width / this.getScaledWidth();
    return this.scale(e / this.width / n);
  }
  scaleToHeight(e) {
    const n = this.getBoundingRect().height / this.getScaledHeight();
    return this.scale(e / this.height / n);
  }
  getCanvasRetinaScaling() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.getRetinaScaling()) || 1;
  }
  getTotalAngle() {
    return this.group ? os(cd(this.calcTransformMatrix())) : this.angle;
  }
  getViewportTransform() {
    var e;
    return ((e = this.canvas) === null || e === void 0 ? void 0 : e.viewportTransform) || $e.concat();
  }
  calcACoords() {
    const e = Mi({ angle: this.angle }), { x: n, y: s } = this.getRelativeCenterPoint(), i = xr(n, s), o = Pe(i, e), a = this._getTransformedDimensions(), l = a.x / 2, c = a.y / 2;
    return { tl: Ue({ x: -l, y: -c }, o), tr: Ue({ x: l, y: -c }, o), bl: Ue({ x: -l, y: c }, o), br: Ue({ x: l, y: c }, o) };
  }
  setCoords() {
    this.aCoords = this.calcACoords();
  }
  transformMatrixKey() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = [];
    return !e && this.group && (n = this.group.transformMatrixKey(e)), n.push(this.top, this.left, this.width, this.height, this.scaleX, this.scaleY, this.angle, this.strokeWidth, this.skewX, this.skewY, +this.flipX, +this.flipY, Se(this.originX), Se(this.originY)), n;
  }
  calcTransformMatrix() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], n = this.calcOwnMatrix();
    if (e || !this.group) return n;
    const s = this.transformMatrixKey(e), i = this.matrixCache;
    return i && i.key.every((o, a) => o === s[a]) ? i.value : (this.group && (n = Pe(this.group.calcTransformMatrix(!1), n)), this.matrixCache = { key: s, value: n }, n);
  }
  calcOwnMatrix() {
    const e = this.transformMatrixKey(!0), n = this.ownMatrixCache;
    if (n && n.key === e) return n.value;
    const s = this.getRelativeCenterPoint(), i = { angle: this.angle, translateX: s.x, translateY: s.y, scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }, o = sC(i);
    return this.ownMatrixCache = { key: e, value: o }, o;
  }
  _getNonTransformedDimensions() {
    return new mt(this.width, this.height).scalarAdd(this.strokeWidth);
  }
  _calculateCurrentDimensions(e) {
    return this._getTransformedDimensions(e).transform(this.getViewportTransform(), !0).scalarAdd(2 * this.padding);
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = st({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, width: this.width, height: this.height, strokeWidth: this.strokeWidth }, e), s = n.strokeWidth;
    let i = s, o = 0;
    this.strokeUniform && (i = 0, o = s);
    const a = n.width + i, l = n.height + i;
    let c;
    return c = n.skewX === 0 && n.skewY === 0 ? new mt(a * n.scaleX, l * n.scaleY) : Gl(a, l, aa(n)), c.scalarAdd(o);
  }
  translateToGivenOrigin(e, n, s, i, o) {
    let a = e.x, l = e.y;
    const c = Se(i) - Se(n), u = Se(o) - Se(s);
    if (c || u) {
      const h = this._getTransformedDimensions();
      a += c * h.x, l += u * h.y;
    }
    return new mt(a, l);
  }
  translateToCenterPoint(e, n, s) {
    if (n === Ut && s === Ut) return e;
    const i = this.translateToGivenOrigin(e, n, s, Ut, Ut);
    return this.angle ? i.rotate(_e(this.angle), e) : i;
  }
  translateToOriginPoint(e, n, s) {
    const i = this.translateToGivenOrigin(e, Ut, Ut, n, s);
    return this.angle ? i.rotate(_e(this.angle), e) : i;
  }
  getCenterPoint() {
    const e = this.getRelativeCenterPoint();
    return this.group ? Ue(e, this.group.calcTransformMatrix()) : e;
  }
  getRelativeCenterPoint() {
    return this.translateToCenterPoint(new mt(this.left, this.top), this.originX, this.originY);
  }
  getPointByOrigin(e, n) {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), e, n);
  }
  setPositionByOrigin(e, n, s) {
    const i = this.translateToCenterPoint(e, n, s), o = this.translateToOriginPoint(i, this.originX, this.originY);
    this.set({ left: o.x, top: o.y });
  }
  _getLeftTopCoords() {
    return this.translateToOriginPoint(this.getRelativeCenterPoint(), Jt, Xe);
  }
}
const RC = ["type"], zC = ["extraParam"];
let jn = class vo extends LC {
  static getDefaults() {
    return vo.ownDefaults;
  }
  get type() {
    const e = this.constructor.type;
    return e === "FabricObject" ? "object" : e.toLowerCase();
  }
  set type(e) {
    Ss("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    super(), nt(this, "_cacheContext", null), Object.assign(this, vo.ownDefaults), this.setOptions(e);
  }
  _createCacheCanvas() {
    this._cacheCanvas = rs(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0;
  }
  _limitCacheSize(e) {
    const n = e.width, s = e.height, i = Gt.maxCacheSideLimit, o = Gt.minCacheSideLimit;
    if (n <= i && s <= i && n * s <= Gt.perfLimitSizeTotal) return n < o && (e.width = o), s < o && (e.height = o), e;
    const a = n / s, [l, c] = Ji.limitDimsByArea(a), u = wi(o, l, i), h = wi(o, c, i);
    return n > u && (e.zoomX /= n / u, e.width = u, e.capped = !0), s > h && (e.zoomY /= s / h, e.height = h, e.capped = !0), e;
  }
  _getCacheCanvasDimensions() {
    const e = this.getTotalObjectScaling(), n = this._getTransformedDimensions({ skewX: 0, skewY: 0 }), s = n.x * e.x / this.scaleX, i = n.y * e.y / this.scaleY;
    return { width: Math.ceil(s + 2), height: Math.ceil(i + 2), zoomX: e.x, zoomY: e.y, x: s, y: i };
  }
  _updateCacheCanvas() {
    const e = this._cacheCanvas, n = this._cacheContext, { width: s, height: i, zoomX: o, zoomY: a, x: l, y: c } = this._limitCacheSize(this._getCacheCanvasDimensions()), u = s !== e.width || i !== e.height, h = this.zoomX !== o || this.zoomY !== a;
    if (!e || !n) return !1;
    if (u || h) {
      s !== e.width || i !== e.height ? (e.width = s, e.height = i) : (n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, e.width, e.height));
      const f = l / 2, m = c / 2;
      return this.cacheTranslationX = Math.round(e.width / 2 - f) + f, this.cacheTranslationY = Math.round(e.height / 2 - m) + m, n.translate(this.cacheTranslationX, this.cacheTranslationY), n.scale(o, a), this.zoomX = o, this.zoomY = a, !0;
    }
    return !1;
  }
  setOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setOptions(e);
  }
  transform(e) {
    const n = this.group && !this.group._transformDone || this.group && this.canvas && e === this.canvas.contextTop, s = this.calcTransformMatrix(!n);
    e.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
  }
  getObjectScaling() {
    if (!this.group) return new mt(Math.abs(this.scaleX), Math.abs(this.scaleY));
    const e = Fo(this.calcTransformMatrix());
    return new mt(Math.abs(e.scaleX), Math.abs(e.scaleY));
  }
  getTotalObjectScaling() {
    const e = this.getObjectScaling();
    if (this.canvas) {
      const n = this.canvas.getZoom(), s = this.getCanvasRetinaScaling();
      return e.scalarMultiply(n * s);
    }
    return e;
  }
  getObjectOpacity() {
    let e = this.opacity;
    return this.group && (e *= this.group.getObjectOpacity()), e;
  }
  _constrainScale(e) {
    return Math.abs(e) < this.minScaleLimit ? e < 0 ? -this.minScaleLimit : this.minScaleLimit : e === 0 ? 1e-4 : e;
  }
  _set(e, n) {
    e !== Ke && e !== an || (n = this._constrainScale(n)), e === Ke && n < 0 ? (this.flipX = !this.flipX, n *= -1) : e === "scaleY" && n < 0 ? (this.flipY = !this.flipY, n *= -1) : e !== "shadow" || !n || n instanceof Jn || (n = new Jn(n));
    const s = this[e] !== n;
    return this[e] = n, s && this.constructor.cacheProperties.includes(e) && (this.dirty = !0), this.parent && (this.dirty || s && this.constructor.stateProperties.includes(e)) && this.parent._set("dirty", !0), this;
  }
  isNotVisible() {
    return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
  }
  render(e) {
    this.isNotVisible() || this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (e.save(), this._setupCompositeOperation(e), this.drawSelectionBackground(e), this.transform(e), this._setOpacity(e), this._setShadow(e), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(e)) : (this._removeCacheCanvas(), this.drawObject(e, !1, {}), this.dirty = !1), e.restore());
  }
  drawSelectionBackground(e) {
  }
  renderCache(e) {
    if (e = e || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && this._cacheContext) {
      const { zoomX: n, zoomY: s, cacheTranslationX: i, cacheTranslationY: o } = this, { width: a, height: l } = this._cacheCanvas;
      this.drawObject(this._cacheContext, e.forClipping, { zoomX: n, zoomY: s, cacheTranslationX: i, cacheTranslationY: o, width: a, height: l, parentClipPaths: [] }), this.dirty = !1;
    }
  }
  _removeCacheCanvas() {
    this._cacheCanvas = void 0, this._cacheContext = null;
  }
  hasStroke() {
    return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
  }
  hasFill() {
    return this.fill && this.fill !== "transparent";
  }
  needsItsOwnCache() {
    return !!(this.paintFirst === Ye && this.hasFill() && this.hasStroke() && this.shadow) || !!this.clipPath;
  }
  shouldCache() {
    return this.ownCaching = this.objectCaching && (!this.parent || !this.parent.isOnACache()) || this.needsItsOwnCache(), this.ownCaching;
  }
  willDrawShadow() {
    return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
  }
  drawClipPathOnCache(e, n, s) {
    e.save(), n.inverted ? e.globalCompositeOperation = "destination-out" : e.globalCompositeOperation = "destination-in", e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(s, 0, 0), e.restore();
  }
  drawObject(e, n, s) {
    const i = this.fill, o = this.stroke;
    n ? (this.fill = "black", this.stroke = "", this._setClippingProperties(e)) : this._renderBackground(e), this._render(e), this._drawClipPath(e, this.clipPath, s), this.fill = i, this.stroke = o;
  }
  createClipPathLayer(e, n) {
    const s = ln(n), i = s.getContext("2d");
    if (i.translate(n.cacheTranslationX, n.cacheTranslationY), i.scale(n.zoomX, n.zoomY), e._cacheCanvas = s, n.parentClipPaths.forEach((o) => {
      o.transform(i);
    }), n.parentClipPaths.push(e), e.absolutePositioned) {
      const o = gn(this.calcTransformMatrix());
      i.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
    }
    return e.transform(i), e.drawObject(i, !0, n), s;
  }
  _drawClipPath(e, n, s) {
    if (!n) return;
    n._transformDone = !0;
    const i = this.createClipPathLayer(n, s);
    this.drawClipPathOnCache(e, n, i);
  }
  drawCacheOnCanvas(e) {
    e.scale(1 / this.zoomX, 1 / this.zoomY), e.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
  }
  isCacheDirty() {
    let e = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
    if (this.isNotVisible()) return !1;
    const n = this._cacheCanvas, s = this._cacheContext;
    return !(!n || !s || e || !this._updateCacheCanvas()) || !!(this.dirty || this.clipPath && this.clipPath.absolutePositioned) && (n && s && !e && (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, n.width, n.height), s.restore()), !0);
  }
  _renderBackground(e) {
    if (!this.backgroundColor) return;
    const n = this._getNonTransformedDimensions();
    e.fillStyle = this.backgroundColor, e.fillRect(-n.x / 2, -n.y / 2, n.x, n.y), this._removeShadow(e);
  }
  _setOpacity(e) {
    this.group && !this.group._transformDone ? e.globalAlpha = this.getObjectOpacity() : e.globalAlpha *= this.opacity;
  }
  _setStrokeStyles(e, n) {
    const s = n.stroke;
    s && (e.lineWidth = n.strokeWidth, e.lineCap = n.strokeLineCap, e.lineDashOffset = n.strokeDashOffset, e.lineJoin = n.strokeLineJoin, e.miterLimit = n.strokeMiterLimit, rn(s) ? s.gradientUnits === "percentage" || s.gradientTransform || s.patternTransform ? this._applyPatternForTransformedGradient(e, s) : (e.strokeStyle = s.toLive(e), this._applyPatternGradientTransform(e, s)) : e.strokeStyle = n.stroke);
  }
  _setFillStyles(e, n) {
    let { fill: s } = n;
    s && (rn(s) ? (e.fillStyle = s.toLive(e), this._applyPatternGradientTransform(e, s)) : e.fillStyle = s);
  }
  _setClippingProperties(e) {
    e.globalAlpha = 1, e.strokeStyle = "transparent", e.fillStyle = "#000000";
  }
  _setLineDash(e, n) {
    n && n.length !== 0 && e.setLineDash(n);
  }
  _setShadow(e) {
    if (!this.shadow) return;
    const n = this.shadow, s = this.canvas, i = this.getCanvasRetinaScaling(), [o, , , a] = (s == null ? void 0 : s.viewportTransform) || $e, l = o * i, c = a * i, u = n.nonScaling ? new mt(1, 1) : this.getObjectScaling();
    e.shadowColor = n.color, e.shadowBlur = n.blur * Gt.browserShadowBlurConstant * (l + c) * (u.x + u.y) / 4, e.shadowOffsetX = n.offsetX * l * u.x, e.shadowOffsetY = n.offsetY * c * u.y;
  }
  _removeShadow(e) {
    this.shadow && (e.shadowColor = "", e.shadowBlur = e.shadowOffsetX = e.shadowOffsetY = 0);
  }
  _applyPatternGradientTransform(e, n) {
    if (!rn(n)) return { offsetX: 0, offsetY: 0 };
    const s = n.gradientTransform || n.patternTransform, i = -this.width / 2 + n.offsetX || 0, o = -this.height / 2 + n.offsetY || 0;
    return n.gradientUnits === "percentage" ? e.transform(this.width, 0, 0, this.height, i, o) : e.transform(1, 0, 0, 1, i, o), s && e.transform(s[0], s[1], s[2], s[3], s[4], s[5]), { offsetX: i, offsetY: o };
  }
  _renderPaintInOrder(e) {
    this.paintFirst === Ye ? (this._renderStroke(e), this._renderFill(e)) : (this._renderFill(e), this._renderStroke(e));
  }
  _render(e) {
  }
  _renderFill(e) {
    this.fill && (e.save(), this._setFillStyles(e, this), this.fillRule === "evenodd" ? e.fill("evenodd") : e.fill(), e.restore());
  }
  _renderStroke(e) {
    if (this.stroke && this.strokeWidth !== 0) {
      if (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this.strokeUniform) {
        const n = this.getObjectScaling();
        e.scale(1 / n.x, 1 / n.y);
      }
      this._setLineDash(e, this.strokeDashArray), this._setStrokeStyles(e, this), e.stroke(), e.restore();
    }
  }
  _applyPatternForTransformedGradient(e, n) {
    var s;
    const i = this._limitCacheSize(this._getCacheCanvasDimensions()), o = this.getCanvasRetinaScaling(), a = i.x / this.scaleX / o, l = i.y / this.scaleY / o, c = ln({ width: Math.ceil(a), height: Math.ceil(l) }), u = c.getContext("2d");
    u && (u.beginPath(), u.moveTo(0, 0), u.lineTo(a, 0), u.lineTo(a, l), u.lineTo(0, l), u.closePath(), u.translate(a / 2, l / 2), u.scale(i.zoomX / this.scaleX / o, i.zoomY / this.scaleY / o), this._applyPatternGradientTransform(u, n), u.fillStyle = n.toLive(e), u.fill(), e.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), e.scale(o * this.scaleX / i.zoomX, o * this.scaleY / i.zoomY), e.strokeStyle = (s = u.createPattern(c, "no-repeat")) !== null && s !== void 0 ? s : "");
  }
  _findCenterFromElement() {
    return new mt(this.left + this.width / 2, this.top + this.height / 2);
  }
  clone(e) {
    const n = this.toObject(e);
    return this.constructor.fromObject(n);
  }
  cloneAsImage(e) {
    const n = this.toCanvasElement(e);
    return new (Et.getClass("image"))(n);
  }
  toCanvasElement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = vd(this), s = this.group, i = this.shadow, o = Math.abs, a = e.enableRetinaScaling ? ed() : 1, l = (e.multiplier || 1) * a, c = e.canvasProvider || ((C) => new wr(C, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }));
    delete this.group, e.withoutTransform && uC(this), e.withoutShadow && (this.shadow = null), e.viewportTransform && dC(this, this.getViewportTransform()), this.setCoords();
    const u = rs(), h = this.getBoundingRect(), f = this.shadow, m = new mt();
    if (f) {
      const C = f.blur, x = f.nonScaling ? new mt(1, 1) : this.getObjectScaling();
      m.x = 2 * Math.round(o(f.offsetX) + C) * o(x.x), m.y = 2 * Math.round(o(f.offsetY) + C) * o(x.y);
    }
    const p = h.width + m.x, y = h.height + m.y;
    u.width = Math.ceil(p), u.height = Math.ceil(y);
    const v = c(u);
    e.format === "jpeg" && (v.backgroundColor = "#fff"), this.setPositionByOrigin(new mt(v.width / 2, v.height / 2), Ut, Ut);
    const _ = this.canvas;
    v._objects = [this], this.set("canvas", v), this.setCoords();
    const g = v.toCanvasElement(l || 1, e);
    return this.set("canvas", _), this.shadow = i, s && (this.group = s), this.set(n), this.setCoords(), v._objects = [], v.destroy(), g;
  }
  toDataURL() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ad(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  toBlob() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ld(this.toCanvasElement(e), e.format || "png", e.quality || 1);
  }
  isType() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    return n.includes(this.constructor.type) || n.includes(this.type);
  }
  complexity() {
    return 1;
  }
  toJSON() {
    return this.toObject();
  }
  rotate(e) {
    const { centeredRotation: n, originX: s, originY: i } = this;
    if (n) {
      const { x: o, y: a } = this.getRelativeCenterPoint();
      this.originX = Ut, this.originY = Ut, this.left = o, this.top = a;
    }
    if (this.set("angle", e), n) {
      const { x: o, y: a } = this.translateToOriginPoint(this.getRelativeCenterPoint(), s, i);
      this.left = o, this.top = a, this.originX = s, this.originY = i;
    }
  }
  setOnGroup() {
  }
  _setupCompositeOperation(e) {
    this.globalCompositeOperation && (e.globalCompositeOperation = this.globalCompositeOperation);
  }
  dispose() {
    Ao.cancelByTarget(this), this.off(), this._set("canvas", void 0), this._cacheCanvas && Fn().dispose(this._cacheCanvas), this._cacheCanvas = void 0, this._cacheContext = null;
  }
  animate(e, n) {
    return Object.entries(e).reduce((s, i) => {
      let [o, a] = i;
      return s[o] = this._animate(o, a, n), s;
    }, {});
  }
  _animate(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = e.split("."), o = this.constructor.colorProperties.includes(i[i.length - 1]), { abort: a, startValue: l, onChange: c, onComplete: u } = s, h = st(st({}, s), {}, { target: this, startValue: l ?? i.reduce((f, m) => f[m], this), endValue: n, abort: a == null ? void 0 : a.bind(this), onChange: (f, m, p) => {
      i.reduce((y, v, _) => (_ === i.length - 1 && (y[v] = f), y[v]), this), c && c(f, m, p);
    }, onComplete: (f, m, p) => {
      this.setCoords(), u && u(f, m, p);
    } });
    return o ? IC(h) : Pd(h);
  }
  isDescendantOf(e) {
    const { parent: n, group: s } = this;
    return n === e || s === e || !!n && n.isDescendantOf(e) || !!s && s !== n && s.isDescendantOf(e);
  }
  getAncestors() {
    const e = [];
    let n = this;
    do
      n = n.parent, n && e.push(n);
    while (n);
    return e;
  }
  findCommonAncestors(e) {
    if (this === e) return { fork: [], otherFork: [], common: [this, ...this.getAncestors()] };
    const n = this.getAncestors(), s = e.getAncestors();
    if (n.length === 0 && s.length > 0 && this === s[s.length - 1]) return { fork: [], otherFork: [e, ...s.slice(0, s.length - 1)], common: [this] };
    for (let i, o = 0; o < n.length; o++) {
      if (i = n[o], i === e) return { fork: [this, ...n.slice(0, o)], otherFork: [], common: n.slice(o) };
      for (let a = 0; a < s.length; a++) {
        if (this === s[a]) return { fork: [], otherFork: [e, ...s.slice(0, a)], common: [this, ...n] };
        if (i === s[a]) return { fork: [this, ...n.slice(0, o)], otherFork: [e, ...s.slice(0, a)], common: n.slice(o) };
      }
    }
    return { fork: [this, ...n], otherFork: [e, ...s], common: [] };
  }
  hasCommonAncestors(e) {
    const n = this.findCommonAncestors(e);
    return n && !!n.common.length;
  }
  isInFrontOf(e) {
    if (this === e) return;
    const n = this.findCommonAncestors(e);
    if (n.fork.includes(e)) return !0;
    if (n.otherFork.includes(this)) return !1;
    const s = n.common[0] || this.canvas;
    if (!s) return;
    const i = n.fork.pop(), o = n.otherFork.pop(), a = s._objects.indexOf(i), l = s._objects.indexOf(o);
    return a > -1 && a > l;
  }
  toObject() {
    const e = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).concat(vo.customProperties, this.constructor.customProperties || []);
    let n;
    const s = Gt.NUM_FRACTION_DIGITS, { clipPath: i, fill: o, stroke: a, shadow: l, strokeDashArray: c, left: u, top: h, originX: f, originY: m, width: p, height: y, strokeWidth: v, strokeLineCap: _, strokeDashOffset: g, strokeLineJoin: C, strokeUniform: x, strokeMiterLimit: k, scaleX: w, scaleY: T, angle: P, flipX: z, flipY: j, opacity: ot, visible: vt, backgroundColor: L, fillRule: Y, paintFirst: M, globalCompositeOperation: I, skewX: tt, skewY: U } = this;
    i && !i.excludeFromExport && (n = i.toObject(e.concat("inverted", "absolutePositioned")));
    const W = (yt) => le(yt, s), Z = st(st({}, Oi(this, e)), {}, { type: this.constructor.type, version: al, originX: f, originY: m, left: W(u), top: W(h), width: W(p), height: W(y), fill: Gc(o) ? o.toObject() : o, stroke: Gc(a) ? a.toObject() : a, strokeWidth: W(v), strokeDashArray: c && c.concat(), strokeLineCap: _, strokeDashOffset: g, strokeLineJoin: C, strokeUniform: x, strokeMiterLimit: W(k), scaleX: W(w), scaleY: W(T), angle: W(P), flipX: z, flipY: j, opacity: W(ot), shadow: l && l.toObject(), visible: vt, backgroundColor: L, fillRule: Y, paintFirst: M, globalCompositeOperation: I, skewX: W(tt), skewY: W(U) }, n ? { clipPath: n } : null);
    return this.includeDefaultValues ? Z : this._removeDefaultValues(Z);
  }
  toDatalessObject(e) {
    return this.toObject(e);
  }
  _removeDefaultValues(e) {
    const n = this.constructor.getDefaults(), s = Object.keys(n).length > 0 ? n : Object.getPrototypeOf(this);
    return Xl(e, (i, o) => {
      if (o === Jt || o === Xe || o === "type") return !0;
      const a = s[o];
      return i !== a && !(Array.isArray(i) && Array.isArray(a) && i.length === 0 && a.length === 0);
    });
  }
  toString() {
    return "#<".concat(this.constructor.type, ">");
  }
  static _fromObject(e) {
    let n = ue(e, RC), s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { extraParam: i } = s, o = ue(s, zC);
    return la(n, o).then((a) => i ? (delete a[i], new this(n[i], a)) : new this(a));
  }
  static fromObject(e, n) {
    return this._fromObject(e, n);
  }
};
nt(jn, "stateProperties", SC), nt(jn, "cacheProperties", ls), nt(jn, "ownDefaults", CC), nt(jn, "type", "FabricObject"), nt(jn, "colorProperties", [Te, Ye, "backgroundColor"]), nt(jn, "customProperties", []), Et.setClass(jn), Et.setClass(jn, "object");
const Ei = (r, e, n) => (s, i, o, a) => {
  const l = e(s, i, o, a);
  return l && yd(r, st(st({}, _d(s, i, o, a)), n)), l;
};
function Pi(r) {
  return (e, n, s, i) => {
    const { target: o, originX: a, originY: l } = n, c = o.getRelativeCenterPoint(), u = o.translateToOriginPoint(c, a, l), h = r(e, n, s, i);
    return o.setPositionByOrigin(u, n.originX, n.originY), h;
  };
}
const cu = Ei(ur, Pi((r, e, n, s) => {
  const i = Yl(e, e.originX, e.originY, n, s);
  if (Se(e.originX) === Se(Ut) || Se(e.originX) === Se(be) && i.x < 0 || Se(e.originX) === Se(Jt) && i.x > 0) {
    const { target: o } = e, a = o.strokeWidth / (o.strokeUniform ? o.scaleX : 1), l = bd(e) ? 2 : 1, c = o.width, u = Math.abs(i.x * l / o.scaleX) - a;
    return o.set("width", Math.max(u, 1)), c !== o.width;
  }
  return !1;
}));
function jC(r, e, n, s, i) {
  s = s || {};
  const o = this.sizeX || s.cornerSize || i.cornerSize, a = this.sizeY || s.cornerSize || i.cornerSize, l = s.transparentCorners !== void 0 ? s.transparentCorners : i.transparentCorners, c = l ? Ye : Te, u = !l && (s.cornerStrokeColor || i.cornerStrokeColor);
  let h, f = e, m = n;
  r.save(), r.fillStyle = s.cornerColor || i.cornerColor || "", r.strokeStyle = s.cornerStrokeColor || i.cornerStrokeColor || "", o > a ? (h = o, r.scale(1, a / o), m = n * o / a) : a > o ? (h = a, r.scale(o / a, 1), f = e * a / o) : h = o, r.beginPath(), r.arc(f, m, h / 2, 0, Eo, !1), r[c](), u && r.stroke(), r.restore();
}
function BC(r, e, n, s, i) {
  s = s || {};
  const o = this.sizeX || s.cornerSize || i.cornerSize, a = this.sizeY || s.cornerSize || i.cornerSize, l = s.transparentCorners !== void 0 ? s.transparentCorners : i.transparentCorners, c = l ? Ye : Te, u = !l && (s.cornerStrokeColor || i.cornerStrokeColor), h = o / 2, f = a / 2;
  r.save(), r.fillStyle = s.cornerColor || i.cornerColor || "", r.strokeStyle = s.cornerStrokeColor || i.cornerStrokeColor || "", r.translate(e, n);
  const m = i.getTotalAngle();
  r.rotate(_e(m)), r["".concat(c, "Rect")](-h, -f, o, a), u && r.strokeRect(-h, -f, o, a), r.restore();
}
class hn {
  constructor(e) {
    nt(this, "visible", !0), nt(this, "actionName", oa), nt(this, "angle", 0), nt(this, "x", 0), nt(this, "y", 0), nt(this, "offsetX", 0), nt(this, "offsetY", 0), nt(this, "sizeX", 0), nt(this, "sizeY", 0), nt(this, "touchSizeX", 0), nt(this, "touchSizeY", 0), nt(this, "cursorStyle", "crosshair"), nt(this, "withConnection", !1), Object.assign(this, e);
  }
  shouldActivate(e, n, s, i) {
    var o;
    let { tl: a, tr: l, br: c, bl: u } = i;
    return ((o = n.canvas) === null || o === void 0 ? void 0 : o.getActiveObject()) === n && n.isControlVisible(e) && fe.isPointInPolygon(s, [a, l, c, u]);
  }
  getActionHandler(e, n, s) {
    return this.actionHandler;
  }
  getMouseDownHandler(e, n, s) {
    return this.mouseDownHandler;
  }
  getMouseUpHandler(e, n, s) {
    return this.mouseUpHandler;
  }
  cursorStyleHandler(e, n, s) {
    return n.cursorStyle;
  }
  getActionName(e, n, s) {
    return n.actionName;
  }
  getVisibility(e, n) {
    var s, i;
    return (s = (i = e._controlsVisibility) === null || i === void 0 ? void 0 : i[n]) !== null && s !== void 0 ? s : this.visible;
  }
  setVisibility(e, n, s) {
    this.visible = e;
  }
  positionHandler(e, n, s, i) {
    return new mt(this.x * e.x + this.offsetX, this.y * e.y + this.offsetY).transform(n);
  }
  calcCornerCoords(e, n, s, i, o, a) {
    const l = Ul([xr(s, i), Mi({ angle: e }), Hl((o ? this.touchSizeX : this.sizeX) || n, (o ? this.touchSizeY : this.sizeY) || n)]);
    return { tl: new mt(-0.5, -0.5).transform(l), tr: new mt(0.5, -0.5).transform(l), br: new mt(0.5, 0.5).transform(l), bl: new mt(-0.5, 0.5).transform(l) };
  }
  render(e, n, s, i, o) {
    ((i = i || {}).cornerStyle || o.cornerStyle) === "circle" ? jC.call(this, e, n, s, i, o) : BC.call(this, e, n, s, i, o);
  }
}
const VC = (r, e, n) => n.lockRotation ? Lo : e.cursorStyle, $C = Ei(sd, Pi((r, e, n, s) => {
  let { target: i, ex: o, ey: a, theta: l, originX: c, originY: u } = e;
  const h = i.translateToOriginPoint(i.getRelativeCenterPoint(), c, u);
  if (bn(i, "lockRotation")) return !1;
  const f = Math.atan2(a - h.y, o - h.x), m = Math.atan2(s - h.y, n - h.x);
  let p = os(m - f + l);
  if (i.snapAngle && i.snapAngle > 0) {
    const v = i.snapAngle, _ = i.snapThreshold || v, g = Math.ceil(p / v) * v, C = Math.floor(p / v) * v;
    Math.abs(p - C) < _ ? p = C : Math.abs(p - g) < _ && (p = g);
  }
  p < 0 && (p = 360 + p), p %= 360;
  const y = i.angle !== p;
  return i.angle = p, y;
}));
function Dd(r, e) {
  const n = e.canvas, s = r[n.uniScaleKey];
  return n.uniformScaling && !s || !n.uniformScaling && s;
}
function Ad(r, e, n) {
  const s = bn(r, "lockScalingX"), i = bn(r, "lockScalingY");
  if (s && i || !e && (s || i) && n || s && e === "x" || i && e === "y") return !0;
  const { width: o, height: a, strokeWidth: l } = r;
  return o === 0 && l === 0 && e !== "y" || a === 0 && l === 0 && e !== "x";
}
const NC = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], Ui = (r, e, n) => {
  const s = Dd(r, n);
  if (Ad(n, e.x !== 0 && e.y === 0 ? "x" : e.x === 0 && e.y !== 0 ? "y" : "", s)) return Lo;
  const i = xd(n, e);
  return "".concat(NC[i], "-resize");
};
function Zl(r, e, n, s) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  const o = e.target, a = i.by, l = Dd(r, o);
  let c, u, h, f, m, p;
  if (Ad(o, a, l)) return !1;
  if (e.gestureScale) u = e.scaleX * e.gestureScale, h = e.scaleY * e.gestureScale;
  else {
    if (c = Yl(e, e.originX, e.originY, n, s), m = a !== "y" ? Math.sign(c.x || e.signX || 1) : 1, p = a !== "x" ? Math.sign(c.y || e.signY || 1) : 1, e.signX || (e.signX = m), e.signY || (e.signY = p), bn(o, "lockScalingFlip") && (e.signX !== m || e.signY !== p)) return !1;
    if (f = o._getTransformedDimensions(), l && !a) {
      const _ = Math.abs(c.x) + Math.abs(c.y), { original: g } = e, C = _ / (Math.abs(f.x * g.scaleX / o.scaleX) + Math.abs(f.y * g.scaleY / o.scaleY));
      u = g.scaleX * C, h = g.scaleY * C;
    } else u = Math.abs(c.x * o.scaleX / f.x), h = Math.abs(c.y * o.scaleY / f.y);
    bd(e) && (u *= 2, h *= 2), e.signX !== m && a !== "y" && (e.originX = Zc(e.originX), u *= -1, e.signX = m), e.signY !== p && a !== "x" && (e.originY = Zc(e.originY), h *= -1, e.signY = p);
  }
  const y = o.scaleX, v = o.scaleY;
  return a ? (a === "x" && o.set(Ke, u), a === "y" && o.set(an, h)) : (!bn(o, "lockScalingX") && o.set(Ke, u), !bn(o, "lockScalingY") && o.set(an, h)), y !== o.scaleX || v !== o.scaleY;
}
const Lr = Ei(ra, Pi((r, e, n, s) => Zl(r, e, n, s))), WC = Ei(ra, Pi((r, e, n, s) => Zl(r, e, n, s, { by: "x" }))), UC = Ei(ra, Pi((r, e, n, s) => Zl(r, e, n, s, { by: "y" }))), HC = ["target", "ex", "ey", "skewingSide"], ja = { x: { counterAxis: "y", scale: Ke, skew: ki, lockSkewing: "lockSkewingX", origin: "originX", flip: "flipX" }, y: { counterAxis: "x", scale: an, skew: Ti, lockSkewing: "lockSkewingY", origin: "originY", flip: "flipY" } }, XC = ["ns", "nesw", "ew", "nwse"], GC = (r, e, n) => {
  if (e.x !== 0 && bn(n, "lockSkewingY") || e.y !== 0 && bn(n, "lockSkewingX")) return Lo;
  const s = xd(n, e) % 4;
  return "".concat(XC[s], "-resize");
};
function Fd(r, e, n, s, i) {
  const { target: o } = n, { counterAxis: a, origin: l, lockSkewing: c, skew: u, flip: h } = ja[r];
  if (bn(o, c)) return !1;
  const { origin: f, flip: m } = ja[a], p = Se(n[f]) * (o[m] ? -1 : 1), y = -Math.sign(p) * (o[h] ? -1 : 1), v = 0.5 * -((o[u] === 0 && Yl(n, Ut, Ut, s, i)[r] > 0 || o[u] > 0 ? 1 : -1) * y) + 0.5;
  return Ei(id, Pi((g, C, x, k) => function(w, T, P) {
    let { target: z, ex: j, ey: ot, skewingSide: vt } = T, L = ue(T, HC);
    const { skew: Y } = ja[w], M = P.subtract(new mt(j, ot)).divide(new mt(z.scaleX, z.scaleY))[w], I = z[Y], tt = L[Y], U = Math.tan(_e(tt)), W = w === "y" ? z._getTransformedDimensions({ scaleX: 1, scaleY: 1, skewX: 0 }).x : z._getTransformedDimensions({ scaleX: 1, scaleY: 1 }).y, Z = 2 * M * vt / Math.max(W, 1) + U, yt = os(Math.atan(Z));
    z.set(Y, yt);
    const Q = I !== z[Y];
    if (Q && w === "y") {
      const { skewX: at, scaleX: _t } = z, ht = z._getTransformedDimensions({ skewY: I }), X = z._getTransformedDimensions(), kt = at !== 0 ? ht.x / X.x : 1;
      kt !== 1 && z.set(Ke, kt * _t);
    }
    return Q;
  }(r, C, new mt(x, k))))(e, st(st({}, n), {}, { [l]: v, skewingSide: y }), s, i);
}
const YC = (r, e, n, s) => Fd("x", r, e, n, s), KC = (r, e, n, s) => Fd("y", r, e, n, s);
function ha(r, e) {
  return r[e.canvas.altActionKey];
}
const Rr = (r, e, n) => {
  const s = ha(r, n);
  return e.x === 0 ? s ? ki : an : e.y === 0 ? s ? Ti : Ke : "";
}, ii = (r, e, n) => ha(r, n) ? GC(0, e, n) : Ui(r, e, n), uu = (r, e, n, s) => ha(r, e.target) ? KC(r, e, n, s) : WC(r, e, n, s), hu = (r, e, n, s) => ha(r, e.target) ? YC(r, e, n, s) : UC(r, e, n, s), Id = () => ({ ml: new hn({ x: -0.5, y: 0, cursorStyleHandler: ii, actionHandler: uu, getActionName: Rr }), mr: new hn({ x: 0.5, y: 0, cursorStyleHandler: ii, actionHandler: uu, getActionName: Rr }), mb: new hn({ x: 0, y: 0.5, cursorStyleHandler: ii, actionHandler: hu, getActionName: Rr }), mt: new hn({ x: 0, y: -0.5, cursorStyleHandler: ii, actionHandler: hu, getActionName: Rr }), tl: new hn({ x: -0.5, y: -0.5, cursorStyleHandler: Ui, actionHandler: Lr }), tr: new hn({ x: 0.5, y: -0.5, cursorStyleHandler: Ui, actionHandler: Lr }), bl: new hn({ x: -0.5, y: 0.5, cursorStyleHandler: Ui, actionHandler: Lr }), br: new hn({ x: 0.5, y: 0.5, cursorStyleHandler: Ui, actionHandler: Lr }), mtr: new hn({ x: 0, y: -0.5, actionHandler: $C, cursorStyleHandler: VC, offsetY: -40, withConnection: !0, actionName: Nl }) }), qC = () => ({ mr: new hn({ x: 0.5, y: 0, actionHandler: cu, cursorStyleHandler: ii, actionName: ur }), ml: new hn({ x: -0.5, y: 0, actionHandler: cu, cursorStyleHandler: ii, actionName: ur }) }), ZC = () => st(st({}, Id()), qC());
class pr extends jn {
  static getDefaults() {
    return st(st({}, super.getDefaults()), pr.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, this.constructor.createControls(), pr.ownDefaults), this.setOptions(e);
  }
  static createControls() {
    return { controls: Id() };
  }
  _updateCacheCanvas() {
    const e = this.canvas;
    if (this.noScaleCache && e && e._currentTransform) {
      const n = e._currentTransform, s = n.target, i = n.action;
      if (this === s && i && i.startsWith(oa)) return !1;
    }
    return super._updateCacheCanvas();
  }
  getActiveControl() {
    const e = this.__corner;
    return e ? { key: e, control: this.controls[e], coord: this.oCoords[e] } : void 0;
  }
  findControl(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    if (!this.hasControls || !this.canvas) return;
    this.__corner = void 0;
    const s = Object.entries(this.oCoords);
    for (let i = s.length - 1; i >= 0; i--) {
      const [o, a] = s[i], l = this.controls[o];
      if (l.shouldActivate(o, this, e, n ? a.touchCorner : a.corner)) return this.__corner = o, { key: o, control: l, coord: this.oCoords[o] };
    }
  }
  calcOCoords() {
    const e = this.getViewportTransform(), n = this.getCenterPoint(), s = xr(n.x, n.y), i = Mi({ angle: this.getTotalAngle() - (this.group && this.flipX ? 180 : 0) }), o = Pe(s, i), a = Pe(e, o), l = Pe(a, [1 / e[0], 0, 0, 1 / e[3], 0, 0]), c = this.group ? Fo(this.calcTransformMatrix()) : void 0;
    c && (c.scaleX = Math.abs(c.scaleX), c.scaleY = Math.abs(c.scaleY));
    const u = this._calculateCurrentDimensions(c), h = {};
    return this.forEachControl((f, m) => {
      const p = f.positionHandler(u, l, this, f);
      h[m] = Object.assign(p, this._calcCornerCoords(f, p));
    }), h;
  }
  _calcCornerCoords(e, n) {
    const s = this.getTotalAngle();
    return { corner: e.calcCornerCoords(s, this.cornerSize, n.x, n.y, !1, this), touchCorner: e.calcCornerCoords(s, this.touchCornerSize, n.x, n.y, !0, this) };
  }
  setCoords() {
    super.setCoords(), this.canvas && (this.oCoords = this.calcOCoords());
  }
  forEachControl(e) {
    for (const n in this.controls) e(this.controls[n], n, this);
  }
  drawSelectionBackground(e) {
    if (!this.selectionBackgroundColor || this.canvas && this.canvas._activeObject !== this) return;
    e.save();
    const n = this.getRelativeCenterPoint(), s = this._calculateCurrentDimensions(), i = this.getViewportTransform();
    e.translate(n.x, n.y), e.scale(1 / i[0], 1 / i[3]), e.rotate(_e(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-s.x / 2, -s.y / 2, s.x, s.y), e.restore();
  }
  strokeBorders(e, n) {
    e.strokeRect(-n.x / 2, -n.y / 2, n.x, n.y);
  }
  _drawBorders(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = st({ hasControls: this.hasControls, borderColor: this.borderColor, borderDashArray: this.borderDashArray }, s);
    e.save(), e.strokeStyle = i.borderColor, this._setLineDash(e, i.borderDashArray), this.strokeBorders(e, n), i.hasControls && this.drawControlsConnectingLines(e, n), e.restore();
  }
  _renderControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { hasBorders: s, hasControls: i } = this, o = st({ hasBorders: s, hasControls: i }, n), a = this.getViewportTransform(), l = o.hasBorders, c = o.hasControls, u = Pe(a, this.calcTransformMatrix()), h = Fo(u);
    e.save(), e.translate(h.translateX, h.translateY), e.lineWidth = this.borderScaleFactor, this.group === this.parent && (e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (h.angle -= 180), e.rotate(_e(this.group ? h.angle : this.angle)), l && this.drawBorders(e, h, n), c && this.drawControls(e, n), e.restore();
  }
  drawBorders(e, n, s) {
    let i;
    if (s && s.forActiveSelection || this.group) {
      const o = Gl(this.width, this.height, aa(n)), a = this.isStrokeAccountedForInDimensions() ? Wl : (this.strokeUniform ? new mt().scalarAdd(this.canvas ? this.canvas.getZoom() : 1) : new mt(n.scaleX, n.scaleY)).scalarMultiply(this.strokeWidth);
      i = o.add(a).scalarAdd(this.borderScaleFactor).scalarAdd(2 * this.padding);
    } else i = this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);
    this._drawBorders(e, i, s);
  }
  drawControlsConnectingLines(e, n) {
    let s = !1;
    e.beginPath(), this.forEachControl((i, o) => {
      i.withConnection && i.getVisibility(this, o) && (s = !0, e.moveTo(i.x * n.x, i.y * n.y), e.lineTo(i.x * n.x + i.offsetX, i.y * n.y + i.offsetY));
    }), s && e.stroke();
  }
  drawControls(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e.save();
    const s = this.getCanvasRetinaScaling(), { cornerStrokeColor: i, cornerDashArray: o, cornerColor: a } = this, l = st({ cornerStrokeColor: i, cornerDashArray: o, cornerColor: a }, n);
    e.setTransform(s, 0, 0, s, 0, 0), e.strokeStyle = e.fillStyle = l.cornerColor, this.transparentCorners || (e.strokeStyle = l.cornerStrokeColor), this._setLineDash(e, l.cornerDashArray), this.forEachControl((c, u) => {
      if (c.getVisibility(this, u)) {
        const h = this.oCoords[u];
        c.render(e, h.x, h.y, l, this);
      }
    }), e.restore();
  }
  isControlVisible(e) {
    return this.controls[e] && this.controls[e].getVisibility(this, e);
  }
  setControlVisible(e, n) {
    this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[e] = n;
  }
  setControlsVisibility() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Object.entries(e).forEach((n) => {
      let [s, i] = n;
      return this.setControlVisible(s, i);
    });
  }
  clearContextTop(e) {
    if (!this.canvas) return;
    const n = this.canvas.contextTop;
    if (!n) return;
    const s = this.canvas.viewportTransform;
    n.save(), n.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this.transform(n);
    const i = this.width + 4, o = this.height + 4;
    return n.clearRect(-i / 2, -o / 2, i, o), e || n.restore(), n;
  }
  onDeselect(e) {
    return !1;
  }
  onSelect(e) {
    return !1;
  }
  shouldStartDragging(e) {
    return !1;
  }
  onDragStart(e) {
    return !1;
  }
  canDrop(e) {
    return !1;
  }
  renderDragSourceEffect(e) {
  }
  renderDropTargetEffect(e) {
  }
}
function Ld(r, e) {
  return e.forEach((n) => {
    Object.getOwnPropertyNames(n.prototype).forEach((s) => {
      s !== "constructor" && Object.defineProperty(r.prototype, s, Object.getOwnPropertyDescriptor(n.prototype, s) || /* @__PURE__ */ Object.create(null));
    });
  }), r;
}
nt(pr, "ownDefaults", { noScaleCache: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, cornerColor: "rgb(178,204,255)", cornerStrokeColor: "", cornerStyle: "rect", cornerDashArray: null, hasControls: !0, borderColor: "rgb(178,204,255)", borderDashArray: null, borderOpacityWhenMoving: 0.4, borderScaleFactor: 1, hasBorders: !0, selectionBackgroundColor: "", selectable: !0, evented: !0, perPixelTargetFind: !1, activeOn: "down", hoverCursor: null, moveCursor: null });
class Ie extends pr {
}
Ld(Ie, [wd]), Et.setClass(Ie), Et.setClass(Ie, "object");
const JC = (r, e, n, s) => {
  const i = 2 * (s = Math.round(s)) + 1, { data: o } = r.getImageData(e - s, n - s, i, i);
  for (let a = 3; a < o.length; a += 4)
    if (o[a] > 0) return !1;
  return !0;
};
class Rd {
  constructor(e) {
    this.options = e, this.strokeProjectionMagnitude = this.options.strokeWidth / 2, this.scale = new mt(this.options.scaleX, this.options.scaleY), this.strokeUniformScalar = this.options.strokeUniform ? new mt(1 / this.options.scaleX, 1 / this.options.scaleY) : new mt(1, 1);
  }
  createSideVector(e, n) {
    const s = hl(e, n);
    return this.options.strokeUniform ? s.multiply(this.scale) : s;
  }
  projectOrthogonally(e, n, s) {
    return this.applySkew(e.add(this.calcOrthogonalProjection(e, n, s)));
  }
  isSkewed() {
    return this.options.skewX !== 0 || this.options.skewY !== 0;
  }
  applySkew(e) {
    const n = new mt(e);
    return n.y += n.x * Math.tan(_e(this.options.skewY)), n.x += n.y * Math.tan(_e(this.options.skewX)), n;
  }
  scaleUnitVector(e, n) {
    return e.multiply(this.strokeUniformScalar).scalarMultiply(n);
  }
}
const QC = new mt();
class mi extends Rd {
  static getOrthogonalRotationFactor(e, n) {
    const s = n ? fl(e, n) : xC(e);
    return Math.abs(s) < _r ? -1 : 1;
  }
  constructor(e, n, s, i) {
    super(i), nt(this, "AB", void 0), nt(this, "AC", void 0), nt(this, "alpha", void 0), nt(this, "bisector", void 0), this.A = new mt(e), this.B = new mt(n), this.C = new mt(s), this.AB = this.createSideVector(this.A, this.B), this.AC = this.createSideVector(this.A, this.C), this.alpha = fl(this.AB, this.AC), this.bisector = Kl(Od(this.AB.eq(QC) ? this.AC : this.AB, this.alpha / 2));
  }
  calcOrthogonalProjection(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const i = this.createSideVector(e, n), o = Ed(i), a = mi.getOrthogonalRotationFactor(o, this.bisector);
    return this.scaleUnitVector(o, s * a);
  }
  projectBevel() {
    const e = [];
    return (this.alpha % Eo == 0 ? [this.B] : [this.B, this.C]).forEach((n) => {
      e.push(this.projectOrthogonally(this.A, n)), e.push(this.projectOrthogonally(this.A, n, -this.strokeProjectionMagnitude));
    }), e;
  }
  projectMiter() {
    const e = [], n = Math.abs(this.alpha), s = 1 / Math.sin(n / 2), i = this.scaleUnitVector(this.bisector, -this.strokeProjectionMagnitude * s), o = this.options.strokeUniform ? dl(this.scaleUnitVector(this.bisector, this.options.strokeMiterLimit)) : this.options.strokeMiterLimit;
    return dl(i) / this.strokeProjectionMagnitude <= o && e.push(this.applySkew(this.A.add(i))), e.push(...this.projectBevel()), e;
  }
  projectRoundNoSkew(e, n) {
    const s = [], i = new mt(mi.getOrthogonalRotationFactor(this.bisector), mi.getOrthogonalRotationFactor(new mt(this.bisector.y, this.bisector.x)));
    return [new mt(1, 0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i), new mt(0, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(i)].forEach((o) => {
      ou(o, e, n) && s.push(this.A.add(o));
    }), s;
  }
  projectRoundWithSkew(e, n) {
    const s = [], { skewX: i, skewY: o, scaleX: a, scaleY: l, strokeUniform: c } = this.options, u = new mt(Math.tan(_e(i)), Math.tan(_e(o))), h = this.strokeProjectionMagnitude, f = c ? h / l / Math.sqrt(1 / l ** 2 + 1 / a ** 2 * u.y ** 2) : h / Math.sqrt(1 + u.y ** 2), m = new mt(Math.sqrt(Math.max(h ** 2 - f ** 2, 0)), f), p = c ? h / Math.sqrt(1 + u.x ** 2 * (1 / l) ** 2 / (1 / a + 1 / a * u.x * u.y) ** 2) : h / Math.sqrt(1 + u.x ** 2 / (1 + u.x * u.y) ** 2), y = new mt(p, Math.sqrt(Math.max(h ** 2 - p ** 2, 0)));
    return [y, y.scalarMultiply(-1), m, m.scalarMultiply(-1)].map((v) => this.applySkew(c ? v.multiply(this.strokeUniformScalar) : v)).forEach((v) => {
      ou(v, e, n) && s.push(this.applySkew(this.A).add(v));
    }), s;
  }
  projectRound() {
    const e = [];
    e.push(...this.projectBevel());
    const n = this.alpha % Eo == 0, s = this.applySkew(this.A), i = e[n ? 0 : 2].subtract(s), o = e[n ? 1 : 0].subtract(s), a = n ? this.applySkew(this.AB.scalarMultiply(-1)) : this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)), l = er(i, a) > 0, c = l ? i : o, u = l ? o : i;
    return this.isSkewed() ? e.push(...this.projectRoundWithSkew(c, u)) : e.push(...this.projectRoundNoSkew(c, u)), e;
  }
  projectPoints() {
    switch (this.options.strokeLineJoin) {
      case "miter":
        return this.projectMiter();
      case "round":
        return this.projectRound();
      default:
        return this.projectBevel();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e, angle: this.alpha, bisector: this.bisector }));
  }
}
class du extends Rd {
  constructor(e, n, s) {
    super(s), this.A = new mt(e), this.T = new mt(n);
  }
  calcOrthogonalProjection(e, n) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.strokeProjectionMagnitude;
    const i = this.createSideVector(e, n);
    return this.scaleUnitVector(Ed(i), s);
  }
  projectButt() {
    return [this.projectOrthogonally(this.A, this.T, this.strokeProjectionMagnitude), this.projectOrthogonally(this.A, this.T, -this.strokeProjectionMagnitude)];
  }
  projectRound() {
    const e = [];
    if (!this.isSkewed() && this.A.eq(this.T)) {
      const n = new mt(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.applySkew(this.A.add(n)), this.applySkew(this.A.subtract(n)));
    } else e.push(...new mi(this.A, this.T, this.T, this.options).projectRound());
    return e;
  }
  projectSquare() {
    const e = [];
    if (this.A.eq(this.T)) {
      const n = new mt(1, 1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);
      e.push(this.A.add(n), this.A.subtract(n));
    } else {
      const n = this.calcOrthogonalProjection(this.A, this.T, this.strokeProjectionMagnitude), s = this.scaleUnitVector(Kl(this.createSideVector(this.A, this.T)), -this.strokeProjectionMagnitude), i = this.A.add(s);
      e.push(i.add(n), i.subtract(n));
    }
    return e.map((n) => this.applySkew(n));
  }
  projectPoints() {
    switch (this.options.strokeLineCap) {
      case "round":
        return this.projectRound();
      case "square":
        return this.projectSquare();
      default:
        return this.projectButt();
    }
  }
  project() {
    return this.projectPoints().map((e) => ({ originPoint: this.A, projectedPoint: e }));
  }
}
const tk = function(r, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  const s = [];
  if (r.length === 0) return s;
  const i = r.reduce((o, a) => (o[o.length - 1].eq(a) || o.push(new mt(a)), o), [new mt(r[0])]);
  if (i.length === 1) n = !0;
  else if (!n) {
    const o = i[0], a = ((l, c) => {
      for (let u = l.length - 1; u >= 0; u--) if (c(l[u], u, l)) return u;
      return -1;
    })(i, (l) => !l.eq(o));
    i.splice(a + 1);
  }
  return i.forEach((o, a, l) => {
    let c, u;
    a === 0 ? (u = l[1], c = n ? o : l[l.length - 1]) : a === l.length - 1 ? (c = l[a - 1], u = n ? o : l[0]) : (c = l[a - 1], u = l[a + 1]), n && l.length === 1 ? s.push(...new du(o, o, e).project()) : !n || a !== 0 && a !== l.length - 1 ? s.push(...new mi(o, c, u, e).project()) : s.push(...new du(o, a === 0 ? u : c, e).project());
  }), s;
}, Jl = (r) => {
  const e = {};
  return Object.keys(r).forEach((n) => {
    e[n] = {}, Object.keys(r[n]).forEach((s) => {
      e[n][s] = st({}, r[n][s]);
    });
  }), e;
}, ek = (r) => r.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
let Li;
const Ql = (r) => {
  if (Li || Li || (Li = "Intl" in ia() && "Segmenter" in Intl && new Intl.Segmenter(void 0, { granularity: "grapheme" })), Li) {
    const e = Li.segment(r);
    return Array.from(e).map((n) => {
      let { segment: s } = n;
      return s;
    });
  }
  return nk(r);
}, nk = (r) => {
  const e = [];
  for (let n, s = 0; s < r.length; s++) (n = sk(r, s)) !== !1 && e.push(n);
  return e;
}, sk = (r, e) => {
  const n = r.charCodeAt(e);
  if (isNaN(n)) return "";
  if (n < 55296 || n > 57343) return r.charAt(e);
  if (55296 <= n && n <= 56319) {
    if (r.length <= e + 1) throw "High surrogate without following low surrogate";
    const i = r.charCodeAt(e + 1);
    if (56320 > i || i > 57343) throw "High surrogate without following low surrogate";
    return r.charAt(e) + r.charAt(e + 1);
  }
  if (e === 0) throw "Low surrogate without preceding high surrogate";
  const s = r.charCodeAt(e - 1);
  if (55296 > s || s > 56319) throw "Low surrogate without preceding high surrogate";
  return !1;
}, tc = function(r, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
  return r.fill !== e.fill || r.stroke !== e.stroke || r.strokeWidth !== e.strokeWidth || r.fontSize !== e.fontSize || r.fontFamily !== e.fontFamily || r.fontWeight !== e.fontWeight || r.fontStyle !== e.fontStyle || r.textDecorationThickness !== e.textDecorationThickness || r.textBackgroundColor !== e.textBackgroundColor || r.deltaY !== e.deltaY || n && (r.overline !== e.overline || r.underline !== e.underline || r.linethrough !== e.linethrough);
}, ik = (r, e) => {
  const n = e.split(`
`), s = [];
  let i = -1, o = {};
  r = Jl(r);
  for (let a = 0; a < n.length; a++) {
    const l = Ql(n[a]);
    if (r[a]) for (let c = 0; c < l.length; c++) {
      i++;
      const u = r[a][c];
      u && Object.keys(u).length > 0 && (tc(o, u, !0) ? s.push({ start: i, end: i + 1, style: u }) : s[s.length - 1].end++), o = u || {};
    }
    else i += l.length, o = {};
  }
  return s;
}, rk = (r, e) => {
  if (!Array.isArray(r)) return Jl(r);
  const n = e.split($l), s = {};
  let i = -1, o = 0;
  for (let a = 0; a < n.length; a++) {
    const l = Ql(n[a]);
    for (let c = 0; c < l.length; c++) i++, r[o] && r[o].start <= i && i < r[o].end && (s[a] = s[a] || {}, s[a][c] = st({}, r[o].style), i === r[o].end - 1 && o++);
  }
  return s;
}, Ts = ["display", "transform", Te, "fill-opacity", "fill-rule", "opacity", Ye, "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"];
function fu(r, e) {
  const n = r.nodeName, s = r.getAttribute("class"), i = r.getAttribute("id"), o = "(?![a-zA-Z\\-]+)";
  let a;
  if (a = new RegExp("^" + n, "i"), e = e.replace(a, ""), i && e.length && (a = new RegExp("#" + i + o, "i"), e = e.replace(a, "")), s && e.length) {
    const l = s.split(" ");
    for (let c = l.length; c--; ) a = new RegExp("\\." + l[c] + o, "i"), e = e.replace(a, "");
  }
  return e.length === 0;
}
function ok(r, e) {
  let n = !0;
  const s = fu(r, e.pop());
  return s && e.length && (n = function(i, o) {
    let a, l = !0;
    for (; i.parentElement && i.parentElement.nodeType === 1 && o.length; ) l && (a = o.pop()), l = fu(i = i.parentElement, a);
    return o.length === 0;
  }(r, e)), s && n && e.length === 0;
}
const ak = (r) => {
  var e;
  return (e = bC[r]) !== null && e !== void 0 ? e : r;
}, lk = new RegExp("(".concat(vn, ")"), "gi"), ck = (r) => Ro(r.replace(lk, " $1 ").replace(/,/gi, " "));
var pu, mu, gu, vu, yu, bu, _u;
const Ve = "(".concat(vn, ")"), uk = String.raw(pu || (pu = In(["(skewX)(", ")"], ["(skewX)\\(", "\\)"])), Ve), hk = String.raw(mu || (mu = In(["(skewY)(", ")"], ["(skewY)\\(", "\\)"])), Ve), dk = String.raw(gu || (gu = In(["(rotate)(", "(?: ", " ", ")?)"], ["(rotate)\\(", "(?: ", " ", ")?\\)"])), Ve, Ve, Ve), fk = String.raw(vu || (vu = In(["(scale)(", "(?: ", ")?)"], ["(scale)\\(", "(?: ", ")?\\)"])), Ve, Ve), pk = String.raw(yu || (yu = In(["(translate)(", "(?: ", ")?)"], ["(translate)\\(", "(?: ", ")?\\)"])), Ve, Ve), mk = String.raw(bu || (bu = In(["(matrix)(", " ", " ", " ", " ", " ", ")"], ["(matrix)\\(", " ", " ", " ", " ", " ", "\\)"])), Ve, Ve, Ve, Ve, Ve, Ve), ec = "(?:".concat(mk, "|").concat(pk, "|").concat(dk, "|").concat(fk, "|").concat(uk, "|").concat(hk, ")"), gk = "(?:".concat(ec, "*)"), vk = String.raw(_u || (_u = In(["^s*(?:", "?)s*$"], ["^\\s*(?:", "?)\\s*$"])), gk), yk = new RegExp(vk), bk = new RegExp(ec), _k = new RegExp(ec, "g");
function pl(r) {
  const e = [];
  if (!(r = ck(r).replace(/\s*([()])\s*/gi, "$1")) || r && !yk.test(r)) return [...$e];
  for (const n of r.matchAll(_k)) {
    const s = bk.exec(n[0]);
    if (!s) continue;
    let i = $e;
    const o = s.filter((y) => !!y), [, a, ...l] = o, [c, u, h, f, m, p] = l.map((y) => parseFloat(y));
    switch (a) {
      case "translate":
        i = xr(c, u);
        break;
      case Nl:
        i = Mi({ angle: c }, { x: u, y: h });
        break;
      case oa:
        i = Hl(c, u);
        break;
      case ki:
        i = hd(c);
        break;
      case Ti:
        i = dd(c);
        break;
      case "matrix":
        i = [c, u, h, f, m, p];
    }
    e.push(i);
  }
  return Ul(e);
}
function xk(r, e, n, s) {
  const i = Array.isArray(e);
  let o, a = e;
  if (r !== Te && r !== Ye || e !== Ge) {
    if (r === "strokeUniform") return e === "non-scaling-stroke";
    if (r === "strokeDashArray") a = e === Ge ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat);
    else if (r === "transformMatrix") a = n && n.transformMatrix ? Pe(n.transformMatrix, pl(e)) : pl(e);
    else if (r === "visible") a = e !== Ge && e !== "hidden", n && n.visible === !1 && (a = !1);
    else if (r === "opacity") a = parseFloat(e), n && n.opacity !== void 0 && (a *= n.opacity);
    else if (r === "textAnchor") a = e === "start" ? Jt : e === "end" ? be : Ut;
    else if (r === "charSpacing" || r === Hs) o = pi(e, s) / s * 1e3;
    else if (r === "paintFirst") {
      const l = e.indexOf(Te), c = e.indexOf(Ye);
      a = Te, (l > -1 && c > -1 && c < l || l === -1 && c > -1) && (a = Ye);
    } else {
      if (r === "href" || r === "xlink:href" || r === "font" || r === "id") return e;
      if (r === "imageSmoothing") return e === "optimizeQuality";
      o = i ? e.map(pi) : pi(e, s);
    }
  } else a = "";
  return !i && isNaN(o) ? a : o;
}
function wk(r, e) {
  const n = r.match(yC);
  if (!n) return;
  const s = n[1], i = n[3], o = n[4], a = n[5], l = n[6];
  s && (e.fontStyle = s), i && (e.fontWeight = isNaN(parseFloat(i)) ? i : parseFloat(i)), o && (e.fontSize = pi(o)), l && (e.fontFamily = l), a && (e.lineHeight = a === "normal" ? 1 : a);
}
function Sk(r, e) {
  r.replace(/;\s*$/, "").split(";").forEach((n) => {
    if (!n) return;
    const [s, i] = n.split(":");
    e[s.trim().toLowerCase()] = i.trim();
  });
}
function Ck(r) {
  const e = {}, n = r.getAttribute("style");
  return n && (typeof n == "string" ? Sk(n, e) : function(s, i) {
    Object.entries(s).forEach((o) => {
      let [a, l] = o;
      l !== void 0 && (i[a.toLowerCase()] = l);
    });
  }(n, e)), e;
}
const kk = { stroke: "strokeOpacity", fill: "fillOpacity" };
function cs(r, e, n) {
  if (!r) return {};
  let s, i = {}, o = Vl;
  r.parentNode && ru.test(r.parentNode.nodeName) && (i = cs(r.parentElement, e, n), i.fontSize && (s = o = pi(i.fontSize)));
  const a = st(st(st({}, e.reduce((u, h) => {
    const f = r.getAttribute(h);
    return f && (u[h] = f), u;
  }, {})), function(u) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, f = {};
    for (const m in h) ok(u, m.split(" ")) && (f = st(st({}, f), h[m]));
    return f;
  }(r, n)), Ck(r));
  a[Ra] && r.setAttribute(Ra, a[Ra]), a[La] && (s = pi(a[La], o), a[La] = "".concat(s));
  const l = {};
  for (const u in a) {
    const h = ak(u), f = xk(h, a[u], i, s);
    l[h] = f;
  }
  l && l.font && wk(l.font, l);
  const c = st(st({}, i), l);
  return ru.test(r.nodeName) ? c : function(u) {
    const h = Ie.getDefaults();
    return Object.entries(kk).forEach((f) => {
      let [m, p] = f;
      if (u[p] === void 0 || u[m] === "") return;
      if (u[m] === void 0) {
        if (!h[m]) return;
        u[m] = h[m];
      }
      if (u[m].indexOf("url(") === 0) return;
      const y = new ee(u[m]);
      u[m] = y.setAlpha(le(y.getAlpha() * u[p], 2)).toRgba();
    }), u;
  }(c);
}
const Tk = ["left", "top", "width", "height", "visible"], zd = ["rx", "ry"];
class On extends Ie {
  static getDefaults() {
    return st(st({}, super.getDefaults()), On.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, On.ownDefaults), this.setOptions(e), this._initRxRy();
  }
  _initRxRy() {
    const { rx: e, ry: n } = this;
    e && !n ? this.ry = e : n && !e && (this.rx = n);
  }
  _render(e) {
    const { width: n, height: s } = this, i = -n / 2, o = -s / 2, a = this.rx ? Math.min(this.rx, n / 2) : 0, l = this.ry ? Math.min(this.ry, s / 2) : 0, c = a !== 0 || l !== 0;
    e.beginPath(), e.moveTo(i + a, o), e.lineTo(i + n - a, o), c && e.bezierCurveTo(i + n - us * a, o, i + n, o + us * l, i + n, o + l), e.lineTo(i + n, o + s - l), c && e.bezierCurveTo(i + n, o + s - us * l, i + n - us * a, o + s, i + n - a, o + s), e.lineTo(i + a, o + s), c && e.bezierCurveTo(i + us * a, o + s, i, o + s - us * l, i, o + s - l), e.lineTo(i, o + l), c && e.bezierCurveTo(i, o + us * l, i + us * a, o, i + a, o), e.closePath(), this._renderPaintInOrder(e);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...zd, ...e]);
  }
  _toSVG() {
    const { width: e, height: n, rx: s, ry: i } = this;
    return ["<rect ", "COMMON_PARTS", 'x="'.concat(-e / 2, '" y="').concat(-n / 2, '" rx="').concat(s, '" ry="').concat(i, '" width="').concat(e, '" height="').concat(n, `" />
`)];
  }
  static async fromElement(e, n, s) {
    const i = cs(e, this.ATTRIBUTE_NAMES, s), { left: o = 0, top: a = 0, width: l = 0, height: c = 0, visible: u = !0 } = i, h = ue(i, Tk);
    return new this(st(st(st({}, n), h), {}, { left: o, top: a, width: l, height: c, visible: !!(u && l && c) }));
  }
}
nt(On, "type", "Rect"), nt(On, "cacheProperties", [...ls, ...zd]), nt(On, "ownDefaults", { rx: 0, ry: 0 }), nt(On, "ATTRIBUTE_NAMES", [...Ts, "x", "y", "rx", "ry", "width", "height"]), Et.setClass(On), Et.setSVGClass(On);
const Hn = "initialization", jo = "added", nc = "removed", Bo = "imperative", jd = (r, e) => {
  const { strokeUniform: n, strokeWidth: s, width: i, height: o, group: a } = e, l = a && a !== r ? ca(a.calcTransformMatrix(), r.calcTransformMatrix()) : null, c = l ? e.getRelativeCenterPoint().transform(l) : e.getRelativeCenterPoint(), u = !e.isStrokeAccountedForInDimensions(), h = n && u ? hC(new mt(s, s), void 0, r.calcTransformMatrix()) : Wl, f = !n && u ? s : 0, m = Gl(i + f, o + f, Ul([l, e.calcOwnMatrix()], !0)).add(h).scalarDivide(2);
  return [c.subtract(m), c.add(m)];
};
class da {
  calcLayoutResult(e, n) {
    if (this.shouldPerformLayout(e)) return this.calcBoundingBox(n, e);
  }
  shouldPerformLayout(e) {
    let { type: n, prevStrategy: s, strategy: i } = e;
    return n === Hn || n === Bo || !!s && i !== s;
  }
  shouldLayoutClipPath(e) {
    let { type: n, target: { clipPath: s } } = e;
    return n !== Hn && s && !s.absolutePositioned;
  }
  getInitialSize(e, n) {
    return n.size;
  }
  calcBoundingBox(e, n) {
    const { type: s, target: i } = n;
    if (s === Bo && n.overrides) return n.overrides;
    if (e.length === 0) return;
    const { left: o, top: a, width: l, height: c } = Zn(e.map((f) => jd(i, f)).reduce((f, m) => f.concat(m), [])), u = new mt(l, c), h = new mt(o, a).add(u.scalarDivide(2));
    if (s === Hn) {
      const f = this.getInitialSize(n, { size: u, center: h });
      return { center: h, relativeCorrection: new mt(0, 0), size: f };
    }
    return { center: h.transform(i.calcOwnMatrix()), size: u };
  }
}
nt(da, "type", "strategy");
class ml extends da {
  shouldPerformLayout(e) {
    return !0;
  }
}
nt(ml, "type", "fit-content"), Et.setClass(ml);
const Mk = ["strategy"], Ok = ["target", "strategy", "bubbles", "prevStrategy"], Bd = "layoutManager";
class mr {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new ml();
    nt(this, "strategy", void 0), this.strategy = e, this._subscriptions = /* @__PURE__ */ new Map();
  }
  performLayout(e) {
    const n = st(st({ bubbles: !0, strategy: this.strategy }, e), {}, { prevStrategy: this._prevLayoutStrategy, stopPropagation() {
      this.bubbles = !1;
    } });
    this.onBeforeLayout(n);
    const s = this.getLayoutResult(n);
    s && this.commitLayout(n, s), this.onAfterLayout(n, s), this._prevLayoutStrategy = n.strategy;
  }
  attachHandlers(e, n) {
    const { target: s } = n;
    return [Do, nd, ur, sd, ra, id, Po, qS, ZS].map((i) => e.on(i, (o) => this.performLayout(i === Do ? { type: "object_modified", trigger: i, e: o, target: s } : { type: "object_modifying", trigger: i, e: o, target: s })));
  }
  subscribe(e, n) {
    this.unsubscribe(e, n);
    const s = this.attachHandlers(e, n);
    this._subscriptions.set(e, s);
  }
  unsubscribe(e, n) {
    (this._subscriptions.get(e) || []).forEach((s) => s()), this._subscriptions.delete(e);
  }
  unsubscribeTargets(e) {
    e.targets.forEach((n) => this.unsubscribe(n, e));
  }
  subscribeTargets(e) {
    e.targets.forEach((n) => this.subscribe(n, e));
  }
  onBeforeLayout(e) {
    const { target: n, type: s } = e, { canvas: i } = n;
    if (s === Hn || s === jo ? this.subscribeTargets(e) : s === nc && this.unsubscribeTargets(e), n.fire("layout:before", { context: e }), i && i.fire("object:layout:before", { target: n, context: e }), s === Bo && e.deep) {
      const o = ue(e, Mk);
      n.forEachObject((a) => a.layoutManager && a.layoutManager.performLayout(st(st({}, o), {}, { bubbles: !1, target: a })));
    }
  }
  getLayoutResult(e) {
    const { target: n, strategy: s, type: i } = e, o = s.calcLayoutResult(e, n.getObjects());
    if (!o) return;
    const a = i === Hn ? new mt() : n.getRelativeCenterPoint(), { center: l, correction: c = new mt(), relativeCorrection: u = new mt() } = o, h = a.subtract(l).add(c).transform(i === Hn ? $e : gn(n.calcOwnMatrix()), !0).add(u);
    return { result: o, prevCenter: a, nextCenter: l, offset: h };
  }
  commitLayout(e, n) {
    const { target: s } = e, { result: { size: i }, nextCenter: o } = n;
    var a, l;
    s.set({ width: i.x, height: i.y }), this.layoutObjects(e, n), e.type === Hn ? s.set({ left: (a = e.x) !== null && a !== void 0 ? a : o.x + i.x * Se(s.originX), top: (l = e.y) !== null && l !== void 0 ? l : o.y + i.y * Se(s.originY) }) : (s.setPositionByOrigin(o, Ut, Ut), s.setCoords(), s.set("dirty", !0));
  }
  layoutObjects(e, n) {
    const { target: s } = e;
    s.forEachObject((i) => {
      i.group === s && this.layoutObject(e, n, i);
    }), e.strategy.shouldLayoutClipPath(e) && this.layoutObject(e, n, s.clipPath);
  }
  layoutObject(e, n, s) {
    let { offset: i } = n;
    s.set({ left: s.left + i.x, top: s.top + i.y });
  }
  onAfterLayout(e, n) {
    const { target: s, strategy: i, bubbles: o, prevStrategy: a } = e, l = ue(e, Ok), { canvas: c } = s;
    s.fire("layout:after", { context: e, result: n }), c && c.fire("object:layout:after", { context: e, result: n, target: s });
    const u = s.parent;
    o && u != null && u.layoutManager && ((l.path || (l.path = [])).push(s), u.layoutManager.performLayout(st(st({}, l), {}, { target: u }))), s.set("dirty", !0);
  }
  dispose() {
    const { _subscriptions: e } = this;
    e.forEach((n) => n.forEach((s) => s())), e.clear();
  }
  toObject() {
    return { type: Bd, strategy: this.strategy.constructor.type };
  }
  toJSON() {
    return this.toObject();
  }
}
Et.setClass(mr, Bd);
const Ek = ["type", "objects", "layoutManager"];
class Pk extends mr {
  performLayout() {
  }
}
class Us extends rd(Ie) {
  static getDefaults() {
    return st(st({}, super.getDefaults()), Us.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), nt(this, "_activeObjects", []), nt(this, "__objectSelectionTracker", void 0), nt(this, "__objectSelectionDisposer", void 0), Object.assign(this, Us.ownDefaults), this.setOptions(n), this.groupInit(e, n);
  }
  groupInit(e, n) {
    var s;
    this._objects = [...e], this.__objectSelectionTracker = this.__objectSelectionMonitor.bind(this, !0), this.__objectSelectionDisposer = this.__objectSelectionMonitor.bind(this, !1), this.forEachObject((i) => {
      this.enterGroup(i, !1);
    }), this.layoutManager = (s = n.layoutManager) !== null && s !== void 0 ? s : new mr(), this.layoutManager.performLayout({ type: Hn, target: this, targets: [...e], x: n.left, y: n.top });
  }
  canEnterGroup(e) {
    return e === this || this.isDescendantOf(e) ? (Ss("error", "Group: circular object trees are not supported, this call has no effect"), !1) : this._objects.indexOf(e) === -1 || (Ss("error", "Group: duplicate objects are not supported inside group, this call has no effect"), !1);
  }
  _filterObjectsBeforeEnteringGroup(e) {
    return e.filter((n, s, i) => this.canEnterGroup(n) && i.indexOf(n) === s);
  }
  add() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    const i = this._filterObjectsBeforeEnteringGroup(n), o = super.add(...i);
    return this._onAfterObjectsChange(jo, i), o;
  }
  insertAt(e) {
    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) s[i - 1] = arguments[i];
    const o = this._filterObjectsBeforeEnteringGroup(s), a = super.insertAt(e, ...o);
    return this._onAfterObjectsChange(jo, o), a;
  }
  remove() {
    const e = super.remove(...arguments);
    return this._onAfterObjectsChange(nc, e), e;
  }
  _onObjectAdded(e) {
    this.enterGroup(e, !0), this.fire("object:added", { target: e }), e.fire("added", { target: this });
  }
  _onObjectRemoved(e, n) {
    this.exitGroup(e, n), this.fire("object:removed", { target: e }), e.fire("removed", { target: this });
  }
  _onAfterObjectsChange(e, n) {
    this.layoutManager.performLayout({ type: e, targets: n, target: this });
  }
  _onStackOrderChanged() {
    this._set("dirty", !0);
  }
  _set(e, n) {
    const s = this[e];
    return super._set(e, n), e === "canvas" && s !== n && (this._objects || []).forEach((i) => {
      i._set(e, n);
    }), this;
  }
  _shouldSetNestedCoords() {
    return this.subTargetCheck;
  }
  removeAll() {
    return this._activeObjects = [], this.remove(...this._objects);
  }
  __objectSelectionMonitor(e, n) {
    let { target: s } = n;
    const i = this._activeObjects;
    if (e) i.push(s), this._set("dirty", !0);
    else if (i.length > 0) {
      const o = i.indexOf(s);
      o > -1 && (i.splice(o, 1), this._set("dirty", !0));
    }
  }
  _watchObject(e, n) {
    e && this._watchObject(!1, n), e ? (n.on("selected", this.__objectSelectionTracker), n.on("deselected", this.__objectSelectionDisposer)) : (n.off("selected", this.__objectSelectionTracker), n.off("deselected", this.__objectSelectionDisposer));
  }
  enterGroup(e, n) {
    e.group && e.group.remove(e), e._set("parent", this), this._enterGroup(e, n);
  }
  _enterGroup(e, n) {
    n && Io(e, Pe(gn(this.calcTransformMatrix()), e.calcTransformMatrix())), this._shouldSetNestedCoords() && e.setCoords(), e._set("group", this), e._set("canvas", this.canvas), this._watchObject(!0, e);
    const s = this.canvas && this.canvas.getActiveObject && this.canvas.getActiveObject();
    s && (s === e || e.isDescendantOf(s)) && this._activeObjects.push(e);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e._set("parent", void 0), e._set("canvas", void 0);
  }
  _exitGroup(e, n) {
    e._set("group", void 0), n || (Io(e, Pe(this.calcTransformMatrix(), e.calcTransformMatrix())), e.setCoords()), this._watchObject(!1, e);
    const s = this._activeObjects.length > 0 ? this._activeObjects.indexOf(e) : -1;
    s > -1 && this._activeObjects.splice(s, 1);
  }
  shouldCache() {
    const e = Ie.prototype.shouldCache.call(this);
    if (e) {
      for (let n = 0; n < this._objects.length; n++) if (this._objects[n].willDrawShadow()) return this.ownCaching = !1, !1;
    }
    return e;
  }
  willDrawShadow() {
    if (super.willDrawShadow()) return !0;
    for (let e = 0; e < this._objects.length; e++) if (this._objects[e].willDrawShadow()) return !0;
    return !1;
  }
  isOnACache() {
    return this.ownCaching || !!this.parent && this.parent.isOnACache();
  }
  drawObject(e, n, s) {
    this._renderBackground(e);
    for (let o = 0; o < this._objects.length; o++) {
      var i;
      const a = this._objects[o];
      (i = this.canvas) !== null && i !== void 0 && i.preserveObjectStacking && a.group !== this ? (e.save(), e.transform(...gn(this.calcTransformMatrix())), a.render(e), e.restore()) : a.group === this && a.render(e);
    }
    this._drawClipPath(e, this.clipPath, s);
  }
  setCoords() {
    super.setCoords(), this._shouldSetNestedCoords() && this.forEachObject((e) => e.setCoords());
  }
  triggerLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.layoutManager.performLayout(st({ target: this, type: Bo }, e));
  }
  render(e) {
    this._transformDone = !0, super.render(e), this._transformDone = !1;
  }
  __serializeObjects(e, n) {
    const s = this.includeDefaultValues;
    return this._objects.filter(function(i) {
      return !i.excludeFromExport;
    }).map(function(i) {
      const o = i.includeDefaultValues;
      i.includeDefaultValues = s;
      const a = i[e || "toObject"](n);
      return i.includeDefaultValues = o, a;
    });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.layoutManager.toObject();
    return st(st(st({}, super.toObject(["subTargetCheck", "interactive", ...e])), n.strategy !== "fit-content" || this.includeDefaultValues ? { layoutManager: n } : {}), {}, { objects: this.__serializeObjects("toObject", e) });
  }
  toString() {
    return "#<Group: (".concat(this.complexity(), ")>");
  }
  dispose() {
    this.layoutManager.unsubscribeTargets({ targets: this.getObjects(), target: this }), this._activeObjects = [], this.forEachObject((e) => {
      this._watchObject(!1, e), e.dispose();
    }), super.dispose();
  }
  _createSVGBgRect(e) {
    if (!this.backgroundColor) return "";
    const n = On.prototype._toSVG.call(this), s = n.indexOf("COMMON_PARTS");
    n[s] = 'for="group" ';
    const i = n.join("");
    return e ? e(i) : i;
  }
  _toSVG(e) {
    const n = ["<g ", "COMMON_PARTS", ` >
`], s = this._createSVGBgRect(e);
    s && n.push("		", s);
    for (let i = 0; i < this._objects.length; i++) n.push("		", this._objects[i].toSVG(e));
    return n.push(`</g>
`), n;
  }
  getSvgStyles() {
    const e = this.opacity !== void 0 && this.opacity !== 1 ? "opacity: ".concat(this.opacity, ";") : "", n = this.visible ? "" : " visibility: hidden;";
    return [e, this.getSvgFilter(), n].join("");
  }
  toClipPathSVG(e) {
    const n = [], s = this._createSVGBgRect(e);
    s && n.push("	", s);
    for (let i = 0; i < this._objects.length; i++) n.push("	", this._objects[i].toClipPathSVG(e));
    return this._createBaseClipPathSVGMarkup(n, { reviver: e });
  }
  static fromObject(e, n) {
    let { type: s, objects: i = [], layoutManager: o } = e, a = ue(e, Ek);
    return Promise.all([hr(i, n), la(a, n)]).then((l) => {
      let [c, u] = l;
      const h = new this(c, st(st(st({}, a), u), {}, { layoutManager: new Pk() }));
      if (o) {
        const f = Et.getClass(o.type), m = Et.getClass(o.strategy);
        h.layoutManager = new f(new m());
      } else h.layoutManager = new mr();
      return h.layoutManager.subscribeTargets({ type: Hn, target: h, targets: h.getObjects() }), h.setCoords(), h;
    });
  }
}
nt(Us, "type", "Group"), nt(Us, "ownDefaults", { strokeWidth: 0, subTargetCheck: !1, interactive: !1 }), Et.setClass(Us);
const Dk = (r, e) => Math.min(e.width / r.width, e.height / r.height), Ak = (r, e) => Math.max(e.width / r.width, e.height / r.height), gl = "\\s*,?\\s*", Ri = "".concat(gl, "(").concat(vn, ")"), Fk = "".concat(Ri).concat(Ri).concat(Ri).concat(gl, "([01])").concat(gl, "([01])").concat(Ri).concat(Ri), Ik = { m: "l", M: "L" }, Lk = (r, e, n, s, i, o, a, l, c, u, h) => {
  const f = ss(r), m = is(r), p = ss(e), y = is(e), v = n * i * p - s * o * y + a, _ = s * i * p + n * o * y + l;
  return ["C", u + c * (-n * i * m - s * o * f), h + c * (-s * i * m + n * o * f), v + c * (n * i * y + s * o * p), _ + c * (s * i * y - n * o * p), v, _];
}, xu = (r, e, n, s) => {
  const i = Math.atan2(e, r), o = Math.atan2(s, n);
  return o >= i ? o - i : 2 * Math.PI - (i - o);
};
function wu(r, e, n, s, i, o, a, l) {
  let c;
  if (Gt.cachesBoundsOfCurve && (c = [...arguments].join(), Ji.boundsOfCurveCache[c])) return Ji.boundsOfCurveCache[c];
  const u = Math.sqrt, h = Math.abs, f = [], m = [[0, 0], [0, 0]];
  let p = 6 * r - 12 * n + 6 * i, y = -3 * r + 9 * n - 9 * i + 3 * a, v = 3 * n - 3 * r;
  for (let k = 0; k < 2; ++k) {
    if (k > 0 && (p = 6 * e - 12 * s + 6 * o, y = -3 * e + 9 * s - 9 * o + 3 * l, v = 3 * s - 3 * e), h(y) < 1e-12) {
      if (h(p) < 1e-12) continue;
      const j = -v / p;
      0 < j && j < 1 && f.push(j);
      continue;
    }
    const w = p * p - 4 * v * y;
    if (w < 0) continue;
    const T = u(w), P = (-p + T) / (2 * y);
    0 < P && P < 1 && f.push(P);
    const z = (-p - T) / (2 * y);
    0 < z && z < 1 && f.push(z);
  }
  let _ = f.length;
  const g = _, C = Vd(r, e, n, s, i, o, a, l);
  for (; _--; ) {
    const { x: k, y: w } = C(f[_]);
    m[0][_] = k, m[1][_] = w;
  }
  m[0][g] = r, m[1][g] = e, m[0][g + 1] = a, m[1][g + 1] = l;
  const x = [new mt(Math.min(...m[0]), Math.min(...m[1])), new mt(Math.max(...m[0]), Math.max(...m[1]))];
  return Gt.cachesBoundsOfCurve && (Ji.boundsOfCurveCache[c] = x), x;
}
const Rk = (r, e, n) => {
  let [s, i, o, a, l, c, u, h] = n;
  const f = ((m, p, y, v, _, g, C) => {
    if (y === 0 || v === 0) return [];
    let x = 0, k = 0, w = 0;
    const T = Math.PI, P = C * Bl, z = is(P), j = ss(P), ot = 0.5 * (-j * m - z * p), vt = 0.5 * (-j * p + z * m), L = y ** 2, Y = v ** 2, M = vt ** 2, I = ot ** 2, tt = L * Y - L * M - Y * I;
    let U = Math.abs(y), W = Math.abs(v);
    if (tt < 0) {
      const E = Math.sqrt(1 - tt / (L * Y));
      U *= E, W *= E;
    } else w = (_ === g ? -1 : 1) * Math.sqrt(tt / (L * M + Y * I));
    const Z = w * U * vt / W, yt = -w * W * ot / U, Q = j * Z - z * yt + 0.5 * m, at = z * Z + j * yt + 0.5 * p;
    let _t = xu(1, 0, (ot - Z) / U, (vt - yt) / W), ht = xu((ot - Z) / U, (vt - yt) / W, (-ot - Z) / U, (-vt - yt) / W);
    g === 0 && ht > 0 ? ht -= 2 * T : g === 1 && ht < 0 && (ht += 2 * T);
    const X = Math.ceil(Math.abs(ht / T * 2)), kt = [], lt = ht / X, pt = 8 / 3 * Math.sin(lt / 4) * Math.sin(lt / 4) / Math.sin(lt / 2);
    let it = _t + lt;
    for (let E = 0; E < X; E++) kt[E] = Lk(_t, it, j, z, U, W, Q, at, pt, x, k), x = kt[E][5], k = kt[E][6], _t = it, it += lt;
    return kt;
  })(u - r, h - e, i, o, l, c, a);
  for (let m = 0, p = f.length; m < p; m++) f[m][1] += r, f[m][2] += e, f[m][3] += r, f[m][4] += e, f[m][5] += r, f[m][6] += e;
  return f;
}, zk = (r) => {
  let e = 0, n = 0, s = 0, i = 0;
  const o = [];
  let a, l = 0, c = 0;
  for (const u of r) {
    const h = [...u];
    let f;
    switch (h[0]) {
      case "l":
        h[1] += e, h[2] += n;
      case "L":
        e = h[1], n = h[2], f = ["L", e, n];
        break;
      case "h":
        h[1] += e;
      case "H":
        e = h[1], f = ["L", e, n];
        break;
      case "v":
        h[1] += n;
      case "V":
        n = h[1], f = ["L", e, n];
        break;
      case "m":
        h[1] += e, h[2] += n;
      case "M":
        e = h[1], n = h[2], s = h[1], i = h[2], f = ["M", e, n];
        break;
      case "c":
        h[1] += e, h[2] += n, h[3] += e, h[4] += n, h[5] += e, h[6] += n;
      case "C":
        l = h[3], c = h[4], e = h[5], n = h[6], f = ["C", h[1], h[2], l, c, e, n];
        break;
      case "s":
        h[1] += e, h[2] += n, h[3] += e, h[4] += n;
      case "S":
        a === "C" ? (l = 2 * e - l, c = 2 * n - c) : (l = e, c = n), e = h[3], n = h[4], f = ["C", l, c, h[1], h[2], e, n], l = f[3], c = f[4];
        break;
      case "q":
        h[1] += e, h[2] += n, h[3] += e, h[4] += n;
      case "Q":
        l = h[1], c = h[2], e = h[3], n = h[4], f = ["Q", l, c, e, n];
        break;
      case "t":
        h[1] += e, h[2] += n;
      case "T":
        a === "Q" ? (l = 2 * e - l, c = 2 * n - c) : (l = e, c = n), e = h[1], n = h[2], f = ["Q", l, c, e, n];
        break;
      case "a":
        h[6] += e, h[7] += n;
      case "A":
        Rk(e, n, h).forEach((m) => o.push(m)), e = h[6], n = h[7];
        break;
      case "z":
      case "Z":
        e = s, n = i, f = ["Z"];
    }
    f ? (o.push(f), a = f[0]) : a = "";
  }
  return o;
}, Vo = (r, e, n, s) => Math.sqrt((n - r) ** 2 + (s - e) ** 2), Vd = (r, e, n, s, i, o, a, l) => (c) => {
  const u = c ** 3, h = ((p) => 3 * p ** 2 * (1 - p))(c), f = ((p) => 3 * p * (1 - p) ** 2)(c), m = ((p) => (1 - p) ** 3)(c);
  return new mt(a * u + i * h + n * f + r * m, l * u + o * h + s * f + e * m);
}, $d = (r) => r ** 2, Nd = (r) => 2 * r * (1 - r), Wd = (r) => (1 - r) ** 2, jk = (r, e, n, s, i, o, a, l) => (c) => {
  const u = $d(c), h = Nd(c), f = Wd(c), m = 3 * (f * (n - r) + h * (i - n) + u * (a - i)), p = 3 * (f * (s - e) + h * (o - s) + u * (l - o));
  return Math.atan2(p, m);
}, Bk = (r, e, n, s, i, o) => (a) => {
  const l = $d(a), c = Nd(a), u = Wd(a);
  return new mt(i * l + n * c + r * u, o * l + s * c + e * u);
}, Vk = (r, e, n, s, i, o) => (a) => {
  const l = 1 - a, c = 2 * (l * (n - r) + a * (i - n)), u = 2 * (l * (s - e) + a * (o - s));
  return Math.atan2(u, c);
}, Su = (r, e, n) => {
  let s = new mt(e, n), i = 0;
  for (let o = 1; o <= 100; o += 1) {
    const a = r(o / 100);
    i += Vo(s.x, s.y, a.x, a.y), s = a;
  }
  return i;
}, $k = (r, e) => {
  let n, s = 0, i = 0, o = { x: r.x, y: r.y }, a = st({}, o), l = 0.01, c = 0;
  const u = r.iterator, h = r.angleFinder;
  for (; i < e && l > 1e-4; ) a = u(s), c = s, n = Vo(o.x, o.y, a.x, a.y), n + i > e ? (s -= l, l /= 2) : (o = a, s += l, i += n);
  return st(st({}, a), {}, { angle: h(c) });
}, Ud = (r) => {
  let e, n, s = 0, i = 0, o = 0, a = 0, l = 0;
  const c = [];
  for (const u of r) {
    const h = { x: i, y: o, command: u[0], length: 0 };
    switch (u[0]) {
      case "M":
        n = h, n.x = a = i = u[1], n.y = l = o = u[2];
        break;
      case "L":
        n = h, n.length = Vo(i, o, u[1], u[2]), i = u[1], o = u[2];
        break;
      case "C":
        e = Vd(i, o, u[1], u[2], u[3], u[4], u[5], u[6]), n = h, n.iterator = e, n.angleFinder = jk(i, o, u[1], u[2], u[3], u[4], u[5], u[6]), n.length = Su(e, i, o), i = u[5], o = u[6];
        break;
      case "Q":
        e = Bk(i, o, u[1], u[2], u[3], u[4]), n = h, n.iterator = e, n.angleFinder = Vk(i, o, u[1], u[2], u[3], u[4]), n.length = Su(e, i, o), i = u[3], o = u[4];
        break;
      case "Z":
        n = h, n.destX = a, n.destY = l, n.length = Vo(i, o, a, l), i = a, o = l;
    }
    s += n.length, c.push(n);
  }
  return c.push({ length: s, x: i, y: o }), c;
}, Nk = function(r, e) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ud(r), s = 0;
  for (; e - n[s].length > 0 && s < n.length - 2; ) e -= n[s].length, s++;
  const i = n[s], o = e / i.length, a = r[s];
  switch (i.command) {
    case "M":
      return { x: i.x, y: i.y, angle: 0 };
    case "Z":
      return st(st({}, new mt(i.x, i.y).lerp(new mt(i.destX, i.destY), o)), {}, { angle: Math.atan2(i.destY - i.y, i.destX - i.x) });
    case "L":
      return st(st({}, new mt(i.x, i.y).lerp(new mt(a[1], a[2]), o)), {}, { angle: Math.atan2(a[2] - i.y, a[1] - i.x) });
    case "C":
    case "Q":
      return $k(i, e);
  }
}, Wk = new RegExp("[mzlhvcsqta][^mzlhvcsqta]*", "gi"), Cu = new RegExp(Fk, "g"), Uk = new RegExp(vn, "gi"), Hk = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, Xk = (r) => {
  var e;
  const n = [], s = (e = r.match(Wk)) !== null && e !== void 0 ? e : [];
  for (const i of s) {
    const o = i[0];
    if (o === "z" || o === "Z") {
      n.push([o]);
      continue;
    }
    const a = Hk[o.toLowerCase()];
    let l = [];
    if (o === "a" || o === "A") {
      Cu.lastIndex = 0;
      for (let c = null; c = Cu.exec(i); ) l.push(...c.slice(1));
    } else l = i.match(Uk) || [];
    for (let c = 0; c < l.length; c += a) {
      const u = new Array(a), h = Ik[o];
      u[0] = c > 0 && h ? h : o;
      for (let f = 0; f < a; f++) u[f + 1] = parseFloat(l[c + f]);
      n.push(u);
    }
  }
  return n;
}, Gk = (r, e) => r.map((n) => n.map((s, i) => i === 0 || e === void 0 ? s : le(s, e)).join(" ")).join(" ");
function vl(r, e) {
  const n = r.style;
  n && e && (typeof e == "string" ? n.cssText += ";" + e : Object.entries(e).forEach((s) => {
    let [i, o] = s;
    return n.setProperty(i, o);
  }));
}
class Yk extends gd {
  constructor(e) {
    let { allowTouchScrolling: n = !1, containerClass: s = "" } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e), nt(this, "upper", void 0), nt(this, "container", void 0);
    const { el: i } = this.lower, o = this.createUpperCanvas();
    this.upper = { el: o, ctx: o.getContext("2d") }, this.applyCanvasStyle(i, { allowTouchScrolling: n }), this.applyCanvasStyle(o, { allowTouchScrolling: n, styles: { position: "absolute", left: "0", top: "0" } });
    const a = this.createContainerElement();
    a.classList.add(s), i.parentNode && i.parentNode.replaceChild(a, i), a.append(i, o), this.container = a;
  }
  createUpperCanvas() {
    const { el: e } = this.lower, n = rs();
    return n.className = e.className, n.classList.remove("lower-canvas"), n.classList.add("upper-canvas"), n.setAttribute("data-fabric", "top"), n.style.cssText = e.style.cssText, n.setAttribute("draggable", "true"), n;
  }
  createContainerElement() {
    const e = Ci().createElement("div");
    return e.setAttribute("data-fabric", "wrapper"), vl(e, { position: "relative" }), Kc(e), e;
  }
  applyCanvasStyle(e, n) {
    const { styles: s, allowTouchScrolling: i } = n;
    vl(e, st(st({}, s), {}, { "touch-action": i ? "manipulation" : Ge })), Kc(e);
  }
  setDimensions(e, n) {
    super.setDimensions(e, n);
    const { el: s, ctx: i } = this.upper;
    md(s, i, e, n);
  }
  setCSSDimensions(e) {
    super.setCSSDimensions(e), cl(this.upper.el, e), cl(this.container, e);
  }
  cleanupDOM(e) {
    const n = this.container, { el: s } = this.lower, { el: i } = this.upper;
    super.cleanupDOM(e), n.removeChild(i), n.removeChild(s), n.parentNode && n.parentNode.replaceChild(s, n);
  }
  dispose() {
    super.dispose(), Fn().dispose(this.upper.el), delete this.upper, delete this.container;
  }
}
class fa extends wr {
  constructor() {
    super(...arguments), nt(this, "targets", []), nt(this, "_hoveredTargets", []), nt(this, "_currentTransform", null), nt(this, "_groupSelector", null), nt(this, "contextTopDirty", !1);
  }
  static getDefaults() {
    return st(st({}, super.getDefaults()), fa.ownDefaults);
  }
  get upperCanvasEl() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.el;
  }
  get contextTop() {
    var e;
    return (e = this.elements.upper) === null || e === void 0 ? void 0 : e.ctx;
  }
  get wrapperEl() {
    return this.elements.container;
  }
  initElements(e) {
    this.elements = new Yk(e, { allowTouchScrolling: this.allowTouchScrolling, containerClass: this.containerClass }), this._createCacheCanvas();
  }
  _onObjectAdded(e) {
    this._objectsToRender = void 0, super._onObjectAdded(e);
  }
  _onObjectRemoved(e) {
    this._objectsToRender = void 0, e === this._activeObject && (this.fire("before:selection:cleared", { deselected: [e] }), this._discardActiveObject(), this.fire("selection:cleared", { deselected: [e] }), e.fire("deselected", { target: e })), e === this._hoveredTarget && (this._hoveredTarget = void 0, this._hoveredTargets = []), super._onObjectRemoved(e);
  }
  _onStackOrderChanged() {
    this._objectsToRender = void 0, super._onStackOrderChanged();
  }
  _chooseObjectsToRender() {
    const e = this._activeObject;
    return !this.preserveObjectStacking && e ? this._objects.filter((n) => !n.group && n !== e).concat(e) : this._objects;
  }
  renderAll() {
    this.cancelRequestedRender(), this.destroyed || (!this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1), !this._objectsToRender && (this._objectsToRender = this._chooseObjectsToRender()), this.renderCanvas(this.getContext(), this._objectsToRender));
  }
  renderTopLayer(e) {
    e.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(e), this.contextTopDirty = !0), e.restore();
  }
  renderTop() {
    const e = this.contextTop;
    this.clearContext(e), this.renderTopLayer(e), this.fire("after:render", { ctx: e });
  }
  setTargetFindTolerance(e) {
    e = Math.round(e), this.targetFindTolerance = e;
    const n = this.getRetinaScaling(), s = Math.ceil((2 * e + 1) * n);
    this.pixelFindCanvasEl.width = this.pixelFindCanvasEl.height = s, this.pixelFindContext.scale(n, n);
  }
  isTargetTransparent(e, n, s) {
    const i = this.targetFindTolerance, o = this.pixelFindContext;
    this.clearContext(o), o.save(), o.translate(-n + i, -s + i), o.transform(...this.viewportTransform);
    const a = e.selectionBackgroundColor;
    e.selectionBackgroundColor = "", e.render(o), e.selectionBackgroundColor = a, o.restore();
    const l = Math.round(i * this.getRetinaScaling());
    return JC(o, l, l, l);
  }
  _isSelectionKeyPressed(e) {
    const n = this.selectionKey;
    return !!n && (Array.isArray(n) ? !!n.find((s) => !!s && e[s] === !0) : e[n]);
  }
  _shouldClearSelection(e, n) {
    const s = this.getActiveObjects(), i = this._activeObject;
    return !!(!n || n && i && s.length > 1 && s.indexOf(n) === -1 && i !== n && !this._isSelectionKeyPressed(e) || n && !n.evented || n && !n.selectable && i && i !== n);
  }
  _shouldCenterTransform(e, n, s) {
    if (!e) return;
    let i;
    return n === oa || n === Ke || n === an || n === ur ? i = this.centeredScaling || e.centeredScaling : n === Nl && (i = this.centeredRotation || e.centeredRotation), i ? !s : s;
  }
  _getOriginFromCorner(e, n) {
    const s = { x: e.originX, y: e.originY };
    return n && (["ml", "tl", "bl"].includes(n) ? s.x = be : ["mr", "tr", "br"].includes(n) && (s.x = Jt), ["tl", "mt", "tr"].includes(n) ? s.y = ll : ["bl", "mb", "br"].includes(n) && (s.y = Xe)), s;
  }
  _setupCurrentTransform(e, n, s) {
    var i;
    const o = n.group ? fi(this.getScenePoint(e), void 0, n.group.calcTransformMatrix()) : this.getScenePoint(e), { key: a = "", control: l } = n.getActiveControl() || {}, c = s && l ? (i = l.getActionHandler(e, n, l)) === null || i === void 0 ? void 0 : i.bind(l) : pC, u = ((p, y, v, _) => {
      if (!y || !p) return "drag";
      const g = _.controls[y];
      return g.getActionName(v, g, _);
    })(s, a, e, n), h = e[this.centeredKey], f = this._shouldCenterTransform(n, u, h) ? { x: Ut, y: Ut } : this._getOriginFromCorner(n, a), m = { target: n, action: u, actionHandler: c, actionPerformed: !1, corner: a, scaleX: n.scaleX, scaleY: n.scaleY, skewX: n.skewX, skewY: n.skewY, offsetX: o.x - n.left, offsetY: o.y - n.top, originX: f.x, originY: f.y, ex: o.x, ey: o.y, lastX: o.x, lastY: o.y, theta: _e(n.angle), width: n.width, height: n.height, shiftKey: e.shiftKey, altKey: h, original: st(st({}, vd(n)), {}, { originX: f.x, originY: f.y }) };
    this._currentTransform = m, this.fire("before:transform", { e, transform: m });
  }
  setCursor(e) {
    this.upperCanvasEl.style.cursor = e;
  }
  _drawSelection(e) {
    const { x: n, y: s, deltaX: i, deltaY: o } = this._groupSelector, a = new mt(n, s).transform(this.viewportTransform), l = new mt(n + i, s + o).transform(this.viewportTransform), c = this.selectionLineWidth / 2;
    let u = Math.min(a.x, l.x), h = Math.min(a.y, l.y), f = Math.max(a.x, l.x), m = Math.max(a.y, l.y);
    this.selectionColor && (e.fillStyle = this.selectionColor, e.fillRect(u, h, f - u, m - h)), this.selectionLineWidth && this.selectionBorderColor && (e.lineWidth = this.selectionLineWidth, e.strokeStyle = this.selectionBorderColor, u += c, h += c, f -= c, m -= c, Ie.prototype._setLineDash.call(this, e, this.selectionDashArray), e.strokeRect(u, h, f - u, m - h));
  }
  findTarget(e) {
    if (this.skipTargetFind) return;
    const n = this.getViewportPoint(e), s = this._activeObject, i = this.getActiveObjects();
    if (this.targets = [], s && i.length >= 1) {
      if (s.findControl(n, ul(e)) || i.length > 1 && this.searchPossibleTargets([s], n)) return s;
      if (s === this.searchPossibleTargets([s], n)) {
        if (this.preserveObjectStacking) {
          const o = this.targets;
          this.targets = [];
          const a = this.searchPossibleTargets(this._objects, n);
          return e[this.altSelectionKey] && a && a !== s ? (this.targets = o, s) : a;
        }
        return s;
      }
    }
    return this.searchPossibleTargets(this._objects, n);
  }
  _pointIsInObjectSelectionArea(e, n) {
    let s = e.getCoords();
    const i = this.getZoom(), o = e.padding / i;
    if (o) {
      const [a, l, c, u] = s, h = Math.atan2(l.y - a.y, l.x - a.x), f = ss(h) * o, m = is(h) * o, p = f + m, y = f - m;
      s = [new mt(a.x - y, a.y - p), new mt(l.x + p, l.y - y), new mt(c.x + y, c.y + p), new mt(u.x - p, u.y + y)];
    }
    return fe.isPointInPolygon(n, s);
  }
  _checkTarget(e, n) {
    return !!(e && e.visible && e.evented && this._pointIsInObjectSelectionArea(e, fi(n, void 0, this.viewportTransform)) && (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing || !this.isTargetTransparent(e, n.x, n.y)));
  }
  _searchPossibleTargets(e, n) {
    let s = e.length;
    for (; s--; ) {
      const i = e[s];
      if (this._checkTarget(i, n)) {
        if (po(i) && i.subTargetCheck) {
          const o = this._searchPossibleTargets(i._objects, n);
          o && this.targets.push(o);
        }
        return i;
      }
    }
  }
  searchPossibleTargets(e, n) {
    const s = this._searchPossibleTargets(e, n);
    if (s && po(s) && s.interactive && this.targets[0]) {
      const i = this.targets;
      for (let o = i.length - 1; o > 0; o--) {
        const a = i[o];
        if (!po(a) || !a.interactive) return a;
      }
      return i[0];
    }
    return s;
  }
  getViewportPoint(e) {
    return this._pointer ? this._pointer : this.getPointer(e, !0);
  }
  getScenePoint(e) {
    return this._absolutePointer ? this._absolutePointer : this.getPointer(e);
  }
  getPointer(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
    const s = this.upperCanvasEl, i = s.getBoundingClientRect();
    let o = aC(e), a = i.width || 0, l = i.height || 0;
    a && l || (Xe in i && ll in i && (l = Math.abs(i.top - i.bottom)), be in i && Jt in i && (a = Math.abs(i.right - i.left))), this.calcOffset(), o.x = o.x - this._offset.left, o.y = o.y - this._offset.top, n || (o = fi(o, void 0, this.viewportTransform));
    const c = this.getRetinaScaling();
    c !== 1 && (o.x /= c, o.y /= c);
    const u = a === 0 || l === 0 ? new mt(1, 1) : new mt(s.width / a, s.height / l);
    return o.multiply(u);
  }
  _setDimensionsImpl(e, n) {
    this._resetTransformEventData(), super._setDimensionsImpl(e, n), this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop);
  }
  _createCacheCanvas() {
    this.pixelFindCanvasEl = rs(), this.pixelFindContext = this.pixelFindCanvasEl.getContext("2d", { willReadFrequently: !0 }), this.setTargetFindTolerance(this.targetFindTolerance);
  }
  getTopContext() {
    return this.elements.upper.ctx;
  }
  getSelectionContext() {
    return this.elements.upper.ctx;
  }
  getSelectionElement() {
    return this.elements.upper.el;
  }
  getActiveObject() {
    return this._activeObject;
  }
  getActiveObjects() {
    const e = this._activeObject;
    return Rs(e) ? e.getObjects() : e ? [e] : [];
  }
  _fireSelectionEvents(e, n) {
    let s = !1, i = !1;
    const o = this.getActiveObjects(), a = [], l = [];
    e.forEach((c) => {
      o.includes(c) || (s = !0, c.fire("deselected", { e: n, target: c }), l.push(c));
    }), o.forEach((c) => {
      e.includes(c) || (s = !0, c.fire("selected", { e: n, target: c }), a.push(c));
    }), e.length > 0 && o.length > 0 ? (i = !0, s && this.fire("selection:updated", { e: n, selected: a, deselected: l })) : o.length > 0 ? (i = !0, this.fire("selection:created", { e: n, selected: a })) : e.length > 0 && (i = !0, this.fire("selection:cleared", { e: n, deselected: l })), i && (this._objectsToRender = void 0);
  }
  setActiveObject(e, n) {
    const s = this.getActiveObjects(), i = this._setActiveObject(e, n);
    return this._fireSelectionEvents(s, n), i;
  }
  _setActiveObject(e, n) {
    const s = this._activeObject;
    return s !== e && !(!this._discardActiveObject(n, e) && this._activeObject) && !e.onSelect({ e: n }) && (this._activeObject = e, Rs(e) && s !== e && e.set("canvas", this), e.setCoords(), !0);
  }
  _discardActiveObject(e, n) {
    const s = this._activeObject;
    return !!s && !s.onDeselect({ e, object: n }) && (this._currentTransform && this._currentTransform.target === s && this.endCurrentTransform(e), Rs(s) && s === this._hoveredTarget && (this._hoveredTarget = void 0), this._activeObject = void 0, !0);
  }
  discardActiveObject(e) {
    const n = this.getActiveObjects(), s = this.getActiveObject();
    n.length && this.fire("before:selection:cleared", { e, deselected: [s] });
    const i = this._discardActiveObject(e);
    return this._fireSelectionEvents(n, e), i;
  }
  endCurrentTransform(e) {
    const n = this._currentTransform;
    this._finalizeCurrentTransform(e), n && n.target && (n.target.isMoving = !1), this._currentTransform = null;
  }
  _finalizeCurrentTransform(e) {
    const n = this._currentTransform, s = n.target, i = { e, target: s, transform: n, action: n.action };
    s._scaling && (s._scaling = !1), s.setCoords(), n.actionPerformed && (this.fire("object:modified", i), s.fire(Do, i));
  }
  setViewportTransform(e) {
    super.setViewportTransform(e);
    const n = this._activeObject;
    n && n.setCoords();
  }
  destroy() {
    const e = this._activeObject;
    Rs(e) && (e.removeAll(), e.dispose()), delete this._activeObject, super.destroy(), this.pixelFindContext = null, this.pixelFindCanvasEl = void 0;
  }
  clear() {
    this.discardActiveObject(), this._activeObject = void 0, this.clearContext(this.contextTop), super.clear();
  }
  drawControls(e) {
    const n = this._activeObject;
    n && n._renderControls(e);
  }
  _toObject(e, n, s) {
    const i = this._realizeGroupTransformOnObject(e), o = super._toObject(e, n, s);
    return e.set(i), o;
  }
  _realizeGroupTransformOnObject(e) {
    const { group: n } = e;
    if (n && Rs(n) && this._activeObject === n) {
      const s = Oi(e, ["angle", "flipX", "flipY", Jt, Ke, an, ki, Ti, Xe]);
      return cC(e, n.calcOwnMatrix()), s;
    }
    return {};
  }
  _setSVGObject(e, n, s) {
    const i = this._realizeGroupTransformOnObject(n);
    super._setSVGObject(e, n, s), n.set(i);
  }
}
nt(fa, "ownDefaults", { uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", selection: !0, selectionKey: "shiftKey", selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, enablePointerEvents: !1, containerClass: "canvas-container", preserveObjectStacking: !1 });
class Kk {
  constructor(e) {
    nt(this, "targets", []), nt(this, "__disposer", void 0);
    const n = () => {
      const { hiddenTextarea: i } = e.getActiveObject() || {};
      i && i.focus();
    }, s = e.upperCanvasEl;
    s.addEventListener("click", n), this.__disposer = () => s.removeEventListener("click", n);
  }
  exitTextEditing() {
    this.target = void 0, this.targets.forEach((e) => {
      e.isEditing && e.exitEditing();
    });
  }
  add(e) {
    this.targets.push(e);
  }
  remove(e) {
    this.unregister(e), si(this.targets, e);
  }
  register(e) {
    this.target = e;
  }
  unregister(e) {
    e === this.target && (this.target = void 0);
  }
  onMouseMove(e) {
    var n;
    !((n = this.target) === null || n === void 0) && n.isEditing && this.target.updateSelectionOnMouseMove(e);
  }
  clear() {
    this.targets = [], this.target = void 0;
  }
  dispose() {
    this.clear(), this.__disposer(), delete this.__disposer;
  }
}
const qk = ["target", "oldTarget", "fireCanvas", "e"], Ze = { passive: !1 }, Qs = (r, e) => {
  const n = r.getViewportPoint(e), s = r.getScenePoint(e);
  return { viewportPoint: n, scenePoint: s, pointer: n, absolutePointer: s };
}, hs = function(r) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) n[s - 1] = arguments[s];
  return r.addEventListener(...n);
}, en = function(r) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), s = 1; s < e; s++) n[s - 1] = arguments[s];
  return r.removeEventListener(...n);
}, Zk = { mouse: { in: "over", out: "out", targetIn: "mouseover", targetOut: "mouseout", canvasIn: "mouse:over", canvasOut: "mouse:out" }, drag: { in: "enter", out: "leave", targetIn: "dragenter", targetOut: "dragleave", canvasIn: "drag:enter", canvasOut: "drag:leave" } };
class yl extends fa {
  constructor(e) {
    super(e, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}), nt(this, "_isClick", void 0), nt(this, "textEditingManager", new Kk(this)), ["_onMouseDown", "_onTouchStart", "_onMouseMove", "_onMouseUp", "_onTouchEnd", "_onResize", "_onMouseWheel", "_onMouseOut", "_onMouseEnter", "_onContextMenu", "_onClick", "_onDragStart", "_onDragEnd", "_onDragProgress", "_onDragOver", "_onDragEnter", "_onDragLeave", "_onDrop"].forEach((n) => {
      this[n] = this[n].bind(this);
    }), this.addOrRemove(hs, "add");
  }
  _getEventPrefix() {
    return this.enablePointerEvents ? "pointer" : "mouse";
  }
  addOrRemove(e, n) {
    const s = this.upperCanvasEl, i = this._getEventPrefix();
    e(pd(s), "resize", this._onResize), e(s, i + "down", this._onMouseDown), e(s, "".concat(i, "move"), this._onMouseMove, Ze), e(s, "".concat(i, "out"), this._onMouseOut), e(s, "".concat(i, "enter"), this._onMouseEnter), e(s, "wheel", this._onMouseWheel, { passive: !1 }), e(s, "contextmenu", this._onContextMenu), e(s, "click", this._onClick), e(s, "dblclick", this._onClick), e(s, "dragstart", this._onDragStart), e(s, "dragend", this._onDragEnd), e(s, "dragover", this._onDragOver), e(s, "dragenter", this._onDragEnter), e(s, "dragleave", this._onDragLeave), e(s, "drop", this._onDrop), this.enablePointerEvents || e(s, "touchstart", this._onTouchStart, Ze);
  }
  removeListeners() {
    this.addOrRemove(en, "remove");
    const e = this._getEventPrefix(), n = mn(this.upperCanvasEl);
    en(n, "".concat(e, "up"), this._onMouseUp), en(n, "touchend", this._onTouchEnd, Ze), en(n, "".concat(e, "move"), this._onMouseMove, Ze), en(n, "touchmove", this._onMouseMove, Ze), clearTimeout(this._willAddMouseDown);
  }
  _onMouseWheel(e) {
    this.__onMouseWheel(e);
  }
  _onMouseOut(e) {
    const n = this._hoveredTarget, s = st({ e }, Qs(this, e));
    this.fire("mouse:out", st(st({}, s), {}, { target: n })), this._hoveredTarget = void 0, n && n.fire("mouseout", st({}, s)), this._hoveredTargets.forEach((i) => {
      this.fire("mouse:out", st(st({}, s), {}, { target: i })), i && i.fire("mouseout", st({}, s));
    }), this._hoveredTargets = [];
  }
  _onMouseEnter(e) {
    this._currentTransform || this.findTarget(e) || (this.fire("mouse:over", st({ e }, Qs(this, e))), this._hoveredTarget = void 0, this._hoveredTargets = []);
  }
  _onDragStart(e) {
    this._isClick = !1;
    const n = this.getActiveObject();
    if (n && n.onDragStart(e)) {
      this._dragSource = n;
      const s = { e, target: n };
      return this.fire("dragstart", s), n.fire("dragstart", s), void hs(this.upperCanvasEl, "drag", this._onDragProgress);
    }
    qc(e);
  }
  _renderDragEffects(e, n, s) {
    let i = !1;
    const o = this._dropTarget;
    o && o !== n && o !== s && (o.clearContextTop(), i = !0), n == null || n.clearContextTop(), s !== n && (s == null || s.clearContextTop());
    const a = this.contextTop;
    a.save(), a.transform(...this.viewportTransform), n && (a.save(), n.transform(a), n.renderDragSourceEffect(e), a.restore(), i = !0), s && (a.save(), s.transform(a), s.renderDropTargetEffect(e), a.restore(), i = !0), a.restore(), i && (this.contextTopDirty = !0);
  }
  _onDragEnd(e) {
    const n = !!e.dataTransfer && e.dataTransfer.dropEffect !== Ge, s = n ? this._activeObject : void 0, i = { e, target: this._dragSource, subTargets: this.targets, dragSource: this._dragSource, didDrop: n, dropTarget: s };
    en(this.upperCanvasEl, "drag", this._onDragProgress), this.fire("dragend", i), this._dragSource && this._dragSource.fire("dragend", i), delete this._dragSource, this._onMouseUp(e);
  }
  _onDragProgress(e) {
    const n = { e, target: this._dragSource, dragSource: this._dragSource, dropTarget: this._draggedoverTarget };
    this.fire("drag", n), this._dragSource && this._dragSource.fire("drag", n);
  }
  findDragTargets(e) {
    return this.targets = [], { target: this._searchPossibleTargets(this._objects, this.getViewportPoint(e)), targets: [...this.targets] };
  }
  _onDragOver(e) {
    const n = "dragover", { target: s, targets: i } = this.findDragTargets(e), o = this._dragSource, a = { e, target: s, subTargets: i, dragSource: o, canDrop: !1, dropTarget: void 0 };
    let l;
    this.fire(n, a), this._fireEnterLeaveEvents(s, a), s && (s.canDrop(e) && (l = s), s.fire(n, a));
    for (let c = 0; c < i.length; c++) {
      const u = i[c];
      u.canDrop(e) && (l = u), u.fire(n, a);
    }
    this._renderDragEffects(e, o, l), this._dropTarget = l;
  }
  _onDragEnter(e) {
    const { target: n, targets: s } = this.findDragTargets(e), i = { e, target: n, subTargets: s, dragSource: this._dragSource };
    this.fire("dragenter", i), this._fireEnterLeaveEvents(n, i);
  }
  _onDragLeave(e) {
    const n = { e, target: this._draggedoverTarget, subTargets: this.targets, dragSource: this._dragSource };
    this.fire("dragleave", n), this._fireEnterLeaveEvents(void 0, n), this._renderDragEffects(e, this._dragSource), this._dropTarget = void 0, this.targets = [], this._hoveredTargets = [];
  }
  _onDrop(e) {
    const { target: n, targets: s } = this.findDragTargets(e), i = this._basicEventHandler("drop:before", st({ e, target: n, subTargets: s, dragSource: this._dragSource }, Qs(this, e)));
    i.didDrop = !1, i.dropTarget = void 0, this._basicEventHandler("drop", i), this.fire("drop:after", i);
  }
  _onContextMenu(e) {
    const n = this.findTarget(e), s = this.targets || [], i = this._basicEventHandler("contextmenu:before", { e, target: n, subTargets: s });
    return this.stopContextMenu && qc(e), this._basicEventHandler("contextmenu", i), !1;
  }
  _onClick(e) {
    const n = e.detail;
    n > 3 || n < 2 || (this._cacheTransformEventData(e), n == 2 && e.type === "dblclick" && this._handleEvent(e, "dblclick"), n == 3 && this._handleEvent(e, "tripleclick"), this._resetTransformEventData());
  }
  getPointerId(e) {
    const n = e.changedTouches;
    return n ? n[0] && n[0].identifier : this.enablePointerEvents ? e.pointerId : -1;
  }
  _isMainEvent(e) {
    return e.isPrimary === !0 || e.isPrimary !== !1 && (e.type === "touchend" && e.touches.length === 0 || !e.changedTouches || e.changedTouches[0].identifier === this.mainTouchId);
  }
  _onTouchStart(e) {
    let n = !this.allowTouchScrolling;
    const s = this._activeObject;
    this.mainTouchId === void 0 && (this.mainTouchId = this.getPointerId(e)), this.__onMouseDown(e), (this.isDrawingMode || s && this._target === s) && (n = !0), n && e.preventDefault(), this._resetTransformEventData();
    const i = this.upperCanvasEl, o = this._getEventPrefix(), a = mn(i);
    hs(a, "touchend", this._onTouchEnd, Ze), n && hs(a, "touchmove", this._onMouseMove, Ze), en(i, "".concat(o, "down"), this._onMouseDown);
  }
  _onMouseDown(e) {
    this.__onMouseDown(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, s = this._getEventPrefix();
    en(n, "".concat(s, "move"), this._onMouseMove, Ze);
    const i = mn(n);
    hs(i, "".concat(s, "up"), this._onMouseUp), hs(i, "".concat(s, "move"), this._onMouseMove, Ze);
  }
  _onTouchEnd(e) {
    if (e.touches.length > 0) return;
    this.__onMouseUp(e), this._resetTransformEventData(), delete this.mainTouchId;
    const n = this._getEventPrefix(), s = mn(this.upperCanvasEl);
    en(s, "touchend", this._onTouchEnd, Ze), en(s, "touchmove", this._onMouseMove, Ze), this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(() => {
      hs(this.upperCanvasEl, "".concat(n, "down"), this._onMouseDown), this._willAddMouseDown = 0;
    }, 400);
  }
  _onMouseUp(e) {
    this.__onMouseUp(e), this._resetTransformEventData();
    const n = this.upperCanvasEl, s = this._getEventPrefix();
    if (this._isMainEvent(e)) {
      const i = mn(this.upperCanvasEl);
      en(i, "".concat(s, "up"), this._onMouseUp), en(i, "".concat(s, "move"), this._onMouseMove, Ze), hs(n, "".concat(s, "move"), this._onMouseMove, Ze);
    }
  }
  _onMouseMove(e) {
    const n = this.getActiveObject();
    !this.allowTouchScrolling && (!n || !n.shouldStartDragging(e)) && e.preventDefault && e.preventDefault(), this.__onMouseMove(e);
  }
  _onResize() {
    this.calcOffset(), this._resetTransformEventData();
  }
  _shouldRender(e) {
    const n = this.getActiveObject();
    return !!n != !!e || n && e && n !== e;
  }
  __onMouseUp(e) {
    var n;
    this._cacheTransformEventData(e), this._handleEvent(e, "up:before");
    const s = this._currentTransform, i = this._isClick, o = this._target, { button: a } = e;
    if (a) return (this.fireMiddleClick && a === 1 || this.fireRightClick && a === 2) && this._handleEvent(e, "up"), void this._resetTransformEventData();
    if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    let l, c, u = !1;
    if (s && (this._finalizeCurrentTransform(e), u = s.actionPerformed), !i) {
      const h = o === this._activeObject;
      this.handleSelection(e), u || (u = this._shouldRender(o) || !h && o === this._activeObject);
    }
    if (o) {
      const h = o.findControl(this.getViewportPoint(e), ul(e)), { key: f, control: m } = h || {};
      if (c = f, o.selectable && o !== this._activeObject && o.activeOn === "up") this.setActiveObject(o, e), u = !0;
      else if (m) {
        const p = m.getMouseUpHandler(e, o, m);
        p && (l = this.getScenePoint(e), p.call(m, e, s, l.x, l.y));
      }
      o.isMoving = !1;
    }
    if (s && (s.target !== o || s.corner !== c)) {
      const h = s.target && s.target.controls[s.corner], f = h && h.getMouseUpHandler(e, s.target, h);
      l = l || this.getScenePoint(e), f && f.call(h, e, s, l.x, l.y);
    }
    this._setCursorFromEvent(e, o), this._handleEvent(e, "up"), this._groupSelector = null, this._currentTransform = null, o && (o.__corner = void 0), u ? this.requestRenderAll() : i || (n = this._activeObject) !== null && n !== void 0 && n.isEditing || this.renderTop();
  }
  _basicEventHandler(e, n) {
    const { target: s, subTargets: i = [] } = n;
    this.fire(e, n), s && s.fire(e, n);
    for (let o = 0; o < i.length; o++) i[o] !== s && i[o].fire(e, n);
    return n;
  }
  _handleEvent(e, n, s) {
    const i = this._target, o = this.targets || [], a = st(st(st({ e, target: i, subTargets: o }, Qs(this, e)), {}, { transform: this._currentTransform }, n === "up:before" || n === "up" ? { isClick: this._isClick, currentTarget: this.findTarget(e), currentSubTargets: this.targets } : {}), n === "down:before" || n === "down" ? s : {});
    this.fire("mouse:".concat(n), a), i && i.fire("mouse".concat(n), a);
    for (let l = 0; l < o.length; l++) o[l] !== i && o[l].fire("mouse".concat(n), a);
  }
  _onMouseDownInDrawingMode(e) {
    this._isCurrentlyDrawing = !0, this.getActiveObject() && (this.discardActiveObject(e), this.requestRenderAll());
    const n = this.getScenePoint(e);
    this.freeDrawingBrush && this.freeDrawingBrush.onMouseDown(n, { e, pointer: n }), this._handleEvent(e, "down", { alreadySelected: !1 });
  }
  _onMouseMoveInDrawingMode(e) {
    if (this._isCurrentlyDrawing) {
      const n = this.getScenePoint(e);
      this.freeDrawingBrush && this.freeDrawingBrush.onMouseMove(n, { e, pointer: n });
    }
    this.setCursor(this.freeDrawingCursor), this._handleEvent(e, "move");
  }
  _onMouseUpInDrawingMode(e) {
    const n = this.getScenePoint(e);
    this.freeDrawingBrush ? this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({ e, pointer: n }) : this._isCurrentlyDrawing = !1, this._handleEvent(e, "up");
  }
  __onMouseDown(e) {
    this._isClick = !0, this._cacheTransformEventData(e), this._handleEvent(e, "down:before");
    let n = this._target, s = !!n && n === this._activeObject;
    const { button: i } = e;
    if (i) return (this.fireMiddleClick && i === 1 || this.fireRightClick && i === 2) && this._handleEvent(e, "down", { alreadySelected: s }), void this._resetTransformEventData();
    if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e);
    if (!this._isMainEvent(e) || this._currentTransform) return;
    let o = this._shouldRender(n), a = !1;
    if (this.handleMultiSelection(e, n) ? (n = this._activeObject, a = !0, o = !0) : this._shouldClearSelection(e, n) && this.discardActiveObject(e), this.selection && (!n || !n.selectable && !n.isEditing && n !== this._activeObject)) {
      const l = this.getScenePoint(e);
      this._groupSelector = { x: l.x, y: l.y, deltaY: 0, deltaX: 0 };
    }
    if (s = !!n && n === this._activeObject, n) {
      n.selectable && n.activeOn === "down" && this.setActiveObject(n, e);
      const l = n.findControl(this.getViewportPoint(e), ul(e));
      if (n === this._activeObject && (l || !a)) {
        this._setupCurrentTransform(e, n, s);
        const c = l ? l.control : void 0, u = this.getScenePoint(e), h = c && c.getMouseDownHandler(e, n, c);
        h && h.call(c, e, this._currentTransform, u.x, u.y);
      }
    }
    o && (this._objectsToRender = void 0), this._handleEvent(e, "down", { alreadySelected: s }), o && this.requestRenderAll();
  }
  _resetTransformEventData() {
    this._target = this._pointer = this._absolutePointer = void 0;
  }
  _cacheTransformEventData(e) {
    this._resetTransformEventData(), this._pointer = this.getViewportPoint(e), this._absolutePointer = fi(this._pointer, void 0, this.viewportTransform), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e);
  }
  __onMouseMove(e) {
    if (this._isClick = !1, this._cacheTransformEventData(e), this._handleEvent(e, "move:before"), this.isDrawingMode) return void this._onMouseMoveInDrawingMode(e);
    if (!this._isMainEvent(e)) return;
    const n = this._groupSelector;
    if (n) {
      const s = this.getScenePoint(e);
      n.deltaX = s.x - n.x, n.deltaY = s.y - n.y, this.renderTop();
    } else if (this._currentTransform) this._transformObject(e);
    else {
      const s = this.findTarget(e);
      this._setCursorFromEvent(e, s), this._fireOverOutEvents(e, s);
    }
    this.textEditingManager.onMouseMove(e), this._handleEvent(e, "move"), this._resetTransformEventData();
  }
  _fireOverOutEvents(e, n) {
    const s = this._hoveredTarget, i = this._hoveredTargets, o = this.targets, a = Math.max(i.length, o.length);
    this.fireSyntheticInOutEvents("mouse", { e, target: n, oldTarget: s, fireCanvas: !0 });
    for (let l = 0; l < a; l++) o[l] === n || i[l] && i[l] === s || this.fireSyntheticInOutEvents("mouse", { e, target: o[l], oldTarget: i[l] });
    this._hoveredTarget = n, this._hoveredTargets = this.targets.concat();
  }
  _fireEnterLeaveEvents(e, n) {
    const s = this._draggedoverTarget, i = this._hoveredTargets, o = this.targets, a = Math.max(i.length, o.length);
    this.fireSyntheticInOutEvents("drag", st(st({}, n), {}, { target: e, oldTarget: s, fireCanvas: !0 }));
    for (let l = 0; l < a; l++) this.fireSyntheticInOutEvents("drag", st(st({}, n), {}, { target: o[l], oldTarget: i[l] }));
    this._draggedoverTarget = e;
  }
  fireSyntheticInOutEvents(e, n) {
    let { target: s, oldTarget: i, fireCanvas: o, e: a } = n, l = ue(n, qk);
    const { targetIn: c, targetOut: u, canvasIn: h, canvasOut: f } = Zk[e], m = i !== s;
    if (i && m) {
      const p = st(st({}, l), {}, { e: a, target: i, nextTarget: s }, Qs(this, a));
      o && this.fire(f, p), i.fire(u, p);
    }
    if (s && m) {
      const p = st(st({}, l), {}, { e: a, target: s, previousTarget: i }, Qs(this, a));
      o && this.fire(h, p), s.fire(c, p);
    }
  }
  __onMouseWheel(e) {
    this._cacheTransformEventData(e), this._handleEvent(e, "wheel"), this._resetTransformEventData();
  }
  _transformObject(e) {
    const n = this.getScenePoint(e), s = this._currentTransform, i = s.target, o = i.group ? fi(n, void 0, i.group.calcTransformMatrix()) : n;
    s.shiftKey = e.shiftKey, s.altKey = !!this.centeredKey && e[this.centeredKey], this._performTransformAction(e, s, o), s.actionPerformed && this.requestRenderAll();
  }
  _performTransformAction(e, n, s) {
    const { action: i, actionHandler: o, target: a } = n, l = !!o && o(e, n, s.x, s.y);
    l && a.setCoords(), i === "drag" && l && (n.target.isMoving = !0, this.setCursor(n.target.moveCursor || this.moveCursor)), n.actionPerformed = n.actionPerformed || l;
  }
  _setCursorFromEvent(e, n) {
    if (!n) return void this.setCursor(this.defaultCursor);
    let s = n.hoverCursor || this.hoverCursor;
    const i = Rs(this._activeObject) ? this._activeObject : null, o = (!i || n.group !== i) && n.findControl(this.getViewportPoint(e));
    if (o) {
      const a = o.control;
      this.setCursor(a.cursorStyleHandler(e, a, n));
    } else n.subTargetCheck && this.targets.concat().reverse().map((a) => {
      s = a.hoverCursor || s;
    }), this.setCursor(s);
  }
  handleMultiSelection(e, n) {
    const s = this._activeObject, i = Rs(s);
    if (s && this._isSelectionKeyPressed(e) && this.selection && n && n.selectable && (s !== n || i) && (i || !n.isDescendantOf(s) && !s.isDescendantOf(n)) && !n.onSelect({ e }) && !s.getActiveControl()) {
      if (i) {
        const o = s.getObjects();
        if (n === s) {
          const a = this.getViewportPoint(e);
          if (!(n = this.searchPossibleTargets(o, a) || this.searchPossibleTargets(this._objects, a)) || !n.selectable) return !1;
        }
        n.group === s ? (s.remove(n), this._hoveredTarget = n, this._hoveredTargets = [...this.targets], s.size() === 1 && this._setActiveObject(s.item(0), e)) : (s.multiSelectAdd(n), this._hoveredTarget = s, this._hoveredTargets = [...this.targets]), this._fireSelectionEvents(o, e);
      } else {
        s.isEditing && s.exitEditing();
        const o = new (Et.getClass("ActiveSelection"))([], { canvas: this });
        o.multiSelectAdd(s, n), this._hoveredTarget = o, this._setActiveObject(o, e), this._fireSelectionEvents([s], e);
      }
      return !0;
    }
    return !1;
  }
  handleSelection(e) {
    if (!this.selection || !this._groupSelector) return !1;
    const { x: n, y: s, deltaX: i, deltaY: o } = this._groupSelector, a = new mt(n, s), l = a.add(new mt(i, o)), c = a.min(l), u = a.max(l).subtract(c), h = this.collectObjects({ left: c.x, top: c.y, width: u.x, height: u.y }, { includeIntersecting: !this.selectionFullyContained }), f = a.eq(l) ? h[0] ? [h[0]] : [] : h.length > 1 ? h.filter((m) => !m.onSelect({ e })).reverse() : h;
    if (f.length === 1) this.setActiveObject(f[0], e);
    else if (f.length > 1) {
      const m = Et.getClass("ActiveSelection");
      this.setActiveObject(new m(f, { canvas: this }), e);
    }
    return this._groupSelector = null, !0;
  }
  clear() {
    this.textEditingManager.clear(), super.clear();
  }
  destroy() {
    this.removeListeners(), this.textEditingManager.dispose(), super.destroy();
  }
}
const Hd = { x1: 0, y1: 0, x2: 0, y2: 0 }, Jk = st(st({}, Hd), {}, { r1: 0, r2: 0 }), ri = (r, e) => isNaN(r) && typeof e == "number" ? e : r;
function Xd(r) {
  return r && /%$/.test(r) && Number.isFinite(parseFloat(r));
}
function Gd(r, e) {
  const n = typeof r == "number" ? r : typeof r == "string" ? parseFloat(r) / (Xd(r) ? 100 : 1) : NaN;
  return wi(0, ri(n, e), 1);
}
const Qk = /\s*;\s*/, tT = /\s*:\s*/;
function eT(r, e) {
  let n, s;
  const i = r.getAttribute("style");
  if (i) {
    const a = i.split(Qk);
    a[a.length - 1] === "" && a.pop();
    for (let l = a.length; l--; ) {
      const [c, u] = a[l].split(tT).map((h) => h.trim());
      c === "stop-color" ? n = u : c === "stop-opacity" && (s = u);
    }
  }
  const o = new ee(n || r.getAttribute("stop-color") || "rgb(0,0,0)");
  return { offset: Gd(r.getAttribute("offset"), 0), color: o.toRgb(), opacity: ri(parseFloat(s || r.getAttribute("stop-opacity") || ""), 1) * o.getAlpha() * e };
}
function nT(r, e) {
  const n = [], s = r.getElementsByTagName("stop"), i = Gd(e, 1);
  for (let o = s.length; o--; ) n.push(eT(s[o], i));
  return n;
}
function Yd(r) {
  return r.nodeName === "linearGradient" || r.nodeName === "LINEARGRADIENT" ? "linear" : "radial";
}
function Kd(r) {
  return r.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage";
}
function cn(r, e) {
  return r.getAttribute(e);
}
function sT(r, e) {
  return function(n, s) {
    let i, { width: o, height: a, gradientUnits: l } = s;
    return Object.entries(n).reduce((c, u) => {
      let [h, f] = u;
      if (f === "Infinity") i = 1;
      else if (f === "-Infinity") i = 0;
      else {
        const m = typeof f == "string";
        i = m ? parseFloat(f) : f, m && Xd(f) && (i *= 0.01, l === "pixels" && (h !== "x1" && h !== "x2" && h !== "r2" || (i *= o), h !== "y1" && h !== "y2" || (i *= a)));
      }
      return c[h] = i, c;
    }, {});
  }(Yd(r) === "linear" ? function(n) {
    return { x1: cn(n, "x1") || 0, y1: cn(n, "y1") || 0, x2: cn(n, "x2") || "100%", y2: cn(n, "y2") || 0 };
  }(r) : function(n) {
    return { x1: cn(n, "fx") || cn(n, "cx") || "50%", y1: cn(n, "fy") || cn(n, "cy") || "50%", r1: 0, x2: cn(n, "cx") || "50%", y2: cn(n, "cy") || "50%", r2: cn(n, "r") || "50%" };
  }(r), st(st({}, e), {}, { gradientUnits: Kd(r) }));
}
class zr {
  constructor(e) {
    const { type: n = "linear", gradientUnits: s = "pixels", coords: i = {}, colorStops: o = [], offsetX: a = 0, offsetY: l = 0, gradientTransform: c, id: u } = e || {};
    Object.assign(this, { type: n, gradientUnits: s, coords: st(st({}, n === "radial" ? Jk : Hd), i), colorStops: o, offsetX: a, offsetY: l, gradientTransform: c, id: u ? "".concat(u, "_").concat(Cs()) : Cs() });
  }
  addColorStop(e) {
    for (const n in e) {
      const s = new ee(e[n]);
      this.colorStops.push({ offset: parseFloat(n), color: s.toRgb(), opacity: s.getAlpha() });
    }
    return this;
  }
  toObject(e) {
    return st(st({}, Oi(this, e)), {}, { type: this.type, coords: st({}, this.coords), colorStops: this.colorStops.map((n) => st({}, n)), offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? [...this.gradientTransform] : void 0 });
  }
  toSVG(e) {
    let { additionalTransform: n } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = [], i = this.gradientTransform ? this.gradientTransform.concat() : $e.concat(), o = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox", a = this.colorStops.map((f) => st({}, f)).sort((f, m) => f.offset - m.offset);
    let l = -this.offsetX, c = -this.offsetY;
    var u;
    o === "objectBoundingBox" ? (l /= e.width, c /= e.height) : (l += e.width / 2, c += e.height / 2), (u = e) && typeof u._renderPathCommands == "function" && this.gradientUnits !== "percentage" && (l -= e.pathOffset.x, c -= e.pathOffset.y), i[4] -= l, i[5] -= c;
    const h = ['id="SVGID_'.concat(this.id, '"'), 'gradientUnits="'.concat(o, '"'), 'gradientTransform="'.concat(n ? n + " " : "").concat(dr(i), '"'), ""].join(" ");
    if (this.type === "linear") {
      const { x1: f, y1: m, x2: p, y2: y } = this.coords;
      s.push("<linearGradient ", h, ' x1="', f, '" y1="', m, '" x2="', p, '" y2="', y, `">
`);
    } else if (this.type === "radial") {
      const { x1: f, y1: m, x2: p, y2: y, r1: v, r2: _ } = this.coords, g = v > _;
      s.push("<radialGradient ", h, ' cx="', g ? f : p, '" cy="', g ? m : y, '" r="', g ? v : _, '" fx="', g ? p : f, '" fy="', g ? y : m, `">
`), g && (a.reverse(), a.forEach((x) => {
        x.offset = 1 - x.offset;
      }));
      const C = Math.min(v, _);
      if (C > 0) {
        const x = C / Math.max(v, _);
        a.forEach((k) => {
          k.offset += x * (1 - k.offset);
        });
      }
    }
    return a.forEach((f) => {
      let { color: m, offset: p, opacity: y } = f;
      s.push("<stop ", 'offset="', 100 * p + "%", '" style="stop-color:', m, y !== void 0 ? ";stop-opacity: " + y : ";", `"/>
`);
    }), s.push(this.type === "linear" ? "</linearGradient>" : "</radialGradient>", `
`), s.join("");
  }
  toLive(e) {
    const { x1: n, y1: s, x2: i, y2: o, r1: a, r2: l } = this.coords, c = this.type === "linear" ? e.createLinearGradient(n, s, i, o) : e.createRadialGradient(n, s, a, i, o, l);
    return this.colorStops.forEach((u) => {
      let { color: h, opacity: f, offset: m } = u;
      c.addColorStop(m, f !== void 0 ? new ee(h).setAlpha(f).toRgba() : h);
    }), c;
  }
  static async fromObject(e) {
    const { colorStops: n, gradientTransform: s } = e;
    return new this(st(st({}, e), {}, { colorStops: n ? n.map((i) => st({}, i)) : void 0, gradientTransform: s ? [...s] : void 0 }));
  }
  static fromElement(e, n, s) {
    const i = Kd(e), o = n._findCenterFromElement();
    return new this(st({ id: e.getAttribute("id") || void 0, type: Yd(e), coords: sT(e, { width: s.viewBoxWidth || s.width, height: s.viewBoxHeight || s.height }), colorStops: nT(e, s.opacity), gradientUnits: i, gradientTransform: pl(e.getAttribute("gradientTransform") || "") }, i === "pixels" ? { offsetX: n.width / 2 - o.x, offsetY: n.height / 2 - o.y } : { offsetX: 0, offsetY: 0 }));
  }
}
nt(zr, "type", "Gradient"), Et.setClass(zr, "gradient"), Et.setClass(zr, "linear"), Et.setClass(zr, "radial");
const iT = ["type", "source", "patternTransform"];
class Ba {
  get type() {
    return "pattern";
  }
  set type(e) {
    Ss("warn", "Setting type has no effect", e);
  }
  constructor(e) {
    nt(this, "repeat", "repeat"), nt(this, "offsetX", 0), nt(this, "offsetY", 0), nt(this, "crossOrigin", ""), this.id = Cs(), Object.assign(this, e);
  }
  isImageSource() {
    return !!this.source && typeof this.source.src == "string";
  }
  isCanvasSource() {
    return !!this.source && !!this.source.toDataURL;
  }
  sourceToString() {
    return this.isImageSource() ? this.source.src : this.isCanvasSource() ? this.source.toDataURL() : "";
  }
  toLive(e) {
    return this.source && (!this.isImageSource() || this.source.complete && this.source.naturalWidth !== 0 && this.source.naturalHeight !== 0) ? e.createPattern(this.source, this.repeat) : null;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const { repeat: n, crossOrigin: s } = this;
    return st(st({}, Oi(this, e)), {}, { type: "pattern", source: this.sourceToString(), repeat: n, crossOrigin: s, offsetX: le(this.offsetX, Gt.NUM_FRACTION_DIGITS), offsetY: le(this.offsetY, Gt.NUM_FRACTION_DIGITS), patternTransform: this.patternTransform ? [...this.patternTransform] : null });
  }
  toSVG(e) {
    let { width: n, height: s } = e;
    const { source: i, repeat: o, id: a } = this, l = ri(this.offsetX / n, 0), c = ri(this.offsetY / s, 0), u = o === "repeat-y" || o === "no-repeat" ? 1 + Math.abs(l || 0) : ri(i.width / n, 0), h = o === "repeat-x" || o === "no-repeat" ? 1 + Math.abs(c || 0) : ri(i.height / s, 0);
    return ['<pattern id="SVGID_'.concat(a, '" x="').concat(l, '" y="').concat(c, '" width="').concat(u, '" height="').concat(h, '">'), '<image x="0" y="0" width="'.concat(i.width, '" height="').concat(i.height, '" xlink:href="').concat(this.sourceToString(), '"></image>'), "</pattern>", ""].join(`
`);
  }
  static async fromObject(e, n) {
    let { type: s, source: i, patternTransform: o } = e, a = ue(e, iT);
    const l = await go(i, st(st({}, n), {}, { crossOrigin: a.crossOrigin }));
    return new this(st(st({}, a), {}, { patternTransform: o && o.slice(0), source: l }));
  }
}
nt(Ba, "type", "Pattern"), Et.setClass(Ba), Et.setClass(Ba, "pattern");
const rT = ["path", "left", "top"], oT = ["d"];
class _s extends Ie {
  constructor(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { path: s, left: i, top: o } = n, a = ue(n, rT);
    super(), Object.assign(this, _s.ownDefaults), this.setOptions(a), this._setPath(e || [], !0), typeof i == "number" && this.set(Jt, i), typeof o == "number" && this.set(Xe, o);
  }
  _setPath(e, n) {
    this.path = zk(Array.isArray(e) ? e : Xk(e)), this.setBoundingBox(n);
  }
  _findCenterFromElement() {
    const e = this._calcBoundsFromPath();
    return new mt(e.left + e.width / 2, e.top + e.height / 2);
  }
  _renderPathCommands(e) {
    const n = -this.pathOffset.x, s = -this.pathOffset.y;
    e.beginPath();
    for (const i of this.path) switch (i[0]) {
      case "L":
        e.lineTo(i[1] + n, i[2] + s);
        break;
      case "M":
        e.moveTo(i[1] + n, i[2] + s);
        break;
      case "C":
        e.bezierCurveTo(i[1] + n, i[2] + s, i[3] + n, i[4] + s, i[5] + n, i[6] + s);
        break;
      case "Q":
        e.quadraticCurveTo(i[1] + n, i[2] + s, i[3] + n, i[4] + s);
        break;
      case "Z":
        e.closePath();
    }
  }
  _render(e) {
    this._renderPathCommands(e), this._renderPaintInOrder(e);
  }
  toString() {
    return "#<Path (".concat(this.complexity(), '): { "top": ').concat(this.top, ', "left": ').concat(this.left, " }>");
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return st(st({}, super.toObject(e)), {}, { path: this.path.map((n) => n.slice()) });
  }
  toDatalessObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = this.toObject(e);
    return this.sourcePath && (delete n.path, n.sourcePath = this.sourcePath), n;
  }
  _toSVG() {
    const e = Gk(this.path, Gt.NUM_FRACTION_DIGITS);
    return ["<path ", "COMMON_PARTS", 'd="'.concat(e, `" stroke-linecap="round" />
`)];
  }
  _getOffsetTransform() {
    const e = Gt.NUM_FRACTION_DIGITS;
    return " translate(".concat(le(-this.pathOffset.x, e), ", ").concat(le(-this.pathOffset.y, e), ")");
  }
  toClipPathSVG(e) {
    const n = this._getOffsetTransform();
    return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  toSVG(e) {
    const n = this._getOffsetTransform();
    return this._createBaseSVGMarkup(this._toSVG(), { reviver: e, additionalTransform: n });
  }
  complexity() {
    return this.path.length;
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { width: n, height: s, pathOffset: i } = this._calcDimensions();
    this.set({ width: n, height: s, pathOffset: i }), e && this.setPositionByOrigin(i, Ut, Ut);
  }
  _calcBoundsFromPath() {
    const e = [];
    let n = 0, s = 0, i = 0, o = 0;
    for (const a of this.path) switch (a[0]) {
      case "L":
        i = a[1], o = a[2], e.push({ x: n, y: s }, { x: i, y: o });
        break;
      case "M":
        i = a[1], o = a[2], n = i, s = o;
        break;
      case "C":
        e.push(...wu(i, o, a[1], a[2], a[3], a[4], a[5], a[6])), i = a[5], o = a[6];
        break;
      case "Q":
        e.push(...wu(i, o, a[1], a[2], a[1], a[2], a[3], a[4])), i = a[3], o = a[4];
        break;
      case "Z":
        i = n, o = s;
    }
    return Zn(e);
  }
  _calcDimensions() {
    const e = this._calcBoundsFromPath();
    return st(st({}, e), {}, { pathOffset: new mt(e.left + e.width / 2, e.top + e.height / 2) });
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "path" });
  }
  static async fromElement(e, n, s) {
    const i = cs(e, this.ATTRIBUTE_NAMES, s), { d: o } = i;
    return new this(o, st(st(st({}, ue(i, oT)), n), {}, { left: void 0, top: void 0 }));
  }
}
nt(_s, "type", "Path"), nt(_s, "cacheProperties", [...ls, "path", "fillRule"]), nt(_s, "ATTRIBUTE_NAMES", [...Ts, "d"]), Et.setClass(_s), Et.setSVGClass(_s);
const aT = ["left", "top", "radius"], qd = ["radius", "startAngle", "endAngle", "counterClockwise"];
class Vn extends Ie {
  static getDefaults() {
    return st(st({}, super.getDefaults()), Vn.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Vn.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    return super._set(e, n), e === "radius" && this.setRadius(n), this;
  }
  _render(e) {
    e.beginPath(), e.arc(0, 0, this.radius, _e(this.startAngle), _e(this.endAngle), this.counterClockwise), this._renderPaintInOrder(e);
  }
  getRadiusX() {
    return this.get("radius") * this.get(Ke);
  }
  getRadiusY() {
    return this.get("radius") * this.get(an);
  }
  setRadius(e) {
    this.radius = e, this.set({ width: 2 * e, height: 2 * e });
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...qd, ...e]);
  }
  _toSVG() {
    const e = (this.endAngle - this.startAngle) % 360;
    if (e === 0) return ["<circle ", "COMMON_PARTS", 'cx="0" cy="0" ', 'r="', "".concat(this.radius), `" />
`];
    {
      const { radius: n } = this, s = _e(this.startAngle), i = _e(this.endAngle), o = ss(s) * n, a = is(s) * n, l = ss(i) * n, c = is(i) * n, u = e > 180 ? 1 : 0, h = this.counterClockwise ? 0 : 1;
      return ['<path d="M '.concat(o, " ").concat(a, " A ").concat(n, " ").concat(n, " 0 ").concat(u, " ").concat(h, " ").concat(l, " ").concat(c, '" '), "COMMON_PARTS", ` />
`];
    }
  }
  static async fromElement(e, n, s) {
    const i = cs(e, this.ATTRIBUTE_NAMES, s), { left: o = 0, top: a = 0, radius: l = 0 } = i;
    return new this(st(st({}, ue(i, aT)), {}, { radius: l, left: o - l, top: a - l }));
  }
  static fromObject(e) {
    return super._fromObject(e);
  }
}
nt(Vn, "type", "Circle"), nt(Vn, "cacheProperties", [...ls, ...qd]), nt(Vn, "ownDefaults", { radius: 0, startAngle: 0, endAngle: 360, counterClockwise: !1 }), nt(Vn, "ATTRIBUTE_NAMES", ["cx", "cy", "r", ...Ts]), Et.setClass(Vn), Et.setSVGClass(Vn);
const lT = ["x1", "y1", "x2", "y2"], cT = ["x1", "y1", "x2", "y2"], bl = ["x1", "x2", "y1", "y2"];
class zs extends Ie {
  constructor() {
    let [e, n, s, i] = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0, 0], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, zs.ownDefaults), this.setOptions(o), this.x1 = e, this.x2 = s, this.y1 = n, this.y2 = i, this._setWidthHeight();
    const { left: a, top: l } = o;
    typeof a == "number" && this.set(Jt, a), typeof l == "number" && this.set(Xe, l);
  }
  _setWidthHeight() {
    const { x1: e, y1: n, x2: s, y2: i } = this;
    this.width = Math.abs(s - e), this.height = Math.abs(i - n);
    const { left: o, top: a, width: l, height: c } = Zn([{ x: e, y: n }, { x: s, y: i }]), u = new mt(o + l / 2, a + c / 2);
    this.setPositionByOrigin(u, Ut, Ut);
  }
  _set(e, n) {
    return super._set(e, n), bl.includes(e) && this._setWidthHeight(), this;
  }
  _render(e) {
    e.beginPath();
    const n = this.calcLinePoints();
    e.moveTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineWidth = this.strokeWidth;
    const s = e.strokeStyle;
    var i;
    rn(this.stroke) ? e.strokeStyle = this.stroke.toLive(e) : e.strokeStyle = (i = this.stroke) !== null && i !== void 0 ? i : e.fillStyle, this.stroke && this._renderStroke(e), e.strokeStyle = s;
  }
  _findCenterFromElement() {
    return new mt((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return st(st({}, super.toObject(e)), this.calcLinePoints());
  }
  _getNonTransformedDimensions() {
    const e = super._getNonTransformedDimensions();
    return this.strokeLineCap === "butt" && (this.width === 0 && (e.y -= this.strokeWidth), this.height === 0 && (e.x -= this.strokeWidth)), e;
  }
  calcLinePoints() {
    const { x1: e, x2: n, y1: s, y2: i, width: o, height: a } = this, l = e <= n ? -1 : 1, c = s <= i ? -1 : 1;
    return { x1: l * o / 2, x2: l * -o / 2, y1: c * a / 2, y2: c * -a / 2 };
  }
  _toSVG() {
    const { x1: e, x2: n, y1: s, y2: i } = this.calcLinePoints();
    return ["<line ", "COMMON_PARTS", 'x1="'.concat(e, '" y1="').concat(s, '" x2="').concat(n, '" y2="').concat(i, `" />
`)];
  }
  static async fromElement(e, n, s) {
    const i = cs(e, this.ATTRIBUTE_NAMES, s), { x1: o = 0, y1: a = 0, x2: l = 0, y2: c = 0 } = i;
    return new this([o, a, l, c], ue(i, lT));
  }
  static fromObject(e) {
    let { x1: n, y1: s, x2: i, y2: o } = e, a = ue(e, cT);
    return this._fromObject(st(st({}, a), {}, { points: [n, s, i, o] }), { extraParam: "points" });
  }
}
nt(zs, "type", "Line"), nt(zs, "cacheProperties", [...ls, ...bl]), nt(zs, "ATTRIBUTE_NAMES", Ts.concat(bl)), Et.setClass(zs), Et.setSVGClass(zs);
class Bs extends Ie {
  static getDefaults() {
    return st(st({}, super.getDefaults()), Bs.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, Bs.ownDefaults), this.setOptions(e);
  }
  _render(e) {
    const n = this.width / 2, s = this.height / 2;
    e.beginPath(), e.moveTo(-n, s), e.lineTo(0, -s), e.lineTo(n, s), e.closePath(), this._renderPaintInOrder(e);
  }
  _toSVG() {
    const e = this.width / 2, n = this.height / 2;
    return ["<polygon ", "COMMON_PARTS", 'points="', "".concat(-e, " ").concat(n, ",0 ").concat(-n, ",").concat(e, " ").concat(n), '" />'];
  }
}
nt(Bs, "type", "Triangle"), nt(Bs, "ownDefaults", { width: 100, height: 100 }), Et.setClass(Bs), Et.setSVGClass(Bs);
const Zd = ["rx", "ry"];
class $n extends Ie {
  static getDefaults() {
    return st(st({}, super.getDefaults()), $n.ownDefaults);
  }
  constructor(e) {
    super(), Object.assign(this, $n.ownDefaults), this.setOptions(e);
  }
  _set(e, n) {
    switch (super._set(e, n), e) {
      case "rx":
        this.rx = n, this.set("width", 2 * n);
        break;
      case "ry":
        this.ry = n, this.set("height", 2 * n);
    }
    return this;
  }
  getRx() {
    return this.get("rx") * this.get(Ke);
  }
  getRy() {
    return this.get("ry") * this.get(an);
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject([...Zd, ...e]);
  }
  _toSVG() {
    return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" rx="'.concat(this.rx, '" ry="').concat(this.ry, `" />
`)];
  }
  _render(e) {
    e.beginPath(), e.save(), e.transform(1, 0, 0, this.ry / this.rx, 0, 0), e.arc(0, 0, this.rx, 0, Eo, !1), e.restore(), this._renderPaintInOrder(e);
  }
  static async fromElement(e, n, s) {
    const i = cs(e, this.ATTRIBUTE_NAMES, s);
    return i.left = (i.left || 0) - i.rx, i.top = (i.top || 0) - i.ry, new this(i);
  }
}
function uT(r) {
  if (!r) return [];
  const e = r.replace(/,/g, " ").trim().split(/\s+/), n = [];
  for (let s = 0; s < e.length; s += 2) n.push({ x: parseFloat(e[s]), y: parseFloat(e[s + 1]) });
  return n;
}
nt($n, "type", "Ellipse"), nt($n, "cacheProperties", [...ls, ...Zd]), nt($n, "ownDefaults", { rx: 0, ry: 0 }), nt($n, "ATTRIBUTE_NAMES", [...Ts, "cx", "cy", "rx", "ry"]), Et.setClass($n), Et.setSVGClass($n);
const hT = ["left", "top"], Jd = { exactBoundingBox: !1 };
class fn extends Ie {
  static getDefaults() {
    return st(st({}, super.getDefaults()), fn.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), nt(this, "strokeDiff", void 0), Object.assign(this, fn.ownDefaults), this.setOptions(n), this.points = e;
    const { left: s, top: i } = n;
    this.initialized = !0, this.setBoundingBox(!0), typeof s == "number" && this.set(Jt, s), typeof i == "number" && this.set(Xe, i);
  }
  isOpen() {
    return !0;
  }
  _projectStrokeOnPoints(e) {
    return tk(this.points, e, this.isOpen());
  }
  _calcDimensions(e) {
    e = st({ scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, strokeLineCap: this.strokeLineCap, strokeLineJoin: this.strokeLineJoin, strokeMiterLimit: this.strokeMiterLimit, strokeUniform: this.strokeUniform, strokeWidth: this.strokeWidth }, e || {});
    const n = this.exactBoundingBox ? this._projectStrokeOnPoints(e).map((u) => u.projectedPoint) : this.points;
    if (n.length === 0) return { left: 0, top: 0, width: 0, height: 0, pathOffset: new mt(), strokeOffset: new mt(), strokeDiff: new mt() };
    const s = Zn(n), i = aa(st(st({}, e), {}, { scaleX: 1, scaleY: 1 })), o = Zn(this.points.map((u) => Ue(u, i, !0))), a = new mt(this.scaleX, this.scaleY);
    let l = s.left + s.width / 2, c = s.top + s.height / 2;
    return this.exactBoundingBox && (l -= c * Math.tan(_e(this.skewX)), c -= l * Math.tan(_e(this.skewY))), st(st({}, s), {}, { pathOffset: new mt(l, c), strokeOffset: new mt(o.left, o.top).subtract(new mt(s.left, s.top)).multiply(a), strokeDiff: new mt(s.width, s.height).subtract(new mt(o.width, o.height)).multiply(a) });
  }
  _findCenterFromElement() {
    const e = Zn(this.points);
    return new mt(e.left + e.width / 2, e.top + e.height / 2);
  }
  setDimensions() {
    this.setBoundingBox();
  }
  setBoundingBox(e) {
    const { left: n, top: s, width: i, height: o, pathOffset: a, strokeOffset: l, strokeDiff: c } = this._calcDimensions();
    this.set({ width: i, height: o, pathOffset: a, strokeOffset: l, strokeDiff: c }), e && this.setPositionByOrigin(new mt(n + i / 2, s + o / 2), Ut, Ut);
  }
  isStrokeAccountedForInDimensions() {
    return this.exactBoundingBox;
  }
  _getNonTransformedDimensions() {
    return this.exactBoundingBox ? new mt(this.width, this.height) : super._getNonTransformedDimensions();
  }
  _getTransformedDimensions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this.exactBoundingBox) {
      let a;
      if (Object.keys(e).some((l) => this.strokeUniform || this.constructor.layoutProperties.includes(l))) {
        var n, s;
        const { width: l, height: c } = this._calcDimensions(e);
        a = new mt((n = e.width) !== null && n !== void 0 ? n : l, (s = e.height) !== null && s !== void 0 ? s : c);
      } else {
        var i, o;
        a = new mt((i = e.width) !== null && i !== void 0 ? i : this.width, (o = e.height) !== null && o !== void 0 ? o : this.height);
      }
      return a.multiply(new mt(e.scaleX || this.scaleX, e.scaleY || this.scaleY));
    }
    return super._getTransformedDimensions(e);
  }
  _set(e, n) {
    const s = this.initialized && this[e] !== n, i = super._set(e, n);
    return this.exactBoundingBox && s && ((e === Ke || e === an) && this.strokeUniform && this.constructor.layoutProperties.includes("strokeUniform") || this.constructor.layoutProperties.includes(e)) && this.setDimensions(), i;
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return st(st({}, super.toObject(e)), {}, { points: this.points.map((n) => {
      let { x: s, y: i } = n;
      return { x: s, y: i };
    }) });
  }
  _toSVG() {
    const e = [], n = this.pathOffset.x, s = this.pathOffset.y, i = Gt.NUM_FRACTION_DIGITS;
    for (let o = 0, a = this.points.length; o < a; o++) e.push(le(this.points[o].x - n, i), ",", le(this.points[o].y - s, i), " ");
    return ["<".concat(this.constructor.type.toLowerCase(), " "), "COMMON_PARTS", 'points="'.concat(e.join(""), `" />
`)];
  }
  _render(e) {
    const n = this.points.length, s = this.pathOffset.x, i = this.pathOffset.y;
    if (n && !isNaN(this.points[n - 1].y)) {
      e.beginPath(), e.moveTo(this.points[0].x - s, this.points[0].y - i);
      for (let o = 0; o < n; o++) {
        const a = this.points[o];
        e.lineTo(a.x - s, a.y - i);
      }
      !this.isOpen() && e.closePath(), this._renderPaintInOrder(e);
    }
  }
  complexity() {
    return this.points.length;
  }
  static async fromElement(e, n, s) {
    return new this(uT(e.getAttribute("points")), st(st({}, ue(cs(e, this.ATTRIBUTE_NAMES, s), hT)), n));
  }
  static fromObject(e) {
    return this._fromObject(e, { extraParam: "points" });
  }
}
nt(fn, "ownDefaults", Jd), nt(fn, "type", "Polyline"), nt(fn, "layoutProperties", [ki, Ti, "strokeLineCap", "strokeLineJoin", "strokeMiterLimit", "strokeWidth", "strokeUniform", "points"]), nt(fn, "cacheProperties", [...ls, "points"]), nt(fn, "ATTRIBUTE_NAMES", [...Ts]), Et.setClass(fn), Et.setSVGClass(fn);
class jr extends fn {
  isOpen() {
    return !1;
  }
}
nt(jr, "ownDefaults", Jd), nt(jr, "type", "Polygon"), Et.setClass(jr), Et.setSVGClass(jr);
class Qd extends Ie {
  isEmptyStyles(e) {
    if (!this.styles || e !== void 0 && !this.styles[e]) return !0;
    const n = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const s in n) for (const i in n[s]) for (const o in n[s][i]) return !1;
    return !0;
  }
  styleHas(e, n) {
    if (!this.styles || n !== void 0 && !this.styles[n]) return !1;
    const s = n === void 0 ? this.styles : { 0: this.styles[n] };
    for (const i in s) for (const o in s[i]) if (s[i][o][e] !== void 0) return !0;
    return !1;
  }
  cleanStyle(e) {
    if (!this.styles) return !1;
    const n = this.styles;
    let s, i, o = 0, a = !0, l = 0;
    for (const c in n) {
      s = 0;
      for (const u in n[c]) {
        const h = n[c][u] || {};
        o++, h[e] !== void 0 ? (i ? h[e] !== i && (a = !1) : i = h[e], h[e] === this[e] && delete h[e]) : a = !1, Object.keys(h).length !== 0 ? s++ : delete n[c][u];
      }
      s === 0 && delete n[c];
    }
    for (let c = 0; c < this._textLines.length; c++) l += this._textLines[c].length;
    a && o === l && (this[e] = i, this.removeStyle(e));
  }
  removeStyle(e) {
    if (!this.styles) return;
    const n = this.styles;
    let s, i, o;
    for (i in n) {
      for (o in s = n[i], s) delete s[o][e], Object.keys(s[o]).length === 0 && delete s[o];
      Object.keys(s).length === 0 && delete n[i];
    }
  }
  _extendStyles(e, n) {
    const { lineIndex: s, charIndex: i } = this.get2DCursorLocation(e);
    this._getLineStyle(s) || this._setLineStyle(s);
    const o = Xl(st(st({}, this._getStyleDeclaration(s, i)), n), (a) => a !== void 0);
    this._setStyleDeclaration(s, i, o);
  }
  getSelectionStyles(e, n, s) {
    const i = [];
    for (let o = e; o < (n || e); o++) i.push(this.getStyleAtPosition(o, s));
    return i;
  }
  getStyleAtPosition(e, n) {
    const { lineIndex: s, charIndex: i } = this.get2DCursorLocation(e);
    return n ? this.getCompleteStyleDeclaration(s, i) : this._getStyleDeclaration(s, i);
  }
  setSelectionStyles(e, n, s) {
    for (let i = n; i < (s || n); i++) this._extendStyles(i, e);
    this._forceClearCache = !0;
  }
  _getStyleDeclaration(e, n) {
    var s;
    const i = this.styles && this.styles[e];
    return i && (s = i[n]) !== null && s !== void 0 ? s : {};
  }
  getCompleteStyleDeclaration(e, n) {
    return st(st({}, Oi(this, this.constructor._styleProperties)), this._getStyleDeclaration(e, n));
  }
  _setStyleDeclaration(e, n, s) {
    this.styles[e][n] = s;
  }
  _deleteStyleDeclaration(e, n) {
    delete this.styles[e][n];
  }
  _getLineStyle(e) {
    return !!this.styles[e];
  }
  _setLineStyle(e) {
    this.styles[e] = {};
  }
  _deleteLineStyle(e) {
    delete this.styles[e];
  }
}
nt(Qd, "_styleProperties", gC);
const dT = /  +/g, fT = /"/g;
function Va(r, e, n, s, i) {
  return "		".concat(function(o, a) {
    let { left: l, top: c, width: u, height: h } = a, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Gt.NUM_FRACTION_DIGITS;
    const m = fr(Te, o, !1), [p, y, v, _] = [l, c, u, h].map((g) => le(g, f));
    return "<rect ".concat(m, ' x="').concat(p, '" y="').concat(y, '" width="').concat(v, '" height="').concat(_, '"></rect>');
  }(r, { left: e, top: n, width: s, height: i }), `
`);
}
const pT = ["textAnchor", "textDecoration", "dx", "dy", "top", "left", "fontSize", "strokeWidth"];
let $a;
class je extends Qd {
  static getDefaults() {
    return st(st({}, super.getDefaults()), je.ownDefaults);
  }
  constructor(e, n) {
    super(), nt(this, "__charBounds", []), Object.assign(this, je.ownDefaults), this.setOptions(n), this.styles || (this.styles = {}), this.text = e, this.initialized = !0, this.path && this.setPathInfo(), this.initDimensions(), this.setCoords();
  }
  setPathInfo() {
    const e = this.path;
    e && (e.segmentsInfo = Ud(e.path));
  }
  _splitText() {
    const e = this._splitTextIntoLines(this.text);
    return this.textLines = e.lines, this._textLines = e.graphemeLines, this._unwrappedTextLines = e._unwrappedLines, this._text = e.graphemeText, e;
  }
  initDimensions() {
    this._splitText(), this._clearCache(), this.dirty = !0, this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), this.textAlign.includes(En) && this.enlargeSpaces();
  }
  enlargeSpaces() {
    let e, n, s, i, o, a, l;
    for (let c = 0, u = this._textLines.length; c < u; c++) if ((this.textAlign === En || c !== u - 1 && !this.isEndOfWrapping(c)) && (i = 0, o = this._textLines[c], n = this.getLineWidth(c), n < this.width && (l = this.textLines[c].match(this._reSpacesAndTabs)))) {
      s = l.length, e = (this.width - n) / s;
      for (let h = 0; h <= o.length; h++) a = this.__charBounds[c][h], this._reSpaceAndTab.test(o[h]) ? (a.width += e, a.kernedWidth += e, a.left += i, i += e) : a.left += i;
    }
  }
  isEndOfWrapping(e) {
    return e === this._textLines.length - 1;
  }
  missingNewlineOffset(e) {
    return 1;
  }
  get2DCursorLocation(e, n) {
    const s = n ? this._unwrappedTextLines : this._textLines;
    let i;
    for (i = 0; i < s.length; i++) {
      if (e <= s[i].length) return { lineIndex: i, charIndex: e };
      e -= s[i].length + this.missingNewlineOffset(i, n);
    }
    return { lineIndex: i - 1, charIndex: s[i - 1].length < e ? s[i - 1].length : e };
  }
  toString() {
    return "#<Text (".concat(this.complexity(), '): { "text": "').concat(this.text, '", "fontFamily": "').concat(this.fontFamily, '" }>');
  }
  _getCacheCanvasDimensions() {
    const e = super._getCacheCanvasDimensions(), n = this.fontSize;
    return e.width += n * e.zoomX, e.height += n * e.zoomY, e;
  }
  _render(e) {
    const n = this.path;
    n && !n.isNotVisible() && n._render(e), this._setTextStyles(e), this._renderTextLinesBackground(e), this._renderTextDecoration(e, "underline"), this._renderText(e), this._renderTextDecoration(e, "overline"), this._renderTextDecoration(e, "linethrough");
  }
  _renderText(e) {
    this.paintFirst === Ye ? (this._renderTextStroke(e), this._renderTextFill(e)) : (this._renderTextFill(e), this._renderTextStroke(e));
  }
  _setTextStyles(e, n, s) {
    if (e.textBaseline = "alphabetic", this.path) switch (this.pathAlign) {
      case Ut:
        e.textBaseline = "middle";
        break;
      case "ascender":
        e.textBaseline = Xe;
        break;
      case "descender":
        e.textBaseline = ll;
    }
    e.font = this._getFontDeclaration(n, s);
  }
  calcTextWidth() {
    let e = this.getLineWidth(0);
    for (let n = 1, s = this._textLines.length; n < s; n++) {
      const i = this.getLineWidth(n);
      i > e && (e = i);
    }
    return e;
  }
  _renderTextLine(e, n, s, i, o, a) {
    this._renderChars(e, n, s, i, o, a);
  }
  _renderTextLinesBackground(e) {
    if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) return;
    const n = e.fillStyle, s = this._getLeftOffset();
    let i = this._getTopOffset();
    for (let o = 0, a = this._textLines.length; o < a; o++) {
      const l = this.getHeightOfLine(o);
      if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", o)) {
        i += l;
        continue;
      }
      const c = this._textLines[o].length, u = this._getLineLeftOffset(o);
      let h, f, m = 0, p = 0, y = this.getValueOfPropertyAt(o, 0, "textBackgroundColor");
      const v = this.getHeightOfLineImpl(o);
      for (let _ = 0; _ < c; _++) {
        const g = this.__charBounds[o][_];
        f = this.getValueOfPropertyAt(o, _, "textBackgroundColor"), this.path ? (e.save(), e.translate(g.renderLeft, g.renderTop), e.rotate(g.angle), e.fillStyle = f, f && e.fillRect(-g.width / 2, -v * (1 - this._fontSizeFraction), g.width, v), e.restore()) : f !== y ? (h = s + u + p, this.direction === "rtl" && (h = this.width - h - m), e.fillStyle = y, y && e.fillRect(h, i, m, v), p = g.left, m = g.width, y = f) : m += g.kernedWidth;
      }
      f && !this.path && (h = s + u + p, this.direction === "rtl" && (h = this.width - h - m), e.fillStyle = f, e.fillRect(h, i, m, v)), i += l;
    }
    e.fillStyle = n, this._removeShadow(e);
  }
  _measureChar(e, n, s, i) {
    const o = Ji.getFontCache(n), a = this._getFontDeclaration(n), l = s + e, c = s && a === this._getFontDeclaration(i), u = n.fontSize / this.CACHE_FONT_SIZE;
    let h, f, m, p;
    if (s && o.has(s) && (m = o.get(s)), o.has(e) && (p = h = o.get(e)), c && o.has(l) && (f = o.get(l), p = f - m), h === void 0 || m === void 0 || f === void 0) {
      const y = function() {
        return $a || ($a = ln({ width: 0, height: 0 }).getContext("2d")), $a;
      }();
      this._setTextStyles(y, n, !0), h === void 0 && (p = h = y.measureText(e).width, o.set(e, h)), m === void 0 && c && s && (m = y.measureText(s).width, o.set(s, m)), c && f === void 0 && (f = y.measureText(l).width, o.set(l, f), p = f - m);
    }
    return { width: h * u, kernedWidth: p * u };
  }
  getHeightOfChar(e, n) {
    return this.getValueOfPropertyAt(e, n, "fontSize");
  }
  measureLine(e) {
    const n = this._measureLine(e);
    return this.charSpacing !== 0 && (n.width -= this._getWidthOfCharSpacing()), n.width < 0 && (n.width = 0), n;
  }
  _measureLine(e) {
    let n, s, i = 0;
    const o = this.pathSide === be, a = this.path, l = this._textLines[e], c = l.length, u = new Array(c);
    this.__charBounds[e] = u;
    for (let h = 0; h < c; h++) {
      const f = l[h];
      s = this._getGraphemeBox(f, e, h, n), u[h] = s, i += s.kernedWidth, n = f;
    }
    if (u[c] = { left: s ? s.left + s.width : 0, width: 0, kernedWidth: 0, height: this.fontSize, deltaY: 0 }, a && a.segmentsInfo) {
      let h = 0;
      const f = a.segmentsInfo[a.segmentsInfo.length - 1].length;
      switch (this.textAlign) {
        case Jt:
          h = o ? f - i : 0;
          break;
        case Ut:
          h = (f - i) / 2;
          break;
        case be:
          h = o ? 0 : f - i;
      }
      h += this.pathStartOffset * (o ? -1 : 1);
      for (let m = o ? c - 1 : 0; o ? m >= 0 : m < c; o ? m-- : m++) s = u[m], h > f ? h %= f : h < 0 && (h += f), this._setGraphemeOnPath(h, s), h += s.kernedWidth;
    }
    return { width: i, numOfSpaces: 0 };
  }
  _setGraphemeOnPath(e, n) {
    const s = e + n.kernedWidth / 2, i = this.path, o = Nk(i.path, s, i.segmentsInfo);
    n.renderLeft = o.x - i.pathOffset.x, n.renderTop = o.y - i.pathOffset.y, n.angle = o.angle + (this.pathSide === be ? Math.PI : 0);
  }
  _getGraphemeBox(e, n, s, i, o) {
    const a = this.getCompleteStyleDeclaration(n, s), l = i ? this.getCompleteStyleDeclaration(n, s - 1) : {}, c = this._measureChar(e, a, i, l);
    let u, h = c.kernedWidth, f = c.width;
    this.charSpacing !== 0 && (u = this._getWidthOfCharSpacing(), f += u, h += u);
    const m = { width: f, left: 0, height: a.fontSize, kernedWidth: h, deltaY: a.deltaY };
    if (s > 0 && !o) {
      const p = this.__charBounds[n][s - 1];
      m.left = p.left + p.width + c.kernedWidth - c.width;
    }
    return m;
  }
  getHeightOfLineImpl(e) {
    const n = this.__lineHeights;
    if (n[e]) return n[e];
    let s = this.getHeightOfChar(e, 0);
    for (let i = 1, o = this._textLines[e].length; i < o; i++) s = Math.max(this.getHeightOfChar(e, i), s);
    return n[e] = s * this._fontSizeMult;
  }
  getHeightOfLine(e) {
    return this.getHeightOfLineImpl(e) * this.lineHeight;
  }
  calcTextHeight() {
    let e = 0;
    for (let n = 0, s = this._textLines.length; n < s; n++) e += n === s - 1 ? this.getHeightOfLineImpl(n) : this.getHeightOfLine(n);
    return e;
  }
  _getLeftOffset() {
    return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
  }
  _getTopOffset() {
    return -this.height / 2;
  }
  _renderTextCommon(e, n) {
    e.save();
    let s = 0;
    const i = this._getLeftOffset(), o = this._getTopOffset();
    for (let a = 0, l = this._textLines.length; a < l; a++) this._renderTextLine(n, e, this._textLines[a], i + this._getLineLeftOffset(a), o + s + this.getHeightOfLineImpl(a), a), s += this.getHeightOfLine(a);
    e.restore();
  }
  _renderTextFill(e) {
    (this.fill || this.styleHas(Te)) && this._renderTextCommon(e, "fillText");
  }
  _renderTextStroke(e) {
    (this.stroke && this.strokeWidth !== 0 || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(e), e.save(), this._setLineDash(e, this.strokeDashArray), e.beginPath(), this._renderTextCommon(e, "strokeText"), e.closePath(), e.restore());
  }
  _renderChars(e, n, s, i, o, a) {
    const l = this.textAlign.includes(En), c = this.path, u = !l && this.charSpacing === 0 && this.isEmptyStyles(a) && !c, h = this.direction === "ltr", f = this.direction === "ltr" ? 1 : -1, m = n.direction;
    let p, y, v, _, g, C = "", x = 0;
    if (n.save(), m !== this.direction && (n.canvas.setAttribute("dir", h ? "ltr" : "rtl"), n.direction = h ? "ltr" : "rtl", n.textAlign = h ? Jt : be), o -= this.getHeightOfLineImpl(a) * this._fontSizeFraction, u) return this._renderChar(e, n, a, 0, s.join(""), i, o), void n.restore();
    for (let k = 0, w = s.length - 1; k <= w; k++) _ = k === w || this.charSpacing || c, C += s[k], v = this.__charBounds[a][k], x === 0 ? (i += f * (v.kernedWidth - v.width), x += v.width) : x += v.kernedWidth, l && !_ && this._reSpaceAndTab.test(s[k]) && (_ = !0), _ || (p = p || this.getCompleteStyleDeclaration(a, k), y = this.getCompleteStyleDeclaration(a, k + 1), _ = tc(p, y, !1)), _ && (c ? (n.save(), n.translate(v.renderLeft, v.renderTop), n.rotate(v.angle), this._renderChar(e, n, a, k, C, -x / 2, 0), n.restore()) : (g = i, this._renderChar(e, n, a, k, C, g, o)), C = "", p = y, i += f * x, x = 0);
    n.restore();
  }
  _applyPatternGradientTransformText(e) {
    const n = this.width + this.strokeWidth, s = this.height + this.strokeWidth, i = ln({ width: n, height: s }), o = i.getContext("2d");
    return i.width = n, i.height = s, o.beginPath(), o.moveTo(0, 0), o.lineTo(n, 0), o.lineTo(n, s), o.lineTo(0, s), o.closePath(), o.translate(n / 2, s / 2), o.fillStyle = e.toLive(o), this._applyPatternGradientTransform(o, e), o.fill(), o.createPattern(i, "no-repeat");
  }
  handleFiller(e, n, s) {
    let i, o;
    return rn(s) ? s.gradientUnits === "percentage" || s.gradientTransform || s.patternTransform ? (i = -this.width / 2, o = -this.height / 2, e.translate(i, o), e[n] = this._applyPatternGradientTransformText(s), { offsetX: i, offsetY: o }) : (e[n] = s.toLive(e), this._applyPatternGradientTransform(e, s)) : (e[n] = s, { offsetX: 0, offsetY: 0 });
  }
  _setStrokeStyles(e, n) {
    let { stroke: s, strokeWidth: i } = n;
    return e.lineWidth = i, e.lineCap = this.strokeLineCap, e.lineDashOffset = this.strokeDashOffset, e.lineJoin = this.strokeLineJoin, e.miterLimit = this.strokeMiterLimit, this.handleFiller(e, "strokeStyle", s);
  }
  _setFillStyles(e, n) {
    let { fill: s } = n;
    return this.handleFiller(e, "fillStyle", s);
  }
  _renderChar(e, n, s, i, o, a, l) {
    const c = this._getStyleDeclaration(s, i), u = this.getCompleteStyleDeclaration(s, i), h = e === "fillText" && u.fill, f = e === "strokeText" && u.stroke && u.strokeWidth;
    if (f || h) {
      if (n.save(), n.font = this._getFontDeclaration(u), c.textBackgroundColor && this._removeShadow(n), c.deltaY && (l += c.deltaY), h) {
        const m = this._setFillStyles(n, u);
        n.fillText(o, a - m.offsetX, l - m.offsetY);
      }
      if (f) {
        const m = this._setStrokeStyles(n, u);
        n.strokeText(o, a - m.offsetX, l - m.offsetY);
      }
      n.restore();
    }
  }
  setSuperscript(e, n) {
    this._setScript(e, n, this.superscript);
  }
  setSubscript(e, n) {
    this._setScript(e, n, this.subscript);
  }
  _setScript(e, n, s) {
    const i = this.get2DCursorLocation(e, !0), o = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "fontSize"), a = this.getValueOfPropertyAt(i.lineIndex, i.charIndex, "deltaY"), l = { fontSize: o * s.size, deltaY: a + o * s.baseline };
    this.setSelectionStyles(l, e, n);
  }
  _getLineLeftOffset(e) {
    const n = this.getLineWidth(e), s = this.width - n, i = this.textAlign, o = this.direction, a = this.isEndOfWrapping(e);
    let l = 0;
    return i === En || i === tr && !a || i === Qi && !a || i === zo && !a ? 0 : (i === Ut && (l = s / 2), i === be && (l = s), i === tr && (l = s / 2), i === Qi && (l = s), o === "rtl" && (i === be || i === En || i === Qi ? l = 0 : i === Jt || i === zo ? l = -s : i !== Ut && i !== tr || (l = -s / 2)), l);
  }
  _clearCache() {
    this._forceClearCache = !1, this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [];
  }
  getLineWidth(e) {
    if (this.__lineWidths[e] !== void 0) return this.__lineWidths[e];
    const { width: n } = this.measureLine(e);
    return this.__lineWidths[e] = n, n;
  }
  _getWidthOfCharSpacing() {
    return this.charSpacing !== 0 ? this.fontSize * this.charSpacing / 1e3 : 0;
  }
  getValueOfPropertyAt(e, n, s) {
    var i;
    return (i = this._getStyleDeclaration(e, n)[s]) !== null && i !== void 0 ? i : this[s];
  }
  _renderTextDecoration(e, n) {
    if (!this[n] && !this.styleHas(n)) return;
    let s = this._getTopOffset();
    const i = this._getLeftOffset(), o = this.path, a = this._getWidthOfCharSpacing(), l = n === "linethrough" ? 0.5 : n === "overline" ? 1 : 0, c = this.offsets[n];
    for (let u = 0, h = this._textLines.length; u < h; u++) {
      const f = this.getHeightOfLine(u);
      if (!this[n] && !this.styleHas(n, u)) {
        s += f;
        continue;
      }
      const m = this._textLines[u], p = f / this.lineHeight, y = this._getLineLeftOffset(u);
      let v = 0, _ = 0, g = this.getValueOfPropertyAt(u, 0, n), C = this.getValueOfPropertyAt(u, 0, Te), x = this.getValueOfPropertyAt(u, 0, Hs), k = g, w = C, T = x;
      const P = s + p * (1 - this._fontSizeFraction);
      let z = this.getHeightOfChar(u, 0), j = this.getValueOfPropertyAt(u, 0, "deltaY");
      for (let L = 0, Y = m.length; L < Y; L++) {
        const M = this.__charBounds[u][L];
        k = this.getValueOfPropertyAt(u, L, n), w = this.getValueOfPropertyAt(u, L, Te), T = this.getValueOfPropertyAt(u, L, Hs);
        const I = this.getHeightOfChar(u, L), tt = this.getValueOfPropertyAt(u, L, "deltaY");
        if (o && k && w) {
          const U = this.fontSize * T / 1e3;
          e.save(), e.fillStyle = C, e.translate(M.renderLeft, M.renderTop), e.rotate(M.angle), e.fillRect(-M.kernedWidth / 2, c * I + tt - l * U, M.kernedWidth, U), e.restore();
        } else if ((k !== g || w !== C || I !== z || T !== x || tt !== j) && _ > 0) {
          const U = this.fontSize * x / 1e3;
          let W = i + y + v;
          this.direction === "rtl" && (W = this.width - W - _), g && C && x && (e.fillStyle = C, e.fillRect(W, P + c * z + j - l * U, _, U)), v = M.left, _ = M.width, g = k, x = T, C = w, z = I, j = tt;
        } else _ += M.kernedWidth;
      }
      let ot = i + y + v;
      this.direction === "rtl" && (ot = this.width - ot - _), e.fillStyle = w;
      const vt = this.fontSize * T / 1e3;
      k && w && T && e.fillRect(ot, P + c * z + j - l * vt, _ - a, vt), s += f;
    }
    this._removeShadow(e);
  }
  _getFontDeclaration() {
    let { fontFamily: e = this.fontFamily, fontStyle: n = this.fontStyle, fontWeight: s = this.fontWeight, fontSize: i = this.fontSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
    const a = e.includes("'") || e.includes('"') || e.includes(",") || je.genericFonts.includes(e.toLowerCase()) ? e : '"'.concat(e, '"');
    return [n, s, "".concat(o ? this.CACHE_FONT_SIZE : i, "px"), a].join(" ");
  }
  render(e) {
    this.visible && (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen() || (this._forceClearCache && this.initDimensions(), super.render(e)));
  }
  graphemeSplit(e) {
    return Ql(e);
  }
  _splitTextIntoLines(e) {
    const n = e.split(this._reNewline), s = new Array(n.length), i = [`
`];
    let o = [];
    for (let a = 0; a < n.length; a++) s[a] = this.graphemeSplit(n[a]), o = o.concat(s[a], i);
    return o.pop(), { _unwrappedLines: s, lines: n, graphemeText: o, graphemeLines: s };
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return st(st({}, super.toObject([...Td, ...e])), {}, { styles: ik(this.styles, this.text) }, this.path ? { path: this.path.toObject() } : {});
  }
  set(e, n) {
    const { textLayoutProperties: s } = this.constructor;
    super.set(e, n);
    let i = !1, o = !1;
    if (typeof e == "object") for (const a in e) a === "path" && this.setPathInfo(), i = i || s.includes(a), o = o || a === "path";
    else i = s.includes(e), o = e === "path";
    return o && this.setPathInfo(), i && this.initialized && (this.initDimensions(), this.setCoords()), this;
  }
  complexity() {
    return 1;
  }
  static async fromElement(e, n, s) {
    const i = cs(e, je.ATTRIBUTE_NAMES, s), o = st(st({}, n), i), { textAnchor: a = Jt, textDecoration: l = "", dx: c = 0, dy: u = 0, top: h = 0, left: f = 0, fontSize: m = Vl, strokeWidth: p = 1 } = o, y = ue(o, pT), v = new this(Ro(e.textContent || "").trim(), st({ left: f + c, top: h + u, underline: l.includes("underline"), overline: l.includes("overline"), linethrough: l.includes("line-through"), strokeWidth: 0, fontSize: m }, y)), _ = v.getScaledHeight() / v.height, g = ((v.height + v.strokeWidth) * v.lineHeight - v.height) * _, C = v.getScaledHeight() + g;
    let x = 0;
    return a === Ut && (x = v.getScaledWidth() / 2), a === be && (x = v.getScaledWidth()), v.set({ left: v.left - x, top: v.top - (C - v.fontSize * (0.07 + v._fontSizeFraction)) / v.lineHeight, strokeWidth: p }), v;
  }
  static fromObject(e) {
    return this._fromObject(st(st({}, e), {}, { styles: rk(e.styles || {}, e.text) }), { extraParam: "text" });
  }
}
nt(je, "textLayoutProperties", kd), nt(je, "cacheProperties", [...ls, ...Td]), nt(je, "ownDefaults", vC), nt(je, "type", "Text"), nt(je, "genericFonts", ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui", "ui-serif", "ui-sans-serif", "ui-monospace", "ui-rounded", "math", "emoji", "fangsong"]), nt(je, "ATTRIBUTE_NAMES", Ts.concat("x", "y", "dx", "dy", "font-family", "font-style", "font-weight", "font-size", "letter-spacing", "text-decoration", "text-anchor")), Ld(je, [class extends wd {
  _toSVG() {
    const r = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(r.textTop, r.textLeft);
    return this._wrapSVGTextAndBg(e);
  }
  toSVG(r) {
    const e = this._createBaseSVGMarkup(this._toSVG(), { reviver: r, noStyle: !0, withShadow: !0 }), n = this.path;
    return n ? e + n._createBaseSVGMarkup(n._toSVG(), { reviver: r, withShadow: !0, additionalTransform: dr(this.calcOwnMatrix()) }) : e;
  }
  _getSVGLeftTopOffsets() {
    return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) };
  }
  _wrapSVGTextAndBg(r) {
    let { textBgRects: e, textSpans: n } = r;
    const s = this.getSvgTextDecoration(this);
    return [e.join(""), '		<text xml:space="preserve" ', 'font-family="'.concat(this.fontFamily.replace(fT, "'"), '" '), 'font-size="'.concat(this.fontSize, '" '), this.fontStyle ? 'font-style="'.concat(this.fontStyle, '" ') : "", this.fontWeight ? 'font-weight="'.concat(this.fontWeight, '" ') : "", s ? 'text-decoration="'.concat(s, '" ') : "", this.direction === "rtl" ? 'direction="'.concat(this.direction, '" ') : "", 'style="', this.getSvgStyles(!0), '"', this.addPaintOrder(), " >", n.join(""), `</text>
`];
  }
  _getSVGTextAndBg(r, e) {
    const n = [], s = [];
    let i, o = r;
    this.backgroundColor && s.push(...Va(this.backgroundColor, -this.width / 2, -this.height / 2, this.width, this.height));
    for (let a = 0, l = this._textLines.length; a < l; a++) i = this._getLineLeftOffset(a), this.direction === "rtl" && (i += this.width), (this.textBackgroundColor || this.styleHas("textBackgroundColor", a)) && this._setSVGTextLineBg(s, a, e + i, o), this._setSVGTextLineText(n, a, e + i, o), o += this.getHeightOfLine(a);
    return { textSpans: n, textBgRects: s };
  }
  _createTextCharSpan(r, e, n, s, i) {
    const o = Gt.NUM_FRACTION_DIGITS, a = this.getSvgSpanStyles(e, r !== r.trim() || !!r.match(dT)), l = a ? 'style="'.concat(a, '"') : "", c = e.deltaY, u = c ? ' dy="'.concat(le(c, o), '" ') : "", { angle: h, renderLeft: f, renderTop: m, width: p } = i;
    let y = "";
    if (f !== void 0) {
      const v = p / 2;
      h && (y = ' rotate="'.concat(le(os(h), o), '"'));
      const _ = Mi({ angle: os(h) });
      _[4] = f, _[5] = m;
      const g = new mt(-v, 0).transform(_);
      n = g.x, s = g.y;
    }
    return '<tspan x="'.concat(le(n, o), '" y="').concat(le(s, o), '" ').concat(u).concat(y).concat(l, ">").concat(ek(r), "</tspan>");
  }
  _setSVGTextLineText(r, e, n, s) {
    const i = this.getHeightOfLine(e), o = this.textAlign.includes(En), a = this._textLines[e];
    let l, c, u, h, f, m = "", p = 0;
    s += i * (1 - this._fontSizeFraction) / this.lineHeight;
    for (let y = 0, v = a.length - 1; y <= v; y++) f = y === v || this.charSpacing || this.path, m += a[y], u = this.__charBounds[e][y], p === 0 ? (n += u.kernedWidth - u.width, p += u.width) : p += u.kernedWidth, o && !f && this._reSpaceAndTab.test(a[y]) && (f = !0), f || (l = l || this.getCompleteStyleDeclaration(e, y), c = this.getCompleteStyleDeclaration(e, y + 1), f = tc(l, c, !0)), f && (h = this._getStyleDeclaration(e, y), r.push(this._createTextCharSpan(m, h, n, s, u)), m = "", l = c, this.direction === "rtl" ? n -= p : n += p, p = 0);
  }
  _setSVGTextLineBg(r, e, n, s) {
    const i = this._textLines[e], o = this.getHeightOfLine(e) / this.lineHeight;
    let a, l = 0, c = 0, u = this.getValueOfPropertyAt(e, 0, "textBackgroundColor");
    for (let h = 0; h < i.length; h++) {
      const { left: f, width: m, kernedWidth: p } = this.__charBounds[e][h];
      a = this.getValueOfPropertyAt(e, h, "textBackgroundColor"), a !== u ? (u && r.push(...Va(u, n + c, s, l, o)), c = f, l = m, u = a) : l += p;
    }
    a && r.push(...Va(u, n + c, s, l, o));
  }
  _getSVGLineTopOffset(r) {
    let e, n = 0;
    for (e = 0; e < r; e++) n += this.getHeightOfLine(e);
    const s = this.getHeightOfLine(e);
    return { lineTop: n, offset: (this._fontSizeMult - this._fontSizeFraction) * s / (this.lineHeight * this._fontSizeMult) };
  }
  getSvgStyles(r) {
    return "".concat(super.getSvgStyles(r), " text-decoration-thickness: ").concat(le(this.textDecorationThickness * this.getObjectScaling().y / 10, Gt.NUM_FRACTION_DIGITS), "%; white-space: pre;");
  }
  getSvgSpanStyles(r, e) {
    const { fontFamily: n, strokeWidth: s, stroke: i, fill: o, fontSize: a, fontStyle: l, fontWeight: c, deltaY: u, textDecorationThickness: h, linethrough: f, overline: m, underline: p } = r, y = this.getSvgTextDecoration({ underline: p ?? this.underline, overline: m ?? this.overline, linethrough: f ?? this.linethrough }), v = h || this.textDecorationThickness;
    return [i ? fr(Ye, i) : "", s ? "stroke-width: ".concat(s, "; ") : "", n ? "font-family: ".concat(n.includes("'") || n.includes('"') ? n : "'".concat(n, "'"), "; ") : "", a ? "font-size: ".concat(a, "px; ") : "", l ? "font-style: ".concat(l, "; ") : "", c ? "font-weight: ".concat(c, "; ") : "", y ? "text-decoration: ".concat(y, "; text-decoration-thickness: ").concat(le(v * this.getObjectScaling().y / 10, Gt.NUM_FRACTION_DIGITS), "%; ") : "", o ? fr(Te, o) : "", u ? "baseline-shift: ".concat(-u, "; ") : "", e ? "white-space: pre; " : ""].join("");
  }
  getSvgTextDecoration(r) {
    return ["overline", "underline", "line-through"].filter((e) => r[e.replace("-", "")]).join(" ");
  }
}]), Et.setClass(je), Et.setSVGClass(je);
class mT {
  constructor(e) {
    nt(this, "target", void 0), nt(this, "__mouseDownInPlace", !1), nt(this, "__dragStartFired", !1), nt(this, "__isDraggingOver", !1), nt(this, "__dragStartSelection", void 0), nt(this, "__dragImageDisposer", void 0), nt(this, "_dispose", void 0), this.target = e;
    const n = [this.target.on("dragenter", this.dragEnterHandler.bind(this)), this.target.on("dragover", this.dragOverHandler.bind(this)), this.target.on("dragleave", this.dragLeaveHandler.bind(this)), this.target.on("dragend", this.dragEndHandler.bind(this)), this.target.on("drop", this.dropHandler.bind(this))];
    this._dispose = () => {
      n.forEach((s) => s()), this._dispose = void 0;
    };
  }
  isPointerOverSelection(e) {
    const n = this.target, s = n.getSelectionStartFromPointer(e);
    return n.isEditing && s >= n.selectionStart && s <= n.selectionEnd && n.selectionStart < n.selectionEnd;
  }
  start(e) {
    return this.__mouseDownInPlace = this.isPointerOverSelection(e);
  }
  isActive() {
    return this.__mouseDownInPlace;
  }
  end(e) {
    const n = this.isActive();
    return n && !this.__dragStartFired && (this.target.setCursorByClick(e), this.target.initDelayedCursor(!0)), this.__mouseDownInPlace = !1, this.__dragStartFired = !1, this.__isDraggingOver = !1, n;
  }
  getDragStartSelection() {
    return this.__dragStartSelection;
  }
  setDragImage(e, n) {
    var s;
    let { selectionStart: i, selectionEnd: o } = n;
    const a = this.target, l = a.canvas, c = new mt(a.flipX ? -1 : 1, a.flipY ? -1 : 1), u = a._getCursorBoundaries(i), h = new mt(u.left + u.leftOffset, u.top + u.topOffset).multiply(c).transform(a.calcTransformMatrix()), f = l.getScenePoint(e).subtract(h), m = a.getCanvasRetinaScaling(), p = a.getBoundingRect(), y = h.subtract(new mt(p.left, p.top)), v = l.viewportTransform, _ = y.add(f).transform(v, !0), g = a.backgroundColor, C = Jl(a.styles);
    a.backgroundColor = "";
    const x = { stroke: "transparent", fill: "transparent", textBackgroundColor: "transparent" };
    a.setSelectionStyles(x, 0, i), a.setSelectionStyles(x, o, a.text.length), a.dirty = !0;
    const k = a.toCanvasElement({ enableRetinaScaling: l.enableRetinaScaling, viewportTransform: !0 });
    a.backgroundColor = g, a.styles = C, a.dirty = !0, vl(k, { position: "fixed", left: "".concat(-k.width, "px"), border: Ge, width: "".concat(k.width / m, "px"), height: "".concat(k.height / m, "px") }), this.__dragImageDisposer && this.__dragImageDisposer(), this.__dragImageDisposer = () => {
      k.remove();
    }, mn(e.target || this.target.hiddenTextarea).body.appendChild(k), (s = e.dataTransfer) === null || s === void 0 || s.setDragImage(k, _.x, _.y);
  }
  onDragStart(e) {
    this.__dragStartFired = !0;
    const n = this.target, s = this.isActive();
    if (s && e.dataTransfer) {
      const i = this.__dragStartSelection = { selectionStart: n.selectionStart, selectionEnd: n.selectionEnd }, o = n._text.slice(i.selectionStart, i.selectionEnd).join(""), a = st({ text: n.text, value: o }, i);
      e.dataTransfer.setData("text/plain", o), e.dataTransfer.setData("application/fabric", JSON.stringify({ value: o, styles: n.getSelectionStyles(i.selectionStart, i.selectionEnd, !0) })), e.dataTransfer.effectAllowed = "copyMove", this.setDragImage(e, a);
    }
    return n.abortCursorAnimation(), s;
  }
  canDrop(e) {
    if (this.target.editable && !this.target.getActiveControl() && !e.defaultPrevented) {
      if (this.isActive() && this.__dragStartSelection) {
        const n = this.target.getSelectionStartFromPointer(e), s = this.__dragStartSelection;
        return n < s.selectionStart || n > s.selectionEnd;
      }
      return !0;
    }
    return !1;
  }
  targetCanDrop(e) {
    return this.target.canDrop(e);
  }
  dragEnterHandler(e) {
    let { e: n } = e;
    const s = this.targetCanDrop(n);
    !this.__isDraggingOver && s && (this.__isDraggingOver = !0);
  }
  dragOverHandler(e) {
    const { e: n } = e, s = this.targetCanDrop(n);
    !this.__isDraggingOver && s ? this.__isDraggingOver = !0 : this.__isDraggingOver && !s && (this.__isDraggingOver = !1), this.__isDraggingOver && (n.preventDefault(), e.canDrop = !0, e.dropTarget = this.target);
  }
  dragLeaveHandler() {
    (this.__isDraggingOver || this.isActive()) && (this.__isDraggingOver = !1);
  }
  dropHandler(e) {
    var n;
    const { e: s } = e, i = s.defaultPrevented;
    this.__isDraggingOver = !1, s.preventDefault();
    let o = (n = s.dataTransfer) === null || n === void 0 ? void 0 : n.getData("text/plain");
    if (o && !i) {
      const a = this.target, l = a.canvas;
      let c = a.getSelectionStartFromPointer(s);
      const { styles: u } = s.dataTransfer.types.includes("application/fabric") ? JSON.parse(s.dataTransfer.getData("application/fabric")) : {}, h = o[Math.max(0, o.length - 1)], f = 0;
      if (this.__dragStartSelection) {
        const m = this.__dragStartSelection.selectionStart, p = this.__dragStartSelection.selectionEnd;
        c > m && c <= p ? c = m : c > p && (c -= p - m), a.removeChars(m, p), delete this.__dragStartSelection;
      }
      a._reNewline.test(h) && (a._reNewline.test(a._text[c]) || c === a._text.length) && (o = o.trimEnd()), e.didDrop = !0, e.dropTarget = a, a.insertChars(o, u, c), l.setActiveObject(a), a.enterEditing(s), a.selectionStart = Math.min(c + f, a._text.length), a.selectionEnd = Math.min(a.selectionStart + o.length, a._text.length), a.hiddenTextarea.value = a.text, a._updateTextarea(), a.hiddenTextarea.focus(), a.fire(Po, { index: c + f, action: "drop" }), l.fire("text:changed", { target: a }), l.contextTopDirty = !0, l.requestRenderAll();
    }
  }
  dragEndHandler(e) {
    let { e: n } = e;
    if (this.isActive() && this.__dragStartFired && this.__dragStartSelection) {
      var s;
      const i = this.target, o = this.target.canvas, { selectionStart: a, selectionEnd: l } = this.__dragStartSelection, c = ((s = n.dataTransfer) === null || s === void 0 ? void 0 : s.dropEffect) || Ge;
      c === Ge ? (i.selectionStart = a, i.selectionEnd = l, i._updateTextarea(), i.hiddenTextarea.focus()) : (i.clearContextTop(), c === "move" && (i.removeChars(a, l), i.selectionStart = i.selectionEnd = a, i.hiddenTextarea && (i.hiddenTextarea.value = i.text), i._updateTextarea(), i.fire(Po, { index: a, action: "dragend" }), o.fire("text:changed", { target: i }), o.requestRenderAll()), i.exitEditing());
    }
    this.__dragImageDisposer && this.__dragImageDisposer(), delete this.__dragImageDisposer, delete this.__dragStartSelection, this.__isDraggingOver = !1;
  }
  dispose() {
    this._dispose && this._dispose();
  }
}
const ku = /[ \n\.,;!\?\-]/;
class gT extends je {
  constructor() {
    super(...arguments), nt(this, "_currentCursorOpacity", 1);
  }
  initBehavior() {
    this._tick = this._tick.bind(this), this._onTickComplete = this._onTickComplete.bind(this), this.updateSelectionOnMouseMove = this.updateSelectionOnMouseMove.bind(this);
  }
  onDeselect(e) {
    return this.isEditing && this.exitEditing(), this.selected = !1, super.onDeselect(e);
  }
  _animateCursor(e) {
    let { toValue: n, duration: s, delay: i, onComplete: o } = e;
    return Pd({ startValue: this._currentCursorOpacity, endValue: n, duration: s, delay: i, onComplete: o, abort: () => !this.canvas || this.selectionStart !== this.selectionEnd, onChange: (a) => {
      this._currentCursorOpacity = a, this.renderCursorOrSelection();
    } });
  }
  _tick(e) {
    this._currentTickState = this._animateCursor({ toValue: 0, duration: this.cursorDuration / 2, delay: Math.max(e || 0, 100), onComplete: this._onTickComplete });
  }
  _onTickComplete() {
    var e;
    (e = this._currentTickCompleteState) === null || e === void 0 || e.abort(), this._currentTickCompleteState = this._animateCursor({ toValue: 1, duration: this.cursorDuration, onComplete: this._tick });
  }
  initDelayedCursor(e) {
    this.abortCursorAnimation(), this._tick(e ? 0 : this.cursorDelay);
  }
  abortCursorAnimation() {
    let e = !1;
    [this._currentTickState, this._currentTickCompleteState].forEach((n) => {
      n && !n.isDone() && (e = !0, n.abort());
    }), this._currentCursorOpacity = 1, e && this.clearContextTop();
  }
  restartCursorIfNeeded() {
    [this._currentTickState, this._currentTickCompleteState].some((e) => !e || e.isDone()) && this.initDelayedCursor();
  }
  selectAll() {
    return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this;
  }
  cmdAll() {
    this.selectAll(), this.renderCursorOrSelection();
  }
  getSelectedText() {
    return this._text.slice(this.selectionStart, this.selectionEnd).join("");
  }
  findWordBoundaryLeft(e) {
    let n = 0, s = e - 1;
    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) n++, s--;
    for (; /\S/.test(this._text[s]) && s > -1; ) n++, s--;
    return e - n;
  }
  findWordBoundaryRight(e) {
    let n = 0, s = e;
    if (this._reSpace.test(this._text[s])) for (; this._reSpace.test(this._text[s]); ) n++, s++;
    for (; /\S/.test(this._text[s]) && s < this._text.length; ) n++, s++;
    return e + n;
  }
  findLineBoundaryLeft(e) {
    let n = 0, s = e - 1;
    for (; !/\n/.test(this._text[s]) && s > -1; ) n++, s--;
    return e - n;
  }
  findLineBoundaryRight(e) {
    let n = 0, s = e;
    for (; !/\n/.test(this._text[s]) && s < this._text.length; ) n++, s++;
    return e + n;
  }
  searchWordBoundary(e, n) {
    const s = this._text;
    let i = e > 0 && this._reSpace.test(s[e]) && (n === -1 || !$l.test(s[e - 1])) ? e - 1 : e, o = s[i];
    for (; i > 0 && i < s.length && !ku.test(o); ) i += n, o = s[i];
    return n === -1 && ku.test(o) && i++, i;
  }
  selectWord(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const s = this.searchWordBoundary(e, -1), i = Math.max(s, this.searchWordBoundary(e, 1));
    this.selectionStart = s, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection();
  }
  selectLine(e) {
    var n;
    e = (n = e) !== null && n !== void 0 ? n : this.selectionStart;
    const s = this.findLineBoundaryLeft(e), i = this.findLineBoundaryRight(e);
    this.selectionStart = s, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea();
  }
  enterEditing(e) {
    !this.isEditing && this.editable && (this.enterEditingImpl(), this.fire("editing:entered", e ? { e } : void 0), this._fireSelectionChanged(), this.canvas && (this.canvas.fire("text:editing:entered", { target: this, e }), this.canvas.requestRenderAll()));
  }
  enterEditingImpl() {
    this.canvas && (this.canvas.calcOffset(), this.canvas.textEditingManager.exitTextEditing()), this.isEditing = !0, this.initHiddenTextarea(), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick();
  }
  updateSelectionOnMouseMove(e) {
    if (this.getActiveControl()) return;
    const n = this.hiddenTextarea;
    mn(n).activeElement !== n && n.focus();
    const s = this.getSelectionStartFromPointer(e), i = this.selectionStart, o = this.selectionEnd;
    (s === this.__selectionStartOnMouseDown && i !== o || i !== s && o !== s) && (s > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = s) : (this.selectionStart = s, this.selectionEnd = this.__selectionStartOnMouseDown), this.selectionStart === i && this.selectionEnd === o || (this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection()));
  }
  _setEditingProps() {
    this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0;
  }
  fromStringToGraphemeSelection(e, n, s) {
    const i = s.slice(0, e), o = this.graphemeSplit(i).length;
    if (e === n) return { selectionStart: o, selectionEnd: o };
    const a = s.slice(e, n);
    return { selectionStart: o, selectionEnd: o + this.graphemeSplit(a).length };
  }
  fromGraphemeToStringSelection(e, n, s) {
    const i = s.slice(0, e).join("").length;
    return e === n ? { selectionStart: i, selectionEnd: i } : { selectionStart: i, selectionEnd: i + s.slice(e, n).join("").length };
  }
  _updateTextarea() {
    if (this.cursorOffsetCache = {}, this.hiddenTextarea) {
      if (!this.inCompositionMode) {
        const e = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = e.selectionStart, this.hiddenTextarea.selectionEnd = e.selectionEnd;
      }
      this.updateTextareaPosition();
    }
  }
  updateFromTextArea() {
    if (!this.hiddenTextarea) return;
    this.cursorOffsetCache = {};
    const e = this.hiddenTextarea;
    this.text = e.value, this.set("dirty", !0), this.initDimensions(), this.setCoords();
    const n = this.fromStringToGraphemeSelection(e.selectionStart, e.selectionEnd, e.value);
    this.selectionEnd = this.selectionStart = n.selectionEnd, this.inCompositionMode || (this.selectionStart = n.selectionStart), this.updateTextareaPosition();
  }
  updateTextareaPosition() {
    if (this.selectionStart === this.selectionEnd) {
      const e = this._calcTextareaPosition();
      this.hiddenTextarea.style.left = e.left, this.hiddenTextarea.style.top = e.top;
    }
  }
  _calcTextareaPosition() {
    if (!this.canvas) return { left: "1px", top: "1px" };
    const e = this.inCompositionMode ? this.compositionStart : this.selectionStart, n = this._getCursorBoundaries(e), s = this.get2DCursorLocation(e), i = s.lineIndex, o = s.charIndex, a = this.getValueOfPropertyAt(i, o, "fontSize") * this.lineHeight, l = n.leftOffset, c = this.getCanvasRetinaScaling(), u = this.canvas.upperCanvasEl, h = u.width / c, f = u.height / c, m = h - a, p = f - a, y = new mt(n.left + l, n.top + n.topOffset + a).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new mt(u.clientWidth / h, u.clientHeight / f));
    return y.x < 0 && (y.x = 0), y.x > m && (y.x = m), y.y < 0 && (y.y = 0), y.y > p && (y.y = p), y.x += this.canvas._offset.left, y.y += this.canvas._offset.top, { left: "".concat(y.x, "px"), top: "".concat(y.y, "px"), fontSize: "".concat(a, "px"), charHeight: a };
  }
  _saveEditingProps() {
    this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor };
  }
  _restoreEditingProps() {
    this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor || this.canvas.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor || this.canvas.moveCursor), delete this._savedProps);
  }
  _exitEditing() {
    const e = this.hiddenTextarea;
    this.selected = !1, this.isEditing = !1, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this.selectionStart !== this.selectionEnd && this.clearContextTop();
  }
  exitEditingImpl() {
    this._exitEditing(), this.selectionEnd = this.selectionStart, this._restoreEditingProps(), this._forceClearCache && (this.initDimensions(), this.setCoords());
  }
  exitEditing() {
    const e = this._textBeforeEdit !== this.text;
    return this.exitEditingImpl(), this.fire("editing:exited"), e && this.fire(Do), this.canvas && (this.canvas.fire("text:editing:exited", { target: this }), e && this.canvas.fire("object:modified", { target: this })), this;
  }
  _removeExtraneousStyles() {
    for (const e in this.styles) this._textLines[e] || delete this.styles[e];
  }
  removeStyleFromTo(e, n) {
    const { lineIndex: s, charIndex: i } = this.get2DCursorLocation(e, !0), { lineIndex: o, charIndex: a } = this.get2DCursorLocation(n, !0);
    if (s !== o) {
      if (this.styles[s]) for (let l = i; l < this._unwrappedTextLines[s].length; l++) delete this.styles[s][l];
      if (this.styles[o]) for (let l = a; l < this._unwrappedTextLines[o].length; l++) {
        const c = this.styles[o][l];
        c && (this.styles[s] || (this.styles[s] = {}), this.styles[s][i + l - a] = c);
      }
      for (let l = s + 1; l <= o; l++) delete this.styles[l];
      this.shiftLineStyles(o, s - o);
    } else if (this.styles[s]) {
      const l = this.styles[s], c = a - i;
      for (let u = i; u < a; u++) delete l[u];
      for (const u in this.styles[s]) {
        const h = parseInt(u, 10);
        h >= a && (l[h - c] = l[u], delete l[u]);
      }
    }
  }
  shiftLineStyles(e, n) {
    const s = Object.assign({}, this.styles);
    for (const i in this.styles) {
      const o = parseInt(i, 10);
      o > e && (this.styles[o + n] = s[o], s[o - n] || delete this.styles[o]);
    }
  }
  insertNewlineStyleObject(e, n, s, i) {
    const o = {}, a = this._unwrappedTextLines[e].length, l = a === n;
    let c = !1;
    s || (s = 1), this.shiftLineStyles(e, s);
    const u = this.styles[e] ? this.styles[e][n === 0 ? n : n - 1] : void 0;
    for (const f in this.styles[e]) {
      const m = parseInt(f, 10);
      m >= n && (c = !0, o[m - n] = this.styles[e][f], l && n === 0 || delete this.styles[e][f]);
    }
    let h = !1;
    for (c && !l && (this.styles[e + s] = o, h = !0), (h || a > n) && s--; s > 0; ) i && i[s - 1] ? this.styles[e + s] = { 0: st({}, i[s - 1]) } : u ? this.styles[e + s] = { 0: st({}, u) } : delete this.styles[e + s], s--;
    this._forceClearCache = !0;
  }
  insertCharStyleObject(e, n, s, i) {
    this.styles || (this.styles = {});
    const o = this.styles[e], a = o ? st({}, o) : {};
    s || (s = 1);
    for (const c in a) {
      const u = parseInt(c, 10);
      u >= n && (o[u + s] = a[u], a[u - s] || delete o[u]);
    }
    if (this._forceClearCache = !0, i) {
      for (; s--; ) Object.keys(i[s]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][n + s] = st({}, i[s]));
      return;
    }
    if (!o) return;
    const l = o[n ? n - 1 : 1];
    for (; l && s--; ) this.styles[e][n + s] = st({}, l);
  }
  insertNewStyleBlock(e, n, s) {
    const i = this.get2DCursorLocation(n, !0), o = [0];
    let a, l = 0;
    for (let c = 0; c < e.length; c++) e[c] === `
` ? (l++, o[l] = 0) : o[l]++;
    for (o[0] > 0 && (this.insertCharStyleObject(i.lineIndex, i.charIndex, o[0], s), s = s && s.slice(o[0] + 1)), l && this.insertNewlineStyleObject(i.lineIndex, i.charIndex + o[0], l), a = 1; a < l; a++) o[a] > 0 ? this.insertCharStyleObject(i.lineIndex + a, 0, o[a], s) : s && this.styles[i.lineIndex + a] && s[0] && (this.styles[i.lineIndex + a][0] = s[0]), s = s && s.slice(o[a] + 1);
    o[a] > 0 && this.insertCharStyleObject(i.lineIndex + a, 0, o[a], s);
  }
  removeChars(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e + 1;
    this.removeStyleFromTo(e, n), this._text.splice(e, n - e), this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  insertChars(e, n, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : s;
    i > s && this.removeStyleFromTo(s, i);
    const o = this.graphemeSplit(e);
    this.insertNewStyleBlock(o, s, n), this._text = [...this._text.slice(0, s), ...o, ...this._text.slice(i)], this.text = this._text.join(""), this.set("dirty", !0), this.initDimensions(), this.setCoords(), this._removeExtraneousStyles();
  }
  setSelectionStartEndWithShift(e, n, s) {
    s <= e ? (n === e ? this._selectionDirection = Jt : this._selectionDirection === be && (this._selectionDirection = Jt, this.selectionEnd = e), this.selectionStart = s) : s > e && s < n ? this._selectionDirection === be ? this.selectionEnd = s : this.selectionStart = s : (n === e ? this._selectionDirection = be : this._selectionDirection === Jt && (this._selectionDirection = be, this.selectionStart = n), this.selectionEnd = s);
  }
}
class vT extends gT {
  initHiddenTextarea() {
    const e = this.canvas && mn(this.canvas.getElement()) || Ci(), n = e.createElement("textarea");
    Object.entries({ autocapitalize: "off", autocorrect: "off", autocomplete: "off", spellcheck: "false", "data-fabric": "textarea", wrap: "off", name: "fabricTextarea" }).map((a) => {
      let [l, c] = a;
      return n.setAttribute(l, c);
    });
    const { top: s, left: i, fontSize: o } = this._calcTextareaPosition();
    n.style.cssText = "position: absolute; top: ".concat(s, "; left: ").concat(i, "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(o, ";"), (this.hiddenTextareaContainer || e.body).appendChild(n), Object.entries({ blur: "blur", keydown: "onKeyDown", keyup: "onKeyUp", input: "onInput", copy: "copy", cut: "copy", paste: "paste", compositionstart: "onCompositionStart", compositionupdate: "onCompositionUpdate", compositionend: "onCompositionEnd" }).map((a) => {
      let [l, c] = a;
      return n.addEventListener(l, this[c].bind(this));
    }), this.hiddenTextarea = n;
  }
  blur() {
    this.abortCursorAnimation();
  }
  onKeyDown(e) {
    if (!this.isEditing) return;
    const n = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
    if (e.keyCode in n) this[n[e.keyCode]](e);
    else {
      if (!(e.keyCode in this.ctrlKeysMapDown) || !e.ctrlKey && !e.metaKey) return;
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    e.stopImmediatePropagation(), e.preventDefault(), e.keyCode >= 33 && e.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll();
  }
  onKeyUp(e) {
    !this.isEditing || this._copyDone || this.inCompositionMode ? this._copyDone = !1 : e.keyCode in this.ctrlKeysMapUp && (e.ctrlKey || e.metaKey) && (this[this.ctrlKeysMapUp[e.keyCode]](e), e.stopImmediatePropagation(), e.preventDefault(), this.canvas && this.canvas.requestRenderAll());
  }
  onInput(e) {
    const n = this.fromPaste, { value: s, selectionStart: i, selectionEnd: o } = this.hiddenTextarea;
    if (this.fromPaste = !1, e && e.stopPropagation(), !this.isEditing) return;
    const a = () => {
      this.updateFromTextArea(), this.fire(Po), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll());
    };
    if (this.hiddenTextarea.value === "") return this.styles = {}, void a();
    const l = this._splitTextIntoLines(s).graphemeText, c = this._text.length, u = l.length, h = this.selectionStart, f = this.selectionEnd, m = h !== f;
    let p, y, v, _, g = u - c;
    const C = this.fromStringToGraphemeSelection(i, o, s), x = h > C.selectionStart;
    m ? (y = this._text.slice(h, f), g += f - h) : u < c && (y = x ? this._text.slice(f + g, f) : this._text.slice(h, h - g));
    const k = l.slice(C.selectionEnd - g, C.selectionEnd);
    if (y && y.length && (k.length && (p = this.getSelectionStyles(h, h + 1, !1), p = k.map(() => p[0])), m ? (v = h, _ = f) : x ? (v = f - y.length, _ = f) : (v = f, _ = f + y.length), this.removeStyleFromTo(v, _)), k.length) {
      const { copyPasteData: w } = Fn();
      n && k.join("") === w.copiedText && !Gt.disableStyleCopyPaste && (p = w.copiedTextStyle), this.insertNewStyleBlock(k, h, p);
    }
    a();
  }
  onCompositionStart() {
    this.inCompositionMode = !0;
  }
  onCompositionEnd() {
    this.inCompositionMode = !1;
  }
  onCompositionUpdate(e) {
    let { target: n } = e;
    const { selectionStart: s, selectionEnd: i } = n;
    this.compositionStart = s, this.compositionEnd = i, this.updateTextareaPosition();
  }
  copy() {
    if (this.selectionStart === this.selectionEnd) return;
    const { copyPasteData: e } = Fn();
    e.copiedText = this.getSelectedText(), Gt.disableStyleCopyPaste ? e.copiedTextStyle = void 0 : e.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0;
  }
  paste() {
    this.fromPaste = !0;
  }
  _getWidthBeforeCursor(e, n) {
    let s, i = this._getLineLeftOffset(e);
    return n > 0 && (s = this.__charBounds[e][n - 1], i += s.left + s.width), i;
  }
  getDownCursorOffset(e, n) {
    const s = this._getSelectionForOffset(e, n), i = this.get2DCursorLocation(s), o = i.lineIndex;
    if (o === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) return this._text.length - s;
    const a = i.charIndex, l = this._getWidthBeforeCursor(o, a), c = this._getIndexOnLine(o + 1, l);
    return this._textLines[o].slice(a).length + c + 1 + this.missingNewlineOffset(o);
  }
  _getSelectionForOffset(e, n) {
    return e.shiftKey && this.selectionStart !== this.selectionEnd && n ? this.selectionEnd : this.selectionStart;
  }
  getUpCursorOffset(e, n) {
    const s = this._getSelectionForOffset(e, n), i = this.get2DCursorLocation(s), o = i.lineIndex;
    if (o === 0 || e.metaKey || e.keyCode === 33) return -s;
    const a = i.charIndex, l = this._getWidthBeforeCursor(o, a), c = this._getIndexOnLine(o - 1, l), u = this._textLines[o].slice(0, a), h = this.missingNewlineOffset(o - 1);
    return -this._textLines[o - 1].length + c - u.length + (1 - h);
  }
  _getIndexOnLine(e, n) {
    const s = this._textLines[e];
    let i, o, a = this._getLineLeftOffset(e), l = 0;
    for (let c = 0, u = s.length; c < u; c++) if (i = this.__charBounds[e][c].width, a += i, a > n) {
      o = !0;
      const h = a - i, f = a, m = Math.abs(h - n);
      l = Math.abs(f - n) < m ? c : c - 1;
      break;
    }
    return o || (l = s.length - 1), l;
  }
  moveCursorDown(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", e);
  }
  moveCursorUp(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorUpOrDown("Up", e);
  }
  _moveCursorUpOrDown(e, n) {
    const s = this["get".concat(e, "CursorOffset")](n, this._selectionDirection === be);
    if (n.shiftKey ? this.moveCursorWithShift(s) : this.moveCursorWithoutShift(s), s !== 0) {
      const i = this.text.length;
      this.selectionStart = wi(0, this.selectionStart, i), this.selectionEnd = wi(0, this.selectionEnd, i), this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea();
    }
  }
  moveCursorWithShift(e) {
    const n = this._selectionDirection === Jt ? this.selectionStart + e : this.selectionEnd + e;
    return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, n), e !== 0;
  }
  moveCursorWithoutShift(e) {
    return e < 0 ? (this.selectionStart += e, this.selectionEnd = this.selectionStart) : (this.selectionEnd += e, this.selectionStart = this.selectionEnd), e !== 0;
  }
  moveCursorLeft(e) {
    this.selectionStart === 0 && this.selectionEnd === 0 || this._moveCursorLeftOrRight("Left", e);
  }
  _move(e, n, s) {
    let i;
    if (e.altKey) i = this["findWordBoundary".concat(s)](this[n]);
    else {
      if (!e.metaKey && e.keyCode !== 35 && e.keyCode !== 36) return this[n] += s === "Left" ? -1 : 1, !0;
      i = this["findLineBoundary".concat(s)](this[n]);
    }
    return i !== void 0 && this[n] !== i && (this[n] = i, !0);
  }
  _moveLeft(e, n) {
    return this._move(e, n, "Left");
  }
  _moveRight(e, n) {
    return this._move(e, n, "Right");
  }
  moveCursorLeftWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = Jt, this.selectionEnd === this.selectionStart && this.selectionStart !== 0 && (n = this._moveLeft(e, "selectionStart")), this.selectionEnd = this.selectionStart, n;
  }
  moveCursorLeftWithShift(e) {
    return this._selectionDirection === be && this.selectionStart !== this.selectionEnd ? this._moveLeft(e, "selectionEnd") : this.selectionStart !== 0 ? (this._selectionDirection = Jt, this._moveLeft(e, "selectionStart")) : void 0;
  }
  moveCursorRight(e) {
    this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", e);
  }
  _moveCursorLeftOrRight(e, n) {
    const s = "moveCursor".concat(e).concat(n.shiftKey ? "WithShift" : "WithoutShift");
    this._currentCursorOpacity = 1, this[s](n) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea());
  }
  moveCursorRightWithShift(e) {
    return this._selectionDirection === Jt && this.selectionStart !== this.selectionEnd ? this._moveRight(e, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = be, this._moveRight(e, "selectionEnd")) : void 0;
  }
  moveCursorRightWithoutShift(e) {
    let n = !0;
    return this._selectionDirection = be, this.selectionStart === this.selectionEnd ? (n = this._moveRight(e, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, n;
  }
}
const Tu = (r) => !!r.button;
class yT extends vT {
  constructor() {
    super(...arguments), nt(this, "draggableTextDelegate", void 0);
  }
  initBehavior() {
    this.on("mousedown", this._mouseDownHandler), this.on("mouseup", this.mouseUpHandler), this.on("mousedblclick", this.doubleClickHandler), this.on("mousetripleclick", this.tripleClickHandler), this.draggableTextDelegate = new mT(this), super.initBehavior();
  }
  shouldStartDragging() {
    return this.draggableTextDelegate.isActive();
  }
  onDragStart(e) {
    return this.draggableTextDelegate.onDragStart(e);
  }
  canDrop(e) {
    return this.draggableTextDelegate.canDrop(e);
  }
  doubleClickHandler(e) {
    this.isEditing && (this.selectWord(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  tripleClickHandler(e) {
    this.isEditing && (this.selectLine(this.getSelectionStartFromPointer(e.e)), this.renderCursorOrSelection());
  }
  _mouseDownHandler(e) {
    let { e: n, alreadySelected: s } = e;
    this.canvas && this.editable && !Tu(n) && !this.getActiveControl() && (this.draggableTextDelegate.start(n) || (this.canvas.textEditingManager.register(this), s && (this.inCompositionMode = !1, this.setCursorByClick(n)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection()), this.selected || (this.selected = s || this.isEditing)));
  }
  mouseUpHandler(e) {
    let { e: n, transform: s } = e;
    const i = this.draggableTextDelegate.end(n);
    if (this.canvas) {
      this.canvas.textEditingManager.unregister(this);
      const o = this.canvas._activeObject;
      if (o && o !== this) return;
    }
    !this.editable || this.group && !this.group.interactive || s && s.actionPerformed || Tu(n) || i || this.selected && !this.getActiveControl() && (this.enterEditing(n), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection());
  }
  setCursorByClick(e) {
    const n = this.getSelectionStartFromPointer(e), s = this.selectionStart, i = this.selectionEnd;
    e.shiftKey ? this.setSelectionStartEndWithShift(s, i, n) : (this.selectionStart = n, this.selectionEnd = n), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea());
  }
  getSelectionStartFromPointer(e) {
    const n = this.canvas.getScenePoint(e).transform(gn(this.calcTransformMatrix())).add(new mt(-this._getLeftOffset(), -this._getTopOffset()));
    let s = 0, i = 0, o = 0;
    for (let u = 0; u < this._textLines.length && s <= n.y; u++) s += this.getHeightOfLine(u), o = u, u > 0 && (i += this._textLines[u - 1].length + this.missingNewlineOffset(u - 1));
    let a = Math.abs(this._getLineLeftOffset(o));
    const l = this._textLines[o].length, c = this.__charBounds[o];
    for (let u = 0; u < l; u++) {
      const h = a + c[u].kernedWidth;
      if (n.x <= h) {
        Math.abs(n.x - h) <= Math.abs(n.x - a) && i++;
        break;
      }
      a = h, i++;
    }
    return Math.min(this.flipX ? l - i : i, this._text.length);
  }
}
const Br = "moveCursorUp", Vr = "moveCursorDown", $r = "moveCursorLeft", Nr = "moveCursorRight", Wr = "exitEditing", Mu = (r, e) => {
  const n = e.getRetinaScaling();
  r.setTransform(n, 0, 0, n, 0, 0);
  const s = e.viewportTransform;
  r.transform(s[0], s[1], s[2], s[3], s[4], s[5]);
}, bT = st({ selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, keysMap: { 9: Wr, 27: Wr, 33: Br, 34: Vr, 35: Nr, 36: $r, 37: $r, 38: Br, 39: Nr, 40: Vr }, keysMapRtl: { 9: Wr, 27: Wr, 33: Br, 34: Vr, 35: $r, 36: Nr, 37: Nr, 38: Br, 39: $r, 40: Vr }, ctrlKeysMapDown: { 65: "cmdAll" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" } }, { _selectionDirection: null, _reSpace: /\s|\r?\n/, inCompositionMode: !1 });
class Xn extends yT {
  static getDefaults() {
    return st(st({}, super.getDefaults()), Xn.ownDefaults);
  }
  get type() {
    const e = super.type;
    return e === "itext" ? "i-text" : e;
  }
  constructor(e, n) {
    super(e, st(st({}, Xn.ownDefaults), n)), this.initBehavior();
  }
  _set(e, n) {
    return this.isEditing && this._savedProps && e in this._savedProps ? (this._savedProps[e] = n, this) : (e === "canvas" && (this.canvas instanceof yl && this.canvas.textEditingManager.remove(this), n instanceof yl && n.textEditingManager.add(this)), super._set(e, n));
  }
  setSelectionStart(e) {
    e = Math.max(e, 0), this._updateAndFire("selectionStart", e);
  }
  setSelectionEnd(e) {
    e = Math.min(e, this.text.length), this._updateAndFire("selectionEnd", e);
  }
  _updateAndFire(e, n) {
    this[e] !== n && (this._fireSelectionChanged(), this[e] = n), this._updateTextarea();
  }
  _fireSelectionChanged() {
    this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this });
  }
  initDimensions() {
    this.isEditing && this.initDelayedCursor(), super.initDimensions();
  }
  getSelectionStyles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart || 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionEnd, s = arguments.length > 2 ? arguments[2] : void 0;
    return super.getSelectionStyles(e, n, s);
  }
  setSelectionStyles(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.selectionStart || 0, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.selectionEnd;
    return super.setSelectionStyles(e, n, s);
  }
  get2DCursorLocation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    return super.get2DCursorLocation(e, n);
  }
  render(e) {
    super.render(e), this.cursorOffsetCache = {}, this.renderCursorOrSelection();
  }
  toCanvasElement(e) {
    const n = this.isEditing;
    this.isEditing = !1;
    const s = super.toCanvasElement(e);
    return this.isEditing = n, s;
  }
  renderCursorOrSelection() {
    if (!this.isEditing || !this.canvas) return;
    const e = this.clearContextTop(!0);
    if (!e) return;
    const n = this._getCursorBoundaries(), s = this.findAncestorsWithClipPath(), i = s.length > 0;
    let o, a = e;
    if (i) {
      o = ln(e.canvas), a = o.getContext("2d"), Mu(a, this.canvas);
      const l = this.calcTransformMatrix();
      a.transform(l[0], l[1], l[2], l[3], l[4], l[5]);
    }
    if (this.selectionStart !== this.selectionEnd || this.inCompositionMode ? this.renderSelection(a, n) : this.renderCursor(a, n), i) for (const l of s) {
      const c = l.clipPath, u = ln(e.canvas), h = u.getContext("2d");
      if (Mu(h, this.canvas), !c.absolutePositioned) {
        const f = l.calcTransformMatrix();
        h.transform(f[0], f[1], f[2], f[3], f[4], f[5]);
      }
      c.transform(h), c.drawObject(h, !0, {}), this.drawClipPathOnCache(a, c, u);
    }
    i && (e.setTransform(1, 0, 0, 1, 0, 0), e.drawImage(o, 0, 0)), this.canvas.contextTopDirty = !0, e.restore();
  }
  findAncestorsWithClipPath() {
    const e = [];
    let n = this;
    for (; n; ) n.clipPath && e.push(n), n = n.parent;
    return e;
  }
  _getCursorBoundaries() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 ? arguments[1] : void 0;
    const s = this._getLeftOffset(), i = this._getTopOffset(), o = this._getCursorBoundariesOffsets(e, n);
    return { left: s, top: i, leftOffset: o.left, topOffset: o.top };
  }
  _getCursorBoundariesOffsets(e, n) {
    return n ? this.__getCursorBoundariesOffsets(e) : this.cursorOffsetCache && "top" in this.cursorOffsetCache ? this.cursorOffsetCache : this.cursorOffsetCache = this.__getCursorBoundariesOffsets(e);
  }
  __getCursorBoundariesOffsets(e) {
    let n = 0, s = 0;
    const { charIndex: i, lineIndex: o } = this.get2DCursorLocation(e);
    for (let u = 0; u < o; u++) n += this.getHeightOfLine(u);
    const a = this._getLineLeftOffset(o), l = this.__charBounds[o][i];
    l && (s = l.left), this.charSpacing !== 0 && i === this._textLines[o].length && (s -= this._getWidthOfCharSpacing());
    const c = { top: n, left: a + (s > 0 ? s : 0) };
    return this.direction === "rtl" && (this.textAlign === be || this.textAlign === En || this.textAlign === Qi ? c.left *= -1 : this.textAlign === Jt || this.textAlign === zo ? c.left = a - (s > 0 ? s : 0) : this.textAlign !== Ut && this.textAlign !== tr || (c.left = a - (s > 0 ? s : 0))), c;
  }
  renderCursorAt(e) {
    this._renderCursor(this.canvas.contextTop, this._getCursorBoundaries(e, !0), e);
  }
  renderCursor(e, n) {
    this._renderCursor(e, n, this.selectionStart);
  }
  getCursorRenderingData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.selectionStart, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._getCursorBoundaries(e);
    const s = this.get2DCursorLocation(e), i = s.lineIndex, o = s.charIndex > 0 ? s.charIndex - 1 : 0, a = this.getValueOfPropertyAt(i, o, "fontSize"), l = this.getObjectScaling().x * this.canvas.getZoom(), c = this.cursorWidth / l, u = this.getValueOfPropertyAt(i, o, "deltaY"), h = n.topOffset + (1 - this._fontSizeFraction) * this.getHeightOfLine(i) / this.lineHeight - a * (1 - this._fontSizeFraction);
    return { color: this.cursorColor || this.getValueOfPropertyAt(i, o, "fill"), opacity: this._currentCursorOpacity, left: n.left + n.leftOffset - c / 2, top: h + n.top + u, width: c, height: a };
  }
  _renderCursor(e, n, s) {
    const { color: i, opacity: o, left: a, top: l, width: c, height: u } = this.getCursorRenderingData(s, n);
    e.fillStyle = i, e.globalAlpha = o, e.fillRect(a, l, c, u);
  }
  renderSelection(e, n) {
    const s = { selectionStart: this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd: this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd };
    this._renderSelection(e, s, n);
  }
  renderDragSourceEffect() {
    const e = this.draggableTextDelegate.getDragStartSelection();
    this._renderSelection(this.canvas.contextTop, e, this._getCursorBoundaries(e.selectionStart, !0));
  }
  renderDropTargetEffect(e) {
    const n = this.getSelectionStartFromPointer(e);
    this.renderCursorAt(n);
  }
  _renderSelection(e, n, s) {
    const i = n.selectionStart, o = n.selectionEnd, a = this.textAlign.includes(En), l = this.get2DCursorLocation(i), c = this.get2DCursorLocation(o), u = l.lineIndex, h = c.lineIndex, f = l.charIndex < 0 ? 0 : l.charIndex, m = c.charIndex < 0 ? 0 : c.charIndex;
    for (let p = u; p <= h; p++) {
      const y = this._getLineLeftOffset(p) || 0;
      let v = this.getHeightOfLine(p), _ = 0, g = 0, C = 0;
      if (p === u && (g = this.__charBounds[u][f].left), p >= u && p < h) C = a && !this.isEndOfWrapping(p) ? this.width : this.getLineWidth(p) || 5;
      else if (p === h) if (m === 0) C = this.__charBounds[h][m].left;
      else {
        const P = this._getWidthOfCharSpacing();
        C = this.__charBounds[h][m - 1].left + this.__charBounds[h][m - 1].width - P;
      }
      _ = v, (this.lineHeight < 1 || p === h && this.lineHeight > 1) && (v /= this.lineHeight);
      let x = s.left + y + g, k = v, w = 0;
      const T = C - g;
      this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", k = 1, w = v) : e.fillStyle = this.selectionColor, this.direction === "rtl" && (this.textAlign === be || this.textAlign === En || this.textAlign === Qi ? x = this.width - x - T : this.textAlign === Jt || this.textAlign === zo ? x = s.left + y - C : this.textAlign !== Ut && this.textAlign !== tr || (x = s.left + y - C)), e.fillRect(x, s.top + s.topOffset + w, T, k), s.topOffset += _;
    }
  }
  getCurrentCharFontSize() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, "fontSize");
  }
  getCurrentCharColor() {
    const e = this._getCurrentCharIndex();
    return this.getValueOfPropertyAt(e.l, e.c, Te);
  }
  _getCurrentCharIndex() {
    const e = this.get2DCursorLocation(this.selectionStart, !0), n = e.charIndex > 0 ? e.charIndex - 1 : 0;
    return { l: e.lineIndex, c: n };
  }
  dispose() {
    this.exitEditingImpl(), this.draggableTextDelegate.dispose(), super.dispose();
  }
}
nt(Xn, "ownDefaults", bT), nt(Xn, "type", "IText"), Et.setClass(Xn), Et.setClass(Xn, "i-text");
class Vs extends Xn {
  static getDefaults() {
    return st(st({}, super.getDefaults()), Vs.ownDefaults);
  }
  constructor(e, n) {
    super(e, st(st({}, Vs.ownDefaults), n));
  }
  static createControls() {
    return { controls: ZC() };
  }
  initDimensions() {
    this.initialized && (this.isEditing && this.initDelayedCursor(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), this.textAlign.includes(En) && this.enlargeSpaces(), this.height = this.calcTextHeight());
  }
  _generateStyleMap(e) {
    let n = 0, s = 0, i = 0;
    const o = {};
    for (let a = 0; a < e.graphemeLines.length; a++) e.graphemeText[i] === `
` && a > 0 ? (s = 0, i++, n++) : !this.splitByGrapheme && this._reSpaceAndTab.test(e.graphemeText[i]) && a > 0 && (s++, i++), o[a] = { line: n, offset: s }, i += e.graphemeLines[a].length, s += e.graphemeLines[a].length;
    return o;
  }
  styleHas(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const s = this._styleMap[n];
      s && (n = s.line);
    }
    return super.styleHas(e, n);
  }
  isEmptyStyles(e) {
    if (!this.styles) return !0;
    let n, s = 0, i = e + 1, o = !1;
    const a = this._styleMap[e], l = this._styleMap[e + 1];
    a && (e = a.line, s = a.offset), l && (i = l.line, o = i === e, n = l.offset);
    const c = e === void 0 ? this.styles : { line: this.styles[e] };
    for (const u in c) for (const h in c[u]) {
      const f = parseInt(h, 10);
      if (f >= s && (!o || f < n)) for (const m in c[u][h]) return !1;
    }
    return !0;
  }
  _getStyleDeclaration(e, n) {
    if (this._styleMap && !this.isWrapping) {
      const s = this._styleMap[e];
      if (!s) return {};
      e = s.line, n = s.offset + n;
    }
    return super._getStyleDeclaration(e, n);
  }
  _setStyleDeclaration(e, n, s) {
    const i = this._styleMap[e];
    super._setStyleDeclaration(i.line, i.offset + n, s);
  }
  _deleteStyleDeclaration(e, n) {
    const s = this._styleMap[e];
    super._deleteStyleDeclaration(s.line, s.offset + n);
  }
  _getLineStyle(e) {
    const n = this._styleMap[e];
    return !!this.styles[n.line];
  }
  _setLineStyle(e) {
    const n = this._styleMap[e];
    super._setLineStyle(n.line);
  }
  _wrapText(e, n) {
    this.isWrapping = !0;
    const s = this.getGraphemeDataForRender(e), i = [];
    for (let o = 0; o < s.wordsData.length; o++) i.push(...this._wrapLine(o, n, s));
    return this.isWrapping = !1, i;
  }
  getGraphemeDataForRender(e) {
    const n = this.splitByGrapheme, s = n ? "" : " ";
    let i = 0;
    return { wordsData: e.map((o, a) => {
      let l = 0;
      const c = n ? this.graphemeSplit(o) : this.wordSplit(o);
      return c.length === 0 ? [{ word: [], width: 0 }] : c.map((u) => {
        const h = n ? [u] : this.graphemeSplit(u), f = this._measureWord(h, a, l);
        return i = Math.max(f, i), l += h.length + s.length, { word: h, width: f };
      });
    }), largestWordWidth: i };
  }
  _measureWord(e, n) {
    let s, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = 0;
    for (let a = 0, l = e.length; a < l; a++)
      o += this._getGraphemeBox(e[a], n, a + i, s, !0).kernedWidth, s = e[a];
    return o;
  }
  wordSplit(e) {
    return e.split(this._wordJoiners);
  }
  _wrapLine(e, n, s) {
    let { largestWordWidth: i, wordsData: o } = s, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    const l = this._getWidthOfCharSpacing(), c = this.splitByGrapheme, u = [], h = c ? "" : " ";
    let f = 0, m = [], p = 0, y = 0, v = !0;
    n -= a;
    const _ = Math.max(n, i, this.dynamicMinWidth), g = o[e];
    let C;
    for (p = 0, C = 0; C < g.length; C++) {
      const { word: x, width: k } = g[C];
      p += x.length, f += y + k - l, f > _ && !v ? (u.push(m), m = [], f = k, v = !0) : f += l, v || c || m.push(h), m = m.concat(x), y = c ? 0 : this._measureWord([h], e, p), p++, v = !1;
    }
    return C && u.push(m), i + a > this.dynamicMinWidth && (this.dynamicMinWidth = i - l + a), u;
  }
  isEndOfWrapping(e) {
    return !this._styleMap[e + 1] || this._styleMap[e + 1].line !== this._styleMap[e].line;
  }
  missingNewlineOffset(e, n) {
    return this.splitByGrapheme && !n ? this.isEndOfWrapping(e) ? 1 : 0 : 1;
  }
  _splitTextIntoLines(e) {
    const n = super._splitTextIntoLines(e), s = this._wrapText(n.lines, this.width), i = new Array(s.length);
    for (let o = 0; o < s.length; o++) i[o] = s[o].join("");
    return n.lines = i, n.graphemeLines = s, n;
  }
  getMinWidth() {
    return Math.max(this.minWidth, this.dynamicMinWidth);
  }
  _removeExtraneousStyles() {
    const e = /* @__PURE__ */ new Map();
    for (const n in this._styleMap) {
      const s = parseInt(n, 10);
      if (this._textLines[s]) {
        const i = this._styleMap[n].line;
        e.set("".concat(i), !0);
      }
    }
    for (const n in this.styles) e.has(n) || delete this.styles[n];
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return super.toObject(["minWidth", "splitByGrapheme", ...e]);
  }
}
nt(Vs, "type", "Textbox"), nt(Vs, "textLayoutProperties", [...Xn.textLayoutProperties, "width"]), nt(Vs, "ownDefaults", { minWidth: 20, dynamicMinWidth: 2, lockScalingFlip: !0, noScaleCache: !1, _wordJoiners: /[ \t\r]/, splitByGrapheme: !1 }), Et.setClass(Vs);
class Ou extends da {
  shouldPerformLayout(e) {
    return !!e.target.clipPath && super.shouldPerformLayout(e);
  }
  shouldLayoutClipPath() {
    return !1;
  }
  calcLayoutResult(e, n) {
    const { target: s } = e, { clipPath: i, group: o } = s;
    if (!i || !this.shouldPerformLayout(e)) return;
    const { width: a, height: l } = Zn(jd(s, i)), c = new mt(a, l);
    if (i.absolutePositioned)
      return { center: fi(i.getRelativeCenterPoint(), void 0, o ? o.calcTransformMatrix() : void 0), size: c };
    {
      const u = i.getRelativeCenterPoint().transform(s.calcOwnMatrix(), !0);
      if (this.shouldPerformLayout(e)) {
        const { center: h = new mt(), correction: f = new mt() } = this.calcBoundingBox(n, e) || {};
        return { center: h.add(u), correction: f.subtract(u), size: c };
      }
      return { center: s.getRelativeCenterPoint().add(u), size: c };
    }
  }
}
nt(Ou, "type", "clip-path"), Et.setClass(Ou);
class Eu extends da {
  getInitialSize(e, n) {
    let { target: s } = e, { size: i } = n;
    return new mt(s.width || i.x, s.height || i.y);
  }
}
nt(Eu, "type", "fixed"), Et.setClass(Eu);
class _T extends mr {
  subscribeTargets(e) {
    const n = e.target;
    e.targets.reduce((s, i) => (i.parent && s.add(i.parent), s), /* @__PURE__ */ new Set()).forEach((s) => {
      s.layoutManager.subscribeTargets({ target: s, targets: [n] });
    });
  }
  unsubscribeTargets(e) {
    const n = e.target, s = n.getObjects();
    e.targets.reduce((i, o) => (o.parent && i.add(o.parent), i), /* @__PURE__ */ new Set()).forEach((i) => {
      !s.some((o) => o.parent === i) && i.layoutManager.unsubscribeTargets({ target: i, targets: [n] });
    });
  }
}
class $s extends Us {
  static getDefaults() {
    return st(st({}, super.getDefaults()), $s.ownDefaults);
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Object.assign(this, $s.ownDefaults), this.setOptions(n);
    const { left: s, top: i, layoutManager: o } = n;
    this.groupInit(e, { left: s, top: i, layoutManager: o ?? new _T() });
  }
  _shouldSetNestedCoords() {
    return !0;
  }
  __objectSelectionMonitor() {
  }
  multiSelectAdd() {
    for (var e = arguments.length, n = new Array(e), s = 0; s < e; s++) n[s] = arguments[s];
    this.multiSelectionStacking === "selection-order" ? this.add(...n) : n.forEach((i) => {
      const o = this._objects.findIndex((l) => l.isInFrontOf(i)), a = o === -1 ? this.size() : o;
      this.insertAt(a, i);
    });
  }
  canEnterGroup(e) {
    return this.getObjects().some((n) => n.isDescendantOf(e) || e.isDescendantOf(n)) ? (Ss("error", "ActiveSelection: circular object trees are not supported, this call has no effect"), !1) : super.canEnterGroup(e);
  }
  enterGroup(e, n) {
    e.parent && e.parent === e.group ? e.parent._exitGroup(e) : e.group && e.parent !== e.group && e.group.remove(e), this._enterGroup(e, n);
  }
  exitGroup(e, n) {
    this._exitGroup(e, n), e.parent && e.parent._enterGroup(e, !0);
  }
  _onAfterObjectsChange(e, n) {
    super._onAfterObjectsChange(e, n);
    const s = /* @__PURE__ */ new Set();
    n.forEach((i) => {
      const { parent: o } = i;
      o && s.add(o);
    }), e === nc ? s.forEach((i) => {
      i._onAfterObjectsChange(jo, n);
    }) : s.forEach((i) => {
      i._set("dirty", !0);
    });
  }
  onDeselect() {
    return this.removeAll(), !1;
  }
  toString() {
    return "#<ActiveSelection: (".concat(this.complexity(), ")>");
  }
  shouldCache() {
    return !1;
  }
  isOnACache() {
    return !1;
  }
  _renderControls(e, n, s) {
    e.save(), e.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
    const i = st(st({ hasControls: !1 }, s), {}, { forActiveSelection: !0 });
    for (let o = 0; o < this._objects.length; o++) this._objects[o]._renderControls(e, i);
    super._renderControls(e, n), e.restore();
  }
}
nt($s, "type", "ActiveSelection"), nt($s, "ownDefaults", { multiSelectionStacking: "canvas-stacking" }), Et.setClass($s), Et.setClass($s, "activeSelection");
class xT {
  constructor() {
    nt(this, "resources", {});
  }
  applyFilters(e, n, s, i, o) {
    const a = o.getContext("2d");
    if (!a) return;
    a.drawImage(n, 0, 0, s, i);
    const l = { sourceWidth: s, sourceHeight: i, imageData: a.getImageData(0, 0, s, i), originalEl: n, originalImageData: a.getImageData(0, 0, s, i), canvasEl: o, ctx: a, filterBackend: this };
    e.forEach((u) => {
      u.applyTo(l);
    });
    const { imageData: c } = l;
    return c.width === s && c.height === i || (o.width = c.width, o.height = c.height), a.putImageData(c, 0, 0), l;
  }
}
class tf {
  constructor() {
    let { tileSize: e = Gt.textureSize } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    nt(this, "aPosition", new Float32Array([0, 0, 0, 1, 1, 0, 1, 1])), nt(this, "resources", {}), this.tileSize = e, this.setupGLContext(e, e), this.captureGPUInfo();
  }
  setupGLContext(e, n) {
    this.dispose(), this.createWebGLCanvas(e, n);
  }
  createWebGLCanvas(e, n) {
    const s = ln({ width: e, height: n }), i = s.getContext("webgl", { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 });
    i && (i.clearColor(0, 0, 0, 0), this.canvas = s, this.gl = i);
  }
  applyFilters(e, n, s, i, o, a) {
    const l = this.gl, c = o.getContext("2d");
    if (!l || !c) return;
    let u;
    a && (u = this.getCachedTexture(a, n));
    const h = { originalWidth: n.width || n.naturalWidth || 0, originalHeight: n.height || n.naturalHeight || 0, sourceWidth: s, sourceHeight: i, destinationWidth: s, destinationHeight: i, context: l, sourceTexture: this.createTexture(l, s, i, u ? void 0 : n), targetTexture: this.createTexture(l, s, i), originalTexture: u || this.createTexture(l, s, i, u ? void 0 : n), passes: e.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: o }, f = l.createFramebuffer();
    return l.bindFramebuffer(l.FRAMEBUFFER, f), e.forEach((m) => {
      m && m.applyTo(h);
    }), function(m) {
      const p = m.targetCanvas, y = p.width, v = p.height, _ = m.destinationWidth, g = m.destinationHeight;
      y === _ && v === g || (p.width = _, p.height = g);
    }(h), this.copyGLTo2D(l, h), l.bindTexture(l.TEXTURE_2D, null), l.deleteTexture(h.sourceTexture), l.deleteTexture(h.targetTexture), l.deleteFramebuffer(f), c.setTransform(1, 0, 0, 1, 0, 0), h;
  }
  dispose() {
    this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches();
  }
  clearWebGLCaches() {
    this.programCache = {}, this.textureCache = {};
  }
  createTexture(e, n, s, i, o) {
    const { NEAREST: a, TEXTURE_2D: l, RGBA: c, UNSIGNED_BYTE: u, CLAMP_TO_EDGE: h, TEXTURE_MAG_FILTER: f, TEXTURE_MIN_FILTER: m, TEXTURE_WRAP_S: p, TEXTURE_WRAP_T: y } = e, v = e.createTexture();
    return e.bindTexture(l, v), e.texParameteri(l, f, o || a), e.texParameteri(l, m, o || a), e.texParameteri(l, p, h), e.texParameteri(l, y, h), i ? e.texImage2D(l, 0, c, c, u, i) : e.texImage2D(l, 0, c, n, s, 0, c, u, null), v;
  }
  getCachedTexture(e, n, s) {
    const { textureCache: i } = this;
    if (i[e]) return i[e];
    {
      const o = this.createTexture(this.gl, n.width, n.height, n, s);
      return o && (i[e] = o), o;
    }
  }
  evictCachesForKey(e) {
    this.textureCache[e] && (this.gl.deleteTexture(this.textureCache[e]), delete this.textureCache[e]);
  }
  copyGLTo2D(e, n) {
    const s = e.canvas, i = n.targetCanvas, o = i.getContext("2d");
    if (!o) return;
    o.translate(0, i.height), o.scale(1, -1);
    const a = s.height - i.height;
    o.drawImage(s, 0, a, i.width, i.height, 0, 0, i.width, i.height);
  }
  copyGLTo2DPutImageData(e, n) {
    const s = n.targetCanvas.getContext("2d"), i = n.destinationWidth, o = n.destinationHeight, a = i * o * 4;
    if (!s) return;
    const l = new Uint8Array(this.imageBuffer, 0, a), c = new Uint8ClampedArray(this.imageBuffer, 0, a);
    e.readPixels(0, 0, i, o, e.RGBA, e.UNSIGNED_BYTE, l);
    const u = new ImageData(c, i, o);
    s.putImageData(u, 0, 0);
  }
  captureGPUInfo() {
    if (this.gpuInfo) return this.gpuInfo;
    const e = this.gl, n = { renderer: "", vendor: "" };
    if (!e) return n;
    const s = e.getExtension("WEBGL_debug_renderer_info");
    if (s) {
      const i = e.getParameter(s.UNMASKED_RENDERER_WEBGL), o = e.getParameter(s.UNMASKED_VENDOR_WEBGL);
      i && (n.renderer = i.toLowerCase()), o && (n.vendor = o.toLowerCase());
    }
    return this.gpuInfo = n, n;
  }
}
let Na;
function wT() {
  const { WebGLProbe: r } = Fn();
  return r.queryWebGL(rs()), Gt.enableGLFiltering && r.isSupported(Gt.textureSize) ? new tf({ tileSize: Gt.textureSize }) : new xT();
}
function Wa() {
  return !Na && (!(arguments.length > 0 && arguments[0] !== void 0) || arguments[0]) && (Na = wT()), Na;
}
const ST = ["filters", "resizeFilter", "src", "crossOrigin", "type"], ef = ["cropX", "cropY"];
class He extends Ie {
  static getDefaults() {
    return st(st({}, super.getDefaults()), He.ownDefaults);
  }
  constructor(e, n) {
    super(), nt(this, "_lastScaleX", 1), nt(this, "_lastScaleY", 1), nt(this, "_filterScalingX", 1), nt(this, "_filterScalingY", 1), this.filters = [], Object.assign(this, He.ownDefaults), this.setOptions(n), this.cacheKey = "texture".concat(Cs()), this.setElement(typeof e == "string" ? (this.canvas && mn(this.canvas.getElement()) || Ci()).getElementById(e) : e, n);
  }
  getElement() {
    return this._element;
  }
  setElement(e) {
    var n;
    let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._element = e, this._originalElement = e, this._setWidthHeight(s), (n = e.classList) === null || n === void 0 || n.add(He.CSS_CANVAS), this.filters.length !== 0 && this.applyFilters(), this.resizeFilter && this.applyResizeFilters();
  }
  removeTexture(e) {
    const n = Wa(!1);
    n instanceof tf && n.evictCachesForKey(e);
  }
  dispose() {
    super.dispose(), this.removeTexture(this.cacheKey), this.removeTexture("".concat(this.cacheKey, "_filtered")), this._cacheContext = null, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach((e) => {
      const n = this[e];
      n && Fn().dispose(n), this[e] = void 0;
    });
  }
  getCrossOrigin() {
    return this._originalElement && (this._originalElement.crossOrigin || null);
  }
  getOriginalSize() {
    const e = this.getElement();
    return e ? { width: e.naturalWidth || e.width, height: e.naturalHeight || e.height } : { width: 0, height: 0 };
  }
  _stroke(e) {
    if (!this.stroke || this.strokeWidth === 0) return;
    const n = this.width / 2, s = this.height / 2;
    e.beginPath(), e.moveTo(-n, -s), e.lineTo(n, -s), e.lineTo(n, s), e.lineTo(-n, s), e.lineTo(-n, -s), e.closePath();
  }
  toObject() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const n = [];
    return this.filters.forEach((s) => {
      s && n.push(s.toObject());
    }), st(st({}, super.toObject([...ef, ...e])), {}, { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: n }, this.resizeFilter ? { resizeFilter: this.resizeFilter.toObject() } : {});
  }
  hasCrop() {
    return !!this.cropX || !!this.cropY || this.width < this._element.width || this.height < this._element.height;
  }
  _toSVG() {
    const e = [], n = this._element, s = -this.width / 2, i = -this.height / 2;
    let o = [], a = [], l = "", c = "";
    if (!n) return [];
    if (this.hasCrop()) {
      const u = Cs();
      o.push('<clipPath id="imageCrop_' + u + `">
`, '	<rect x="' + s + '" y="' + i + '" width="' + this.width + '" height="' + this.height + `" />
`, `</clipPath>
`), l = ' clip-path="url(#imageCrop_' + u + ')" ';
    }
    if (this.imageSmoothing || (c = ' image-rendering="optimizeSpeed"'), e.push("	<image ", "COMMON_PARTS", 'xlink:href="'.concat(this.getSvgSrc(!0), '" x="').concat(s - this.cropX, '" y="').concat(i - this.cropY, '" width="').concat(n.width || n.naturalWidth, '" height="').concat(n.height || n.naturalHeight, '"').concat(c).concat(l, `></image>
`)), this.stroke || this.strokeDashArray) {
      const u = this.fill;
      this.fill = null, a = ['	<rect x="'.concat(s, '" y="').concat(i, '" width="').concat(this.width, '" height="').concat(this.height, '" style="').concat(this.getSvgStyles(), `" />
`)], this.fill = u;
    }
    return o = this.paintFirst !== Te ? o.concat(a, e) : o.concat(e, a), o;
  }
  getSrc(e) {
    const n = e ? this._element : this._originalElement;
    return n ? n.toDataURL ? n.toDataURL() : this.srcFromAttribute ? n.getAttribute("src") || "" : n.src : this.src || "";
  }
  getSvgSrc(e) {
    return this.getSrc(e);
  }
  setSrc(e) {
    let { crossOrigin: n, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return go(e, { crossOrigin: n, signal: s }).then((i) => {
      n !== void 0 && this.set({ crossOrigin: n }), this.setElement(i);
    });
  }
  toString() {
    return '#<Image: { src: "'.concat(this.getSrc(), '" }>');
  }
  applyResizeFilters() {
    const e = this.resizeFilter, n = this.minimumScaleTrigger, s = this.getTotalObjectScaling(), i = s.x, o = s.y, a = this._filteredEl || this._originalElement;
    if (this.group && this.set("dirty", !0), !e || i > n && o > n) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = i, void (this._lastScaleY = o);
    const l = ln(a), { width: c, height: u } = a;
    this._element = l, this._lastScaleX = e.scaleX = i, this._lastScaleY = e.scaleY = o, Wa().applyFilters([e], a, c, u, this._element), this._filterScalingX = l.width / this._originalElement.width, this._filterScalingY = l.height / this._originalElement.height;
  }
  applyFilters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.filters || [];
    if (e = e.filter((o) => o && !o.isNeutralState()), this.set("dirty", !0), this.removeTexture("".concat(this.cacheKey, "_filtered")), e.length === 0) return this._element = this._originalElement, this._filteredEl = void 0, this._filterScalingX = 1, void (this._filterScalingY = 1);
    const n = this._originalElement, s = n.naturalWidth || n.width, i = n.naturalHeight || n.height;
    if (this._element === this._originalElement) {
      const o = ln({ width: s, height: i });
      this._element = o, this._filteredEl = o;
    } else this._filteredEl && (this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, s, i), this._lastScaleX = 1, this._lastScaleY = 1);
    Wa().applyFilters(e, this._originalElement, s, i, this._element, this.cacheKey), this._originalElement.width === this._element.width && this._originalElement.height === this._element.height || (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height);
  }
  _render(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(e), this._renderPaintInOrder(e);
  }
  drawCacheOnCanvas(e) {
    e.imageSmoothingEnabled = this.imageSmoothing, super.drawCacheOnCanvas(e);
  }
  shouldCache() {
    return this.needsItsOwnCache();
  }
  _renderFill(e) {
    const n = this._element;
    if (!n) return;
    const s = this._filterScalingX, i = this._filterScalingY, o = this.width, a = this.height, l = Math.max(this.cropX, 0), c = Math.max(this.cropY, 0), u = n.naturalWidth || n.width, h = n.naturalHeight || n.height, f = l * s, m = c * i, p = Math.min(o * s, u - f), y = Math.min(a * i, h - m), v = -o / 2, _ = -a / 2, g = Math.min(o, u / s - l), C = Math.min(a, h / i - c);
    n && e.drawImage(n, f, m, p, y, v, _, g, C);
  }
  _needsResize() {
    const e = this.getTotalObjectScaling();
    return e.x !== this._lastScaleX || e.y !== this._lastScaleY;
  }
  _resetWidthHeight() {
    this.set(this.getOriginalSize());
  }
  _setWidthHeight() {
    let { width: e, height: n } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const s = this.getOriginalSize();
    this.width = e || s.width, this.height = n || s.height;
  }
  parsePreserveAspectRatioAttribute() {
    const e = mC(this.preserveAspectRatio || ""), n = this.width, s = this.height, i = { width: n, height: s };
    let o, a = this._element.width, l = this._element.height, c = 1, u = 1, h = 0, f = 0, m = 0, p = 0;
    return !e || e.alignX === Ge && e.alignY === Ge ? (c = n / a, u = s / l) : (e.meetOrSlice === "meet" && (c = u = Dk(this._element, i), o = (n - a * c) / 2, e.alignX === "Min" && (h = -o), e.alignX === "Max" && (h = o), o = (s - l * u) / 2, e.alignY === "Min" && (f = -o), e.alignY === "Max" && (f = o)), e.meetOrSlice === "slice" && (c = u = Ak(this._element, i), o = a - n / c, e.alignX === "Mid" && (m = o / 2), e.alignX === "Max" && (m = o), o = l - s / u, e.alignY === "Mid" && (p = o / 2), e.alignY === "Max" && (p = o), a = n / c, l = s / u)), { width: a, height: l, scaleX: c, scaleY: u, offsetLeft: h, offsetTop: f, cropX: m, cropY: p };
  }
  static fromObject(e, n) {
    let { filters: s, resizeFilter: i, src: o, crossOrigin: a, type: l } = e, c = ue(e, ST);
    return Promise.all([go(o, st(st({}, n), {}, { crossOrigin: a })), s && hr(s, n), i && hr([i], n), la(c, n)]).then((u) => {
      let [h, f = [], [m] = [], p = {}] = u;
      return new this(h, st(st({}, c), {}, { src: o, filters: f, resizeFilter: m }, p));
    });
  }
  static fromURL(e) {
    let { crossOrigin: n = null, signal: s } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
    return go(e, { crossOrigin: n, signal: s }).then((o) => new this(o, i));
  }
  static async fromElement(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = arguments.length > 2 ? arguments[2] : void 0;
    const i = cs(e, this.ATTRIBUTE_NAMES, s);
    return this.fromURL(i["xlink:href"] || i.href, n, i).catch((o) => (Ss("log", "Unable to parse Image", o), null));
  }
}
nt(He, "type", "Image"), nt(He, "cacheProperties", [...ls, ...ef]), nt(He, "ownDefaults", { strokeWidth: 0, srcFromAttribute: !1, minimumScaleTrigger: 0.5, cropX: 0, cropY: 0, imageSmoothing: !0 }), nt(He, "CSS_CANVAS", "canvas-img"), nt(He, "ATTRIBUTE_NAMES", [...Ts, "x", "y", "width", "height", "preserveAspectRatio", "xlink:href", "href", "crossOrigin", "image-rendering"]), Et.setClass(He), Et.setSVGClass(He);
ua(["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"]);
const pa = (r) => r.webgl !== void 0, sc = "precision highp float", CT = `
    `.concat(sc, `;
    varying vec2 vTexCoord;
    uniform sampler2D uTexture;
    void main() {
      gl_FragColor = texture2D(uTexture, vTexCoord);
    }`), kT = ["type"], TT = ["type"], MT = new RegExp(sc, "g");
class Me {
  get type() {
    return this.constructor.type;
  }
  constructor() {
    let e = ue(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, kT);
    Object.assign(this, this.constructor.defaults, e);
  }
  getFragmentSource() {
    return CT;
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aPosition;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }`;
  }
  createProgram(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getFragmentSource(), s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.getVertexSource();
    const { WebGLProbe: { GLPrecision: i = "highp" } } = Fn();
    i !== "highp" && (n = n.replace(MT, sc.replace("highp", i)));
    const o = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER), l = e.createProgram();
    if (!o || !a || !l) throw new Pn("Vertex, fragment shader or program creation error");
    if (e.shaderSource(o, s), e.compileShader(o), !e.getShaderParameter(o, e.COMPILE_STATUS)) throw new Pn("Vertex shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(o)));
    if (e.shaderSource(a, n), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS)) throw new Pn("Fragment shader compile error for ".concat(this.type, ": ").concat(e.getShaderInfoLog(a)));
    if (e.attachShader(l, o), e.attachShader(l, a), e.linkProgram(l), !e.getProgramParameter(l, e.LINK_STATUS)) throw new Pn('Shader link error for "'.concat(this.type, '" ').concat(e.getProgramInfoLog(l)));
    const c = this.getUniformLocations(e, l) || {};
    return c.uStepW = e.getUniformLocation(l, "uStepW"), c.uStepH = e.getUniformLocation(l, "uStepH"), { program: l, attributeLocations: this.getAttributeLocations(e, l), uniformLocations: c };
  }
  getAttributeLocations(e, n) {
    return { aPosition: e.getAttribLocation(n, "aPosition") };
  }
  getUniformLocations(e, n) {
    const s = this.constructor.uniformLocations, i = {};
    for (let o = 0; o < s.length; o++) i[s[o]] = e.getUniformLocation(n, s[o]);
    return i;
  }
  sendAttributeData(e, n, s) {
    const i = n.aPosition, o = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, o), e.enableVertexAttribArray(i), e.vertexAttribPointer(i, 2, e.FLOAT, !1, 0, 0), e.bufferData(e.ARRAY_BUFFER, s, e.STATIC_DRAW);
  }
  _setupFrameBuffer(e) {
    const n = e.context;
    if (e.passes > 1) {
      const s = e.destinationWidth, i = e.destinationHeight;
      e.sourceWidth === s && e.sourceHeight === i || (n.deleteTexture(e.targetTexture), e.targetTexture = e.filterBackend.createTexture(n, s, i)), n.framebufferTexture2D(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, e.targetTexture, 0);
    } else n.bindFramebuffer(n.FRAMEBUFFER, null), n.finish();
  }
  _swapTextures(e) {
    e.passes--, e.pass++;
    const n = e.targetTexture;
    e.targetTexture = e.sourceTexture, e.sourceTexture = n;
  }
  isNeutralState(e) {
    return !1;
  }
  applyTo(e) {
    pa(e) ? (this._setupFrameBuffer(e), this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
  }
  getCacheKey() {
    return this.type;
  }
  retrieveShader(e) {
    const n = this.getCacheKey();
    return e.programCache[n] || (e.programCache[n] = this.createProgram(e.context)), e.programCache[n];
  }
  applyToWebGL(e) {
    const n = e.context, s = this.retrieveShader(e);
    e.pass === 0 && e.originalTexture ? n.bindTexture(n.TEXTURE_2D, e.originalTexture) : n.bindTexture(n.TEXTURE_2D, e.sourceTexture), n.useProgram(s.program), this.sendAttributeData(n, s.attributeLocations, e.aPosition), n.uniform1f(s.uniformLocations.uStepW, 1 / e.sourceWidth), n.uniform1f(s.uniformLocations.uStepH, 1 / e.sourceHeight), this.sendUniformData(n, s.uniformLocations), n.viewport(0, 0, e.destinationWidth, e.destinationHeight), n.drawArrays(n.TRIANGLE_STRIP, 0, 4);
  }
  bindAdditionalTexture(e, n, s) {
    e.activeTexture(s), e.bindTexture(e.TEXTURE_2D, n), e.activeTexture(e.TEXTURE0);
  }
  unbindAdditionalTexture(e, n) {
    e.activeTexture(n), e.bindTexture(e.TEXTURE_2D, null), e.activeTexture(e.TEXTURE0);
  }
  sendUniformData(e, n) {
  }
  createHelpLayer(e) {
    if (!e.helpLayer) {
      const { sourceWidth: n, sourceHeight: s } = e, i = ln({ width: n, height: s });
      e.helpLayer = i;
    }
  }
  toObject() {
    const e = Object.keys(this.constructor.defaults || {});
    return st({ type: this.type }, e.reduce((n, s) => (n[s] = this[s], n), {}));
  }
  toJSON() {
    return this.toObject();
  }
  static async fromObject(e, n) {
    return new this(ue(e, TT));
  }
}
nt(Me, "type", "BaseFilter"), nt(Me, "uniformLocations", []);
const OT = { multiply: `gl_FragColor.rgb *= uColor.rgb;
`, screen: `gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);
`, add: `gl_FragColor.rgb += uColor.rgb;
`, difference: `gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);
`, subtract: `gl_FragColor.rgb -= uColor.rgb;
`, lighten: `gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);
`, darken: `gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);
`, exclusion: `gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);
`, overlay: `
    if (uColor.r < 0.5) {
      gl_FragColor.r *= 2.0 * uColor.r;
    } else {
      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);
    }
    if (uColor.g < 0.5) {
      gl_FragColor.g *= 2.0 * uColor.g;
    } else {
      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);
    }
    if (uColor.b < 0.5) {
      gl_FragColor.b *= 2.0 * uColor.b;
    } else {
      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);
    }
    `, tint: `
    gl_FragColor.rgb *= (1.0 - uColor.a);
    gl_FragColor.rgb += uColor.rgb;
    ` };
class Ur extends Me {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec4 uColor;
      varying vec2 vTexCoord;
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        gl_FragColor = color;
        if (color.a > 0.0) {
          `.concat(OT[this.mode], `
        }
      }
      `);
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = new ee(this.color).getSource(), i = this.alpha, o = s[0] * i, a = s[1] * i, l = s[2] * i, c = 1 - i;
    for (let u = 0; u < n.length; u += 4) {
      const h = n[u], f = n[u + 1], m = n[u + 2];
      let p, y, v;
      switch (this.mode) {
        case "multiply":
          p = h * o / 255, y = f * a / 255, v = m * l / 255;
          break;
        case "screen":
          p = 255 - (255 - h) * (255 - o) / 255, y = 255 - (255 - f) * (255 - a) / 255, v = 255 - (255 - m) * (255 - l) / 255;
          break;
        case "add":
          p = h + o, y = f + a, v = m + l;
          break;
        case "difference":
          p = Math.abs(h - o), y = Math.abs(f - a), v = Math.abs(m - l);
          break;
        case "subtract":
          p = h - o, y = f - a, v = m - l;
          break;
        case "darken":
          p = Math.min(h, o), y = Math.min(f, a), v = Math.min(m, l);
          break;
        case "lighten":
          p = Math.max(h, o), y = Math.max(f, a), v = Math.max(m, l);
          break;
        case "overlay":
          p = o < 128 ? 2 * h * o / 255 : 255 - 2 * (255 - h) * (255 - o) / 255, y = a < 128 ? 2 * f * a / 255 : 255 - 2 * (255 - f) * (255 - a) / 255, v = l < 128 ? 2 * m * l / 255 : 255 - 2 * (255 - m) * (255 - l) / 255;
          break;
        case "exclusion":
          p = o + h - 2 * o * h / 255, y = a + f - 2 * a * f / 255, v = l + m - 2 * l * m / 255;
          break;
        case "tint":
          p = o + h * c, y = a + f * c, v = l + m * c;
      }
      n[u] = p, n[u + 1] = y, n[u + 2] = v;
    }
  }
  sendUniformData(e, n) {
    const s = new ee(this.color).getSource();
    s[0] = this.alpha * s[0] / 255, s[1] = this.alpha * s[1] / 255, s[2] = this.alpha * s[2] / 255, s[3] = this.alpha, e.uniform4fv(n.uColor, s);
  }
}
nt(Ur, "defaults", { color: "#F95C63", mode: "multiply", alpha: 1 }), nt(Ur, "type", "BlendColor"), nt(Ur, "uniformLocations", ["uColor"]), Et.setClass(Ur);
const ET = { multiply: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.rgba *= color2.rgba;
      gl_FragColor = color;
    }
    `, mask: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform sampler2D uImage;
    uniform vec4 uColor;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      vec4 color2 = texture2D(uImage, vTexCoord2);
      color.a = color2.a;
      gl_FragColor = color;
    }
    ` }, PT = ["type", "image"];
class Hr extends Me {
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return ET[this.mode];
  }
  getVertexSource() {
    return `
    attribute vec2 aPosition;
    varying vec2 vTexCoord;
    varying vec2 vTexCoord2;
    uniform mat3 uTransformMatrix;
    void main() {
      vTexCoord = aPosition;
      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;
      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);
    }
    `;
  }
  applyToWebGL(e) {
    const n = e.context, s = this.createTexture(e.filterBackend, this.image);
    this.bindAdditionalTexture(n, s, n.TEXTURE1), super.applyToWebGL(e), this.unbindAdditionalTexture(n, n.TEXTURE1);
  }
  createTexture(e, n) {
    return e.getCachedTexture(n.cacheKey, n.getElement());
  }
  calculateMatrix() {
    const e = this.image, { width: n, height: s } = e.getElement();
    return [1 / e.scaleX, 0, 0, 0, 1 / e.scaleY, 0, -e.left / n, -e.top / s, 1];
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: s, height: i }, filterBackend: { resources: o } } = e;
    const a = this.image;
    o.blendImage || (o.blendImage = rs());
    const l = o.blendImage, c = l.getContext("2d");
    l.width !== s || l.height !== i ? (l.width = s, l.height = i) : c.clearRect(0, 0, s, i), c.setTransform(a.scaleX, 0, 0, a.scaleY, a.left, a.top), c.drawImage(a.getElement(), 0, 0, s, i);
    const u = c.getImageData(0, 0, s, i).data;
    for (let h = 0; h < n.length; h += 4) {
      const f = n[h], m = n[h + 1], p = n[h + 2], y = n[h + 3], v = u[h], _ = u[h + 1], g = u[h + 2], C = u[h + 3];
      switch (this.mode) {
        case "multiply":
          n[h] = f * v / 255, n[h + 1] = m * _ / 255, n[h + 2] = p * g / 255, n[h + 3] = y * C / 255;
          break;
        case "mask":
          n[h + 3] = C;
      }
    }
  }
  sendUniformData(e, n) {
    const s = this.calculateMatrix();
    e.uniform1i(n.uImage, 1), e.uniformMatrix3fv(n.uTransformMatrix, !1, s);
  }
  toObject() {
    return st(st({}, super.toObject()), {}, { image: this.image && this.image.toObject() });
  }
  static async fromObject(e, n) {
    let { type: s, image: i } = e, o = ue(e, PT);
    return He.fromObject(i, n).then((a) => new this(st(st({}, o), {}, { image: a })));
  }
}
nt(Hr, "type", "BlendImage"), nt(Hr, "defaults", { mode: "multiply", alpha: 1 }), nt(Hr, "uniformLocations", ["uTransformMatrix", "uImage"]), Et.setClass(Hr);
class Xr extends Me {
  getFragmentSource() {
    return `
    precision highp float;
    uniform sampler2D uTexture;
    uniform vec2 uDelta;
    varying vec2 vTexCoord;
    const float nSamples = 15.0;
    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);
    float random(vec3 scale) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);
    }
    void main() {
      vec4 color = vec4(0.0);
      float totalC = 0.0;
      float totalA = 0.0;
      float offset = random(v3offset);
      for (float t = -nSamples; t <= nSamples; t++) {
        float percent = (t + offset - 0.5) / nSamples;
        vec4 sample = texture2D(uTexture, vTexCoord + uDelta * percent);
        float weight = 1.0 - abs(percent);
        float alpha = weight * sample.a;
        color.rgb += sample.rgb * alpha;
        color.a += alpha;
        totalA += weight;
        totalC += alpha;
      }
      gl_FragColor.rgb = color.rgb / totalC;
      gl_FragColor.a = color.a / totalA;
    }
  `;
  }
  applyTo(e) {
    pa(e) ? (this.aspectRatio = e.sourceWidth / e.sourceHeight, e.passes++, this._setupFrameBuffer(e), this.horizontal = !0, this.applyToWebGL(e), this._swapTextures(e), this._setupFrameBuffer(e), this.horizontal = !1, this.applyToWebGL(e), this._swapTextures(e)) : this.applyTo2d(e);
  }
  applyTo2d(e) {
    let { imageData: { data: n, width: s, height: i } } = e;
    this.aspectRatio = s / i, this.horizontal = !0;
    let o = this.getBlurValue() * s;
    const a = new Uint8ClampedArray(n), l = 15, c = 4 * s;
    for (let u = 0; u < n.length; u += 4) {
      let h = 0, f = 0, m = 0, p = 0, y = 0;
      const v = u - u % c, _ = v + c;
      for (let g = -14; g < l; g++) {
        const C = g / l, x = 4 * Math.floor(o * C), k = 1 - Math.abs(C);
        let w = u + x;
        w < v ? w = v : w > _ && (w = _);
        const T = n[w + 3] * k;
        h += n[w] * T, f += n[w + 1] * T, m += n[w + 2] * T, p += T, y += k;
      }
      a[u] = h / p, a[u + 1] = f / p, a[u + 2] = m / p, a[u + 3] = p / y;
    }
    this.horizontal = !1, o = this.getBlurValue() * i;
    for (let u = 0; u < a.length; u += 4) {
      let h = 0, f = 0, m = 0, p = 0, y = 0;
      const v = u % c, _ = a.length - c + v;
      for (let g = -14; g < l; g++) {
        const C = g / l, x = Math.floor(o * C) * c, k = 1 - Math.abs(C);
        let w = u + x;
        w < v ? w = v : w > _ && (w = _);
        const T = a[w + 3] * k;
        h += a[w] * T, f += a[w + 1] * T, m += a[w + 2] * T, p += T, y += k;
      }
      n[u] = h / p, n[u + 1] = f / p, n[u + 2] = m / p, n[u + 3] = p / y;
    }
  }
  sendUniformData(e, n) {
    const s = this.chooseRightDelta();
    e.uniform2fv(n.uDelta, s);
  }
  isNeutralState() {
    return this.blur === 0;
  }
  getBlurValue() {
    let e = 1;
    const { horizontal: n, aspectRatio: s } = this;
    return n ? s > 1 && (e = 1 / s) : s < 1 && (e = s), e * this.blur * 0.12;
  }
  chooseRightDelta() {
    const e = this.getBlurValue();
    return this.horizontal ? [e, 0] : [0, e];
  }
}
nt(Xr, "type", "Blur"), nt(Xr, "defaults", { blur: 0 }), nt(Xr, "uniformLocations", ["uDelta"]), Et.setClass(Xr);
class Gr extends Me {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBrightness;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += uBrightness;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = Math.round(255 * this.brightness);
    for (let i = 0; i < n.length; i += 4) n[i] += s, n[i + 1] += s, n[i + 2] += s;
  }
  isNeutralState() {
    return this.brightness === 0;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBrightness, this.brightness);
  }
}
nt(Gr, "type", "Brightness"), nt(Gr, "defaults", { brightness: 0 }), nt(Gr, "uniformLocations", ["uBrightness"]), Et.setClass(Gr);
const nf = { matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], colorsOnly: !0 };
class oi extends Me {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  varying vec2 vTexCoord;
  uniform mat4 uColorMatrix;
  uniform vec4 uConstants;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color *= uColorMatrix;
    color += uConstants;
    gl_FragColor = color;
  }`;
  }
  applyTo2d(e) {
    const n = e.imageData.data, s = this.matrix, i = this.colorsOnly;
    for (let o = 0; o < n.length; o += 4) {
      const a = n[o], l = n[o + 1], c = n[o + 2];
      if (n[o] = a * s[0] + l * s[1] + c * s[2] + 255 * s[4], n[o + 1] = a * s[5] + l * s[6] + c * s[7] + 255 * s[9], n[o + 2] = a * s[10] + l * s[11] + c * s[12] + 255 * s[14], !i) {
        const u = n[o + 3];
        n[o] += u * s[3], n[o + 1] += u * s[8], n[o + 2] += u * s[13], n[o + 3] = a * s[15] + l * s[16] + c * s[17] + u * s[18] + 255 * s[19];
      }
    }
  }
  sendUniformData(e, n) {
    const s = this.matrix, i = [s[0], s[1], s[2], s[3], s[5], s[6], s[7], s[8], s[10], s[11], s[12], s[13], s[15], s[16], s[17], s[18]], o = [s[4], s[9], s[14], s[19]];
    e.uniformMatrix4fv(n.uColorMatrix, !1, i), e.uniform4fv(n.uConstants, o);
  }
  toObject() {
    return st(st({}, super.toObject()), {}, { matrix: [...this.matrix] });
  }
}
function Gs(r, e) {
  var n;
  const s = (nt(n = class extends oi {
    toObject() {
      return { type: this.type, colorsOnly: this.colorsOnly };
    }
  }, "type", r), nt(n, "defaults", { colorsOnly: !1, matrix: e }), n);
  return Et.setClass(s, r), s;
}
nt(oi, "type", "ColorMatrix"), nt(oi, "defaults", nf), nt(oi, "uniformLocations", ["uColorMatrix", "uConstants"]), Et.setClass(oi);
Gs("Brownie", [0.5997, 0.34553, -0.27082, 0, 0.186, -0.0377, 0.86095, 0.15059, 0, -0.1449, 0.24113, -0.07441, 0.44972, 0, -0.02965, 0, 0, 0, 1, 0]);
Gs("Vintage", [0.62793, 0.32021, -0.03965, 0, 0.03784, 0.02578, 0.64411, 0.03259, 0, 0.02926, 0.0466, -0.08512, 0.52416, 0, 0.02023, 0, 0, 0, 1, 0]);
Gs("Kodachrome", [1.12855, -0.39673, -0.03992, 0, 0.24991, -0.16404, 1.08352, -0.05498, 0, 0.09698, -0.16786, -0.56034, 1.60148, 0, 0.13972, 0, 0, 0, 1, 0]);
Gs("Technicolor", [1.91252, -0.85453, -0.09155, 0, 0.04624, -0.30878, 1.76589, -0.10601, 0, -0.27589, -0.2311, -0.75018, 1.84759, 0, 0.12137, 0, 0, 0, 1, 0]);
Gs("Polaroid", [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0]);
Gs("Sepia", [0.393, 0.769, 0.189, 0, 0, 0.349, 0.686, 0.168, 0, 0, 0.272, 0.534, 0.131, 0, 0, 0, 0, 0, 1, 0]);
Gs("BlackWhite", [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0]);
class Pu extends Me {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.subFilters = e.subFilters || [];
  }
  applyTo(e) {
    pa(e) && (e.passes += this.subFilters.length - 1), this.subFilters.forEach((n) => {
      n.applyTo(e);
    });
  }
  toObject() {
    return { type: this.type, subFilters: this.subFilters.map((e) => e.toObject()) };
  }
  isNeutralState() {
    return !this.subFilters.some((e) => !e.isNeutralState());
  }
  static fromObject(e, n) {
    return Promise.all((e.subFilters || []).map((s) => Et.getClass(s.type).fromObject(s, n))).then((s) => new this({ subFilters: s }));
  }
}
nt(Pu, "type", "Composed"), Et.setClass(Pu);
class Yr extends Me {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uContrast;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));
    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;
    gl_FragColor = color;
  }`;
  }
  isNeutralState() {
    return this.contrast === 0;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = Math.floor(255 * this.contrast), i = 259 * (s + 255) / (255 * (259 - s));
    for (let o = 0; o < n.length; o += 4) n[o] = i * (n[o] - 128) + 128, n[o + 1] = i * (n[o + 1] - 128) + 128, n[o + 2] = i * (n[o + 2] - 128) + 128;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uContrast, this.contrast);
  }
}
nt(Yr, "type", "Contrast"), nt(Yr, "defaults", { contrast: 0 }), nt(Yr, "uniformLocations", ["uContrast"]), Et.setClass(Yr);
const DT = { Convolute_3_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_3_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[9];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 3.0; h+=1.0) {
        for (float w = 0.0; w < 3.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_5_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_5_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[25];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 5.0; h+=1.0) {
        for (float w = 0.0; w < 5.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_7_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_7_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[49];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 7.0; h+=1.0) {
        for (float w = 0.0; w < 7.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    `, Convolute_9_1: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 0);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];
        }
      }
      gl_FragColor = color;
    }
    `, Convolute_9_0: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform float uMatrix[81];
    uniform float uStepW;
    uniform float uStepH;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = vec4(0, 0, 0, 1);
      for (float h = 0.0; h < 9.0; h+=1.0) {
        for (float w = 0.0; w < 9.0; w+=1.0) {
          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));
          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];
        }
      }
      float alpha = texture2D(uTexture, vTexCoord).a;
      gl_FragColor = color;
      gl_FragColor.a = alpha;
    }
    ` };
class Kr extends Me {
  getCacheKey() {
    return "".concat(this.type, "_").concat(Math.sqrt(this.matrix.length), "_").concat(this.opaque ? 1 : 0);
  }
  getFragmentSource() {
    return DT[this.getCacheKey()];
  }
  applyTo2d(e) {
    const n = e.imageData, s = n.data, i = this.matrix, o = Math.round(Math.sqrt(i.length)), a = Math.floor(o / 2), l = n.width, c = n.height, u = e.ctx.createImageData(l, c), h = u.data, f = this.opaque ? 1 : 0;
    let m, p, y, v, _, g, C, x, k, w, T, P, z;
    for (T = 0; T < c; T++) for (w = 0; w < l; w++) {
      for (_ = 4 * (T * l + w), m = 0, p = 0, y = 0, v = 0, z = 0; z < o; z++) for (P = 0; P < o; P++) C = T + z - a, g = w + P - a, C < 0 || C >= c || g < 0 || g >= l || (x = 4 * (C * l + g), k = i[z * o + P], m += s[x] * k, p += s[x + 1] * k, y += s[x + 2] * k, f || (v += s[x + 3] * k));
      h[_] = m, h[_ + 1] = p, h[_ + 2] = y, h[_ + 3] = f ? s[_ + 3] : v;
    }
    e.imageData = u;
  }
  sendUniformData(e, n) {
    e.uniform1fv(n.uMatrix, this.matrix);
  }
  toObject() {
    return st(st({}, super.toObject()), {}, { opaque: this.opaque, matrix: [...this.matrix] });
  }
}
nt(Kr, "type", "Convolute"), nt(Kr, "defaults", { opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0] }), nt(Kr, "uniformLocations", ["uMatrix", "uOpaque", "uHalfSize", "uSize"]), Et.setClass(Kr);
const sf = "Gamma";
class qr extends Me {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform vec3 uGamma;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    vec3 correction = (1.0 / uGamma);
    color.r = pow(color.r, correction.r);
    color.g = pow(color.g, correction.g);
    color.b = pow(color.b, correction.b);
    gl_FragColor = color;
    gl_FragColor.rgb *= color.a;
  }
`;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e), this.gamma = e.gamma || this.constructor.defaults.gamma.concat();
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = this.gamma, i = 1 / s[0], o = 1 / s[1], a = 1 / s[2];
    this.rgbValues || (this.rgbValues = { r: new Uint8Array(256), g: new Uint8Array(256), b: new Uint8Array(256) });
    const l = this.rgbValues;
    for (let c = 0; c < 256; c++) l.r[c] = 255 * Math.pow(c / 255, i), l.g[c] = 255 * Math.pow(c / 255, o), l.b[c] = 255 * Math.pow(c / 255, a);
    for (let c = 0; c < n.length; c += 4) n[c] = l.r[n[c]], n[c + 1] = l.g[n[c + 1]], n[c + 2] = l.b[n[c + 2]];
  }
  sendUniformData(e, n) {
    e.uniform3fv(n.uGamma, this.gamma);
  }
  isNeutralState() {
    const { gamma: e } = this;
    return e[0] === 1 && e[1] === 1 && e[2] === 1;
  }
  toObject() {
    return { type: sf, gamma: this.gamma.concat() };
  }
}
nt(qr, "type", sf), nt(qr, "defaults", { gamma: [1, 1, 1] }), nt(qr, "uniformLocations", ["uGamma"]), Et.setClass(qr);
const AT = { average: `
    precision highp float;
    uniform sampler2D uTexture;
    varying vec2 vTexCoord;
    void main() {
      vec4 color = texture2D(uTexture, vTexCoord);
      float average = (color.r + color.b + color.g) / 3.0;
      gl_FragColor = vec4(average, average, average, color.a);
    }
    `, lightness: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    `, luminosity: `
    precision highp float;
    uniform sampler2D uTexture;
    uniform int uMode;
    varying vec2 vTexCoord;
    void main() {
      vec4 col = texture2D(uTexture, vTexCoord);
      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;
      gl_FragColor = vec4(average, average, average, col.a);
    }
    ` };
class Zr extends Me {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let s, i = 0; i < n.length; i += 4) {
      const o = n[i], a = n[i + 1], l = n[i + 2];
      switch (this.mode) {
        case "average":
          s = (o + a + l) / 3;
          break;
        case "lightness":
          s = (Math.min(o, a, l) + Math.max(o, a, l)) / 2;
          break;
        case "luminosity":
          s = 0.21 * o + 0.72 * a + 0.07 * l;
      }
      n[i + 2] = n[i + 1] = n[i] = s;
    }
  }
  getCacheKey() {
    return "".concat(this.type, "_").concat(this.mode);
  }
  getFragmentSource() {
    return AT[this.mode];
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uMode, 1);
  }
  isNeutralState() {
    return !1;
  }
}
nt(Zr, "type", "Grayscale"), nt(Zr, "defaults", { mode: "average" }), nt(Zr, "uniformLocations", ["uMode"]), Et.setClass(Zr);
const FT = st(st({}, nf), {}, { rotation: 0 });
class Ua extends oi {
  calculateMatrix() {
    const e = this.rotation * Math.PI, n = ss(e), s = is(e), i = 1 / 3, o = Math.sqrt(i) * s, a = 1 - n;
    this.matrix = [n + a / 3, i * a - o, i * a + o, 0, 0, i * a + o, n + i * a, i * a - o, 0, 0, i * a - o, i * a + o, n + i * a, 0, 0, 0, 0, 0, 1, 0];
  }
  isNeutralState() {
    return this.rotation === 0;
  }
  applyTo(e) {
    this.calculateMatrix(), super.applyTo(e);
  }
  toObject() {
    return { type: this.type, rotation: this.rotation };
  }
}
nt(Ua, "type", "HueRotation"), nt(Ua, "defaults", FT), Et.setClass(Ua);
class Jr extends Me {
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    for (let s = 0; s < n.length; s += 4) n[s] = 255 - n[s], n[s + 1] = 255 - n[s + 1], n[s + 2] = 255 - n[s + 2], this.alpha && (n[s + 3] = 255 - n[s + 3]);
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform int uInvert;
  uniform int uAlpha;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    if (uInvert == 1) {
      if (uAlpha == 1) {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);
      } else {
        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);
      }
    } else {
      gl_FragColor = color;
    }
  }
`;
  }
  isNeutralState() {
    return !this.invert;
  }
  sendUniformData(e, n) {
    e.uniform1i(n.uInvert, Number(this.invert)), e.uniform1i(n.uAlpha, Number(this.alpha));
  }
}
nt(Jr, "type", "Invert"), nt(Jr, "defaults", { alpha: !1, invert: !0 }), nt(Jr, "uniformLocations", ["uInvert", "uAlpha"]), Et.setClass(Jr);
class Qr extends Me {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uStepH;
  uniform float uNoise;
  uniform float uSeed;
  varying vec2 vTexCoord;
  float rand(vec2 co, float seed, float vScale) {
    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);
  }
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = this.noise;
    for (let i = 0; i < n.length; i += 4) {
      const o = (0.5 - Math.random()) * s;
      n[i] += o, n[i + 1] += o, n[i + 2] += o;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uNoise, this.noise / 255), e.uniform1f(n.uSeed, Math.random());
  }
  isNeutralState() {
    return this.noise === 0;
  }
}
nt(Qr, "type", "Noise"), nt(Qr, "defaults", { noise: 0 }), nt(Qr, "uniformLocations", ["uNoise", "uSeed"]), Et.setClass(Qr);
class to extends Me {
  applyTo2d(e) {
    let { imageData: { data: n, width: s, height: i } } = e;
    for (let o = 0; o < i; o += this.blocksize) for (let a = 0; a < s; a += this.blocksize) {
      const l = 4 * o * s + 4 * a, c = n[l], u = n[l + 1], h = n[l + 2], f = n[l + 3];
      for (let m = o; m < Math.min(o + this.blocksize, i); m++) for (let p = a; p < Math.min(a + this.blocksize, s); p++) {
        const y = 4 * m * s + 4 * p;
        n[y] = c, n[y + 1] = u, n[y + 2] = h, n[y + 3] = f;
      }
    }
  }
  isNeutralState() {
    return this.blocksize === 1;
  }
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uBlocksize;
  uniform float uStepW;
  uniform float uStepH;
  varying vec2 vTexCoord;
  void main() {
    float blockW = uBlocksize * uStepW;
    float blockH = uBlocksize * uStepH;
    int posX = int(vTexCoord.x / blockW);
    int posY = int(vTexCoord.y / blockH);
    float fposX = float(posX);
    float fposY = float(posY);
    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);
    vec4 color = texture2D(uTexture, squareCoords);
    gl_FragColor = color;
  }
`;
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uBlocksize, this.blocksize);
  }
}
nt(to, "type", "Pixelate"), nt(to, "defaults", { blocksize: 4 }), nt(to, "uniformLocations", ["uBlocksize"]), Et.setClass(to);
class eo extends Me {
  getFragmentSource() {
    return `
precision highp float;
uniform sampler2D uTexture;
uniform vec4 uLow;
uniform vec4 uHigh;
varying vec2 vTexCoord;
void main() {
  gl_FragColor = texture2D(uTexture, vTexCoord);
  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {
    gl_FragColor.a = 0.0;
  }
}
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = 255 * this.distance, i = new ee(this.color).getSource(), o = [i[0] - s, i[1] - s, i[2] - s], a = [i[0] + s, i[1] + s, i[2] + s];
    for (let l = 0; l < n.length; l += 4) {
      const c = n[l], u = n[l + 1], h = n[l + 2];
      c > o[0] && u > o[1] && h > o[2] && c < a[0] && u < a[1] && h < a[2] && (n[l + 3] = 0);
    }
  }
  sendUniformData(e, n) {
    const s = new ee(this.color).getSource(), i = this.distance, o = [0 + s[0] / 255 - i, 0 + s[1] / 255 - i, 0 + s[2] / 255 - i, 1], a = [s[0] / 255 + i, s[1] / 255 + i, s[2] / 255 + i, 1];
    e.uniform4fv(n.uLow, o), e.uniform4fv(n.uHigh, a);
  }
}
nt(eo, "type", "RemoveColor"), nt(eo, "defaults", { color: "#FFFFFF", distance: 0.02, useAlpha: !1 }), nt(eo, "uniformLocations", ["uLow", "uHigh"]), Et.setClass(eo);
class no extends Me {
  sendUniformData(e, n) {
    e.uniform2fv(n.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), e.uniform1fv(n.uTaps, this.taps);
  }
  getFilterWindow() {
    const e = this.tempScale;
    return Math.ceil(this.lanczosLobes / e);
  }
  getCacheKey() {
    const e = this.getFilterWindow();
    return "".concat(this.type, "_").concat(e);
  }
  getFragmentSource() {
    const e = this.getFilterWindow();
    return this.generateShader(e);
  }
  getTaps() {
    const e = this.lanczosCreate(this.lanczosLobes), n = this.tempScale, s = this.getFilterWindow(), i = new Array(s);
    for (let o = 1; o <= s; o++) i[o - 1] = e(o * n);
    return i;
  }
  generateShader(e) {
    const n = new Array(e);
    for (let s = 1; s <= e; s++) n[s - 1] = "".concat(s, ".0 * uDelta");
    return `
      precision highp float;
      uniform sampler2D uTexture;
      uniform vec2 uDelta;
      varying vec2 vTexCoord;
      uniform float uTaps[`.concat(e, `];
      void main() {
        vec4 color = texture2D(uTexture, vTexCoord);
        float sum = 1.0;
        `).concat(n.map((s, i) => `
              color += texture2D(uTexture, vTexCoord + `.concat(s, ") * uTaps[").concat(i, "] + texture2D(uTexture, vTexCoord - ").concat(s, ") * uTaps[").concat(i, `];
              sum += 2.0 * uTaps[`).concat(i, `];
            `)).join(`
`), `
        gl_FragColor = color / sum;
      }
    `);
  }
  applyToForWebgl(e) {
    e.passes++, this.width = e.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = e.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), e.destinationWidth = this.dW, super.applyTo(e), e.sourceWidth = e.destinationWidth, this.height = e.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), e.destinationHeight = this.dH, super.applyTo(e), e.sourceHeight = e.destinationHeight;
  }
  applyTo(e) {
    pa(e) ? this.applyToForWebgl(e) : this.applyTo2d(e);
  }
  isNeutralState() {
    return this.scaleX === 1 && this.scaleY === 1;
  }
  lanczosCreate(e) {
    return (n) => {
      if (n >= e || n <= -e) return 0;
      if (n < 11920929e-14 && n > -11920929e-14) return 1;
      const s = (n *= Math.PI) / e;
      return Math.sin(n) / n * Math.sin(s) / s;
    };
  }
  applyTo2d(e) {
    const n = e.imageData, s = this.scaleX, i = this.scaleY;
    this.rcpScaleX = 1 / s, this.rcpScaleY = 1 / i;
    const o = n.width, a = n.height, l = Math.round(o * s), c = Math.round(a * i);
    let u;
    u = this.resizeType === "sliceHack" ? this.sliceByTwo(e, o, a, l, c) : this.resizeType === "hermite" ? this.hermiteFastResize(e, o, a, l, c) : this.resizeType === "bilinear" ? this.bilinearFiltering(e, o, a, l, c) : this.resizeType === "lanczos" ? this.lanczosResize(e, o, a, l, c) : new ImageData(l, c), e.imageData = u;
  }
  sliceByTwo(e, n, s, i, o) {
    const a = e.imageData, l = 0.5;
    let c = !1, u = !1, h = n * l, f = s * l;
    const m = e.filterBackend.resources;
    let p = 0, y = 0;
    const v = n;
    let _ = 0;
    m.sliceByTwo || (m.sliceByTwo = rs());
    const g = m.sliceByTwo;
    (g.width < 1.5 * n || g.height < s) && (g.width = 1.5 * n, g.height = s);
    const C = g.getContext("2d");
    for (C.clearRect(0, 0, 1.5 * n, s), C.putImageData(a, 0, 0), i = Math.floor(i), o = Math.floor(o); !c || !u; ) n = h, s = f, i < Math.floor(h * l) ? h = Math.floor(h * l) : (h = i, c = !0), o < Math.floor(f * l) ? f = Math.floor(f * l) : (f = o, u = !0), C.drawImage(g, p, y, n, s, v, _, h, f), p = v, y = _, _ += f;
    return C.getImageData(p, y, i, o);
  }
  lanczosResize(e, n, s, i, o) {
    const a = e.imageData.data, l = e.ctx.createImageData(i, o), c = l.data, u = this.lanczosCreate(this.lanczosLobes), h = this.rcpScaleX, f = this.rcpScaleY, m = 2 / this.rcpScaleX, p = 2 / this.rcpScaleY, y = Math.ceil(h * this.lanczosLobes / 2), v = Math.ceil(f * this.lanczosLobes / 2), _ = {}, g = { x: 0, y: 0 }, C = { x: 0, y: 0 };
    return function x(k) {
      let w, T, P, z, j, ot, vt, L, Y, M, I;
      for (g.x = (k + 0.5) * h, C.x = Math.floor(g.x), w = 0; w < o; w++) {
        for (g.y = (w + 0.5) * f, C.y = Math.floor(g.y), j = 0, ot = 0, vt = 0, L = 0, Y = 0, T = C.x - y; T <= C.x + y; T++) if (!(T < 0 || T >= n)) {
          M = Math.floor(1e3 * Math.abs(T - g.x)), _[M] || (_[M] = {});
          for (let tt = C.y - v; tt <= C.y + v; tt++) tt < 0 || tt >= s || (I = Math.floor(1e3 * Math.abs(tt - g.y)), _[M][I] || (_[M][I] = u(Math.sqrt(Math.pow(M * m, 2) + Math.pow(I * p, 2)) / 1e3)), P = _[M][I], P > 0 && (z = 4 * (tt * n + T), j += P, ot += P * a[z], vt += P * a[z + 1], L += P * a[z + 2], Y += P * a[z + 3]));
        }
        z = 4 * (w * i + k), c[z] = ot / j, c[z + 1] = vt / j, c[z + 2] = L / j, c[z + 3] = Y / j;
      }
      return ++k < i ? x(k) : l;
    }(0);
  }
  bilinearFiltering(e, n, s, i, o) {
    let a, l, c, u, h, f, m, p, y, v, _, g, C, x = 0;
    const k = this.rcpScaleX, w = this.rcpScaleY, T = 4 * (n - 1), P = e.imageData.data, z = e.ctx.createImageData(i, o), j = z.data;
    for (m = 0; m < o; m++) for (p = 0; p < i; p++) for (h = Math.floor(k * p), f = Math.floor(w * m), y = k * p - h, v = w * m - f, C = 4 * (f * n + h), _ = 0; _ < 4; _++) a = P[C + _], l = P[C + 4 + _], c = P[C + T + _], u = P[C + T + 4 + _], g = a * (1 - y) * (1 - v) + l * y * (1 - v) + c * v * (1 - y) + u * y * v, j[x++] = g;
    return z;
  }
  hermiteFastResize(e, n, s, i, o) {
    const a = this.rcpScaleX, l = this.rcpScaleY, c = Math.ceil(a / 2), u = Math.ceil(l / 2), h = e.imageData.data, f = e.ctx.createImageData(i, o), m = f.data;
    for (let p = 0; p < o; p++) for (let y = 0; y < i; y++) {
      const v = 4 * (y + p * i);
      let _ = 0, g = 0, C = 0, x = 0, k = 0, w = 0, T = 0;
      const P = (p + 0.5) * l;
      for (let z = Math.floor(p * l); z < (p + 1) * l; z++) {
        const j = Math.abs(P - (z + 0.5)) / u, ot = (y + 0.5) * a, vt = j * j;
        for (let L = Math.floor(y * a); L < (y + 1) * a; L++) {
          let Y = Math.abs(ot - (L + 0.5)) / c;
          const M = Math.sqrt(vt + Y * Y);
          M > 1 && M < -1 || (_ = 2 * M * M * M - 3 * M * M + 1, _ > 0 && (Y = 4 * (L + z * n), T += _ * h[Y + 3], C += _, h[Y + 3] < 255 && (_ = _ * h[Y + 3] / 250), x += _ * h[Y], k += _ * h[Y + 1], w += _ * h[Y + 2], g += _));
        }
      }
      m[v] = x / g, m[v + 1] = k / g, m[v + 2] = w / g, m[v + 3] = T / C;
    }
    return f;
  }
}
nt(no, "type", "Resize"), nt(no, "defaults", { resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3 }), nt(no, "uniformLocations", ["uDelta", "uTaps"]), Et.setClass(no);
class so extends Me {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uSaturation;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float rgMax = max(color.r, color.g);
    float rgbMax = max(rgMax, color.b);
    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;
    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;
    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = -this.saturation;
    for (let i = 0; i < n.length; i += 4) {
      const o = n[i], a = n[i + 1], l = n[i + 2], c = Math.max(o, a, l);
      n[i] += c !== o ? (c - o) * s : 0, n[i + 1] += c !== a ? (c - a) * s : 0, n[i + 2] += c !== l ? (c - l) * s : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uSaturation, -this.saturation);
  }
  isNeutralState() {
    return this.saturation === 0;
  }
}
nt(so, "type", "Saturation"), nt(so, "defaults", { saturation: 0 }), nt(so, "uniformLocations", ["uSaturation"]), Et.setClass(so);
class io extends Me {
  getFragmentSource() {
    return `
  precision highp float;
  uniform sampler2D uTexture;
  uniform float uVibrance;
  varying vec2 vTexCoord;
  void main() {
    vec4 color = texture2D(uTexture, vTexCoord);
    float max = max(color.r, max(color.g, color.b));
    float avg = (color.r + color.g + color.b) / 3.0;
    float amt = (abs(max - avg) * 2.0) * uVibrance;
    color.r += max != color.r ? (max - color.r) * amt : 0.00;
    color.g += max != color.g ? (max - color.g) * amt : 0.00;
    color.b += max != color.b ? (max - color.b) * amt : 0.00;
    gl_FragColor = color;
  }
`;
  }
  applyTo2d(e) {
    let { imageData: { data: n } } = e;
    const s = -this.vibrance;
    for (let i = 0; i < n.length; i += 4) {
      const o = n[i], a = n[i + 1], l = n[i + 2], c = Math.max(o, a, l), u = (o + a + l) / 3, h = 2 * Math.abs(c - u) / 255 * s;
      n[i] += c !== o ? (c - o) * h : 0, n[i + 1] += c !== a ? (c - a) * h : 0, n[i + 2] += c !== l ? (c - l) * h : 0;
    }
  }
  sendUniformData(e, n) {
    e.uniform1f(n.uVibrance, -this.vibrance);
  }
  isNeutralState() {
    return this.vibrance === 0;
  }
}
nt(io, "type", "Vibrance"), nt(io, "defaults", { vibrance: 0 }), nt(io, "uniformLocations", ["uVibrance"]), Et.setClass(io);
const Du = IT(), Au = LT();
function IT() {
  const r = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, s = Math.round(255 * gi(0.267004 + n * (4874e-6 + n * (-0.259027 + n * (2.066795 + n * (-2.131557 + n * 0.736987)))))), i = Math.round(255 * gi(4874e-6 + n * (1.404613 + n * (-0.598103 + n * (-0.229949 + n * (0.659864 + n * -0.238132)))))), o = Math.round(255 * gi(0.329415 + n * (1.384613 + n * (-1.860504 + n * (1.592785 + n * (-0.730173 + n * 0.13561))))));
    r[e * 4] = s, r[e * 4 + 1] = i, r[e * 4 + 2] = o, r[e * 4 + 3] = 255;
  }
  return r;
}
function LT() {
  const r = new Uint8Array(1024);
  for (let e = 0; e < 256; e++) {
    const n = e / 255, s = Math.round(255 * gi(0.050383 + n * (2.689401 + n * (-1.802775 + n * (-0.391194 + n * (0.706557 + n * -0.218185)))))), i = Math.round(255 * gi(0.029803 + n * (-0.177105 + n * (0.96833 + n * (0.419198 + n * (-0.991163 + n * 0.517737)))))), o = Math.round(255 * gi(0.527975 + n * (1.546816 + n * (-4.246533 + n * (6.585146 + n * (-4.621553 + n * 1.205227))))));
    r[e * 4] = s, r[e * 4 + 1] = i, r[e * 4 + 2] = o, r[e * 4 + 3] = 255;
  }
  return r;
}
function gi(r) {
  return Math.max(0, Math.min(1, r));
}
const js = class js extends He {
  constructor(e, n = {}) {
    super(e, {
      ...js.ownDefaults,
      ...n
    }), this.colormap = n.colormap || "viridis", this._colorizedCanvas = null, this._webglContext = null, this._webglProgram = null, this._sourceImageData = null, this._initializeColorization();
  }
  /**
   * Initialize the colorization system (WebGL or Canvas2D fallback)
   */
  _initializeColorization() {
    const e = this.getElement();
    e && (this._colorizedCanvas = document.createElement("canvas"), this._colorizedCanvas.width = e.width || e.naturalWidth, this._colorizedCanvas.height = e.height || e.naturalHeight, this._initWebGL() ? this._applyColormapWebGL() : this._applyColormapCanvas2D());
  }
  /**
   * Initialize WebGL context and shader program
   */
  _initWebGL() {
    if (!this._colorizedCanvas) return !1;
    try {
      const e = this._colorizedCanvas.getContext("webgl", {
        preserveDrawingBuffer: !0,
        alpha: !0
      });
      if (!e) return !1;
      this._webglContext = e;
      const n = `
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        void main() {
          gl_Position = vec4(a_position, 0.0, 1.0);
          v_texCoord = a_texCoord;
        }
      `, s = `
        precision mediump float;
        uniform sampler2D u_image;
        uniform sampler2D u_colormap;
        varying vec2 v_texCoord;
        void main() {
          vec4 depth = texture2D(u_image, v_texCoord);
          float gray = dot(depth.rgb, vec3(0.299, 0.587, 0.114));
          vec4 color = texture2D(u_colormap, vec2(gray, 0.5));
          gl_FragColor = vec4(color.rgb, depth.a);
        }
      `, i = this._compileShader(e, e.VERTEX_SHADER, n), o = this._compileShader(e, e.FRAGMENT_SHADER, s);
      if (!i || !o) return !1;
      const a = e.createProgram();
      return a ? (e.attachShader(a, i), e.attachShader(a, o), e.linkProgram(a), e.getProgramParameter(a, e.LINK_STATUS) ? (this._webglProgram = a, !0) : (console.error("[DepthMapImage] Program link error:", e.getProgramInfoLog(a)), !1)) : !1;
    } catch (e) {
      return console.warn("[DepthMapImage] WebGL init failed:", e), !1;
    }
  }
  _compileShader(e, n, s) {
    const i = e.createShader(n);
    return i ? (e.shaderSource(i, s), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS) ? i : (console.error("[DepthMapImage] Shader compile error:", e.getShaderInfoLog(i)), e.deleteShader(i), null)) : null;
  }
  /**
   * Apply colormap using WebGL
   */
  _applyColormapWebGL() {
    const e = this._webglContext, n = this._webglProgram;
    if (!e || !n || !this._colorizedCanvas) return;
    e.useProgram(n);
    const s = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, s), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW);
    const i = e.getAttribLocation(n, "a_position");
    e.enableVertexAttribArray(i), e.vertexAttribPointer(i, 2, e.FLOAT, !1, 0, 0);
    const o = e.createBuffer();
    e.bindBuffer(e.ARRAY_BUFFER, o), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
    const a = e.getAttribLocation(n, "a_texCoord");
    e.enableVertexAttribArray(a), e.vertexAttribPointer(a, 2, e.FLOAT, !1, 0, 0);
    const l = e.createTexture();
    e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, l), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this.getElement());
    const c = e.createTexture();
    e.activeTexture(e.TEXTURE1), e.bindTexture(e.TEXTURE_2D, c), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR);
    const u = this.colormap === "plasma" ? Au : Du;
    e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 256, 1, 0, e.RGBA, e.UNSIGNED_BYTE, u), e.uniform1i(e.getUniformLocation(n, "u_image"), 0), e.uniform1i(e.getUniformLocation(n, "u_colormap"), 1), e.viewport(0, 0, this._colorizedCanvas.width, this._colorizedCanvas.height), e.drawArrays(e.TRIANGLES, 0, 6);
  }
  /**
   * Apply colormap using Canvas2D (fallback)
   */
  _applyColormapCanvas2D() {
    if (!this._colorizedCanvas) return;
    const e = this._colorizedCanvas.getContext("2d");
    if (!e) return;
    const n = this.getElement(), s = this._colorizedCanvas.width, i = this._colorizedCanvas.height;
    e.drawImage(n, 0, 0, s, i);
    const o = e.getImageData(0, 0, s, i), a = o.data, l = this.colormap === "plasma" ? Au : this.colormap === "viridis" ? Du : null;
    if (l) {
      for (let c = 0; c < a.length; c += 4) {
        const u = Math.round(
          a[c] * 0.299 + a[c + 1] * 0.587 + a[c + 2] * 0.114
        );
        a[c] = l[u * 4], a[c + 1] = l[u * 4 + 1], a[c + 2] = l[u * 4 + 2];
      }
      e.putImageData(o, 0, 0);
    }
  }
  /**
   * Set the colormap and re-apply
   */
  setColormap(e) {
    var n;
    this.colormap = e, this._webglContext && this._webglProgram ? this._applyColormapWebGL() : this._applyColormapCanvas2D(), this.dirty = !0, (n = this.canvas) == null || n.requestRenderAll();
  }
  /**
   * Override render to use colorized canvas
   */
  render(e) {
    if (this._colorizedCanvas && this.colormap !== "grayscale") {
      const n = this.getElement();
      this.setElement(this._colorizedCanvas), super.render(e), this.setElement(n);
    } else
      super.render(e);
  }
  /**
   * Get serializable properties including colormap
   */
  getSerializableData() {
    return {
      colormap: this.colormap
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    return new Promise((n, s) => {
      if (!e.src) {
        s(new Error("DepthMapImage requires a src property"));
        return;
      }
      const i = new Image();
      i.crossOrigin = "anonymous", i.onload = () => {
        n(new js(i, {
          colormap: e.colormap,
          ...e
        }));
      }, i.onerror = s, i.src = e.src;
    });
  }
  /**
   * Create from base64 data
   */
  static fromBase64(e, n = {}) {
    return new Promise((s, i) => {
      const o = new Image();
      o.crossOrigin = "anonymous", o.onload = () => {
        s(new js(o, n));
      }, o.onerror = i, o.src = e.startsWith("data:") ? e : `data:image/png;base64,${e}`;
    });
  }
};
Lt(js, "type", "DepthMapImage"), Lt(js, "ownDefaults", {
  colormap: "viridis",
  opacity: 0.5,
  visible: !0
});
let $o = js;
Et.setClass($o);
const ai = class ai extends _s {
  constructor(e, n = {}) {
    super(e, {
      ...ai.ownDefaults,
      ...n
    }), this.controlPoints = n.controlPoints || [], this._animationKeyframes = [];
  }
  /**
   * Update path data from control points
   */
  updatePathFromControlPoints() {
    if (this.controlPoints.length < 2) {
      this.set("path", []);
      return;
    }
    const e = [], n = this.controlPoints;
    e.push(["M", n[0].x, n[0].y]);
    for (let s = 0; s < n.length - 1; s++) {
      const i = n[s], o = n[s + 1], a = i.handleOut || { x: i.x, y: i.y }, l = o.handleIn || { x: o.x, y: o.y };
      e.push([
        "C",
        a.x,
        a.y,
        l.x,
        l.y,
        o.x,
        o.y
      ]);
    }
    this.set("path", e), this.setCoords();
  }
  /**
   * Add a new control point at position
   */
  addControlPoint(e, n, s) {
    const i = {
      id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      x: e,
      y: n,
      depth: s,
      handleIn: null,
      handleOut: null,
      type: "corner"
    };
    return this.controlPoints.push(i), this.updatePathFromControlPoints(), i;
  }
  /**
   * Move a control point
   */
  moveControlPoint(e, n, s) {
    const i = this.controlPoints.find((l) => l.id === e);
    if (!i) return;
    const o = n - i.x, a = s - i.y;
    i.x = n, i.y = s, i.handleIn && (i.handleIn.x += o, i.handleIn.y += a), i.handleOut && (i.handleOut.x += o, i.handleOut.y += a), this.updatePathFromControlPoints();
  }
  /**
   * Set handle position for a control point
   */
  setHandle(e, n, s, i, o = !1) {
    const a = this.controlPoints.find((l) => l.id === e);
    if (a) {
      if (n === "in" ? a.handleIn = { x: s, y: i } : a.handleOut = { x: s, y: i }, !o && a.type === "smooth") {
        const l = n === "in" ? a.handleIn : a.handleOut, c = n === "in" ? "handleOut" : "handleIn";
        if (l) {
          const u = l.x - a.x, h = l.y - a.y;
          a[c] = {
            x: a.x - u,
            y: a.y - h
          };
        }
      }
      this.updatePathFromControlPoints();
    }
  }
  /**
   * Delete a control point
   */
  deleteControlPoint(e) {
    const n = this.controlPoints.findIndex((s) => s.id === e);
    n !== -1 && (this.controlPoints.splice(n, 1), this.updatePathFromControlPoints());
  }
  /**
   * Get spline data for serialization
   */
  getSplineData() {
    var e;
    return {
      pathData: ((e = this.path) == null ? void 0 : e.map((n) => n.join(" ")).join(" ")) || "",
      controlPoints: this.controlPoints,
      closed: !1,
      stroke: this.stroke,
      strokeWidth: this.strokeWidth,
      fill: this.fill
    };
  }
  /**
   * Get serializable properties
   */
  getSerializableData() {
    return {
      controlPoints: this.controlPoints,
      _animationKeyframes: this._animationKeyframes
    };
  }
  /**
   * Deserialization from JSON
   */
  static fromObject(e) {
    var s;
    const n = ((s = e.path) == null ? void 0 : s.map((i) => i.join(" ")).join(" ")) || "";
    return Promise.resolve(new ai(n, {
      ...e,
      controlPoints: e.controlPoints || []
    }));
  }
};
// Type identifier for serialization
Lt(ai, "type", "SplinePath"), // Default values
Lt(ai, "ownDefaults", {
  stroke: "#00ff00",
  strokeWidth: 2,
  fill: "",
  selectable: !0,
  controlPoints: []
});
let No = ai;
Et.setClass(No);
const RT = { class: "spline-editor" }, zT = ["viewBox"], jT = ["x1", "y1", "x2", "y2"], BT = ["x1", "y1", "x2", "y2"], VT = ["cx", "cy", "onMousedown"], $T = ["cx", "cy", "onMousedown"], NT = ["cx", "cy", "onMousedown"], WT = ["cx", "cy"], UT = /* @__PURE__ */ ye({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(r, { expose: e, emit: n }) {
    const s = r, i = n, o = qe(), a = ut(null), l = ut(null), c = ut(null), u = St(() => {
      if (!s.layerId) return [];
      const C = o.layers.find((k) => k.id === s.layerId);
      return !C || C.type !== "spline" || !C.data ? [] : C.data.controlPoints || [];
    });
    function h(C, x) {
      const k = s.viewportTransform, w = (C - k[4]) / k[0], T = (x - k[5]) / k[3];
      return { x: w, y: T };
    }
    function f(C) {
      const k = C.currentTarget.getBoundingClientRect(), w = C.clientX - k.left, T = C.clientY - k.top;
      return h(w, T);
    }
    function m(C) {
      if (!s.isPenMode) return;
      const x = f(C);
      if (s.layerId) {
        const k = o.layers.find((w) => w.id === s.layerId);
        if (k && k.type === "spline") {
          const w = k.data, T = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: x.x,
            y: x.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          w.controlPoints || (w.controlPoints = []), w.controlPoints.push(T), a.value = T.id, c.value = {
            type: "handleOut",
            pointId: T.id,
            startX: x.x,
            startY: x.y
          }, i("pointAdded", T), i("pathUpdated");
        }
      }
    }
    function p(C) {
      var k;
      const x = f(C);
      if (s.isPenMode && (l.value = x), c.value) {
        const w = o.layers.find((z) => z.id === s.layerId);
        if (!w || w.type !== "spline") return;
        const P = (k = w.data.controlPoints) == null ? void 0 : k.find((z) => z.id === c.value.pointId);
        if (!P) return;
        if (c.value.type === "point") {
          const z = x.x - P.x, j = x.y - P.y;
          P.x = x.x, P.y = x.y, P.handleIn && (P.handleIn.x += z, P.handleIn.y += j), P.handleOut && (P.handleOut.x += z, P.handleOut.y += j), i("pointMoved", P.id, x.x, x.y);
        } else if (c.value.type === "handleIn") {
          if (P.handleIn = { x: x.x, y: x.y }, P.type === "smooth") {
            const z = x.x - P.x, j = x.y - P.y;
            P.handleOut = { x: P.x - z, y: P.y - j };
          }
          i("handleMoved", P.id, "in", x.x, x.y);
        } else if (c.value.type === "handleOut") {
          if (P.handleOut = { x: x.x, y: x.y }, P.type === "smooth") {
            const z = x.x - P.x, j = x.y - P.y;
            P.handleIn = { x: P.x - z, y: P.y - j };
          }
          i("handleMoved", P.id, "out", x.x, x.y);
        }
        i("pathUpdated");
      }
    }
    function y() {
      var C;
      if (c.value) {
        const x = o.layers.find((k) => k.id === s.layerId);
        if (x && x.type === "spline") {
          const w = (C = x.data.controlPoints) == null ? void 0 : C.find((T) => T.id === c.value.pointId);
          if (w && w.handleOut) {
            const T = w.handleOut.x - w.x, P = w.handleOut.y - w.y;
            Math.sqrt(T * T + P * P) > 5 ? (w.type = "smooth", w.handleIn = { x: w.x - T, y: w.y - P }) : w.handleOut = null;
          }
        }
        c.value = null, i("pathUpdated");
      }
    }
    function v(C, x) {
      if (a.value = C, !s.isPenMode) {
        const k = f(x);
        c.value = {
          type: "point",
          pointId: C,
          startX: k.x,
          startY: k.y
        };
      }
    }
    function _(C, x, k) {
      const w = f(k);
      c.value = {
        type: x === "in" ? "handleIn" : "handleOut",
        pointId: C,
        startX: w.x,
        startY: w.y
      };
    }
    function g(C) {
      var x, k;
      if ((C.key === "Delete" || C.key === "Backspace") && a.value && s.layerId) {
        const w = o.layers.find((T) => T.id === s.layerId);
        if (w && w.type === "spline") {
          const T = w.data, P = (x = T.controlPoints) == null ? void 0 : x.findIndex((z) => z.id === a.value);
          P !== void 0 && P >= 0 && ((k = T.controlPoints) == null || k.splice(P, 1), i("pointDeleted", a.value), i("pathUpdated"), a.value = null);
        }
      }
    }
    return Ne(() => {
      window.addEventListener("keydown", g);
    }), wn(() => {
      window.removeEventListener("keydown", g);
    }), e({
      selectedPointId: a,
      clearSelection: () => {
        a.value = null;
      }
    }), (C, x) => (H(), G("div", RT, [
      (H(), G("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${r.canvasWidth} ${r.canvasHeight}`,
        onMousedown: m,
        onMousemove: p,
        onMouseup: y,
        onMouseleave: y
      }, [
        (H(!0), G(Dt, null, jt(u.value, (k) => (H(), G(Dt, {
          key: `handles-${k.id}`
        }, [
          k.handleIn && a.value === k.id ? (H(), G("line", {
            key: 0,
            x1: k.x,
            y1: k.y,
            x2: k.handleIn.x,
            y2: k.handleIn.y,
            class: "handle-line"
          }, null, 8, jT)) : xt("", !0),
          k.handleOut && a.value === k.id ? (H(), G("line", {
            key: 1,
            x1: k.x,
            y1: k.y,
            x2: k.handleOut.x,
            y2: k.handleOut.y,
            class: "handle-line"
          }, null, 8, BT)) : xt("", !0)
        ], 64))), 128)),
        (H(!0), G(Dt, null, jt(u.value, (k) => {
          var w, T;
          return H(), G(Dt, {
            key: `handle-points-${k.id}`
          }, [
            k.handleIn && a.value === k.id ? (H(), G("circle", {
              key: 0,
              cx: k.handleIn.x,
              cy: k.handleIn.y,
              r: "4",
              class: wt(["handle-point", { active: ((w = c.value) == null ? void 0 : w.type) === "handleIn" && c.value.pointId === k.id }]),
              onMousedown: Bt((P) => _(k.id, "in", P), ["stop"])
            }, null, 42, VT)) : xt("", !0),
            k.handleOut && a.value === k.id ? (H(), G("circle", {
              key: 1,
              cx: k.handleOut.x,
              cy: k.handleOut.y,
              r: "4",
              class: wt(["handle-point", { active: ((T = c.value) == null ? void 0 : T.type) === "handleOut" && c.value.pointId === k.id }]),
              onMousedown: Bt((P) => _(k.id, "out", P), ["stop"])
            }, null, 42, $T)) : xt("", !0)
          ], 64);
        }), 128)),
        (H(!0), G(Dt, null, jt(u.value, (k) => (H(), G("circle", {
          key: `point-${k.id}`,
          cx: k.x,
          cy: k.y,
          r: "6",
          class: wt(["control-point", {
            selected: a.value === k.id,
            corner: k.type === "corner",
            smooth: k.type === "smooth"
          }]),
          onMousedown: Bt((w) => v(k.id, w), ["stop"])
        }, null, 42, NT))), 128)),
        l.value && r.isPenMode ? (H(), G("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, WT)) : xt("", !0)
      ], 40, zT))
    ]));
  }
}), HT = /* @__PURE__ */ we(UT, [["__scopeId", "data-v-48e73a8b"]]), rf = /* @__PURE__ */ Math.sqrt(3), XT = 0.5 * (rf - 1), zi = (3 - rf) / 6, Fu = (r) => Math.floor(r) | 0, Iu = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function GT(r = Math.random) {
  const e = YT(r), n = new Float64Array(e).map((i) => Iu[i % 12 * 2]), s = new Float64Array(e).map((i) => Iu[i % 12 * 2 + 1]);
  return function(o, a) {
    let l = 0, c = 0, u = 0;
    const h = (o + a) * XT, f = Fu(o + h), m = Fu(a + h), p = (f + m) * zi, y = f - p, v = m - p, _ = o - y, g = a - v;
    let C, x;
    _ > g ? (C = 1, x = 0) : (C = 0, x = 1);
    const k = _ - C + zi, w = g - x + zi, T = _ - 1 + 2 * zi, P = g - 1 + 2 * zi, z = f & 255, j = m & 255;
    let ot = 0.5 - _ * _ - g * g;
    if (ot >= 0) {
      const Y = z + e[j], M = n[Y], I = s[Y];
      ot *= ot, l = ot * ot * (M * _ + I * g);
    }
    let vt = 0.5 - k * k - w * w;
    if (vt >= 0) {
      const Y = z + C + e[j + x], M = n[Y], I = s[Y];
      vt *= vt, c = vt * vt * (M * k + I * w);
    }
    let L = 0.5 - T * T - P * P;
    if (L >= 0) {
      const Y = z + 1 + e[j + 1], M = n[Y], I = s[Y];
      L *= L, u = L * L * (M * T + I * P);
    }
    return 70 * (l + c + u);
  };
}
function YT(r) {
  const n = new Uint8Array(512);
  for (let s = 0; s < 512 / 2; s++)
    n[s] = s;
  for (let s = 0; s < 512 / 2 - 1; s++) {
    const i = s + ~~(r() * (256 - s)), o = n[s];
    n[s] = n[i], n[i] = o;
  }
  for (let s = 256; s < 512; s++)
    n[s] = n[s - 256];
  return n;
}
function KT() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function qT() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: []
  };
}
function Lu() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: KT()
  };
}
class ma {
  constructor(e = {}) {
    Lt(this, "particles", []);
    Lt(this, "emitters", /* @__PURE__ */ new Map());
    Lt(this, "gravityWells", /* @__PURE__ */ new Map());
    Lt(this, "vortices", /* @__PURE__ */ new Map());
    Lt(this, "modulations", []);
    Lt(this, "config");
    Lt(this, "boundaryMask", null);
    Lt(this, "frameCount", 0);
    Lt(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    Lt(this, "nextParticleId", 0);
    Lt(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    Lt(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator
    Lt(this, "noise2D");
    Lt(this, "noiseTime", 0);
    // Render options cache for spatial grid
    Lt(this, "renderOptions", Lu());
    this.config = { ...qT(), ...e }, this.noise2D = GT();
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let s = 0; s < n; s++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const s = this.emitters.get(e);
    s && Object.assign(s, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const s = this.gravityWells.get(e);
    s && Object.assign(s, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const s = this.vortices.get(e);
    s && Object.assign(s, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((s) => s.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, s) {
    const i = s ? `${s}:${e}` : `*:${e}`;
    this.featureOverrides.set(i, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    this.emitters.forEach((u, h) => {
      if (!u.enabled) return;
      const m = (this.getFeatureValue("emissionRate", h) ?? u.emissionRate) * e;
      let p = (this.emissionAccumulators.get(h) || 0) + m;
      for (; p >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(u), p -= 1;
      this.emissionAccumulators.set(h, p);
    });
    const n = this.config.windDirection * Math.PI / 180, s = Math.cos(n) * this.config.windStrength * 1e-3, i = Math.sin(n) * this.config.windStrength * 1e-3, o = this.getFeatureValue("gravity", "*") ?? this.config.gravity, a = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = s * (a / Math.max(1, this.config.windStrength)), c = i * (a / Math.max(1, this.config.windStrength));
    for (let u = this.particles.length - 1; u >= 0; u--) {
      const h = this.particles[u];
      if (h.prevX = h.x, h.prevY = h.y, this.trailHistory.has(h.id)) {
        const m = this.trailHistory.get(h.id);
        m.unshift({ x: h.x, y: h.y }), m.length > 20 && m.pop();
      }
      h.vy += o * 1e-3 * e, h.vx += l * e, h.vy += c * e, this.gravityWells.forEach((m) => {
        if (!m.enabled) return;
        const p = m.x - h.x, y = m.y - h.y, v = Math.sqrt(p * p + y * y);
        if (v < m.radius && v > 1e-3) {
          let _ = m.strength * 1e-4;
          switch (m.falloff) {
            case "linear":
              _ *= 1 - v / m.radius;
              break;
            case "quadratic":
              _ *= Math.pow(1 - v / m.radius, 2);
              break;
          }
          const g = p / v, C = y / v;
          h.vx += g * _ * e, h.vy += C * _ * e;
        }
      }), this.vortices.forEach((m) => {
        if (!m.enabled) return;
        const p = m.x - h.x, y = m.y - h.y, v = Math.sqrt(p * p + y * y);
        if (v < m.radius && v > 1e-3) {
          const _ = 1 - v / m.radius, g = m.strength * 1e-4 * _, C = p / v, x = y / v, k = -x, w = C;
          h.vx += k * g * e, h.vy += w * g * e;
          const T = m.inwardPull * 1e-4 * _;
          h.vx += C * T * e, h.vy += x * T * e;
        }
      }), this.applyTurbulence(h, e);
      const f = 1 - this.config.friction;
      h.vx *= f, h.vy *= f, h.x += h.vx * e, h.y += h.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(h), this.handleCanvasBoundary(h), this.applyModulations(h), h.age += e, h.age > h.lifetime && (h.isSubParticle || this.triggerSubEmitters(h), this.particles.splice(u, 1), this.trailHistory.delete(h.id));
    }
    this.noiseTime += e, this.frameCount++;
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = e.spread * Math.PI / 180, i = e.direction * Math.PI / 180 + (Math.random() - 0.5) * n, a = (e.speed + (Math.random() - 0.5) * 2 * e.speedVariance) * 1e-3, l = Math.max(1, e.size + (Math.random() - 0.5) * 2 * e.sizeVariance), c = Math.max(1, e.particleLifetime + (Math.random() - 0.5) * 2 * e.lifetimeVariance), u = {
      id: this.nextParticleId++,
      x: e.x,
      y: e.y,
      prevX: e.x,
      prevY: e.y,
      vx: Math.cos(i) * a,
      vy: Math.sin(i) * a,
      age: 0,
      lifetime: c,
      size: l,
      baseSize: l,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1
    };
    this.particles.push(u), this.trailHistory.set(u.id, [{ x: u.x, y: u.y }]);
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), s = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || s < 0 || s >= this.boundaryMask.height)
      return;
    const i = (s * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[i] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = Math.random(), e.y = Math.random();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const s of this.modulations) {
      if (s.emitterId !== "*" && s.emitterId !== e.emitterId) continue;
      const i = s.easing, o = Oo[i] || Oo.linear, a = vg(n, o), l = s.startValue + (s.endValue - s.startValue) * a;
      switch (s.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const c = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (c > 1e-4) {
            const u = l / Math.max(1e-4, c * 1e3);
            e.vx *= u, e.vy *= u;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const s = this.config.turbulenceFields || [];
    for (const i of s) {
      if (!i.enabled) continue;
      const o = e.x * i.scale * 1e3, a = e.y * i.scale * 1e3, l = this.noiseTime * i.evolutionSpeed, c = this.noise2D(o + l, a + l) * Math.PI * 2, u = i.strength * 1e-5;
      e.vx += Math.cos(c) * u * n, e.vy += Math.sin(c) * u * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var i;
    const s = (i = this.config.turbulenceFields) == null ? void 0 : i.find((o) => o.id === e);
    s && Object.assign(s, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const s of n)
      if (s.enabled && !(s.parentEmitterId !== "*" && s.parentEmitterId !== e.emitterId))
        for (let i = 0; i < s.spawnCount; i++) {
          const o = (Math.random() - 0.5) * s.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + o, c = Math.sqrt(e.vx ** 2 + e.vy ** 2) * s.inheritVelocity, u = s.speed * 1e-3 + c, h = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * u + e.vx * s.inheritVelocity,
            vy: Math.sin(l) * u + e.vy * s.inheritVelocity,
            age: 0,
            lifetime: s.lifetime * (1 + (Math.random() - 0.5) * 0.2),
            size: s.size * (1 + (Math.random() - 0.5) * s.sizeVariance / s.size),
            baseSize: s.size,
            color: [...s.color, 255],
            baseColor: [...s.color, 255],
            emitterId: s.id,
            isSubParticle: !0
          };
          this.particles.push(h), this.trailHistory.set(h.id, [{ x: h.x, y: h.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var i;
    const s = (i = this.config.subEmitters) == null ? void 0 : i.find((o) => o.id === e);
    s && Object.assign(s, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const s = this.emitters.get(e);
    if (!s || !s.enabled) return;
    const i = n ?? s.burstCount ?? 20;
    for (let o = 0; o < i; o++)
      this.spawnParticle(s);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var s;
    const e = ((s = this.renderOptions.connections) == null ? void 0 : s.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const i of this.particles) {
      const o = Math.floor(i.x * 1e3 / e), a = Math.floor(i.y * 1e3 / e), l = `${o},${a}`;
      n.has(l) || n.set(l, []), n.get(l).push(i);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const s = Math.floor(e.x * 1e3 / n.cellSize), i = Math.floor(e.y * 1e3 / n.cellSize), o = [];
    for (let a = -1; a <= 1; a++)
      for (let l = -1; l <= 1; l++) {
        const c = `${s + a},${i + l}`, u = n.cells.get(c);
        u && o.push(...u);
      }
    return o;
  }
  renderConnections(e, n, s) {
    const i = this.renderOptions.connections;
    if (!(i != null && i.enabled) || this.particles.length < 2) return;
    const o = this.buildSpatialGrid(), a = i.maxDistance / 1e3, l = a * a;
    e.lineWidth = i.lineWidth;
    for (const c of this.particles) {
      const u = this.getNeighborParticles(c, o);
      let h = 0;
      for (const f of u) {
        if (f.id <= c.id) continue;
        if (h >= i.maxConnections) break;
        const m = f.x - c.x, p = f.y - c.y, y = m * m + p * p;
        if (y < l) {
          const v = Math.sqrt(y);
          let _ = i.lineOpacity;
          i.fadeByDistance && (_ *= 1 - v / a);
          const g = Math.round((c.color[0] + f.color[0]) / 2), C = Math.round((c.color[1] + f.color[1]) / 2), x = Math.round((c.color[2] + f.color[2]) / 2);
          e.strokeStyle = `rgba(${g},${C},${x},${_})`, e.beginPath(), e.moveTo(c.x * n, c.y * s), e.lineTo(f.x * n, f.y * s), e.stroke(), h++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, s, i = Lu()) {
    switch (this.renderOptions = i, e.save(), i.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, s);
    for (const o of this.particles) {
      const a = o.x * n, l = o.y * s, c = o.size;
      if (i.renderTrails) {
        const u = this.trailHistory.get(o.id);
        if (u && u.length > 1) {
          e.beginPath(), e.moveTo(a, l);
          const h = Math.min(u.length, i.trailLength);
          for (let f = 0; f < h; f++) {
            const m = u[f], p = o.color[3] * Math.pow(i.trailOpacityFalloff, f + 1);
            e.strokeStyle = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${p / 255})`, e.lineWidth = c * Math.pow(i.trailOpacityFalloff, f), e.lineTo(m.x * n, m.y * s);
          }
          e.stroke();
        }
      }
      i.glowEnabled ? (e.shadowBlur = i.glowRadius, e.shadowColor = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${i.glowIntensity})`) : e.shadowBlur = 0, i.motionBlur && (o.vx !== 0 || o.vy !== 0) ? this.renderParticleWithMotionBlur(e, o, a, l, c, n, s, i) : this.renderParticleShape(e, a, l, c, o.color, i.particleShape);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, s, i, o, a, l, c) {
    const u = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (u < 1e-4) {
      this.renderParticleShape(e, s, i, o, n.color, c.particleShape);
      return;
    }
    const h = c.motionBlurStrength * u * 500, f = Math.min(c.motionBlurSamples, 16), m = n.vx / u, p = n.vy / u, y = Math.min(h * o, o * 10);
    for (let v = 0; v < f; v++) {
      const _ = v / (f - 1), g = (1 - _ * 0.8) / f, C = s - m * y * _, x = i - p * y * _, k = o * (1 - _ * 0.3), w = n.color[3] / 255 * g * f;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, w)})`, this.renderParticleShape(e, C, x, k, null, c.particleShape);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, s, i, o, n.color, c.particleShape);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, s, i, o, a) {
    switch (o && (e.fillStyle = `rgba(${o[0]}, ${o[1]}, ${o[2]}, ${o[3] / 255})`), a) {
      case "circle":
        e.beginPath(), e.arc(n, s, i / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(n - i / 2, s - i / 2, i, i);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(n, s - i / 2), e.lineTo(n - i / 2, s + i / 2), e.lineTo(n + i / 2, s + i / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, n, s, 5, i / 2, i / 4), e.fill();
        break;
    }
  }
  drawStar(e, n, s, i, o, a) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let c = 0; c < i; c++) {
      const u = n + Math.cos(l) * o, h = s + Math.sin(l) * o;
      c === 0 ? e.moveTo(u, h) : e.lineTo(u, h), l += Math.PI / i;
      const f = n + Math.cos(l) * a, m = s + Math.sin(l) * a;
      e.lineTo(f, m), l += Math.PI / i;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const i = new OffscreenCanvas(e, n).getContext("2d");
    i.fillStyle = "#FFFFFF", i.fillRect(0, 0, e, n);
    const o = this.renderOptions.connections;
    o != null && o.enabled && this.particles.length >= 2 && (i.strokeStyle = "#000000", i.lineWidth = o.lineWidth * 2, this.renderConnections(i, e, n)), i.fillStyle = "#000000";
    for (const a of this.particles) {
      const l = a.x * e, c = a.y * n, u = a.size * 1.5;
      i.beginPath(), i.arc(l, c, u / 2, 0, Math.PI * 2), i.fill();
    }
    return i.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new ma(e.config);
    if (e.emitters)
      for (const s of e.emitters)
        n.addEmitter(s);
    if (e.gravityWells)
      for (const s of e.gravityWells)
        n.addGravityWell(s);
    if (e.vortices)
      for (const s of e.vortices)
        n.addVortex(s);
    if (e.modulations)
      for (const s of e.modulations)
        n.addModulation(s);
    return n;
  }
}
function ZT() {
  return {
    preset: "static",
    zoom: 1,
    offsetX: 0,
    offsetY: 0,
    rotation: 0,
    depthScale: 1,
    focusDepth: 0.5,
    dollyZoom: 0,
    orbitRadius: 0.1,
    orbitSpeed: 2,
    swingAmplitude: 0.1,
    swingFrequency: 0.5,
    edgeDilation: 5,
    inpaintEdges: !0
  };
}
const JT = `#version 300 es
in vec2 a_position;
in vec2 a_texCoord;
out vec2 v_texCoord;

void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
  v_texCoord = a_texCoord;
}
`, QT = `#version 300 es
precision highp float;

in vec2 v_texCoord;
out vec4 outColor;

uniform sampler2D u_source;
uniform sampler2D u_depth;
uniform float u_zoom;
uniform vec2 u_offset;
uniform float u_rotation;
uniform float u_depthScale;
uniform float u_focusDepth;
uniform float u_edgeDilation;
uniform vec2 u_resolution;

vec2 rotate2D(vec2 p, float angle) {
  float c = cos(angle);
  float s = sin(angle);
  return vec2(p.x * c - p.y * s, p.x * s + p.y * c);
}

void main() {
  // Get depth at current pixel
  float depth = texture(u_depth, v_texCoord).r;

  // Calculate parallax offset based on depth
  // Objects closer than focus depth move more, objects further move less
  float depthDiff = (depth - u_focusDepth) * u_depthScale;

  // Transform texture coordinates
  vec2 center = vec2(0.5, 0.5);
  vec2 coord = v_texCoord - center;

  // Apply rotation
  float rotRad = u_rotation * 3.14159265 / 180.0;
  coord = rotate2D(coord, rotRad);

  // Apply zoom
  coord /= u_zoom;

  // Apply parallax offset based on depth
  vec2 parallaxOffset = u_offset * depthDiff;
  coord += parallaxOffset;

  // Apply camera offset
  coord -= u_offset * 0.5;

  coord += center;

  // Edge handling with dilation
  float dilatePixels = u_edgeDilation / u_resolution.x;

  // Clamp coordinates
  vec2 clampedCoord = clamp(coord, vec2(dilatePixels), vec2(1.0 - dilatePixels));

  // Check if we're sampling outside bounds
  float outOfBounds = step(0.0, coord.x) * step(coord.x, 1.0) *
                      step(0.0, coord.y) * step(coord.y, 1.0);

  // Sample source texture
  vec4 color = texture(u_source, clampedCoord);

  // Fade edges if out of bounds
  if (outOfBounds < 0.5) {
    // Sample from clamped position with reduced alpha
    color = texture(u_source, clampedCoord);
    color.a *= 0.3;
  }

  outColor = color;
}
`;
class t5 {
  constructor() {
    Lt(this, "sourceCanvas");
    Lt(this, "depthCanvas");
    Lt(this, "outputCanvas");
    Lt(this, "gl", null);
    Lt(this, "program", null);
    Lt(this, "useWebGL", !1);
    // WebGL resources
    Lt(this, "sourceTexture", null);
    Lt(this, "depthTexture", null);
    Lt(this, "positionBuffer", null);
    Lt(this, "texCoordBuffer", null);
    // Uniform locations
    Lt(this, "uniforms", {});
    // Current config
    Lt(this, "config", ZT());
    // Source dimensions
    Lt(this, "width", 0);
    Lt(this, "height", 0);
    this.sourceCanvas = document.createElement("canvas"), this.depthCanvas = document.createElement("canvas"), this.outputCanvas = document.createElement("canvas"), this.initWebGL();
  }
  initWebGL() {
    const e = this.outputCanvas.getContext("webgl2", {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0
    });
    if (!e) {
      console.warn("[Depthflow] WebGL2 not available, using Canvas2D fallback"), this.useWebGL = !1;
      return;
    }
    this.gl = e, this.useWebGL = !0;
    const n = this.compileShader(e, e.VERTEX_SHADER, JT), s = this.compileShader(e, e.FRAGMENT_SHADER, QT);
    if (!n || !s) {
      this.useWebGL = !1;
      return;
    }
    const i = e.createProgram();
    if (e.attachShader(i, n), e.attachShader(i, s), e.linkProgram(i), !e.getProgramParameter(i, e.LINK_STATUS)) {
      console.error("[Depthflow] Program link error:", e.getProgramInfoLog(i)), this.useWebGL = !1;
      return;
    }
    this.program = i, this.uniforms = {
      u_source: e.getUniformLocation(i, "u_source"),
      u_depth: e.getUniformLocation(i, "u_depth"),
      u_zoom: e.getUniformLocation(i, "u_zoom"),
      u_offset: e.getUniformLocation(i, "u_offset"),
      u_rotation: e.getUniformLocation(i, "u_rotation"),
      u_depthScale: e.getUniformLocation(i, "u_depthScale"),
      u_focusDepth: e.getUniformLocation(i, "u_focusDepth"),
      u_edgeDilation: e.getUniformLocation(i, "u_edgeDilation"),
      u_resolution: e.getUniformLocation(i, "u_resolution")
    }, this.positionBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.positionBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      1,
      1
    ]), e.STATIC_DRAW), this.texCoordBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this.texCoordBuffer), e.bufferData(e.ARRAY_BUFFER, new Float32Array([
      0,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      0
    ]), e.STATIC_DRAW);
  }
  compileShader(e, n, s) {
    const i = e.createShader(n);
    return e.shaderSource(i, s), e.compileShader(i), e.getShaderParameter(i, e.COMPILE_STATUS) ? i : (console.error("[Depthflow] Shader compile error:", e.getShaderInfoLog(i)), e.deleteShader(i), null);
  }
  setSource(e) {
    e instanceof ImageData ? (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.sourceCanvas.width = e.width, this.sourceCanvas.height = e.height, this.sourceCanvas.getContext("2d").drawImage(e, 0, 0)), this.width = this.sourceCanvas.width, this.height = this.sourceCanvas.height, this.outputCanvas.width = this.width, this.outputCanvas.height = this.height, this.useWebGL && this.gl && this.updateTexture("source");
  }
  setDepthMap(e) {
    e instanceof ImageData ? (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").putImageData(e, 0, 0)) : (this.depthCanvas.width = e.width, this.depthCanvas.height = e.height, this.depthCanvas.getContext("2d").drawImage(e, 0, 0)), this.useWebGL && this.gl && this.updateTexture("depth");
  }
  updateTexture(e) {
    const n = this.gl, s = e === "source" ? this.sourceCanvas : this.depthCanvas;
    e === "source" ? (this.sourceTexture && n.deleteTexture(this.sourceTexture), this.sourceTexture = n.createTexture(), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture)) : (this.depthTexture && n.deleteTexture(this.depthTexture), this.depthTexture = n.createTexture(), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture)), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, n.LINEAR), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, s);
  }
  setConfig(e) {
    this.config = { ...this.config, ...e };
  }
  getConfig() {
    return { ...this.config };
  }
  /**
   * Get animated camera parameters for a specific frame based on preset
   */
  getAnimatedParams(e, n) {
    const s = n > 1 ? e / (n - 1) : 0, { preset: i, orbitRadius: o, orbitSpeed: a, swingAmplitude: l, swingFrequency: c } = this.config;
    let u = this.config.zoom, h = this.config.offsetX, f = this.config.offsetY, m = this.config.rotation, p = this.config.depthScale;
    switch (i) {
      case "static":
        break;
      case "zoom_in":
        u = 1 + s * 0.3;
        break;
      case "zoom_out":
        u = 1 - s * 0.3;
        break;
      case "dolly_zoom_in":
        u = 1 + s * 0.4, p = this.config.depthScale * (1 - s * 0.5);
        break;
      case "dolly_zoom_out":
        u = 1 - s * 0.3, p = this.config.depthScale * (1 + s * 0.5);
        break;
      case "pan_left":
        h = -s * 0.3;
        break;
      case "pan_right":
        h = s * 0.3;
        break;
      case "pan_up":
        f = -s * 0.3;
        break;
      case "pan_down":
        f = s * 0.3;
        break;
      case "circle_cw": {
        const y = s * Math.PI * 2 * (a / 360);
        h = Math.cos(y) * o, f = Math.sin(y) * o;
        break;
      }
      case "circle_ccw": {
        const y = -s * Math.PI * 2 * (a / 360);
        h = Math.cos(y) * o, f = Math.sin(y) * o;
        break;
      }
      case "horizontal_swing":
        h = Math.sin(s * Math.PI * 2 * c) * l;
        break;
      case "vertical_swing":
        f = Math.sin(s * Math.PI * 2 * c) * l;
        break;
    }
    return { zoom: u, offsetX: h, offsetY: f, rotation: m, depthScale: p };
  }
  renderFrame(e, n) {
    const s = this.getAnimatedParams(e, n);
    return this.useWebGL && this.gl && this.program ? this.renderWebGL(s) : this.renderCanvas2D(s);
  }
  renderWebGL(e) {
    const n = this.gl;
    n.viewport(0, 0, this.width, this.height), n.useProgram(this.program), n.activeTexture(n.TEXTURE0), n.bindTexture(n.TEXTURE_2D, this.sourceTexture), n.uniform1i(this.uniforms.u_source, 0), n.activeTexture(n.TEXTURE1), n.bindTexture(n.TEXTURE_2D, this.depthTexture), n.uniform1i(this.uniforms.u_depth, 1), n.uniform1f(this.uniforms.u_zoom, e.zoom), n.uniform2f(this.uniforms.u_offset, e.offsetX, e.offsetY), n.uniform1f(this.uniforms.u_rotation, e.rotation), n.uniform1f(this.uniforms.u_depthScale, e.depthScale), n.uniform1f(this.uniforms.u_focusDepth, this.config.focusDepth), n.uniform1f(this.uniforms.u_edgeDilation, this.config.edgeDilation), n.uniform2f(this.uniforms.u_resolution, this.width, this.height);
    const s = n.getAttribLocation(this.program, "a_position");
    n.bindBuffer(n.ARRAY_BUFFER, this.positionBuffer), n.enableVertexAttribArray(s), n.vertexAttribPointer(s, 2, n.FLOAT, !1, 0, 0);
    const i = n.getAttribLocation(this.program, "a_texCoord");
    n.bindBuffer(n.ARRAY_BUFFER, this.texCoordBuffer), n.enableVertexAttribArray(i), n.vertexAttribPointer(i, 2, n.FLOAT, !1, 0, 0), n.drawArrays(n.TRIANGLES, 0, 6);
    const o = new Uint8ClampedArray(this.width * this.height * 4);
    n.readPixels(0, 0, this.width, this.height, n.RGBA, n.UNSIGNED_BYTE, o);
    const a = new Uint8ClampedArray(o.length);
    for (let l = 0; l < this.height; l++) {
      const c = (this.height - 1 - l) * this.width * 4, u = l * this.width * 4;
      a.set(o.subarray(c, c + this.width * 4), u);
    }
    return new ImageData(a, this.width, this.height);
  }
  renderCanvas2D(e) {
    const n = this.outputCanvas.getContext("2d"), s = this.sourceCanvas.getContext("2d"), i = this.depthCanvas.getContext("2d"), o = s.getImageData(0, 0, this.width, this.height), a = i.getImageData(0, 0, this.width, this.height), l = n.createImageData(this.width, this.height), { zoom: c, offsetX: u, offsetY: h, rotation: f, depthScale: m } = e, { focusDepth: p } = this.config, y = f * Math.PI / 180, v = Math.cos(y), _ = Math.sin(y);
    for (let g = 0; g < this.height; g++)
      for (let C = 0; C < this.width; C++) {
        const x = (g * this.width + C) * 4, w = (a.data[x] / 255 - p) * m;
        let T = C / this.width - 0.5, P = g / this.height - 0.5;
        const z = T * v - P * _, j = T * _ + P * v;
        T = z, P = j, T /= c, P /= c, T += u * w, P += h * w, T -= u * 0.5, P -= h * 0.5, T = (T + 0.5) * this.width, P = (P + 0.5) * this.height;
        const ot = Math.floor(T), vt = Math.floor(P), L = ot + 1, Y = vt + 1, M = T - ot, I = P - vt, tt = Math.max(0, Math.min(this.width - 1, ot)), U = Math.max(0, Math.min(this.height - 1, vt)), W = Math.max(0, Math.min(this.width - 1, L)), Z = Math.max(0, Math.min(this.height - 1, Y)), yt = (U * this.width + tt) * 4, Q = (U * this.width + W) * 4, at = (Z * this.width + tt) * 4, _t = (Z * this.width + W) * 4;
        for (let ht = 0; ht < 4; ht++) {
          const X = o.data[yt + ht], kt = o.data[Q + ht], lt = o.data[at + ht], pt = o.data[_t + ht], it = X * (1 - M) + kt * M, E = lt * (1 - M) + pt * M;
          l.data[x + ht] = Math.round(it * (1 - I) + E * I);
        }
        (T < 0 || T >= this.width || P < 0 || P >= this.height) && (l.data[x + 3] = Math.round(l.data[x + 3] * 0.3));
      }
    return n.putImageData(l, 0, 0), l;
  }
  renderSequence(e, n) {
    const s = [];
    for (let i = 0; i < e; i++)
      s.push(this.renderFrame(i, e)), n && n(i);
    return s;
  }
  /**
   * Get preset configuration with optional intensity modifier
   */
  getPresetConfig(e, n = 1) {
    const s = { preset: e };
    switch (e) {
      case "zoom_in":
      case "zoom_out":
        return { ...s, depthScale: 1 * n };
      case "dolly_zoom_in":
      case "dolly_zoom_out":
        return { ...s, depthScale: 1.5 * n, dollyZoom: 0.5 * n };
      case "pan_left":
      case "pan_right":
      case "pan_up":
      case "pan_down":
        return { ...s, depthScale: 0.8 * n };
      case "circle_cw":
      case "circle_ccw":
        return { ...s, orbitRadius: 0.1 * n, orbitSpeed: 360 };
      case "horizontal_swing":
      case "vertical_swing":
        return { ...s, swingAmplitude: 0.1 * n, swingFrequency: 1 };
      default:
        return s;
    }
  }
  getOutputCanvas() {
    return this.outputCanvas;
  }
  dispose() {
    this.gl && (this.sourceTexture && this.gl.deleteTexture(this.sourceTexture), this.depthTexture && this.gl.deleteTexture(this.depthTexture), this.positionBuffer && this.gl.deleteBuffer(this.positionBuffer), this.texCoordBuffer && this.gl.deleteBuffer(this.texCoordBuffer), this.program && this.gl.deleteProgram(this.program)), this.sourceTexture = null, this.depthTexture = null, this.positionBuffer = null, this.texCoordBuffer = null, this.program = null, this.gl = null;
  }
}
const e5 = { class: "zoom-controls" }, n5 = { class: "zoom-level" }, s5 = {
  key: 1,
  class: "overlay-controls"
}, i5 = {
  key: 2,
  class: "loading-overlay"
}, r5 = /* @__PURE__ */ ye({
  __name: "CompositionCanvas",
  setup(r, { expose: e }) {
    const n = qe(), s = ut(null), i = ut(null), o = ut(null), a = ut(null), l = ut(null), c = ut(null), u = ut(/* @__PURE__ */ new Map()), h = ut(!1), f = ut(1), m = ut(!0), p = ut("viridis"), y = ut(50), v = ut(800), _ = ut(600), g = ut(/* @__PURE__ */ new Map()), C = ut(/* @__PURE__ */ new Map()), x = ut(null), k = ut(null), w = ut(null), T = ut(/* @__PURE__ */ new Map()), P = St(() => n.depthMap !== null), z = St(() => n.currentTool === "pen"), j = St(() => {
      const O = n.selectedLayer;
      if ((O == null ? void 0 : O.type) === "spline")
        return O.id;
      if (z.value && n.layers.filter((S) => S.type === "spline").length === 0)
        return null;
      if (z.value) {
        const S = n.layers.filter((F) => F.type === "spline");
        return S.length > 0 ? S[S.length - 1].id : null;
      }
      return null;
    }), ot = St(() => {
      var S;
      const O = (S = a.value) == null ? void 0 : S.viewportTransform;
      return O ? Array.from(O) : [1, 0, 0, 1, 0, 0];
    });
    Ne(() => {
      if (!i.value || !s.value) return;
      const O = s.value, S = O.getBoundingClientRect();
      v.value = S.width, _.value = S.height, a.value = new yl(i.value, {
        width: S.width,
        height: S.height,
        backgroundColor: "#1a1a1a",
        selection: !0,
        preserveObjectStacking: !0
      }), vt(), new ResizeObserver(L).observe(O), ae(() => n.sourceImage, Y, { immediate: !0 }), ae(() => n.depthMap, M, { immediate: !0 }), ae(() => n.layers, I, { deep: !0, immediate: !0 }), ae(() => n.layers, at, { deep: !0, immediate: !0 }), ae(() => n.layers, _t, { deep: !0, immediate: !0 }), x.value = document.createElement("canvas"), k.value = x.value.getContext("2d"), ht();
    }), wn(() => {
      var O;
      w.value !== null && cancelAnimationFrame(w.value), g.value.forEach((S) => {
        S.reset();
      }), g.value.clear(), C.value.forEach((S) => {
        S.dispose();
      }), C.value.clear(), (O = a.value) == null || O.dispose();
    });
    function vt() {
      const O = a.value;
      if (!O) return;
      O.on("mouse:wheel", (B) => {
        const R = B.e.deltaY;
        let D = O.getZoom() * (R > 0 ? 0.9 : 1.1);
        D = Math.min(Math.max(D, 0.1), 10);
        const A = new mt(B.e.offsetX, B.e.offsetY);
        O.zoomToPoint(A, D), f.value = D, B.e.preventDefault(), B.e.stopPropagation();
      });
      let S = !1, F = 0, b = 0;
      O.on("mouse:down", (B) => {
        const R = B.e;
        (R.button === 1 || R.button === 0 && R.altKey) && (S = !0, F = R.clientX, b = R.clientY, O.selection = !1);
      }), O.on("mouse:move", (B) => {
        if (S) {
          const R = B.e, D = O.viewportTransform;
          D && (D[4] += R.clientX - F, D[5] += R.clientY - b, O.requestRenderAll()), F = R.clientX, b = R.clientY;
        }
      }), O.on("mouse:up", () => {
        S && (S = !1, O.selection = !0);
      }), O.on("selection:created", (B) => {
        var D;
        const R = (D = B.selected) == null ? void 0 : D[0];
        R && R.layerId && n.selectLayer(R.layerId);
      });
    }
    function L(O) {
      const S = a.value;
      if (S)
        for (const F of O) {
          const { width: b, height: B } = F.contentRect;
          S.setDimensions({ width: b, height: B }), v.value = b, _.value = B, S.requestRenderAll();
        }
    }
    async function Y(O) {
      const S = a.value;
      if (!(!S || !O)) {
        h.value = !0;
        try {
          l.value && S.remove(l.value);
          const F = await W(O);
          l.value = new He(F, {
            selectable: !1,
            evented: !1,
            left: 0,
            top: 0
          }), S.add(l.value), S.sendObjectToBack(l.value), Q();
        } catch (F) {
          console.error("[CompositionCanvas] Failed to load source image:", F);
        } finally {
          h.value = !1;
        }
      }
    }
    async function M(O) {
      const S = a.value;
      if (!(!S || !O))
        try {
          if (c.value && S.remove(c.value), c.value = await $o.fromBase64(O, {
            colormap: p.value,
            opacity: y.value / 100,
            visible: m.value
          }), c.value.set({
            selectable: !1,
            evented: !1,
            left: 0,
            top: 0
          }), S.add(c.value), l.value) {
            const F = S.getObjects().indexOf(l.value);
            S.moveObjectTo(c.value, F + 1);
          }
          S.requestRenderAll();
        } catch (F) {
          console.error("[CompositionCanvas] Failed to load depth map:", F);
        }
    }
    function I() {
      const O = a.value;
      if (!O) return;
      const S = n.layers.filter((b) => b.type === "spline");
      for (const b of S) {
        const B = b.data;
        if (!B) continue;
        let R = u.value.get(b.id);
        R ? (R.controlPoints = B.controlPoints || [], R.set({
          stroke: B.stroke,
          strokeWidth: B.strokeWidth,
          fill: B.fill,
          selectable: !b.locked,
          visible: b.visible
        })) : (R = new No("", {
          stroke: B.stroke || "#00ff00",
          strokeWidth: B.strokeWidth || 2,
          fill: B.fill || "",
          controlPoints: B.controlPoints || [],
          selectable: !b.locked
        }), R.layerId = b.id, u.value.set(b.id, R), O.add(R)), R.updatePathFromControlPoints();
      }
      const F = new Set(S.map((b) => b.id));
      for (const [b, B] of u.value)
        F.has(b) || (O.remove(B), u.value.delete(b));
      O.requestRenderAll();
    }
    function tt(O) {
      if (!j.value) {
        const S = n.createLayer("spline");
        n.selectLayer(S.id);
      }
    }
    function U() {
      I();
    }
    ae(m, (O) => {
      var S;
      c.value && (c.value.set("visible", O), (S = a.value) == null || S.requestRenderAll());
    }), ae(p, (O) => {
      c.value && c.value.setColormap(O);
    }), ae(y, (O) => {
      var S;
      c.value && (c.value.set("opacity", O / 100), (S = a.value) == null || S.requestRenderAll());
    });
    function W(O) {
      return new Promise((S, F) => {
        const b = new Image();
        b.crossOrigin = "anonymous", b.onload = () => S(b), b.onerror = F, b.src = O.startsWith("data:") ? O : `data:image/png;base64,${O}`;
      });
    }
    function Z() {
      const O = a.value;
      if (!O) return;
      const S = Math.min(O.getZoom() * 1.2, 10);
      O.setZoom(S), f.value = S;
    }
    function yt() {
      const O = a.value;
      if (!O) return;
      const S = Math.max(O.getZoom() * 0.8, 0.1);
      O.setZoom(S), f.value = S;
    }
    function Q() {
      const O = a.value, S = s.value;
      if (!O || !S || !l.value) return;
      const F = S.getBoundingClientRect(), b = l.value.width || 1, B = l.value.height || 1, R = 40, D = (F.width - R * 2) / b, A = (F.height - R * 2) / B, N = Math.min(D, A, 1), q = O.viewportTransform;
      q && (q[0] = N, q[3] = N, q[4] = (F.width - b * N) / 2, q[5] = (F.height - B * N) / 2), f.value = N, O.requestRenderAll();
    }
    function at() {
      var F;
      const O = n.layers.filter((b) => b.type === "particles"), S = new Set(O.map((b) => b.id));
      for (const b of O)
        if (g.value.has(b.id)) {
          const B = g.value.get(b.id), R = b.data;
          if (R) {
            B.setConfig(R.systemConfig);
            const D = B.getEmitters();
            for (const A of R.emitters)
              D.find((q) => q.id === A.id) ? B.updateEmitter(A.id, A) : B.addEmitter(A);
          }
        } else {
          const B = b.data;
          if (B) {
            const R = new ma(B.systemConfig);
            for (const D of B.emitters)
              R.addEmitter(D);
            for (const D of B.gravityWells)
              R.addGravityWell(D);
            for (const D of B.vortices)
              R.addVortex(D);
            for (const D of B.modulations)
              R.addModulation(D);
            g.value.set(b.id, R);
          }
        }
      for (const [b] of g.value)
        S.has(b) || ((F = g.value.get(b)) == null || F.reset(), g.value.delete(b));
    }
    function _t() {
      var F;
      const O = n.layers.filter((b) => b.type === "depthflow"), S = new Set(O.map((b) => b.id));
      for (const b of O)
        if (C.value.has(b.id)) {
          const B = C.value.get(b.id), R = b.data;
          R && B.setConfig(R.config);
        } else {
          const B = b.data;
          if (B) {
            const R = new t5();
            R.setConfig(B.config), C.value.set(b.id, R);
          }
        }
      for (const [b] of C.value)
        S.has(b) || ((F = C.value.get(b)) == null || F.dispose(), C.value.delete(b));
    }
    function ht() {
      const O = () => {
        (n.isPlaying || n.audioAnalysis) && pt(), n.isPlaying && X(), kt(), it(), w.value = requestAnimationFrame(O);
      };
      w.value = requestAnimationFrame(O);
    }
    function X() {
      var S;
      const O = ((S = n.audioAnalysis) == null ? void 0 : S.onsets.includes(n.currentFrame)) ?? !1;
      g.value.forEach((F, b) => {
        const B = n.getActiveMappingsForLayer(b);
        for (const R of B) {
          const A = n.getAudioFeatureAtFrame(R.feature) * R.sensitivity, N = R.target.split("."), q = N.length > 1 ? N[1] : R.target;
          F.setFeatureValue(q, A, R.targetEmitterId);
        }
        O && F.triggerAllBursts(), F.step(1);
      });
    }
    function kt() {
      const O = a.value;
      if (!O || !x.value || !k.value) return;
      const S = n.layers.filter((B) => B.type === "particles" && B.visible);
      if (S.length === 0) return;
      (x.value.width !== O.width || x.value.height !== O.height) && (x.value.width = O.width || 800, x.value.height = O.height || 600);
      const F = k.value;
      F.clearRect(0, 0, x.value.width, x.value.height);
      for (const B of S) {
        const R = g.value.get(B.id), D = B.data;
        if (R && D) {
          F.save();
          const A = O.viewportTransform;
          A && F.transform(A[0], A[1], A[2], A[3], A[4], A[5]), R.renderToCanvas(
            F,
            n.width,
            n.height,
            D.renderOptions
          ), F.restore();
        }
      }
      const b = O.getContext();
      b && S.length > 0 && b.drawImage(x.value, 0, 0);
    }
    function lt(O) {
      const S = g.value.get(O);
      return (S == null ? void 0 : S.getParticleCount()) ?? 0;
    }
    function pt() {
      n.updatePathAnimators();
      for (const O of n.layers) {
        const S = n.getPathAnimator(O.id);
        if (S) {
          const F = S.getState();
          T.value.set(O.id, F);
        }
      }
    }
    function it() {
      const O = a.value;
      if (!O || !x.value || !k.value) return;
      const S = n.layers.filter((b) => b.type === "text" && b.visible);
      if (S.length === 0) return;
      const F = k.value;
      for (const b of S) {
        const B = b.data;
        if (!(B != null && B.pathLayerId)) continue;
        const R = n.getPathAnimator(b.id);
        if (!R) continue;
        const D = T.value.get(b.id);
        if (!D) continue;
        const A = n.layers.find(($) => $.id === B.pathLayerId);
        if (!A) continue;
        const N = A.data;
        if (!(N != null && N.pathData)) continue;
        F.save();
        const q = O.viewportTransform;
        q && F.transform(q[0], q[1], q[2], q[3], q[4], q[5]);
        const J = R.getConfig(), V = Math.abs(D.position - D.previousPosition);
        if (J.motionBlur && V > 1e-3) {
          const $ = R.getMotionBlurTrail(8);
          F.lineCap = "round", F.lineJoin = "round";
          for (let rt = 0; rt < $.length - 1; rt++) {
            const ft = $[rt], bt = $[rt + 1], Ft = ft.opacity * J.motionBlurStrength * 0.5;
            F.strokeStyle = `rgba(255, 255, 255, ${Ft})`, F.lineWidth = Math.max(2, (B.fontSize || 48) * 0.1 * (1 - rt / $.length)), F.beginPath(), F.moveTo(ft.x, ft.y), F.lineTo(bt.x, bt.y), F.stroke();
          }
        }
        F.restore();
      }
    }
    function E(O) {
      const S = n.getPathAnimator(O);
      if (!S) return null;
      const F = T.value.get(O);
      if (!F) return null;
      const b = S.getPositionOnPath(F.position);
      return {
        x: b.x,
        y: b.y,
        angle: b.angle
      };
    }
    return e({
      fabricCanvas: a,
      fitToView: Q,
      zoom: f,
      particleSystems: g,
      depthflowRenderers: C,
      getParticleCount: lt,
      getTextPathPosition: E,
      pathAnimationStates: T
    }), (O, S) => (H(), G("div", {
      class: "composition-canvas",
      ref_key: "containerRef",
      ref: s
    }, [
      d("canvas", {
        ref_key: "canvasRef",
        ref: i
      }, null, 512),
      j.value || z.value ? (H(), ce(HT, {
        key: 0,
        layerId: j.value,
        canvasWidth: v.value,
        canvasHeight: _.value,
        zoom: f.value,
        viewportTransform: ot.value,
        isPenMode: z.value,
        onPointAdded: tt,
        onPathUpdated: U,
        ref_key: "splineEditorRef",
        ref: o
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : xt("", !0),
      d("div", e5, [
        d("button", {
          onClick: Z,
          title: "Zoom In"
        }, "+"),
        d("span", n5, ct(Math.round(f.value * 100)) + "%", 1),
        d("button", {
          onClick: yt,
          title: "Zoom Out"
        }, "-"),
        d("button", {
          onClick: Q,
          title: "Fit to View"
        }, "Fit")
      ]),
      P.value ? (H(), G("div", s5, [
        d("label", null, [
          Wt(d("input", {
            type: "checkbox",
            "onUpdate:modelValue": S[0] || (S[0] = (F) => m.value = F)
          }, null, 512), [
            [Lm, m.value]
          ]),
          S[3] || (S[3] = qt(" Depth Overlay ", -1))
        ]),
        Wt(d("select", {
          "onUpdate:modelValue": S[1] || (S[1] = (F) => p.value = F),
          class: "colormap-select"
        }, [...S[4] || (S[4] = [
          d("option", { value: "viridis" }, "Viridis", -1),
          d("option", { value: "plasma" }, "Plasma", -1),
          d("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [Kn, p.value]
        ]),
        Wt(d("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": S[2] || (S[2] = (F) => y.value = F),
          class: "opacity-slider"
        }, null, 512), [
          [
            ge,
            y.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : xt("", !0),
      h.value ? (H(), G("div", i5, [...S[5] || (S[5] = [
        d("div", { class: "loading-spinner" }, null, -1),
        d("span", null, "Loading...", -1)
      ])])) : xt("", !0)
    ], 512));
  }
}), o5 = /* @__PURE__ */ we(r5, [["__scopeId", "data-v-6b736d12"]]), a5 = { class: "layer-info" }, l5 = ["onClick"], c5 = { class: "av-switches" }, u5 = ["title"], h5 = { class: "icon" }, d5 = ["title"], f5 = { class: "icon" }, p5 = { class: "layer-name-container" }, m5 = ["title"], g5 = ["title"], v5 = { class: "parent-picker" }, y5 = ["value", "disabled"], b5 = ["value"], _5 = {
  key: 0,
  class: "layer-switches"
}, x5 = {
  key: 0,
  class: "effect-indicator",
  title: "Has Effects"
}, w5 = ["title", "onClick", "onDblclick"], S5 = /* @__PURE__ */ ye({
  __name: "EnhancedLayerTrack",
  props: {
    layer: {},
    frameCount: {},
    allLayers: {},
    soloedLayerIds: {},
    showSwitches: { type: Boolean }
  },
  emits: ["select", "updateLayer", "selectKeyframe", "setParent", "toggleSolo"],
  setup(r, { emit: e }) {
    const n = r, s = e, i = qe(), o = ut(null), a = ut(null), l = ut(!1), c = ut(!1), u = ut(""), h = [
      "#ff6b6b",
      "#ffc107",
      "#4ecdc4",
      "#45b7d1",
      "#96ceb4",
      "#7c9cff",
      "#bb8fce",
      "#ff8a65",
      "#a1887f",
      "#90a4ae",
      "#e0e0e0",
      "#333333"
    ], f = St(() => i.selectedLayerIds.includes(n.layer.id)), m = St(() => i.selectedKeyframeIds), p = St(() => n.soloedLayerIds.includes(n.layer.id)), y = St(
      () => n.soloedLayerIds.length > 0 && !p.value
    ), v = St(
      () => n.layer.type === "audio" || n.layer.type === "video"
    ), _ = St(() => n.allLayers.filter((E) => {
      if (E.id === n.layer.id) return !1;
      let O = E;
      for (; O.parentId; ) {
        if (O.parentId === n.layer.id) return !1;
        if (O = n.allLayers.find((S) => S.id === O.parentId) || O, !O.parentId) break;
      }
      return !0;
    })), g = St(() => {
      const E = n.layer.inPoint / n.frameCount * 100, S = (n.layer.outPoint + 1) / n.frameCount * 100 - E;
      return {
        left: `${E}%`,
        width: `${S}%`
      };
    }), C = St(() => {
      const E = [];
      return n.layer.opacity.animated && n.layer.opacity.keyframes.forEach((O) => {
        E.push({ ...O, propertyName: "Opacity" });
      }), ["position", "scale", "rotation"].forEach((O) => {
        const S = n.layer.transform[O];
        S != null && S.animated && S.keyframes.forEach((F) => {
          E.push({ ...F, propertyName: O.charAt(0).toUpperCase() + O.slice(1) });
        });
      }), n.layer.properties.forEach((O) => {
        O.animated && O.keyframes.forEach((S) => {
          E.push({ ...S, propertyName: O.name });
        });
      }), E;
    }), x = St(() => C.value.length > 0), k = St(() => {
      const E = [];
      return n.layer.properties.forEach((O) => {
        O.expression && E.push({
          propertyId: O.id,
          startFrame: n.layer.inPoint
        });
      }), E;
    });
    function w(E) {
      return E / n.frameCount * 100;
    }
    function T(E) {
      return {
        spline: "~",
        text: "T",
        solid: "[]",
        null: "N",
        camera: "C",
        light: "*",
        audio: "A",
        video: "V",
        image: "I",
        shape: "S",
        adjustment: "Ad"
      }[E] || "?";
    }
    function P() {
      s("select", n.layer.id);
    }
    function z() {
      s("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function j() {
      s("updateLayer", n.layer.id, { audioEnabled: !n.layer.audioEnabled });
    }
    function ot() {
      s("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function vt() {
      s("toggleSolo", n.layer.id);
    }
    function L(E) {
      s("updateLayer", n.layer.id, { [E]: !n.layer[E] });
    }
    function Y() {
      const E = n.layer.quality === "best" ? "draft" : "best";
      s("updateLayer", n.layer.id, { quality: E });
    }
    function M(E) {
      s("updateLayer", n.layer.id, { labelColor: E }), l.value = !1;
    }
    function I(E) {
      const S = E.target.value || null;
      s("setParent", n.layer.id, S);
    }
    function tt(E) {
      s("selectKeyframe", E);
    }
    function U(E) {
      i.setFrame(E);
    }
    function W() {
      n.layer.locked || (c.value = !0, u.value = n.layer.name, ws(() => {
        var E, O;
        (E = a.value) == null || E.focus(), (O = a.value) == null || O.select();
      }));
    }
    function Z() {
      u.value.trim() && s("updateLayer", n.layer.id, { name: u.value.trim() }), c.value = !1;
    }
    function yt() {
      c.value = !1;
    }
    let Q = null, at = 0, _t = 0, ht = 0;
    function X(E) {
      n.layer.locked || (Q = "move", at = E.clientX, _t = n.layer.inPoint, ht = n.layer.outPoint, document.addEventListener("mousemove", pt), document.addEventListener("mouseup", it));
    }
    function kt(E) {
      n.layer.locked || (Q = "trimIn", document.addEventListener("mousemove", pt), document.addEventListener("mouseup", it));
    }
    function lt(E) {
      n.layer.locked || (Q = "trimOut", document.addEventListener("mousemove", pt), document.addEventListener("mouseup", it));
    }
    function pt(E) {
      if (!o.value || !Q) return;
      const O = o.value.getBoundingClientRect(), S = E.clientX - O.left, F = Math.round(S / O.width * n.frameCount);
      if (Q === "trimIn") {
        const b = Math.min(F, n.layer.outPoint - 1);
        s("updateLayer", n.layer.id, { inPoint: Math.max(0, b) });
      } else if (Q === "trimOut") {
        const b = Math.max(F, n.layer.inPoint + 1);
        s("updateLayer", n.layer.id, { outPoint: Math.min(n.frameCount - 1, b) });
      } else if (Q === "move") {
        const b = E.clientX - at, B = Math.round(b / O.width * n.frameCount);
        let R = _t + B, D = ht + B;
        R < 0 && (D -= R, R = 0), D > n.frameCount - 1 && (R -= D - (n.frameCount - 1), D = n.frameCount - 1), s("updateLayer", n.layer.id, { inPoint: R, outPoint: D });
      }
    }
    function it() {
      Q = null, document.removeEventListener("mousemove", pt), document.removeEventListener("mouseup", it);
    }
    return (E, O) => (H(), G("div", {
      class: wt(["enhanced-layer-track", {
        selected: f.value,
        locked: r.layer.locked,
        hidden: !r.layer.visible,
        soloed: p.value,
        "dimmed-by-solo": y.value
      }]),
      onClick: P,
      style: ne({ "--label-color": r.layer.labelColor || "#7c9cff" })
    }, [
      d("div", a5, [
        d("div", {
          class: "label-color",
          onClick: O[1] || (O[1] = Bt((S) => l.value = !l.value, ["stop"]))
        }, [
          l.value ? (H(), G("div", {
            key: 0,
            class: "label-picker",
            onClick: O[0] || (O[0] = Bt(() => {
            }, ["stop"]))
          }, [
            (H(), G(Dt, null, jt(h, (S) => d("button", {
              key: S,
              style: ne({ background: S }),
              onClick: (F) => M(S)
            }, null, 12, l5)), 64))
          ])) : xt("", !0)
        ]),
        d("div", c5, [
          d("button", {
            class: wt(["icon-btn", { active: r.layer.visible }]),
            onClick: Bt(z, ["stop"]),
            title: r.layer.visible ? "Hide (V)" : "Show (V)"
          }, [
            d("span", h5, ct(r.layer.visible ? "V" : "-"), 1)
          ], 10, u5),
          v.value ? (H(), G("button", {
            key: 0,
            class: wt(["icon-btn", { active: r.layer.audioEnabled }]),
            onClick: Bt(j, ["stop"]),
            title: "Toggle Audio"
          }, [...O[7] || (O[7] = [
            d("span", { class: "icon" }, "A", -1)
          ])], 2)) : xt("", !0)
        ]),
        d("button", {
          class: wt(["icon-btn solo-btn", { active: p.value }]),
          onClick: Bt(vt, ["stop"]),
          title: "Solo (S)"
        }, [...O[8] || (O[8] = [
          d("span", { class: "icon" }, "S", -1)
        ])], 2),
        d("button", {
          class: wt(["icon-btn lock-btn", { active: r.layer.locked }]),
          onClick: Bt(ot, ["stop"]),
          title: r.layer.locked ? "Unlock (L)" : "Lock (L)"
        }, [
          d("span", f5, ct(r.layer.locked ? "L" : "u"), 1)
        ], 10, d5),
        d("div", p5, [
          d("span", {
            class: "layer-type-icon",
            title: r.layer.type
          }, ct(T(r.layer.type)), 9, m5),
          d("span", {
            class: "layer-name",
            title: r.layer.name,
            onDblclick: Bt(W, ["stop"])
          }, [
            c.value ? Wt((H(), G("input", {
              key: 0,
              "onUpdate:modelValue": O[2] || (O[2] = (S) => u.value = S),
              onBlur: Z,
              onKeyup: [
                sl(Z, ["enter"]),
                sl(yt, ["escape"])
              ],
              class: "rename-input",
              ref_key: "renameInput",
              ref: a
            }, null, 544)), [
              [ge, u.value]
            ]) : (H(), G(Dt, { key: 1 }, [
              qt(ct(r.layer.name), 1)
            ], 64))
          ], 40, g5)
        ]),
        d("div", v5, [
          d("select", {
            value: r.layer.parentId || "",
            onChange: I,
            disabled: r.layer.locked,
            class: "parent-select",
            title: "Parent & Link"
          }, [
            O[9] || (O[9] = d("option", { value: "" }, "None", -1)),
            (H(!0), G(Dt, null, jt(_.value, (S) => (H(), G("option", {
              key: S.id,
              value: S.id
            }, ct(S.name), 9, b5))), 128))
          ], 40, y5)
        ]),
        r.showSwitches ? (H(), G("div", _5, [
          d("button", {
            class: wt(["switch-btn", { active: r.layer.shy }]),
            onClick: O[3] || (O[3] = Bt((S) => L("shy"), ["stop"])),
            title: "Shy"
          }, " Sh ", 2),
          d("button", {
            class: wt(["switch-btn", { active: r.layer.collapse }]),
            onClick: O[4] || (O[4] = Bt((S) => L("collapse"), ["stop"])),
            title: "Collapse Transformations"
          }, " Ct ", 2),
          d("button", {
            class: wt(["switch-btn", { active: r.layer.quality === "best" }]),
            onClick: Bt(Y, ["stop"]),
            title: "Quality"
          }, ct(r.layer.quality === "best" ? "B" : "D"), 3),
          d("button", {
            class: wt(["switch-btn", { active: r.layer.is3D }]),
            onClick: O[5] || (O[5] = Bt((S) => L("is3D"), ["stop"])),
            title: "3D Layer"
          }, " 3D ", 2),
          d("button", {
            class: wt(["switch-btn", { active: r.layer.motionBlur }]),
            onClick: O[6] || (O[6] = Bt((S) => L("motionBlur"), ["stop"])),
            title: "Motion Blur"
          }, " MB ", 2)
        ])) : xt("", !0)
      ]),
      d("div", {
        class: "track-area",
        ref_key: "trackAreaRef",
        ref: o
      }, [
        d("div", {
          class: wt(["duration-bar", { "has-keyframes": x.value }]),
          style: ne(g.value),
          onMousedown: X
        }, [
          d("div", {
            class: "trim-handle trim-in",
            onMousedown: Bt(kt, ["stop"])
          }, null, 32),
          d("div", {
            class: "trim-handle trim-out",
            onMousedown: Bt(lt, ["stop"])
          }, null, 32),
          r.layer.effects && r.layer.effects.length > 0 ? (H(), G("div", x5, " fx ")) : xt("", !0)
        ], 38),
        (H(!0), G(Dt, null, jt(C.value, (S) => (H(), G("div", {
          key: S.id,
          class: wt(["keyframe-diamond", {
            selected: m.value.includes(S.id),
            [S.interpolation]: !0
          }]),
          style: ne({ left: `${w(S.frame)}%` }),
          title: `${S.propertyName} @ Frame ${S.frame}`,
          onClick: Bt((F) => tt(S.id), ["stop"]),
          onDblclick: Bt((F) => U(S.frame), ["stop"])
        }, null, 46, w5))), 128)),
        (H(!0), G(Dt, null, jt(k.value, (S) => (H(), G("div", {
          key: S.propertyId,
          class: "expression-indicator",
          style: ne({ left: `${w(S.startFrame)}%` }),
          title: "Expression"
        }, " = ", 4))), 128))
      ], 512)
    ], 6));
  }
}), C5 = /* @__PURE__ */ we(S5, [["__scopeId", "data-v-2d2067d2"]]), k5 = { class: "timeline-panel" }, T5 = { class: "timeline-header" }, M5 = { class: "header-left" }, O5 = { class: "timeline-info" }, E5 = { class: "header-center" }, P5 = { class: "playback-controls" }, D5 = { class: "icon" }, A5 = ["title"], F5 = { class: "icon" }, I5 = { class: "header-right" }, L5 = {
  key: 0,
  class: "add-layer-menu"
}, R5 = { class: "time-ruler" }, z5 = ["onClick", "onDblclick", "title"], j5 = {
  key: 0,
  class: "mark-label"
}, B5 = {
  key: 0,
  class: "empty-state"
}, V5 = { key: 0 }, $5 = { class: "timeline-scrubber" }, N5 = { class: "scrubber-sidebar" }, W5 = { class: "frame-label" }, U5 = { class: "frame-input" }, H5 = ["value", "max"], X5 = { class: "frame-total" }, G5 = { class: "marker-dialog-content" }, Y5 = { class: "form-row" }, K5 = { class: "form-row" }, q5 = { class: "form-row" }, Z5 = { class: "form-row" }, J5 = { class: "dialog-actions" }, Q5 = 220, tM = /* @__PURE__ */ ye({
  __name: "TimelinePanel",
  setup(r) {
    const e = qe(), n = ut(null), s = ut(null), i = ut(null), o = ut(!1), a = ut(600), l = ut(""), c = ut(!0), u = ut(!1), h = ut("loop");
    let f = null, m = 1;
    const p = Xs({
      start: 0,
      end: e.frameCount - 1
    }), y = ut([]), v = ut(null), _ = ut(null), g = ut([]), C = St(() => {
      if (!l.value) return e.layers;
      const V = l.value.toLowerCase();
      return e.layers.filter(
        ($) => $.name.toLowerCase().includes(V)
      );
    }), x = St(() => e.currentFrame / e.frameCount * a.value), k = St(() => e.currentFrame / (e.frameCount - 1) * 100), w = St(() => {
      const V = p.start / e.frameCount * 100, $ = (p.end + 1) / e.frameCount * 100;
      return {
        left: `${V}%`,
        width: `${$ - V}%`
      };
    }), T = St(() => w.value), P = St(() => {
      const V = [], $ = e.frameCount, rt = Math.max(1, Math.floor($ / 20)), ft = rt * 2;
      for (let bt = 0; bt <= $; bt += rt)
        V.push({
          frame: bt,
          position: bt / $ * 100,
          major: bt % ft === 0
        });
      return V;
    });
    function z(V) {
      const $ = e.fps, rt = V / $, ft = Math.floor(rt / 60), bt = Math.floor(rt % 60), Ft = V % $;
      return `${ft.toString().padStart(2, "0")}:${bt.toString().padStart(2, "0")}:${Ft.toString().padStart(2, "0")}`;
    }
    function j() {
      s.value && (a.value = s.value.offsetWidth);
    }
    function ot() {
      u.value = !u.value, u.value ? (m = 1, f = window.setInterval(() => {
        let V = e.currentFrame + m;
        if (V > p.end)
          if (h.value === "loop")
            V = p.start;
          else if (h.value === "pingpong")
            m = -1, V = e.currentFrame - 1;
          else {
            vt();
            return;
          }
        else V < p.start && h.value === "pingpong" && (m = 1, V = e.currentFrame + 1);
        e.setFrame(Math.max(p.start, Math.min(p.end, V)));
      }, 1e3 / e.fps)) : vt();
    }
    function vt() {
      u.value = !1, f && (clearInterval(f), f = null);
    }
    function L() {
      e.setFrame(p.start);
    }
    function Y() {
      e.setFrame(p.end);
    }
    function M() {
      e.setFrame(Math.min(e.currentFrame + 1, p.end));
    }
    function I() {
      e.setFrame(Math.max(e.currentFrame - 1, p.start));
    }
    function tt() {
      const V = ["none", "loop", "pingpong"], $ = V.indexOf(h.value);
      h.value = V[($ + 1) % V.length];
    }
    function U(V) {
      e.selectLayer(V);
    }
    function W(V, $) {
      e.updateLayer(V, $);
    }
    function Z(V) {
      const $ = e.selectedKeyframeIds.indexOf(V);
      $ >= 0 ? e.selectedKeyframeIds.splice($, 1) : e.selectedKeyframeIds.push(V);
    }
    function yt(V) {
      e.createLayer(V), o.value = !1;
    }
    function Q(V, $) {
      e.updateLayer(V, { parentId: $ });
    }
    function at(V) {
      const $ = g.value.indexOf(V);
      $ >= 0 ? g.value.splice($, 1) : g.value.push(V);
    }
    let _t = null, ht = 0;
    function X(V) {
      _t = "move", ht = V.clientX, document.addEventListener("mousemove", lt), document.addEventListener("mouseup", pt);
    }
    function kt(V, $) {
      _t = V, document.addEventListener("mousemove", lt), document.addEventListener("mouseup", pt);
    }
    function lt(V) {
      if (!s.value || !_t) return;
      const $ = s.value.getBoundingClientRect(), rt = V.clientX - $.left, ft = Math.round(rt / $.width * e.frameCount);
      if (_t === "start")
        p.start = Math.max(0, Math.min(ft, p.end - 1));
      else if (_t === "end")
        p.end = Math.min(e.frameCount - 1, Math.max(ft, p.start + 1));
      else if (_t === "move") {
        const bt = V.clientX - ht, Ft = Math.round(bt / $.width * e.frameCount), Ot = p.start + Ft, Xt = p.end + Ft;
        Ot >= 0 && Xt <= e.frameCount - 1 && (p.start = Ot, p.end = Xt), ht = V.clientX;
      }
    }
    function pt() {
      _t = null, document.removeEventListener("mousemove", lt), document.removeEventListener("mouseup", pt);
    }
    function it(V) {
      if (!s.value) return;
      const $ = s.value.getBoundingClientRect(), rt = V.clientX - $.left, ft = Math.round(rt / $.width * e.frameCount), bt = {
        id: `marker-${Date.now()}`,
        frame: ft,
        label: `Marker ${y.value.length + 1}`,
        color: "#ffc107",
        comment: ""
      };
      y.value.push(bt), _.value = { ...bt };
    }
    function E(V) {
      v.value = v.value === V ? null : V;
    }
    function O(V) {
      const $ = y.value.find((rt) => rt.id === V);
      $ && (_.value = { ...$ });
    }
    function S() {
      if (!_.value) return;
      const V = y.value.findIndex(($) => $.id === _.value.id);
      V >= 0 && (y.value[V] = { ..._.value }), _.value = null;
    }
    function F(V) {
      y.value = y.value.filter(($) => $.id !== V), v.value === V && (v.value = null), _.value = null;
    }
    let b = !1;
    function B(V) {
      b = !0, R(V), document.addEventListener("mousemove", D), document.addEventListener("mouseup", A);
    }
    function R(V) {
      const rt = V.currentTarget.getBoundingClientRect(), ft = V.clientX - rt.left, bt = Math.max(0, Math.min(1, ft / rt.width)), Ft = Math.round(bt * (e.frameCount - 1));
      e.setFrame(Ft);
    }
    function D(V) {
      if (!b) return;
      const $ = document.querySelector(".scrubber-track");
      if (!$) return;
      const rt = $.getBoundingClientRect(), ft = V.clientX - rt.left, bt = Math.max(0, Math.min(1, ft / rt.width)), Ft = Math.round(bt * (e.frameCount - 1));
      e.setFrame(Ft);
    }
    function A() {
      b = !1, document.removeEventListener("mousemove", D), document.removeEventListener("mouseup", A);
    }
    function N(V) {
      const $ = V.target, rt = parseInt($.value, 10);
      isNaN(rt) || e.setFrame(rt);
    }
    function q(V) {
      if (!(V.target.tagName === "INPUT" || V.target.tagName === "TEXTAREA"))
        switch (V.key) {
          case " ":
            V.preventDefault(), ot();
            break;
          case "Home":
            L();
            break;
          case "End":
            Y();
            break;
          case "PageUp":
            I();
            break;
          case "PageDown":
            M();
            break;
          case "b":
          case "B":
            p.start = e.currentFrame;
            break;
          case "n":
          case "N":
            p.end = e.currentFrame;
            break;
        }
    }
    function J(V) {
      const $ = V.target;
      !$.closest(".add-layer-btn") && !$.closest(".add-layer-menu") && (o.value = !1);
    }
    return Ne(() => {
      j(), window.addEventListener("resize", j), document.addEventListener("click", J), document.addEventListener("keydown", q), p.end = e.frameCount - 1;
    }), wn(() => {
      vt(), window.removeEventListener("resize", j), document.removeEventListener("click", J), document.removeEventListener("keydown", q);
    }), ae(() => e.frameCount, (V) => {
      p.end >= V && (p.end = V - 1);
    }), (V, $) => (H(), G("div", k5, [
      d("div", T5, [
        d("div", M5, [
          $[18] || ($[18] = d("span", { class: "timeline-title" }, "Timeline", -1)),
          d("span", O5, ct(At(e).frameCount) + " frames @ " + ct(At(e).fps) + "fps ", 1)
        ]),
        d("div", E5, [
          d("div", P5, [
            d("button", {
              onClick: L,
              title: "Go to Start (Home)"
            }, [...$[19] || ($[19] = [
              d("span", { class: "icon" }, "|<", -1)
            ])]),
            d("button", {
              onClick: I,
              title: "Previous Frame (Page Up)"
            }, [...$[20] || ($[20] = [
              d("span", { class: "icon" }, "<", -1)
            ])]),
            d("button", {
              onClick: ot,
              class: wt({ active: u.value }),
              title: "Play/Pause (Space)"
            }, [
              d("span", D5, ct(u.value ? "||" : ">"), 1)
            ], 2),
            d("button", {
              onClick: M,
              title: "Next Frame (Page Down)"
            }, [...$[21] || ($[21] = [
              d("span", { class: "icon" }, ">", -1)
            ])]),
            d("button", {
              onClick: Y,
              title: "Go to End (End)"
            }, [...$[22] || ($[22] = [
              d("span", { class: "icon" }, ">|", -1)
            ])])
          ]),
          d("button", {
            class: wt(["loop-btn", { active: h.value !== "none" }]),
            onClick: tt,
            title: `Loop: ${h.value}`
          }, [
            d("span", F5, ct(h.value === "none" ? "L-" : h.value === "loop" ? "LP" : "PP"), 1)
          ], 10, A5)
        ]),
        d("div", I5, [
          Wt(d("input", {
            type: "text",
            "onUpdate:modelValue": $[0] || ($[0] = (rt) => l.value = rt),
            placeholder: "Search layers...",
            class: "search-input"
          }, null, 512), [
            [ge, l.value]
          ]),
          d("button", {
            class: "add-layer-btn",
            onClick: $[1] || ($[1] = (rt) => o.value = !o.value)
          }, [...$[23] || ($[23] = [
            d("span", { class: "icon" }, "+", -1),
            qt(" Add Layer ", -1)
          ])]),
          o.value ? (H(), G("div", L5, [
            d("button", {
              onClick: $[2] || ($[2] = (rt) => yt("spline"))
            }, "Spline Path"),
            d("button", {
              onClick: $[3] || ($[3] = (rt) => yt("text"))
            }, "Text"),
            d("button", {
              onClick: $[4] || ($[4] = (rt) => yt("solid"))
            }, "Solid"),
            d("button", {
              onClick: $[5] || ($[5] = (rt) => yt("null"))
            }, "Null Object"),
            d("button", {
              onClick: $[6] || ($[6] = (rt) => yt("camera"))
            }, "Camera"),
            d("button", {
              onClick: $[7] || ($[7] = (rt) => yt("light"))
            }, "Light")
          ])) : xt("", !0)
        ])
      ]),
      $[33] || ($[33] = bi('<div class="column-headers" data-v-f3b9bc96><div class="layer-columns-header" data-v-f3b9bc96><span class="col-header col-label" title="Label Color" data-v-f3b9bc96>L</span><span class="col-header col-av" title="Audio/Video" data-v-f3b9bc96>AV</span><span class="col-header col-solo" title="Solo" data-v-f3b9bc96>S</span><span class="col-header col-lock" title="Lock" data-v-f3b9bc96>Lk</span><span class="col-header col-name" data-v-f3b9bc96>Layer Name</span><span class="col-header col-parent" title="Parent &amp; Link" data-v-f3b9bc96>Par</span><span class="col-header col-switches" title="Layer Switches" data-v-f3b9bc96>Switches</span></div><div class="track-header" data-v-f3b9bc96></div></div>', 1)),
      d("div", {
        class: "timeline-content",
        ref_key: "timelineContentRef",
        ref: n
      }, [
        d("div", R5, [
          $[24] || ($[24] = d("div", { class: "ruler-sidebar" }, null, -1)),
          d("div", {
            class: "ruler-track",
            ref_key: "rulerTrackRef",
            ref: s,
            onDblclick: it
          }, [
            d("div", {
              class: "work-area",
              style: ne(w.value),
              onMousedown: X
            }, [
              d("div", {
                class: "work-area-handle start",
                onMousedown: $[8] || ($[8] = Bt((rt) => kt("start"), ["stop"]))
              }, null, 32),
              d("div", {
                class: "work-area-handle end",
                onMousedown: $[9] || ($[9] = Bt((rt) => kt("end"), ["stop"]))
              }, null, 32)
            ], 36),
            (H(!0), G(Dt, null, jt(y.value, (rt) => (H(), G("div", {
              key: rt.id,
              class: wt(["marker", { selected: v.value === rt.id }]),
              style: ne({ left: `${rt.frame / At(e).frameCount * 100}%` }),
              onClick: Bt((ft) => E(rt.id), ["stop"]),
              onDblclick: Bt((ft) => O(rt.id), ["stop"]),
              title: `${rt.label} (Frame ${rt.frame})`
            }, [
              d("div", {
                class: "marker-flag",
                style: ne({ background: rt.color })
              }, null, 4)
            ], 46, z5))), 128)),
            (H(!0), G(Dt, null, jt(P.value, (rt) => (H(), G("div", {
              key: rt.frame,
              class: wt(["ruler-mark", { major: rt.major }]),
              style: ne({ left: `${rt.position}%` })
            }, [
              rt.major ? (H(), G("span", j5, ct(z(rt.frame)), 1)) : xt("", !0)
            ], 6))), 128))
          ], 544)
        ]),
        d("div", {
          class: "layer-tracks",
          ref_key: "layerTracksRef",
          ref: i
        }, [
          (H(!0), G(Dt, null, jt(C.value, (rt) => (H(), ce(C5, {
            key: rt.id,
            layer: rt,
            frameCount: At(e).frameCount,
            allLayers: At(e).layers,
            soloedLayerIds: g.value,
            showSwitches: c.value,
            onSelect: U,
            onUpdateLayer: W,
            onSelectKeyframe: Z,
            onSetParent: Q,
            onToggleSolo: at
          }, null, 8, ["layer", "frameCount", "allLayers", "soloedLayerIds", "showSwitches"]))), 128)),
          C.value.length === 0 ? (H(), G("div", B5, [
            l.value ? (H(), G("p", V5, 'No layers match "' + ct(l.value) + '"', 1)) : (H(), G(Dt, { key: 1 }, [
              $[25] || ($[25] = d("p", null, "No layers yet", -1)),
              $[26] || ($[26] = d("p", { class: "hint" }, 'Click "Add Layer" to create a layer', -1))
            ], 64))
          ])) : xt("", !0)
        ], 512),
        d("div", {
          class: "playhead",
          style: ne({ left: `${Q5 + x.value}px` })
        }, [...$[27] || ($[27] = [
          d("div", { class: "playhead-head" }, null, -1),
          d("div", { class: "playhead-line" }, null, -1)
        ])], 4)
      ], 512),
      d("div", $5, [
        d("div", N5, [
          d("button", {
            class: wt(["toggle-switches-btn", { active: c.value }]),
            onClick: $[10] || ($[10] = (rt) => c.value = !c.value),
            title: "Toggle Layer Switches"
          }, " Sw ", 2),
          d("span", W5, ct(z(At(e).currentFrame)), 1)
        ]),
        d("div", {
          class: "scrubber-track",
          onMousedown: B,
          onClick: R
        }, [
          d("div", {
            class: "scrubber-work-area",
            style: ne(T.value)
          }, null, 4),
          d("div", {
            class: "scrubber-progress",
            style: ne({ width: `${k.value}%` })
          }, null, 4)
        ], 32),
        d("div", U5, [
          d("input", {
            type: "number",
            value: At(e).currentFrame,
            min: 0,
            max: At(e).frameCount - 1,
            onChange: N
          }, null, 40, H5),
          d("span", X5, "/ " + ct(At(e).frameCount - 1), 1)
        ])
      ]),
      _.value ? (H(), G("div", {
        key: 0,
        class: "marker-dialog",
        onClick: $[17] || ($[17] = Bt((rt) => _.value = null, ["self"]))
      }, [
        d("div", G5, [
          $[32] || ($[32] = d("h3", null, "Edit Marker", -1)),
          d("div", Y5, [
            $[28] || ($[28] = d("label", null, "Label:", -1)),
            Wt(d("input", {
              type: "text",
              "onUpdate:modelValue": $[11] || ($[11] = (rt) => _.value.label = rt)
            }, null, 512), [
              [ge, _.value.label]
            ])
          ]),
          d("div", K5, [
            $[29] || ($[29] = d("label", null, "Frame:", -1)),
            Wt(d("input", {
              type: "number",
              "onUpdate:modelValue": $[12] || ($[12] = (rt) => _.value.frame = rt)
            }, null, 512), [
              [
                ge,
                _.value.frame,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          d("div", q5, [
            $[30] || ($[30] = d("label", null, "Color:", -1)),
            Wt(d("input", {
              type: "color",
              "onUpdate:modelValue": $[13] || ($[13] = (rt) => _.value.color = rt)
            }, null, 512), [
              [ge, _.value.color]
            ])
          ]),
          d("div", Z5, [
            $[31] || ($[31] = d("label", null, "Comment:", -1)),
            Wt(d("textarea", {
              "onUpdate:modelValue": $[14] || ($[14] = (rt) => _.value.comment = rt),
              rows: "3"
            }, null, 512), [
              [ge, _.value.comment]
            ])
          ]),
          d("div", J5, [
            d("button", {
              onClick: $[15] || ($[15] = (rt) => F(_.value.id))
            }, "Delete"),
            d("button", {
              onClick: $[16] || ($[16] = (rt) => _.value = null)
            }, "Cancel"),
            d("button", {
              class: "primary",
              onClick: S
            }, "Save")
          ])
        ])
      ])) : xt("", !0)
    ]));
  }
}), Ru = /* @__PURE__ */ we(tM, [["__scopeId", "data-v-f3b9bc96"]]), eM = { class: "graph-editor" }, nM = { class: "graph-header" }, sM = { class: "mode-toggle" }, iM = { class: "preset-buttons" }, rM = ["onClick", "title"], oM = { class: "toolbar" }, aM = { class: "graph-content" }, lM = { class: "property-list" }, cM = { class: "property-list-header" }, uM = ["title"], hM = ["onClick"], dM = ["onClick"], fM = { class: "property-name" }, pM = {
  key: 0,
  class: "keyframe-count"
}, mM = {
  key: 0,
  class: "dimension-toggles"
}, gM = ["onClick"], vM = {
  key: 0,
  class: "no-properties"
}, yM = { class: "graph-main" }, bM = ["viewBox"], _M = ["onMousedown"], xM = ["x", "y", "fill", "transform"], wM = {
  key: 1,
  class: "bezier-handles"
}, SM = {
  key: 0,
  class: "handle out-handle"
}, CM = ["x1", "y1", "x2", "y2"], kM = ["cx", "cy", "onMousedown"], TM = {
  key: 1,
  class: "handle in-handle"
}, MM = ["x1", "y1", "x2", "y2"], OM = ["cx", "cy", "onMousedown"], EM = ["x1", "x2", "y2"], PM = {
  key: 0,
  class: "keyframe-info-panel"
}, DM = { class: "info-row" }, AM = ["value"], FM = { class: "info-row" }, IM = ["value"], LM = { class: "info-row" }, RM = ["value"], zM = ["disabled"], jM = ["disabled"], BM = ["disabled"], VM = /* @__PURE__ */ ye({
  __name: "GraphEditor",
  emits: ["close"],
  setup(r, { emit: e }) {
    const n = e, s = qe(), i = ut(null), o = ut(null), a = ut(null), l = ut(null), c = ut(null), u = ut(null), h = ut(400), f = ut(200), m = ut("value"), p = Xs({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), y = ut([]), v = ut([]), _ = ut({}), g = ut([]), C = ut(null), x = ut(null), k = ut(null), w = ut(null), T = ut(null), P = ut(!1), z = ut(!0), j = { top: 10, right: 10, bottom: 10, left: 10 }, ot = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, vt = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], L = St(() => {
      const K = s.selectedLayer;
      if (!K) return [];
      const et = [];
      return et.push(K.transform.position), et.push(K.transform.scale), et.push(K.transform.rotation), et.push(K.opacity), et.push(...K.properties), et;
    }), Y = St(() => L.value.filter(
      (K) => v.value.includes(K.id) && K.animated
    )), M = St(() => L.value.every((K) => v.value.includes(K.id))), I = St(() => tt(s.currentFrame));
    function tt(K) {
      const et = h.value - j.left - j.right, dt = (K - p.frameStart) / (p.frameEnd - p.frameStart);
      return j.left + dt * et;
    }
    function U(K) {
      const et = h.value - j.left - j.right, dt = (K - j.left) / et;
      return p.frameStart + dt * (p.frameEnd - p.frameStart);
    }
    function W(K) {
      const et = f.value - j.top - j.bottom, dt = (K - p.valueMin) / (p.valueMax - p.valueMin);
      return f.value - j.bottom - dt * et;
    }
    function Z(K) {
      const et = f.value - j.top - j.bottom, dt = (f.value - j.bottom - K) / et;
      return p.valueMin + dt * (p.valueMax - p.valueMin);
    }
    function yt(K) {
      return tt(K.frame);
    }
    function Q(K, et) {
      const dt = typeof et.value == "number" ? et.value : typeof et.value == "object" ? et.value.x ?? et.value : 0;
      return W(dt);
    }
    function at(K) {
      if (!K) return 0;
      const et = K.keyframe.value;
      return typeof et == "number" ? et : typeof et == "object" ? et.x ?? 0 : 0;
    }
    function _t(K, et) {
      const dt = K.keyframes[et], Tt = K.keyframes[et + 1];
      if (!dt || !Tt) return 0;
      const gt = Tt.frame - dt.frame, Mt = dt.frame + dt.outHandle.x * gt;
      return tt(Mt);
    }
    function ht(K, et) {
      const dt = K.keyframes[et], Tt = K.keyframes[et + 1];
      if (!dt || !Tt) return 0;
      const gt = lt(Tt.value) - lt(dt.value), Mt = lt(dt.value) + dt.outHandle.y * gt;
      return W(Mt);
    }
    function X(K, et) {
      const dt = K.keyframes[et], Tt = K.keyframes[et - 1];
      if (!dt || !Tt) return 0;
      const gt = dt.frame - Tt.frame, Mt = dt.frame - dt.inHandle.x * gt;
      return tt(Mt);
    }
    function kt(K, et) {
      const dt = K.keyframes[et], Tt = K.keyframes[et - 1];
      if (!dt || !Tt) return 0;
      const gt = lt(dt.value) - lt(Tt.value), Mt = lt(dt.value) - dt.inHandle.y * gt;
      return W(Mt);
    }
    function lt(K) {
      return typeof K == "number" ? K : typeof K == "object" ? K.x ?? K.y ?? K.z ?? 0 : 0;
    }
    function pt(K) {
      const et = L.value.find((dt) => dt.id === K);
      return et ? ot[et.name] ?? ot.default : ot.default;
    }
    function it(K) {
      return K.frame >= p.frameStart && K.frame <= p.frameEnd;
    }
    function E(K, et) {
      return g.value.some((dt) => dt.propId === K && dt.index === et);
    }
    function O(K, et) {
      if (!K.animated || K.keyframes.length === 0) return !1;
      const dt = K.keyframes[0].value;
      return typeof dt == "object" && et in dt;
    }
    function S(K) {
      const et = y.value.indexOf(K);
      et === -1 ? y.value.push(K) : y.value.splice(et, 1);
    }
    function F(K) {
      const et = v.value.indexOf(K);
      et === -1 ? v.value.push(K) : v.value.splice(et, 1), D();
    }
    function b() {
      M.value ? v.value = [] : v.value = L.value.map((K) => K.id), D();
    }
    function B(K, et) {
      _.value[K] || (_.value[K] = []);
      const dt = _.value[K], Tt = dt.indexOf(et);
      Tt === -1 ? dt.push(et) : dt.splice(Tt, 1);
    }
    function R() {
      const K = Y.value;
      if (K.length === 0) return;
      let et = 1 / 0, dt = -1 / 0, Tt = 1 / 0, gt = -1 / 0;
      for (const Yt of K)
        for (const te of Yt.keyframes) {
          et = Math.min(et, te.frame), dt = Math.max(dt, te.frame);
          const Vt = lt(te.value);
          Tt = Math.min(Tt, Vt), gt = Math.max(gt, Vt);
        }
      const Mt = (dt - et) * 0.1 || 10, It = (gt - Tt) * 0.1 || 10;
      p.frameStart = et - Mt, p.frameEnd = dt + Mt, p.valueMin = Tt - It, p.valueMax = gt + It;
    }
    function D() {
      R();
    }
    function A() {
      z.value = !z.value;
    }
    function N(K) {
      if (g.value.length === 0) return !1;
      const et = Oo[K];
      return et ? g.value.every((dt) => {
        const Tt = Math.abs(dt.keyframe.outHandle.x - et.outHandle.x) < 0.01 && Math.abs(dt.keyframe.outHandle.y - et.outHandle.y) < 0.01, gt = Math.abs(dt.keyframe.inHandle.x - et.inHandle.x) < 0.01 && Math.abs(dt.keyframe.inHandle.y - et.inHandle.y) < 0.01;
        return Tt && gt;
      }) : !1;
    }
    function q(K) {
      const et = Oo[K];
      if (et) {
        for (const dt of g.value)
          dt.keyframe.outHandle = { ...et.outHandle }, dt.keyframe.inHandle = { ...et.inHandle }, dt.keyframe.interpolation = K === "linear" ? "linear" : "bezier";
        Re();
      }
    }
    function J(K) {
      var gt;
      const et = (gt = i.value) == null ? void 0 : gt.getBoundingClientRect();
      if (!et) return;
      const dt = K.clientX - et.left, Tt = K.clientY - et.top;
      K.button === 1 || K.button === 0 && K.altKey ? x.value = { type: "pan", startX: dt, startY: Tt } : K.button === 0 && (K.shiftKey || (g.value = []), k.value = { x: dt, y: Tt, width: 0, height: 0 }, x.value = { type: "select", startX: dt, startY: Tt });
    }
    function V(K) {
      var gt;
      const et = (gt = i.value) == null ? void 0 : gt.getBoundingClientRect();
      if (!et) return;
      const dt = K.clientX - et.left, Tt = K.clientY - et.top;
      if (ft(dt, Tt), !!x.value)
        if (x.value.type === "pan") {
          const Mt = dt - (x.value.startX ?? 0), It = Tt - (x.value.startY ?? 0), Yt = h.value - j.left - j.right, te = f.value - j.top - j.bottom, Vt = -Mt / Yt * (p.frameEnd - p.frameStart), Oe = It / te * (p.valueMax - p.valueMin);
          p.frameStart += Vt, p.frameEnd += Vt, p.valueMin += Oe, p.valueMax += Oe, x.value.startX = dt, x.value.startY = Tt, Re();
        } else if (x.value.type === "select" && k.value) {
          const Mt = x.value.startX ?? 0, It = x.value.startY ?? 0;
          k.value = {
            x: Math.min(dt, Mt),
            y: Math.min(Tt, It),
            width: Math.abs(dt - Mt),
            height: Math.abs(Tt - It)
          };
        } else x.value.type === "keyframe" ? Ot(dt, Tt) : (x.value.type === "outHandle" || x.value.type === "inHandle") && he(dt, Tt);
    }
    function $() {
      var K;
      ((K = x.value) == null ? void 0 : K.type) === "select" && k.value && Ft(), x.value = null, k.value = null;
    }
    function rt(K) {
      var Yt;
      K.preventDefault();
      const et = (Yt = i.value) == null ? void 0 : Yt.getBoundingClientRect();
      if (!et) return;
      const dt = K.clientX - et.left, Tt = K.deltaY > 0 ? 1.1 : 0.9, gt = U(dt), Mt = gt - (gt - p.frameStart) * Tt, It = gt + (p.frameEnd - gt) * Tt;
      if (K.shiftKey)
        p.frameStart = Mt, p.frameEnd = It;
      else {
        p.frameStart = Mt, p.frameEnd = It;
        const te = K.clientY - et.top, Vt = Z(te);
        p.valueMin = Vt - (Vt - p.valueMin) * Tt, p.valueMax = Vt + (p.valueMax - Vt) * Tt;
      }
      Re();
    }
    function ft(K, et) {
      C.value = null;
      for (const dt of Y.value)
        for (let Tt = 0; Tt < dt.keyframes.length; Tt++) {
          const gt = dt.keyframes[Tt], Mt = yt(gt), It = Q(dt, gt);
          if (Math.sqrt((K - Mt) ** 2 + (et - It) ** 2) < 10) {
            C.value = { propId: dt.id, index: Tt };
            return;
          }
        }
    }
    function bt(K, et, dt) {
      const Tt = L.value.find((Mt) => Mt.id === K);
      if (!Tt) return;
      const gt = Tt.keyframes[et];
      dt.shiftKey || (g.value = []), E(K, et) || g.value.push({ propId: K, index: et, keyframe: gt }), x.value = { type: "keyframe", propId: K, index: et };
    }
    function Ft() {
      if (!k.value) return;
      const K = k.value;
      for (const et of Y.value)
        for (let dt = 0; dt < et.keyframes.length; dt++) {
          const Tt = et.keyframes[dt], gt = yt(Tt), Mt = Q(et, Tt);
          gt >= K.x && gt <= K.x + K.width && Mt >= K.y && Mt <= K.y + K.height && (E(et.id, dt) || g.value.push({ propId: et.id, index: dt, keyframe: Tt }));
        }
    }
    function Ot(K, et) {
      const dt = Math.round(U(K)), Tt = Z(et);
      if (g.value.length > 0) {
        const gt = g.value[0];
        gt.keyframe.frame = P.value ? Math.round(dt / 5) * 5 : dt, typeof gt.keyframe.value == "number" && (gt.keyframe.value = Tt);
      }
      Re();
    }
    function Xt(K, et, dt, Tt) {
      x.value = { type: K, propId: et, index: dt }, document.addEventListener("mousemove", de), document.addEventListener("mouseup", Ce);
    }
    function de(K) {
      var gt;
      const et = (gt = i.value) == null ? void 0 : gt.getBoundingClientRect();
      if (!et || !x.value) return;
      const dt = K.clientX - et.left, Tt = K.clientY - et.top;
      he(dt, Tt);
    }
    function he(K, et) {
      if (!x.value || !x.value.propId) return;
      const dt = L.value.find((Mt) => Mt.id === x.value.propId);
      if (!dt) return;
      const Tt = x.value.index, gt = dt.keyframes[Tt];
      if (gt) {
        if (x.value.type === "outHandle") {
          const Mt = dt.keyframes[Tt + 1];
          if (!Mt) return;
          const It = Mt.frame - gt.frame, Yt = lt(Mt.value) - lt(gt.value), te = U(K), Vt = Z(et);
          gt.outHandle = {
            x: Math.max(0, Math.min(1, (te - gt.frame) / It)),
            y: Yt !== 0 ? (Vt - lt(gt.value)) / Yt : 0
          }, gt.interpolation = "bezier";
        } else if (x.value.type === "inHandle") {
          const Mt = dt.keyframes[Tt - 1];
          if (!Mt) return;
          const It = gt.frame - Mt.frame, Yt = lt(gt.value) - lt(Mt.value), te = U(K), Vt = Z(et);
          gt.inHandle = {
            x: Math.max(0, Math.min(1, (gt.frame - te) / It)),
            y: Yt !== 0 ? (lt(gt.value) - Vt) / Yt : 0
          };
        }
        Re();
      }
    }
    function Ce() {
      x.value = null, document.removeEventListener("mousemove", de), document.removeEventListener("mouseup", Ce);
    }
    function Qt(K) {
      w.value = { x: K.offsetX, y: K.offsetY };
    }
    function Ln() {
      if (!w.value) return;
      const K = Math.round(U(w.value.x)), et = Z(w.value.y);
      if (Y.value.length > 0) {
        const dt = Y.value[0], Tt = {
          id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          frame: K,
          value: typeof dt.value == "number" ? et : { x: et, y: et },
          interpolation: "bezier",
          inHandle: { x: 0.33, y: 0 },
          outHandle: { x: 0.33, y: 0 },
          handlesBroken: !1
        }, gt = dt.keyframes.findIndex((Mt) => Mt.frame > K);
        gt === -1 ? dt.keyframes.push(Tt) : dt.keyframes.splice(gt, 0, Tt), dt.animated = !0, Re();
      }
      w.value = null;
    }
    function ke() {
      for (const K of g.value) {
        const et = L.value.find((dt) => dt.id === K.propId);
        if (et) {
          const dt = et.keyframes.indexOf(K.keyframe);
          dt !== -1 && et.keyframes.splice(dt, 1), et.keyframes.length === 0 && (et.animated = !1);
        }
      }
      g.value = [], Re();
    }
    function pe() {
      T.value = g.value.map((K) => ({ ...K.keyframe }));
    }
    function Ms() {
      if (!T.value || Y.value.length === 0) return;
      const K = Y.value[0], et = s.currentFrame - T.value[0].frame;
      for (const dt of T.value) {
        const Tt = {
          ...dt,
          frame: dt.frame + et
        }, gt = K.keyframes.findIndex((Mt) => Mt.frame > Tt.frame);
        gt === -1 ? K.keyframes.push(Tt) : K.keyframes.splice(gt, 0, Tt);
      }
      K.animated = !0, Re();
    }
    function Ys() {
      g.value = [];
      for (const K of Y.value)
        for (let et = 0; et < K.keyframes.length; et++)
          g.value.push({ propId: K.id, index: et, keyframe: K.keyframes[et] });
    }
    function ga() {
      const K = [];
      for (const et of Y.value)
        for (let dt = 0; dt < et.keyframes.length; dt++)
          E(et.id, dt) || K.push({ propId: et.id, index: dt, keyframe: et.keyframes[dt] });
      g.value = K;
    }
    function va(K) {
      const et = parseInt(K.target.value);
      g.value.length > 0 && !isNaN(et) && (g.value[0].keyframe.frame = et, Re());
    }
    function Sr(K) {
      const et = parseFloat(K.target.value);
      if (g.value.length > 0 && !isNaN(et)) {
        const dt = g.value[0].keyframe;
        typeof dt.value == "number" ? dt.value = et : typeof dt.value == "object" && (dt.value.x = et), Re();
      }
    }
    function Os(K) {
      const et = K.target.value;
      g.value.length > 0 && (g.value[0].keyframe.interpolation = et, Re());
    }
    function Ks(K) {
      var gt;
      const et = (gt = l.value) == null ? void 0 : gt.getBoundingClientRect();
      if (!et) return;
      const dt = K.clientX - et.left, Tt = Math.round(U(dt));
      s.setFrame(Tt);
    }
    function Re() {
      uf(), ff(), pf();
    }
    function uf() {
      const K = i.value;
      if (!K) return;
      const et = K.getContext("2d");
      if (et) {
        K.width = h.value, K.height = f.value, et.fillStyle = "#1a1a1a", et.fillRect(0, 0, h.value, f.value), hf(et);
        for (const dt of Y.value)
          df(et, dt);
      }
    }
    function hf(K) {
      const et = h.value - j.left - j.right, dt = f.value - j.top - j.bottom;
      K.strokeStyle = "#2a2a2a", K.lineWidth = 1;
      const Tt = p.frameEnd - p.frameStart, gt = Cr(Tt, et, 50), Mt = p.valueMax - p.valueMin, It = Cr(Mt, dt, 30), Yt = Math.ceil(p.frameStart / gt) * gt;
      for (let Vt = Yt; Vt <= p.frameEnd; Vt += gt) {
        const Oe = tt(Vt);
        K.beginPath(), K.moveTo(Oe, j.top), K.lineTo(Oe, f.value - j.bottom), K.stroke();
      }
      const te = Math.ceil(p.valueMin / It) * It;
      for (let Vt = te; Vt <= p.valueMax; Vt += It) {
        const Oe = W(Vt);
        K.beginPath(), K.moveTo(j.left, Oe), K.lineTo(h.value - j.right, Oe), K.stroke();
      }
      if (K.strokeStyle = "#3a3a3a", K.lineWidth = 1, p.frameStart <= 0 && p.frameEnd >= 0) {
        const Vt = tt(0);
        K.beginPath(), K.moveTo(Vt, j.top), K.lineTo(Vt, f.value - j.bottom), K.stroke();
      }
      if (p.valueMin <= 0 && p.valueMax >= 0) {
        const Vt = W(0);
        K.beginPath(), K.moveTo(j.left, Vt), K.lineTo(h.value - j.right, Vt), K.stroke();
      }
    }
    function Cr(K, et, dt) {
      const Tt = K * dt / et, gt = Math.pow(10, Math.floor(Math.log10(Tt))), Mt = Tt / gt;
      return Mt <= 1 ? gt : Mt <= 2 ? 2 * gt : Mt <= 5 ? 5 * gt : 10 * gt;
    }
    function df(K, et) {
      if (et.keyframes.length < 2) return;
      const dt = pt(et.id);
      K.strokeStyle = dt, K.lineWidth = 2, K.beginPath();
      let Tt = !1;
      for (let gt = 0; gt < et.keyframes.length - 1; gt++) {
        const Mt = et.keyframes[gt], It = et.keyframes[gt + 1];
        if (It.frame < p.frameStart || Mt.frame > p.frameEnd) continue;
        const Yt = yt(Mt), te = Q(et, Mt), Vt = yt(It), Oe = Q(et, It);
        if (Tt || (K.moveTo(Yt, te), Tt = !0), Mt.interpolation === "hold")
          K.lineTo(Vt, te), K.lineTo(Vt, Oe);
        else if (Mt.interpolation === "linear")
          K.lineTo(Vt, Oe);
        else {
          const kr = Yt + (Vt - Yt) * Mt.outHandle.x, Tr = te + (Oe - te) * Mt.outHandle.y, Mr = Vt - (Vt - Yt) * It.inHandle.x, Or = Oe - (Oe - te) * It.inHandle.y;
          K.bezierCurveTo(kr, Tr, Mr, Or, Vt, Oe);
        }
      }
      K.stroke();
    }
    function ff() {
      var Yt;
      const K = l.value;
      if (!K) return;
      const et = (Yt = a.value) == null ? void 0 : Yt.getBoundingClientRect();
      if (!et) return;
      K.width = et.width, K.height = 24;
      const dt = K.getContext("2d");
      if (!dt) return;
      dt.fillStyle = "#252525", dt.fillRect(0, 0, K.width, K.height);
      const Tt = p.frameEnd - p.frameStart, gt = Cr(Tt, K.width, 60);
      dt.fillStyle = "#888", dt.font = "10px system-ui", dt.textAlign = "center";
      const Mt = Math.ceil(p.frameStart / gt) * gt;
      for (let te = Mt; te <= p.frameEnd; te += gt) {
        const Vt = tt(te);
        dt.fillText(te.toString(), Vt, 16), dt.strokeStyle = "#444", dt.beginPath(), dt.moveTo(Vt, 20), dt.lineTo(Vt, 24), dt.stroke();
      }
      const It = tt(s.currentFrame);
      dt.fillStyle = "#ff4444", dt.beginPath(), dt.moveTo(It - 5, 0), dt.lineTo(It + 5, 0), dt.lineTo(It, 8), dt.closePath(), dt.fill();
    }
    function pf() {
      var It;
      const K = u.value;
      if (!K) return;
      const et = (It = c.value) == null ? void 0 : It.getBoundingClientRect();
      if (!et) return;
      K.width = 40, K.height = et.height;
      const dt = K.getContext("2d");
      if (!dt) return;
      dt.fillStyle = "#252525", dt.fillRect(0, 0, K.width, K.height);
      const Tt = p.valueMax - p.valueMin, gt = Cr(Tt, K.height, 30);
      dt.fillStyle = "#888", dt.font = "10px system-ui", dt.textAlign = "right";
      const Mt = Math.ceil(p.valueMin / gt) * gt;
      for (let Yt = Mt; Yt <= p.valueMax; Yt += gt) {
        const te = W(Yt);
        dt.fillText(Yt.toFixed(0), 36, te + 4);
      }
    }
    let Di = null;
    return Ne(() => {
      o.value && (Di = new ResizeObserver((K) => {
        for (const et of K)
          h.value = et.contentRect.width, f.value = et.contentRect.height, Re();
      }), Di.observe(o.value)), v.value = L.value.filter((K) => K.animated).map((K) => K.id), R(), Re();
    }), wn(() => {
      Di == null || Di.disconnect();
    }), ae([() => s.currentFrame, v, m], () => {
      Re();
    }), ae(L, () => {
      R(), Re();
    }, { deep: !0 }), (K, et) => {
      var dt, Tt;
      return H(), G("div", eM, [
        d("div", nM, [
          et[9] || (et[9] = d("span", { class: "graph-title" }, "Graph Editor", -1)),
          d("div", sM, [
            d("button", {
              class: wt({ active: m.value === "value" }),
              onClick: et[0] || (et[0] = (gt) => m.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            d("button", {
              class: wt({ active: m.value === "speed" }),
              onClick: et[1] || (et[1] = (gt) => m.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          d("div", iM, [
            (H(), G(Dt, null, jt(vt, (gt) => d("button", {
              key: gt.key,
              class: wt(["preset-btn", { active: N(gt.key) }]),
              onClick: (Mt) => q(gt.key),
              title: gt.label
            }, ct(gt.shortLabel), 11, rM)), 64))
          ]),
          d("div", oM, [
            d("button", {
              onClick: R,
              title: "Fit to View"
            }, [...et[5] || (et[5] = [
              d("span", { class: "icon" }, "[ ]", -1)
            ])]),
            d("button", {
              onClick: A,
              class: wt({ active: z.value }),
              title: "Auto-select Nearby Keyframes"
            }, [...et[6] || (et[6] = [
              d("span", { class: "icon" }, "A", -1)
            ])], 2),
            d("button", {
              onClick: et[2] || (et[2] = (gt) => P.value = !P.value),
              class: wt({ active: P.value }),
              title: "Snap to Grid"
            }, [...et[7] || (et[7] = [
              d("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          d("button", {
            class: "close-btn",
            onClick: et[3] || (et[3] = (gt) => n("close"))
          }, [...et[8] || (et[8] = [
            d("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        d("div", aM, [
          d("div", lM, [
            d("div", cM, [
              et[10] || (et[10] = qt(" Properties ", -1)),
              d("button", {
                class: "toggle-all-btn",
                onClick: b,
                title: M.value ? "Hide All" : "Show All"
              }, ct(M.value ? "Hide" : "Show"), 9, uM)
            ]),
            (H(!0), G(Dt, null, jt(L.value, (gt) => (H(), G("div", {
              key: gt.id,
              class: wt(["property-item", {
                selected: y.value.includes(gt.id),
                animated: gt.animated
              }])
            }, [
              d("div", {
                class: "property-row",
                onClick: (Mt) => S(gt.id)
              }, [
                d("span", {
                  class: wt(["visibility-toggle", { visible: v.value.includes(gt.id) }]),
                  onClick: Bt((Mt) => F(gt.id), ["stop"])
                }, null, 10, dM),
                d("span", {
                  class: "property-color",
                  style: ne({ background: pt(gt.id) })
                }, null, 4),
                d("span", fM, ct(gt.name), 1),
                gt.animated ? (H(), G("span", pM, ct(gt.keyframes.length), 1)) : xt("", !0)
              ], 8, hM),
              gt.name === "Position" || gt.name === "Scale" ? (H(), G("div", mM, [
                (H(), G(Dt, null, jt(["x", "y", "z"], (Mt) => {
                  var It;
                  return d("button", {
                    key: Mt,
                    class: wt({
                      active: (It = _.value[gt.id]) == null ? void 0 : It.includes(Mt),
                      hasValue: O(gt, Mt)
                    }),
                    onClick: (Yt) => B(gt.id, Mt)
                  }, ct(Mt.toUpperCase()), 11, gM);
                }), 64))
              ])) : xt("", !0)
            ], 2))), 128)),
            L.value.length === 0 ? (H(), G("div", vM, " No animated properties ")) : xt("", !0)
          ]),
          d("div", yM, [
            d("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: a
            }, [
              d("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: Ks
              }, null, 512)
            ], 512),
            d("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: o
            }, [
              d("canvas", {
                ref_key: "canvasRef",
                ref: i,
                onMousedown: J,
                onMousemove: V,
                onMouseup: $,
                onMouseleave: $,
                onWheel: rt,
                onContextmenu: Bt(Qt, ["prevent"])
              }, null, 544),
              k.value ? (H(), G("div", {
                key: 0,
                class: "selection-box",
                style: ne({
                  left: k.value.x + "px",
                  top: k.value.y + "px",
                  width: k.value.width + "px",
                  height: k.value.height + "px"
                })
              }, null, 4)) : xt("", !0),
              (H(), G("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${h.value} ${f.value}`
              }, [
                (H(!0), G(Dt, null, jt(Y.value, (gt) => (H(), G("g", {
                  key: gt.id,
                  class: "property-handles"
                }, [
                  (H(!0), G(Dt, null, jt(gt.keyframes, (Mt, It) => {
                    var Yt, te, Vt, Oe, kr, Tr, Mr, Or;
                    return H(), G(Dt, { key: It }, [
                      it(Mt) ? (H(), G("g", {
                        key: 0,
                        class: wt(["keyframe-marker", {
                          selected: E(gt.id, It),
                          hovered: ((Yt = C.value) == null ? void 0 : Yt.propId) === gt.id && ((te = C.value) == null ? void 0 : te.index) === It
                        }]),
                        onMousedown: Bt((ya) => bt(gt.id, It, ya), ["stop"])
                      }, [
                        d("rect", {
                          x: yt(Mt) - 5,
                          y: Q(gt, Mt) - 5,
                          width: "10",
                          height: "10",
                          fill: pt(gt.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${yt(Mt)}, ${Q(gt, Mt)})`
                        }, null, 8, xM)
                      ], 42, _M)) : xt("", !0),
                      E(gt.id, It) && Mt.interpolation === "bezier" ? (H(), G("g", wM, [
                        gt.keyframes[It + 1] ? (H(), G("g", SM, [
                          d("line", {
                            x1: yt(Mt),
                            y1: Q(gt, Mt),
                            x2: _t(gt, It),
                            y2: ht(gt, It),
                            class: "handle-line"
                          }, null, 8, CM),
                          d("circle", {
                            cx: _t(gt, It),
                            cy: ht(gt, It),
                            r: "5",
                            class: wt(["handle-point", { dragging: ((Vt = x.value) == null ? void 0 : Vt.type) === "outHandle" && ((Oe = x.value) == null ? void 0 : Oe.propId) === gt.id && ((kr = x.value) == null ? void 0 : kr.index) === It }]),
                            onMousedown: Bt((ya) => Xt("outHandle", gt.id, It), ["stop"])
                          }, null, 42, kM)
                        ])) : xt("", !0),
                        It > 0 ? (H(), G("g", TM, [
                          d("line", {
                            x1: yt(Mt),
                            y1: Q(gt, Mt),
                            x2: X(gt, It),
                            y2: kt(gt, It),
                            class: "handle-line"
                          }, null, 8, MM),
                          d("circle", {
                            cx: X(gt, It),
                            cy: kt(gt, It),
                            r: "5",
                            class: wt(["handle-point", { dragging: ((Tr = x.value) == null ? void 0 : Tr.type) === "inHandle" && ((Mr = x.value) == null ? void 0 : Mr.propId) === gt.id && ((Or = x.value) == null ? void 0 : Or.index) === It }]),
                            onMousedown: Bt((ya) => Xt("inHandle", gt.id, It), ["stop"])
                          }, null, 42, OM)
                        ])) : xt("", !0)
                      ])) : xt("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                d("line", {
                  x1: I.value,
                  y1: 0,
                  x2: I.value,
                  y2: f.value,
                  class: "current-time-line"
                }, null, 8, EM)
              ], 8, bM))
            ], 512),
            d("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: c
            }, [
              d("canvas", {
                ref_key: "valueAxisCanvas",
                ref: u
              }, null, 512)
            ], 512)
          ])
        ]),
        g.value.length > 0 ? (H(), G("div", PM, [
          d("div", DM, [
            et[11] || (et[11] = d("span", { class: "info-label" }, "Frame:", -1)),
            d("input", {
              type: "number",
              value: (dt = g.value[0]) == null ? void 0 : dt.keyframe.frame,
              onChange: va,
              class: "info-input"
            }, null, 40, AM)
          ]),
          d("div", FM, [
            et[12] || (et[12] = d("span", { class: "info-label" }, "Value:", -1)),
            d("input", {
              type: "number",
              value: at(g.value[0]),
              onChange: Sr,
              class: "info-input",
              step: "0.1"
            }, null, 40, IM)
          ]),
          d("div", LM, [
            et[14] || (et[14] = d("span", { class: "info-label" }, "Interpolation:", -1)),
            d("select", {
              value: (Tt = g.value[0]) == null ? void 0 : Tt.keyframe.interpolation,
              onChange: Os,
              class: "info-select"
            }, [...et[13] || (et[13] = [
              d("option", { value: "linear" }, "Linear", -1),
              d("option", { value: "bezier" }, "Bezier", -1),
              d("option", { value: "hold" }, "Hold", -1)
            ])], 40, RM)
          ])
        ])) : xt("", !0),
        w.value ? (H(), G("div", {
          key: 1,
          class: "context-menu",
          style: ne({ left: w.value.x + "px", top: w.value.y + "px" }),
          onClick: et[4] || (et[4] = (gt) => w.value = null)
        }, [
          d("button", { onClick: Ln }, "Add Keyframe"),
          d("button", {
            onClick: ke,
            disabled: g.value.length === 0
          }, "Delete Keyframe(s)", 8, zM),
          et[15] || (et[15] = d("hr", null, null, -1)),
          d("button", {
            onClick: pe,
            disabled: g.value.length === 0
          }, "Copy", 8, jM),
          d("button", {
            onClick: Ms,
            disabled: !T.value
          }, "Paste", 8, BM),
          et[16] || (et[16] = d("hr", null, null, -1)),
          d("button", { onClick: Ys }, "Select All"),
          d("button", { onClick: ga }, "Invert Selection")
        ], 4)) : xt("", !0)
      ]);
    };
  }
}), $M = /* @__PURE__ */ we(VM, [["__scopeId", "data-v-300cb1cd"]]), { abs: ji, cos: zn, sin: ti, acos: NM, atan2: Bi, sqrt: ds, pow: nn } = Math;
function Vi(r) {
  return r < 0 ? -nn(-r, 1 / 3) : nn(r, 1 / 3);
}
const of = Math.PI, ro = 2 * of, fs = of / 2, WM = 1e-6, Ha = Number.MAX_SAFE_INTEGER || 9007199254740991, Xa = Number.MIN_SAFE_INTEGER || -9007199254740991, UM = { x: 0, y: 0, z: 0 }, Ct = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(r, e) {
    const n = e(r);
    let s = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (s += n.z * n.z), ds(s);
  },
  compute: function(r, e, n) {
    if (r === 0)
      return e[0].t = 0, e[0];
    const s = e.length - 1;
    if (r === 1)
      return e[s].t = 1, e[s];
    const i = 1 - r;
    let o = e;
    if (s === 0)
      return e[0].t = r, e[0];
    if (s === 1) {
      const l = {
        x: i * o[0].x + r * o[1].x,
        y: i * o[0].y + r * o[1].y,
        t: r
      };
      return n && (l.z = i * o[0].z + r * o[1].z), l;
    }
    if (s < 4) {
      let l = i * i, c = r * r, u, h, f, m = 0;
      s === 2 ? (o = [o[0], o[1], o[2], UM], u = l, h = i * r * 2, f = c) : s === 3 && (u = l * i, h = l * r * 3, f = i * c * 3, m = r * c);
      const p = {
        x: u * o[0].x + h * o[1].x + f * o[2].x + m * o[3].x,
        y: u * o[0].y + h * o[1].y + f * o[2].y + m * o[3].y,
        t: r
      };
      return n && (p.z = u * o[0].z + h * o[1].z + f * o[2].z + m * o[3].z), p;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * r,
          y: a[l].y + (a[l + 1].y - a[l].y) * r
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * r);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = r, a[0];
  },
  computeWithRatios: function(r, e, n, s) {
    const i = 1 - r, o = n, a = e;
    let l = o[0], c = o[1], u = o[2], h = o[3], f;
    if (l *= i, c *= r, a.length === 2)
      return f = l + c, {
        x: (l * a[0].x + c * a[1].x) / f,
        y: (l * a[0].y + c * a[1].y) / f,
        z: s ? (l * a[0].z + c * a[1].z) / f : !1,
        t: r
      };
    if (l *= i, c *= 2 * i, u *= r * r, a.length === 3)
      return f = l + c + u, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x) / f,
        y: (l * a[0].y + c * a[1].y + u * a[2].y) / f,
        z: s ? (l * a[0].z + c * a[1].z + u * a[2].z) / f : !1,
        t: r
      };
    if (l *= i, c *= 1.5 * i, u *= 3 * i, h *= r * r * r, a.length === 4)
      return f = l + c + u + h, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x + h * a[3].x) / f,
        y: (l * a[0].y + c * a[1].y + u * a[2].y + h * a[3].y) / f,
        z: s ? (l * a[0].z + c * a[1].z + u * a[2].z + h * a[3].z) / f : !1,
        t: r
      };
  },
  derive: function(r, e) {
    const n = [];
    for (let s = r, i = s.length, o = i - 1; i > 1; i--, o--) {
      const a = [];
      for (let l = 0, c; l < o; l++)
        c = {
          x: o * (s[l + 1].x - s[l].x),
          y: o * (s[l + 1].y - s[l].y)
        }, e && (c.z = o * (s[l + 1].z - s[l].z)), a.push(c);
      n.push(a), s = a;
    }
    return n;
  },
  between: function(r, e, n) {
    return e <= r && r <= n || Ct.approximately(r, e) || Ct.approximately(r, n);
  },
  approximately: function(r, e, n) {
    return ji(r - e) <= (n || WM);
  },
  length: function(r) {
    const n = Ct.Tvalues.length;
    let s = 0;
    for (let i = 0, o; i < n; i++)
      o = 0.5 * Ct.Tvalues[i] + 0.5, s += Ct.Cvalues[i] * Ct.arcfn(o, r);
    return 0.5 * s;
  },
  map: function(r, e, n, s, i) {
    const o = n - e, a = i - s, l = r - e, c = l / o;
    return s + a * c;
  },
  lerp: function(r, e, n) {
    const s = {
      x: e.x + r * (n.x - e.x),
      y: e.y + r * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (s.z = e.z + r * (n.z - e.z)), s;
  },
  pointToString: function(r) {
    let e = r.x + "/" + r.y;
    return typeof r.z < "u" && (e += "/" + r.z), e;
  },
  pointsToString: function(r) {
    return "[" + r.map(Ct.pointToString).join(", ") + "]";
  },
  copy: function(r) {
    return JSON.parse(JSON.stringify(r));
  },
  angle: function(r, e, n) {
    const s = e.x - r.x, i = e.y - r.y, o = n.x - r.x, a = n.y - r.y, l = s * a - i * o, c = s * o + i * a;
    return Bi(l, c);
  },
  // round as string, to avoid rounding errors
  round: function(r, e) {
    const n = "" + r, s = n.indexOf(".");
    return parseFloat(n.substring(0, s + 1 + e));
  },
  dist: function(r, e) {
    const n = r.x - e.x, s = r.y - e.y;
    return ds(n * n + s * s);
  },
  closest: function(r, e) {
    let n = nn(2, 63), s, i;
    return r.forEach(function(o, a) {
      i = Ct.dist(e, o), i < n && (n = i, s = a);
    }), { mdist: n, mpos: s };
  },
  abcratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const n = nn(r, e) + nn(1 - r, e), s = n - 1;
    return ji(s / n);
  },
  projectionratio: function(r, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof r > "u")
      r = 0.5;
    else if (r === 0 || r === 1)
      return r;
    const n = nn(1 - r, e), s = nn(r, e) + n;
    return n / s;
  },
  lli8: function(r, e, n, s, i, o, a, l) {
    const c = (r * s - e * n) * (i - a) - (r - n) * (i * l - o * a), u = (r * s - e * n) * (o - l) - (e - s) * (i * l - o * a), h = (r - n) * (o - l) - (e - s) * (i - a);
    return h == 0 ? !1 : { x: c / h, y: u / h };
  },
  lli4: function(r, e, n, s) {
    const i = r.x, o = r.y, a = e.x, l = e.y, c = n.x, u = n.y, h = s.x, f = s.y;
    return Ct.lli8(i, o, a, l, c, u, h, f);
  },
  lli: function(r, e) {
    return Ct.lli4(r, r.c, e, e.c);
  },
  makeline: function(r, e) {
    return new af(
      r.x,
      r.y,
      (r.x + e.x) / 2,
      (r.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(r) {
    let e = Ha, n = Ha, s = Xa, i = Xa;
    return r.forEach(function(o) {
      const a = o.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), s < a.x.max && (s = a.x.max), i < a.y.max && (i = a.y.max);
    }), {
      x: { min: e, mid: (e + s) / 2, max: s, size: s - e },
      y: { min: n, mid: (n + i) / 2, max: i, size: i - n }
    };
  },
  shapeintersections: function(r, e, n, s, i) {
    if (!Ct.bboxoverlap(e, s)) return [];
    const o = [], a = [r.startcap, r.forward, r.back, r.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(c) {
      c.virtual || l.forEach(function(u) {
        if (u.virtual) return;
        const h = c.intersects(u, i);
        h.length > 0 && (h.c1 = c, h.c2 = u, h.s1 = r, h.s2 = n, o.push(h));
      });
    }), o;
  },
  makeshape: function(r, e, n) {
    const s = e.points.length, i = r.points.length, o = Ct.makeline(e.points[s - 1], r.points[0]), a = Ct.makeline(r.points[i - 1], e.points[0]), l = {
      startcap: o,
      forward: r,
      back: e,
      endcap: a,
      bbox: Ct.findbbox([o, r, e, a])
    };
    return l.intersections = function(c) {
      return Ct.shapeintersections(
        l,
        l.bbox,
        c,
        c.bbox,
        n
      );
    }, l;
  },
  getminmax: function(r, e, n) {
    if (!n) return { min: 0, max: 0 };
    let s = Ha, i = Xa, o, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, c = n.length; l < c; l++)
      o = n[l], a = r.get(o), a[e] < s && (s = a[e]), a[e] > i && (i = a[e]);
    return { min: s, mid: (s + i) / 2, max: i, size: i - s };
  },
  align: function(r, e) {
    const n = e.p1.x, s = e.p1.y, i = -Bi(e.p2.y - s, e.p2.x - n), o = function(a) {
      return {
        x: (a.x - n) * zn(i) - (a.y - s) * ti(i),
        y: (a.x - n) * ti(i) + (a.y - s) * zn(i)
      };
    };
    return r.map(o);
  },
  roots: function(r, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = r.length - 1, s = Ct.align(r, e), i = function(P) {
      return 0 <= P && P <= 1;
    };
    if (n === 2) {
      const P = s[0].y, z = s[1].y, j = s[2].y, ot = P - 2 * z + j;
      if (ot !== 0) {
        const vt = -ds(z * z - P * j), L = -P + z, Y = -(vt + L) / ot, M = -(-vt + L) / ot;
        return [Y, M].filter(i);
      } else if (z !== j && ot === 0)
        return [(2 * z - j) / (2 * z - 2 * j)].filter(i);
      return [];
    }
    const o = s[0].y, a = s[1].y, l = s[2].y, c = s[3].y;
    let u = -o + 3 * a - 3 * l + c, h = 3 * o - 6 * a + 3 * l, f = -3 * o + 3 * a, m = o;
    if (Ct.approximately(u, 0)) {
      if (Ct.approximately(h, 0))
        return Ct.approximately(f, 0) ? [] : [-m / f].filter(i);
      const P = ds(f * f - 4 * h * m), z = 2 * h;
      return [(P - f) / z, (-f - P) / z].filter(i);
    }
    h /= u, f /= u, m /= u;
    const p = (3 * f - h * h) / 3, y = p / 3, v = (2 * h * h * h - 9 * h * f + 27 * m) / 27, _ = v / 2, g = _ * _ + y * y * y;
    let C, x, k, w, T;
    if (g < 0) {
      const P = -p / 3, z = P * P * P, j = ds(z), ot = -v / (2 * j), vt = ot < -1 ? -1 : ot > 1 ? 1 : ot, L = NM(vt), Y = Vi(j), M = 2 * Y;
      return k = M * zn(L / 3) - h / 3, w = M * zn((L + ro) / 3) - h / 3, T = M * zn((L + 2 * ro) / 3) - h / 3, [k, w, T].filter(i);
    } else {
      if (g === 0)
        return C = _ < 0 ? Vi(-_) : -Vi(_), k = 2 * C - h / 3, w = -C - h / 3, [k, w].filter(i);
      {
        const P = ds(g);
        return C = Vi(-_ + P), x = Vi(_ + P), [C - x - h / 3].filter(i);
      }
    }
  },
  droots: function(r) {
    if (r.length === 3) {
      const e = r[0], n = r[1], s = r[2], i = e - 2 * n + s;
      if (i !== 0) {
        const o = -ds(n * n - e * s), a = -e + n, l = -(o + a) / i, c = -(-o + a) / i;
        return [l, c];
      } else if (n !== s && i === 0)
        return [(2 * n - s) / (2 * (n - s))];
      return [];
    }
    if (r.length === 2) {
      const e = r[0], n = r[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(r, e, n, s, i) {
    let o, a, l, c, u = 0, h = 0;
    const f = Ct.compute(r, e), m = Ct.compute(r, n), p = f.x * f.x + f.y * f.y;
    if (s ? (o = ds(
      nn(f.y * m.z - m.y * f.z, 2) + nn(f.z * m.x - m.z * f.x, 2) + nn(f.x * m.y - m.x * f.y, 2)
    ), a = nn(p + f.z * f.z, 3 / 2)) : (o = f.x * m.y - f.y * m.x, a = nn(p, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (u = o / a, h = a / o, !i) {
      const y = Ct.curvature(r - 1e-3, e, n, s, !0).k, v = Ct.curvature(r + 1e-3, e, n, s, !0).k;
      c = (v - u + (u - y)) / 2, l = (ji(v - u) + ji(u - y)) / 2;
    }
    return { k: u, r: h, dk: c, adk: l };
  },
  inflections: function(r) {
    if (r.length < 4) return [];
    const e = Ct.align(r, { p1: r[0], p2: r.slice(-1)[0] }), n = e[2].x * e[1].y, s = e[3].x * e[1].y, i = e[1].x * e[2].y, o = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * s + 3 * i - o), l = 18 * (3 * n - s - 3 * i), c = 18 * (i - n);
    if (Ct.approximately(a, 0)) {
      if (!Ct.approximately(l, 0)) {
        let m = -c / l;
        if (0 <= m && m <= 1) return [m];
      }
      return [];
    }
    const u = 2 * a;
    if (Ct.approximately(u, 0)) return [];
    const h = l * l - 4 * a * c;
    if (h < 0) return [];
    const f = Math.sqrt(h);
    return [(f - l) / u, -(l + f) / u].filter(function(m) {
      return 0 <= m && m <= 1;
    });
  },
  bboxoverlap: function(r, e) {
    const n = ["x", "y"], s = n.length;
    for (let i = 0, o, a, l, c; i < s; i++)
      if (o = n[i], a = r[o].mid, l = e[o].mid, c = (r[o].size + e[o].size) / 2, ji(a - l) >= c) return !1;
    return !0;
  },
  expandbox: function(r, e) {
    e.x.min < r.x.min && (r.x.min = e.x.min), e.y.min < r.y.min && (r.y.min = e.y.min), e.z && e.z.min < r.z.min && (r.z.min = e.z.min), e.x.max > r.x.max && (r.x.max = e.x.max), e.y.max > r.y.max && (r.y.max = e.y.max), e.z && e.z.max > r.z.max && (r.z.max = e.z.max), r.x.mid = (r.x.min + r.x.max) / 2, r.y.mid = (r.y.min + r.y.max) / 2, r.z && (r.z.mid = (r.z.min + r.z.max) / 2), r.x.size = r.x.max - r.x.min, r.y.size = r.y.max - r.y.min, r.z && (r.z.size = r.z.max - r.z.min);
  },
  pairiteration: function(r, e, n) {
    const s = r.bbox(), i = e.bbox(), o = 1e5, a = n || 0.5;
    if (s.x.size + s.y.size < a && i.x.size + i.y.size < a)
      return [
        (o * (r._t1 + r._t2) / 2 | 0) / o + "/" + (o * (e._t1 + e._t2) / 2 | 0) / o
      ];
    let l = r.split(0.5), c = e.split(0.5), u = [
      { left: l.left, right: c.left },
      { left: l.left, right: c.right },
      { left: l.right, right: c.right },
      { left: l.right, right: c.left }
    ];
    u = u.filter(function(f) {
      return Ct.bboxoverlap(f.left.bbox(), f.right.bbox());
    });
    let h = [];
    return u.length === 0 || (u.forEach(function(f) {
      h = h.concat(
        Ct.pairiteration(f.left, f.right, a)
      );
    }), h = h.filter(function(f, m) {
      return h.indexOf(f) === m;
    })), h;
  },
  getccenter: function(r, e, n) {
    const s = e.x - r.x, i = e.y - r.y, o = n.x - e.x, a = n.y - e.y, l = s * zn(fs) - i * ti(fs), c = s * ti(fs) + i * zn(fs), u = o * zn(fs) - a * ti(fs), h = o * ti(fs) + a * zn(fs), f = (r.x + e.x) / 2, m = (r.y + e.y) / 2, p = (e.x + n.x) / 2, y = (e.y + n.y) / 2, v = f + l, _ = m + c, g = p + u, C = y + h, x = Ct.lli8(f, m, v, _, p, y, g, C), k = Ct.dist(x, r);
    let w = Bi(r.y - x.y, r.x - x.x), T = Bi(e.y - x.y, e.x - x.x), P = Bi(n.y - x.y, n.x - x.x), z;
    return w < P ? ((w > T || T > P) && (w += ro), w > P && (z = P, P = w, w = z)) : P < T && T < w ? (z = P, P = w, w = z) : P += ro, x.s = w, x.e = P, x.r = k, x;
  },
  numberSort: function(r, e) {
    return r - e;
  }
};
class nr {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Ct.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), s = 1; s < e.length; s++)
      Ct.expandbox(n, e[s].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(s) {
      n.push(...s.offset(e));
    }), new nr(n);
  }
}
const { abs: $i, min: zu, max: ju, cos: HM, sin: XM, acos: GM, sqrt: Ni } = Math, YM = Math.PI;
let af = class me {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), s = !1;
    if (typeof n[0] == "object") {
      s = n.length;
      const p = [];
      n.forEach(function(y) {
        ["x", "y", "z"].forEach(function(v) {
          typeof y[v] < "u" && p.push(y[v]);
        });
      }), n = p;
    }
    let i = !1;
    const o = n.length;
    if (s) {
      if (s > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        i = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !i && (o === 9 || o === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let p = 0, y = a ? 3 : 2; p < o; p += y) {
      var c = {
        x: n[p],
        y: n[p + 1]
      };
      a && (c.z = n[p + 2]), l.push(c);
    }
    const u = this.order = l.length - 1, h = this.dims = ["x", "y"];
    a && h.push("z"), this.dimlen = h.length;
    const f = Ct.align(l, { p1: l[0], p2: l[u] }), m = Ct.dist(l[0], l[u]);
    this._linear = f.reduce((p, y) => p + $i(y.y), 0) < m / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, s, i) {
    if (typeof i > "u" && (i = 0.5), i === 0)
      return new me(n, n, s);
    if (i === 1)
      return new me(e, n, n);
    const o = me.getABC(2, e, n, s, i);
    return new me(e, o.A, s);
  }
  static cubicFromPoints(e, n, s, i, o) {
    typeof i > "u" && (i = 0.5);
    const a = me.getABC(3, e, n, s, i);
    typeof o > "u" && (o = Ct.dist(n, a.C));
    const l = o * (1 - i) / i, c = Ct.dist(e, s), u = (s.x - e.x) / c, h = (s.y - e.y) / c, f = o * u, m = o * h, p = l * u, y = l * h, v = { x: n.x - f, y: n.y - m }, _ = { x: n.x + p, y: n.y + y }, g = a.A, C = { x: g.x + (v.x - g.x) / (1 - i), y: g.y + (v.y - g.y) / (1 - i) }, x = { x: g.x + (_.x - g.x) / i, y: g.y + (_.y - g.y) / i }, k = { x: e.x + (C.x - e.x) / i, y: e.y + (C.y - e.y) / i }, w = {
      x: s.x + (x.x - s.x) / (1 - i),
      y: s.y + (x.y - s.y) / (1 - i)
    };
    return new me(e, k, w, s);
  }
  static getUtils() {
    return Ct;
  }
  getUtils() {
    return me.getUtils();
  }
  static get PolyBezier() {
    return nr;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Ct.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, s = e[0].y, i = ["M", n, s, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = e.length; o < a; o++)
      i.push(e[o].x), i.push(e[o].y);
    return i.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Ct.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = Ct.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return Ct.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, s, i, o = 0.5) {
    const a = Ct.projectionratio(o, e), l = 1 - a, c = {
      x: a * n.x + l * i.x,
      y: a * n.y + l * i.y
    }, u = Ct.abcratio(o, e);
    return { A: {
      x: s.x + (s.x - c.x) / u,
      y: s.y + (s.y - c.y) / u
    }, B: s, C: c, S: n, E: i };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let s = this.points[0], i = this.points[this.order];
    return me.getABC(this.order, s, n, i, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, s, i; n < e; n++)
      i = n / (e - 1), s = this.compute(i), s.t = i, this._lut.push(s);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const s = this.getLUT(), i = [];
    for (let o = 0, a, l = 0; o < s.length; o++)
      a = s[o], Ct.dist(a, e) < n && (i.push(a), l += o / s.length);
    return i.length ? t /= i.length : !1;
  }
  project(e) {
    const n = this.getLUT(), s = n.length - 1, i = Ct.closest(n, e), o = i.mpos, a = (o - 1) / s, l = (o + 1) / s, c = 0.1 / s;
    let u = i.mdist, h = a, f = h, m;
    u += 1;
    for (let p; h < l + c; h += c)
      m = this.compute(h), p = Ct.dist(e, m), p < u && (u = p, f = h);
    return f = f < 0 ? 0 : f > 1 ? 1 : f, m = this.compute(f), m.t = f, m.d = u, m;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Ct.computeWithRatios(e, this.points, this.ratios, this._3d) : Ct.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], s = e.length;
    for (let i = 1, o, a; i < s; i++)
      o = e[i], a = e[i - 1], n[i] = {
        x: (s - i) / s * o.x + i / s * a.x,
        y: (s - i) / s * o.y + i / s * a.y
      };
    return n[s] = e[s - 1], new me(n);
  }
  derivative(e) {
    return Ct.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Ct.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new me(Ct.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Ct.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Ct.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), s = Ni(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / s, y: n.x / s };
  }
  __normal3(e) {
    const n = this.derivative(e), s = this.derivative(e + 0.01), i = Ni(n.x * n.x + n.y * n.y + n.z * n.z), o = Ni(s.x * s.x + s.y * s.y + s.z * s.z);
    n.x /= i, n.y /= i, n.z /= i, s.x /= o, s.y /= o, s.z /= o;
    const a = {
      x: s.y * n.z - s.z * n.y,
      y: s.z * n.x - s.x * n.z,
      z: s.x * n.y - s.y * n.x
    }, l = Ni(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const c = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, s = [], i = [], o = 0;
    for (i[o++] = n[0], i[o++] = n[1], i[o++] = n[2], this.order === 3 && (i[o++] = n[3]); n.length > 1; ) {
      s = [];
      for (let a = 0, l, c = n.length - 1; a < c; a++)
        l = Ct.lerp(e, n[a], n[a + 1]), i[o++] = l, s.push(l);
      n = s;
    }
    return i;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const s = this.hull(e), i = {
      left: this.order === 2 ? new me([s[0], s[3], s[5]]) : new me([s[0], s[4], s[7], s[9]]),
      right: this.order === 2 ? new me([s[5], s[4], s[2]]) : new me([s[9], s[8], s[6], s[3]]),
      span: s
    };
    return i.left._t1 = Ct.map(0, 0, 1, this._t1, this._t2), i.left._t2 = Ct.map(e, 0, 1, this._t1, this._t2), i.right._t1 = Ct.map(e, 0, 1, this._t1, this._t2), i.right._t2 = Ct.map(1, 0, 1, this._t1, this._t2), n ? (n = Ct.map(n, e, 1, 0, 1), i.right.split(n).left) : i;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(s) {
        let i = function(a) {
          return a[s];
        }, o = this.dpoints[0].map(i);
        e[s] = Ct.droots(o), this.order === 3 && (o = this.dpoints[1].map(i), e[s] = e[s].concat(Ct.droots(o))), e[s] = e[s].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[s].sort(Ct.numberSort));
      }).bind(this)
    ), e.values = n.sort(Ct.numberSort).filter(function(s, i) {
      return n.indexOf(s) === i;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(s) {
        n[s] = Ct.getminmax(this, s, e[s]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), s = e.bbox();
    return Ct.bboxoverlap(n, s);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const s = this.get(e), i = this.normal(e), o = {
        c: s,
        n: i,
        x: s.x + i.x * n,
        y: s.y + i.y * n
      };
      return this._3d && (o.z = s.z + i.z * n), o;
    }
    if (this._linear) {
      const s = this.normal(0), i = this.points.map(function(o) {
        const a = {
          x: o.x + e * s.x,
          y: o.y + e * s.y
        };
        return o.z && s.z && (a.z = o.z + e * s.z), a;
      });
      return [new me(i)];
    }
    return this.reduce().map(function(s) {
      return s._linear ? s.offset(e)[0] : s.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const i = Ct.angle(this.points[0], this.points[3], this.points[1]), o = Ct.angle(this.points[0], this.points[3], this.points[2]);
      if (i > 0 && o < 0 || i < 0 && o > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let s = e.x * n.x + e.y * n.y;
    return this._3d && (s += e.z * n.z), $i(GM(s)) < YM / 3;
  }
  reduce() {
    let e, n = 0, s = 0, i = 0.01, o, a = [], l = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      s = c[e], o = this.split(n, s), o._t1 = n, o._t2 = s, a.push(o), n = s;
    return a.forEach(function(u) {
      for (n = 0, s = 0; s <= 1; )
        for (s = n + i; s <= 1 + i; s += i)
          if (o = u.split(n, s), !o.simple()) {
            if (s -= i, $i(n - s) < i)
              return [];
            o = u.split(n, s), o._t1 = Ct.map(n, 0, 1, u._t1, u._t2), o._t2 = Ct.map(s, 0, 1, u._t1, u._t2), l.push(o), n = s;
            break;
          }
      n < 1 && (o = u.split(n, 1), o._t1 = Ct.map(n, 0, 1, u._t1, u._t2), o._t2 = u._t2, l.push(o));
    }), l;
  }
  translate(e, n, s) {
    s = typeof s == "number" ? s : n;
    const i = this.order;
    let o = this.points.map((a, l) => (1 - l / i) * n + l / i * s);
    return new me(
      this.points.map((a, l) => ({
        x: a.x + e.x * o[l],
        y: a.y + e.y * o[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let s = !1;
    if (typeof e == "function" && (s = e), s && n === 2)
      return this.raise().scale(s);
    const i = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        s ? s(0) : e,
        s ? s(1) : e
      );
    const a = s ? s(0) : e, l = s ? s(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], u = [], h = Ct.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!h)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(f) {
      const m = u[f * n] = Ct.copy(o[f * n]);
      m.x += (f ? l : a) * c[f].n.x, m.y += (f ? l : a) * c[f].n.y;
    }), s ? ([0, 1].forEach(function(f) {
      if (!(n === 2 && f)) {
        var m = o[f + 1], p = {
          x: m.x - h.x,
          y: m.y - h.y
        }, y = s ? s((f + 1) / n) : e;
        s && !i && (y = -y);
        var v = Ni(p.x * p.x + p.y * p.y);
        p.x /= v, p.y /= v, u[f + 1] = {
          x: m.x + y * p.x,
          y: m.y + y * p.y
        };
      }
    }), new me(u)) : ([0, 1].forEach((f) => {
      if (n === 2 && f) return;
      const m = u[f * n], p = this.derivative(f), y = { x: m.x + p.x, y: m.y + p.y };
      u[f + 1] = Ct.lli4(m, y, h, o[f + 1]);
    }), new me(u));
  }
  outline(e, n, s, i) {
    if (n = n === void 0 ? e : n, this._linear) {
      const w = this.normal(0), T = this.points[0], P = this.points[this.points.length - 1];
      let z, j, ot;
      s === void 0 && (s = e, i = n), z = { x: T.x + w.x * e, y: T.y + w.y * e }, ot = { x: P.x + w.x * s, y: P.y + w.y * s }, j = { x: (z.x + ot.x) / 2, y: (z.y + ot.y) / 2 };
      const vt = [z, j, ot];
      z = { x: T.x - w.x * n, y: T.y - w.y * n }, ot = { x: P.x - w.x * i, y: P.y - w.y * i }, j = { x: (z.x + ot.x) / 2, y: (z.y + ot.y) / 2 };
      const L = [ot, j, z], Y = Ct.makeline(L[2], vt[0]), M = Ct.makeline(vt[2], L[0]), I = [Y, new me(vt), M, new me(L)];
      return new nr(I);
    }
    const o = this.reduce(), a = o.length, l = [];
    let c = [], u, h = 0, f = this.length();
    const m = typeof s < "u" && typeof i < "u";
    function p(w, T, P, z, j) {
      return function(ot) {
        const vt = z / P, L = (z + j) / P, Y = T - w;
        return Ct.map(ot, 0, 1, w + vt * Y, w + L * Y);
      };
    }
    o.forEach(function(w) {
      const T = w.length();
      m ? (l.push(
        w.scale(p(e, s, f, h, T))
      ), c.push(
        w.scale(p(-n, -i, f, h, T))
      )) : (l.push(w.scale(e)), c.push(w.scale(-n))), h += T;
    }), c = c.map(function(w) {
      return u = w.points, u[3] ? w.points = [u[3], u[2], u[1], u[0]] : w.points = [u[2], u[1], u[0]], w;
    }).reverse();
    const y = l[0].points[0], v = l[a - 1].points[l[a - 1].points.length - 1], _ = c[a - 1].points[c[a - 1].points.length - 1], g = c[0].points[0], C = Ct.makeline(_, y), x = Ct.makeline(v, g), k = [C].concat(l).concat([x]).concat(c);
    return new nr(k);
  }
  outlineshapes(e, n, s) {
    n = n || e;
    const i = this.outline(e, n).curves, o = [];
    for (let a = 1, l = i.length; a < l / 2; a++) {
      const c = Ct.makeshape(
        i[a],
        i[l - a],
        s
      );
      c.startcap.virtual = a > 1, c.endcap.virtual = a < l / 2 - 1, o.push(c);
    }
    return o;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof me && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = zu(e.p1.x, e.p2.x), s = zu(e.p1.y, e.p2.y), i = ju(e.p1.x, e.p2.x), o = ju(e.p1.y, e.p2.y);
    return Ct.roots(this.points, e).filter((a) => {
      var l = this.get(a);
      return Ct.between(l.x, n, i) && Ct.between(l.y, s, o);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), s = n.length - 2, i = [];
    for (let o = 0, a, l, c; o < s; o++)
      l = n.slice(o, o + 1), c = n.slice(o + 2), a = this.curveintersects(l, c, e), i.push(...a);
    return i;
  }
  curveintersects(e, n, s) {
    const i = [];
    e.forEach(function(a) {
      n.forEach(function(l) {
        a.overlaps(l) && i.push({ left: a, right: l });
      });
    });
    let o = [];
    return i.forEach(function(a) {
      const l = Ct.pairiteration(
        a.left,
        a.right,
        s
      );
      l.length > 0 && (o = o.concat(l));
    }), o;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, s, i) {
    const o = (i - s) / 4, a = this.get(s + o), l = this.get(i - o), c = Ct.dist(e, n), u = Ct.dist(e, a), h = Ct.dist(e, l);
    return $i(u - c) + $i(h - c);
  }
  _iterate(e, n) {
    let s = 0, i = 1, o;
    do {
      o = 0, i = 1;
      let a = this.get(s), l, c, u, h, f = !1, m = !1, p, y = i, v = 1;
      do
        if (m = f, h = u, y = (s + i) / 2, l = this.get(y), c = this.get(i), u = Ct.getccenter(a, l, c), u.interval = {
          start: s,
          end: i
        }, f = this._error(u, a, s, i) <= e, p = m && !f, p || (v = i), f) {
          if (i >= 1) {
            if (u.interval.end = v = 1, h = u, i > 1) {
              let g = {
                x: u.x + u.r * HM(u.e),
                y: u.y + u.r * XM(u.e)
              };
              u.e += Ct.angle({ x: u.x, y: u.y }, g, this.get(1));
            }
            break;
          }
          i = i + (i - s) / 2;
        } else
          i = y;
      while (!p && o++ < 100);
      if (o >= 100)
        break;
      h = h || u, n.push(h), s = v;
    } while (i < 1);
    return n;
  }
};
const KM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: af
}, Symbol.toStringTag, { value: "Module" })), Bu = KM;
class qM {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    Lt(this, "curve");
    Lt(this, "lut");
    Lt(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, s = this.curve.get(0);
    for (let i = 0; i <= e; i++) {
      const o = i / e, a = this.curve.get(o);
      if (i > 0) {
        const l = a.x - s.x, c = a.y - s.y;
        n += Math.sqrt(l * l + c * c);
      }
      this.lut.push({
        t: o,
        length: n
      }), s = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, s = this.lut.length - 1;
    for (; n < s; ) {
      const l = Math.floor((n + s) / 2);
      this.lut[l].length < e ? n = l + 1 : s = l;
    }
    const i = this.lut[n], o = this.lut[Math.max(0, n - 1)];
    if (i.length === o.length)
      return i.t;
    const a = (e - o.length) / (i.length - o.length);
    return o.t + a * (i.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], s = this.totalLength / (e - 1);
    for (let i = 0; i < e; i++) {
      const o = i * s;
      n.push(this.getPointAtDistance(o));
    }
    return n;
  }
}
function ZM(r) {
  if (!r || r.length < 2)
    return null;
  let e = null;
  for (const n of r) {
    const [s, ...i] = n;
    if (s === "M")
      e = { x: i[0], y: i[1] };
    else {
      if (s === "C" && e)
        return new Bu(
          e.x,
          e.y,
          i[0],
          i[1],
          // control point 1
          i[2],
          i[3],
          // control point 2
          i[4],
          i[5]
          // end point
        );
      if (s === "Q" && e)
        return new Bu(
          e.x,
          e.y,
          i[0],
          i[1],
          // control point
          i[2],
          i[3]
          // end point
        );
    }
  }
  return null;
}
class JM {
  constructor() {
    Lt(this, "offscreenCanvas", null);
    Lt(this, "ctx", null);
    Lt(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const s = Math.round(e / 8) * 8, i = Math.round(n / 8) * 8, o = Math.max(256, s), a = Math.max(256, i), l = e === o && n === a;
    return {
      valid: l,
      correctedWidth: o,
      correctedHeight: a,
      message: l ? void 0 : `Adjusted to ${o}x${a} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, s) {
    const { frameCount: i } = e.composition, { width: o, height: a } = n;
    this.offscreenCanvas = new OffscreenCanvas(o, a), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let c = 0; c < i; c++) {
      s && s({
        frame: c,
        total: i,
        percent: Math.round(c / i * 100)
      }), this.stepParticleSystemsToFrame(e, c);
      const u = await this.generateFrame(e, c, n);
      l.push(u);
    }
    return this.particleSystems.clear(), s && s({
      frame: i,
      total: i,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, s) {
    const i = this.ctx, { width: o, height: a } = s;
    if (i.fillStyle = "#FFFFFF", i.fillRect(0, 0, o, a), s.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    i.fillStyle = "#000000";
    const l = o / e.composition.width, c = a / e.composition.height, u = e.layers.filter(
      (f) => f.type === "text" && f.visible && n >= f.inPoint && n <= f.outPoint
    );
    for (const f of u)
      await this.renderTextLayerToMatte(i, f, e, n, l, c);
    const h = e.layers.filter(
      (f) => f.type === "particles" && f.visible && n >= f.inPoint && n <= f.outPoint
    );
    for (const f of h)
      this.renderParticleLayerToMatte(i, f, o, a);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, s) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== s.width || this.offscreenCanvas.height !== s.height) && (this.offscreenCanvas = new OffscreenCanvas(s.width, s.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const i = await this.generateFrame(e, n, s);
    return URL.createObjectURL(i);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, s, i, o, a) {
    const l = n.data;
    if (!l) return;
    const c = n.properties.find((f) => f.name === "fontSize"), h = (c ? ni(c, i) : l.fontSize) * Math.min(o, a);
    e.font = `${l.fontWeight} ${h}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, s, i, h, o, a) : this.renderTextBlockToMatte(e, n, l, i, h, o, a);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, s, i, o, a, l, c) {
    const u = i.layers.find((x) => x.id === s.pathLayerId);
    if (!u || u.type !== "spline") return;
    const h = u.data;
    if (!(h != null && h.controlPoints) || h.controlPoints.length < 2) return;
    const f = this.buildPathCommands(h);
    if (!f || f.length < 2) return;
    const m = ZM(f);
    if (!m) return;
    const p = new qM(m), y = n.properties.find((x) => x.name === "pathOffset"), v = y ? ni(y, o) : s.pathOffset, _ = p.totalLength;
    let g = v * _;
    const C = 4 * Math.min(l, c);
    for (const x of s.text) {
      if (x === " ") {
        const vt = e.measureText(" ").width;
        g += vt + s.letterSpacing;
        continue;
      }
      const k = e.measureText(x).width, w = Math.max(0, Math.min(g, _)), { point: T, tangent: P } = p.getPointAtDistance(w), z = Math.atan2(P.y, P.x), j = T.x * l, ot = T.y * c;
      e.save(), e.translate(j, ot), e.rotate(z), e.fillRect(
        -C,
        -a - C,
        k + C * 2,
        a + C * 2
      ), e.restore(), g += k + s.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const s = [];
    s.push(["M", n[0].x, n[0].y]);
    for (let i = 0; i < n.length - 1; i++) {
      const o = n[i], a = n[i + 1], l = o.handleOut || { x: o.x, y: o.y }, c = a.handleIn || { x: a.x, y: a.y };
      s.push([
        "C",
        l.x,
        l.y,
        c.x,
        c.y,
        a.x,
        a.y
      ]);
    }
    return s;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, s, i, o, a, l) {
    const c = n.transform.position, u = ni(c, i), h = n.transform.rotation, f = ni(h, i), m = n.transform.scale, p = ni(m, i);
    e.save(), e.translate(u.x * a, u.y * l), e.rotate(f * Math.PI / 180), e.scale(p.x, p.y);
    const v = e.measureText(s.text).width, _ = o, g = 4;
    e.fillRect(
      -g,
      -_ - g,
      v + g * 2,
      _ + g * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", s) {
    const i = (await Promise.resolve().then(() => d3)).default, o = new i();
    e.forEach((u, h) => {
      const f = `${n}_${String(h).padStart(4, "0")}.png`;
      o.file(f, u);
    });
    const a = await o.generateAsync(
      { type: "blob" },
      (u) => {
        s && s(Math.round(u.percent));
      }
    ), l = URL.createObjectURL(a), c = document.createElement("a");
    c.href = l, c.download = `${n}.zip`, document.body.appendChild(c), c.click(), document.body.removeChild(c), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (s) => s.type === "particles"
    );
    for (const s of n) {
      const i = s.data;
      if (!i) continue;
      const o = new ma(i.systemConfig);
      for (const l of i.emitters)
        o.addEmitter(l);
      for (const l of i.gravityWells)
        o.addGravityWell(l);
      for (const l of i.vortices)
        o.addVortex(l);
      for (const l of i.modulations)
        o.addModulation(l);
      const a = i.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < a; l++)
        o.step();
      this.particleSystems.set(s.id, o);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const s of e.layers) {
        if (s.type !== "particles") continue;
        const i = this.particleSystems.get(s.id);
        i && s.visible && n >= s.inPoint && n <= s.outPoint && i.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, s, i) {
    const o = this.particleSystems.get(n.id);
    if (!o) return;
    const a = o.renderToMask(s, i), l = new OffscreenCanvas(s, i);
    l.getContext("2d").putImageData(a, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const Fs = new JM(), QM = { class: "export-dialog" }, tO = { class: "dialog-header" }, eO = { class: "dialog-content" }, nO = { class: "form-group" }, sO = { class: "resolution-presets" }, iO = ["onClick"], rO = { class: "custom-resolution" }, oO = { class: "dimension-input" }, aO = { class: "dimension-input" }, lO = {
  key: 0,
  class: "dimension-warning"
}, cO = { class: "form-group" }, uO = { class: "matte-mode-options" }, hO = { class: "form-group" }, dO = { class: "preview-container" }, fO = ["src"], pO = {
  key: 1,
  class: "preview-placeholder"
}, mO = {
  key: 0,
  class: "progress-section"
}, gO = { class: "progress-bar" }, vO = { class: "progress-text" }, yO = { class: "dialog-footer" }, bO = { class: "export-info" }, _O = ["disabled"], xO = ["disabled"], wO = /* @__PURE__ */ ye({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(r, { emit: e }) {
    const n = e, s = qe(), i = Fs.getResolutionPresets(), o = ut("720p (1280x720)"), a = ut(1280), l = ut(720), c = ut(), u = ut("exclude_text"), h = ut(null), f = ut(!1), m = ut(0), p = ut(""), y = St(() => a.value), v = St(() => l.value);
    function _(k) {
      o.value = k.label, a.value = k.width, l.value = k.height, c.value = void 0;
    }
    function g() {
      const k = Fs.validateDimensions(a.value, l.value);
      if (!k.valid)
        a.value = k.correctedWidth, l.value = k.correctedHeight, c.value = k.message, o.value = "";
      else {
        c.value = void 0;
        const w = i.find(
          (T) => T.width === a.value && T.height === l.value
        );
        o.value = (w == null ? void 0 : w.label) || "";
      }
    }
    async function C() {
      if (!s.hasProject) return;
      h.value && (URL.revokeObjectURL(h.value), h.value = null);
      const k = {
        width: y.value,
        height: v.value,
        matteMode: u.value
      };
      h.value = await Fs.generatePreviewFrame(
        s.project,
        0,
        k
      );
    }
    async function x() {
      if (f.value || !s.hasProject) return;
      f.value = !0, m.value = 0, p.value = "Generating frames...";
      const k = {
        width: y.value,
        height: v.value,
        matteMode: u.value
      };
      try {
        const w = await Fs.generateMatteSequence(
          s.project,
          k,
          (T) => {
            m.value = T.percent, p.value = `Generating frame ${T.frame + 1} of ${T.total}...`;
          }
        );
        p.value = "Creating ZIP archive...", await Fs.downloadAsZip(
          w,
          `matte_${Date.now()}`,
          (T) => {
            p.value = `Compressing... ${T}%`;
          }
        ), p.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (w) {
        console.error("[ExportDialog] Export failed:", w), p.value = `Export failed: ${w instanceof Error ? w.message : "Unknown error"}`;
      } finally {
        f.value = !1;
      }
    }
    return ae(
      [y, v, u],
      () => {
        C();
      },
      { immediate: !1 }
    ), Ne(() => {
      if (s.hasProject) {
        const k = Fs.validateDimensions(s.width, s.height);
        a.value = k.correctedWidth, l.value = k.correctedHeight;
        const w = i.find(
          (T) => T.width === a.value && T.height === l.value
        );
        o.value = (w == null ? void 0 : w.label) || "", k.valid || (c.value = k.message);
      }
      C();
    }), wn(() => {
      h.value && URL.revokeObjectURL(h.value), Fs.dispose();
    }), (k, w) => (H(), G("div", {
      class: "export-dialog-overlay",
      onClick: w[6] || (w[6] = Bt((T) => n("close"), ["self"]))
    }, [
      d("div", QM, [
        d("div", tO, [
          w[8] || (w[8] = d("h3", null, "Export Matte Sequence", -1)),
          d("button", {
            class: "close-btn",
            onClick: w[0] || (w[0] = (T) => n("close"))
          }, [...w[7] || (w[7] = [
            d("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        d("div", eO, [
          d("div", nO, [
            w[13] || (w[13] = d("label", null, "Resolution", -1)),
            d("div", sO, [
              (H(!0), G(Dt, null, jt(At(i), (T) => (H(), G("button", {
                key: T.label,
                class: wt(["preset-btn", { active: o.value === T.label }]),
                onClick: (P) => _(T)
              }, ct(T.label), 11, iO))), 128))
            ]),
            d("div", rO, [
              d("div", oO, [
                w[9] || (w[9] = d("label", null, "Width", -1)),
                Wt(d("input", {
                  "onUpdate:modelValue": w[1] || (w[1] = (T) => a.value = T),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: g
                }, null, 544), [
                  [
                    ge,
                    a.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              w[11] || (w[11] = d("span", { class: "dimension-x" }, "", -1)),
              d("div", aO, [
                w[10] || (w[10] = d("label", null, "Height", -1)),
                Wt(d("input", {
                  "onUpdate:modelValue": w[2] || (w[2] = (T) => l.value = T),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: g
                }, null, 544), [
                  [
                    ge,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            c.value ? (H(), G("p", lO, [
              w[12] || (w[12] = d("i", { class: "pi pi-info-circle" }, null, -1)),
              qt(" " + ct(c.value), 1)
            ])) : xt("", !0)
          ]),
          d("div", cO, [
            w[16] || (w[16] = d("label", null, "Matte Mode", -1)),
            d("div", uO, [
              d("button", {
                class: wt(["mode-btn", { active: u.value === "exclude_text" }]),
                onClick: w[3] || (w[3] = (T) => u.value = "exclude_text")
              }, [...w[14] || (w[14] = [
                d("i", { class: "pi pi-ban" }, null, -1),
                d("span", null, "Exclude Text", -1),
                d("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              d("button", {
                class: wt(["mode-btn", { active: u.value === "include_all" }]),
                onClick: w[4] || (w[4] = (T) => u.value = "include_all")
              }, [...w[15] || (w[15] = [
                d("i", { class: "pi pi-check-circle" }, null, -1),
                d("span", null, "Include All", -1),
                d("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          d("div", hO, [
            w[18] || (w[18] = d("label", null, "Preview (Frame 0)", -1)),
            d("div", dO, [
              h.value ? (H(), G("img", {
                key: 0,
                src: h.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, fO)) : (H(), G("div", pO, [...w[17] || (w[17] = [
                d("i", { class: "pi pi-image" }, null, -1),
                d("span", null, "Generating preview...", -1)
              ])]))
            ]),
            w[19] || (w[19] = d("p", { class: "preview-info" }, [
              qt(" White = Keep original / generate content"),
              d("br"),
              qt(" Black = Exclude from generation ")
            ], -1))
          ]),
          f.value ? (H(), G("div", mO, [
            d("div", gO, [
              d("div", {
                class: "progress-fill",
                style: ne({ width: `${m.value}%` })
              }, null, 4)
            ]),
            d("p", vO, ct(p.value), 1)
          ])) : xt("", !0)
        ]),
        d("div", yO, [
          d("div", bO, [
            d("span", null, ct(At(s).frameCount) + " frames @ " + ct(y.value) + "" + ct(v.value), 1)
          ]),
          d("button", {
            class: "cancel-btn",
            onClick: w[5] || (w[5] = (T) => n("close")),
            disabled: f.value
          }, " Cancel ", 8, _O),
          d("button", {
            class: "export-btn",
            onClick: x,
            disabled: f.value || !At(s).hasProject
          }, [
            w[20] || (w[20] = d("i", { class: "pi pi-download" }, null, -1)),
            qt(" " + ct(f.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, xO)
        ])
      ])
    ]));
  }
}), SO = /* @__PURE__ */ we(wO, [["__scopeId", "data-v-34eee532"]]), CO = { class: "workspace-layout" }, kO = { class: "toolbar" }, TO = { class: "tool-group" }, MO = { class: "tool-group" }, OO = ["title"], EO = { class: "icon" }, PO = { class: "timecode-display" }, DO = { class: "tool-group" }, AO = { class: "tool-group" }, FO = ["disabled"], IO = ["disabled"], LO = { class: "workspace-content" }, RO = { class: "panel left-panel" }, zO = { class: "panel-tabs" }, jO = { class: "panel-content" }, BO = { class: "panel viewport-panel" }, VO = { class: "viewport-header" }, $O = { class: "viewport-tabs" }, NO = { class: "viewport-controls" }, WO = { class: "viewport-content" }, UO = { class: "panel timeline-panel" }, HO = { class: "panel graph-editor-panel" }, XO = {
  key: 1,
  class: "panel timeline-panel"
}, GO = { class: "panel right-panel" }, YO = { class: "panel-tabs" }, KO = { class: "panel-content" }, qO = { class: "status-bar" }, ZO = { class: "status-left" }, JO = { class: "status-item" }, QO = { class: "status-item" }, t3 = { class: "status-center" }, e3 = {
  key: 0,
  class: "render-progress"
}, n3 = { class: "status-right" }, s3 = { class: "status-item" }, i3 = { class: "status-item" }, r3 = /* @__PURE__ */ ye({
  __name: "WorkspaceLayout",
  setup(r) {
    const e = qe(), n = ut("select"), s = ut("standard"), i = ut("project"), o = ut("properties"), a = ut("composition"), l = ut("fit"), c = ut(!1), u = ut(!0), h = ut(!1), f = ut(!1), m = ut(!1), p = ut("cpu"), y = ut(null), v = ut(Sg()), _ = ut(Cg()), g = ut({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), C = St(() => {
      var ht, X;
      return ((X = (ht = e.project) == null ? void 0 : ht.composition) == null ? void 0 : X.width) || 1920;
    }), x = St(() => {
      var ht, X;
      return ((X = (ht = e.project) == null ? void 0 : ht.composition) == null ? void 0 : X.height) || 1080;
    }), k = ut(60), w = ut("0 MB"), T = ut(0), P = St(() => {
      var E, O;
      const ht = e.currentFrame, X = ((O = (E = e.project) == null ? void 0 : E.composition) == null ? void 0 : O.fps) || 30, kt = ht / X, lt = Math.floor(kt / 60), pt = Math.floor(kt % 60), it = ht % X;
      return `${String(lt).padStart(2, "0")}:${String(pt).padStart(2, "0")}:${String(it).padStart(2, "0")}`;
    }), z = St(() => {
      var ht, X;
      return ((X = (ht = e.project) == null ? void 0 : ht.meta) == null ? void 0 : X.name) || "Untitled Project";
    }), j = St(() => {
      var X;
      const ht = (X = e.project) == null ? void 0 : X.composition;
      return ht ? `${ht.width}${ht.height} @ ${ht.fps}fps` : "No Composition";
    }), ot = St(() => e.canUndo), vt = St(() => e.canRedo);
    function L() {
      m.value = !m.value, m.value ? e.play() : e.pause();
    }
    function Y() {
      e.goToStart();
    }
    function M() {
      e.goToEnd();
    }
    function I() {
      e.setFrame(e.currentFrame + 1);
    }
    function tt() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function U() {
      e.undo();
    }
    function W() {
      e.redo();
    }
    function Z(ht) {
      v.value = ht;
    }
    function yt() {
      console.log("[Weyl] Export completed");
    }
    function Q(ht) {
      var X, kt;
      if (!(((X = document.activeElement) == null ? void 0 : X.tagName) === "INPUT" || ((kt = document.activeElement) == null ? void 0 : kt.tagName) === "TEXTAREA"))
        switch (ht.key.toLowerCase()) {
          case " ":
            ht.preventDefault(), L();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            ht.ctrlKey || ht.metaKey ? (ht.preventDefault(), ht.shiftKey ? W() : U()) : n.value = "zoom";
            break;
          case "home":
            ht.preventDefault(), Y();
            break;
          case "end":
            ht.preventDefault(), M();
            break;
          case "arrowleft":
            ht.preventDefault(), tt();
            break;
          case "arrowright":
            ht.preventDefault(), I();
            break;
          case "g":
            ht.shiftKey && (h.value = !h.value);
            break;
        }
    }
    let at;
    function _t() {
      if ("memory" in performance) {
        const ht = performance.memory, X = Math.round(ht.usedJSHeapSize / 1024 / 1024);
        w.value = `${X} MB`;
      }
    }
    return Ne(async () => {
      const ht = await xg();
      p.value = ht.tier, window.addEventListener("keydown", Q), at = window.setInterval(_t, 1e3);
    }), wn(() => {
      window.removeEventListener("keydown", Q), clearInterval(at);
    }), (ht, X) => (H(), G("div", CO, [
      d("div", kO, [
        d("div", TO, [
          d("button", {
            class: wt({ active: n.value === "select" }),
            onClick: X[0] || (X[0] = (kt) => n.value = "select"),
            title: "Select (V)"
          }, [...X[20] || (X[20] = [
            d("span", { class: "icon" }, "", -1)
          ])], 2),
          d("button", {
            class: wt({ active: n.value === "pen" }),
            onClick: X[1] || (X[1] = (kt) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...X[21] || (X[21] = [
            d("span", { class: "icon" }, "", -1)
          ])], 2),
          d("button", {
            class: wt({ active: n.value === "text" }),
            onClick: X[2] || (X[2] = (kt) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...X[22] || (X[22] = [
            d("span", { class: "icon" }, "T", -1)
          ])], 2),
          d("button", {
            class: wt({ active: n.value === "hand" }),
            onClick: X[3] || (X[3] = (kt) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...X[23] || (X[23] = [
            d("span", { class: "icon" }, "", -1)
          ])], 2),
          d("button", {
            class: wt({ active: n.value === "zoom" }),
            onClick: X[4] || (X[4] = (kt) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...X[24] || (X[24] = [
            d("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        X[33] || (X[33] = d("div", { class: "divider" }, null, -1)),
        d("div", MO, [
          d("button", {
            onClick: Y,
            title: "Go to Start (Home)"
          }, [...X[25] || (X[25] = [
            d("span", { class: "icon" }, "", -1)
          ])]),
          d("button", {
            onClick: tt,
            title: "Step Backward"
          }, [...X[26] || (X[26] = [
            d("span", { class: "icon" }, "", -1)
          ])]),
          d("button", {
            onClick: L,
            title: m.value ? "Pause (Space)" : "Play (Space)"
          }, [
            d("span", EO, ct(m.value ? "" : ""), 1)
          ], 8, OO),
          d("button", {
            onClick: I,
            title: "Step Forward"
          }, [...X[27] || (X[27] = [
            d("span", { class: "icon" }, "", -1)
          ])]),
          d("button", {
            onClick: M,
            title: "Go to End (End)"
          }, [...X[28] || (X[28] = [
            d("span", { class: "icon" }, "", -1)
          ])])
        ]),
        d("div", PO, ct(P.value), 1),
        X[34] || (X[34] = d("div", { class: "divider" }, null, -1)),
        d("div", DO, [
          Wt(d("select", {
            "onUpdate:modelValue": X[5] || (X[5] = (kt) => s.value = kt),
            class: "workspace-selector"
          }, [...X[29] || (X[29] = [
            d("option", { value: "standard" }, "Standard", -1),
            d("option", { value: "animation" }, "Animation", -1),
            d("option", { value: "effects" }, "Effects", -1),
            d("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [Kn, s.value]
          ])
        ]),
        X[35] || (X[35] = d("div", { class: "spacer" }, null, -1)),
        d("div", AO, [
          d("span", {
            class: wt(["gpu-badge", p.value])
          }, ct(p.value.toUpperCase()), 3),
          d("button", {
            onClick: U,
            disabled: !ot.value,
            title: "Undo (Ctrl+Z)"
          }, [...X[30] || (X[30] = [
            d("span", { class: "icon" }, "", -1)
          ])], 8, FO),
          d("button", {
            onClick: W,
            disabled: !vt.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...X[31] || (X[31] = [
            d("span", { class: "icon" }, "", -1)
          ])], 8, IO),
          d("button", {
            onClick: X[6] || (X[6] = (kt) => f.value = !0),
            title: "Export"
          }, [...X[32] || (X[32] = [
            d("span", { class: "icon" }, "", -1),
            qt(" Export ", -1)
          ])])
        ])
      ]),
      d("div", LO, [
        Pt(At(Ea), { class: "default-theme horizontal-split" }, {
          default: un(() => [
            Pt(At(As), {
              size: 15,
              "min-size": 10,
              "max-size": 25
            }, {
              default: un(() => [
                d("div", RO, [
                  d("div", zO, [
                    d("button", {
                      class: wt({ active: i.value === "project" }),
                      onClick: X[7] || (X[7] = (kt) => i.value = "project")
                    }, " Project ", 2),
                    d("button", {
                      class: wt({ active: i.value === "effects" }),
                      onClick: X[8] || (X[8] = (kt) => i.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  d("div", jO, [
                    i.value === "project" ? (H(), ce(qg, { key: 0 })) : i.value === "effects" ? (H(), ce(Dv, { key: 1 })) : xt("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            Pt(At(As), {
              size: 60,
              "min-size": 30
            }, {
              default: un(() => [
                Pt(At(Ea), {
                  horizontal: "",
                  class: "default-theme"
                }, {
                  default: un(() => [
                    Pt(At(As), {
                      size: 65,
                      "min-size": 20
                    }, {
                      default: un(() => [
                        d("div", BO, [
                          d("div", VO, [
                            d("div", $O, [
                              d("button", {
                                class: wt({ active: a.value === "composition" }),
                                onClick: X[9] || (X[9] = (kt) => a.value = "composition")
                              }, " Composition ", 2),
                              d("button", {
                                class: wt({ active: a.value === "layer" }),
                                onClick: X[10] || (X[10] = (kt) => a.value = "layer")
                              }, " Layer ", 2),
                              d("button", {
                                class: wt({ active: a.value === "footage" }),
                                onClick: X[11] || (X[11] = (kt) => a.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            d("div", NO, [
                              Wt(d("select", {
                                "onUpdate:modelValue": X[12] || (X[12] = (kt) => l.value = kt),
                                class: "zoom-select"
                              }, [...X[36] || (X[36] = [
                                d("option", { value: "fit" }, "Fit", -1),
                                d("option", { value: "25" }, "25%", -1),
                                d("option", { value: "50" }, "50%", -1),
                                d("option", { value: "100" }, "100%", -1),
                                d("option", { value: "200" }, "200%", -1)
                              ])], 512), [
                                [Kn, l.value]
                              ]),
                              d("button", {
                                class: wt({ active: c.value }),
                                onClick: X[13] || (X[13] = (kt) => c.value = !c.value),
                                title: "Toggle Guides"
                              }, [...X[37] || (X[37] = [
                                d("span", { class: "icon" }, "", -1)
                              ])], 2),
                              d("button", {
                                class: wt({ active: u.value }),
                                onClick: X[14] || (X[14] = (kt) => u.value = !u.value),
                                title: "Toggle Grid"
                              }, [...X[38] || (X[38] = [
                                d("span", { class: "icon" }, "", -1)
                              ])], 2)
                            ])
                          ]),
                          d("div", WO, [
                            a.value === "composition" ? (H(), ce(HS, {
                              key: 0,
                              camera: v.value,
                              viewportState: _.value,
                              viewOptions: g.value,
                              compWidth: C.value,
                              compHeight: x.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"])) : (H(), ce(o5, {
                              key: 1,
                              ref_key: "canvasRef",
                              ref: y
                            }, null, 512))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    Pt(At(As), {
                      size: 35,
                      "min-size": 15
                    }, {
                      default: un(() => [
                        h.value ? (H(), ce(At(Ea), {
                          key: 0,
                          horizontal: "",
                          class: "default-theme"
                        }, {
                          default: un(() => [
                            Pt(At(As), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: un(() => [
                                d("div", UO, [
                                  Pt(Ru)
                                ])
                              ]),
                              _: 1
                            }),
                            Pt(At(As), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: un(() => [
                                d("div", HO, [
                                  Pt($M, {
                                    onClose: X[15] || (X[15] = (kt) => h.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : (H(), G("div", XO, [
                          Pt(Ru)
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            Pt(At(As), {
              size: 25,
              "min-size": 15,
              "max-size": 30
            }, {
              default: un(() => [
                d("div", GO, [
                  d("div", YO, [
                    d("button", {
                      class: wt({ active: o.value === "properties" }),
                      onClick: X[16] || (X[16] = (kt) => o.value = "properties")
                    }, " Properties ", 2),
                    d("button", {
                      class: wt({ active: o.value === "camera" }),
                      onClick: X[17] || (X[17] = (kt) => o.value = "camera")
                    }, " Camera ", 2),
                    d("button", {
                      class: wt({ active: o.value === "audio" }),
                      onClick: X[18] || (X[18] = (kt) => o.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  d("div", KO, [
                    o.value === "properties" ? (H(), ce(_w, { key: 0 })) : o.value === "camera" ? (H(), ce(z2, {
                      key: 1,
                      camera: v.value,
                      "onUpdate:camera": Z
                    }, null, 8, ["camera"])) : o.value === "audio" ? (H(), ce(SS, { key: 2 })) : xt("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      d("div", qO, [
        d("div", ZO, [
          d("span", JO, ct(z.value), 1),
          X[39] || (X[39] = d("span", { class: "status-divider" }, "|", -1)),
          d("span", QO, ct(j.value), 1)
        ]),
        d("div", t3, [
          T.value > 0 ? (H(), G("span", e3, " Rendering: " + ct(Math.round(T.value * 100)) + "% ", 1)) : xt("", !0)
        ]),
        d("div", n3, [
          d("span", s3, ct(w.value), 1),
          X[40] || (X[40] = d("span", { class: "status-divider" }, "|", -1)),
          d("span", i3, ct(k.value) + " fps", 1)
        ])
      ]),
      f.value ? (H(), ce(SO, {
        key: 0,
        onClose: X[19] || (X[19] = (kt) => f.value = !1),
        onExported: yt
      })) : xt("", !0)
    ]));
  }
}), o3 = /* @__PURE__ */ we(r3, [["__scopeId", "data-v-d94e9539"]]), a3 = /* @__PURE__ */ ye({
  __name: "App",
  setup(r) {
    return (e, n) => (H(), ce(o3));
  }
});
let lf = null;
function Vu(r) {
  let e = null;
  if (typeof r == "string" ? e = document.getElementById(r) || document.querySelector(r) : r instanceof HTMLElement ? e = r : e = document.getElementById("weyl-compositor-root") || document.getElementById("app"), !e) return null;
  const n = $m(a3);
  return n.use(Um()), n.mount(e), lf = n, l3(), n;
}
function l3() {
  window.addEventListener("weyl:inputs-ready", (r) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: r.detail }));
  });
}
async function p3(r, e) {
  var n, s;
  return ((s = (n = window.WeylCompositor) == null ? void 0 : n.sendOutput) == null ? void 0 : s.call(n, r, e)) ?? !1;
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => Vu()) : setTimeout(() => {
  lf || Vu();
}, 0);
var oo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function c3(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function ao(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var cf = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(r, e) {
  (function(n) {
    r.exports = n();
  })(function() {
    return function n(s, i, o) {
      function a(u, h) {
        if (!i[u]) {
          if (!s[u]) {
            var f = typeof ao == "function" && ao;
            if (!h && f) return f(u, !0);
            if (l) return l(u, !0);
            var m = new Error("Cannot find module '" + u + "'");
            throw m.code = "MODULE_NOT_FOUND", m;
          }
          var p = i[u] = { exports: {} };
          s[u][0].call(p.exports, function(y) {
            var v = s[u][1][y];
            return a(v || y);
          }, p, p.exports, n, s, i, o);
        }
        return i[u].exports;
      }
      for (var l = typeof ao == "function" && ao, c = 0; c < o.length; c++) a(o[c]);
      return a;
    }({ 1: [function(n, s, i) {
      var o = n("./utils"), a = n("./support"), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      i.encode = function(c) {
        for (var u, h, f, m, p, y, v, _ = [], g = 0, C = c.length, x = C, k = o.getTypeOf(c) !== "string"; g < c.length; ) x = C - g, f = k ? (u = c[g++], h = g < C ? c[g++] : 0, g < C ? c[g++] : 0) : (u = c.charCodeAt(g++), h = g < C ? c.charCodeAt(g++) : 0, g < C ? c.charCodeAt(g++) : 0), m = u >> 2, p = (3 & u) << 4 | h >> 4, y = 1 < x ? (15 & h) << 2 | f >> 6 : 64, v = 2 < x ? 63 & f : 64, _.push(l.charAt(m) + l.charAt(p) + l.charAt(y) + l.charAt(v));
        return _.join("");
      }, i.decode = function(c) {
        var u, h, f, m, p, y, v = 0, _ = 0, g = "data:";
        if (c.substr(0, g.length) === g) throw new Error("Invalid base64 input, it looks like a data url.");
        var C, x = 3 * (c = c.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (c.charAt(c.length - 1) === l.charAt(64) && x--, c.charAt(c.length - 2) === l.charAt(64) && x--, x % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (C = a.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); v < c.length; ) u = l.indexOf(c.charAt(v++)) << 2 | (m = l.indexOf(c.charAt(v++))) >> 4, h = (15 & m) << 4 | (p = l.indexOf(c.charAt(v++))) >> 2, f = (3 & p) << 6 | (y = l.indexOf(c.charAt(v++))), C[_++] = u, p !== 64 && (C[_++] = h), y !== 64 && (C[_++] = f);
        return C;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(n, s, i) {
      var o = n("./external"), a = n("./stream/DataWorker"), l = n("./stream/Crc32Probe"), c = n("./stream/DataLengthProbe");
      function u(h, f, m, p, y) {
        this.compressedSize = h, this.uncompressedSize = f, this.crc32 = m, this.compression = p, this.compressedContent = y;
      }
      u.prototype = { getContentWorker: function() {
        var h = new a(o.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new c("data_length")), f = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== f.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new a(o.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, u.createWorkerFrom = function(h, f, m) {
        return h.pipe(new l()).pipe(new c("uncompressedSize")).pipe(f.compressWorker(m)).pipe(new c("compressedSize")).withStreamInfo("compression", f);
      }, s.exports = u;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(n, s, i) {
      var o = n("./stream/GenericWorker");
      i.STORE = { magic: "\0\0", compressWorker: function() {
        return new o("STORE compression");
      }, uncompressWorker: function() {
        return new o("STORE decompression");
      } }, i.DEFLATE = n("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(n, s, i) {
      var o = n("./utils"), a = function() {
        for (var l, c = [], u = 0; u < 256; u++) {
          l = u;
          for (var h = 0; h < 8; h++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          c[u] = l;
        }
        return c;
      }();
      s.exports = function(l, c) {
        return l !== void 0 && l.length ? o.getTypeOf(l) !== "string" ? function(u, h, f, m) {
          var p = a, y = m + f;
          u ^= -1;
          for (var v = m; v < y; v++) u = u >>> 8 ^ p[255 & (u ^ h[v])];
          return -1 ^ u;
        }(0 | c, l, l.length, 0) : function(u, h, f, m) {
          var p = a, y = m + f;
          u ^= -1;
          for (var v = m; v < y; v++) u = u >>> 8 ^ p[255 & (u ^ h.charCodeAt(v))];
          return -1 ^ u;
        }(0 | c, l, l.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(n, s, i) {
      i.base64 = !1, i.binary = !1, i.dir = !1, i.createFolders = !0, i.date = null, i.compression = null, i.compressionOptions = null, i.comment = null, i.unixPermissions = null, i.dosPermissions = null;
    }, {}], 6: [function(n, s, i) {
      var o = null;
      o = typeof Promise < "u" ? Promise : n("lie"), s.exports = { Promise: o };
    }, { lie: 37 }], 7: [function(n, s, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", a = n("pako"), l = n("./utils"), c = n("./stream/GenericWorker"), u = o ? "uint8array" : "array";
      function h(f, m) {
        c.call(this, "FlateWorker/" + f), this._pako = null, this._pakoAction = f, this._pakoOptions = m, this.meta = {};
      }
      i.magic = "\b\0", l.inherits(h, c), h.prototype.processChunk = function(f) {
        this.meta = f.meta, this._pako === null && this._createPako(), this._pako.push(l.transformTo(u, f.data), !1);
      }, h.prototype.flush = function() {
        c.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        c.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new a[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var f = this;
        this._pako.onData = function(m) {
          f.push({ data: m, meta: f.meta });
        };
      }, i.compressWorker = function(f) {
        return new h("Deflate", f);
      }, i.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(n, s, i) {
      function o(p, y) {
        var v, _ = "";
        for (v = 0; v < y; v++) _ += String.fromCharCode(255 & p), p >>>= 8;
        return _;
      }
      function a(p, y, v, _, g, C) {
        var x, k, w = p.file, T = p.compression, P = C !== u.utf8encode, z = l.transformTo("string", C(w.name)), j = l.transformTo("string", u.utf8encode(w.name)), ot = w.comment, vt = l.transformTo("string", C(ot)), L = l.transformTo("string", u.utf8encode(ot)), Y = j.length !== w.name.length, M = L.length !== ot.length, I = "", tt = "", U = "", W = w.dir, Z = w.date, yt = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        y && !v || (yt.crc32 = p.crc32, yt.compressedSize = p.compressedSize, yt.uncompressedSize = p.uncompressedSize);
        var Q = 0;
        y && (Q |= 8), P || !Y && !M || (Q |= 2048);
        var at = 0, _t = 0;
        W && (at |= 16), g === "UNIX" ? (_t = 798, at |= function(X, kt) {
          var lt = X;
          return X || (lt = kt ? 16893 : 33204), (65535 & lt) << 16;
        }(w.unixPermissions, W)) : (_t = 20, at |= function(X) {
          return 63 & (X || 0);
        }(w.dosPermissions)), x = Z.getUTCHours(), x <<= 6, x |= Z.getUTCMinutes(), x <<= 5, x |= Z.getUTCSeconds() / 2, k = Z.getUTCFullYear() - 1980, k <<= 4, k |= Z.getUTCMonth() + 1, k <<= 5, k |= Z.getUTCDate(), Y && (tt = o(1, 1) + o(h(z), 4) + j, I += "up" + o(tt.length, 2) + tt), M && (U = o(1, 1) + o(h(vt), 4) + L, I += "uc" + o(U.length, 2) + U);
        var ht = "";
        return ht += `
\0`, ht += o(Q, 2), ht += T.magic, ht += o(x, 2), ht += o(k, 2), ht += o(yt.crc32, 4), ht += o(yt.compressedSize, 4), ht += o(yt.uncompressedSize, 4), ht += o(z.length, 2), ht += o(I.length, 2), { fileRecord: f.LOCAL_FILE_HEADER + ht + z + I, dirRecord: f.CENTRAL_FILE_HEADER + o(_t, 2) + ht + o(vt.length, 2) + "\0\0\0\0" + o(at, 4) + o(_, 4) + z + I + vt };
      }
      var l = n("../utils"), c = n("../stream/GenericWorker"), u = n("../utf8"), h = n("../crc32"), f = n("../signature");
      function m(p, y, v, _) {
        c.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = y, this.zipPlatform = v, this.encodeFileName = _, this.streamFiles = p, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      l.inherits(m, c), m.prototype.push = function(p) {
        var y = p.meta.percent || 0, v = this.entriesCount, _ = this._sources.length;
        this.accumulate ? this.contentBuffer.push(p) : (this.bytesWritten += p.data.length, c.prototype.push.call(this, { data: p.data, meta: { currentFile: this.currentFile, percent: v ? (y + 100 * (v - _ - 1)) / v : 100 } }));
      }, m.prototype.openedSource = function(p) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = p.file.name;
        var y = this.streamFiles && !p.file.dir;
        if (y) {
          var v = a(p, y, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: v.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, m.prototype.closedSource = function(p) {
        this.accumulate = !1;
        var y = this.streamFiles && !p.file.dir, v = a(p, y, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(v.dirRecord), y) this.push({ data: function(_) {
          return f.DATA_DESCRIPTOR + o(_.crc32, 4) + o(_.compressedSize, 4) + o(_.uncompressedSize, 4);
        }(p), meta: { percent: 100 } });
        else for (this.push({ data: v.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, m.prototype.flush = function() {
        for (var p = this.bytesWritten, y = 0; y < this.dirRecords.length; y++) this.push({ data: this.dirRecords[y], meta: { percent: 100 } });
        var v = this.bytesWritten - p, _ = function(g, C, x, k, w) {
          var T = l.transformTo("string", w(k));
          return f.CENTRAL_DIRECTORY_END + "\0\0\0\0" + o(g, 2) + o(g, 2) + o(C, 4) + o(x, 4) + o(T.length, 2) + T;
        }(this.dirRecords.length, v, p, this.zipComment, this.encodeFileName);
        this.push({ data: _, meta: { percent: 100 } });
      }, m.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, m.prototype.registerPrevious = function(p) {
        this._sources.push(p);
        var y = this;
        return p.on("data", function(v) {
          y.processChunk(v);
        }), p.on("end", function() {
          y.closedSource(y.previous.streamInfo), y._sources.length ? y.prepareNextSource() : y.end();
        }), p.on("error", function(v) {
          y.error(v);
        }), this;
      }, m.prototype.resume = function() {
        return !!c.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, m.prototype.error = function(p) {
        var y = this._sources;
        if (!c.prototype.error.call(this, p)) return !1;
        for (var v = 0; v < y.length; v++) try {
          y[v].error(p);
        } catch {
        }
        return !0;
      }, m.prototype.lock = function() {
        c.prototype.lock.call(this);
        for (var p = this._sources, y = 0; y < p.length; y++) p[y].lock();
      }, s.exports = m;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(n, s, i) {
      var o = n("../compressions"), a = n("./ZipFileWorker");
      i.generateWorker = function(l, c, u) {
        var h = new a(c.streamFiles, u, c.platform, c.encodeFileName), f = 0;
        try {
          l.forEach(function(m, p) {
            f++;
            var y = function(C, x) {
              var k = C || x, w = o[k];
              if (!w) throw new Error(k + " is not a valid compression method !");
              return w;
            }(p.options.compression, c.compression), v = p.options.compressionOptions || c.compressionOptions || {}, _ = p.dir, g = p.date;
            p._compressWorker(y, v).withStreamInfo("file", { name: m, dir: _, date: g, comment: p.comment || "", unixPermissions: p.unixPermissions, dosPermissions: p.dosPermissions }).pipe(h);
          }), h.entriesCount = f;
        } catch (m) {
          h.error(m);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(n, s, i) {
      function o() {
        if (!(this instanceof o)) return new o();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var a = new o();
          for (var l in this) typeof this[l] != "function" && (a[l] = this[l]);
          return a;
        };
      }
      (o.prototype = n("./object")).loadAsync = n("./load"), o.support = n("./support"), o.defaults = n("./defaults"), o.version = "3.10.1", o.loadAsync = function(a, l) {
        return new o().loadAsync(a, l);
      }, o.external = n("./external"), s.exports = o;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(n, s, i) {
      var o = n("./utils"), a = n("./external"), l = n("./utf8"), c = n("./zipEntries"), u = n("./stream/Crc32Probe"), h = n("./nodejsUtils");
      function f(m) {
        return new a.Promise(function(p, y) {
          var v = m.decompressed.getContentWorker().pipe(new u());
          v.on("error", function(_) {
            y(_);
          }).on("end", function() {
            v.streamInfo.crc32 !== m.decompressed.crc32 ? y(new Error("Corrupted zip : CRC32 mismatch")) : p();
          }).resume();
        });
      }
      s.exports = function(m, p) {
        var y = this;
        return p = o.extend(p || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: l.utf8decode }), h.isNode && h.isStream(m) ? a.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : o.prepareContent("the loaded zip file", m, !0, p.optimizedBinaryString, p.base64).then(function(v) {
          var _ = new c(p);
          return _.load(v), _;
        }).then(function(v) {
          var _ = [a.Promise.resolve(v)], g = v.files;
          if (p.checkCRC32) for (var C = 0; C < g.length; C++) _.push(f(g[C]));
          return a.Promise.all(_);
        }).then(function(v) {
          for (var _ = v.shift(), g = _.files, C = 0; C < g.length; C++) {
            var x = g[C], k = x.fileNameStr, w = o.resolve(x.fileNameStr);
            y.file(w, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: p.createFolders }), x.dir || (y.file(w).unsafeOriginalName = k);
          }
          return _.zipComment.length && (y.comment = _.zipComment), y;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(n, s, i) {
      var o = n("../utils"), a = n("../stream/GenericWorker");
      function l(c, u) {
        a.call(this, "Nodejs stream input adapter for " + c), this._upstreamEnded = !1, this._bindStream(u);
      }
      o.inherits(l, a), l.prototype._bindStream = function(c) {
        var u = this;
        (this._stream = c).pause(), c.on("data", function(h) {
          u.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          u.isPaused ? this.generatedError = h : u.error(h);
        }).on("end", function() {
          u.isPaused ? u._upstreamEnded = !0 : u.end();
        });
      }, l.prototype.pause = function() {
        return !!a.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, l.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, s.exports = l;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(n, s, i) {
      var o = n("readable-stream").Readable;
      function a(l, c, u) {
        o.call(this, c), this._helper = l;
        var h = this;
        l.on("data", function(f, m) {
          h.push(f) || h._helper.pause(), u && u(m);
        }).on("error", function(f) {
          h.emit("error", f);
        }).on("end", function() {
          h.push(null);
        });
      }
      n("../utils").inherits(a, o), a.prototype._read = function() {
        this._helper.resume();
      }, s.exports = a;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(n, s, i) {
      s.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(o, a) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(o, a);
        if (typeof o == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(o, a);
      }, allocBuffer: function(o) {
        if (Buffer.alloc) return Buffer.alloc(o);
        var a = new Buffer(o);
        return a.fill(0), a;
      }, isBuffer: function(o) {
        return Buffer.isBuffer(o);
      }, isStream: function(o) {
        return o && typeof o.on == "function" && typeof o.pause == "function" && typeof o.resume == "function";
      } };
    }, {}], 15: [function(n, s, i) {
      function o(w, T, P) {
        var z, j = l.getTypeOf(T), ot = l.extend(P || {}, h);
        ot.date = ot.date || /* @__PURE__ */ new Date(), ot.compression !== null && (ot.compression = ot.compression.toUpperCase()), typeof ot.unixPermissions == "string" && (ot.unixPermissions = parseInt(ot.unixPermissions, 8)), ot.unixPermissions && 16384 & ot.unixPermissions && (ot.dir = !0), ot.dosPermissions && 16 & ot.dosPermissions && (ot.dir = !0), ot.dir && (w = g(w)), ot.createFolders && (z = _(w)) && C.call(this, z, !0);
        var vt = j === "string" && ot.binary === !1 && ot.base64 === !1;
        P && P.binary !== void 0 || (ot.binary = !vt), (T instanceof f && T.uncompressedSize === 0 || ot.dir || !T || T.length === 0) && (ot.base64 = !1, ot.binary = !0, T = "", ot.compression = "STORE", j = "string");
        var L = null;
        L = T instanceof f || T instanceof c ? T : y.isNode && y.isStream(T) ? new v(w, T) : l.prepareContent(w, T, ot.binary, ot.optimizedBinaryString, ot.base64);
        var Y = new m(w, L, ot);
        this.files[w] = Y;
      }
      var a = n("./utf8"), l = n("./utils"), c = n("./stream/GenericWorker"), u = n("./stream/StreamHelper"), h = n("./defaults"), f = n("./compressedObject"), m = n("./zipObject"), p = n("./generate"), y = n("./nodejsUtils"), v = n("./nodejs/NodejsStreamInputAdapter"), _ = function(w) {
        w.slice(-1) === "/" && (w = w.substring(0, w.length - 1));
        var T = w.lastIndexOf("/");
        return 0 < T ? w.substring(0, T) : "";
      }, g = function(w) {
        return w.slice(-1) !== "/" && (w += "/"), w;
      }, C = function(w, T) {
        return T = T !== void 0 ? T : h.createFolders, w = g(w), this.files[w] || o.call(this, w, null, { dir: !0, createFolders: T }), this.files[w];
      };
      function x(w) {
        return Object.prototype.toString.call(w) === "[object RegExp]";
      }
      var k = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(w) {
        var T, P, z;
        for (T in this.files) z = this.files[T], (P = T.slice(this.root.length, T.length)) && T.slice(0, this.root.length) === this.root && w(P, z);
      }, filter: function(w) {
        var T = [];
        return this.forEach(function(P, z) {
          w(P, z) && T.push(z);
        }), T;
      }, file: function(w, T, P) {
        if (arguments.length !== 1) return w = this.root + w, o.call(this, w, T, P), this;
        if (x(w)) {
          var z = w;
          return this.filter(function(ot, vt) {
            return !vt.dir && z.test(ot);
          });
        }
        var j = this.files[this.root + w];
        return j && !j.dir ? j : null;
      }, folder: function(w) {
        if (!w) return this;
        if (x(w)) return this.filter(function(j, ot) {
          return ot.dir && w.test(j);
        });
        var T = this.root + w, P = C.call(this, T), z = this.clone();
        return z.root = P.name, z;
      }, remove: function(w) {
        w = this.root + w;
        var T = this.files[w];
        if (T || (w.slice(-1) !== "/" && (w += "/"), T = this.files[w]), T && !T.dir) delete this.files[w];
        else for (var P = this.filter(function(j, ot) {
          return ot.name.slice(0, w.length) === w;
        }), z = 0; z < P.length; z++) delete this.files[P[z].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(w) {
        var T, P = {};
        try {
          if ((P = l.extend(w || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: a.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type) throw new Error("No output type specified.");
          l.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var z = P.comment || this.comment || "";
          T = p.generateWorker(this, P, z);
        } catch (j) {
          (T = new c("error")).error(j);
        }
        return new u(T, P.type || "string", P.mimeType);
      }, generateAsync: function(w, T) {
        return this.generateInternalStream(w).accumulate(T);
      }, generateNodeStream: function(w, T) {
        return (w = w || {}).type || (w.type = "nodebuffer"), this.generateInternalStream(w).toNodejsStream(T);
      } };
      s.exports = k;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(n, s, i) {
      s.exports = n("stream");
    }, { stream: void 0 }], 17: [function(n, s, i) {
      var o = n("./DataReader");
      function a(l) {
        o.call(this, l);
        for (var c = 0; c < this.data.length; c++) l[c] = 255 & l[c];
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(l) {
        return this.data[this.zero + l];
      }, a.prototype.lastIndexOfSignature = function(l) {
        for (var c = l.charCodeAt(0), u = l.charCodeAt(1), h = l.charCodeAt(2), f = l.charCodeAt(3), m = this.length - 4; 0 <= m; --m) if (this.data[m] === c && this.data[m + 1] === u && this.data[m + 2] === h && this.data[m + 3] === f) return m - this.zero;
        return -1;
      }, a.prototype.readAndCheckSignature = function(l) {
        var c = l.charCodeAt(0), u = l.charCodeAt(1), h = l.charCodeAt(2), f = l.charCodeAt(3), m = this.readData(4);
        return c === m[0] && u === m[1] && h === m[2] && f === m[3];
      }, a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0) return [];
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, c;
      }, s.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(n, s, i) {
      var o = n("../utils");
      function a(l) {
        this.data = l, this.length = l.length, this.index = 0, this.zero = 0;
      }
      a.prototype = { checkOffset: function(l) {
        this.checkIndex(this.index + l);
      }, checkIndex: function(l) {
        if (this.length < this.zero + l || l < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + l + "). Corrupted zip ?");
      }, setIndex: function(l) {
        this.checkIndex(l), this.index = l;
      }, skip: function(l) {
        this.setIndex(this.index + l);
      }, byteAt: function() {
      }, readInt: function(l) {
        var c, u = 0;
        for (this.checkOffset(l), c = this.index + l - 1; c >= this.index; c--) u = (u << 8) + this.byteAt(c);
        return this.index += l, u;
      }, readString: function(l) {
        return o.transformTo("string", this.readData(l));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var l = this.readInt(4);
        return new Date(Date.UTC(1980 + (l >> 25 & 127), (l >> 21 & 15) - 1, l >> 16 & 31, l >> 11 & 31, l >> 5 & 63, (31 & l) << 1));
      } }, s.exports = a;
    }, { "../utils": 32 }], 19: [function(n, s, i) {
      var o = n("./Uint8ArrayReader");
      function a(l) {
        o.call(this, l);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(l) {
        this.checkOffset(l);
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, c;
      }, s.exports = a;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(n, s, i) {
      var o = n("./DataReader");
      function a(l) {
        o.call(this, l);
      }
      n("../utils").inherits(a, o), a.prototype.byteAt = function(l) {
        return this.data.charCodeAt(this.zero + l);
      }, a.prototype.lastIndexOfSignature = function(l) {
        return this.data.lastIndexOf(l) - this.zero;
      }, a.prototype.readAndCheckSignature = function(l) {
        return l === this.readData(4);
      }, a.prototype.readData = function(l) {
        this.checkOffset(l);
        var c = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, c;
      }, s.exports = a;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(n, s, i) {
      var o = n("./ArrayReader");
      function a(l) {
        o.call(this, l);
      }
      n("../utils").inherits(a, o), a.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0) return new Uint8Array(0);
        var c = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, c;
      }, s.exports = a;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(n, s, i) {
      var o = n("../utils"), a = n("../support"), l = n("./ArrayReader"), c = n("./StringReader"), u = n("./NodeBufferReader"), h = n("./Uint8ArrayReader");
      s.exports = function(f) {
        var m = o.getTypeOf(f);
        return o.checkSupport(m), m !== "string" || a.uint8array ? m === "nodebuffer" ? new u(f) : a.uint8array ? new h(o.transformTo("uint8array", f)) : new l(o.transformTo("array", f)) : new c(f);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(n, s, i) {
      i.LOCAL_FILE_HEADER = "PK", i.CENTRAL_FILE_HEADER = "PK", i.CENTRAL_DIRECTORY_END = "PK", i.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", i.ZIP64_CENTRAL_DIRECTORY_END = "PK", i.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(n, s, i) {
      var o = n("./GenericWorker"), a = n("../utils");
      function l(c) {
        o.call(this, "ConvertWorker to " + c), this.destType = c;
      }
      a.inherits(l, o), l.prototype.processChunk = function(c) {
        this.push({ data: a.transformTo(this.destType, c.data), meta: c.meta });
      }, s.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(n, s, i) {
      var o = n("./GenericWorker"), a = n("../crc32");
      function l() {
        o.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      n("../utils").inherits(l, o), l.prototype.processChunk = function(c) {
        this.streamInfo.crc32 = a(c.data, this.streamInfo.crc32 || 0), this.push(c);
      }, s.exports = l;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(n, s, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function l(c) {
        a.call(this, "DataLengthProbe for " + c), this.propName = c, this.withStreamInfo(c, 0);
      }
      o.inherits(l, a), l.prototype.processChunk = function(c) {
        if (c) {
          var u = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = u + c.data.length;
        }
        a.prototype.processChunk.call(this, c);
      }, s.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(n, s, i) {
      var o = n("../utils"), a = n("./GenericWorker");
      function l(c) {
        a.call(this, "DataWorker");
        var u = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, c.then(function(h) {
          u.dataIsReady = !0, u.data = h, u.max = h && h.length || 0, u.type = o.getTypeOf(h), u.isPaused || u._tickAndRepeat();
        }, function(h) {
          u.error(h);
        });
      }
      o.inherits(l, a), l.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this.data = null;
      }, l.prototype.resume = function() {
        return !!a.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, o.delay(this._tickAndRepeat, [], this)), !0);
      }, l.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (o.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, l.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var c = null, u = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            c = this.data.substring(this.index, u);
            break;
          case "uint8array":
            c = this.data.subarray(this.index, u);
            break;
          case "array":
          case "nodebuffer":
            c = this.data.slice(this.index, u);
        }
        return this.index = u, this.push({ data: c, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, s.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(n, s, i) {
      function o(a) {
        this.name = a || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      o.prototype = { push: function(a) {
        this.emit("data", a);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (a) {
          this.emit("error", a);
        }
        return !0;
      }, error: function(a) {
        return !this.isFinished && (this.isPaused ? this.generatedError = a : (this.isFinished = !0, this.emit("error", a), this.previous && this.previous.error(a), this.cleanUp()), !0);
      }, on: function(a, l) {
        return this._listeners[a].push(l), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(a, l) {
        if (this._listeners[a]) for (var c = 0; c < this._listeners[a].length; c++) this._listeners[a][c].call(this, l);
      }, pipe: function(a) {
        return a.registerPrevious(this);
      }, registerPrevious: function(a) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = a.streamInfo, this.mergeStreamInfo(), this.previous = a;
        var l = this;
        return a.on("data", function(c) {
          l.processChunk(c);
        }), a.on("end", function() {
          l.end();
        }), a.on("error", function(c) {
          l.error(c);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var a = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), a = !0), this.previous && this.previous.resume(), !a;
      }, flush: function() {
      }, processChunk: function(a) {
        this.push(a);
      }, withStreamInfo: function(a, l) {
        return this.extraStreamInfo[a] = l, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var a in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, a) && (this.streamInfo[a] = this.extraStreamInfo[a]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var a = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + a : a;
      } }, s.exports = o;
    }, {}], 29: [function(n, s, i) {
      var o = n("../utils"), a = n("./ConvertWorker"), l = n("./GenericWorker"), c = n("../base64"), u = n("../support"), h = n("../external"), f = null;
      if (u.nodestream) try {
        f = n("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function m(y, v) {
        return new h.Promise(function(_, g) {
          var C = [], x = y._internalType, k = y._outputType, w = y._mimeType;
          y.on("data", function(T, P) {
            C.push(T), v && v(P);
          }).on("error", function(T) {
            C = [], g(T);
          }).on("end", function() {
            try {
              var T = function(P, z, j) {
                switch (P) {
                  case "blob":
                    return o.newBlob(o.transformTo("arraybuffer", z), j);
                  case "base64":
                    return c.encode(z);
                  default:
                    return o.transformTo(P, z);
                }
              }(k, function(P, z) {
                var j, ot = 0, vt = null, L = 0;
                for (j = 0; j < z.length; j++) L += z[j].length;
                switch (P) {
                  case "string":
                    return z.join("");
                  case "array":
                    return Array.prototype.concat.apply([], z);
                  case "uint8array":
                    for (vt = new Uint8Array(L), j = 0; j < z.length; j++) vt.set(z[j], ot), ot += z[j].length;
                    return vt;
                  case "nodebuffer":
                    return Buffer.concat(z);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(x, C), w);
              _(T);
            } catch (P) {
              g(P);
            }
            C = [];
          }).resume();
        });
      }
      function p(y, v, _) {
        var g = v;
        switch (v) {
          case "blob":
          case "arraybuffer":
            g = "uint8array";
            break;
          case "base64":
            g = "string";
        }
        try {
          this._internalType = g, this._outputType = v, this._mimeType = _, o.checkSupport(g), this._worker = y.pipe(new a(g)), y.lock();
        } catch (C) {
          this._worker = new l("error"), this._worker.error(C);
        }
      }
      p.prototype = { accumulate: function(y) {
        return m(this, y);
      }, on: function(y, v) {
        var _ = this;
        return y === "data" ? this._worker.on(y, function(g) {
          v.call(_, g.data, g.meta);
        }) : this._worker.on(y, function() {
          o.delay(v, arguments, _);
        }), this;
      }, resume: function() {
        return o.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(y) {
        if (o.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new f(this, { objectMode: this._outputType !== "nodebuffer" }, y);
      } }, s.exports = p;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(n, s, i) {
      if (i.base64 = !0, i.array = !0, i.string = !0, i.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", i.nodebuffer = typeof Buffer < "u", i.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") i.blob = !1;
      else {
        var o = new ArrayBuffer(0);
        try {
          i.blob = new Blob([o], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var a = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            a.append(o), i.blob = a.getBlob("application/zip").size === 0;
          } catch {
            i.blob = !1;
          }
        }
      }
      try {
        i.nodestream = !!n("readable-stream").Readable;
      } catch {
        i.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(n, s, i) {
      for (var o = n("./utils"), a = n("./support"), l = n("./nodejsUtils"), c = n("./stream/GenericWorker"), u = new Array(256), h = 0; h < 256; h++) u[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      u[254] = u[254] = 1;
      function f() {
        c.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function m() {
        c.call(this, "utf-8 encode");
      }
      i.utf8encode = function(p) {
        return a.nodebuffer ? l.newBufferFrom(p, "utf-8") : function(y) {
          var v, _, g, C, x, k = y.length, w = 0;
          for (C = 0; C < k; C++) (64512 & (_ = y.charCodeAt(C))) == 55296 && C + 1 < k && (64512 & (g = y.charCodeAt(C + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (g - 56320), C++), w += _ < 128 ? 1 : _ < 2048 ? 2 : _ < 65536 ? 3 : 4;
          for (v = a.uint8array ? new Uint8Array(w) : new Array(w), C = x = 0; x < w; C++) (64512 & (_ = y.charCodeAt(C))) == 55296 && C + 1 < k && (64512 & (g = y.charCodeAt(C + 1))) == 56320 && (_ = 65536 + (_ - 55296 << 10) + (g - 56320), C++), _ < 128 ? v[x++] = _ : (_ < 2048 ? v[x++] = 192 | _ >>> 6 : (_ < 65536 ? v[x++] = 224 | _ >>> 12 : (v[x++] = 240 | _ >>> 18, v[x++] = 128 | _ >>> 12 & 63), v[x++] = 128 | _ >>> 6 & 63), v[x++] = 128 | 63 & _);
          return v;
        }(p);
      }, i.utf8decode = function(p) {
        return a.nodebuffer ? o.transformTo("nodebuffer", p).toString("utf-8") : function(y) {
          var v, _, g, C, x = y.length, k = new Array(2 * x);
          for (v = _ = 0; v < x; ) if ((g = y[v++]) < 128) k[_++] = g;
          else if (4 < (C = u[g])) k[_++] = 65533, v += C - 1;
          else {
            for (g &= C === 2 ? 31 : C === 3 ? 15 : 7; 1 < C && v < x; ) g = g << 6 | 63 & y[v++], C--;
            1 < C ? k[_++] = 65533 : g < 65536 ? k[_++] = g : (g -= 65536, k[_++] = 55296 | g >> 10 & 1023, k[_++] = 56320 | 1023 & g);
          }
          return k.length !== _ && (k.subarray ? k = k.subarray(0, _) : k.length = _), o.applyFromCharCode(k);
        }(p = o.transformTo(a.uint8array ? "uint8array" : "array", p));
      }, o.inherits(f, c), f.prototype.processChunk = function(p) {
        var y = o.transformTo(a.uint8array ? "uint8array" : "array", p.data);
        if (this.leftOver && this.leftOver.length) {
          if (a.uint8array) {
            var v = y;
            (y = new Uint8Array(v.length + this.leftOver.length)).set(this.leftOver, 0), y.set(v, this.leftOver.length);
          } else y = this.leftOver.concat(y);
          this.leftOver = null;
        }
        var _ = function(C, x) {
          var k;
          for ((x = x || C.length) > C.length && (x = C.length), k = x - 1; 0 <= k && (192 & C[k]) == 128; ) k--;
          return k < 0 || k === 0 ? x : k + u[C[k]] > x ? k : x;
        }(y), g = y;
        _ !== y.length && (a.uint8array ? (g = y.subarray(0, _), this.leftOver = y.subarray(_, y.length)) : (g = y.slice(0, _), this.leftOver = y.slice(_, y.length))), this.push({ data: i.utf8decode(g), meta: p.meta });
      }, f.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: i.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, i.Utf8DecodeWorker = f, o.inherits(m, c), m.prototype.processChunk = function(p) {
        this.push({ data: i.utf8encode(p.data), meta: p.meta });
      }, i.Utf8EncodeWorker = m;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(n, s, i) {
      var o = n("./support"), a = n("./base64"), l = n("./nodejsUtils"), c = n("./external");
      function u(v) {
        return v;
      }
      function h(v, _) {
        for (var g = 0; g < v.length; ++g) _[g] = 255 & v.charCodeAt(g);
        return _;
      }
      n("setimmediate"), i.newBlob = function(v, _) {
        i.checkSupport("blob");
        try {
          return new Blob([v], { type: _ });
        } catch {
          try {
            var g = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return g.append(v), g.getBlob(_);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var f = { stringifyByChunk: function(v, _, g) {
        var C = [], x = 0, k = v.length;
        if (k <= g) return String.fromCharCode.apply(null, v);
        for (; x < k; ) _ === "array" || _ === "nodebuffer" ? C.push(String.fromCharCode.apply(null, v.slice(x, Math.min(x + g, k)))) : C.push(String.fromCharCode.apply(null, v.subarray(x, Math.min(x + g, k)))), x += g;
        return C.join("");
      }, stringifyByChar: function(v) {
        for (var _ = "", g = 0; g < v.length; g++) _ += String.fromCharCode(v[g]);
        return _;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && String.fromCharCode.apply(null, l.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function m(v) {
        var _ = 65536, g = i.getTypeOf(v), C = !0;
        if (g === "uint8array" ? C = f.applyCanBeUsed.uint8array : g === "nodebuffer" && (C = f.applyCanBeUsed.nodebuffer), C) for (; 1 < _; ) try {
          return f.stringifyByChunk(v, g, _);
        } catch {
          _ = Math.floor(_ / 2);
        }
        return f.stringifyByChar(v);
      }
      function p(v, _) {
        for (var g = 0; g < v.length; g++) _[g] = v[g];
        return _;
      }
      i.applyFromCharCode = m;
      var y = {};
      y.string = { string: u, array: function(v) {
        return h(v, new Array(v.length));
      }, arraybuffer: function(v) {
        return y.string.uint8array(v).buffer;
      }, uint8array: function(v) {
        return h(v, new Uint8Array(v.length));
      }, nodebuffer: function(v) {
        return h(v, l.allocBuffer(v.length));
      } }, y.array = { string: m, array: u, arraybuffer: function(v) {
        return new Uint8Array(v).buffer;
      }, uint8array: function(v) {
        return new Uint8Array(v);
      }, nodebuffer: function(v) {
        return l.newBufferFrom(v);
      } }, y.arraybuffer = { string: function(v) {
        return m(new Uint8Array(v));
      }, array: function(v) {
        return p(new Uint8Array(v), new Array(v.byteLength));
      }, arraybuffer: u, uint8array: function(v) {
        return new Uint8Array(v);
      }, nodebuffer: function(v) {
        return l.newBufferFrom(new Uint8Array(v));
      } }, y.uint8array = { string: m, array: function(v) {
        return p(v, new Array(v.length));
      }, arraybuffer: function(v) {
        return v.buffer;
      }, uint8array: u, nodebuffer: function(v) {
        return l.newBufferFrom(v);
      } }, y.nodebuffer = { string: m, array: function(v) {
        return p(v, new Array(v.length));
      }, arraybuffer: function(v) {
        return y.nodebuffer.uint8array(v).buffer;
      }, uint8array: function(v) {
        return p(v, new Uint8Array(v.length));
      }, nodebuffer: u }, i.transformTo = function(v, _) {
        if (_ = _ || "", !v) return _;
        i.checkSupport(v);
        var g = i.getTypeOf(_);
        return y[g][v](_);
      }, i.resolve = function(v) {
        for (var _ = v.split("/"), g = [], C = 0; C < _.length; C++) {
          var x = _[C];
          x === "." || x === "" && C !== 0 && C !== _.length - 1 || (x === ".." ? g.pop() : g.push(x));
        }
        return g.join("/");
      }, i.getTypeOf = function(v) {
        return typeof v == "string" ? "string" : Object.prototype.toString.call(v) === "[object Array]" ? "array" : o.nodebuffer && l.isBuffer(v) ? "nodebuffer" : o.uint8array && v instanceof Uint8Array ? "uint8array" : o.arraybuffer && v instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, i.checkSupport = function(v) {
        if (!o[v.toLowerCase()]) throw new Error(v + " is not supported by this platform");
      }, i.MAX_VALUE_16BITS = 65535, i.MAX_VALUE_32BITS = -1, i.pretty = function(v) {
        var _, g, C = "";
        for (g = 0; g < (v || "").length; g++) C += "\\x" + ((_ = v.charCodeAt(g)) < 16 ? "0" : "") + _.toString(16).toUpperCase();
        return C;
      }, i.delay = function(v, _, g) {
        setImmediate(function() {
          v.apply(g || null, _ || []);
        });
      }, i.inherits = function(v, _) {
        function g() {
        }
        g.prototype = _.prototype, v.prototype = new g();
      }, i.extend = function() {
        var v, _, g = {};
        for (v = 0; v < arguments.length; v++) for (_ in arguments[v]) Object.prototype.hasOwnProperty.call(arguments[v], _) && g[_] === void 0 && (g[_] = arguments[v][_]);
        return g;
      }, i.prepareContent = function(v, _, g, C, x) {
        return c.Promise.resolve(_).then(function(k) {
          return o.blob && (k instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(k)) !== -1) && typeof FileReader < "u" ? new c.Promise(function(w, T) {
            var P = new FileReader();
            P.onload = function(z) {
              w(z.target.result);
            }, P.onerror = function(z) {
              T(z.target.error);
            }, P.readAsArrayBuffer(k);
          }) : k;
        }).then(function(k) {
          var w = i.getTypeOf(k);
          return w ? (w === "arraybuffer" ? k = i.transformTo("uint8array", k) : w === "string" && (x ? k = a.decode(k) : g && C !== !0 && (k = function(T) {
            return h(T, o.uint8array ? new Uint8Array(T.length) : new Array(T.length));
          }(k))), k) : c.Promise.reject(new Error("Can't read the data of '" + v + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(n, s, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), l = n("./signature"), c = n("./zipEntry"), u = n("./support");
      function h(f) {
        this.files = [], this.loadOptions = f;
      }
      h.prototype = { checkSignature: function(f) {
        if (!this.reader.readAndCheckSignature(f)) {
          this.reader.index -= 4;
          var m = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + a.pretty(m) + ", expected " + a.pretty(f) + ")");
        }
      }, isSignature: function(f, m) {
        var p = this.reader.index;
        this.reader.setIndex(f);
        var y = this.reader.readString(4) === m;
        return this.reader.setIndex(p), y;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var f = this.reader.readData(this.zipCommentLength), m = u.uint8array ? "uint8array" : "array", p = a.transformTo(m, f);
        this.zipComment = this.loadOptions.decodeFileName(p);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var f, m, p, y = this.zip64EndOfCentralSize - 44; 0 < y; ) f = this.reader.readInt(2), m = this.reader.readInt(4), p = this.reader.readData(m), this.zip64ExtensibleData[f] = { id: f, length: m, value: p };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var f, m;
        for (f = 0; f < this.files.length; f++) m = this.files[f], this.reader.setIndex(m.localHeaderOffset), this.checkSignature(l.LOCAL_FILE_HEADER), m.readLocalPart(this.reader), m.handleUTF8(), m.processAttributes();
      }, readCentralDir: function() {
        var f;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(l.CENTRAL_FILE_HEADER); ) (f = new c({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(f);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var f = this.reader.lastIndexOfSignature(l.CENTRAL_DIRECTORY_END);
        if (f < 0) throw this.isSignature(0, l.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(f);
        var m = f;
        if (this.checkSignature(l.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === a.MAX_VALUE_16BITS || this.diskWithCentralDirStart === a.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === a.MAX_VALUE_16BITS || this.centralDirRecords === a.MAX_VALUE_16BITS || this.centralDirSize === a.MAX_VALUE_32BITS || this.centralDirOffset === a.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (f = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(f), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, l.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var p = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (p += 20, p += 12 + this.zip64EndOfCentralSize);
        var y = m - p;
        if (0 < y) this.isSignature(m, l.CENTRAL_FILE_HEADER) || (this.reader.zero = y);
        else if (y < 0) throw new Error("Corrupted zip: missing " + Math.abs(y) + " bytes.");
      }, prepareReader: function(f) {
        this.reader = o(f);
      }, load: function(f) {
        this.prepareReader(f), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, s.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(n, s, i) {
      var o = n("./reader/readerFor"), a = n("./utils"), l = n("./compressedObject"), c = n("./crc32"), u = n("./utf8"), h = n("./compressions"), f = n("./support");
      function m(p, y) {
        this.options = p, this.loadOptions = y;
      }
      m.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(p) {
        var y, v;
        if (p.skip(22), this.fileNameLength = p.readInt(2), v = p.readInt(2), this.fileName = p.readData(this.fileNameLength), p.skip(v), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((y = function(_) {
          for (var g in h) if (Object.prototype.hasOwnProperty.call(h, g) && h[g].magic === _) return h[g];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + a.pretty(this.compressionMethod) + " unknown (inner file : " + a.transformTo("string", this.fileName) + ")");
        this.decompressed = new l(this.compressedSize, this.uncompressedSize, this.crc32, y, p.readData(this.compressedSize));
      }, readCentralPart: function(p) {
        this.versionMadeBy = p.readInt(2), p.skip(2), this.bitFlag = p.readInt(2), this.compressionMethod = p.readString(2), this.date = p.readDate(), this.crc32 = p.readInt(4), this.compressedSize = p.readInt(4), this.uncompressedSize = p.readInt(4);
        var y = p.readInt(2);
        if (this.extraFieldsLength = p.readInt(2), this.fileCommentLength = p.readInt(2), this.diskNumberStart = p.readInt(2), this.internalFileAttributes = p.readInt(2), this.externalFileAttributes = p.readInt(4), this.localHeaderOffset = p.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        p.skip(y), this.readExtraFields(p), this.parseZIP64ExtraField(p), this.fileComment = p.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var p = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), p == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), p == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var p = o(this.extraFields[1].value);
          this.uncompressedSize === a.MAX_VALUE_32BITS && (this.uncompressedSize = p.readInt(8)), this.compressedSize === a.MAX_VALUE_32BITS && (this.compressedSize = p.readInt(8)), this.localHeaderOffset === a.MAX_VALUE_32BITS && (this.localHeaderOffset = p.readInt(8)), this.diskNumberStart === a.MAX_VALUE_32BITS && (this.diskNumberStart = p.readInt(4));
        }
      }, readExtraFields: function(p) {
        var y, v, _, g = p.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); p.index + 4 < g; ) y = p.readInt(2), v = p.readInt(2), _ = p.readData(v), this.extraFields[y] = { id: y, length: v, value: _ };
        p.setIndex(g);
      }, handleUTF8: function() {
        var p = f.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
        else {
          var y = this.findExtraFieldUnicodePath();
          if (y !== null) this.fileNameStr = y;
          else {
            var v = a.transformTo(p, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(v);
          }
          var _ = this.findExtraFieldUnicodeComment();
          if (_ !== null) this.fileCommentStr = _;
          else {
            var g = a.transformTo(p, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(g);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var p = this.extraFields[28789];
        if (p) {
          var y = o(p.value);
          return y.readInt(1) !== 1 || c(this.fileName) !== y.readInt(4) ? null : u.utf8decode(y.readData(p.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var p = this.extraFields[25461];
        if (p) {
          var y = o(p.value);
          return y.readInt(1) !== 1 || c(this.fileComment) !== y.readInt(4) ? null : u.utf8decode(y.readData(p.length - 5));
        }
        return null;
      } }, s.exports = m;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(n, s, i) {
      function o(y, v, _) {
        this.name = y, this.dir = _.dir, this.date = _.date, this.comment = _.comment, this.unixPermissions = _.unixPermissions, this.dosPermissions = _.dosPermissions, this._data = v, this._dataBinary = _.binary, this.options = { compression: _.compression, compressionOptions: _.compressionOptions };
      }
      var a = n("./stream/StreamHelper"), l = n("./stream/DataWorker"), c = n("./utf8"), u = n("./compressedObject"), h = n("./stream/GenericWorker");
      o.prototype = { internalStream: function(y) {
        var v = null, _ = "string";
        try {
          if (!y) throw new Error("No output type specified.");
          var g = (_ = y.toLowerCase()) === "string" || _ === "text";
          _ !== "binarystring" && _ !== "text" || (_ = "string"), v = this._decompressWorker();
          var C = !this._dataBinary;
          C && !g && (v = v.pipe(new c.Utf8EncodeWorker())), !C && g && (v = v.pipe(new c.Utf8DecodeWorker()));
        } catch (x) {
          (v = new h("error")).error(x);
        }
        return new a(v, _, "");
      }, async: function(y, v) {
        return this.internalStream(y).accumulate(v);
      }, nodeStream: function(y, v) {
        return this.internalStream(y || "nodebuffer").toNodejsStream(v);
      }, _compressWorker: function(y, v) {
        if (this._data instanceof u && this._data.compression.magic === y.magic) return this._data.getCompressedWorker();
        var _ = this._decompressWorker();
        return this._dataBinary || (_ = _.pipe(new c.Utf8EncodeWorker())), u.createWorkerFrom(_, y, v);
      }, _decompressWorker: function() {
        return this._data instanceof u ? this._data.getContentWorker() : this._data instanceof h ? this._data : new l(this._data);
      } };
      for (var f = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], m = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, p = 0; p < f.length; p++) o.prototype[f[p]] = m;
      s.exports = o;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(n, s, i) {
      (function(o) {
        var a, l, c = o.MutationObserver || o.WebKitMutationObserver;
        if (c) {
          var u = 0, h = new c(y), f = o.document.createTextNode("");
          h.observe(f, { characterData: !0 }), a = function() {
            f.data = u = ++u % 2;
          };
        } else if (o.setImmediate || o.MessageChannel === void 0) a = "document" in o && "onreadystatechange" in o.document.createElement("script") ? function() {
          var v = o.document.createElement("script");
          v.onreadystatechange = function() {
            y(), v.onreadystatechange = null, v.parentNode.removeChild(v), v = null;
          }, o.document.documentElement.appendChild(v);
        } : function() {
          setTimeout(y, 0);
        };
        else {
          var m = new o.MessageChannel();
          m.port1.onmessage = y, a = function() {
            m.port2.postMessage(0);
          };
        }
        var p = [];
        function y() {
          var v, _;
          l = !0;
          for (var g = p.length; g; ) {
            for (_ = p, p = [], v = -1; ++v < g; ) _[v]();
            g = p.length;
          }
          l = !1;
        }
        s.exports = function(v) {
          p.push(v) !== 1 || l || a();
        };
      }).call(this, typeof oo < "u" ? oo : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(n, s, i) {
      var o = n("immediate");
      function a() {
      }
      var l = {}, c = ["REJECTED"], u = ["FULFILLED"], h = ["PENDING"];
      function f(g) {
        if (typeof g != "function") throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, g !== a && v(this, g);
      }
      function m(g, C, x) {
        this.promise = g, typeof C == "function" && (this.onFulfilled = C, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function p(g, C, x) {
        o(function() {
          var k;
          try {
            k = C(x);
          } catch (w) {
            return l.reject(g, w);
          }
          k === g ? l.reject(g, new TypeError("Cannot resolve promise with itself")) : l.resolve(g, k);
        });
      }
      function y(g) {
        var C = g && g.then;
        if (g && (typeof g == "object" || typeof g == "function") && typeof C == "function") return function() {
          C.apply(g, arguments);
        };
      }
      function v(g, C) {
        var x = !1;
        function k(P) {
          x || (x = !0, l.reject(g, P));
        }
        function w(P) {
          x || (x = !0, l.resolve(g, P));
        }
        var T = _(function() {
          C(w, k);
        });
        T.status === "error" && k(T.value);
      }
      function _(g, C) {
        var x = {};
        try {
          x.value = g(C), x.status = "success";
        } catch (k) {
          x.status = "error", x.value = k;
        }
        return x;
      }
      (s.exports = f).prototype.finally = function(g) {
        if (typeof g != "function") return this;
        var C = this.constructor;
        return this.then(function(x) {
          return C.resolve(g()).then(function() {
            return x;
          });
        }, function(x) {
          return C.resolve(g()).then(function() {
            throw x;
          });
        });
      }, f.prototype.catch = function(g) {
        return this.then(null, g);
      }, f.prototype.then = function(g, C) {
        if (typeof g != "function" && this.state === u || typeof C != "function" && this.state === c) return this;
        var x = new this.constructor(a);
        return this.state !== h ? p(x, this.state === u ? g : C, this.outcome) : this.queue.push(new m(x, g, C)), x;
      }, m.prototype.callFulfilled = function(g) {
        l.resolve(this.promise, g);
      }, m.prototype.otherCallFulfilled = function(g) {
        p(this.promise, this.onFulfilled, g);
      }, m.prototype.callRejected = function(g) {
        l.reject(this.promise, g);
      }, m.prototype.otherCallRejected = function(g) {
        p(this.promise, this.onRejected, g);
      }, l.resolve = function(g, C) {
        var x = _(y, C);
        if (x.status === "error") return l.reject(g, x.value);
        var k = x.value;
        if (k) v(g, k);
        else {
          g.state = u, g.outcome = C;
          for (var w = -1, T = g.queue.length; ++w < T; ) g.queue[w].callFulfilled(C);
        }
        return g;
      }, l.reject = function(g, C) {
        g.state = c, g.outcome = C;
        for (var x = -1, k = g.queue.length; ++x < k; ) g.queue[x].callRejected(C);
        return g;
      }, f.resolve = function(g) {
        return g instanceof this ? g : l.resolve(new this(a), g);
      }, f.reject = function(g) {
        var C = new this(a);
        return l.reject(C, g);
      }, f.all = function(g) {
        var C = this;
        if (Object.prototype.toString.call(g) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = g.length, k = !1;
        if (!x) return this.resolve([]);
        for (var w = new Array(x), T = 0, P = -1, z = new this(a); ++P < x; ) j(g[P], P);
        return z;
        function j(ot, vt) {
          C.resolve(ot).then(function(L) {
            w[vt] = L, ++T !== x || k || (k = !0, l.resolve(z, w));
          }, function(L) {
            k || (k = !0, l.reject(z, L));
          });
        }
      }, f.race = function(g) {
        var C = this;
        if (Object.prototype.toString.call(g) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = g.length, k = !1;
        if (!x) return this.resolve([]);
        for (var w = -1, T = new this(a); ++w < x; ) P = g[w], C.resolve(P).then(function(z) {
          k || (k = !0, l.resolve(T, z));
        }, function(z) {
          k || (k = !0, l.reject(T, z));
        });
        var P;
        return T;
      };
    }, { immediate: 36 }], 38: [function(n, s, i) {
      var o = {};
      (0, n("./lib/utils/common").assign)(o, n("./lib/deflate"), n("./lib/inflate"), n("./lib/zlib/constants")), s.exports = o;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(n, s, i) {
      var o = n("./zlib/deflate"), a = n("./utils/common"), l = n("./utils/strings"), c = n("./zlib/messages"), u = n("./zlib/zstream"), h = Object.prototype.toString, f = 0, m = -1, p = 0, y = 8;
      function v(g) {
        if (!(this instanceof v)) return new v(g);
        this.options = a.assign({ level: m, method: y, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: p, to: "" }, g || {});
        var C = this.options;
        C.raw && 0 < C.windowBits ? C.windowBits = -C.windowBits : C.gzip && 0 < C.windowBits && C.windowBits < 16 && (C.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var x = o.deflateInit2(this.strm, C.level, C.method, C.windowBits, C.memLevel, C.strategy);
        if (x !== f) throw new Error(c[x]);
        if (C.header && o.deflateSetHeader(this.strm, C.header), C.dictionary) {
          var k;
          if (k = typeof C.dictionary == "string" ? l.string2buf(C.dictionary) : h.call(C.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(C.dictionary) : C.dictionary, (x = o.deflateSetDictionary(this.strm, k)) !== f) throw new Error(c[x]);
          this._dict_set = !0;
        }
      }
      function _(g, C) {
        var x = new v(C);
        if (x.push(g, !0), x.err) throw x.msg || c[x.err];
        return x.result;
      }
      v.prototype.push = function(g, C) {
        var x, k, w = this.strm, T = this.options.chunkSize;
        if (this.ended) return !1;
        k = C === ~~C ? C : C === !0 ? 4 : 0, typeof g == "string" ? w.input = l.string2buf(g) : h.call(g) === "[object ArrayBuffer]" ? w.input = new Uint8Array(g) : w.input = g, w.next_in = 0, w.avail_in = w.input.length;
        do {
          if (w.avail_out === 0 && (w.output = new a.Buf8(T), w.next_out = 0, w.avail_out = T), (x = o.deflate(w, k)) !== 1 && x !== f) return this.onEnd(x), !(this.ended = !0);
          w.avail_out !== 0 && (w.avail_in !== 0 || k !== 4 && k !== 2) || (this.options.to === "string" ? this.onData(l.buf2binstring(a.shrinkBuf(w.output, w.next_out))) : this.onData(a.shrinkBuf(w.output, w.next_out)));
        } while ((0 < w.avail_in || w.avail_out === 0) && x !== 1);
        return k === 4 ? (x = o.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === f) : k !== 2 || (this.onEnd(f), !(w.avail_out = 0));
      }, v.prototype.onData = function(g) {
        this.chunks.push(g);
      }, v.prototype.onEnd = function(g) {
        g === f && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, i.Deflate = v, i.deflate = _, i.deflateRaw = function(g, C) {
        return (C = C || {}).raw = !0, _(g, C);
      }, i.gzip = function(g, C) {
        return (C = C || {}).gzip = !0, _(g, C);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(n, s, i) {
      var o = n("./zlib/inflate"), a = n("./utils/common"), l = n("./utils/strings"), c = n("./zlib/constants"), u = n("./zlib/messages"), h = n("./zlib/zstream"), f = n("./zlib/gzheader"), m = Object.prototype.toString;
      function p(v) {
        if (!(this instanceof p)) return new p(v);
        this.options = a.assign({ chunkSize: 16384, windowBits: 0, to: "" }, v || {});
        var _ = this.options;
        _.raw && 0 <= _.windowBits && _.windowBits < 16 && (_.windowBits = -_.windowBits, _.windowBits === 0 && (_.windowBits = -15)), !(0 <= _.windowBits && _.windowBits < 16) || v && v.windowBits || (_.windowBits += 32), 15 < _.windowBits && _.windowBits < 48 && !(15 & _.windowBits) && (_.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var g = o.inflateInit2(this.strm, _.windowBits);
        if (g !== c.Z_OK) throw new Error(u[g]);
        this.header = new f(), o.inflateGetHeader(this.strm, this.header);
      }
      function y(v, _) {
        var g = new p(_);
        if (g.push(v, !0), g.err) throw g.msg || u[g.err];
        return g.result;
      }
      p.prototype.push = function(v, _) {
        var g, C, x, k, w, T, P = this.strm, z = this.options.chunkSize, j = this.options.dictionary, ot = !1;
        if (this.ended) return !1;
        C = _ === ~~_ ? _ : _ === !0 ? c.Z_FINISH : c.Z_NO_FLUSH, typeof v == "string" ? P.input = l.binstring2buf(v) : m.call(v) === "[object ArrayBuffer]" ? P.input = new Uint8Array(v) : P.input = v, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new a.Buf8(z), P.next_out = 0, P.avail_out = z), (g = o.inflate(P, c.Z_NO_FLUSH)) === c.Z_NEED_DICT && j && (T = typeof j == "string" ? l.string2buf(j) : m.call(j) === "[object ArrayBuffer]" ? new Uint8Array(j) : j, g = o.inflateSetDictionary(this.strm, T)), g === c.Z_BUF_ERROR && ot === !0 && (g = c.Z_OK, ot = !1), g !== c.Z_STREAM_END && g !== c.Z_OK) return this.onEnd(g), !(this.ended = !0);
          P.next_out && (P.avail_out !== 0 && g !== c.Z_STREAM_END && (P.avail_in !== 0 || C !== c.Z_FINISH && C !== c.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = l.utf8border(P.output, P.next_out), k = P.next_out - x, w = l.buf2string(P.output, x), P.next_out = k, P.avail_out = z - k, k && a.arraySet(P.output, P.output, x, k, 0), this.onData(w)) : this.onData(a.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (ot = !0);
        } while ((0 < P.avail_in || P.avail_out === 0) && g !== c.Z_STREAM_END);
        return g === c.Z_STREAM_END && (C = c.Z_FINISH), C === c.Z_FINISH ? (g = o.inflateEnd(this.strm), this.onEnd(g), this.ended = !0, g === c.Z_OK) : C !== c.Z_SYNC_FLUSH || (this.onEnd(c.Z_OK), !(P.avail_out = 0));
      }, p.prototype.onData = function(v) {
        this.chunks.push(v);
      }, p.prototype.onEnd = function(v) {
        v === c.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = a.flattenChunks(this.chunks)), this.chunks = [], this.err = v, this.msg = this.strm.msg;
      }, i.Inflate = p, i.inflate = y, i.inflateRaw = function(v, _) {
        return (_ = _ || {}).raw = !0, y(v, _);
      }, i.ungzip = y;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(n, s, i) {
      var o = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      i.assign = function(c) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var h = u.shift();
          if (h) {
            if (typeof h != "object") throw new TypeError(h + "must be non-object");
            for (var f in h) h.hasOwnProperty(f) && (c[f] = h[f]);
          }
        }
        return c;
      }, i.shrinkBuf = function(c, u) {
        return c.length === u ? c : c.subarray ? c.subarray(0, u) : (c.length = u, c);
      };
      var a = { arraySet: function(c, u, h, f, m) {
        if (u.subarray && c.subarray) c.set(u.subarray(h, h + f), m);
        else for (var p = 0; p < f; p++) c[m + p] = u[h + p];
      }, flattenChunks: function(c) {
        var u, h, f, m, p, y;
        for (u = f = 0, h = c.length; u < h; u++) f += c[u].length;
        for (y = new Uint8Array(f), u = m = 0, h = c.length; u < h; u++) p = c[u], y.set(p, m), m += p.length;
        return y;
      } }, l = { arraySet: function(c, u, h, f, m) {
        for (var p = 0; p < f; p++) c[m + p] = u[h + p];
      }, flattenChunks: function(c) {
        return [].concat.apply([], c);
      } };
      i.setTyped = function(c) {
        c ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, a)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, l));
      }, i.setTyped(o);
    }, {}], 42: [function(n, s, i) {
      var o = n("./common"), a = !0, l = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        a = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        l = !1;
      }
      for (var c = new o.Buf8(256), u = 0; u < 256; u++) c[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      function h(f, m) {
        if (m < 65537 && (f.subarray && l || !f.subarray && a)) return String.fromCharCode.apply(null, o.shrinkBuf(f, m));
        for (var p = "", y = 0; y < m; y++) p += String.fromCharCode(f[y]);
        return p;
      }
      c[254] = c[254] = 1, i.string2buf = function(f) {
        var m, p, y, v, _, g = f.length, C = 0;
        for (v = 0; v < g; v++) (64512 & (p = f.charCodeAt(v))) == 55296 && v + 1 < g && (64512 & (y = f.charCodeAt(v + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (y - 56320), v++), C += p < 128 ? 1 : p < 2048 ? 2 : p < 65536 ? 3 : 4;
        for (m = new o.Buf8(C), v = _ = 0; _ < C; v++) (64512 & (p = f.charCodeAt(v))) == 55296 && v + 1 < g && (64512 & (y = f.charCodeAt(v + 1))) == 56320 && (p = 65536 + (p - 55296 << 10) + (y - 56320), v++), p < 128 ? m[_++] = p : (p < 2048 ? m[_++] = 192 | p >>> 6 : (p < 65536 ? m[_++] = 224 | p >>> 12 : (m[_++] = 240 | p >>> 18, m[_++] = 128 | p >>> 12 & 63), m[_++] = 128 | p >>> 6 & 63), m[_++] = 128 | 63 & p);
        return m;
      }, i.buf2binstring = function(f) {
        return h(f, f.length);
      }, i.binstring2buf = function(f) {
        for (var m = new o.Buf8(f.length), p = 0, y = m.length; p < y; p++) m[p] = f.charCodeAt(p);
        return m;
      }, i.buf2string = function(f, m) {
        var p, y, v, _, g = m || f.length, C = new Array(2 * g);
        for (p = y = 0; p < g; ) if ((v = f[p++]) < 128) C[y++] = v;
        else if (4 < (_ = c[v])) C[y++] = 65533, p += _ - 1;
        else {
          for (v &= _ === 2 ? 31 : _ === 3 ? 15 : 7; 1 < _ && p < g; ) v = v << 6 | 63 & f[p++], _--;
          1 < _ ? C[y++] = 65533 : v < 65536 ? C[y++] = v : (v -= 65536, C[y++] = 55296 | v >> 10 & 1023, C[y++] = 56320 | 1023 & v);
        }
        return h(C, y);
      }, i.utf8border = function(f, m) {
        var p;
        for ((m = m || f.length) > f.length && (m = f.length), p = m - 1; 0 <= p && (192 & f[p]) == 128; ) p--;
        return p < 0 || p === 0 ? m : p + c[f[p]] > m ? p : m;
      };
    }, { "./common": 41 }], 43: [function(n, s, i) {
      s.exports = function(o, a, l, c) {
        for (var u = 65535 & o | 0, h = o >>> 16 & 65535 | 0, f = 0; l !== 0; ) {
          for (l -= f = 2e3 < l ? 2e3 : l; h = h + (u = u + a[c++] | 0) | 0, --f; ) ;
          u %= 65521, h %= 65521;
        }
        return u | h << 16 | 0;
      };
    }, {}], 44: [function(n, s, i) {
      s.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(n, s, i) {
      var o = function() {
        for (var a, l = [], c = 0; c < 256; c++) {
          a = c;
          for (var u = 0; u < 8; u++) a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[c] = a;
        }
        return l;
      }();
      s.exports = function(a, l, c, u) {
        var h = o, f = u + c;
        a ^= -1;
        for (var m = u; m < f; m++) a = a >>> 8 ^ h[255 & (a ^ l[m])];
        return -1 ^ a;
      };
    }, {}], 46: [function(n, s, i) {
      var o, a = n("../utils/common"), l = n("./trees"), c = n("./adler32"), u = n("./crc32"), h = n("./messages"), f = 0, m = 4, p = 0, y = -2, v = -1, _ = 4, g = 2, C = 8, x = 9, k = 286, w = 30, T = 19, P = 2 * k + 1, z = 15, j = 3, ot = 258, vt = ot + j + 1, L = 42, Y = 113, M = 1, I = 2, tt = 3, U = 4;
      function W(b, B) {
        return b.msg = h[B], B;
      }
      function Z(b) {
        return (b << 1) - (4 < b ? 9 : 0);
      }
      function yt(b) {
        for (var B = b.length; 0 <= --B; ) b[B] = 0;
      }
      function Q(b) {
        var B = b.state, R = B.pending;
        R > b.avail_out && (R = b.avail_out), R !== 0 && (a.arraySet(b.output, B.pending_buf, B.pending_out, R, b.next_out), b.next_out += R, B.pending_out += R, b.total_out += R, b.avail_out -= R, B.pending -= R, B.pending === 0 && (B.pending_out = 0));
      }
      function at(b, B) {
        l._tr_flush_block(b, 0 <= b.block_start ? b.block_start : -1, b.strstart - b.block_start, B), b.block_start = b.strstart, Q(b.strm);
      }
      function _t(b, B) {
        b.pending_buf[b.pending++] = B;
      }
      function ht(b, B) {
        b.pending_buf[b.pending++] = B >>> 8 & 255, b.pending_buf[b.pending++] = 255 & B;
      }
      function X(b, B) {
        var R, D, A = b.max_chain_length, N = b.strstart, q = b.prev_length, J = b.nice_match, V = b.strstart > b.w_size - vt ? b.strstart - (b.w_size - vt) : 0, $ = b.window, rt = b.w_mask, ft = b.prev, bt = b.strstart + ot, Ft = $[N + q - 1], Ot = $[N + q];
        b.prev_length >= b.good_match && (A >>= 2), J > b.lookahead && (J = b.lookahead);
        do
          if ($[(R = B) + q] === Ot && $[R + q - 1] === Ft && $[R] === $[N] && $[++R] === $[N + 1]) {
            N += 2, R++;
            do
              ;
            while ($[++N] === $[++R] && $[++N] === $[++R] && $[++N] === $[++R] && $[++N] === $[++R] && $[++N] === $[++R] && $[++N] === $[++R] && $[++N] === $[++R] && $[++N] === $[++R] && N < bt);
            if (D = ot - (bt - N), N = bt - ot, q < D) {
              if (b.match_start = B, J <= (q = D)) break;
              Ft = $[N + q - 1], Ot = $[N + q];
            }
          }
        while ((B = ft[B & rt]) > V && --A != 0);
        return q <= b.lookahead ? q : b.lookahead;
      }
      function kt(b) {
        var B, R, D, A, N, q, J, V, $, rt, ft = b.w_size;
        do {
          if (A = b.window_size - b.lookahead - b.strstart, b.strstart >= ft + (ft - vt)) {
            for (a.arraySet(b.window, b.window, ft, ft, 0), b.match_start -= ft, b.strstart -= ft, b.block_start -= ft, B = R = b.hash_size; D = b.head[--B], b.head[B] = ft <= D ? D - ft : 0, --R; ) ;
            for (B = R = ft; D = b.prev[--B], b.prev[B] = ft <= D ? D - ft : 0, --R; ) ;
            A += ft;
          }
          if (b.strm.avail_in === 0) break;
          if (q = b.strm, J = b.window, V = b.strstart + b.lookahead, $ = A, rt = void 0, rt = q.avail_in, $ < rt && (rt = $), R = rt === 0 ? 0 : (q.avail_in -= rt, a.arraySet(J, q.input, q.next_in, rt, V), q.state.wrap === 1 ? q.adler = c(q.adler, J, rt, V) : q.state.wrap === 2 && (q.adler = u(q.adler, J, rt, V)), q.next_in += rt, q.total_in += rt, rt), b.lookahead += R, b.lookahead + b.insert >= j) for (N = b.strstart - b.insert, b.ins_h = b.window[N], b.ins_h = (b.ins_h << b.hash_shift ^ b.window[N + 1]) & b.hash_mask; b.insert && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[N + j - 1]) & b.hash_mask, b.prev[N & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = N, N++, b.insert--, !(b.lookahead + b.insert < j)); ) ;
        } while (b.lookahead < vt && b.strm.avail_in !== 0);
      }
      function lt(b, B) {
        for (var R, D; ; ) {
          if (b.lookahead < vt) {
            if (kt(b), b.lookahead < vt && B === f) return M;
            if (b.lookahead === 0) break;
          }
          if (R = 0, b.lookahead >= j && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + j - 1]) & b.hash_mask, R = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart), R !== 0 && b.strstart - R <= b.w_size - vt && (b.match_length = X(b, R)), b.match_length >= j) if (D = l._tr_tally(b, b.strstart - b.match_start, b.match_length - j), b.lookahead -= b.match_length, b.match_length <= b.max_lazy_match && b.lookahead >= j) {
            for (b.match_length--; b.strstart++, b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + j - 1]) & b.hash_mask, R = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart, --b.match_length != 0; ) ;
            b.strstart++;
          } else b.strstart += b.match_length, b.match_length = 0, b.ins_h = b.window[b.strstart], b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + 1]) & b.hash_mask;
          else D = l._tr_tally(b, 0, b.window[b.strstart]), b.lookahead--, b.strstart++;
          if (D && (at(b, !1), b.strm.avail_out === 0)) return M;
        }
        return b.insert = b.strstart < j - 1 ? b.strstart : j - 1, B === m ? (at(b, !0), b.strm.avail_out === 0 ? tt : U) : b.last_lit && (at(b, !1), b.strm.avail_out === 0) ? M : I;
      }
      function pt(b, B) {
        for (var R, D, A; ; ) {
          if (b.lookahead < vt) {
            if (kt(b), b.lookahead < vt && B === f) return M;
            if (b.lookahead === 0) break;
          }
          if (R = 0, b.lookahead >= j && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + j - 1]) & b.hash_mask, R = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart), b.prev_length = b.match_length, b.prev_match = b.match_start, b.match_length = j - 1, R !== 0 && b.prev_length < b.max_lazy_match && b.strstart - R <= b.w_size - vt && (b.match_length = X(b, R), b.match_length <= 5 && (b.strategy === 1 || b.match_length === j && 4096 < b.strstart - b.match_start) && (b.match_length = j - 1)), b.prev_length >= j && b.match_length <= b.prev_length) {
            for (A = b.strstart + b.lookahead - j, D = l._tr_tally(b, b.strstart - 1 - b.prev_match, b.prev_length - j), b.lookahead -= b.prev_length - 1, b.prev_length -= 2; ++b.strstart <= A && (b.ins_h = (b.ins_h << b.hash_shift ^ b.window[b.strstart + j - 1]) & b.hash_mask, R = b.prev[b.strstart & b.w_mask] = b.head[b.ins_h], b.head[b.ins_h] = b.strstart), --b.prev_length != 0; ) ;
            if (b.match_available = 0, b.match_length = j - 1, b.strstart++, D && (at(b, !1), b.strm.avail_out === 0)) return M;
          } else if (b.match_available) {
            if ((D = l._tr_tally(b, 0, b.window[b.strstart - 1])) && at(b, !1), b.strstart++, b.lookahead--, b.strm.avail_out === 0) return M;
          } else b.match_available = 1, b.strstart++, b.lookahead--;
        }
        return b.match_available && (D = l._tr_tally(b, 0, b.window[b.strstart - 1]), b.match_available = 0), b.insert = b.strstart < j - 1 ? b.strstart : j - 1, B === m ? (at(b, !0), b.strm.avail_out === 0 ? tt : U) : b.last_lit && (at(b, !1), b.strm.avail_out === 0) ? M : I;
      }
      function it(b, B, R, D, A) {
        this.good_length = b, this.max_lazy = B, this.nice_length = R, this.max_chain = D, this.func = A;
      }
      function E() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = C, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new a.Buf16(2 * P), this.dyn_dtree = new a.Buf16(2 * (2 * w + 1)), this.bl_tree = new a.Buf16(2 * (2 * T + 1)), yt(this.dyn_ltree), yt(this.dyn_dtree), yt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new a.Buf16(z + 1), this.heap = new a.Buf16(2 * k + 1), yt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new a.Buf16(2 * k + 1), yt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function O(b) {
        var B;
        return b && b.state ? (b.total_in = b.total_out = 0, b.data_type = g, (B = b.state).pending = 0, B.pending_out = 0, B.wrap < 0 && (B.wrap = -B.wrap), B.status = B.wrap ? L : Y, b.adler = B.wrap === 2 ? 0 : 1, B.last_flush = f, l._tr_init(B), p) : W(b, y);
      }
      function S(b) {
        var B = O(b);
        return B === p && function(R) {
          R.window_size = 2 * R.w_size, yt(R.head), R.max_lazy_match = o[R.level].max_lazy, R.good_match = o[R.level].good_length, R.nice_match = o[R.level].nice_length, R.max_chain_length = o[R.level].max_chain, R.strstart = 0, R.block_start = 0, R.lookahead = 0, R.insert = 0, R.match_length = R.prev_length = j - 1, R.match_available = 0, R.ins_h = 0;
        }(b.state), B;
      }
      function F(b, B, R, D, A, N) {
        if (!b) return y;
        var q = 1;
        if (B === v && (B = 6), D < 0 ? (q = 0, D = -D) : 15 < D && (q = 2, D -= 16), A < 1 || x < A || R !== C || D < 8 || 15 < D || B < 0 || 9 < B || N < 0 || _ < N) return W(b, y);
        D === 8 && (D = 9);
        var J = new E();
        return (b.state = J).strm = b, J.wrap = q, J.gzhead = null, J.w_bits = D, J.w_size = 1 << J.w_bits, J.w_mask = J.w_size - 1, J.hash_bits = A + 7, J.hash_size = 1 << J.hash_bits, J.hash_mask = J.hash_size - 1, J.hash_shift = ~~((J.hash_bits + j - 1) / j), J.window = new a.Buf8(2 * J.w_size), J.head = new a.Buf16(J.hash_size), J.prev = new a.Buf16(J.w_size), J.lit_bufsize = 1 << A + 6, J.pending_buf_size = 4 * J.lit_bufsize, J.pending_buf = new a.Buf8(J.pending_buf_size), J.d_buf = 1 * J.lit_bufsize, J.l_buf = 3 * J.lit_bufsize, J.level = B, J.strategy = N, J.method = R, S(b);
      }
      o = [new it(0, 0, 0, 0, function(b, B) {
        var R = 65535;
        for (R > b.pending_buf_size - 5 && (R = b.pending_buf_size - 5); ; ) {
          if (b.lookahead <= 1) {
            if (kt(b), b.lookahead === 0 && B === f) return M;
            if (b.lookahead === 0) break;
          }
          b.strstart += b.lookahead, b.lookahead = 0;
          var D = b.block_start + R;
          if ((b.strstart === 0 || b.strstart >= D) && (b.lookahead = b.strstart - D, b.strstart = D, at(b, !1), b.strm.avail_out === 0) || b.strstart - b.block_start >= b.w_size - vt && (at(b, !1), b.strm.avail_out === 0)) return M;
        }
        return b.insert = 0, B === m ? (at(b, !0), b.strm.avail_out === 0 ? tt : U) : (b.strstart > b.block_start && (at(b, !1), b.strm.avail_out), M);
      }), new it(4, 4, 8, 4, lt), new it(4, 5, 16, 8, lt), new it(4, 6, 32, 32, lt), new it(4, 4, 16, 16, pt), new it(8, 16, 32, 32, pt), new it(8, 16, 128, 128, pt), new it(8, 32, 128, 256, pt), new it(32, 128, 258, 1024, pt), new it(32, 258, 258, 4096, pt)], i.deflateInit = function(b, B) {
        return F(b, B, C, 15, 8, 0);
      }, i.deflateInit2 = F, i.deflateReset = S, i.deflateResetKeep = O, i.deflateSetHeader = function(b, B) {
        return b && b.state ? b.state.wrap !== 2 ? y : (b.state.gzhead = B, p) : y;
      }, i.deflate = function(b, B) {
        var R, D, A, N;
        if (!b || !b.state || 5 < B || B < 0) return b ? W(b, y) : y;
        if (D = b.state, !b.output || !b.input && b.avail_in !== 0 || D.status === 666 && B !== m) return W(b, b.avail_out === 0 ? -5 : y);
        if (D.strm = b, R = D.last_flush, D.last_flush = B, D.status === L) if (D.wrap === 2) b.adler = 0, _t(D, 31), _t(D, 139), _t(D, 8), D.gzhead ? (_t(D, (D.gzhead.text ? 1 : 0) + (D.gzhead.hcrc ? 2 : 0) + (D.gzhead.extra ? 4 : 0) + (D.gzhead.name ? 8 : 0) + (D.gzhead.comment ? 16 : 0)), _t(D, 255 & D.gzhead.time), _t(D, D.gzhead.time >> 8 & 255), _t(D, D.gzhead.time >> 16 & 255), _t(D, D.gzhead.time >> 24 & 255), _t(D, D.level === 9 ? 2 : 2 <= D.strategy || D.level < 2 ? 4 : 0), _t(D, 255 & D.gzhead.os), D.gzhead.extra && D.gzhead.extra.length && (_t(D, 255 & D.gzhead.extra.length), _t(D, D.gzhead.extra.length >> 8 & 255)), D.gzhead.hcrc && (b.adler = u(b.adler, D.pending_buf, D.pending, 0)), D.gzindex = 0, D.status = 69) : (_t(D, 0), _t(D, 0), _t(D, 0), _t(D, 0), _t(D, 0), _t(D, D.level === 9 ? 2 : 2 <= D.strategy || D.level < 2 ? 4 : 0), _t(D, 3), D.status = Y);
        else {
          var q = C + (D.w_bits - 8 << 4) << 8;
          q |= (2 <= D.strategy || D.level < 2 ? 0 : D.level < 6 ? 1 : D.level === 6 ? 2 : 3) << 6, D.strstart !== 0 && (q |= 32), q += 31 - q % 31, D.status = Y, ht(D, q), D.strstart !== 0 && (ht(D, b.adler >>> 16), ht(D, 65535 & b.adler)), b.adler = 1;
        }
        if (D.status === 69) if (D.gzhead.extra) {
          for (A = D.pending; D.gzindex < (65535 & D.gzhead.extra.length) && (D.pending !== D.pending_buf_size || (D.gzhead.hcrc && D.pending > A && (b.adler = u(b.adler, D.pending_buf, D.pending - A, A)), Q(b), A = D.pending, D.pending !== D.pending_buf_size)); ) _t(D, 255 & D.gzhead.extra[D.gzindex]), D.gzindex++;
          D.gzhead.hcrc && D.pending > A && (b.adler = u(b.adler, D.pending_buf, D.pending - A, A)), D.gzindex === D.gzhead.extra.length && (D.gzindex = 0, D.status = 73);
        } else D.status = 73;
        if (D.status === 73) if (D.gzhead.name) {
          A = D.pending;
          do {
            if (D.pending === D.pending_buf_size && (D.gzhead.hcrc && D.pending > A && (b.adler = u(b.adler, D.pending_buf, D.pending - A, A)), Q(b), A = D.pending, D.pending === D.pending_buf_size)) {
              N = 1;
              break;
            }
            N = D.gzindex < D.gzhead.name.length ? 255 & D.gzhead.name.charCodeAt(D.gzindex++) : 0, _t(D, N);
          } while (N !== 0);
          D.gzhead.hcrc && D.pending > A && (b.adler = u(b.adler, D.pending_buf, D.pending - A, A)), N === 0 && (D.gzindex = 0, D.status = 91);
        } else D.status = 91;
        if (D.status === 91) if (D.gzhead.comment) {
          A = D.pending;
          do {
            if (D.pending === D.pending_buf_size && (D.gzhead.hcrc && D.pending > A && (b.adler = u(b.adler, D.pending_buf, D.pending - A, A)), Q(b), A = D.pending, D.pending === D.pending_buf_size)) {
              N = 1;
              break;
            }
            N = D.gzindex < D.gzhead.comment.length ? 255 & D.gzhead.comment.charCodeAt(D.gzindex++) : 0, _t(D, N);
          } while (N !== 0);
          D.gzhead.hcrc && D.pending > A && (b.adler = u(b.adler, D.pending_buf, D.pending - A, A)), N === 0 && (D.status = 103);
        } else D.status = 103;
        if (D.status === 103 && (D.gzhead.hcrc ? (D.pending + 2 > D.pending_buf_size && Q(b), D.pending + 2 <= D.pending_buf_size && (_t(D, 255 & b.adler), _t(D, b.adler >> 8 & 255), b.adler = 0, D.status = Y)) : D.status = Y), D.pending !== 0) {
          if (Q(b), b.avail_out === 0) return D.last_flush = -1, p;
        } else if (b.avail_in === 0 && Z(B) <= Z(R) && B !== m) return W(b, -5);
        if (D.status === 666 && b.avail_in !== 0) return W(b, -5);
        if (b.avail_in !== 0 || D.lookahead !== 0 || B !== f && D.status !== 666) {
          var J = D.strategy === 2 ? function(V, $) {
            for (var rt; ; ) {
              if (V.lookahead === 0 && (kt(V), V.lookahead === 0)) {
                if ($ === f) return M;
                break;
              }
              if (V.match_length = 0, rt = l._tr_tally(V, 0, V.window[V.strstart]), V.lookahead--, V.strstart++, rt && (at(V, !1), V.strm.avail_out === 0)) return M;
            }
            return V.insert = 0, $ === m ? (at(V, !0), V.strm.avail_out === 0 ? tt : U) : V.last_lit && (at(V, !1), V.strm.avail_out === 0) ? M : I;
          }(D, B) : D.strategy === 3 ? function(V, $) {
            for (var rt, ft, bt, Ft, Ot = V.window; ; ) {
              if (V.lookahead <= ot) {
                if (kt(V), V.lookahead <= ot && $ === f) return M;
                if (V.lookahead === 0) break;
              }
              if (V.match_length = 0, V.lookahead >= j && 0 < V.strstart && (ft = Ot[bt = V.strstart - 1]) === Ot[++bt] && ft === Ot[++bt] && ft === Ot[++bt]) {
                Ft = V.strstart + ot;
                do
                  ;
                while (ft === Ot[++bt] && ft === Ot[++bt] && ft === Ot[++bt] && ft === Ot[++bt] && ft === Ot[++bt] && ft === Ot[++bt] && ft === Ot[++bt] && ft === Ot[++bt] && bt < Ft);
                V.match_length = ot - (Ft - bt), V.match_length > V.lookahead && (V.match_length = V.lookahead);
              }
              if (V.match_length >= j ? (rt = l._tr_tally(V, 1, V.match_length - j), V.lookahead -= V.match_length, V.strstart += V.match_length, V.match_length = 0) : (rt = l._tr_tally(V, 0, V.window[V.strstart]), V.lookahead--, V.strstart++), rt && (at(V, !1), V.strm.avail_out === 0)) return M;
            }
            return V.insert = 0, $ === m ? (at(V, !0), V.strm.avail_out === 0 ? tt : U) : V.last_lit && (at(V, !1), V.strm.avail_out === 0) ? M : I;
          }(D, B) : o[D.level].func(D, B);
          if (J !== tt && J !== U || (D.status = 666), J === M || J === tt) return b.avail_out === 0 && (D.last_flush = -1), p;
          if (J === I && (B === 1 ? l._tr_align(D) : B !== 5 && (l._tr_stored_block(D, 0, 0, !1), B === 3 && (yt(D.head), D.lookahead === 0 && (D.strstart = 0, D.block_start = 0, D.insert = 0))), Q(b), b.avail_out === 0)) return D.last_flush = -1, p;
        }
        return B !== m ? p : D.wrap <= 0 ? 1 : (D.wrap === 2 ? (_t(D, 255 & b.adler), _t(D, b.adler >> 8 & 255), _t(D, b.adler >> 16 & 255), _t(D, b.adler >> 24 & 255), _t(D, 255 & b.total_in), _t(D, b.total_in >> 8 & 255), _t(D, b.total_in >> 16 & 255), _t(D, b.total_in >> 24 & 255)) : (ht(D, b.adler >>> 16), ht(D, 65535 & b.adler)), Q(b), 0 < D.wrap && (D.wrap = -D.wrap), D.pending !== 0 ? p : 1);
      }, i.deflateEnd = function(b) {
        var B;
        return b && b.state ? (B = b.state.status) !== L && B !== 69 && B !== 73 && B !== 91 && B !== 103 && B !== Y && B !== 666 ? W(b, y) : (b.state = null, B === Y ? W(b, -3) : p) : y;
      }, i.deflateSetDictionary = function(b, B) {
        var R, D, A, N, q, J, V, $, rt = B.length;
        if (!b || !b.state || (N = (R = b.state).wrap) === 2 || N === 1 && R.status !== L || R.lookahead) return y;
        for (N === 1 && (b.adler = c(b.adler, B, rt, 0)), R.wrap = 0, rt >= R.w_size && (N === 0 && (yt(R.head), R.strstart = 0, R.block_start = 0, R.insert = 0), $ = new a.Buf8(R.w_size), a.arraySet($, B, rt - R.w_size, R.w_size, 0), B = $, rt = R.w_size), q = b.avail_in, J = b.next_in, V = b.input, b.avail_in = rt, b.next_in = 0, b.input = B, kt(R); R.lookahead >= j; ) {
          for (D = R.strstart, A = R.lookahead - (j - 1); R.ins_h = (R.ins_h << R.hash_shift ^ R.window[D + j - 1]) & R.hash_mask, R.prev[D & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = D, D++, --A; ) ;
          R.strstart = D, R.lookahead = j - 1, kt(R);
        }
        return R.strstart += R.lookahead, R.block_start = R.strstart, R.insert = R.lookahead, R.lookahead = 0, R.match_length = R.prev_length = j - 1, R.match_available = 0, b.next_in = J, b.input = V, b.avail_in = q, R.wrap = N, p;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(n, s, i) {
      s.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(n, s, i) {
      s.exports = function(o, a) {
        var l, c, u, h, f, m, p, y, v, _, g, C, x, k, w, T, P, z, j, ot, vt, L, Y, M, I;
        l = o.state, c = o.next_in, M = o.input, u = c + (o.avail_in - 5), h = o.next_out, I = o.output, f = h - (a - o.avail_out), m = h + (o.avail_out - 257), p = l.dmax, y = l.wsize, v = l.whave, _ = l.wnext, g = l.window, C = l.hold, x = l.bits, k = l.lencode, w = l.distcode, T = (1 << l.lenbits) - 1, P = (1 << l.distbits) - 1;
        t: do {
          x < 15 && (C += M[c++] << x, x += 8, C += M[c++] << x, x += 8), z = k[C & T];
          e: for (; ; ) {
            if (C >>>= j = z >>> 24, x -= j, (j = z >>> 16 & 255) === 0) I[h++] = 65535 & z;
            else {
              if (!(16 & j)) {
                if (!(64 & j)) {
                  z = k[(65535 & z) + (C & (1 << j) - 1)];
                  continue e;
                }
                if (32 & j) {
                  l.mode = 12;
                  break t;
                }
                o.msg = "invalid literal/length code", l.mode = 30;
                break t;
              }
              ot = 65535 & z, (j &= 15) && (x < j && (C += M[c++] << x, x += 8), ot += C & (1 << j) - 1, C >>>= j, x -= j), x < 15 && (C += M[c++] << x, x += 8, C += M[c++] << x, x += 8), z = w[C & P];
              n: for (; ; ) {
                if (C >>>= j = z >>> 24, x -= j, !(16 & (j = z >>> 16 & 255))) {
                  if (!(64 & j)) {
                    z = w[(65535 & z) + (C & (1 << j) - 1)];
                    continue n;
                  }
                  o.msg = "invalid distance code", l.mode = 30;
                  break t;
                }
                if (vt = 65535 & z, x < (j &= 15) && (C += M[c++] << x, (x += 8) < j && (C += M[c++] << x, x += 8)), p < (vt += C & (1 << j) - 1)) {
                  o.msg = "invalid distance too far back", l.mode = 30;
                  break t;
                }
                if (C >>>= j, x -= j, (j = h - f) < vt) {
                  if (v < (j = vt - j) && l.sane) {
                    o.msg = "invalid distance too far back", l.mode = 30;
                    break t;
                  }
                  if (Y = g, (L = 0) === _) {
                    if (L += y - j, j < ot) {
                      for (ot -= j; I[h++] = g[L++], --j; ) ;
                      L = h - vt, Y = I;
                    }
                  } else if (_ < j) {
                    if (L += y + _ - j, (j -= _) < ot) {
                      for (ot -= j; I[h++] = g[L++], --j; ) ;
                      if (L = 0, _ < ot) {
                        for (ot -= j = _; I[h++] = g[L++], --j; ) ;
                        L = h - vt, Y = I;
                      }
                    }
                  } else if (L += _ - j, j < ot) {
                    for (ot -= j; I[h++] = g[L++], --j; ) ;
                    L = h - vt, Y = I;
                  }
                  for (; 2 < ot; ) I[h++] = Y[L++], I[h++] = Y[L++], I[h++] = Y[L++], ot -= 3;
                  ot && (I[h++] = Y[L++], 1 < ot && (I[h++] = Y[L++]));
                } else {
                  for (L = h - vt; I[h++] = I[L++], I[h++] = I[L++], I[h++] = I[L++], 2 < (ot -= 3); ) ;
                  ot && (I[h++] = I[L++], 1 < ot && (I[h++] = I[L++]));
                }
                break;
              }
            }
            break;
          }
        } while (c < u && h < m);
        c -= ot = x >> 3, C &= (1 << (x -= ot << 3)) - 1, o.next_in = c, o.next_out = h, o.avail_in = c < u ? u - c + 5 : 5 - (c - u), o.avail_out = h < m ? m - h + 257 : 257 - (h - m), l.hold = C, l.bits = x;
      };
    }, {}], 49: [function(n, s, i) {
      var o = n("../utils/common"), a = n("./adler32"), l = n("./crc32"), c = n("./inffast"), u = n("./inftrees"), h = 1, f = 2, m = 0, p = -2, y = 1, v = 852, _ = 592;
      function g(L) {
        return (L >>> 24 & 255) + (L >>> 8 & 65280) + ((65280 & L) << 8) + ((255 & L) << 24);
      }
      function C() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new o.Buf16(320), this.work = new o.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(L) {
        var Y;
        return L && L.state ? (Y = L.state, L.total_in = L.total_out = Y.total = 0, L.msg = "", Y.wrap && (L.adler = 1 & Y.wrap), Y.mode = y, Y.last = 0, Y.havedict = 0, Y.dmax = 32768, Y.head = null, Y.hold = 0, Y.bits = 0, Y.lencode = Y.lendyn = new o.Buf32(v), Y.distcode = Y.distdyn = new o.Buf32(_), Y.sane = 1, Y.back = -1, m) : p;
      }
      function k(L) {
        var Y;
        return L && L.state ? ((Y = L.state).wsize = 0, Y.whave = 0, Y.wnext = 0, x(L)) : p;
      }
      function w(L, Y) {
        var M, I;
        return L && L.state ? (I = L.state, Y < 0 ? (M = 0, Y = -Y) : (M = 1 + (Y >> 4), Y < 48 && (Y &= 15)), Y && (Y < 8 || 15 < Y) ? p : (I.window !== null && I.wbits !== Y && (I.window = null), I.wrap = M, I.wbits = Y, k(L))) : p;
      }
      function T(L, Y) {
        var M, I;
        return L ? (I = new C(), (L.state = I).window = null, (M = w(L, Y)) !== m && (L.state = null), M) : p;
      }
      var P, z, j = !0;
      function ot(L) {
        if (j) {
          var Y;
          for (P = new o.Buf32(512), z = new o.Buf32(32), Y = 0; Y < 144; ) L.lens[Y++] = 8;
          for (; Y < 256; ) L.lens[Y++] = 9;
          for (; Y < 280; ) L.lens[Y++] = 7;
          for (; Y < 288; ) L.lens[Y++] = 8;
          for (u(h, L.lens, 0, 288, P, 0, L.work, { bits: 9 }), Y = 0; Y < 32; ) L.lens[Y++] = 5;
          u(f, L.lens, 0, 32, z, 0, L.work, { bits: 5 }), j = !1;
        }
        L.lencode = P, L.lenbits = 9, L.distcode = z, L.distbits = 5;
      }
      function vt(L, Y, M, I) {
        var tt, U = L.state;
        return U.window === null && (U.wsize = 1 << U.wbits, U.wnext = 0, U.whave = 0, U.window = new o.Buf8(U.wsize)), I >= U.wsize ? (o.arraySet(U.window, Y, M - U.wsize, U.wsize, 0), U.wnext = 0, U.whave = U.wsize) : (I < (tt = U.wsize - U.wnext) && (tt = I), o.arraySet(U.window, Y, M - I, tt, U.wnext), (I -= tt) ? (o.arraySet(U.window, Y, M - I, I, 0), U.wnext = I, U.whave = U.wsize) : (U.wnext += tt, U.wnext === U.wsize && (U.wnext = 0), U.whave < U.wsize && (U.whave += tt))), 0;
      }
      i.inflateReset = k, i.inflateReset2 = w, i.inflateResetKeep = x, i.inflateInit = function(L) {
        return T(L, 15);
      }, i.inflateInit2 = T, i.inflate = function(L, Y) {
        var M, I, tt, U, W, Z, yt, Q, at, _t, ht, X, kt, lt, pt, it, E, O, S, F, b, B, R, D, A = 0, N = new o.Buf8(4), q = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!L || !L.state || !L.output || !L.input && L.avail_in !== 0) return p;
        (M = L.state).mode === 12 && (M.mode = 13), W = L.next_out, tt = L.output, yt = L.avail_out, U = L.next_in, I = L.input, Z = L.avail_in, Q = M.hold, at = M.bits, _t = Z, ht = yt, B = m;
        t: for (; ; ) switch (M.mode) {
          case y:
            if (M.wrap === 0) {
              M.mode = 13;
              break;
            }
            for (; at < 16; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            if (2 & M.wrap && Q === 35615) {
              N[M.check = 0] = 255 & Q, N[1] = Q >>> 8 & 255, M.check = l(M.check, N, 2, 0), at = Q = 0, M.mode = 2;
              break;
            }
            if (M.flags = 0, M.head && (M.head.done = !1), !(1 & M.wrap) || (((255 & Q) << 8) + (Q >> 8)) % 31) {
              L.msg = "incorrect header check", M.mode = 30;
              break;
            }
            if ((15 & Q) != 8) {
              L.msg = "unknown compression method", M.mode = 30;
              break;
            }
            if (at -= 4, b = 8 + (15 & (Q >>>= 4)), M.wbits === 0) M.wbits = b;
            else if (b > M.wbits) {
              L.msg = "invalid window size", M.mode = 30;
              break;
            }
            M.dmax = 1 << b, L.adler = M.check = 1, M.mode = 512 & Q ? 10 : 12, at = Q = 0;
            break;
          case 2:
            for (; at < 16; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            if (M.flags = Q, (255 & M.flags) != 8) {
              L.msg = "unknown compression method", M.mode = 30;
              break;
            }
            if (57344 & M.flags) {
              L.msg = "unknown header flags set", M.mode = 30;
              break;
            }
            M.head && (M.head.text = Q >> 8 & 1), 512 & M.flags && (N[0] = 255 & Q, N[1] = Q >>> 8 & 255, M.check = l(M.check, N, 2, 0)), at = Q = 0, M.mode = 3;
          case 3:
            for (; at < 32; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            M.head && (M.head.time = Q), 512 & M.flags && (N[0] = 255 & Q, N[1] = Q >>> 8 & 255, N[2] = Q >>> 16 & 255, N[3] = Q >>> 24 & 255, M.check = l(M.check, N, 4, 0)), at = Q = 0, M.mode = 4;
          case 4:
            for (; at < 16; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            M.head && (M.head.xflags = 255 & Q, M.head.os = Q >> 8), 512 & M.flags && (N[0] = 255 & Q, N[1] = Q >>> 8 & 255, M.check = l(M.check, N, 2, 0)), at = Q = 0, M.mode = 5;
          case 5:
            if (1024 & M.flags) {
              for (; at < 16; ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              M.length = Q, M.head && (M.head.extra_len = Q), 512 & M.flags && (N[0] = 255 & Q, N[1] = Q >>> 8 & 255, M.check = l(M.check, N, 2, 0)), at = Q = 0;
            } else M.head && (M.head.extra = null);
            M.mode = 6;
          case 6:
            if (1024 & M.flags && (Z < (X = M.length) && (X = Z), X && (M.head && (b = M.head.extra_len - M.length, M.head.extra || (M.head.extra = new Array(M.head.extra_len)), o.arraySet(M.head.extra, I, U, X, b)), 512 & M.flags && (M.check = l(M.check, I, X, U)), Z -= X, U += X, M.length -= X), M.length)) break t;
            M.length = 0, M.mode = 7;
          case 7:
            if (2048 & M.flags) {
              if (Z === 0) break t;
              for (X = 0; b = I[U + X++], M.head && b && M.length < 65536 && (M.head.name += String.fromCharCode(b)), b && X < Z; ) ;
              if (512 & M.flags && (M.check = l(M.check, I, X, U)), Z -= X, U += X, b) break t;
            } else M.head && (M.head.name = null);
            M.length = 0, M.mode = 8;
          case 8:
            if (4096 & M.flags) {
              if (Z === 0) break t;
              for (X = 0; b = I[U + X++], M.head && b && M.length < 65536 && (M.head.comment += String.fromCharCode(b)), b && X < Z; ) ;
              if (512 & M.flags && (M.check = l(M.check, I, X, U)), Z -= X, U += X, b) break t;
            } else M.head && (M.head.comment = null);
            M.mode = 9;
          case 9:
            if (512 & M.flags) {
              for (; at < 16; ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              if (Q !== (65535 & M.check)) {
                L.msg = "header crc mismatch", M.mode = 30;
                break;
              }
              at = Q = 0;
            }
            M.head && (M.head.hcrc = M.flags >> 9 & 1, M.head.done = !0), L.adler = M.check = 0, M.mode = 12;
            break;
          case 10:
            for (; at < 32; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            L.adler = M.check = g(Q), at = Q = 0, M.mode = 11;
          case 11:
            if (M.havedict === 0) return L.next_out = W, L.avail_out = yt, L.next_in = U, L.avail_in = Z, M.hold = Q, M.bits = at, 2;
            L.adler = M.check = 1, M.mode = 12;
          case 12:
            if (Y === 5 || Y === 6) break t;
          case 13:
            if (M.last) {
              Q >>>= 7 & at, at -= 7 & at, M.mode = 27;
              break;
            }
            for (; at < 3; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            switch (M.last = 1 & Q, at -= 1, 3 & (Q >>>= 1)) {
              case 0:
                M.mode = 14;
                break;
              case 1:
                if (ot(M), M.mode = 20, Y !== 6) break;
                Q >>>= 2, at -= 2;
                break t;
              case 2:
                M.mode = 17;
                break;
              case 3:
                L.msg = "invalid block type", M.mode = 30;
            }
            Q >>>= 2, at -= 2;
            break;
          case 14:
            for (Q >>>= 7 & at, at -= 7 & at; at < 32; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            if ((65535 & Q) != (Q >>> 16 ^ 65535)) {
              L.msg = "invalid stored block lengths", M.mode = 30;
              break;
            }
            if (M.length = 65535 & Q, at = Q = 0, M.mode = 15, Y === 6) break t;
          case 15:
            M.mode = 16;
          case 16:
            if (X = M.length) {
              if (Z < X && (X = Z), yt < X && (X = yt), X === 0) break t;
              o.arraySet(tt, I, U, X, W), Z -= X, U += X, yt -= X, W += X, M.length -= X;
              break;
            }
            M.mode = 12;
            break;
          case 17:
            for (; at < 14; ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            if (M.nlen = 257 + (31 & Q), Q >>>= 5, at -= 5, M.ndist = 1 + (31 & Q), Q >>>= 5, at -= 5, M.ncode = 4 + (15 & Q), Q >>>= 4, at -= 4, 286 < M.nlen || 30 < M.ndist) {
              L.msg = "too many length or distance symbols", M.mode = 30;
              break;
            }
            M.have = 0, M.mode = 18;
          case 18:
            for (; M.have < M.ncode; ) {
              for (; at < 3; ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              M.lens[q[M.have++]] = 7 & Q, Q >>>= 3, at -= 3;
            }
            for (; M.have < 19; ) M.lens[q[M.have++]] = 0;
            if (M.lencode = M.lendyn, M.lenbits = 7, R = { bits: M.lenbits }, B = u(0, M.lens, 0, 19, M.lencode, 0, M.work, R), M.lenbits = R.bits, B) {
              L.msg = "invalid code lengths set", M.mode = 30;
              break;
            }
            M.have = 0, M.mode = 19;
          case 19:
            for (; M.have < M.nlen + M.ndist; ) {
              for (; it = (A = M.lencode[Q & (1 << M.lenbits) - 1]) >>> 16 & 255, E = 65535 & A, !((pt = A >>> 24) <= at); ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              if (E < 16) Q >>>= pt, at -= pt, M.lens[M.have++] = E;
              else {
                if (E === 16) {
                  for (D = pt + 2; at < D; ) {
                    if (Z === 0) break t;
                    Z--, Q += I[U++] << at, at += 8;
                  }
                  if (Q >>>= pt, at -= pt, M.have === 0) {
                    L.msg = "invalid bit length repeat", M.mode = 30;
                    break;
                  }
                  b = M.lens[M.have - 1], X = 3 + (3 & Q), Q >>>= 2, at -= 2;
                } else if (E === 17) {
                  for (D = pt + 3; at < D; ) {
                    if (Z === 0) break t;
                    Z--, Q += I[U++] << at, at += 8;
                  }
                  at -= pt, b = 0, X = 3 + (7 & (Q >>>= pt)), Q >>>= 3, at -= 3;
                } else {
                  for (D = pt + 7; at < D; ) {
                    if (Z === 0) break t;
                    Z--, Q += I[U++] << at, at += 8;
                  }
                  at -= pt, b = 0, X = 11 + (127 & (Q >>>= pt)), Q >>>= 7, at -= 7;
                }
                if (M.have + X > M.nlen + M.ndist) {
                  L.msg = "invalid bit length repeat", M.mode = 30;
                  break;
                }
                for (; X--; ) M.lens[M.have++] = b;
              }
            }
            if (M.mode === 30) break;
            if (M.lens[256] === 0) {
              L.msg = "invalid code -- missing end-of-block", M.mode = 30;
              break;
            }
            if (M.lenbits = 9, R = { bits: M.lenbits }, B = u(h, M.lens, 0, M.nlen, M.lencode, 0, M.work, R), M.lenbits = R.bits, B) {
              L.msg = "invalid literal/lengths set", M.mode = 30;
              break;
            }
            if (M.distbits = 6, M.distcode = M.distdyn, R = { bits: M.distbits }, B = u(f, M.lens, M.nlen, M.ndist, M.distcode, 0, M.work, R), M.distbits = R.bits, B) {
              L.msg = "invalid distances set", M.mode = 30;
              break;
            }
            if (M.mode = 20, Y === 6) break t;
          case 20:
            M.mode = 21;
          case 21:
            if (6 <= Z && 258 <= yt) {
              L.next_out = W, L.avail_out = yt, L.next_in = U, L.avail_in = Z, M.hold = Q, M.bits = at, c(L, ht), W = L.next_out, tt = L.output, yt = L.avail_out, U = L.next_in, I = L.input, Z = L.avail_in, Q = M.hold, at = M.bits, M.mode === 12 && (M.back = -1);
              break;
            }
            for (M.back = 0; it = (A = M.lencode[Q & (1 << M.lenbits) - 1]) >>> 16 & 255, E = 65535 & A, !((pt = A >>> 24) <= at); ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            if (it && !(240 & it)) {
              for (O = pt, S = it, F = E; it = (A = M.lencode[F + ((Q & (1 << O + S) - 1) >> O)]) >>> 16 & 255, E = 65535 & A, !(O + (pt = A >>> 24) <= at); ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              Q >>>= O, at -= O, M.back += O;
            }
            if (Q >>>= pt, at -= pt, M.back += pt, M.length = E, it === 0) {
              M.mode = 26;
              break;
            }
            if (32 & it) {
              M.back = -1, M.mode = 12;
              break;
            }
            if (64 & it) {
              L.msg = "invalid literal/length code", M.mode = 30;
              break;
            }
            M.extra = 15 & it, M.mode = 22;
          case 22:
            if (M.extra) {
              for (D = M.extra; at < D; ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              M.length += Q & (1 << M.extra) - 1, Q >>>= M.extra, at -= M.extra, M.back += M.extra;
            }
            M.was = M.length, M.mode = 23;
          case 23:
            for (; it = (A = M.distcode[Q & (1 << M.distbits) - 1]) >>> 16 & 255, E = 65535 & A, !((pt = A >>> 24) <= at); ) {
              if (Z === 0) break t;
              Z--, Q += I[U++] << at, at += 8;
            }
            if (!(240 & it)) {
              for (O = pt, S = it, F = E; it = (A = M.distcode[F + ((Q & (1 << O + S) - 1) >> O)]) >>> 16 & 255, E = 65535 & A, !(O + (pt = A >>> 24) <= at); ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              Q >>>= O, at -= O, M.back += O;
            }
            if (Q >>>= pt, at -= pt, M.back += pt, 64 & it) {
              L.msg = "invalid distance code", M.mode = 30;
              break;
            }
            M.offset = E, M.extra = 15 & it, M.mode = 24;
          case 24:
            if (M.extra) {
              for (D = M.extra; at < D; ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              M.offset += Q & (1 << M.extra) - 1, Q >>>= M.extra, at -= M.extra, M.back += M.extra;
            }
            if (M.offset > M.dmax) {
              L.msg = "invalid distance too far back", M.mode = 30;
              break;
            }
            M.mode = 25;
          case 25:
            if (yt === 0) break t;
            if (X = ht - yt, M.offset > X) {
              if ((X = M.offset - X) > M.whave && M.sane) {
                L.msg = "invalid distance too far back", M.mode = 30;
                break;
              }
              kt = X > M.wnext ? (X -= M.wnext, M.wsize - X) : M.wnext - X, X > M.length && (X = M.length), lt = M.window;
            } else lt = tt, kt = W - M.offset, X = M.length;
            for (yt < X && (X = yt), yt -= X, M.length -= X; tt[W++] = lt[kt++], --X; ) ;
            M.length === 0 && (M.mode = 21);
            break;
          case 26:
            if (yt === 0) break t;
            tt[W++] = M.length, yt--, M.mode = 21;
            break;
          case 27:
            if (M.wrap) {
              for (; at < 32; ) {
                if (Z === 0) break t;
                Z--, Q |= I[U++] << at, at += 8;
              }
              if (ht -= yt, L.total_out += ht, M.total += ht, ht && (L.adler = M.check = M.flags ? l(M.check, tt, ht, W - ht) : a(M.check, tt, ht, W - ht)), ht = yt, (M.flags ? Q : g(Q)) !== M.check) {
                L.msg = "incorrect data check", M.mode = 30;
                break;
              }
              at = Q = 0;
            }
            M.mode = 28;
          case 28:
            if (M.wrap && M.flags) {
              for (; at < 32; ) {
                if (Z === 0) break t;
                Z--, Q += I[U++] << at, at += 8;
              }
              if (Q !== (4294967295 & M.total)) {
                L.msg = "incorrect length check", M.mode = 30;
                break;
              }
              at = Q = 0;
            }
            M.mode = 29;
          case 29:
            B = 1;
            break t;
          case 30:
            B = -3;
            break t;
          case 31:
            return -4;
          case 32:
          default:
            return p;
        }
        return L.next_out = W, L.avail_out = yt, L.next_in = U, L.avail_in = Z, M.hold = Q, M.bits = at, (M.wsize || ht !== L.avail_out && M.mode < 30 && (M.mode < 27 || Y !== 4)) && vt(L, L.output, L.next_out, ht - L.avail_out) ? (M.mode = 31, -4) : (_t -= L.avail_in, ht -= L.avail_out, L.total_in += _t, L.total_out += ht, M.total += ht, M.wrap && ht && (L.adler = M.check = M.flags ? l(M.check, tt, ht, L.next_out - ht) : a(M.check, tt, ht, L.next_out - ht)), L.data_type = M.bits + (M.last ? 64 : 0) + (M.mode === 12 ? 128 : 0) + (M.mode === 20 || M.mode === 15 ? 256 : 0), (_t == 0 && ht === 0 || Y === 4) && B === m && (B = -5), B);
      }, i.inflateEnd = function(L) {
        if (!L || !L.state) return p;
        var Y = L.state;
        return Y.window && (Y.window = null), L.state = null, m;
      }, i.inflateGetHeader = function(L, Y) {
        var M;
        return L && L.state && 2 & (M = L.state).wrap ? ((M.head = Y).done = !1, m) : p;
      }, i.inflateSetDictionary = function(L, Y) {
        var M, I = Y.length;
        return L && L.state ? (M = L.state).wrap !== 0 && M.mode !== 11 ? p : M.mode === 11 && a(1, Y, I, 0) !== M.check ? -3 : vt(L, Y, I, I) ? (M.mode = 31, -4) : (M.havedict = 1, m) : p;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(n, s, i) {
      var o = n("../utils/common"), a = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], c = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], u = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      s.exports = function(h, f, m, p, y, v, _, g) {
        var C, x, k, w, T, P, z, j, ot, vt = g.bits, L = 0, Y = 0, M = 0, I = 0, tt = 0, U = 0, W = 0, Z = 0, yt = 0, Q = 0, at = null, _t = 0, ht = new o.Buf16(16), X = new o.Buf16(16), kt = null, lt = 0;
        for (L = 0; L <= 15; L++) ht[L] = 0;
        for (Y = 0; Y < p; Y++) ht[f[m + Y]]++;
        for (tt = vt, I = 15; 1 <= I && ht[I] === 0; I--) ;
        if (I < tt && (tt = I), I === 0) return y[v++] = 20971520, y[v++] = 20971520, g.bits = 1, 0;
        for (M = 1; M < I && ht[M] === 0; M++) ;
        for (tt < M && (tt = M), L = Z = 1; L <= 15; L++) if (Z <<= 1, (Z -= ht[L]) < 0) return -1;
        if (0 < Z && (h === 0 || I !== 1)) return -1;
        for (X[1] = 0, L = 1; L < 15; L++) X[L + 1] = X[L] + ht[L];
        for (Y = 0; Y < p; Y++) f[m + Y] !== 0 && (_[X[f[m + Y]]++] = Y);
        if (P = h === 0 ? (at = kt = _, 19) : h === 1 ? (at = a, _t -= 257, kt = l, lt -= 257, 256) : (at = c, kt = u, -1), L = M, T = v, W = Y = Q = 0, k = -1, w = (yt = 1 << (U = tt)) - 1, h === 1 && 852 < yt || h === 2 && 592 < yt) return 1;
        for (; ; ) {
          for (z = L - W, ot = _[Y] < P ? (j = 0, _[Y]) : _[Y] > P ? (j = kt[lt + _[Y]], at[_t + _[Y]]) : (j = 96, 0), C = 1 << L - W, M = x = 1 << U; y[T + (Q >> W) + (x -= C)] = z << 24 | j << 16 | ot | 0, x !== 0; ) ;
          for (C = 1 << L - 1; Q & C; ) C >>= 1;
          if (C !== 0 ? (Q &= C - 1, Q += C) : Q = 0, Y++, --ht[L] == 0) {
            if (L === I) break;
            L = f[m + _[Y]];
          }
          if (tt < L && (Q & w) !== k) {
            for (W === 0 && (W = tt), T += M, Z = 1 << (U = L - W); U + W < I && !((Z -= ht[U + W]) <= 0); ) U++, Z <<= 1;
            if (yt += 1 << U, h === 1 && 852 < yt || h === 2 && 592 < yt) return 1;
            y[k = Q & w] = tt << 24 | U << 16 | T - v | 0;
          }
        }
        return Q !== 0 && (y[T + Q] = L - W << 24 | 64 << 16 | 0), g.bits = tt, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(n, s, i) {
      s.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(n, s, i) {
      var o = n("../utils/common"), a = 0, l = 1;
      function c(A) {
        for (var N = A.length; 0 <= --N; ) A[N] = 0;
      }
      var u = 0, h = 29, f = 256, m = f + 1 + h, p = 30, y = 19, v = 2 * m + 1, _ = 15, g = 16, C = 7, x = 256, k = 16, w = 17, T = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], z = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], j = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ot = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], vt = new Array(2 * (m + 2));
      c(vt);
      var L = new Array(2 * p);
      c(L);
      var Y = new Array(512);
      c(Y);
      var M = new Array(256);
      c(M);
      var I = new Array(h);
      c(I);
      var tt, U, W, Z = new Array(p);
      function yt(A, N, q, J, V) {
        this.static_tree = A, this.extra_bits = N, this.extra_base = q, this.elems = J, this.max_length = V, this.has_stree = A && A.length;
      }
      function Q(A, N) {
        this.dyn_tree = A, this.max_code = 0, this.stat_desc = N;
      }
      function at(A) {
        return A < 256 ? Y[A] : Y[256 + (A >>> 7)];
      }
      function _t(A, N) {
        A.pending_buf[A.pending++] = 255 & N, A.pending_buf[A.pending++] = N >>> 8 & 255;
      }
      function ht(A, N, q) {
        A.bi_valid > g - q ? (A.bi_buf |= N << A.bi_valid & 65535, _t(A, A.bi_buf), A.bi_buf = N >> g - A.bi_valid, A.bi_valid += q - g) : (A.bi_buf |= N << A.bi_valid & 65535, A.bi_valid += q);
      }
      function X(A, N, q) {
        ht(A, q[2 * N], q[2 * N + 1]);
      }
      function kt(A, N) {
        for (var q = 0; q |= 1 & A, A >>>= 1, q <<= 1, 0 < --N; ) ;
        return q >>> 1;
      }
      function lt(A, N, q) {
        var J, V, $ = new Array(_ + 1), rt = 0;
        for (J = 1; J <= _; J++) $[J] = rt = rt + q[J - 1] << 1;
        for (V = 0; V <= N; V++) {
          var ft = A[2 * V + 1];
          ft !== 0 && (A[2 * V] = kt($[ft]++, ft));
        }
      }
      function pt(A) {
        var N;
        for (N = 0; N < m; N++) A.dyn_ltree[2 * N] = 0;
        for (N = 0; N < p; N++) A.dyn_dtree[2 * N] = 0;
        for (N = 0; N < y; N++) A.bl_tree[2 * N] = 0;
        A.dyn_ltree[2 * x] = 1, A.opt_len = A.static_len = 0, A.last_lit = A.matches = 0;
      }
      function it(A) {
        8 < A.bi_valid ? _t(A, A.bi_buf) : 0 < A.bi_valid && (A.pending_buf[A.pending++] = A.bi_buf), A.bi_buf = 0, A.bi_valid = 0;
      }
      function E(A, N, q, J) {
        var V = 2 * N, $ = 2 * q;
        return A[V] < A[$] || A[V] === A[$] && J[N] <= J[q];
      }
      function O(A, N, q) {
        for (var J = A.heap[q], V = q << 1; V <= A.heap_len && (V < A.heap_len && E(N, A.heap[V + 1], A.heap[V], A.depth) && V++, !E(N, J, A.heap[V], A.depth)); ) A.heap[q] = A.heap[V], q = V, V <<= 1;
        A.heap[q] = J;
      }
      function S(A, N, q) {
        var J, V, $, rt, ft = 0;
        if (A.last_lit !== 0) for (; J = A.pending_buf[A.d_buf + 2 * ft] << 8 | A.pending_buf[A.d_buf + 2 * ft + 1], V = A.pending_buf[A.l_buf + ft], ft++, J === 0 ? X(A, V, N) : (X(A, ($ = M[V]) + f + 1, N), (rt = P[$]) !== 0 && ht(A, V -= I[$], rt), X(A, $ = at(--J), q), (rt = z[$]) !== 0 && ht(A, J -= Z[$], rt)), ft < A.last_lit; ) ;
        X(A, x, N);
      }
      function F(A, N) {
        var q, J, V, $ = N.dyn_tree, rt = N.stat_desc.static_tree, ft = N.stat_desc.has_stree, bt = N.stat_desc.elems, Ft = -1;
        for (A.heap_len = 0, A.heap_max = v, q = 0; q < bt; q++) $[2 * q] !== 0 ? (A.heap[++A.heap_len] = Ft = q, A.depth[q] = 0) : $[2 * q + 1] = 0;
        for (; A.heap_len < 2; ) $[2 * (V = A.heap[++A.heap_len] = Ft < 2 ? ++Ft : 0)] = 1, A.depth[V] = 0, A.opt_len--, ft && (A.static_len -= rt[2 * V + 1]);
        for (N.max_code = Ft, q = A.heap_len >> 1; 1 <= q; q--) O(A, $, q);
        for (V = bt; q = A.heap[1], A.heap[1] = A.heap[A.heap_len--], O(A, $, 1), J = A.heap[1], A.heap[--A.heap_max] = q, A.heap[--A.heap_max] = J, $[2 * V] = $[2 * q] + $[2 * J], A.depth[V] = (A.depth[q] >= A.depth[J] ? A.depth[q] : A.depth[J]) + 1, $[2 * q + 1] = $[2 * J + 1] = V, A.heap[1] = V++, O(A, $, 1), 2 <= A.heap_len; ) ;
        A.heap[--A.heap_max] = A.heap[1], function(Ot, Xt) {
          var de, he, Ce, Qt, Ln, ke, pe = Xt.dyn_tree, Ms = Xt.max_code, Ys = Xt.stat_desc.static_tree, ga = Xt.stat_desc.has_stree, va = Xt.stat_desc.extra_bits, Sr = Xt.stat_desc.extra_base, Os = Xt.stat_desc.max_length, Ks = 0;
          for (Qt = 0; Qt <= _; Qt++) Ot.bl_count[Qt] = 0;
          for (pe[2 * Ot.heap[Ot.heap_max] + 1] = 0, de = Ot.heap_max + 1; de < v; de++) Os < (Qt = pe[2 * pe[2 * (he = Ot.heap[de]) + 1] + 1] + 1) && (Qt = Os, Ks++), pe[2 * he + 1] = Qt, Ms < he || (Ot.bl_count[Qt]++, Ln = 0, Sr <= he && (Ln = va[he - Sr]), ke = pe[2 * he], Ot.opt_len += ke * (Qt + Ln), ga && (Ot.static_len += ke * (Ys[2 * he + 1] + Ln)));
          if (Ks !== 0) {
            do {
              for (Qt = Os - 1; Ot.bl_count[Qt] === 0; ) Qt--;
              Ot.bl_count[Qt]--, Ot.bl_count[Qt + 1] += 2, Ot.bl_count[Os]--, Ks -= 2;
            } while (0 < Ks);
            for (Qt = Os; Qt !== 0; Qt--) for (he = Ot.bl_count[Qt]; he !== 0; ) Ms < (Ce = Ot.heap[--de]) || (pe[2 * Ce + 1] !== Qt && (Ot.opt_len += (Qt - pe[2 * Ce + 1]) * pe[2 * Ce], pe[2 * Ce + 1] = Qt), he--);
          }
        }(A, N), lt($, Ft, A.bl_count);
      }
      function b(A, N, q) {
        var J, V, $ = -1, rt = N[1], ft = 0, bt = 7, Ft = 4;
        for (rt === 0 && (bt = 138, Ft = 3), N[2 * (q + 1) + 1] = 65535, J = 0; J <= q; J++) V = rt, rt = N[2 * (J + 1) + 1], ++ft < bt && V === rt || (ft < Ft ? A.bl_tree[2 * V] += ft : V !== 0 ? (V !== $ && A.bl_tree[2 * V]++, A.bl_tree[2 * k]++) : ft <= 10 ? A.bl_tree[2 * w]++ : A.bl_tree[2 * T]++, $ = V, Ft = (ft = 0) === rt ? (bt = 138, 3) : V === rt ? (bt = 6, 3) : (bt = 7, 4));
      }
      function B(A, N, q) {
        var J, V, $ = -1, rt = N[1], ft = 0, bt = 7, Ft = 4;
        for (rt === 0 && (bt = 138, Ft = 3), J = 0; J <= q; J++) if (V = rt, rt = N[2 * (J + 1) + 1], !(++ft < bt && V === rt)) {
          if (ft < Ft) for (; X(A, V, A.bl_tree), --ft != 0; ) ;
          else V !== 0 ? (V !== $ && (X(A, V, A.bl_tree), ft--), X(A, k, A.bl_tree), ht(A, ft - 3, 2)) : ft <= 10 ? (X(A, w, A.bl_tree), ht(A, ft - 3, 3)) : (X(A, T, A.bl_tree), ht(A, ft - 11, 7));
          $ = V, Ft = (ft = 0) === rt ? (bt = 138, 3) : V === rt ? (bt = 6, 3) : (bt = 7, 4);
        }
      }
      c(Z);
      var R = !1;
      function D(A, N, q, J) {
        ht(A, (u << 1) + (J ? 1 : 0), 3), function(V, $, rt, ft) {
          it(V), _t(V, rt), _t(V, ~rt), o.arraySet(V.pending_buf, V.window, $, rt, V.pending), V.pending += rt;
        }(A, N, q);
      }
      i._tr_init = function(A) {
        R || (function() {
          var N, q, J, V, $, rt = new Array(_ + 1);
          for (V = J = 0; V < h - 1; V++) for (I[V] = J, N = 0; N < 1 << P[V]; N++) M[J++] = V;
          for (M[J - 1] = V, V = $ = 0; V < 16; V++) for (Z[V] = $, N = 0; N < 1 << z[V]; N++) Y[$++] = V;
          for ($ >>= 7; V < p; V++) for (Z[V] = $ << 7, N = 0; N < 1 << z[V] - 7; N++) Y[256 + $++] = V;
          for (q = 0; q <= _; q++) rt[q] = 0;
          for (N = 0; N <= 143; ) vt[2 * N + 1] = 8, N++, rt[8]++;
          for (; N <= 255; ) vt[2 * N + 1] = 9, N++, rt[9]++;
          for (; N <= 279; ) vt[2 * N + 1] = 7, N++, rt[7]++;
          for (; N <= 287; ) vt[2 * N + 1] = 8, N++, rt[8]++;
          for (lt(vt, m + 1, rt), N = 0; N < p; N++) L[2 * N + 1] = 5, L[2 * N] = kt(N, 5);
          tt = new yt(vt, P, f + 1, m, _), U = new yt(L, z, 0, p, _), W = new yt(new Array(0), j, 0, y, C);
        }(), R = !0), A.l_desc = new Q(A.dyn_ltree, tt), A.d_desc = new Q(A.dyn_dtree, U), A.bl_desc = new Q(A.bl_tree, W), A.bi_buf = 0, A.bi_valid = 0, pt(A);
      }, i._tr_stored_block = D, i._tr_flush_block = function(A, N, q, J) {
        var V, $, rt = 0;
        0 < A.level ? (A.strm.data_type === 2 && (A.strm.data_type = function(ft) {
          var bt, Ft = 4093624447;
          for (bt = 0; bt <= 31; bt++, Ft >>>= 1) if (1 & Ft && ft.dyn_ltree[2 * bt] !== 0) return a;
          if (ft.dyn_ltree[18] !== 0 || ft.dyn_ltree[20] !== 0 || ft.dyn_ltree[26] !== 0) return l;
          for (bt = 32; bt < f; bt++) if (ft.dyn_ltree[2 * bt] !== 0) return l;
          return a;
        }(A)), F(A, A.l_desc), F(A, A.d_desc), rt = function(ft) {
          var bt;
          for (b(ft, ft.dyn_ltree, ft.l_desc.max_code), b(ft, ft.dyn_dtree, ft.d_desc.max_code), F(ft, ft.bl_desc), bt = y - 1; 3 <= bt && ft.bl_tree[2 * ot[bt] + 1] === 0; bt--) ;
          return ft.opt_len += 3 * (bt + 1) + 5 + 5 + 4, bt;
        }(A), V = A.opt_len + 3 + 7 >>> 3, ($ = A.static_len + 3 + 7 >>> 3) <= V && (V = $)) : V = $ = q + 5, q + 4 <= V && N !== -1 ? D(A, N, q, J) : A.strategy === 4 || $ === V ? (ht(A, 2 + (J ? 1 : 0), 3), S(A, vt, L)) : (ht(A, 4 + (J ? 1 : 0), 3), function(ft, bt, Ft, Ot) {
          var Xt;
          for (ht(ft, bt - 257, 5), ht(ft, Ft - 1, 5), ht(ft, Ot - 4, 4), Xt = 0; Xt < Ot; Xt++) ht(ft, ft.bl_tree[2 * ot[Xt] + 1], 3);
          B(ft, ft.dyn_ltree, bt - 1), B(ft, ft.dyn_dtree, Ft - 1);
        }(A, A.l_desc.max_code + 1, A.d_desc.max_code + 1, rt + 1), S(A, A.dyn_ltree, A.dyn_dtree)), pt(A), J && it(A);
      }, i._tr_tally = function(A, N, q) {
        return A.pending_buf[A.d_buf + 2 * A.last_lit] = N >>> 8 & 255, A.pending_buf[A.d_buf + 2 * A.last_lit + 1] = 255 & N, A.pending_buf[A.l_buf + A.last_lit] = 255 & q, A.last_lit++, N === 0 ? A.dyn_ltree[2 * q]++ : (A.matches++, N--, A.dyn_ltree[2 * (M[q] + f + 1)]++, A.dyn_dtree[2 * at(N)]++), A.last_lit === A.lit_bufsize - 1;
      }, i._tr_align = function(A) {
        ht(A, 2, 3), X(A, x, vt), function(N) {
          N.bi_valid === 16 ? (_t(N, N.bi_buf), N.bi_buf = 0, N.bi_valid = 0) : 8 <= N.bi_valid && (N.pending_buf[N.pending++] = 255 & N.bi_buf, N.bi_buf >>= 8, N.bi_valid -= 8);
        }(A);
      };
    }, { "../utils/common": 41 }], 53: [function(n, s, i) {
      s.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(n, s, i) {
      (function(o) {
        (function(a, l) {
          if (!a.setImmediate) {
            var c, u, h, f, m = 1, p = {}, y = !1, v = a.document, _ = Object.getPrototypeOf && Object.getPrototypeOf(a);
            _ = _ && _.setTimeout ? _ : a, c = {}.toString.call(a.process) === "[object process]" ? function(k) {
              process.nextTick(function() {
                C(k);
              });
            } : function() {
              if (a.postMessage && !a.importScripts) {
                var k = !0, w = a.onmessage;
                return a.onmessage = function() {
                  k = !1;
                }, a.postMessage("", "*"), a.onmessage = w, k;
              }
            }() ? (f = "setImmediate$" + Math.random() + "$", a.addEventListener ? a.addEventListener("message", x, !1) : a.attachEvent("onmessage", x), function(k) {
              a.postMessage(f + k, "*");
            }) : a.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(k) {
              C(k.data);
            }, function(k) {
              h.port2.postMessage(k);
            }) : v && "onreadystatechange" in v.createElement("script") ? (u = v.documentElement, function(k) {
              var w = v.createElement("script");
              w.onreadystatechange = function() {
                C(k), w.onreadystatechange = null, u.removeChild(w), w = null;
              }, u.appendChild(w);
            }) : function(k) {
              setTimeout(C, 0, k);
            }, _.setImmediate = function(k) {
              typeof k != "function" && (k = new Function("" + k));
              for (var w = new Array(arguments.length - 1), T = 0; T < w.length; T++) w[T] = arguments[T + 1];
              var P = { callback: k, args: w };
              return p[m] = P, c(m), m++;
            }, _.clearImmediate = g;
          }
          function g(k) {
            delete p[k];
          }
          function C(k) {
            if (y) setTimeout(C, 0, k);
            else {
              var w = p[k];
              if (w) {
                y = !0;
                try {
                  (function(T) {
                    var P = T.callback, z = T.args;
                    switch (z.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(z[0]);
                        break;
                      case 2:
                        P(z[0], z[1]);
                        break;
                      case 3:
                        P(z[0], z[1], z[2]);
                        break;
                      default:
                        P.apply(l, z);
                    }
                  })(w);
                } finally {
                  g(k), y = !1;
                }
              }
            }
          }
          function x(k) {
            k.source === a && typeof k.data == "string" && k.data.indexOf(f) === 0 && C(+k.data.slice(f.length));
          }
        })(typeof self > "u" ? o === void 0 ? this : o : self);
      }).call(this, typeof oo < "u" ? oo : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(cf);
var u3 = cf.exports;
const h3 = /* @__PURE__ */ c3(u3), d3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: h3
}, Symbol.toStringTag, { value: "Module" }));
export {
  Vu as mountApp,
  p3 as sendToComfyUI
};
