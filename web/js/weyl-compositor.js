var s1 = Object.defineProperty;
var r1 = (s, e, n) => e in s ? s1(s, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : s[e] = n;
var fe = (s, e, n) => r1(s, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function of(s) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of s.split(",")) e[n] = 1;
  return (n) => n in e;
}
const en = {}, Do = [], rs = () => {
}, vg = () => !1, du = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // uppercase letter
(s.charCodeAt(2) > 122 || s.charCodeAt(2) < 97), af = (s) => s.startsWith("onUpdate:"), Zn = Object.assign, lf = (s, e) => {
  const n = s.indexOf(e);
  n > -1 && s.splice(n, 1);
}, o1 = Object.prototype.hasOwnProperty, Xt = (s, e) => o1.call(s, e), _t = Array.isArray, ko = (s) => xl(s) === "[object Map]", Zo = (s) => xl(s) === "[object Set]", gp = (s) => xl(s) === "[object Date]", Ct = (s) => typeof s == "function", yn = (s) => typeof s == "string", Wi = (s) => typeof s == "symbol", tn = (s) => s !== null && typeof s == "object", gg = (s) => (tn(s) || Ct(s)) && Ct(s.then) && Ct(s.catch), yg = Object.prototype.toString, xl = (s) => yg.call(s), a1 = (s) => xl(s).slice(8, -1), xg = (s) => xl(s) === "[object Object]", hu = (s) => yn(s) && s !== "NaN" && s[0] !== "-" && "" + parseInt(s, 10) === s, Ua = /* @__PURE__ */ of(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), fu = (s) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = s(n));
}, l1 = /-\w/g, Di = fu(
  (s) => s.replace(l1, (e) => e.slice(1).toUpperCase())
), c1 = /\B([A-Z])/g, ur = fu(
  (s) => s.replace(c1, "-$1").toLowerCase()
), pu = fu((s) => s.charAt(0).toUpperCase() + s.slice(1)), Xu = fu(
  (s) => s ? `on${pu(s)}` : ""
), rr = (s, e) => !Object.is(s, e), Pc = (s, ...e) => {
  for (let n = 0; n < s.length; n++)
    s[n](...e);
}, _g = (s, e, n, i = !1) => {
  Object.defineProperty(s, e, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: n
  });
}, mu = (s) => {
  const e = parseFloat(s);
  return isNaN(e) ? s : e;
};
let yp;
const vu = () => yp || (yp = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function yt(s) {
  if (_t(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++) {
      const i = s[n], r = yn(i) ? f1(i) : yt(i);
      if (r)
        for (const o in r)
          e[o] = r[o];
    }
    return e;
  } else if (yn(s) || tn(s))
    return s;
}
const u1 = /;(?![^(]*\))/g, d1 = /:([^]+)/, h1 = /\/\*[^]*?\*\//g;
function f1(s) {
  const e = {};
  return s.replace(h1, "").split(u1).forEach((n) => {
    if (n) {
      const i = n.split(d1);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Fe(s) {
  let e = "";
  if (yn(s))
    e = s;
  else if (_t(s))
    for (let n = 0; n < s.length; n++) {
      const i = Fe(s[n]);
      i && (e += i + " ");
    }
  else if (tn(s))
    for (const n in s)
      s[n] && (e += n + " ");
  return e.trim();
}
const p1 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", m1 = /* @__PURE__ */ of(p1);
function bg(s) {
  return !!s || s === "";
}
function v1(s, e) {
  if (s.length !== e.length) return !1;
  let n = !0;
  for (let i = 0; n && i < s.length; i++)
    n = _l(s[i], e[i]);
  return n;
}
function _l(s, e) {
  if (s === e) return !0;
  let n = gp(s), i = gp(e);
  if (n || i)
    return n && i ? s.getTime() === e.getTime() : !1;
  if (n = Wi(s), i = Wi(e), n || i)
    return s === e;
  if (n = _t(s), i = _t(e), n || i)
    return n && i ? v1(s, e) : !1;
  if (n = tn(s), i = tn(e), n || i) {
    if (!n || !i)
      return !1;
    const r = Object.keys(s).length, o = Object.keys(e).length;
    if (r !== o)
      return !1;
    for (const a in s) {
      const l = s.hasOwnProperty(a), c = e.hasOwnProperty(a);
      if (l && !c || !l && c || !_l(s[a], e[a]))
        return !1;
    }
  }
  return String(s) === String(e);
}
function cf(s, e) {
  return s.findIndex((n) => _l(n, e));
}
const wg = (s) => !!(s && s.__v_isRef === !0), _e = (s) => yn(s) ? s : s == null ? "" : _t(s) || tn(s) && (s.toString === yg || !Ct(s.toString)) ? wg(s) ? _e(s.value) : JSON.stringify(s, Sg, 2) : String(s), Sg = (s, e) => wg(e) ? Sg(s, e.value) : ko(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [i, r], o) => (n[ju(i, o) + " =>"] = r, n),
    {}
  )
} : Zo(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => ju(n))
} : Wi(e) ? ju(e) : tn(e) && !_t(e) && !xg(e) ? String(e) : e, ju = (s, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Wi(s) ? `Symbol(${(n = s.description) != null ? n : e})` : s
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Xn;
class Mg {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Xn, !e && Xn && (this.index = (Xn.scopes || (Xn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = Xn;
      try {
        return Xn = this, e();
      } finally {
        Xn = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Xn, Xn = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Xn = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, i;
      for (n = 0, i = this.effects.length; n < i; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, i = this.cleanups.length; n < i; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, i = this.scopes.length; n < i; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Cg(s) {
  return new Mg(s);
}
function Tg() {
  return Xn;
}
function g1(s, e = !1) {
  Xn && Xn.cleanups.push(s);
}
let nn;
const Yu = /* @__PURE__ */ new WeakSet();
class Eg {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Xn && Xn.active && Xn.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Yu.has(this) && (Yu.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Pg(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, xp(this), Rg(this);
    const e = nn, n = $i;
    nn = this, $i = !0;
    try {
      return this.fn();
    } finally {
      Dg(this), nn = e, $i = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        hf(e);
      this.deps = this.depsTail = void 0, xp(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Yu.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Kd(this) && this.run();
  }
  get dirty() {
    return Kd(this);
  }
}
let Ag = 0, Oa, za;
function Pg(s, e = !1) {
  if (s.flags |= 8, e) {
    s.next = za, za = s;
    return;
  }
  s.next = Oa, Oa = s;
}
function uf() {
  Ag++;
}
function df() {
  if (--Ag > 0)
    return;
  if (za) {
    let e = za;
    for (za = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let s;
  for (; Oa; ) {
    let e = Oa;
    for (Oa = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (i) {
          s || (s = i);
        }
      e = n;
    }
  }
  if (s) throw s;
}
function Rg(s) {
  for (let e = s.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function Dg(s) {
  let e, n = s.depsTail, i = n;
  for (; i; ) {
    const r = i.prevDep;
    i.version === -1 ? (i === n && (n = r), hf(i), y1(i)) : e = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = r;
  }
  s.deps = e, s.depsTail = n;
}
function Kd(s) {
  for (let e = s.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (kg(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!s._dirty;
}
function kg(s) {
  if (s.flags & 4 && !(s.flags & 16) || (s.flags &= -17, s.globalVersion === Qa) || (s.globalVersion = Qa, !s.isSSR && s.flags & 128 && (!s.deps && !s._dirty || !Kd(s))))
    return;
  s.flags |= 2;
  const e = s.dep, n = nn, i = $i;
  nn = s, $i = !0;
  try {
    Rg(s);
    const r = s.fn(s._value);
    (e.version === 0 || rr(r, s._value)) && (s.flags |= 128, s._value = r, e.version++);
  } catch (r) {
    throw e.version++, r;
  } finally {
    nn = n, $i = i, Dg(s), s.flags &= -3;
  }
}
function hf(s, e = !1) {
  const { dep: n, prevSub: i, nextSub: r } = s;
  if (i && (i.nextSub = r, s.prevSub = void 0), r && (r.prevSub = i, s.nextSub = void 0), n.subs === s && (n.subs = i, !i && n.computed)) {
    n.computed.flags &= -5;
    for (let o = n.computed.deps; o; o = o.nextDep)
      hf(o, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function y1(s) {
  const { prevDep: e, nextDep: n } = s;
  e && (e.nextDep = n, s.prevDep = void 0), n && (n.prevDep = e, s.nextDep = void 0);
}
let $i = !0;
const Ig = [];
function Ds() {
  Ig.push($i), $i = !1;
}
function ks() {
  const s = Ig.pop();
  $i = s === void 0 ? !0 : s;
}
function xp(s) {
  const { cleanup: e } = s;
  if (s.cleanup = void 0, e) {
    const n = nn;
    nn = void 0;
    try {
      e();
    } finally {
      nn = n;
    }
  }
}
let Qa = 0;
class x1 {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ff {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!nn || !$i || nn === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== nn)
      n = this.activeLink = new x1(nn, this), nn.deps ? (n.prevDep = nn.depsTail, nn.depsTail.nextDep = n, nn.depsTail = n) : nn.deps = nn.depsTail = n, Lg(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const i = n.nextDep;
      i.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = i), n.prevDep = nn.depsTail, n.nextDep = void 0, nn.depsTail.nextDep = n, nn.depsTail = n, nn.deps === n && (nn.deps = i);
    }
    return n;
  }
  trigger(e) {
    this.version++, Qa++, this.notify(e);
  }
  notify(e) {
    uf();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      df();
    }
  }
}
function Lg(s) {
  if (s.dep.sc++, s.sub.flags & 4) {
    const e = s.dep.computed;
    if (e && !s.dep.subs) {
      e.flags |= 20;
      for (let i = e.deps; i; i = i.nextDep)
        Lg(i);
    }
    const n = s.dep.subs;
    n !== s && (s.prevSub = n, n && (n.nextSub = s)), s.dep.subs = s;
  }
}
const $c = /* @__PURE__ */ new WeakMap(), Nr = Symbol(
  ""
), Jd = Symbol(
  ""
), el = Symbol(
  ""
);
function Yn(s, e, n) {
  if ($i && nn) {
    let i = $c.get(s);
    i || $c.set(s, i = /* @__PURE__ */ new Map());
    let r = i.get(n);
    r || (i.set(n, r = new ff()), r.map = i, r.key = n), r.track();
  }
}
function Ms(s, e, n, i, r, o) {
  const a = $c.get(s);
  if (!a) {
    Qa++;
    return;
  }
  const l = (c) => {
    c && c.trigger();
  };
  if (uf(), e === "clear")
    a.forEach(l);
  else {
    const c = _t(s), u = c && hu(n);
    if (c && n === "length") {
      const d = Number(i);
      a.forEach((h, m) => {
        (m === "length" || m === el || !Wi(m) && m >= d) && l(h);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && l(a.get(n)), u && l(a.get(el)), e) {
        case "add":
          c ? u && l(a.get("length")) : (l(a.get(Nr)), ko(s) && l(a.get(Jd)));
          break;
        case "delete":
          c || (l(a.get(Nr)), ko(s) && l(a.get(Jd)));
          break;
        case "set":
          ko(s) && l(a.get(Nr));
          break;
      }
  }
  df();
}
function _1(s, e) {
  const n = $c.get(s);
  return n && n.get(e);
}
function Jr(s) {
  const e = Nt(s);
  return e === s ? e : (Yn(e, "iterate", el), wi(s) ? e : e.map(Xi));
}
function gu(s) {
  return Yn(s = Nt(s), "iterate", el), s;
}
function er(s, e) {
  return Is(s) ? Es(s) ? Oo(Xi(e)) : Oo(e) : Xi(e);
}
const b1 = {
  __proto__: null,
  [Symbol.iterator]() {
    return qu(this, Symbol.iterator, (s) => er(this, s));
  },
  concat(...s) {
    return Jr(this).concat(
      ...s.map((e) => _t(e) ? Jr(e) : e)
    );
  },
  entries() {
    return qu(this, "entries", (s) => (s[1] = er(this, s[1]), s));
  },
  every(s, e) {
    return ds(this, "every", s, e, void 0, arguments);
  },
  filter(s, e) {
    return ds(
      this,
      "filter",
      s,
      e,
      (n) => n.map((i) => er(this, i)),
      arguments
    );
  },
  find(s, e) {
    return ds(
      this,
      "find",
      s,
      e,
      (n) => er(this, n),
      arguments
    );
  },
  findIndex(s, e) {
    return ds(this, "findIndex", s, e, void 0, arguments);
  },
  findLast(s, e) {
    return ds(
      this,
      "findLast",
      s,
      e,
      (n) => er(this, n),
      arguments
    );
  },
  findLastIndex(s, e) {
    return ds(this, "findLastIndex", s, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(s, e) {
    return ds(this, "forEach", s, e, void 0, arguments);
  },
  includes(...s) {
    return Zu(this, "includes", s);
  },
  indexOf(...s) {
    return Zu(this, "indexOf", s);
  },
  join(s) {
    return Jr(this).join(s);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...s) {
    return Zu(this, "lastIndexOf", s);
  },
  map(s, e) {
    return ds(this, "map", s, e, void 0, arguments);
  },
  pop() {
    return ua(this, "pop");
  },
  push(...s) {
    return ua(this, "push", s);
  },
  reduce(s, ...e) {
    return _p(this, "reduce", s, e);
  },
  reduceRight(s, ...e) {
    return _p(this, "reduceRight", s, e);
  },
  shift() {
    return ua(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(s, e) {
    return ds(this, "some", s, e, void 0, arguments);
  },
  splice(...s) {
    return ua(this, "splice", s);
  },
  toReversed() {
    return Jr(this).toReversed();
  },
  toSorted(s) {
    return Jr(this).toSorted(s);
  },
  toSpliced(...s) {
    return Jr(this).toSpliced(...s);
  },
  unshift(...s) {
    return ua(this, "unshift", s);
  },
  values() {
    return qu(this, "values", (s) => er(this, s));
  }
};
function qu(s, e, n) {
  const i = gu(s), r = i[e]();
  return i !== s && !wi(s) && (r._next = r.next, r.next = () => {
    const o = r._next();
    return o.done || (o.value = n(o.value)), o;
  }), r;
}
const w1 = Array.prototype;
function ds(s, e, n, i, r, o) {
  const a = gu(s), l = a !== s && !wi(s), c = a[e];
  if (c !== w1[e]) {
    const h = c.apply(s, o);
    return l ? Xi(h) : h;
  }
  let u = n;
  a !== s && (l ? u = function(h, m) {
    return n.call(this, er(s, h), m, s);
  } : n.length > 2 && (u = function(h, m) {
    return n.call(this, h, m, s);
  }));
  const d = c.call(a, u, i);
  return l && r ? r(d) : d;
}
function _p(s, e, n, i) {
  const r = gu(s);
  let o = n;
  return r !== s && (wi(s) ? n.length > 3 && (o = function(a, l, c) {
    return n.call(this, a, l, c, s);
  }) : o = function(a, l, c) {
    return n.call(this, a, er(s, l), c, s);
  }), r[e](o, ...i);
}
function Zu(s, e, n) {
  const i = Nt(s);
  Yn(i, "iterate", el);
  const r = i[e](...n);
  return (r === -1 || r === !1) && yu(n[0]) ? (n[0] = Nt(n[0]), i[e](...n)) : r;
}
function ua(s, e, n = []) {
  Ds(), uf();
  const i = Nt(s)[e].apply(s, n);
  return df(), ks(), i;
}
const S1 = /* @__PURE__ */ of("__proto__,__v_isRef,__isVue"), Fg = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((s) => s !== "arguments" && s !== "caller").map((s) => Symbol[s]).filter(Wi)
);
function M1(s) {
  Wi(s) || (s = String(s));
  const e = Nt(this);
  return Yn(e, "has", s), e.hasOwnProperty(s);
}
class Ug {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, i) {
    if (n === "__v_skip") return e.__v_skip;
    const r = this._isReadonly, o = this._isShallow;
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return o;
    if (n === "__v_raw")
      return i === (r ? o ? L1 : Bg : o ? Ng : zg).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
    const a = _t(e);
    if (!r) {
      let c;
      if (a && (c = b1[n]))
        return c;
      if (n === "hasOwnProperty")
        return M1;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      gn(e) ? e : i
    );
    if ((Wi(n) ? Fg.has(n) : S1(n)) || (r || Yn(e, "get", n), o))
      return l;
    if (gn(l)) {
      const c = a && hu(n) ? l : l.value;
      return r && tn(c) ? eh(c) : c;
    }
    return tn(l) ? r ? eh(l) : $r(l) : l;
  }
}
class Og extends Ug {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, i, r) {
    let o = e[n];
    const a = _t(e) && hu(n);
    if (!this._isShallow) {
      const u = Is(o);
      if (!wi(i) && !Is(i) && (o = Nt(o), i = Nt(i)), !a && gn(o) && !gn(i))
        return u || (o.value = i), !0;
    }
    const l = a ? Number(n) < e.length : Xt(e, n), c = Reflect.set(
      e,
      n,
      i,
      gn(e) ? e : r
    );
    return e === Nt(r) && (l ? rr(i, o) && Ms(e, "set", n, i) : Ms(e, "add", n, i)), c;
  }
  deleteProperty(e, n) {
    const i = Xt(e, n);
    e[n];
    const r = Reflect.deleteProperty(e, n);
    return r && i && Ms(e, "delete", n, void 0), r;
  }
  has(e, n) {
    const i = Reflect.has(e, n);
    return (!Wi(n) || !Fg.has(n)) && Yn(e, "has", n), i;
  }
  ownKeys(e) {
    return Yn(
      e,
      "iterate",
      _t(e) ? "length" : Nr
    ), Reflect.ownKeys(e);
  }
}
class C1 extends Ug {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return !0;
  }
  deleteProperty(e, n) {
    return !0;
  }
}
const T1 = /* @__PURE__ */ new Og(), E1 = /* @__PURE__ */ new C1(), A1 = /* @__PURE__ */ new Og(!0);
const Qd = (s) => s, Fl = (s) => Reflect.getPrototypeOf(s);
function P1(s, e, n) {
  return function(...i) {
    const r = this.__v_raw, o = Nt(r), a = ko(o), l = s === "entries" || s === Symbol.iterator && a, c = s === "keys" && a, u = r[s](...i), d = n ? Qd : e ? Oo : Xi;
    return !e && Yn(
      o,
      "iterate",
      c ? Jd : Nr
    ), {
      // iterator protocol
      next() {
        const { value: h, done: m } = u.next();
        return m ? { value: h, done: m } : {
          value: l ? [d(h[0]), d(h[1])] : d(h),
          done: m
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ul(s) {
  return function(...e) {
    return s === "delete" ? !1 : s === "clear" ? void 0 : this;
  };
}
function R1(s, e) {
  const n = {
    get(r) {
      const o = this.__v_raw, a = Nt(o), l = Nt(r);
      s || (rr(r, l) && Yn(a, "get", r), Yn(a, "get", l));
      const { has: c } = Fl(a), u = e ? Qd : s ? Oo : Xi;
      if (c.call(a, r))
        return u(o.get(r));
      if (c.call(a, l))
        return u(o.get(l));
      o !== a && o.get(r);
    },
    get size() {
      const r = this.__v_raw;
      return !s && Yn(Nt(r), "iterate", Nr), r.size;
    },
    has(r) {
      const o = this.__v_raw, a = Nt(o), l = Nt(r);
      return s || (rr(r, l) && Yn(a, "has", r), Yn(a, "has", l)), r === l ? o.has(r) : o.has(r) || o.has(l);
    },
    forEach(r, o) {
      const a = this, l = a.__v_raw, c = Nt(l), u = e ? Qd : s ? Oo : Xi;
      return !s && Yn(c, "iterate", Nr), l.forEach((d, h) => r.call(o, u(d), u(h), a));
    }
  };
  return Zn(
    n,
    s ? {
      add: Ul("add"),
      set: Ul("set"),
      delete: Ul("delete"),
      clear: Ul("clear")
    } : {
      add(r) {
        !e && !wi(r) && !Is(r) && (r = Nt(r));
        const o = Nt(this);
        return Fl(o).has.call(o, r) || (o.add(r), Ms(o, "add", r, r)), this;
      },
      set(r, o) {
        !e && !wi(o) && !Is(o) && (o = Nt(o));
        const a = Nt(this), { has: l, get: c } = Fl(a);
        let u = l.call(a, r);
        u || (r = Nt(r), u = l.call(a, r));
        const d = c.call(a, r);
        return a.set(r, o), u ? rr(o, d) && Ms(a, "set", r, o) : Ms(a, "add", r, o), this;
      },
      delete(r) {
        const o = Nt(this), { has: a, get: l } = Fl(o);
        let c = a.call(o, r);
        c || (r = Nt(r), c = a.call(o, r)), l && l.call(o, r);
        const u = o.delete(r);
        return c && Ms(o, "delete", r, void 0), u;
      },
      clear() {
        const r = Nt(this), o = r.size !== 0, a = r.clear();
        return o && Ms(
          r,
          "clear",
          void 0,
          void 0
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((r) => {
    n[r] = P1(r, s, e);
  }), n;
}
function pf(s, e) {
  const n = R1(s, e);
  return (i, r, o) => r === "__v_isReactive" ? !s : r === "__v_isReadonly" ? s : r === "__v_raw" ? i : Reflect.get(
    Xt(n, r) && r in i ? n : i,
    r,
    o
  );
}
const D1 = {
  get: /* @__PURE__ */ pf(!1, !1)
}, k1 = {
  get: /* @__PURE__ */ pf(!1, !0)
}, I1 = {
  get: /* @__PURE__ */ pf(!0, !1)
};
const zg = /* @__PURE__ */ new WeakMap(), Ng = /* @__PURE__ */ new WeakMap(), Bg = /* @__PURE__ */ new WeakMap(), L1 = /* @__PURE__ */ new WeakMap();
function F1(s) {
  switch (s) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function U1(s) {
  return s.__v_skip || !Object.isExtensible(s) ? 0 : F1(a1(s));
}
function $r(s) {
  return Is(s) ? s : mf(
    s,
    !1,
    T1,
    D1,
    zg
  );
}
function O1(s) {
  return mf(
    s,
    !1,
    A1,
    k1,
    Ng
  );
}
function eh(s) {
  return mf(
    s,
    !0,
    E1,
    I1,
    Bg
  );
}
function mf(s, e, n, i, r) {
  if (!tn(s) || s.__v_raw && !(e && s.__v_isReactive))
    return s;
  const o = U1(s);
  if (o === 0)
    return s;
  const a = r.get(s);
  if (a)
    return a;
  const l = new Proxy(
    s,
    o === 2 ? i : n
  );
  return r.set(s, l), l;
}
function Es(s) {
  return Is(s) ? Es(s.__v_raw) : !!(s && s.__v_isReactive);
}
function Is(s) {
  return !!(s && s.__v_isReadonly);
}
function wi(s) {
  return !!(s && s.__v_isShallow);
}
function yu(s) {
  return s ? !!s.__v_raw : !1;
}
function Nt(s) {
  const e = s && s.__v_raw;
  return e ? Nt(e) : s;
}
function Ss(s) {
  return !Xt(s, "__v_skip") && Object.isExtensible(s) && _g(s, "__v_skip", !0), s;
}
const Xi = (s) => tn(s) ? $r(s) : s, Oo = (s) => tn(s) ? eh(s) : s;
function gn(s) {
  return s ? s.__v_isRef === !0 : !1;
}
function we(s) {
  return Vg(s, !1);
}
function z1(s) {
  return Vg(s, !0);
}
function Vg(s, e) {
  return gn(s) ? s : new N1(s, e);
}
class N1 {
  constructor(e, n) {
    this.dep = new ff(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : Nt(e), this._value = n ? e : Xi(e), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, i = this.__v_isShallow || wi(e) || Is(e);
    e = i ? e : Nt(e), rr(e, n) && (this._rawValue = e, this._value = i ? e : Xi(e), this.dep.trigger());
  }
}
function Ve(s) {
  return gn(s) ? s.value : s;
}
const B1 = {
  get: (s, e, n) => e === "__v_raw" ? s : Ve(Reflect.get(s, e, n)),
  set: (s, e, n, i) => {
    const r = s[e];
    return gn(r) && !gn(n) ? (r.value = n, !0) : Reflect.set(s, e, n, i);
  }
};
function Gg(s) {
  return Es(s) ? s : new Proxy(s, B1);
}
function V1(s) {
  const e = _t(s) ? new Array(s.length) : {};
  for (const n in s)
    e[n] = H1(s, n);
  return e;
}
class G1 {
  constructor(e, n, i) {
    this._object = e, this._key = n, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0, this._raw = Nt(e);
    let r = !0, o = e;
    if (!_t(e) || !hu(String(n)))
      do
        r = !yu(o) || wi(o);
      while (r && (o = o.__v_raw));
    this._shallow = r;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = Ve(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && gn(this._raw[this._key])) {
      const n = this._object[this._key];
      if (gn(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return _1(this._raw, this._key);
  }
}
function H1(s, e, n) {
  return new G1(s, e, n);
}
class $1 {
  constructor(e, n, i) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new ff(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Qa - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    nn !== this)
      return Pg(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return kg(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function W1(s, e, n = !1) {
  let i, r;
  return Ct(s) ? i = s : (i = s.get, r = s.set), new $1(i, r, n);
}
const Ol = {}, Wc = /* @__PURE__ */ new WeakMap();
let Er;
function X1(s, e = !1, n = Er) {
  if (n) {
    let i = Wc.get(n);
    i || Wc.set(n, i = []), i.push(s);
  }
}
function j1(s, e, n = en) {
  const { immediate: i, deep: r, once: o, scheduler: a, augmentJob: l, call: c } = n, u = (b) => r ? b : wi(b) || r === !1 || r === 0 ? Cs(b, 1) : Cs(b);
  let d, h, m, p, v = !1, _ = !1;
  if (gn(s) ? (h = () => s.value, v = wi(s)) : Es(s) ? (h = () => u(s), v = !0) : _t(s) ? (_ = !0, v = s.some((b) => Es(b) || wi(b)), h = () => s.map((b) => {
    if (gn(b))
      return b.value;
    if (Es(b))
      return u(b);
    if (Ct(b))
      return c ? c(b, 2) : b();
  })) : Ct(s) ? e ? h = c ? () => c(s, 2) : s : h = () => {
    if (m) {
      Ds();
      try {
        m();
      } finally {
        ks();
      }
    }
    const b = Er;
    Er = d;
    try {
      return c ? c(s, 3, [p]) : s(p);
    } finally {
      Er = b;
    }
  } : h = rs, e && r) {
    const b = h, C = r === !0 ? 1 / 0 : r;
    h = () => Cs(b(), C);
  }
  const g = Tg(), x = () => {
    d.stop(), g && g.active && lf(g.effects, d);
  };
  if (o && e) {
    const b = e;
    e = (...C) => {
      b(...C), x();
    };
  }
  let M = _ ? new Array(s.length).fill(Ol) : Ol;
  const S = (b) => {
    if (!(!(d.flags & 1) || !d.dirty && !b))
      if (e) {
        const C = d.run();
        if (r || v || (_ ? C.some((T, P) => rr(T, M[P])) : rr(C, M))) {
          m && m();
          const T = Er;
          Er = d;
          try {
            const P = [
              C,
              // pass undefined as the old value when it's changed for the first time
              M === Ol ? void 0 : _ && M[0] === Ol ? [] : M,
              p
            ];
            M = C, c ? c(e, 3, P) : (
              // @ts-expect-error
              e(...P)
            );
          } finally {
            Er = T;
          }
        }
      } else
        d.run();
  };
  return l && l(S), d = new Eg(h), d.scheduler = a ? () => a(S, !1) : S, p = (b) => X1(b, !1, d), m = d.onStop = () => {
    const b = Wc.get(d);
    if (b) {
      if (c)
        c(b, 4);
      else
        for (const C of b) C();
      Wc.delete(d);
    }
  }, e ? i ? S(!0) : M = d.run() : a ? a(S.bind(null, !0), !0) : d.run(), x.pause = d.pause.bind(d), x.resume = d.resume.bind(d), x.stop = x, x;
}
function Cs(s, e = 1 / 0, n) {
  if (e <= 0 || !tn(s) || s.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(s) || 0) >= e))
    return s;
  if (n.set(s, e), e--, gn(s))
    Cs(s.value, e, n);
  else if (_t(s))
    for (let i = 0; i < s.length; i++)
      Cs(s[i], e, n);
  else if (Zo(s) || ko(s))
    s.forEach((i) => {
      Cs(i, e, n);
    });
  else if (xg(s)) {
    for (const i in s)
      Cs(s[i], e, n);
    for (const i of Object.getOwnPropertySymbols(s))
      Object.prototype.propertyIsEnumerable.call(s, i) && Cs(s[i], e, n);
  }
  return s;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function bl(s, e, n, i) {
  try {
    return i ? s(...i) : s();
  } catch (r) {
    xu(r, e, n);
  }
}
function as(s, e, n, i) {
  if (Ct(s)) {
    const r = bl(s, e, n, i);
    return r && gg(r) && r.catch((o) => {
      xu(o, e, n);
    }), r;
  }
  if (_t(s)) {
    const r = [];
    for (let o = 0; o < s.length; o++)
      r.push(as(s[o], e, n, i));
    return r;
  }
}
function xu(s, e, n, i = !0) {
  const r = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: a } = e && e.appContext.config || en;
  if (e) {
    let l = e.parent;
    const c = e.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const d = l.ec;
      if (d) {
        for (let h = 0; h < d.length; h++)
          if (d[h](s, c, u) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      Ds(), bl(o, null, 10, [
        s,
        c,
        u
      ]), ks();
      return;
    }
  }
  Y1(s, n, r, i, a);
}
function Y1(s, e, n, i = !0, r = !1) {
  if (r)
    throw s;
  console.error(s);
}
const ii = [];
let ts = -1;
const Io = [];
let tr = null, wo = 0;
const Hg = /* @__PURE__ */ Promise.resolve();
let Xc = null;
function Pi(s) {
  const e = Xc || Hg;
  return s ? e.then(this ? s.bind(this) : s) : e;
}
function q1(s) {
  let e = ts + 1, n = ii.length;
  for (; e < n; ) {
    const i = e + n >>> 1, r = ii[i], o = tl(r);
    o < s || o === s && r.flags & 2 ? e = i + 1 : n = i;
  }
  return e;
}
function vf(s) {
  if (!(s.flags & 1)) {
    const e = tl(s), n = ii[ii.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(s.flags & 2) && e >= tl(n) ? ii.push(s) : ii.splice(q1(e), 0, s), s.flags |= 1, $g();
  }
}
function $g() {
  Xc || (Xc = Hg.then(Xg));
}
function Z1(s) {
  _t(s) ? Io.push(...s) : tr && s.id === -1 ? tr.splice(wo + 1, 0, s) : s.flags & 1 || (Io.push(s), s.flags |= 1), $g();
}
function bp(s, e, n = ts + 1) {
  for (; n < ii.length; n++) {
    const i = ii[n];
    if (i && i.flags & 2) {
      if (s && i.id !== s.uid)
        continue;
      ii.splice(n, 1), n--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function Wg(s) {
  if (Io.length) {
    const e = [...new Set(Io)].sort(
      (n, i) => tl(n) - tl(i)
    );
    if (Io.length = 0, tr) {
      tr.push(...e);
      return;
    }
    for (tr = e, wo = 0; wo < tr.length; wo++) {
      const n = tr[wo];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    tr = null, wo = 0;
  }
}
const tl = (s) => s.id == null ? s.flags & 2 ? -1 : 1 / 0 : s.id;
function Xg(s) {
  try {
    for (ts = 0; ts < ii.length; ts++) {
      const e = ii[ts];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), bl(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; ts < ii.length; ts++) {
      const e = ii[ts];
      e && (e.flags &= -2);
    }
    ts = -1, ii.length = 0, Wg(), Xc = null, (ii.length || Io.length) && Xg();
  }
}
let Un = null, jg = null;
function jc(s) {
  const e = Un;
  return Un = s, jg = s && s.type.__scopeId || null, e;
}
function Ni(s, e = Un, n) {
  if (!e || s._n)
    return s;
  const i = (...r) => {
    i._d && Zc(-1);
    const o = jc(e);
    let a;
    try {
      a = s(...r);
    } finally {
      jc(o), i._d && Zc(1);
    }
    return a;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function st(s, e) {
  if (Un === null)
    return s;
  const n = Mu(Un), i = s.dirs || (s.dirs = []);
  for (let r = 0; r < e.length; r++) {
    let [o, a, l, c = en] = e[r];
    o && (Ct(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Cs(a), i.push({
      dir: o,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: c
    }));
  }
  return s;
}
function pr(s, e, n, i) {
  const r = s.dirs, o = e && e.dirs;
  for (let a = 0; a < r.length; a++) {
    const l = r[a];
    o && (l.oldValue = o[a].value);
    let c = l.dir[i];
    c && (Ds(), as(c, n, 8, [
      s.el,
      l,
      s,
      e
    ]), ks());
  }
}
const Yg = Symbol("_vte"), K1 = (s) => s.__isTeleport, Na = (s) => s && (s.disabled || s.disabled === ""), wp = (s) => s && (s.defer || s.defer === ""), Sp = (s) => typeof SVGElement < "u" && s instanceof SVGElement, Mp = (s) => typeof MathMLElement == "function" && s instanceof MathMLElement, th = (s, e) => {
  const n = s && s.to;
  return yn(n) ? e ? e(n) : null : n;
}, qg = {
  name: "Teleport",
  __isTeleport: !0,
  process(s, e, n, i, r, o, a, l, c, u) {
    const {
      mc: d,
      pc: h,
      pbc: m,
      o: { insert: p, querySelector: v, createText: _, createComment: g }
    } = u, x = Na(e.props);
    let { shapeFlag: M, children: S, dynamicChildren: b } = e;
    if (s == null) {
      const C = e.el = _(""), T = e.anchor = _("");
      p(C, n, i), p(T, n, i);
      const P = (y, w) => {
        M & 16 && d(
          S,
          y,
          w,
          r,
          o,
          a,
          l,
          c
        );
      }, E = () => {
        const y = e.target = th(e.props, v), w = Zg(y, e, _, p);
        y && (a !== "svg" && Sp(y) ? a = "svg" : a !== "mathml" && Mp(y) && (a = "mathml"), r && r.isCE && (r.ce._teleportTargets || (r.ce._teleportTargets = /* @__PURE__ */ new Set())).add(y), x || (P(y, w), Rc(e, !1)));
      };
      x && (P(n, T), Rc(e, !0)), wp(e.props) ? (e.el.__isMounted = !1, ti(() => {
        E(), delete e.el.__isMounted;
      }, o)) : E();
    } else {
      if (wp(e.props) && s.el.__isMounted === !1) {
        ti(() => {
          qg.process(
            s,
            e,
            n,
            i,
            r,
            o,
            a,
            l,
            c,
            u
          );
        }, o);
        return;
      }
      e.el = s.el, e.targetStart = s.targetStart;
      const C = e.anchor = s.anchor, T = e.target = s.target, P = e.targetAnchor = s.targetAnchor, E = Na(s.props), y = E ? n : T, w = E ? C : P;
      if (a === "svg" || Sp(T) ? a = "svg" : (a === "mathml" || Mp(T)) && (a = "mathml"), b ? (m(
        s.dynamicChildren,
        b,
        y,
        r,
        o,
        a,
        l
      ), bf(s, e, !0)) : c || h(
        s,
        e,
        y,
        w,
        r,
        o,
        a,
        l,
        !1
      ), x)
        E ? e.props && s.props && e.props.to !== s.props.to && (e.props.to = s.props.to) : zl(
          e,
          n,
          C,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (s.props && s.props.to)) {
        const D = e.target = th(
          e.props,
          v
        );
        D && zl(
          e,
          D,
          null,
          u,
          0
        );
      } else E && zl(
        e,
        T,
        P,
        u,
        1
      );
      Rc(e, x);
    }
  },
  remove(s, e, n, { um: i, o: { remove: r } }, o) {
    const {
      shapeFlag: a,
      children: l,
      anchor: c,
      targetStart: u,
      targetAnchor: d,
      target: h,
      props: m
    } = s;
    if (h && (r(u), r(d)), o && r(c), a & 16) {
      const p = o || !Na(m);
      for (let v = 0; v < l.length; v++) {
        const _ = l[v];
        i(
          _,
          e,
          n,
          p,
          !!_.dynamicChildren
        );
      }
    }
  },
  move: zl,
  hydrate: J1
};
function zl(s, e, n, { o: { insert: i }, m: r }, o = 2) {
  o === 0 && i(s.targetAnchor, e, n);
  const { el: a, anchor: l, shapeFlag: c, children: u, props: d } = s, h = o === 2;
  if (h && i(a, e, n), (!h || Na(d)) && c & 16)
    for (let m = 0; m < u.length; m++)
      r(
        u[m],
        e,
        n,
        2
      );
  h && i(l, e, n);
}
function J1(s, e, n, i, r, o, {
  o: { nextSibling: a, parentNode: l, querySelector: c, insert: u, createText: d }
}, h) {
  function m(_, g, x, M) {
    g.anchor = h(
      a(_),
      g,
      l(_),
      n,
      i,
      r,
      o
    ), g.targetStart = x, g.targetAnchor = M;
  }
  const p = e.target = th(
    e.props,
    c
  ), v = Na(e.props);
  if (p) {
    const _ = p._lpa || p.firstChild;
    if (e.shapeFlag & 16)
      if (v)
        m(
          s,
          e,
          _,
          _ && a(_)
        );
      else {
        e.anchor = a(s);
        let g = _;
        for (; g; ) {
          if (g && g.nodeType === 8) {
            if (g.data === "teleport start anchor")
              e.targetStart = g;
            else if (g.data === "teleport anchor") {
              e.targetAnchor = g, p._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          g = a(g);
        }
        e.targetAnchor || Zg(p, e, d, u), h(
          _ && a(_),
          e,
          p,
          n,
          i,
          r,
          o
        );
      }
    Rc(e, v);
  } else v && e.shapeFlag & 16 && m(s, e, s, a(s));
  return e.anchor && a(e.anchor);
}
const zo = qg;
function Rc(s, e) {
  const n = s.ctx;
  if (n && n.ut) {
    let i, r;
    for (e ? (i = s.el, r = s.anchor) : (i = s.targetStart, r = s.targetAnchor); i && i !== r; )
      i.nodeType === 1 && i.setAttribute("data-v-owner", n.uid), i = i.nextSibling;
    n.ut();
  }
}
function Zg(s, e, n, i) {
  const r = e.targetStart = n(""), o = e.targetAnchor = n("");
  return r[Yg] = o, s && (i(r, s), i(o, s)), o;
}
const Q1 = Symbol("_leaveCb");
function gf(s, e) {
  s.shapeFlag & 6 && s.component ? (s.transition = e, gf(s.component.subTree, e)) : s.shapeFlag & 128 ? (s.ssContent.transition = e.clone(s.ssContent), s.ssFallback.transition = e.clone(s.ssFallback)) : s.transition = e;
}
// @__NO_SIDE_EFFECTS__
function Ot(s, e) {
  return Ct(s) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Zn({ name: s.name }, e, { setup: s })
  ) : s;
}
function Kg(s) {
  s.ids = [s.ids[0] + s.ids[2]++ + "-", 0, 0];
}
const Yc = /* @__PURE__ */ new WeakMap();
function Ba(s, e, n, i, r = !1) {
  if (_t(s)) {
    s.forEach(
      (v, _) => Ba(
        v,
        e && (_t(e) ? e[_] : e),
        n,
        i,
        r
      )
    );
    return;
  }
  if (Lo(i) && !r) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && Ba(s, e, n, i.component.subTree);
    return;
  }
  const o = i.shapeFlag & 4 ? Mu(i.component) : i.el, a = r ? null : o, { i: l, r: c } = s, u = e && e.r, d = l.refs === en ? l.refs = {} : l.refs, h = l.setupState, m = Nt(h), p = h === en ? vg : (v) => Xt(m, v);
  if (u != null && u !== c) {
    if (Cp(e), yn(u))
      d[u] = null, p(u) && (h[u] = null);
    else if (gn(u)) {
      u.value = null;
      const v = e;
      v.k && (d[v.k] = null);
    }
  }
  if (Ct(c))
    bl(c, l, 12, [a, d]);
  else {
    const v = yn(c), _ = gn(c);
    if (v || _) {
      const g = () => {
        if (s.f) {
          const x = v ? p(c) ? h[c] : d[c] : c.value;
          if (r)
            _t(x) && lf(x, o);
          else if (_t(x))
            x.includes(o) || x.push(o);
          else if (v)
            d[c] = [o], p(c) && (h[c] = d[c]);
          else {
            const M = [o];
            c.value = M, s.k && (d[s.k] = M);
          }
        } else v ? (d[c] = a, p(c) && (h[c] = a)) : _ && (c.value = a, s.k && (d[s.k] = a));
      };
      if (a) {
        const x = () => {
          g(), Yc.delete(s);
        };
        x.id = -1, Yc.set(s, x), ti(x, n);
      } else
        Cp(s), g();
    }
  }
}
function Cp(s) {
  const e = Yc.get(s);
  e && (e.flags |= 8, Yc.delete(s));
}
vu().requestIdleCallback;
vu().cancelIdleCallback;
const Lo = (s) => !!s.type.__asyncLoader, Jg = (s) => s.type.__isKeepAlive;
function ex(s, e) {
  Qg(s, "a", e);
}
function tx(s, e) {
  Qg(s, "da", e);
}
function Qg(s, e, n = qn) {
  const i = s.__wdc || (s.__wdc = () => {
    let r = n;
    for (; r; ) {
      if (r.isDeactivated)
        return;
      r = r.parent;
    }
    return s();
  });
  if (_u(e, i, n), n) {
    let r = n.parent;
    for (; r && r.parent; )
      Jg(r.parent.vnode) && nx(i, e, n, r), r = r.parent;
  }
}
function nx(s, e, n, i) {
  const r = _u(
    e,
    s,
    i,
    !0
    /* prepend */
  );
  Nn(() => {
    lf(i[e], r);
  }, n);
}
function _u(s, e, n = qn, i = !1) {
  if (n) {
    const r = n[s] || (n[s] = []), o = e.__weh || (e.__weh = (...a) => {
      Ds();
      const l = wl(n), c = as(e, n, s, a);
      return l(), ks(), c;
    });
    return i ? r.unshift(o) : r.push(o), o;
  }
}
const Fs = (s) => (e, n = qn) => {
  (!sl || s === "sp") && _u(s, (...i) => e(...i), n);
}, ix = Fs("bm"), xn = Fs("m"), sx = Fs(
  "bu"
), rx = Fs("u"), yf = Fs(
  "bum"
), Nn = Fs("um"), ox = Fs(
  "sp"
), ax = Fs("rtg"), lx = Fs("rtc");
function cx(s, e = qn) {
  _u("ec", s, e);
}
const ux = "components", e0 = Symbol.for("v-ndc");
function t0(s) {
  return yn(s) ? dx(ux, s, !1) || s : s || e0;
}
function dx(s, e, n = !0, i = !1) {
  const r = Un || qn;
  if (r) {
    const o = r.type;
    {
      const l = t_(
        o,
        !1
      );
      if (l && (l === e || l === Di(e) || l === pu(Di(e))))
        return o;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      Tp(r[s] || o[s], e) || // global registration
      Tp(r.appContext[s], e)
    );
    return !a && i ? o : a;
  }
}
function Tp(s, e) {
  return s && (s[e] || s[Di(e)] || s[pu(Di(e))]);
}
function ot(s, e, n, i) {
  let r;
  const o = n, a = _t(s);
  if (a || yn(s)) {
    const l = a && Es(s);
    let c = !1, u = !1;
    l && (c = !wi(s), u = Is(s), s = gu(s)), r = new Array(s.length);
    for (let d = 0, h = s.length; d < h; d++)
      r[d] = e(
        c ? u ? Oo(Xi(s[d])) : Xi(s[d]) : s[d],
        d,
        void 0,
        o
      );
  } else if (typeof s == "number") {
    r = new Array(s);
    for (let l = 0; l < s; l++)
      r[l] = e(l + 1, l, void 0, o);
  } else if (tn(s))
    if (s[Symbol.iterator])
      r = Array.from(
        s,
        (l, c) => e(l, c, void 0, o)
      );
    else {
      const l = Object.keys(s);
      r = new Array(l.length);
      for (let c = 0, u = l.length; c < u; c++) {
        const d = l[c];
        r[c] = e(s[d], d, c, o);
      }
    }
  else
    r = [];
  return r;
}
function hx(s, e, n = {}, i, r) {
  if (Un.ce || Un.parent && Lo(Un.parent) && Un.parent.ce) {
    const u = Object.keys(n).length > 0;
    return te(), St(
      qe,
      null,
      [ze("slot", n, i)],
      u ? -2 : 64
    );
  }
  let o = s[e];
  o && o._c && (o._d = !1), te();
  const a = o && n0(o(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, c = St(
    qe,
    {
      key: (l && !Wi(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && i ? "_fb" : "")
    },
    a || [],
    a && s._ === 1 ? 64 : -2
  );
  return c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), o && o._c && (o._d = !0), c;
}
function n0(s) {
  return s.some((e) => il(e) ? !(e.type === Ls || e.type === qe && !n0(e.children)) : !0) ? s : null;
}
const nh = (s) => s ? b0(s) ? Mu(s) : nh(s.parent) : null, Va = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Zn(/* @__PURE__ */ Object.create(null), {
    $: (s) => s,
    $el: (s) => s.vnode.el,
    $data: (s) => s.data,
    $props: (s) => s.props,
    $attrs: (s) => s.attrs,
    $slots: (s) => s.slots,
    $refs: (s) => s.refs,
    $parent: (s) => nh(s.parent),
    $root: (s) => nh(s.root),
    $host: (s) => s.ce,
    $emit: (s) => s.emit,
    $options: (s) => s0(s),
    $forceUpdate: (s) => s.f || (s.f = () => {
      vf(s.update);
    }),
    $nextTick: (s) => s.n || (s.n = Pi.bind(s.proxy)),
    $watch: (s) => Tx.bind(s)
  })
), Ku = (s, e) => s !== en && !s.__isScriptSetup && Xt(s, e), fx = {
  get({ _: s }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: i, data: r, props: o, accessCache: a, type: l, appContext: c } = s;
    if (e[0] !== "$") {
      const m = a[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return i[e];
          case 2:
            return r[e];
          case 4:
            return n[e];
          case 3:
            return o[e];
        }
      else {
        if (Ku(i, e))
          return a[e] = 1, i[e];
        if (r !== en && Xt(r, e))
          return a[e] = 2, r[e];
        if (Xt(o, e))
          return a[e] = 3, o[e];
        if (n !== en && Xt(n, e))
          return a[e] = 4, n[e];
        ih && (a[e] = 0);
      }
    }
    const u = Va[e];
    let d, h;
    if (u)
      return e === "$attrs" && Yn(s.attrs, "get", ""), u(s);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[e])
    )
      return d;
    if (n !== en && Xt(n, e))
      return a[e] = 4, n[e];
    if (
      // global properties
      h = c.config.globalProperties, Xt(h, e)
    )
      return h[e];
  },
  set({ _: s }, e, n) {
    const { data: i, setupState: r, ctx: o } = s;
    return Ku(r, e) ? (r[e] = n, !0) : i !== en && Xt(i, e) ? (i[e] = n, !0) : Xt(s.props, e) || e[0] === "$" && e.slice(1) in s ? !1 : (o[e] = n, !0);
  },
  has({
    _: { data: s, setupState: e, accessCache: n, ctx: i, appContext: r, props: o, type: a }
  }, l) {
    let c;
    return !!(n[l] || s !== en && l[0] !== "$" && Xt(s, l) || Ku(e, l) || Xt(o, l) || Xt(i, l) || Xt(Va, l) || Xt(r.config.globalProperties, l) || (c = a.__cssModules) && c[l]);
  },
  defineProperty(s, e, n) {
    return n.get != null ? s._.accessCache[e] = 0 : Xt(n, "value") && this.set(s, e, n.value, null), Reflect.defineProperty(s, e, n);
  }
};
function px() {
  return mx().slots;
}
function mx(s) {
  const e = Su();
  return e.setupContext || (e.setupContext = S0(e));
}
function Ep(s) {
  return _t(s) ? s.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : s;
}
let ih = !0;
function vx(s) {
  const e = s0(s), n = s.proxy, i = s.ctx;
  ih = !1, e.beforeCreate && Ap(e.beforeCreate, s, "bc");
  const {
    // state
    data: r,
    computed: o,
    methods: a,
    watch: l,
    provide: c,
    inject: u,
    // lifecycle
    created: d,
    beforeMount: h,
    mounted: m,
    beforeUpdate: p,
    updated: v,
    activated: _,
    deactivated: g,
    beforeDestroy: x,
    beforeUnmount: M,
    destroyed: S,
    unmounted: b,
    render: C,
    renderTracked: T,
    renderTriggered: P,
    errorCaptured: E,
    serverPrefetch: y,
    // public API
    expose: w,
    inheritAttrs: D,
    // assets
    components: U,
    directives: R,
    filters: O
  } = e;
  if (u && gx(u, i, null), a)
    for (const ue in a) {
      const Q = a[ue];
      Ct(Q) && (i[ue] = Q.bind(n));
    }
  if (r) {
    const ue = r.call(n, n);
    tn(ue) && (s.data = $r(ue));
  }
  if (ih = !0, o)
    for (const ue in o) {
      const Q = o[ue], le = Ct(Q) ? Q.bind(n, n) : Ct(Q.get) ? Q.get.bind(n, n) : rs, re = !Ct(Q) && Ct(Q.set) ? Q.set.bind(n) : rs, j = Ie({
        get: le,
        set: re
      });
      Object.defineProperty(i, ue, {
        enumerable: !0,
        configurable: !0,
        get: () => j.value,
        set: ($) => j.value = $
      });
    }
  if (l)
    for (const ue in l)
      i0(l[ue], i, n, ue);
  if (c) {
    const ue = Ct(c) ? c.call(n) : c;
    Reflect.ownKeys(ue).forEach((Q) => {
      Ks(Q, ue[Q]);
    });
  }
  d && Ap(d, s, "c");
  function G(ue, Q) {
    _t(Q) ? Q.forEach((le) => ue(le.bind(n))) : Q && ue(Q.bind(n));
  }
  if (G(ix, h), G(xn, m), G(sx, p), G(rx, v), G(ex, _), G(tx, g), G(cx, E), G(lx, T), G(ax, P), G(yf, M), G(Nn, b), G(ox, y), _t(w))
    if (w.length) {
      const ue = s.exposed || (s.exposed = {});
      w.forEach((Q) => {
        Object.defineProperty(ue, Q, {
          get: () => n[Q],
          set: (le) => n[Q] = le,
          enumerable: !0
        });
      });
    } else s.exposed || (s.exposed = {});
  C && s.render === rs && (s.render = C), D != null && (s.inheritAttrs = D), U && (s.components = U), R && (s.directives = R), y && Kg(s);
}
function gx(s, e, n = rs) {
  _t(s) && (s = sh(s));
  for (const i in s) {
    const r = s[i];
    let o;
    tn(r) ? "default" in r ? o = Bi(
      r.from || i,
      r.default,
      !0
    ) : o = Bi(r.from || i) : o = Bi(r), gn(o) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (a) => o.value = a
    }) : e[i] = o;
  }
}
function Ap(s, e, n) {
  as(
    _t(s) ? s.map((i) => i.bind(e.proxy)) : s.bind(e.proxy),
    e,
    n
  );
}
function i0(s, e, n, i) {
  let r = i.includes(".") ? a0(n, i) : () => n[i];
  if (yn(s)) {
    const o = e[s];
    Ct(o) && Ft(r, o);
  } else if (Ct(s))
    Ft(r, s.bind(n));
  else if (tn(s))
    if (_t(s))
      s.forEach((o) => i0(o, e, n, i));
    else {
      const o = Ct(s.handler) ? s.handler.bind(n) : e[s.handler];
      Ct(o) && Ft(r, o, s);
    }
}
function s0(s) {
  const e = s.type, { mixins: n, extends: i } = e, {
    mixins: r,
    optionsCache: o,
    config: { optionMergeStrategies: a }
  } = s.appContext, l = o.get(e);
  let c;
  return l ? c = l : !r.length && !n && !i ? c = e : (c = {}, r.length && r.forEach(
    (u) => qc(c, u, a, !0)
  ), qc(c, e, a)), tn(e) && o.set(e, c), c;
}
function qc(s, e, n, i = !1) {
  const { mixins: r, extends: o } = e;
  o && qc(s, o, n, !0), r && r.forEach(
    (a) => qc(s, a, n, !0)
  );
  for (const a in e)
    if (!(i && a === "expose")) {
      const l = yx[a] || n && n[a];
      s[a] = l ? l(s[a], e[a]) : e[a];
    }
  return s;
}
const yx = {
  data: Pp,
  props: Rp,
  emits: Rp,
  // objects
  methods: Ra,
  computed: Ra,
  // lifecycle
  beforeCreate: Jn,
  created: Jn,
  beforeMount: Jn,
  mounted: Jn,
  beforeUpdate: Jn,
  updated: Jn,
  beforeDestroy: Jn,
  beforeUnmount: Jn,
  destroyed: Jn,
  unmounted: Jn,
  activated: Jn,
  deactivated: Jn,
  errorCaptured: Jn,
  serverPrefetch: Jn,
  // assets
  components: Ra,
  directives: Ra,
  // watch
  watch: _x,
  // provide / inject
  provide: Pp,
  inject: xx
};
function Pp(s, e) {
  return e ? s ? function() {
    return Zn(
      Ct(s) ? s.call(this, this) : s,
      Ct(e) ? e.call(this, this) : e
    );
  } : e : s;
}
function xx(s, e) {
  return Ra(sh(s), sh(e));
}
function sh(s) {
  if (_t(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++)
      e[s[n]] = s[n];
    return e;
  }
  return s;
}
function Jn(s, e) {
  return s ? [...new Set([].concat(s, e))] : e;
}
function Ra(s, e) {
  return s ? Zn(/* @__PURE__ */ Object.create(null), s, e) : e;
}
function Rp(s, e) {
  return s ? _t(s) && _t(e) ? [.../* @__PURE__ */ new Set([...s, ...e])] : Zn(
    /* @__PURE__ */ Object.create(null),
    Ep(s),
    Ep(e ?? {})
  ) : e;
}
function _x(s, e) {
  if (!s) return e;
  if (!e) return s;
  const n = Zn(/* @__PURE__ */ Object.create(null), s);
  for (const i in e)
    n[i] = Jn(s[i], e[i]);
  return n;
}
function r0() {
  return {
    app: null,
    config: {
      isNativeTag: vg,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let bx = 0;
function wx(s, e) {
  return function(i, r = null) {
    Ct(i) || (i = Zn({}, i)), r != null && !tn(r) && (r = null);
    const o = r0(), a = /* @__PURE__ */ new WeakSet(), l = [];
    let c = !1;
    const u = o.app = {
      _uid: bx++,
      _component: i,
      _props: r,
      _container: null,
      _context: o,
      _instance: null,
      version: s_,
      get config() {
        return o.config;
      },
      set config(d) {
      },
      use(d, ...h) {
        return a.has(d) || (d && Ct(d.install) ? (a.add(d), d.install(u, ...h)) : Ct(d) && (a.add(d), d(u, ...h))), u;
      },
      mixin(d) {
        return o.mixins.includes(d) || o.mixins.push(d), u;
      },
      component(d, h) {
        return h ? (o.components[d] = h, u) : o.components[d];
      },
      directive(d, h) {
        return h ? (o.directives[d] = h, u) : o.directives[d];
      },
      mount(d, h, m) {
        if (!c) {
          const p = u._ceVNode || ze(i, r);
          return p.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), s(p, d, m), c = !0, u._container = d, d.__vue_app__ = u, Mu(p.component);
        }
      },
      onUnmount(d) {
        l.push(d);
      },
      unmount() {
        c && (as(
          l,
          u._instance,
          16
        ), s(null, u._container), delete u._container.__vue_app__);
      },
      provide(d, h) {
        return o.provides[d] = h, u;
      },
      runWithContext(d) {
        const h = Br;
        Br = u;
        try {
          return d();
        } finally {
          Br = h;
        }
      }
    };
    return u;
  };
}
let Br = null;
function Ks(s, e) {
  if (qn) {
    let n = qn.provides;
    const i = qn.parent && qn.parent.provides;
    i === n && (n = qn.provides = Object.create(i)), n[s] = e;
  }
}
function Bi(s, e, n = !1) {
  const i = Su();
  if (i || Br) {
    let r = Br ? Br._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (r && s in r)
      return r[s];
    if (arguments.length > 1)
      return n && Ct(e) ? e.call(i && i.proxy) : e;
  }
}
function Sx() {
  return !!(Su() || Br);
}
const Mx = Symbol.for("v-scx"), Cx = () => Bi(Mx);
function Ft(s, e, n) {
  return o0(s, e, n);
}
function o0(s, e, n = en) {
  const { immediate: i, deep: r, flush: o, once: a } = n, l = Zn({}, n), c = e && i || !e && o !== "post";
  let u;
  if (sl) {
    if (o === "sync") {
      const p = Cx();
      u = p.__watcherHandles || (p.__watcherHandles = []);
    } else if (!c) {
      const p = () => {
      };
      return p.stop = rs, p.resume = rs, p.pause = rs, p;
    }
  }
  const d = qn;
  l.call = (p, v, _) => as(p, d, v, _);
  let h = !1;
  o === "post" ? l.scheduler = (p) => {
    ti(p, d && d.suspense);
  } : o !== "sync" && (h = !0, l.scheduler = (p, v) => {
    v ? p() : vf(p);
  }), l.augmentJob = (p) => {
    e && (p.flags |= 4), h && (p.flags |= 2, d && (p.id = d.uid, p.i = d));
  };
  const m = j1(s, e, l);
  return sl && (u ? u.push(m) : c && m()), m;
}
function Tx(s, e, n) {
  const i = this.proxy, r = yn(s) ? s.includes(".") ? a0(i, s) : () => i[s] : s.bind(i, i);
  let o;
  Ct(e) ? o = e : (o = e.handler, n = e);
  const a = wl(this), l = o0(r, o.bind(i), n);
  return a(), l;
}
function a0(s, e) {
  const n = e.split(".");
  return () => {
    let i = s;
    for (let r = 0; r < n.length && i; r++)
      i = i[n[r]];
    return i;
  };
}
const Ex = (s, e) => e === "modelValue" || e === "model-value" ? s.modelModifiers : s[`${e}Modifiers`] || s[`${Di(e)}Modifiers`] || s[`${ur(e)}Modifiers`];
function Ax(s, e, ...n) {
  if (s.isUnmounted) return;
  const i = s.vnode.props || en;
  let r = n;
  const o = e.startsWith("update:"), a = o && Ex(i, e.slice(7));
  a && (a.trim && (r = n.map((d) => yn(d) ? d.trim() : d)), a.number && (r = n.map(mu)));
  let l, c = i[l = Xu(e)] || // also try camelCase event handler (#2249)
  i[l = Xu(Di(e))];
  !c && o && (c = i[l = Xu(ur(e))]), c && as(
    c,
    s,
    6,
    r
  );
  const u = i[l + "Once"];
  if (u) {
    if (!s.emitted)
      s.emitted = {};
    else if (s.emitted[l])
      return;
    s.emitted[l] = !0, as(
      u,
      s,
      6,
      r
    );
  }
}
const Px = /* @__PURE__ */ new WeakMap();
function l0(s, e, n = !1) {
  const i = n ? Px : e.emitsCache, r = i.get(s);
  if (r !== void 0)
    return r;
  const o = s.emits;
  let a = {}, l = !1;
  if (!Ct(s)) {
    const c = (u) => {
      const d = l0(u, e, !0);
      d && (l = !0, Zn(a, d));
    };
    !n && e.mixins.length && e.mixins.forEach(c), s.extends && c(s.extends), s.mixins && s.mixins.forEach(c);
  }
  return !o && !l ? (tn(s) && i.set(s, null), null) : (_t(o) ? o.forEach((c) => a[c] = null) : Zn(a, o), tn(s) && i.set(s, a), a);
}
function bu(s, e) {
  return !s || !du(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Xt(s, e[0].toLowerCase() + e.slice(1)) || Xt(s, ur(e)) || Xt(s, e));
}
function Dp(s) {
  const {
    type: e,
    vnode: n,
    proxy: i,
    withProxy: r,
    propsOptions: [o],
    slots: a,
    attrs: l,
    emit: c,
    render: u,
    renderCache: d,
    props: h,
    data: m,
    setupState: p,
    ctx: v,
    inheritAttrs: _
  } = s, g = jc(s);
  let x, M;
  try {
    if (n.shapeFlag & 4) {
      const b = r || i, C = b;
      x = is(
        u.call(
          C,
          b,
          d,
          h,
          p,
          m,
          v
        )
      ), M = l;
    } else {
      const b = e;
      x = is(
        b.length > 1 ? b(
          h,
          { attrs: l, slots: a, emit: c }
        ) : b(
          h,
          null
        )
      ), M = e.props ? l : Rx(l);
    }
  } catch (b) {
    Ga.length = 0, xu(b, s, 1), x = ze(Ls);
  }
  let S = x;
  if (M && _ !== !1) {
    const b = Object.keys(M), { shapeFlag: C } = S;
    b.length && C & 7 && (o && b.some(af) && (M = Dx(
      M,
      o
    )), S = No(S, M, !1, !0));
  }
  return n.dirs && (S = No(S, null, !1, !0), S.dirs = S.dirs ? S.dirs.concat(n.dirs) : n.dirs), n.transition && gf(S, n.transition), x = S, jc(g), x;
}
const Rx = (s) => {
  let e;
  for (const n in s)
    (n === "class" || n === "style" || du(n)) && ((e || (e = {}))[n] = s[n]);
  return e;
}, Dx = (s, e) => {
  const n = {};
  for (const i in s)
    (!af(i) || !(i.slice(9) in e)) && (n[i] = s[i]);
  return n;
};
function kx(s, e, n) {
  const { props: i, children: r, component: o } = s, { props: a, children: l, patchFlag: c } = e, u = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && c >= 0) {
    if (c & 1024)
      return !0;
    if (c & 16)
      return i ? kp(i, a, u) : !!a;
    if (c & 8) {
      const d = e.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        const m = d[h];
        if (a[m] !== i[m] && !bu(u, m))
          return !0;
      }
    }
  } else
    return (r || l) && (!l || !l.$stable) ? !0 : i === a ? !1 : i ? a ? kp(i, a, u) : !0 : !!a;
  return !1;
}
function kp(s, e, n) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(s).length)
    return !0;
  for (let r = 0; r < i.length; r++) {
    const o = i[r];
    if (e[o] !== s[o] && !bu(n, o))
      return !0;
  }
  return !1;
}
function Ix({ vnode: s, parent: e }, n) {
  for (; e; ) {
    const i = e.subTree;
    if (i.suspense && i.suspense.activeBranch === s && (i.el = s.el), i === s)
      (s = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const c0 = {}, u0 = () => Object.create(c0), d0 = (s) => Object.getPrototypeOf(s) === c0;
function Lx(s, e, n, i = !1) {
  const r = {}, o = u0();
  s.propsDefaults = /* @__PURE__ */ Object.create(null), h0(s, e, r, o);
  for (const a in s.propsOptions[0])
    a in r || (r[a] = void 0);
  n ? s.props = i ? r : O1(r) : s.type.props ? s.props = r : s.props = o, s.attrs = o;
}
function Fx(s, e, n, i) {
  const {
    props: r,
    attrs: o,
    vnode: { patchFlag: a }
  } = s, l = Nt(r), [c] = s.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const d = s.vnode.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        let m = d[h];
        if (bu(s.emitsOptions, m))
          continue;
        const p = e[m];
        if (c)
          if (Xt(o, m))
            p !== o[m] && (o[m] = p, u = !0);
          else {
            const v = Di(m);
            r[v] = rh(
              c,
              l,
              v,
              p,
              s,
              !1
            );
          }
        else
          p !== o[m] && (o[m] = p, u = !0);
      }
    }
  } else {
    h0(s, e, r, o) && (u = !0);
    let d;
    for (const h in l)
      (!e || // for camelCase
      !Xt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = ur(h)) === h || !Xt(e, d))) && (c ? n && // for camelCase
      (n[h] !== void 0 || // for kebab-case
      n[d] !== void 0) && (r[h] = rh(
        c,
        l,
        h,
        void 0,
        s,
        !0
      )) : delete r[h]);
    if (o !== l)
      for (const h in o)
        (!e || !Xt(e, h)) && (delete o[h], u = !0);
  }
  u && Ms(s.attrs, "set", "");
}
function h0(s, e, n, i) {
  const [r, o] = s.propsOptions;
  let a = !1, l;
  if (e)
    for (let c in e) {
      if (Ua(c))
        continue;
      const u = e[c];
      let d;
      r && Xt(r, d = Di(c)) ? !o || !o.includes(d) ? n[d] = u : (l || (l = {}))[d] = u : bu(s.emitsOptions, c) || (!(c in i) || u !== i[c]) && (i[c] = u, a = !0);
    }
  if (o) {
    const c = Nt(n), u = l || en;
    for (let d = 0; d < o.length; d++) {
      const h = o[d];
      n[h] = rh(
        r,
        c,
        h,
        u[h],
        s,
        !Xt(u, h)
      );
    }
  }
  return a;
}
function rh(s, e, n, i, r, o) {
  const a = s[n];
  if (a != null) {
    const l = Xt(a, "default");
    if (l && i === void 0) {
      const c = a.default;
      if (a.type !== Function && !a.skipFactory && Ct(c)) {
        const { propsDefaults: u } = r;
        if (n in u)
          i = u[n];
        else {
          const d = wl(r);
          i = u[n] = c.call(
            null,
            e
          ), d();
        }
      } else
        i = c;
      r.ce && r.ce._setProp(n, i);
    }
    a[
      0
      /* shouldCast */
    ] && (o && !l ? i = !1 : a[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === ur(n)) && (i = !0));
  }
  return i;
}
const Ux = /* @__PURE__ */ new WeakMap();
function f0(s, e, n = !1) {
  const i = n ? Ux : e.propsCache, r = i.get(s);
  if (r)
    return r;
  const o = s.props, a = {}, l = [];
  let c = !1;
  if (!Ct(s)) {
    const d = (h) => {
      c = !0;
      const [m, p] = f0(h, e, !0);
      Zn(a, m), p && l.push(...p);
    };
    !n && e.mixins.length && e.mixins.forEach(d), s.extends && d(s.extends), s.mixins && s.mixins.forEach(d);
  }
  if (!o && !c)
    return tn(s) && i.set(s, Do), Do;
  if (_t(o))
    for (let d = 0; d < o.length; d++) {
      const h = Di(o[d]);
      Ip(h) && (a[h] = en);
    }
  else if (o)
    for (const d in o) {
      const h = Di(d);
      if (Ip(h)) {
        const m = o[d], p = a[h] = _t(m) || Ct(m) ? { type: m } : Zn({}, m), v = p.type;
        let _ = !1, g = !0;
        if (_t(v))
          for (let x = 0; x < v.length; ++x) {
            const M = v[x], S = Ct(M) && M.name;
            if (S === "Boolean") {
              _ = !0;
              break;
            } else S === "String" && (g = !1);
          }
        else
          _ = Ct(v) && v.name === "Boolean";
        p[
          0
          /* shouldCast */
        ] = _, p[
          1
          /* shouldCastTrue */
        ] = g, (_ || Xt(p, "default")) && l.push(h);
      }
    }
  const u = [a, l];
  return tn(s) && i.set(s, u), u;
}
function Ip(s) {
  return s[0] !== "$" && !Ua(s);
}
const xf = (s) => s === "_" || s === "_ctx" || s === "$stable", _f = (s) => _t(s) ? s.map(is) : [is(s)], Ox = (s, e, n) => {
  if (e._n)
    return e;
  const i = Ni((...r) => _f(e(...r)), n);
  return i._c = !1, i;
}, p0 = (s, e, n) => {
  const i = s._ctx;
  for (const r in s) {
    if (xf(r)) continue;
    const o = s[r];
    if (Ct(o))
      e[r] = Ox(r, o, i);
    else if (o != null) {
      const a = _f(o);
      e[r] = () => a;
    }
  }
}, m0 = (s, e) => {
  const n = _f(e);
  s.slots.default = () => n;
}, v0 = (s, e, n) => {
  for (const i in e)
    (n || !xf(i)) && (s[i] = e[i]);
}, zx = (s, e, n) => {
  const i = s.slots = u0();
  if (s.vnode.shapeFlag & 32) {
    const r = e._;
    r ? (v0(i, e, n), n && _g(i, "_", r, !0)) : p0(e, i);
  } else e && m0(s, e);
}, Nx = (s, e, n) => {
  const { vnode: i, slots: r } = s;
  let o = !0, a = en;
  if (i.shapeFlag & 32) {
    const l = e._;
    l ? n && l === 1 ? o = !1 : v0(r, e, n) : (o = !e.$stable, p0(e, r)), a = e;
  } else e && (m0(s, e), a = { default: 1 });
  if (o)
    for (const l in r)
      !xf(l) && a[l] == null && delete r[l];
}, ti = $x;
function Bx(s) {
  return Vx(s);
}
function Vx(s, e) {
  const n = vu();
  n.__VUE__ = !0;
  const {
    insert: i,
    remove: r,
    patchProp: o,
    createElement: a,
    createText: l,
    createComment: c,
    setText: u,
    setElementText: d,
    parentNode: h,
    nextSibling: m,
    setScopeId: p = rs,
    insertStaticContent: v
  } = s, _ = (L, ee, Z, k = null, ne = null, J = null, B = void 0, X = null, se = !!ee.dynamicChildren) => {
    if (L === ee)
      return;
    L && !da(L, ee) && (k = V(L), $(L, ne, J, !0), L = null), ee.patchFlag === -2 && (se = !1, ee.dynamicChildren = null);
    const { type: z, ref: N, shapeFlag: K } = ee;
    switch (z) {
      case wu:
        g(L, ee, Z, k);
        break;
      case Ls:
        x(L, ee, Z, k);
        break;
      case Dc:
        L == null && M(ee, Z, k, B);
        break;
      case qe:
        U(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        );
        break;
      default:
        K & 1 ? C(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        ) : K & 6 ? R(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        ) : (K & 64 || K & 128) && z.process(
          L,
          ee,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se,
          I
        );
    }
    N != null && ne ? Ba(N, L && L.ref, J, ee || L, !ee) : N == null && L && L.ref != null && Ba(L.ref, null, J, L, !0);
  }, g = (L, ee, Z, k) => {
    if (L == null)
      i(
        ee.el = l(ee.children),
        Z,
        k
      );
    else {
      const ne = ee.el = L.el;
      ee.children !== L.children && u(ne, ee.children);
    }
  }, x = (L, ee, Z, k) => {
    L == null ? i(
      ee.el = c(ee.children || ""),
      Z,
      k
    ) : ee.el = L.el;
  }, M = (L, ee, Z, k) => {
    [L.el, L.anchor] = v(
      L.children,
      ee,
      Z,
      k,
      L.el,
      L.anchor
    );
  }, S = ({ el: L, anchor: ee }, Z, k) => {
    let ne;
    for (; L && L !== ee; )
      ne = m(L), i(L, Z, k), L = ne;
    i(ee, Z, k);
  }, b = ({ el: L, anchor: ee }) => {
    let Z;
    for (; L && L !== ee; )
      Z = m(L), r(L), L = Z;
    r(ee);
  }, C = (L, ee, Z, k, ne, J, B, X, se) => {
    if (ee.type === "svg" ? B = "svg" : ee.type === "math" && (B = "mathml"), L == null)
      T(
        ee,
        Z,
        k,
        ne,
        J,
        B,
        X,
        se
      );
    else {
      const z = L.el && L.el._isVueCE ? L.el : null;
      try {
        z && z._beginPatch(), y(
          L,
          ee,
          ne,
          J,
          B,
          X,
          se
        );
      } finally {
        z && z._endPatch();
      }
    }
  }, T = (L, ee, Z, k, ne, J, B, X) => {
    let se, z;
    const { props: N, shapeFlag: K, transition: he, dirs: me } = L;
    if (se = L.el = a(
      L.type,
      J,
      N && N.is,
      N
    ), K & 8 ? d(se, L.children) : K & 16 && E(
      L.children,
      se,
      null,
      k,
      ne,
      Ju(L, J),
      B,
      X
    ), me && pr(L, null, k, "created"), P(se, L, L.scopeId, B, k), N) {
      for (const Me in N)
        Me !== "value" && !Ua(Me) && o(se, Me, null, N[Me], J, k);
      "value" in N && o(se, "value", null, N.value, J), (z = N.onVnodeBeforeMount) && Ki(z, k, L);
    }
    me && pr(L, null, k, "beforeMount");
    const ge = Gx(ne, he);
    ge && he.beforeEnter(se), i(se, ee, Z), ((z = N && N.onVnodeMounted) || ge || me) && ti(() => {
      z && Ki(z, k, L), ge && he.enter(se), me && pr(L, null, k, "mounted");
    }, ne);
  }, P = (L, ee, Z, k, ne) => {
    if (Z && p(L, Z), k)
      for (let J = 0; J < k.length; J++)
        p(L, k[J]);
    if (ne) {
      let J = ne.subTree;
      if (ee === J || y0(J.type) && (J.ssContent === ee || J.ssFallback === ee)) {
        const B = ne.vnode;
        P(
          L,
          B,
          B.scopeId,
          B.slotScopeIds,
          ne.parent
        );
      }
    }
  }, E = (L, ee, Z, k, ne, J, B, X, se = 0) => {
    for (let z = se; z < L.length; z++) {
      const N = L[z] = X ? nr(L[z]) : is(L[z]);
      _(
        null,
        N,
        ee,
        Z,
        k,
        ne,
        J,
        B,
        X
      );
    }
  }, y = (L, ee, Z, k, ne, J, B) => {
    const X = ee.el = L.el;
    let { patchFlag: se, dynamicChildren: z, dirs: N } = ee;
    se |= L.patchFlag & 16;
    const K = L.props || en, he = ee.props || en;
    let me;
    if (Z && mr(Z, !1), (me = he.onVnodeBeforeUpdate) && Ki(me, Z, ee, L), N && pr(ee, L, Z, "beforeUpdate"), Z && mr(Z, !0), (K.innerHTML && he.innerHTML == null || K.textContent && he.textContent == null) && d(X, ""), z ? w(
      L.dynamicChildren,
      z,
      X,
      Z,
      k,
      Ju(ee, ne),
      J
    ) : B || Q(
      L,
      ee,
      X,
      null,
      Z,
      k,
      Ju(ee, ne),
      J,
      !1
    ), se > 0) {
      if (se & 16)
        D(X, K, he, Z, ne);
      else if (se & 2 && K.class !== he.class && o(X, "class", null, he.class, ne), se & 4 && o(X, "style", K.style, he.style, ne), se & 8) {
        const ge = ee.dynamicProps;
        for (let Me = 0; Me < ge.length; Me++) {
          const Ee = ge[Me], Ae = K[Ee], Xe = he[Ee];
          (Xe !== Ae || Ee === "value") && o(X, Ee, Ae, Xe, ne, Z);
        }
      }
      se & 1 && L.children !== ee.children && d(X, ee.children);
    } else !B && z == null && D(X, K, he, Z, ne);
    ((me = he.onVnodeUpdated) || N) && ti(() => {
      me && Ki(me, Z, ee, L), N && pr(ee, L, Z, "updated");
    }, k);
  }, w = (L, ee, Z, k, ne, J, B) => {
    for (let X = 0; X < ee.length; X++) {
      const se = L[X], z = ee[X], N = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        se.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (se.type === qe || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !da(se, z) || // - In the case of a component, it could contain anything.
        se.shapeFlag & 198) ? h(se.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          Z
        )
      );
      _(
        se,
        z,
        N,
        null,
        k,
        ne,
        J,
        B,
        !0
      );
    }
  }, D = (L, ee, Z, k, ne) => {
    if (ee !== Z) {
      if (ee !== en)
        for (const J in ee)
          !Ua(J) && !(J in Z) && o(
            L,
            J,
            ee[J],
            null,
            ne,
            k
          );
      for (const J in Z) {
        if (Ua(J)) continue;
        const B = Z[J], X = ee[J];
        B !== X && J !== "value" && o(L, J, X, B, ne, k);
      }
      "value" in Z && o(L, "value", ee.value, Z.value, ne);
    }
  }, U = (L, ee, Z, k, ne, J, B, X, se) => {
    const z = ee.el = L ? L.el : l(""), N = ee.anchor = L ? L.anchor : l("");
    let { patchFlag: K, dynamicChildren: he, slotScopeIds: me } = ee;
    me && (X = X ? X.concat(me) : me), L == null ? (i(z, Z, k), i(N, Z, k), E(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      ee.children || [],
      Z,
      N,
      ne,
      J,
      B,
      X,
      se
    )) : K > 0 && K & 64 && he && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    L.dynamicChildren ? (w(
      L.dynamicChildren,
      he,
      Z,
      ne,
      J,
      B,
      X
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (ee.key != null || ne && ee === ne.subTree) && bf(
      L,
      ee,
      !0
      /* shallow */
    )) : Q(
      L,
      ee,
      Z,
      N,
      ne,
      J,
      B,
      X,
      se
    );
  }, R = (L, ee, Z, k, ne, J, B, X, se) => {
    ee.slotScopeIds = X, L == null ? ee.shapeFlag & 512 ? ne.ctx.activate(
      ee,
      Z,
      k,
      B,
      se
    ) : O(
      ee,
      Z,
      k,
      ne,
      J,
      B,
      se
    ) : A(L, ee, se);
  }, O = (L, ee, Z, k, ne, J, B) => {
    const X = L.component = Kx(
      L,
      k,
      ne
    );
    if (Jg(L) && (X.ctx.renderer = I), Jx(X, !1, B), X.asyncDep) {
      if (ne && ne.registerDep(X, G, B), !L.el) {
        const se = X.subTree = ze(Ls);
        x(null, se, ee, Z), L.placeholder = se.el;
      }
    } else
      G(
        X,
        L,
        ee,
        Z,
        ne,
        J,
        B
      );
  }, A = (L, ee, Z) => {
    const k = ee.component = L.component;
    if (kx(L, ee, Z))
      if (k.asyncDep && !k.asyncResolved) {
        ue(k, ee, Z);
        return;
      } else
        k.next = ee, k.update();
    else
      ee.el = L.el, k.vnode = ee;
  }, G = (L, ee, Z, k, ne, J, B) => {
    const X = () => {
      if (L.isMounted) {
        let { next: K, bu: he, u: me, parent: ge, vnode: Me } = L;
        {
          const He = g0(L);
          if (He) {
            K && (K.el = Me.el, ue(L, K, B)), He.asyncDep.then(() => {
              L.isUnmounted || X();
            });
            return;
          }
        }
        let Ee = K, Ae;
        mr(L, !1), K ? (K.el = Me.el, ue(L, K, B)) : K = Me, he && Pc(he), (Ae = K.props && K.props.onVnodeBeforeUpdate) && Ki(Ae, ge, K, Me), mr(L, !0);
        const Xe = Dp(L), Oe = L.subTree;
        L.subTree = Xe, _(
          Oe,
          Xe,
          // parent may have changed if it's in a teleport
          h(Oe.el),
          // anchor may have changed if it's in a fragment
          V(Oe),
          L,
          ne,
          J
        ), K.el = Xe.el, Ee === null && Ix(L, Xe.el), me && ti(me, ne), (Ae = K.props && K.props.onVnodeUpdated) && ti(
          () => Ki(Ae, ge, K, Me),
          ne
        );
      } else {
        let K;
        const { el: he, props: me } = ee, { bm: ge, m: Me, parent: Ee, root: Ae, type: Xe } = L, Oe = Lo(ee);
        mr(L, !1), ge && Pc(ge), !Oe && (K = me && me.onVnodeBeforeMount) && Ki(K, Ee, ee), mr(L, !0);
        {
          Ae.ce && // @ts-expect-error _def is private
          Ae.ce._def.shadowRoot !== !1 && Ae.ce._injectChildStyle(Xe);
          const He = L.subTree = Dp(L);
          _(
            null,
            He,
            Z,
            k,
            L,
            ne,
            J
          ), ee.el = He.el;
        }
        if (Me && ti(Me, ne), !Oe && (K = me && me.onVnodeMounted)) {
          const He = ee;
          ti(
            () => Ki(K, Ee, He),
            ne
          );
        }
        (ee.shapeFlag & 256 || Ee && Lo(Ee.vnode) && Ee.vnode.shapeFlag & 256) && L.a && ti(L.a, ne), L.isMounted = !0, ee = Z = k = null;
      }
    };
    L.scope.on();
    const se = L.effect = new Eg(X);
    L.scope.off();
    const z = L.update = se.run.bind(se), N = L.job = se.runIfDirty.bind(se);
    N.i = L, N.id = L.uid, se.scheduler = () => vf(N), mr(L, !0), z();
  }, ue = (L, ee, Z) => {
    ee.component = L;
    const k = L.vnode.props;
    L.vnode = ee, L.next = null, Fx(L, ee.props, k, Z), Nx(L, ee.children, Z), Ds(), bp(L), ks();
  }, Q = (L, ee, Z, k, ne, J, B, X, se = !1) => {
    const z = L && L.children, N = L ? L.shapeFlag : 0, K = ee.children, { patchFlag: he, shapeFlag: me } = ee;
    if (he > 0) {
      if (he & 128) {
        re(
          z,
          K,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        );
        return;
      } else if (he & 256) {
        le(
          z,
          K,
          Z,
          k,
          ne,
          J,
          B,
          X,
          se
        );
        return;
      }
    }
    me & 8 ? (N & 16 && ce(z, ne, J), K !== z && d(Z, K)) : N & 16 ? me & 16 ? re(
      z,
      K,
      Z,
      k,
      ne,
      J,
      B,
      X,
      se
    ) : ce(z, ne, J, !0) : (N & 8 && d(Z, ""), me & 16 && E(
      K,
      Z,
      k,
      ne,
      J,
      B,
      X,
      se
    ));
  }, le = (L, ee, Z, k, ne, J, B, X, se) => {
    L = L || Do, ee = ee || Do;
    const z = L.length, N = ee.length, K = Math.min(z, N);
    let he;
    for (he = 0; he < K; he++) {
      const me = ee[he] = se ? nr(ee[he]) : is(ee[he]);
      _(
        L[he],
        me,
        Z,
        null,
        ne,
        J,
        B,
        X,
        se
      );
    }
    z > N ? ce(
      L,
      ne,
      J,
      !0,
      !1,
      K
    ) : E(
      ee,
      Z,
      k,
      ne,
      J,
      B,
      X,
      se,
      K
    );
  }, re = (L, ee, Z, k, ne, J, B, X, se) => {
    let z = 0;
    const N = ee.length;
    let K = L.length - 1, he = N - 1;
    for (; z <= K && z <= he; ) {
      const me = L[z], ge = ee[z] = se ? nr(ee[z]) : is(ee[z]);
      if (da(me, ge))
        _(
          me,
          ge,
          Z,
          null,
          ne,
          J,
          B,
          X,
          se
        );
      else
        break;
      z++;
    }
    for (; z <= K && z <= he; ) {
      const me = L[K], ge = ee[he] = se ? nr(ee[he]) : is(ee[he]);
      if (da(me, ge))
        _(
          me,
          ge,
          Z,
          null,
          ne,
          J,
          B,
          X,
          se
        );
      else
        break;
      K--, he--;
    }
    if (z > K) {
      if (z <= he) {
        const me = he + 1, ge = me < N ? ee[me].el : k;
        for (; z <= he; )
          _(
            null,
            ee[z] = se ? nr(ee[z]) : is(ee[z]),
            Z,
            ge,
            ne,
            J,
            B,
            X,
            se
          ), z++;
      }
    } else if (z > he)
      for (; z <= K; )
        $(L[z], ne, J, !0), z++;
    else {
      const me = z, ge = z, Me = /* @__PURE__ */ new Map();
      for (z = ge; z <= he; z++) {
        const Le = ee[z] = se ? nr(ee[z]) : is(ee[z]);
        Le.key != null && Me.set(Le.key, z);
      }
      let Ee, Ae = 0;
      const Xe = he - ge + 1;
      let Oe = !1, He = 0;
      const Ye = new Array(Xe);
      for (z = 0; z < Xe; z++) Ye[z] = 0;
      for (z = me; z <= K; z++) {
        const Le = L[z];
        if (Ae >= Xe) {
          $(Le, ne, J, !0);
          continue;
        }
        let nt;
        if (Le.key != null)
          nt = Me.get(Le.key);
        else
          for (Ee = ge; Ee <= he; Ee++)
            if (Ye[Ee - ge] === 0 && da(Le, ee[Ee])) {
              nt = Ee;
              break;
            }
        nt === void 0 ? $(Le, ne, J, !0) : (Ye[nt - ge] = z + 1, nt >= He ? He = nt : Oe = !0, _(
          Le,
          ee[nt],
          Z,
          null,
          ne,
          J,
          B,
          X,
          se
        ), Ae++);
      }
      const $e = Oe ? Hx(Ye) : Do;
      for (Ee = $e.length - 1, z = Xe - 1; z >= 0; z--) {
        const Le = ge + z, nt = ee[Le], Je = ee[Le + 1], bt = Le + 1 < N ? (
          // #13559, fallback to el placeholder for unresolved async component
          Je.el || Je.placeholder
        ) : k;
        Ye[z] === 0 ? _(
          null,
          nt,
          Z,
          bt,
          ne,
          J,
          B,
          X,
          se
        ) : Oe && (Ee < 0 || z !== $e[Ee] ? j(nt, Z, bt, 2) : Ee--);
      }
    }
  }, j = (L, ee, Z, k, ne = null) => {
    const { el: J, type: B, transition: X, children: se, shapeFlag: z } = L;
    if (z & 6) {
      j(L.component.subTree, ee, Z, k);
      return;
    }
    if (z & 128) {
      L.suspense.move(ee, Z, k);
      return;
    }
    if (z & 64) {
      B.move(L, ee, Z, I);
      return;
    }
    if (B === qe) {
      i(J, ee, Z);
      for (let K = 0; K < se.length; K++)
        j(se[K], ee, Z, k);
      i(L.anchor, ee, Z);
      return;
    }
    if (B === Dc) {
      S(L, ee, Z);
      return;
    }
    if (k !== 2 && z & 1 && X)
      if (k === 0)
        X.beforeEnter(J), i(J, ee, Z), ti(() => X.enter(J), ne);
      else {
        const { leave: K, delayLeave: he, afterLeave: me } = X, ge = () => {
          L.ctx.isUnmounted ? r(J) : i(J, ee, Z);
        }, Me = () => {
          J._isLeaving && J[Q1](
            !0
            /* cancelled */
          ), K(J, () => {
            ge(), me && me();
          });
        };
        he ? he(J, ge, Me) : Me();
      }
    else
      i(J, ee, Z);
  }, $ = (L, ee, Z, k = !1, ne = !1) => {
    const {
      type: J,
      props: B,
      ref: X,
      children: se,
      dynamicChildren: z,
      shapeFlag: N,
      patchFlag: K,
      dirs: he,
      cacheIndex: me
    } = L;
    if (K === -2 && (ne = !1), X != null && (Ds(), Ba(X, null, Z, L, !0), ks()), me != null && (ee.renderCache[me] = void 0), N & 256) {
      ee.ctx.deactivate(L);
      return;
    }
    const ge = N & 1 && he, Me = !Lo(L);
    let Ee;
    if (Me && (Ee = B && B.onVnodeBeforeUnmount) && Ki(Ee, ee, L), N & 6)
      ie(L.component, Z, k);
    else {
      if (N & 128) {
        L.suspense.unmount(Z, k);
        return;
      }
      ge && pr(L, null, ee, "beforeUnmount"), N & 64 ? L.type.remove(
        L,
        ee,
        Z,
        I,
        k
      ) : z && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !z.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (J !== qe || K > 0 && K & 64) ? ce(
        z,
        ee,
        Z,
        !1,
        !0
      ) : (J === qe && K & 384 || !ne && N & 16) && ce(se, ee, Z), k && q(L);
    }
    (Me && (Ee = B && B.onVnodeUnmounted) || ge) && ti(() => {
      Ee && Ki(Ee, ee, L), ge && pr(L, null, ee, "unmounted");
    }, Z);
  }, q = (L) => {
    const { type: ee, el: Z, anchor: k, transition: ne } = L;
    if (ee === qe) {
      oe(Z, k);
      return;
    }
    if (ee === Dc) {
      b(L);
      return;
    }
    const J = () => {
      r(Z), ne && !ne.persisted && ne.afterLeave && ne.afterLeave();
    };
    if (L.shapeFlag & 1 && ne && !ne.persisted) {
      const { leave: B, delayLeave: X } = ne, se = () => B(Z, J);
      X ? X(L.el, J, se) : se();
    } else
      J();
  }, oe = (L, ee) => {
    let Z;
    for (; L !== ee; )
      Z = m(L), r(L), L = Z;
    r(ee);
  }, ie = (L, ee, Z) => {
    const { bum: k, scope: ne, job: J, subTree: B, um: X, m: se, a: z } = L;
    Lp(se), Lp(z), k && Pc(k), ne.stop(), J && (J.flags |= 8, $(B, L, ee, Z)), X && ti(X, ee), ti(() => {
      L.isUnmounted = !0;
    }, ee);
  }, ce = (L, ee, Z, k = !1, ne = !1, J = 0) => {
    for (let B = J; B < L.length; B++)
      $(L[B], ee, Z, k, ne);
  }, V = (L) => {
    if (L.shapeFlag & 6)
      return V(L.component.subTree);
    if (L.shapeFlag & 128)
      return L.suspense.next();
    const ee = m(L.anchor || L.el), Z = ee && ee[Yg];
    return Z ? m(Z) : ee;
  };
  let Y = !1;
  const H = (L, ee, Z) => {
    L == null ? ee._vnode && $(ee._vnode, null, null, !0) : _(
      ee._vnode || null,
      L,
      ee,
      null,
      null,
      null,
      Z
    ), ee._vnode = L, Y || (Y = !0, bp(), Wg(), Y = !1);
  }, I = {
    p: _,
    um: $,
    m: j,
    r: q,
    mt: O,
    mc: E,
    pc: Q,
    pbc: w,
    n: V,
    o: s
  };
  return {
    render: H,
    hydrate: void 0,
    createApp: wx(H)
  };
}
function Ju({ type: s, props: e }, n) {
  return n === "svg" && s === "foreignObject" || n === "mathml" && s === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function mr({ effect: s, job: e }, n) {
  n ? (s.flags |= 32, e.flags |= 4) : (s.flags &= -33, e.flags &= -5);
}
function Gx(s, e) {
  return (!s || s && !s.pendingBranch) && e && !e.persisted;
}
function bf(s, e, n = !1) {
  const i = s.children, r = e.children;
  if (_t(i) && _t(r))
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      let l = r[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[o] = nr(r[o]), l.el = a.el), !n && l.patchFlag !== -2 && bf(a, l)), l.type === wu && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = a.el), l.type === Ls && !l.el && (l.el = a.el);
    }
}
function Hx(s) {
  const e = s.slice(), n = [0];
  let i, r, o, a, l;
  const c = s.length;
  for (i = 0; i < c; i++) {
    const u = s[i];
    if (u !== 0) {
      if (r = n[n.length - 1], s[r] < u) {
        e[i] = r, n.push(i);
        continue;
      }
      for (o = 0, a = n.length - 1; o < a; )
        l = o + a >> 1, s[n[l]] < u ? o = l + 1 : a = l;
      u < s[n[o]] && (o > 0 && (e[i] = n[o - 1]), n[o] = i);
    }
  }
  for (o = n.length, a = n[o - 1]; o-- > 0; )
    n[o] = a, a = e[a];
  return n;
}
function g0(s) {
  const e = s.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : g0(e);
}
function Lp(s) {
  if (s)
    for (let e = 0; e < s.length; e++)
      s[e].flags |= 8;
}
const y0 = (s) => s.__isSuspense;
function $x(s, e) {
  e && e.pendingBranch ? _t(s) ? e.effects.push(...s) : e.effects.push(s) : Z1(s);
}
const qe = Symbol.for("v-fgt"), wu = Symbol.for("v-txt"), Ls = Symbol.for("v-cmt"), Dc = Symbol.for("v-stc"), Ga = [];
let bi = null;
function te(s = !1) {
  Ga.push(bi = s ? null : []);
}
function Wx() {
  Ga.pop(), bi = Ga[Ga.length - 1] || null;
}
let nl = 1;
function Zc(s, e = !1) {
  nl += s, s < 0 && bi && e && (bi.hasOnce = !0);
}
function x0(s) {
  return s.dynamicChildren = nl > 0 ? bi || Do : null, Wx(), nl > 0 && bi && bi.push(s), s;
}
function ae(s, e, n, i, r, o) {
  return x0(
    f(
      s,
      e,
      n,
      i,
      r,
      o,
      !0
    )
  );
}
function St(s, e, n, i, r) {
  return x0(
    ze(
      s,
      e,
      n,
      i,
      r,
      !0
    )
  );
}
function il(s) {
  return s ? s.__v_isVNode === !0 : !1;
}
function da(s, e) {
  return s.type === e.type && s.key === e.key;
}
const _0 = ({ key: s }) => s ?? null, kc = ({
  ref: s,
  ref_key: e,
  ref_for: n
}) => (typeof s == "number" && (s = "" + s), s != null ? yn(s) || gn(s) || Ct(s) ? { i: Un, r: s, k: e, f: !!n } : s : null);
function f(s, e = null, n = null, i = 0, r = null, o = s === qe ? 0 : 1, a = !1, l = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s,
    props: e,
    key: e && _0(e),
    ref: e && kc(e),
    scopeId: jg,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: i,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: Un
  };
  return l ? (wf(c, n), o & 128 && s.normalize(c)) : n && (c.shapeFlag |= yn(n) ? 8 : 16), nl > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  bi && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (c.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  c.patchFlag !== 32 && bi.push(c), c;
}
const ze = Xx;
function Xx(s, e = null, n = null, i = 0, r = null, o = !1) {
  if ((!s || s === e0) && (s = Ls), il(s)) {
    const l = No(
      s,
      e,
      !0
      /* mergeRef: true */
    );
    return n && wf(l, n), nl > 0 && !o && bi && (l.shapeFlag & 6 ? bi[bi.indexOf(s)] = l : bi.push(l)), l.patchFlag = -2, l;
  }
  if (n_(s) && (s = s.__vccOpts), e) {
    e = jx(e);
    let { class: l, style: c } = e;
    l && !yn(l) && (e.class = Fe(l)), tn(c) && (yu(c) && !_t(c) && (c = Zn({}, c)), e.style = yt(c));
  }
  const a = yn(s) ? 1 : y0(s) ? 128 : K1(s) ? 64 : tn(s) ? 4 : Ct(s) ? 2 : 0;
  return f(
    s,
    e,
    n,
    i,
    r,
    a,
    o,
    !0
  );
}
function jx(s) {
  return s ? yu(s) || d0(s) ? Zn({}, s) : s : null;
}
function No(s, e, n = !1, i = !1) {
  const { props: r, ref: o, patchFlag: a, children: l, transition: c } = s, u = e ? Yx(r || {}, e) : r, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s.type,
    props: u,
    key: u && _0(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && o ? _t(o) ? o.concat(kc(e)) : [o, kc(e)] : kc(e)
    ) : o,
    scopeId: s.scopeId,
    slotScopeIds: s.slotScopeIds,
    children: l,
    target: s.target,
    targetStart: s.targetStart,
    targetAnchor: s.targetAnchor,
    staticCount: s.staticCount,
    shapeFlag: s.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && s.type !== qe ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: s.dynamicProps,
    dynamicChildren: s.dynamicChildren,
    appContext: s.appContext,
    dirs: s.dirs,
    transition: c,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: s.component,
    suspense: s.suspense,
    ssContent: s.ssContent && No(s.ssContent),
    ssFallback: s.ssFallback && No(s.ssFallback),
    placeholder: s.placeholder,
    el: s.el,
    anchor: s.anchor,
    ctx: s.ctx,
    ce: s.ce
  };
  return c && i && gf(
    d,
    c.clone(d)
  ), d;
}
function ct(s = " ", e = 0) {
  return ze(wu, null, s, e);
}
function ls(s, e) {
  const n = ze(Dc, null, s);
  return n.staticCount = e, n;
}
function Pe(s = "", e = !1) {
  return e ? (te(), St(Ls, null, s)) : ze(Ls, null, s);
}
function is(s) {
  return s == null || typeof s == "boolean" ? ze(Ls) : _t(s) ? ze(
    qe,
    null,
    // #3666, avoid reference pollution when reusing vnode
    s.slice()
  ) : il(s) ? nr(s) : ze(wu, null, String(s));
}
function nr(s) {
  return s.el === null && s.patchFlag !== -1 || s.memo ? s : No(s);
}
function wf(s, e) {
  let n = 0;
  const { shapeFlag: i } = s;
  if (e == null)
    e = null;
  else if (_t(e))
    n = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const r = e.default;
      r && (r._c && (r._d = !1), wf(s, r()), r._c && (r._d = !0));
      return;
    } else {
      n = 32;
      const r = e._;
      !r && !d0(e) ? e._ctx = Un : r === 3 && Un && (Un.slots._ === 1 ? e._ = 1 : (e._ = 2, s.patchFlag |= 1024));
    }
  else Ct(e) ? (e = { default: e, _ctx: Un }, n = 32) : (e = String(e), i & 64 ? (n = 16, e = [ct(e)]) : n = 8);
  s.children = e, s.shapeFlag |= n;
}
function Yx(...s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = s[n];
    for (const r in i)
      if (r === "class")
        e.class !== i.class && (e.class = Fe([e.class, i.class]));
      else if (r === "style")
        e.style = yt([e.style, i.style]);
      else if (du(r)) {
        const o = e[r], a = i[r];
        a && o !== a && !(_t(o) && o.includes(a)) && (e[r] = o ? [].concat(o, a) : a);
      } else r !== "" && (e[r] = i[r]);
  }
  return e;
}
function Ki(s, e, n, i = null) {
  as(s, e, 7, [
    n,
    i
  ]);
}
const qx = r0();
let Zx = 0;
function Kx(s, e, n) {
  const i = s.type, r = (e ? e.appContext : s.appContext) || qx, o = {
    uid: Zx++,
    vnode: s,
    type: i,
    parent: e,
    appContext: r,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Mg(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(r.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: f0(i, r),
    emitsOptions: l0(i, r),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: en,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: en,
    data: en,
    props: en,
    attrs: en,
    slots: en,
    refs: en,
    setupState: en,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = Ax.bind(null, o), s.ce && s.ce(o), o;
}
let qn = null;
const Su = () => qn || Un;
let Kc, oh;
{
  const s = vu(), e = (n, i) => {
    let r;
    return (r = s[n]) || (r = s[n] = []), r.push(i), (o) => {
      r.length > 1 ? r.forEach((a) => a(o)) : r[0](o);
    };
  };
  Kc = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => qn = n
  ), oh = e(
    "__VUE_SSR_SETTERS__",
    (n) => sl = n
  );
}
const wl = (s) => {
  const e = qn;
  return Kc(s), s.scope.on(), () => {
    s.scope.off(), Kc(e);
  };
}, Fp = () => {
  qn && qn.scope.off(), Kc(null);
};
function b0(s) {
  return s.vnode.shapeFlag & 4;
}
let sl = !1;
function Jx(s, e = !1, n = !1) {
  e && oh(e);
  const { props: i, children: r } = s.vnode, o = b0(s);
  Lx(s, i, o, e), zx(s, r, n || e);
  const a = o ? Qx(s, e) : void 0;
  return e && oh(!1), a;
}
function Qx(s, e) {
  const n = s.type;
  s.accessCache = /* @__PURE__ */ Object.create(null), s.proxy = new Proxy(s.ctx, fx);
  const { setup: i } = n;
  if (i) {
    Ds();
    const r = s.setupContext = i.length > 1 ? S0(s) : null, o = wl(s), a = bl(
      i,
      s,
      0,
      [
        s.props,
        r
      ]
    ), l = gg(a);
    if (ks(), o(), (l || s.sp) && !Lo(s) && Kg(s), l) {
      if (a.then(Fp, Fp), e)
        return a.then((c) => {
          Up(s, c);
        }).catch((c) => {
          xu(c, s, 0);
        });
      s.asyncDep = a;
    } else
      Up(s, a);
  } else
    w0(s);
}
function Up(s, e, n) {
  Ct(e) ? s.type.__ssrInlineRender ? s.ssrRender = e : s.render = e : tn(e) && (s.setupState = Gg(e)), w0(s);
}
function w0(s, e, n) {
  const i = s.type;
  s.render || (s.render = i.render || rs);
  {
    const r = wl(s);
    Ds();
    try {
      vx(s);
    } finally {
      ks(), r();
    }
  }
}
const e_ = {
  get(s, e) {
    return Yn(s, "get", ""), s[e];
  }
};
function S0(s) {
  const e = (n) => {
    s.exposed = n || {};
  };
  return {
    attrs: new Proxy(s.attrs, e_),
    slots: s.slots,
    emit: s.emit,
    expose: e
  };
}
function Mu(s) {
  return s.exposed ? s.exposeProxy || (s.exposeProxy = new Proxy(Gg(Ss(s.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in Va)
        return Va[n](s);
    },
    has(e, n) {
      return n in e || n in Va;
    }
  })) : s.proxy;
}
function t_(s, e = !0) {
  return Ct(s) ? s.displayName || s.name : s.name || e && s.__name;
}
function n_(s) {
  return Ct(s) && "__vccOpts" in s;
}
const Ie = (s, e) => W1(s, e, sl);
function i_(s, e, n) {
  try {
    Zc(-1);
    const i = arguments.length;
    return i === 2 ? tn(e) && !_t(e) ? il(e) ? ze(s, null, [e]) : ze(s, e) : ze(s, null, e) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && il(n) && (n = [n]), ze(s, e, n));
  } finally {
    Zc(1);
  }
}
const s_ = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let ah;
const Op = typeof window < "u" && window.trustedTypes;
if (Op)
  try {
    ah = /* @__PURE__ */ Op.createPolicy("vue", {
      createHTML: (s) => s
    });
  } catch {
  }
const M0 = ah ? (s) => ah.createHTML(s) : (s) => s, r_ = "http://www.w3.org/2000/svg", o_ = "http://www.w3.org/1998/Math/MathML", ws = typeof document < "u" ? document : null, zp = ws && /* @__PURE__ */ ws.createElement("template"), a_ = {
  insert: (s, e, n) => {
    e.insertBefore(s, n || null);
  },
  remove: (s) => {
    const e = s.parentNode;
    e && e.removeChild(s);
  },
  createElement: (s, e, n, i) => {
    const r = e === "svg" ? ws.createElementNS(r_, s) : e === "mathml" ? ws.createElementNS(o_, s) : n ? ws.createElement(s, { is: n }) : ws.createElement(s);
    return s === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple), r;
  },
  createText: (s) => ws.createTextNode(s),
  createComment: (s) => ws.createComment(s),
  setText: (s, e) => {
    s.nodeValue = e;
  },
  setElementText: (s, e) => {
    s.textContent = e;
  },
  parentNode: (s) => s.parentNode,
  nextSibling: (s) => s.nextSibling,
  querySelector: (s) => ws.querySelector(s),
  setScopeId(s, e) {
    s.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(s, e, n, i, r, o) {
    const a = n ? n.previousSibling : e.lastChild;
    if (r && (r === o || r.nextSibling))
      for (; e.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling)); )
        ;
    else {
      zp.innerHTML = M0(
        i === "svg" ? `<svg>${s}</svg>` : i === "mathml" ? `<math>${s}</math>` : s
      );
      const l = zp.content;
      if (i === "svg" || i === "mathml") {
        const c = l.firstChild;
        for (; c.firstChild; )
          l.appendChild(c.firstChild);
        l.removeChild(c);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, l_ = Symbol("_vtc");
function c_(s, e, n) {
  const i = s[l_];
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? s.removeAttribute("class") : n ? s.setAttribute("class", e) : s.className = e;
}
const Jc = Symbol("_vod"), C0 = Symbol("_vsh"), Bs = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(s, { value: e }, { transition: n }) {
    s[Jc] = s.style.display === "none" ? "" : s.style.display, n && e ? n.beforeEnter(s) : ha(s, e);
  },
  mounted(s, { value: e }, { transition: n }) {
    n && e && n.enter(s);
  },
  updated(s, { value: e, oldValue: n }, { transition: i }) {
    !e != !n && (i ? e ? (i.beforeEnter(s), ha(s, !0), i.enter(s)) : i.leave(s, () => {
      ha(s, !1);
    }) : ha(s, e));
  },
  beforeUnmount(s, { value: e }) {
    ha(s, e);
  }
};
function ha(s, e) {
  s.style.display = e ? s[Jc] : "none", s[C0] = !e;
}
const u_ = Symbol(""), d_ = /(?:^|;)\s*display\s*:/;
function h_(s, e, n) {
  const i = s.style, r = yn(n);
  let o = !1;
  if (n && !r) {
    if (e)
      if (yn(e))
        for (const a of e.split(";")) {
          const l = a.slice(0, a.indexOf(":")).trim();
          n[l] == null && Ic(i, l, "");
        }
      else
        for (const a in e)
          n[a] == null && Ic(i, a, "");
    for (const a in n)
      a === "display" && (o = !0), Ic(i, a, n[a]);
  } else if (r) {
    if (e !== n) {
      const a = i[u_];
      a && (n += ";" + a), i.cssText = n, o = d_.test(n);
    }
  } else e && s.removeAttribute("style");
  Jc in s && (s[Jc] = o ? i.display : "", s[C0] && (i.display = "none"));
}
const Np = /\s*!important$/;
function Ic(s, e, n) {
  if (_t(n))
    n.forEach((i) => Ic(s, e, i));
  else if (n == null && (n = ""), e.startsWith("--"))
    s.setProperty(e, n);
  else {
    const i = f_(s, e);
    Np.test(n) ? s.setProperty(
      ur(i),
      n.replace(Np, ""),
      "important"
    ) : s[i] = n;
  }
}
const Bp = ["Webkit", "Moz", "ms"], Qu = {};
function f_(s, e) {
  const n = Qu[e];
  if (n)
    return n;
  let i = Di(e);
  if (i !== "filter" && i in s)
    return Qu[e] = i;
  i = pu(i);
  for (let r = 0; r < Bp.length; r++) {
    const o = Bp[r] + i;
    if (o in s)
      return Qu[e] = o;
  }
  return e;
}
const Vp = "http://www.w3.org/1999/xlink";
function Gp(s, e, n, i, r, o = m1(e)) {
  i && e.startsWith("xlink:") ? n == null ? s.removeAttributeNS(Vp, e.slice(6, e.length)) : s.setAttributeNS(Vp, e, n) : n == null || o && !bg(n) ? s.removeAttribute(e) : s.setAttribute(
    e,
    o ? "" : Wi(n) ? String(n) : n
  );
}
function Hp(s, e, n, i, r) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (s[e] = e === "innerHTML" ? M0(n) : n);
    return;
  }
  const o = s.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? s.getAttribute("value") || "" : s.value, c = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      s.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== c || !("_value" in s)) && (s.value = c), n == null && s.removeAttribute(e), s._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const l = typeof s[e];
    l === "boolean" ? n = bg(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0);
  }
  try {
    s[e] = n;
  } catch {
  }
  a && s.removeAttribute(r || e);
}
function ir(s, e, n, i) {
  s.addEventListener(e, n, i);
}
function p_(s, e, n, i) {
  s.removeEventListener(e, n, i);
}
const $p = Symbol("_vei");
function m_(s, e, n, i, r = null) {
  const o = s[$p] || (s[$p] = {}), a = o[e];
  if (i && a)
    a.value = i;
  else {
    const [l, c] = v_(e);
    if (i) {
      const u = o[e] = x_(
        i,
        r
      );
      ir(s, l, u, c);
    } else a && (p_(s, l, a, c), o[e] = void 0);
  }
}
const Wp = /(?:Once|Passive|Capture)$/;
function v_(s) {
  let e;
  if (Wp.test(s)) {
    e = {};
    let i;
    for (; i = s.match(Wp); )
      s = s.slice(0, s.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [s[2] === ":" ? s.slice(3) : ur(s.slice(2)), e];
}
let ed = 0;
const g_ = /* @__PURE__ */ Promise.resolve(), y_ = () => ed || (g_.then(() => ed = 0), ed = Date.now());
function x_(s, e) {
  const n = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= n.attached)
      return;
    as(
      __(i, n.value),
      e,
      5,
      [i]
    );
  };
  return n.value = s, n.attached = y_(), n;
}
function __(s, e) {
  if (_t(e)) {
    const n = s.stopImmediatePropagation;
    return s.stopImmediatePropagation = () => {
      n.call(s), s._stopped = !0;
    }, e.map(
      (i) => (r) => !r._stopped && i && i(r)
    );
  } else
    return e;
}
const Xp = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // lowercase letter
s.charCodeAt(2) > 96 && s.charCodeAt(2) < 123, b_ = (s, e, n, i, r, o) => {
  const a = r === "svg";
  e === "class" ? c_(s, i, a) : e === "style" ? h_(s, n, i) : du(e) ? af(e) || m_(s, e, n, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : w_(s, e, i, a)) ? (Hp(s, e, i), !s.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Gp(s, e, i, a, o, e !== "value")) : /* #11081 force set props for possible async custom element */ s._isVueCE && (/[A-Z]/.test(e) || !yn(i)) ? Hp(s, Di(e), i, o, e) : (e === "true-value" ? s._trueValue = i : e === "false-value" && (s._falseValue = i), Gp(s, e, i, a));
};
function w_(s, e, n, i) {
  if (i)
    return !!(e === "innerHTML" || e === "textContent" || e in s && Xp(e) && Ct(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && s.tagName === "IFRAME" || e === "form" || e === "list" && s.tagName === "INPUT" || e === "type" && s.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const r = s.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
      return !1;
  }
  return Xp(e) && yn(n) ? !1 : e in s;
}
const Bo = (s) => {
  const e = s.props["onUpdate:modelValue"] || !1;
  return _t(e) ? (n) => Pc(e, n) : e;
};
function S_(s) {
  s.target.composing = !0;
}
function jp(s) {
  const e = s.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const As = Symbol("_assign");
function Yp(s, e, n) {
  return e && (s = s.trim()), n && (s = mu(s)), s;
}
const Ut = {
  created(s, { modifiers: { lazy: e, trim: n, number: i } }, r) {
    s[As] = Bo(r);
    const o = i || r.props && r.props.type === "number";
    ir(s, e ? "change" : "input", (a) => {
      a.target.composing || s[As](Yp(s.value, n, o));
    }), (n || o) && ir(s, "change", () => {
      s.value = Yp(s.value, n, o);
    }), e || (ir(s, "compositionstart", S_), ir(s, "compositionend", jp), ir(s, "change", jp));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(s, { value: e }) {
    s.value = e ?? "";
  },
  beforeUpdate(s, { value: e, oldValue: n, modifiers: { lazy: i, trim: r, number: o } }, a) {
    if (s[As] = Bo(a), s.composing) return;
    const l = (o || s.type === "number") && !/^0\d/.test(s.value) ? mu(s.value) : s.value, c = e ?? "";
    l !== c && (document.activeElement === s && s.type !== "range" && (i && e === n || r && s.value.trim() === c) || (s.value = c));
  }
}, _i = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(s, e, n) {
    s[As] = Bo(n), ir(s, "change", () => {
      const i = s._modelValue, r = rl(s), o = s.checked, a = s[As];
      if (_t(i)) {
        const l = cf(i, r), c = l !== -1;
        if (o && !c)
          a(i.concat(r));
        else if (!o && c) {
          const u = [...i];
          u.splice(l, 1), a(u);
        }
      } else if (Zo(i)) {
        const l = new Set(i);
        o ? l.add(r) : l.delete(r), a(l);
      } else
        a(T0(s, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: qp,
  beforeUpdate(s, e, n) {
    s[As] = Bo(n), qp(s, e, n);
  }
};
function qp(s, { value: e, oldValue: n }, i) {
  s._modelValue = e;
  let r;
  if (_t(e))
    r = cf(e, i.props.value) > -1;
  else if (Zo(e))
    r = e.has(i.props.value);
  else {
    if (e === n) return;
    r = _l(e, T0(s, !0));
  }
  s.checked !== r && (s.checked = r);
}
const Cn = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(s, { value: e, modifiers: { number: n } }, i) {
    const r = Zo(e);
    ir(s, "change", () => {
      const o = Array.prototype.filter.call(s.options, (a) => a.selected).map(
        (a) => n ? mu(rl(a)) : rl(a)
      );
      s[As](
        s.multiple ? r ? new Set(o) : o : o[0]
      ), s._assigning = !0, Pi(() => {
        s._assigning = !1;
      });
    }), s[As] = Bo(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(s, { value: e }) {
    Zp(s, e);
  },
  beforeUpdate(s, e, n) {
    s[As] = Bo(n);
  },
  updated(s, { value: e }) {
    s._assigning || Zp(s, e);
  }
};
function Zp(s, e) {
  const n = s.multiple, i = _t(e);
  if (!(n && !i && !Zo(e))) {
    for (let r = 0, o = s.options.length; r < o; r++) {
      const a = s.options[r], l = rl(a);
      if (n)
        if (i) {
          const c = typeof l;
          c === "string" || c === "number" ? a.selected = e.some((u) => String(u) === String(l)) : a.selected = cf(e, l) > -1;
        } else
          a.selected = e.has(l);
      else if (_l(rl(a), e)) {
        s.selectedIndex !== r && (s.selectedIndex = r);
        return;
      }
    }
    !n && s.selectedIndex !== -1 && (s.selectedIndex = -1);
  }
}
function rl(s) {
  return "_value" in s ? s._value : s.value;
}
function T0(s, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in s ? s[n] : e;
}
const M_ = ["ctrl", "shift", "alt", "meta"], C_ = {
  stop: (s) => s.stopPropagation(),
  prevent: (s) => s.preventDefault(),
  self: (s) => s.target !== s.currentTarget,
  ctrl: (s) => !s.ctrlKey,
  shift: (s) => !s.shiftKey,
  alt: (s) => !s.altKey,
  meta: (s) => !s.metaKey,
  left: (s) => "button" in s && s.button !== 0,
  middle: (s) => "button" in s && s.button !== 1,
  right: (s) => "button" in s && s.button !== 2,
  exact: (s, e) => M_.some((n) => s[`${n}Key`] && !e.includes(n))
}, xt = (s, e) => {
  const n = s._withMods || (s._withMods = {}), i = e.join(".");
  return n[i] || (n[i] = (r, ...o) => {
    for (let a = 0; a < e.length; a++) {
      const l = C_[e[a]];
      if (l && l(r, e)) return;
    }
    return s(r, ...o);
  });
}, T_ = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, ol = (s, e) => {
  const n = s._withKeys || (s._withKeys = {}), i = e.join(".");
  return n[i] || (n[i] = (r) => {
    if (!("key" in r))
      return;
    const o = ur(r.key);
    if (e.some(
      (a) => a === o || T_[a] === o
    ))
      return s(r);
  });
}, E_ = /* @__PURE__ */ Zn({ patchProp: b_ }, a_);
let Kp;
function A_() {
  return Kp || (Kp = Bx(E_));
}
const P_ = (...s) => {
  const e = A_().createApp(...s), { mount: n } = e;
  return e.mount = (i) => {
    const r = D_(i);
    if (!r) return;
    const o = e._component;
    !Ct(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const a = n(r, !1, R_(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), a;
  }, e;
};
function R_(s) {
  if (s instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && s instanceof MathMLElement)
    return "mathml";
}
function D_(s) {
  return yn(s) ? document.querySelector(s) : s;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let E0;
const Cu = (s) => E0 = s, A0 = (
  /* istanbul ignore next */
  Symbol()
);
function lh(s) {
  return s && typeof s == "object" && Object.prototype.toString.call(s) === "[object Object]" && typeof s.toJSON != "function";
}
var Ha;
(function(s) {
  s.direct = "direct", s.patchObject = "patch object", s.patchFunction = "patch function";
})(Ha || (Ha = {}));
function k_() {
  const s = Cg(!0), e = s.run(() => we({}));
  let n = [], i = [];
  const r = Ss({
    install(o) {
      Cu(r), r._a = o, o.provide(A0, r), o.config.globalProperties.$pinia = r, i.forEach((a) => n.push(a)), i = [];
    },
    use(o) {
      return this._a ? n.push(o) : i.push(o), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: s,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return r;
}
const P0 = () => {
};
function Jp(s, e, n, i = P0) {
  s.push(e);
  const r = () => {
    const o = s.indexOf(e);
    o > -1 && (s.splice(o, 1), i());
  };
  return !n && Tg() && g1(r), r;
}
function Qr(s, ...e) {
  s.slice().forEach((n) => {
    n(...e);
  });
}
const I_ = (s) => s(), Qp = Symbol(), td = Symbol();
function ch(s, e) {
  s instanceof Map && e instanceof Map ? e.forEach((n, i) => s.set(i, n)) : s instanceof Set && e instanceof Set && e.forEach(s.add, s);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const i = e[n], r = s[n];
    lh(r) && lh(i) && s.hasOwnProperty(n) && !gn(i) && !Es(i) ? s[n] = ch(r, i) : s[n] = i;
  }
  return s;
}
const L_ = (
  /* istanbul ignore next */
  Symbol()
);
function F_(s) {
  return !lh(s) || !s.hasOwnProperty(L_);
}
const { assign: Js } = Object;
function U_(s) {
  return !!(gn(s) && s.effect);
}
function O_(s, e, n, i) {
  const { state: r, actions: o, getters: a } = e, l = n.state.value[s];
  let c;
  function u() {
    l || (n.state.value[s] = r ? r() : {});
    const d = V1(n.state.value[s]);
    return Js(d, o, Object.keys(a || {}).reduce((h, m) => (h[m] = Ss(Ie(() => {
      Cu(n);
      const p = n._s.get(s);
      return a[m].call(p, p);
    })), h), {}));
  }
  return c = R0(s, u, e, n, i, !0), c;
}
function R0(s, e, n = {}, i, r, o) {
  let a;
  const l = Js({ actions: {} }, n), c = { deep: !0 };
  let u, d, h = [], m = [], p;
  const v = i.state.value[s];
  !o && !v && (i.state.value[s] = {}), we({});
  let _;
  function g(E) {
    let y;
    u = d = !1, typeof E == "function" ? (E(i.state.value[s]), y = {
      type: Ha.patchFunction,
      storeId: s,
      events: p
    }) : (ch(i.state.value[s], E), y = {
      type: Ha.patchObject,
      payload: E,
      storeId: s,
      events: p
    });
    const w = _ = Symbol();
    Pi().then(() => {
      _ === w && (u = !0);
    }), d = !0, Qr(h, y, i.state.value[s]);
  }
  const x = o ? function() {
    const { state: y } = n, w = y ? y() : {};
    this.$patch((D) => {
      Js(D, w);
    });
  } : (
    /* istanbul ignore next */
    P0
  );
  function M() {
    a.stop(), h = [], m = [], i._s.delete(s);
  }
  const S = (E, y = "") => {
    if (Qp in E)
      return E[td] = y, E;
    const w = function() {
      Cu(i);
      const D = Array.from(arguments), U = [], R = [];
      function O(ue) {
        U.push(ue);
      }
      function A(ue) {
        R.push(ue);
      }
      Qr(m, {
        args: D,
        name: w[td],
        store: C,
        after: O,
        onError: A
      });
      let G;
      try {
        G = E.apply(this && this.$id === s ? this : C, D);
      } catch (ue) {
        throw Qr(R, ue), ue;
      }
      return G instanceof Promise ? G.then((ue) => (Qr(U, ue), ue)).catch((ue) => (Qr(R, ue), Promise.reject(ue))) : (Qr(U, G), G);
    };
    return w[Qp] = !0, w[td] = y, w;
  }, b = {
    _p: i,
    // _s: scope,
    $id: s,
    $onAction: Jp.bind(null, m),
    $patch: g,
    $reset: x,
    $subscribe(E, y = {}) {
      const w = Jp(h, E, y.detached, () => D()), D = a.run(() => Ft(() => i.state.value[s], (U) => {
        (y.flush === "sync" ? d : u) && E({
          storeId: s,
          type: Ha.direct,
          events: p
        }, U);
      }, Js({}, c, y)));
      return w;
    },
    $dispose: M
  }, C = $r(b);
  i._s.set(s, C);
  const P = (i._a && i._a.runWithContext || I_)(() => i._e.run(() => (a = Cg()).run(() => e({ action: S }))));
  for (const E in P) {
    const y = P[E];
    if (gn(y) && !U_(y) || Es(y))
      o || (v && F_(y) && (gn(y) ? y.value = v[E] : ch(y, v[E])), i.state.value[s][E] = y);
    else if (typeof y == "function") {
      const w = S(y, E);
      P[E] = w, l.actions[E] = y;
    }
  }
  return Js(C, P), Js(Nt(C), P), Object.defineProperty(C, "$state", {
    get: () => i.state.value[s],
    set: (E) => {
      g((y) => {
        Js(y, E);
      });
    }
  }), i._p.forEach((E) => {
    Js(C, a.run(() => E({
      store: C,
      app: i._a,
      pinia: i,
      options: l
    })));
  }), v && o && n.hydrate && n.hydrate(C.$state, v), u = !0, d = !0, C;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function z_(s, e, n) {
  let i, r;
  const o = typeof e == "function";
  i = s, r = o ? n : e;
  function a(l, c) {
    const u = Sx();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (u ? Bi(A0, null) : null), l && Cu(l), l = E0, l._s.has(i) || (o ? R0(i, e, r, l) : O_(i, r, l)), l._s.get(i);
  }
  return a.$id = i, a;
}
const nd = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: !1 },
    pushOtherPanes: { type: Boolean, default: !0 },
    maximizePanes: { type: Boolean, default: !0 },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: !1 }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(s, { emit: e }) {
    const n = e, i = s, r = px(), o = we([]), a = Ie(() => o.value.reduce((V, Y) => (V[~~Y.id] = Y) && V, {})), l = Ie(() => o.value.length), c = we(null), u = we(!1), d = we({
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), h = we({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), m = Ie(() => ({
      [`splitpanes splitpanes--${i.horizontal ? "horizontal" : "vertical"}`]: !0,
      "splitpanes--dragging": d.value.dragging
    })), p = () => {
      document.addEventListener("mousemove", g, { passive: !1 }), document.addEventListener("mouseup", x), "ontouchstart" in window && (document.addEventListener("touchmove", g, { passive: !1 }), document.addEventListener("touchend", x));
    }, v = () => {
      document.removeEventListener("mousemove", g, { passive: !1 }), document.removeEventListener("mouseup", x), "ontouchstart" in window && (document.removeEventListener("touchmove", g, { passive: !1 }), document.removeEventListener("touchend", x));
    }, _ = (V, Y) => {
      const H = V.target.closest(".splitpanes__splitter");
      if (H) {
        const { left: I, top: F } = H.getBoundingClientRect(), { clientX: L, clientY: ee } = "ontouchstart" in window && V.touches ? V.touches[0] : V;
        d.value.cursorOffset = i.horizontal ? ee - F : L - I;
      }
      p(), d.value.mouseDown = !0, d.value.activeSplitter = Y;
    }, g = (V) => {
      d.value.mouseDown && (V.preventDefault(), d.value.dragging = !0, requestAnimationFrame(() => {
        P(C(V)), ie("resize", { event: V }, !0);
      }));
    }, x = (V) => {
      d.value.dragging && (window.getSelection().removeAllRanges(), ie("resized", { event: V }, !0)), d.value.mouseDown = !1, d.value.activeSplitter = null, setTimeout(() => {
        d.value.dragging = !1, v();
      }, 100);
    }, M = (V, Y) => {
      "ontouchstart" in window && (V.preventDefault(), h.value.splitter === Y ? (clearTimeout(h.value.timeoutId), h.value.timeoutId = null, S(V, Y), h.value.splitter = null) : (h.value.splitter = Y, h.value.timeoutId = setTimeout(() => h.value.splitter = null, 500))), d.value.dragging || ie("splitter-click", { event: V, index: Y }, !0);
    }, S = (V, Y) => {
      if (ie("splitter-dblclick", { event: V, index: Y }, !0), i.maximizePanes) {
        let H = 0;
        o.value = o.value.map((I, F) => (I.size = F === Y ? I.max : I.min, F !== Y && (H += I.min), I)), o.value[Y].size -= H, ie("pane-maximize", { event: V, index: Y, pane: o.value[Y] }), ie("resized", { event: V, index: Y }, !0);
      }
    }, b = (V, Y) => {
      ie("pane-click", {
        event: V,
        index: a.value[Y].index,
        pane: a.value[Y]
      });
    }, C = (V) => {
      const Y = c.value.getBoundingClientRect(), { clientX: H, clientY: I } = "ontouchstart" in window && V.touches ? V.touches[0] : V;
      return {
        x: H - (i.horizontal ? 0 : d.value.cursorOffset) - Y.left,
        y: I - (i.horizontal ? d.value.cursorOffset : 0) - Y.top
      };
    }, T = (V) => {
      V = V[i.horizontal ? "y" : "x"];
      const Y = c.value[i.horizontal ? "clientHeight" : "clientWidth"];
      return i.rtl && !i.horizontal && (V = Y - V), V * 100 / Y;
    }, P = (V) => {
      const Y = d.value.activeSplitter;
      let H = {
        prevPanesSize: y(Y),
        nextPanesSize: w(Y),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const I = 0 + (i.pushOtherPanes ? 0 : H.prevPanesSize), F = 100 - (i.pushOtherPanes ? 0 : H.nextPanesSize), L = Math.max(Math.min(T(V), F), I);
      let ee = [Y, Y + 1], Z = o.value[ee[0]] || null, k = o.value[ee[1]] || null;
      const ne = Z.max < 100 && L >= Z.max + H.prevPanesSize, J = k.max < 100 && L <= 100 - (k.max + w(Y + 1));
      if (ne || J) {
        ne ? (Z.size = Z.max, k.size = Math.max(100 - Z.max - H.prevPanesSize - H.nextPanesSize, 0)) : (Z.size = Math.max(100 - k.max - H.prevPanesSize - w(Y + 1), 0), k.size = k.max);
        return;
      }
      if (i.pushOtherPanes) {
        const B = E(H, L);
        if (!B) return;
        ({ sums: H, panesToResize: ee } = B), Z = o.value[ee[0]] || null, k = o.value[ee[1]] || null;
      }
      Z !== null && (Z.size = Math.min(Math.max(L - H.prevPanesSize - H.prevReachedMinPanes, Z.min), Z.max)), k !== null && (k.size = Math.min(Math.max(100 - L - H.nextPanesSize - H.nextReachedMinPanes, k.min), k.max));
    }, E = (V, Y) => {
      const H = d.value.activeSplitter, I = [H, H + 1];
      return Y < V.prevPanesSize + o.value[I[0]].min && (I[0] = D(H).index, V.prevReachedMinPanes = 0, I[0] < H && o.value.forEach((F, L) => {
        L > I[0] && L <= H && (F.size = F.min, V.prevReachedMinPanes += F.min);
      }), V.prevPanesSize = y(I[0]), I[0] === void 0) ? (V.prevReachedMinPanes = 0, o.value[0].size = o.value[0].min, o.value.forEach((F, L) => {
        L > 0 && L <= H && (F.size = F.min, V.prevReachedMinPanes += F.min);
      }), o.value[I[1]].size = 100 - V.prevReachedMinPanes - o.value[0].min - V.prevPanesSize - V.nextPanesSize, null) : Y > 100 - V.nextPanesSize - o.value[I[1]].min && (I[1] = U(H).index, V.nextReachedMinPanes = 0, I[1] > H + 1 && o.value.forEach((F, L) => {
        L > H && L < I[1] && (F.size = F.min, V.nextReachedMinPanes += F.min);
      }), V.nextPanesSize = w(I[1] - 1), I[1] === void 0) ? (V.nextReachedMinPanes = 0, o.value.forEach((F, L) => {
        L < l.value - 1 && L >= H + 1 && (F.size = F.min, V.nextReachedMinPanes += F.min);
      }), o.value[I[0]].size = 100 - V.prevPanesSize - w(I[0] - 1), null) : { sums: V, panesToResize: I };
    }, y = (V) => o.value.reduce((Y, H, I) => Y + (I < V ? H.size : 0), 0), w = (V) => o.value.reduce((Y, H, I) => Y + (I > V + 1 ? H.size : 0), 0), D = (V) => [...o.value].reverse().find((Y) => Y.index < V && Y.size > Y.min) || {}, U = (V) => o.value.find((Y) => Y.index > V + 1 && Y.size > Y.min) || {}, R = () => {
      var V;
      const Y = Array.from(((V = c.value) == null ? void 0 : V.children) || []);
      for (const H of Y) {
        const I = H.classList.contains("splitpanes__pane"), F = H.classList.contains("splitpanes__splitter");
        !I && !F && (H.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, O = (V, Y, H = !1) => {
      const I = V - 1, F = document.createElement("div");
      F.classList.add("splitpanes__splitter"), H || (F.onmousedown = (L) => _(L, I), typeof window < "u" && "ontouchstart" in window && (F.ontouchstart = (L) => _(L, I)), F.onclick = (L) => M(L, I + 1)), F.ondblclick = (L) => S(L, I + 1), Y.parentNode.insertBefore(F, Y);
    }, A = (V) => {
      V.onmousedown = void 0, V.onclick = void 0, V.ondblclick = void 0, V.remove();
    }, G = () => {
      var V;
      const Y = Array.from(((V = c.value) == null ? void 0 : V.children) || []);
      for (const I of Y)
        I.className.includes("splitpanes__splitter") && A(I);
      let H = 0;
      for (const I of Y)
        I.className.includes("splitpanes__pane") && (!H && i.firstSplitter ? O(H, I, !0) : H && O(H, I), H++);
    }, ue = ({ uid: V, ...Y }) => {
      const H = a.value[V];
      for (const [I, F] of Object.entries(Y)) H[I] = F;
    }, Q = (V) => {
      var Y;
      let H = -1;
      Array.from(((Y = c.value) == null ? void 0 : Y.children) || []).some((I) => (I.className.includes("splitpanes__pane") && H++, I.isSameNode(V.el))), o.value.splice(H, 0, { ...V, index: H }), o.value.forEach((I, F) => I.index = F), u.value && Pi(() => {
        G(), re({ addedPane: o.value[H] }), ie("pane-add", { pane: o.value[H] });
      });
    }, le = (V) => {
      const Y = o.value.findIndex((I) => I.id === V);
      o.value[Y].el = null;
      const H = o.value.splice(Y, 1)[0];
      o.value.forEach((I, F) => I.index = F), Pi(() => {
        G(), ie("pane-remove", { pane: H }), re({ removedPane: { ...H } });
      });
    }, re = (V = {}) => {
      !V.addedPane && !V.removedPane ? $() : o.value.some((Y) => Y.givenSize !== null || Y.min || Y.max < 100) ? q(V) : j(), u.value && ie("resized");
    }, j = () => {
      const V = 100 / l.value;
      let Y = 0;
      const H = [], I = [];
      for (const F of o.value)
        F.size = Math.max(Math.min(V, F.max), F.min), Y -= F.size, F.size >= F.max && H.push(F.id), F.size <= F.min && I.push(F.id);
      Y > 0.1 && oe(Y, H, I);
    }, $ = () => {
      let V = 100;
      const Y = [], H = [];
      let I = 0;
      for (const L of o.value)
        V -= L.size, L.givenSize !== null && I++, L.size >= L.max && Y.push(L.id), L.size <= L.min && H.push(L.id);
      let F = 100;
      if (V > 0.1) {
        for (const L of o.value)
          L.givenSize === null && (L.size = Math.max(Math.min(V / (l.value - I), L.max), L.min)), F -= L.size;
        F > 0.1 && oe(F, Y, H);
      }
    }, q = ({ addedPane: V, removedPane: Y } = {}) => {
      let H = 100 / l.value, I = 0;
      const F = [], L = [];
      ((V == null ? void 0 : V.givenSize) ?? null) !== null && (H = (100 - V.givenSize) / (l.value - 1));
      for (const ee of o.value)
        I -= ee.size, ee.size >= ee.max && F.push(ee.id), ee.size <= ee.min && L.push(ee.id);
      if (!(Math.abs(I) < 0.1)) {
        for (const ee of o.value)
          (V == null ? void 0 : V.givenSize) !== null && (V == null ? void 0 : V.id) === ee.id || (ee.size = Math.max(Math.min(H, ee.max), ee.min)), I -= ee.size, ee.size >= ee.max && F.push(ee.id), ee.size <= ee.min && L.push(ee.id);
        I > 0.1 && oe(I, F, L);
      }
    }, oe = (V, Y, H) => {
      let I;
      V > 0 ? I = V / (l.value - Y.length) : I = V / (l.value - H.length), o.value.forEach((F, L) => {
        if (V > 0 && !Y.includes(F.id)) {
          const ee = Math.max(Math.min(F.size + I, F.max), F.min), Z = ee - F.size;
          V -= Z, F.size = ee;
        } else if (!H.includes(F.id)) {
          const ee = Math.max(Math.min(F.size + I, F.max), F.min), Z = ee - F.size;
          V -= Z, F.size = ee;
        }
      }), Math.abs(V) > 0.1 && Pi(() => {
        u.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, ie = (V, Y = void 0, H = !1) => {
      const I = (Y == null ? void 0 : Y.index) ?? d.value.activeSplitter ?? null;
      n(V, {
        ...Y,
        ...I !== null && { index: I },
        ...H && I !== null && {
          prevPane: o.value[I - (i.firstSplitter ? 1 : 0)],
          nextPane: o.value[I + (i.firstSplitter ? 0 : 1)]
        },
        panes: o.value.map((F) => ({ min: F.min, max: F.max, size: F.size }))
      });
    };
    Ft(() => i.firstSplitter, () => G()), xn(() => {
      R(), G(), re(), ie("ready"), u.value = !0;
    }), yf(() => u.value = !1);
    const ce = () => {
      var V;
      return i_(
        "div",
        { ref: c, class: m.value },
        (V = r.default) == null ? void 0 : V.call(r)
      );
    };
    return Ks("panes", o), Ks("indexedPanes", a), Ks("horizontal", Ie(() => i.horizontal)), Ks("requestUpdate", ue), Ks("onPaneAdd", Q), Ks("onPaneRemove", le), Ks("onPaneClick", b), (V, Y) => (te(), St(t0(ce)));
  }
}, vr = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(s) {
    var e;
    const n = s, i = Bi("requestUpdate"), r = Bi("onPaneAdd"), o = Bi("horizontal"), a = Bi("onPaneRemove"), l = Bi("onPaneClick"), c = (e = Su()) == null ? void 0 : e.uid, u = Bi("indexedPanes"), d = Ie(() => u.value[c]), h = we(null), m = Ie(() => {
      const g = isNaN(n.size) || n.size === void 0 ? 0 : parseFloat(n.size);
      return Math.max(Math.min(g, v.value), p.value);
    }), p = Ie(() => {
      const g = parseFloat(n.minSize);
      return isNaN(g) ? 0 : g;
    }), v = Ie(() => {
      const g = parseFloat(n.maxSize);
      return isNaN(g) ? 100 : g;
    }), _ = Ie(() => {
      var g;
      return `${o.value ? "height" : "width"}: ${(g = d.value) == null ? void 0 : g.size}%`;
    });
    return Ft(() => m.value, (g) => i({ uid: c, size: g })), Ft(() => p.value, (g) => i({ uid: c, min: g })), Ft(() => v.value, (g) => i({ uid: c, max: g })), xn(() => {
      r({
        id: c,
        el: h.value,
        min: p.value,
        max: v.value,
        // The given size (useful to know the user intention).
        givenSize: n.size === void 0 ? null : m.value,
        size: m.value
        // The computed current size at any time.
      });
    }), yf(() => a(c)), (g, x) => (te(), ae("div", {
      ref_key: "paneEl",
      ref: h,
      class: "splitpanes__pane",
      onClick: x[0] || (x[0] = (M) => Ve(l)(M, g._.uid)),
      style: yt(_.value)
    }, [
      hx(g.$slots, "default")
    ], 4));
  }
}, em = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
}, Qc = {
  level: "warn",
  prefix: "[Weyl]"
};
function hs(s) {
  return em[s] >= em[Qc.level];
}
function eo(s, e, n) {
  const i = [];
  return i.push(Qc.prefix), e && i.push(`[${e}]`), i.push(n), i.join(" ");
}
function Ko(s) {
  return {
    debug(e, ...n) {
      hs("debug") && console.log(eo("DEBUG", s, e), ...n);
    },
    info(e, ...n) {
      hs("info") && console.info(eo("INFO", s, e), ...n);
    },
    warn(e, ...n) {
      hs("warn") && console.warn(eo("WARN", s, e), ...n);
    },
    error(e, ...n) {
      hs("error") && console.error(eo("ERROR", s, e), ...n);
    },
    /**
     * Log with a specific level
     */
    log(e, n, ...i) {
      switch (e) {
        case "debug":
          this.debug(n, ...i);
          break;
        case "info":
          this.info(n, ...i);
          break;
        case "warn":
          this.warn(n, ...i);
          break;
        case "error":
          this.error(n, ...i);
          break;
      }
    },
    /**
     * Group related logs (collapsible in console)
     */
    group(e) {
      hs("debug") && console.group(eo("", s, e));
    },
    groupEnd() {
      hs("debug") && console.groupEnd();
    },
    /**
     * Log a table (useful for arrays/objects)
     */
    table(e) {
      hs("debug") && (console.log(eo("", s, "Table:")), console.table(e));
    },
    /**
     * Measure time for an operation
     */
    time(e) {
      hs("debug") && console.time(`${Qc.prefix} [${s}] ${e}`);
    },
    timeEnd(e) {
      hs("debug") && console.timeEnd(`${Qc.prefix} [${s}] ${e}`);
    }
  };
}
const Jt = Ko("Store"), ns = Ko("Engine"), Ei = Ko("Layer"), al = Ko("Render");
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Sf = "170", N_ = 0, tm = 1, B_ = 2, D0 = 1, k0 = 2, _s = 3, ar = 0, hi = 1, vn = 2, os = 0, Hi = 1, ll = 2, uh = 3, Fo = 4, kr = 5, Vi = 100, I0 = 101, V_ = 102, L0 = 103, F0 = 104, G_ = 200, bs = 201, H_ = 202, dh = 203, eu = 204, cl = 205, $_ = 206, W_ = 207, X_ = 208, U0 = 209, j_ = 210, Y_ = 211, q_ = 212, Z_ = 213, K_ = 214, hh = 0, fh = 1, ph = 2, Vo = 3, mh = 4, vh = 5, gh = 6, yh = 7, O0 = 0, J_ = 1, Q_ = 2, or = 0, z0 = 1, N0 = 2, B0 = 3, Mf = 4, eb = 5, V0 = 6, G0 = 7, H0 = 300, Go = 301, Ho = 302, xh = 303, _h = 304, Tu = 306, bh = 1e3, Or = 1001, wh = 1002, On = 1003, tb = 1004, Nl = 1005, Bt = 1006, id = 1007, zr = 1008, ji = 1009, $0 = 1010, W0 = 1011, ul = 1012, Cf = 1013, Wr = 1014, si = 1015, dr = 1016, Tf = 1017, Ef = 1018, $o = 1020, X0 = 35902, j0 = 1021, Y0 = 1022, Rn = 1023, q0 = 1024, Z0 = 1025, Vr = 1026, Wo = 1027, tu = 1028, Af = 1029, K0 = 1030, Pf = 1031, Rf = 1033, Lc = 33776, Fc = 33777, Uc = 33778, Oc = 33779, Sh = 35840, Mh = 35841, Ch = 35842, Th = 35843, Eh = 36196, Ah = 37492, Ph = 37496, Rh = 37808, Dh = 37809, kh = 37810, Ih = 37811, Lh = 37812, Fh = 37813, Uh = 37814, Oh = 37815, zh = 37816, Nh = 37817, Bh = 37818, Vh = 37819, Gh = 37820, Hh = 37821, zc = 36492, $h = 36494, Wh = 36495, J0 = 36283, Xh = 36284, jh = 36285, Yh = 36286, nb = 3200, Df = 3201, kf = 0, ib = 1, sr = "", dn = "srgb", Jo = "srgb-linear", Eu = "linear", qt = "srgb", to = 7680, nm = 519, sb = 512, rb = 513, ob = 514, Q0 = 515, ab = 516, lb = 517, cb = 518, ub = 519, im = 35044, no = 35048, sm = "300 es", Ts = 2e3, nu = 2001;
class jr {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const o = r.indexOf(n);
      o !== -1 && r.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let o = 0, a = r.length; o < a; o++)
        r[o].call(this, e);
      e.target = null;
    }
  }
}
const Hn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let rm = 1234567;
const $a = Math.PI / 180, Xo = 180 / Math.PI;
function Yr() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Hn[s & 255] + Hn[s >> 8 & 255] + Hn[s >> 16 & 255] + Hn[s >> 24 & 255] + "-" + Hn[e & 255] + Hn[e >> 8 & 255] + "-" + Hn[e >> 16 & 15 | 64] + Hn[e >> 24 & 255] + "-" + Hn[n & 63 | 128] + Hn[n >> 8 & 255] + "-" + Hn[n >> 16 & 255] + Hn[n >> 24 & 255] + Hn[i & 255] + Hn[i >> 8 & 255] + Hn[i >> 16 & 255] + Hn[i >> 24 & 255]).toLowerCase();
}
function Fn(s, e, n) {
  return Math.max(e, Math.min(n, s));
}
function If(s, e) {
  return (s % e + e) % e;
}
function db(s, e, n, i, r) {
  return i + (s - e) * (r - i) / (n - e);
}
function hb(s, e, n) {
  return s !== e ? (n - s) / (e - s) : 0;
}
function Wa(s, e, n) {
  return (1 - n) * s + n * e;
}
function fb(s, e, n, i) {
  return Wa(s, e, 1 - Math.exp(-n * i));
}
function pb(s, e = 1) {
  return e - Math.abs(If(s, e * 2) - e);
}
function mb(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * (3 - 2 * s));
}
function vb(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function gb(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function yb(s, e) {
  return s + Math.random() * (e - s);
}
function xb(s) {
  return s * (0.5 - Math.random());
}
function _b(s) {
  s !== void 0 && (rm = s);
  let e = rm += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function bb(s) {
  return s * $a;
}
function wb(s) {
  return s * Xo;
}
function Sb(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function Mb(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function Cb(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function Tb(s, e, n, i, r) {
  const o = Math.cos, a = Math.sin, l = o(n / 2), c = a(n / 2), u = o((e + i) / 2), d = a((e + i) / 2), h = o((e - i) / 2), m = a((e - i) / 2), p = o((i - e) / 2), v = a((i - e) / 2);
  switch (r) {
    case "XYX":
      s.set(l * d, c * h, c * m, l * u);
      break;
    case "YZY":
      s.set(c * m, l * d, c * h, l * u);
      break;
    case "ZXZ":
      s.set(c * h, c * m, l * d, l * u);
      break;
    case "XZX":
      s.set(l * d, c * v, c * p, l * u);
      break;
    case "YXY":
      s.set(c * p, l * d, c * v, l * u);
      break;
    case "ZYZ":
      s.set(c * v, c * p, l * d, l * u);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function So(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Qn(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const mn = {
  DEG2RAD: $a,
  RAD2DEG: Xo,
  generateUUID: Yr,
  clamp: Fn,
  euclideanModulo: If,
  mapLinear: db,
  inverseLerp: hb,
  lerp: Wa,
  damp: fb,
  pingpong: pb,
  smoothstep: mb,
  smootherstep: vb,
  randInt: gb,
  randFloat: yb,
  randFloatSpread: xb,
  seededRandom: _b,
  degToRad: bb,
  radToDeg: wb,
  isPowerOfTwo: Sb,
  ceilPowerOfTwo: Mb,
  floorPowerOfTwo: Cb,
  setQuaternionFromProperEuler: Tb,
  normalize: Qn,
  denormalize: So
};
class rt {
  constructor(e = 0, n = 0) {
    rt.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * n + r[3] * i + r[6], this.y = r[1] * n + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Fn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n), r = Math.sin(n), o = this.x - e.x, a = this.y - e.y;
    return this.x = o * i - a * r + e.x, this.y = o * r + a * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Tt {
  constructor(e, n, i, r, o, a, l, c, u) {
    Tt.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, r, o, a, l, c, u);
  }
  set(e, n, i, r, o, a, l, c, u) {
    const d = this.elements;
    return d[0] = e, d[1] = r, d[2] = l, d[3] = n, d[4] = o, d[5] = c, d[6] = i, d[7] = a, d[8] = u, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, r = n.elements, o = this.elements, a = i[0], l = i[3], c = i[6], u = i[1], d = i[4], h = i[7], m = i[2], p = i[5], v = i[8], _ = r[0], g = r[3], x = r[6], M = r[1], S = r[4], b = r[7], C = r[2], T = r[5], P = r[8];
    return o[0] = a * _ + l * M + c * C, o[3] = a * g + l * S + c * T, o[6] = a * x + l * b + c * P, o[1] = u * _ + d * M + h * C, o[4] = u * g + d * S + h * T, o[7] = u * x + d * b + h * P, o[2] = m * _ + p * M + v * C, o[5] = m * g + p * S + v * T, o[8] = m * x + p * b + v * P, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8];
    return n * a * d - n * l * u - i * o * d + i * l * c + r * o * u - r * a * c;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = d * a - l * u, m = l * c - d * o, p = u * o - a * c, v = n * h + i * m + r * p;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / v;
    return e[0] = h * _, e[1] = (r * u - d * i) * _, e[2] = (l * i - r * a) * _, e[3] = m * _, e[4] = (d * n - r * c) * _, e[5] = (r * o - l * n) * _, e[6] = p * _, e[7] = (i * c - u * n) * _, e[8] = (a * n - i * o) * _, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, i, r, o, a, l) {
    const c = Math.cos(o), u = Math.sin(o);
    return this.set(
      i * c,
      i * u,
      -i * (c * a + u * l) + a + e,
      -r * u,
      r * c,
      -r * (-u * a + c * l) + l + n,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, n) {
    return this.premultiply(sd.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(sd.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(sd.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      i,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++)
      if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const sd = /* @__PURE__ */ new Tt();
function ey(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
function dl(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function Eb() {
  const s = dl("canvas");
  return s.style.display = "block", s;
}
const om = {};
function Da(s) {
  s in om || (om[s] = !0, console.warn(s));
}
function Ab(s, e, n) {
  return new Promise(function(i, r) {
    function o() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          r();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(o, n);
          break;
        default:
          i();
      }
    }
    setTimeout(o, n);
  });
}
function Pb(s) {
  const e = s.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function Rb(s) {
  const e = s.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const It = {
  enabled: !0,
  workingColorSpace: Jo,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(s, e, n) {
    return this.enabled === !1 || e === n || !e || !n || (this.spaces[e].transfer === qt && (s.r = Ps(s.r), s.g = Ps(s.g), s.b = Ps(s.b)), this.spaces[e].primaries !== this.spaces[n].primaries && (s.applyMatrix3(this.spaces[e].toXYZ), s.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === qt && (s.r = Uo(s.r), s.g = Uo(s.g), s.b = Uo(s.b))), s;
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this.workingColorSpace);
  },
  getPrimaries: function(s) {
    return this.spaces[s].primaries;
  },
  getTransfer: function(s) {
    return s === sr ? Eu : this.spaces[s].transfer;
  },
  getLuminanceCoefficients: function(s, e = this.workingColorSpace) {
    return s.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(s) {
    Object.assign(this.spaces, s);
  },
  // Internal APIs
  _getMatrix: function(s, e, n) {
    return s.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(s) {
    return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(s = this.workingColorSpace) {
    return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
  }
};
function Ps(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function Uo(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
const am = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], lm = [0.2126, 0.7152, 0.0722], cm = [0.3127, 0.329], um = /* @__PURE__ */ new Tt().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), dm = /* @__PURE__ */ new Tt().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
It.define({
  [Jo]: {
    primaries: am,
    whitePoint: cm,
    transfer: Eu,
    toXYZ: um,
    fromXYZ: dm,
    luminanceCoefficients: lm,
    workingColorSpaceConfig: { unpackColorSpace: dn },
    outputColorSpaceConfig: { drawingBufferColorSpace: dn }
  },
  [dn]: {
    primaries: am,
    whitePoint: cm,
    transfer: qt,
    toXYZ: um,
    fromXYZ: dm,
    luminanceCoefficients: lm,
    outputColorSpaceConfig: { drawingBufferColorSpace: dn }
  }
});
let io;
class Db {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      io === void 0 && (io = dl("canvas")), io.width = e.width, io.height = e.height;
      const i = io.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = io;
    }
    return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = dl("canvas");
      n.width = e.width, n.height = e.height;
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), o = r.data;
      for (let a = 0; a < o.length; a++)
        o[a] = Ps(o[a] / 255) * 255;
      return i.putImageData(r, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(Ps(n[i] / 255) * 255) : n[i] = Ps(n[i]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let kb = 0;
class ty {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: kb++ }), this.uuid = Yr(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let o;
      if (Array.isArray(r)) {
        o = [];
        for (let a = 0, l = r.length; a < l; a++)
          r[a].isDataTexture ? o.push(rd(r[a].image)) : o.push(rd(r[a]));
      } else
        o = rd(r);
      i.url = o;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function rd(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Db.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Ib = 0;
class _n extends jr {
  constructor(e = _n.DEFAULT_IMAGE, n = _n.DEFAULT_MAPPING, i = Or, r = Or, o = Bt, a = zr, l = Rn, c = ji, u = _n.DEFAULT_ANISOTROPY, d = sr) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Ib++ }), this.uuid = Yr(), this.name = "", this.source = new ty(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = o, this.minFilter = a, this.anisotropy = u, this.format = l, this.internalFormat = null, this.type = c, this.offset = new rt(0, 0), this.repeat = new rt(1, 1), this.center = new rt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Tt(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), n || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== H0) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case bh:
          e.x = e.x - Math.floor(e.x);
          break;
        case Or:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case wh:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case bh:
          e.y = e.y - Math.floor(e.y);
          break;
        case Or:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case wh:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
_n.DEFAULT_IMAGE = null;
_n.DEFAULT_MAPPING = H0;
_n.DEFAULT_ANISOTROPY = 1;
class jt {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    jt.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, r) {
    return this.x = e, this.y = n, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, r = this.z, o = this.w, a = e.elements;
    return this.x = a[0] * n + a[4] * i + a[8] * r + a[12] * o, this.y = a[1] * n + a[5] * i + a[9] * r + a[13] * o, this.z = a[2] * n + a[6] * i + a[10] * r + a[14] * o, this.w = a[3] * n + a[7] * i + a[11] * r + a[15] * o, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, r, o;
    const c = e.elements, u = c[0], d = c[4], h = c[8], m = c[1], p = c[5], v = c[9], _ = c[2], g = c[6], x = c[10];
    if (Math.abs(d - m) < 0.01 && Math.abs(h - _) < 0.01 && Math.abs(v - g) < 0.01) {
      if (Math.abs(d + m) < 0.1 && Math.abs(h + _) < 0.1 && Math.abs(v + g) < 0.1 && Math.abs(u + p + x - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const S = (u + 1) / 2, b = (p + 1) / 2, C = (x + 1) / 2, T = (d + m) / 4, P = (h + _) / 4, E = (v + g) / 4;
      return S > b && S > C ? S < 0.01 ? (i = 0, r = 0.707106781, o = 0.707106781) : (i = Math.sqrt(S), r = T / i, o = P / i) : b > C ? b < 0.01 ? (i = 0.707106781, r = 0, o = 0.707106781) : (r = Math.sqrt(b), i = T / r, o = E / r) : C < 0.01 ? (i = 0.707106781, r = 0.707106781, o = 0) : (o = Math.sqrt(C), i = P / o, r = E / o), this.set(i, r, o, n), this;
    }
    let M = Math.sqrt((g - v) * (g - v) + (h - _) * (h - _) + (m - d) * (m - d));
    return Math.abs(M) < 1e-3 && (M = 1), this.x = (g - v) / M, this.y = (h - _) / M, this.z = (m - d) / M, this.w = Math.acos((u + p + x - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this.w = e.w + (n.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Lb extends jr {
  constructor(e = 1, n = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new jt(0, 0, e, n), this.scissorTest = !1, this.viewport = new jt(0, 0, e, n);
    const r = { width: e, height: n, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Bt,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const o = new _n(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    o.flipY = !1, o.generateMipmaps = i.generateMipmaps, o.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let l = 0; l < a; l++)
      this.textures[l] = o.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      this.width = e, this.height = n, this.depth = i;
      for (let r = 0, o = this.textures.length; r < o; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = n, this.textures[r].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let i = 0, r = e.textures.length; i < r; i++)
      this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const n = Object.assign({}, e.texture.image);
    return this.texture.source = new ty(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Ri extends Lb {
  constructor(e = 1, n = 1, i = {}) {
    super(e, n, i), this.isWebGLRenderTarget = !0;
  }
}
class ny extends _n {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: i, depth: r }, this.magFilter = On, this.minFilter = On, this.wrapR = Or, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Fb extends _n {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: i, depth: r }, this.magFilter = On, this.minFilter = On, this.wrapR = Or, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class ni {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = i, this._w = r;
  }
  static slerpFlat(e, n, i, r, o, a, l) {
    let c = i[r + 0], u = i[r + 1], d = i[r + 2], h = i[r + 3];
    const m = o[a + 0], p = o[a + 1], v = o[a + 2], _ = o[a + 3];
    if (l === 0) {
      e[n + 0] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
      return;
    }
    if (l === 1) {
      e[n + 0] = m, e[n + 1] = p, e[n + 2] = v, e[n + 3] = _;
      return;
    }
    if (h !== _ || c !== m || u !== p || d !== v) {
      let g = 1 - l;
      const x = c * m + u * p + d * v + h * _, M = x >= 0 ? 1 : -1, S = 1 - x * x;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S), T = Math.atan2(C, x * M);
        g = Math.sin(g * T) / C, l = Math.sin(l * T) / C;
      }
      const b = l * M;
      if (c = c * g + m * b, u = u * g + p * b, d = d * g + v * b, h = h * g + _ * b, g === 1 - l) {
        const C = 1 / Math.sqrt(c * c + u * u + d * d + h * h);
        c *= C, u *= C, d *= C, h *= C;
      }
    }
    e[n] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
  }
  static multiplyQuaternionsFlat(e, n, i, r, o, a) {
    const l = i[r], c = i[r + 1], u = i[r + 2], d = i[r + 3], h = o[a], m = o[a + 1], p = o[a + 2], v = o[a + 3];
    return e[n] = l * v + d * h + c * p - u * m, e[n + 1] = c * v + d * m + u * h - l * p, e[n + 2] = u * v + d * p + l * m - c * h, e[n + 3] = d * v - l * h - c * m - u * p, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, i, r) {
    return this._x = e, this._y = n, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n = !0) {
    const i = e._x, r = e._y, o = e._z, a = e._order, l = Math.cos, c = Math.sin, u = l(i / 2), d = l(r / 2), h = l(o / 2), m = c(i / 2), p = c(r / 2), v = c(o / 2);
    switch (a) {
      case "XYZ":
        this._x = m * d * h + u * p * v, this._y = u * p * h - m * d * v, this._z = u * d * v + m * p * h, this._w = u * d * h - m * p * v;
        break;
      case "YXZ":
        this._x = m * d * h + u * p * v, this._y = u * p * h - m * d * v, this._z = u * d * v - m * p * h, this._w = u * d * h + m * p * v;
        break;
      case "ZXY":
        this._x = m * d * h - u * p * v, this._y = u * p * h + m * d * v, this._z = u * d * v + m * p * h, this._w = u * d * h - m * p * v;
        break;
      case "ZYX":
        this._x = m * d * h - u * p * v, this._y = u * p * h + m * d * v, this._z = u * d * v - m * p * h, this._w = u * d * h + m * p * v;
        break;
      case "YZX":
        this._x = m * d * h + u * p * v, this._y = u * p * h + m * d * v, this._z = u * d * v - m * p * h, this._w = u * d * h - m * p * v;
        break;
      case "XZY":
        this._x = m * d * h - u * p * v, this._y = u * p * h - m * d * v, this._z = u * d * v + m * p * h, this._w = u * d * h + m * p * v;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, i = n[0], r = n[4], o = n[8], a = n[1], l = n[5], c = n[9], u = n[2], d = n[6], h = n[10], m = i + l + h;
    if (m > 0) {
      const p = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / p, this._x = (d - c) * p, this._y = (o - u) * p, this._z = (a - r) * p;
    } else if (i > l && i > h) {
      const p = 2 * Math.sqrt(1 + i - l - h);
      this._w = (d - c) / p, this._x = 0.25 * p, this._y = (r + a) / p, this._z = (o + u) / p;
    } else if (l > h) {
      const p = 2 * Math.sqrt(1 + l - i - h);
      this._w = (o - u) / p, this._x = (r + a) / p, this._y = 0.25 * p, this._z = (c + d) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - l);
      this._w = (a - r) / p, this._x = (o + u) / p, this._y = (c + d) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Fn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, n / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x, r = e._y, o = e._z, a = e._w, l = n._x, c = n._y, u = n._z, d = n._w;
    return this._x = i * d + a * l + r * u - o * c, this._y = r * d + a * c + o * l - i * u, this._z = o * d + a * u + i * c - r * l, this._w = a * d - i * l - r * c - o * u, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x, r = this._y, o = this._z, a = this._w;
    let l = a * e._w + i * e._x + r * e._y + o * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = a, this._x = i, this._y = r, this._z = o, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const p = 1 - n;
      return this._w = p * a + n * this._w, this._x = p * i + n * this._x, this._y = p * r + n * this._y, this._z = p * o + n * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(c), d = Math.atan2(u, l), h = Math.sin((1 - n) * d) / u, m = Math.sin(n * d) / u;
    return this._w = a * h + this._w * m, this._x = i * h + this._x * m, this._y = r * h + this._y * m, this._z = o * h + this._z * m, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), i = Math.random(), r = Math.sqrt(1 - i), o = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      o * Math.sin(n),
      o * Math.cos(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class de {
  constructor(e = 0, n = 0, i = 0) {
    de.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = i;
  }
  set(e, n, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = n, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(hm.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(hm.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * n + o[3] * i + o[6] * r, this.y = o[1] * n + o[4] * i + o[7] * r, this.z = o[2] * n + o[5] * i + o[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements, a = 1 / (o[3] * n + o[7] * i + o[11] * r + o[15]);
    return this.x = (o[0] * n + o[4] * i + o[8] * r + o[12]) * a, this.y = (o[1] * n + o[5] * i + o[9] * r + o[13]) * a, this.z = (o[2] * n + o[6] * i + o[10] * r + o[14]) * a, this;
  }
  applyQuaternion(e) {
    const n = this.x, i = this.y, r = this.z, o = e.x, a = e.y, l = e.z, c = e.w, u = 2 * (a * r - l * i), d = 2 * (l * n - o * r), h = 2 * (o * i - a * n);
    return this.x = n + c * u + a * h - l * d, this.y = i + c * d + l * u - o * h, this.z = r + c * h + o * d - a * u, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * n + o[4] * i + o[8] * r, this.y = o[1] * n + o[5] * i + o[9] * r, this.z = o[2] * n + o[6] * i + o[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x, r = e.y, o = e.z, a = n.x, l = n.y, c = n.z;
    return this.x = r * c - o * l, this.y = o * a - i * c, this.z = i * l - r * a, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return od.copy(this).projectOnVector(e), this.sub(od);
  }
  reflect(e) {
    return this.sub(od.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Fn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return n * n + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const r = Math.sin(n) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(n) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return this.x = e * Math.sin(n), this.y = i, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, i = Math.sqrt(1 - n * n);
    return this.x = i * Math.cos(e), this.y = n, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const od = /* @__PURE__ */ new de(), hm = /* @__PURE__ */ new ni();
class hr {
  constructor(e = new de(1 / 0, 1 / 0, 1 / 0), n = new de(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(Fi.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(Fi.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = Fi.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const o = i.getAttribute("position");
      if (n === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, l = o.count; a < l; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Fi) : Fi.fromBufferAttribute(o, a), Fi.applyMatrix4(e.matrixWorld), this.expandByPoint(Fi);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Bl.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Bl.copy(i.boundingBox)), Bl.applyMatrix4(e.matrixWorld), this.union(Bl);
    }
    const r = e.children;
    for (let o = 0, a = r.length; o < a; o++)
      this.expandByObject(r[o], n);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Fi), Fi.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, i;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, i += e.normal.z * this.min.z), n <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(fa), Vl.subVectors(this.max, fa), so.subVectors(e.a, fa), ro.subVectors(e.b, fa), oo.subVectors(e.c, fa), Vs.subVectors(ro, so), Gs.subVectors(oo, ro), gr.subVectors(so, oo);
    let n = [
      0,
      -Vs.z,
      Vs.y,
      0,
      -Gs.z,
      Gs.y,
      0,
      -gr.z,
      gr.y,
      Vs.z,
      0,
      -Vs.x,
      Gs.z,
      0,
      -Gs.x,
      gr.z,
      0,
      -gr.x,
      -Vs.y,
      Vs.x,
      0,
      -Gs.y,
      Gs.x,
      0,
      -gr.y,
      gr.x,
      0
    ];
    return !ad(n, so, ro, oo, Vl) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !ad(n, so, ro, oo, Vl)) ? !1 : (Gl.crossVectors(Vs, Gs), n = [Gl.x, Gl.y, Gl.z], ad(n, so, ro, oo, Vl));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Fi).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Fi).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (fs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), fs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), fs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), fs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), fs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), fs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), fs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), fs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(fs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const fs = [
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de(),
  /* @__PURE__ */ new de()
], Fi = /* @__PURE__ */ new de(), Bl = /* @__PURE__ */ new hr(), so = /* @__PURE__ */ new de(), ro = /* @__PURE__ */ new de(), oo = /* @__PURE__ */ new de(), Vs = /* @__PURE__ */ new de(), Gs = /* @__PURE__ */ new de(), gr = /* @__PURE__ */ new de(), fa = /* @__PURE__ */ new de(), Vl = /* @__PURE__ */ new de(), Gl = /* @__PURE__ */ new de(), yr = /* @__PURE__ */ new de();
function ad(s, e, n, i, r) {
  for (let o = 0, a = s.length - 3; o <= a; o += 3) {
    yr.fromArray(s, o);
    const l = r.x * Math.abs(yr.x) + r.y * Math.abs(yr.y) + r.z * Math.abs(yr.z), c = e.dot(yr), u = n.dot(yr), d = i.dot(yr);
    if (Math.max(-Math.max(c, u, d), Math.min(c, u, d)) > l)
      return !1;
  }
  return !0;
}
const Ub = /* @__PURE__ */ new hr(), pa = /* @__PURE__ */ new de(), ld = /* @__PURE__ */ new de();
class Sl {
  constructor(e = new de(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : Ub.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let o = 0, a = e.length; o < a; o++)
      r = Math.max(r, i.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    pa.subVectors(e, this.center);
    const n = pa.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n), r = (i - this.radius) * 0.5;
      this.center.addScaledVector(pa, r / i), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (ld.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(pa.copy(e.center).add(ld)), this.expandByPoint(pa.copy(e.center).sub(ld))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ps = /* @__PURE__ */ new de(), cd = /* @__PURE__ */ new de(), Hl = /* @__PURE__ */ new de(), Hs = /* @__PURE__ */ new de(), ud = /* @__PURE__ */ new de(), $l = /* @__PURE__ */ new de(), dd = /* @__PURE__ */ new de();
class Lf {
  constructor(e = new de(), n = new de(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, ps)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = ps.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (ps.copy(this.origin).addScaledVector(this.direction, n), ps.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, r) {
    cd.copy(e).add(n).multiplyScalar(0.5), Hl.copy(n).sub(e).normalize(), Hs.copy(this.origin).sub(cd);
    const o = e.distanceTo(n) * 0.5, a = -this.direction.dot(Hl), l = Hs.dot(this.direction), c = -Hs.dot(Hl), u = Hs.lengthSq(), d = Math.abs(1 - a * a);
    let h, m, p, v;
    if (d > 0)
      if (h = a * c - l, m = a * l - c, v = o * d, h >= 0)
        if (m >= -v)
          if (m <= v) {
            const _ = 1 / d;
            h *= _, m *= _, p = h * (h + a * m + 2 * l) + m * (a * h + m + 2 * c) + u;
          } else
            m = o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
        else
          m = -o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
      else
        m <= -v ? (h = Math.max(0, -(-a * o + l)), m = h > 0 ? -o : Math.min(Math.max(-o, -c), o), p = -h * h + m * (m + 2 * c) + u) : m <= v ? (h = 0, m = Math.min(Math.max(-o, -c), o), p = m * (m + 2 * c) + u) : (h = Math.max(0, -(a * o + l)), m = h > 0 ? o : Math.min(Math.max(-o, -c), o), p = -h * h + m * (m + 2 * c) + u);
    else
      m = a > 0 ? -o : o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), r && r.copy(cd).addScaledVector(Hl, m), p;
  }
  intersectSphere(e, n) {
    ps.subVectors(e.center, this.origin);
    const i = ps.dot(this.direction), r = ps.dot(ps) - i * i, o = e.radius * e.radius;
    if (r > o) return null;
    const a = Math.sqrt(o - r), l = i - a, c = i + a;
    return c < 0 ? null : l < 0 ? this.at(c, n) : this.at(l, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, r, o, a, l, c;
    const u = 1 / this.direction.x, d = 1 / this.direction.y, h = 1 / this.direction.z, m = this.origin;
    return u >= 0 ? (i = (e.min.x - m.x) * u, r = (e.max.x - m.x) * u) : (i = (e.max.x - m.x) * u, r = (e.min.x - m.x) * u), d >= 0 ? (o = (e.min.y - m.y) * d, a = (e.max.y - m.y) * d) : (o = (e.max.y - m.y) * d, a = (e.min.y - m.y) * d), i > a || o > r || ((o > i || isNaN(i)) && (i = o), (a < r || isNaN(r)) && (r = a), h >= 0 ? (l = (e.min.z - m.z) * h, c = (e.max.z - m.z) * h) : (l = (e.max.z - m.z) * h, c = (e.min.z - m.z) * h), i > c || l > r) || ((l > i || i !== i) && (i = l), (c < r || r !== r) && (r = c), r < 0) ? null : this.at(i >= 0 ? i : r, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, ps) !== null;
  }
  intersectTriangle(e, n, i, r, o) {
    ud.subVectors(n, e), $l.subVectors(i, e), dd.crossVectors(ud, $l);
    let a = this.direction.dot(dd), l;
    if (a > 0) {
      if (r) return null;
      l = 1;
    } else if (a < 0)
      l = -1, a = -a;
    else
      return null;
    Hs.subVectors(this.origin, e);
    const c = l * this.direction.dot($l.crossVectors(Hs, $l));
    if (c < 0)
      return null;
    const u = l * this.direction.dot(ud.cross(Hs));
    if (u < 0 || c + u > a)
      return null;
    const d = -l * Hs.dot(dd);
    return d < 0 ? null : this.at(d / a, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Zt {
  constructor(e, n, i, r, o, a, l, c, u, d, h, m, p, v, _, g) {
    Zt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, r, o, a, l, c, u, d, h, m, p, v, _, g);
  }
  set(e, n, i, r, o, a, l, c, u, d, h, m, p, v, _, g) {
    const x = this.elements;
    return x[0] = e, x[4] = n, x[8] = i, x[12] = r, x[1] = o, x[5] = a, x[9] = l, x[13] = c, x[2] = u, x[6] = d, x[10] = h, x[14] = m, x[3] = p, x[7] = v, x[11] = _, x[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Zt().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
  }
  copyPosition(e) {
    const n = this.elements, i = e.elements;
    return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, i) {
    return this.set(
      e.x,
      n.x,
      i.x,
      0,
      e.y,
      n.y,
      i.y,
      0,
      e.z,
      n.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, i = e.elements, r = 1 / ao.setFromMatrixColumn(e, 0).length(), o = 1 / ao.setFromMatrixColumn(e, 1).length(), a = 1 / ao.setFromMatrixColumn(e, 2).length();
    return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[3] = 0, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[7] = 0, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const n = this.elements, i = e.x, r = e.y, o = e.z, a = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r), d = Math.cos(o), h = Math.sin(o);
    if (e.order === "XYZ") {
      const m = a * d, p = a * h, v = l * d, _ = l * h;
      n[0] = c * d, n[4] = -c * h, n[8] = u, n[1] = p + v * u, n[5] = m - _ * u, n[9] = -l * c, n[2] = _ - m * u, n[6] = v + p * u, n[10] = a * c;
    } else if (e.order === "YXZ") {
      const m = c * d, p = c * h, v = u * d, _ = u * h;
      n[0] = m + _ * l, n[4] = v * l - p, n[8] = a * u, n[1] = a * h, n[5] = a * d, n[9] = -l, n[2] = p * l - v, n[6] = _ + m * l, n[10] = a * c;
    } else if (e.order === "ZXY") {
      const m = c * d, p = c * h, v = u * d, _ = u * h;
      n[0] = m - _ * l, n[4] = -a * h, n[8] = v + p * l, n[1] = p + v * l, n[5] = a * d, n[9] = _ - m * l, n[2] = -a * u, n[6] = l, n[10] = a * c;
    } else if (e.order === "ZYX") {
      const m = a * d, p = a * h, v = l * d, _ = l * h;
      n[0] = c * d, n[4] = v * u - p, n[8] = m * u + _, n[1] = c * h, n[5] = _ * u + m, n[9] = p * u - v, n[2] = -u, n[6] = l * c, n[10] = a * c;
    } else if (e.order === "YZX") {
      const m = a * c, p = a * u, v = l * c, _ = l * u;
      n[0] = c * d, n[4] = _ - m * h, n[8] = v * h + p, n[1] = h, n[5] = a * d, n[9] = -l * d, n[2] = -u * d, n[6] = p * h + v, n[10] = m - _ * h;
    } else if (e.order === "XZY") {
      const m = a * c, p = a * u, v = l * c, _ = l * u;
      n[0] = c * d, n[4] = -h, n[8] = u * d, n[1] = m * h + _, n[5] = a * d, n[9] = p * h - v, n[2] = v * h - p, n[6] = l * d, n[10] = _ * h + m;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Ob, e, zb);
  }
  lookAt(e, n, i) {
    const r = this.elements;
    return yi.subVectors(e, n), yi.lengthSq() === 0 && (yi.z = 1), yi.normalize(), $s.crossVectors(i, yi), $s.lengthSq() === 0 && (Math.abs(i.z) === 1 ? yi.x += 1e-4 : yi.z += 1e-4, yi.normalize(), $s.crossVectors(i, yi)), $s.normalize(), Wl.crossVectors(yi, $s), r[0] = $s.x, r[4] = Wl.x, r[8] = yi.x, r[1] = $s.y, r[5] = Wl.y, r[9] = yi.y, r[2] = $s.z, r[6] = Wl.z, r[10] = yi.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, r = n.elements, o = this.elements, a = i[0], l = i[4], c = i[8], u = i[12], d = i[1], h = i[5], m = i[9], p = i[13], v = i[2], _ = i[6], g = i[10], x = i[14], M = i[3], S = i[7], b = i[11], C = i[15], T = r[0], P = r[4], E = r[8], y = r[12], w = r[1], D = r[5], U = r[9], R = r[13], O = r[2], A = r[6], G = r[10], ue = r[14], Q = r[3], le = r[7], re = r[11], j = r[15];
    return o[0] = a * T + l * w + c * O + u * Q, o[4] = a * P + l * D + c * A + u * le, o[8] = a * E + l * U + c * G + u * re, o[12] = a * y + l * R + c * ue + u * j, o[1] = d * T + h * w + m * O + p * Q, o[5] = d * P + h * D + m * A + p * le, o[9] = d * E + h * U + m * G + p * re, o[13] = d * y + h * R + m * ue + p * j, o[2] = v * T + _ * w + g * O + x * Q, o[6] = v * P + _ * D + g * A + x * le, o[10] = v * E + _ * U + g * G + x * re, o[14] = v * y + _ * R + g * ue + x * j, o[3] = M * T + S * w + b * O + C * Q, o[7] = M * P + S * D + b * A + C * le, o[11] = M * E + S * U + b * G + C * re, o[15] = M * y + S * R + b * ue + C * j, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[4], r = e[8], o = e[12], a = e[1], l = e[5], c = e[9], u = e[13], d = e[2], h = e[6], m = e[10], p = e[14], v = e[3], _ = e[7], g = e[11], x = e[15];
    return v * (+o * c * h - r * u * h - o * l * m + i * u * m + r * l * p - i * c * p) + _ * (+n * c * p - n * u * m + o * a * m - r * a * p + r * u * d - o * c * d) + g * (+n * u * h - n * l * p - o * a * h + i * a * p + o * l * d - i * u * d) + x * (-r * l * d - n * c * h + n * l * m + r * a * h - i * a * m + i * c * d);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = n, r[14] = i), this;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = e[9], m = e[10], p = e[11], v = e[12], _ = e[13], g = e[14], x = e[15], M = h * g * u - _ * m * u + _ * c * p - l * g * p - h * c * x + l * m * x, S = v * m * u - d * g * u - v * c * p + a * g * p + d * c * x - a * m * x, b = d * _ * u - v * h * u + v * l * p - a * _ * p - d * l * x + a * h * x, C = v * h * c - d * _ * c - v * l * m + a * _ * m + d * l * g - a * h * g, T = n * M + i * S + r * b + o * C;
    if (T === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / T;
    return e[0] = M * P, e[1] = (_ * m * o - h * g * o - _ * r * p + i * g * p + h * r * x - i * m * x) * P, e[2] = (l * g * o - _ * c * o + _ * r * u - i * g * u - l * r * x + i * c * x) * P, e[3] = (h * c * o - l * m * o - h * r * u + i * m * u + l * r * p - i * c * p) * P, e[4] = S * P, e[5] = (d * g * o - v * m * o + v * r * p - n * g * p - d * r * x + n * m * x) * P, e[6] = (v * c * o - a * g * o - v * r * u + n * g * u + a * r * x - n * c * x) * P, e[7] = (a * m * o - d * c * o + d * r * u - n * m * u - a * r * p + n * c * p) * P, e[8] = b * P, e[9] = (v * h * o - d * _ * o - v * i * p + n * _ * p + d * i * x - n * h * x) * P, e[10] = (a * _ * o - v * l * o + v * i * u - n * _ * u - a * i * x + n * l * x) * P, e[11] = (d * l * o - a * h * o - d * i * u + n * h * u + a * i * p - n * l * p) * P, e[12] = C * P, e[13] = (d * _ * r - v * h * r + v * i * m - n * _ * m - d * i * g + n * h * g) * P, e[14] = (v * l * r - a * _ * r - v * i * c + n * _ * c + a * i * g - n * l * g) * P, e[15] = (a * h * r - d * l * r + d * i * c - n * h * c - a * i * m + n * l * m) * P, this;
  }
  scale(e) {
    const n = this.elements, i = e.x, r = e.y, o = e.z;
    return n[0] *= i, n[4] *= r, n[8] *= o, n[1] *= i, n[5] *= r, n[9] *= o, n[2] *= i, n[6] *= r, n[10] *= o, n[3] *= i, n[7] *= r, n[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, r));
  }
  makeTranslation(e, n, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n), r = Math.sin(n), o = 1 - i, a = e.x, l = e.y, c = e.z, u = o * a, d = o * l;
    return this.set(
      u * a + i,
      u * l - r * c,
      u * c + r * l,
      0,
      u * l + r * c,
      d * l + i,
      d * c - r * a,
      0,
      u * c - r * l,
      d * c + r * a,
      o * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, i, r, o, a) {
    return this.set(
      1,
      i,
      o,
      0,
      e,
      1,
      a,
      0,
      n,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, i) {
    const r = this.elements, o = n._x, a = n._y, l = n._z, c = n._w, u = o + o, d = a + a, h = l + l, m = o * u, p = o * d, v = o * h, _ = a * d, g = a * h, x = l * h, M = c * u, S = c * d, b = c * h, C = i.x, T = i.y, P = i.z;
    return r[0] = (1 - (_ + x)) * C, r[1] = (p + b) * C, r[2] = (v - S) * C, r[3] = 0, r[4] = (p - b) * T, r[5] = (1 - (m + x)) * T, r[6] = (g + M) * T, r[7] = 0, r[8] = (v + S) * P, r[9] = (g - M) * P, r[10] = (1 - (m + _)) * P, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, n, i) {
    const r = this.elements;
    let o = ao.set(r[0], r[1], r[2]).length();
    const a = ao.set(r[4], r[5], r[6]).length(), l = ao.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (o = -o), e.x = r[12], e.y = r[13], e.z = r[14], Ui.copy(this);
    const u = 1 / o, d = 1 / a, h = 1 / l;
    return Ui.elements[0] *= u, Ui.elements[1] *= u, Ui.elements[2] *= u, Ui.elements[4] *= d, Ui.elements[5] *= d, Ui.elements[6] *= d, Ui.elements[8] *= h, Ui.elements[9] *= h, Ui.elements[10] *= h, n.setFromRotationMatrix(Ui), i.x = o, i.y = a, i.z = l, this;
  }
  makePerspective(e, n, i, r, o, a, l = Ts) {
    const c = this.elements, u = 2 * o / (n - e), d = 2 * o / (i - r), h = (n + e) / (n - e), m = (i + r) / (i - r);
    let p, v;
    if (l === Ts)
      p = -(a + o) / (a - o), v = -2 * a * o / (a - o);
    else if (l === nu)
      p = -a / (a - o), v = -a * o / (a - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return c[0] = u, c[4] = 0, c[8] = h, c[12] = 0, c[1] = 0, c[5] = d, c[9] = m, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = p, c[14] = v, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, n, i, r, o, a, l = Ts) {
    const c = this.elements, u = 1 / (n - e), d = 1 / (i - r), h = 1 / (a - o), m = (n + e) * u, p = (i + r) * d;
    let v, _;
    if (l === Ts)
      v = (a + o) * h, _ = -2 * h;
    else if (l === nu)
      v = o * h, _ = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return c[0] = 2 * u, c[4] = 0, c[8] = 0, c[12] = -m, c[1] = 0, c[5] = 2 * d, c[9] = 0, c[13] = -p, c[2] = 0, c[6] = 0, c[10] = _, c[14] = -v, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++)
      if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e[n + 9] = i[9], e[n + 10] = i[10], e[n + 11] = i[11], e[n + 12] = i[12], e[n + 13] = i[13], e[n + 14] = i[14], e[n + 15] = i[15], e;
  }
}
const ao = /* @__PURE__ */ new de(), Ui = /* @__PURE__ */ new Zt(), Ob = /* @__PURE__ */ new de(0, 0, 0), zb = /* @__PURE__ */ new de(1, 1, 1), $s = /* @__PURE__ */ new de(), Wl = /* @__PURE__ */ new de(), yi = /* @__PURE__ */ new de(), fm = /* @__PURE__ */ new Zt(), pm = /* @__PURE__ */ new ni();
class Mi {
  constructor(e = 0, n = 0, i = 0, r = Mi.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, i, r = this._order) {
    return this._x = e, this._y = n, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const r = e.elements, o = r[0], a = r[4], l = r[8], c = r[1], u = r[5], d = r[9], h = r[2], m = r[6], p = r[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(Fn(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(m, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Fn(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(l, p), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Fn(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(c, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Fn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(m, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, u));
        break;
      case "YZX":
        this._z = Math.asin(Fn(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-d, u), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(l, p));
        break;
      case "XZY":
        this._z = Math.asin(-Fn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(m, u), this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-d, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return fm.makeRotationFromQuaternion(e), this.setFromRotationMatrix(fm, n, i);
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return pm.setFromEuler(this), this.setFromQuaternion(pm, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Mi.DEFAULT_ORDER = "XYZ";
class Ff {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let Nb = 0;
const mm = /* @__PURE__ */ new de(), lo = /* @__PURE__ */ new ni(), ms = /* @__PURE__ */ new Zt(), Xl = /* @__PURE__ */ new de(), ma = /* @__PURE__ */ new de(), Bb = /* @__PURE__ */ new de(), Vb = /* @__PURE__ */ new ni(), vm = /* @__PURE__ */ new de(1, 0, 0), gm = /* @__PURE__ */ new de(0, 1, 0), ym = /* @__PURE__ */ new de(0, 0, 1), xm = { type: "added" }, Gb = { type: "removed" }, co = { type: "childadded", child: null }, hd = { type: "childremoved", child: null };
class cn extends jr {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Nb++ }), this.uuid = Yr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = cn.DEFAULT_UP.clone();
    const e = new de(), n = new Mi(), i = new ni(), r = new de(1, 1, 1);
    function o() {
      i.setFromEuler(n, !1);
    }
    function a() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(o), i._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new Zt()
      },
      normalMatrix: {
        value: new Tt()
      }
    }), this.matrix = new Zt(), this.matrixWorld = new Zt(), this.matrixAutoUpdate = cn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = cn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Ff(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return lo.setFromAxisAngle(e, n), this.quaternion.multiply(lo), this;
  }
  rotateOnWorldAxis(e, n) {
    return lo.setFromAxisAngle(e, n), this.quaternion.premultiply(lo), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(vm, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(gm, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(ym, e);
  }
  translateOnAxis(e, n) {
    return mm.copy(e).applyQuaternion(this.quaternion), this.position.add(mm.multiplyScalar(n)), this;
  }
  translateX(e) {
    return this.translateOnAxis(vm, e);
  }
  translateY(e) {
    return this.translateOnAxis(gm, e);
  }
  translateZ(e) {
    return this.translateOnAxis(ym, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ms.copy(this.matrixWorld).invert());
  }
  lookAt(e, n, i) {
    e.isVector3 ? Xl.copy(e) : Xl.set(e, n, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), ma.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ms.lookAt(ma, Xl, this.up) : ms.lookAt(Xl, ma, this.up), this.quaternion.setFromRotationMatrix(ms), r && (ms.extractRotation(r.matrixWorld), lo.setFromRotationMatrix(ms), this.quaternion.premultiply(lo.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(xm), co.child = e, this.dispatchEvent(co), co.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Gb), hd.child = e, this.dispatchEvent(hd), hd.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), ms.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ms.multiply(e.parent.matrixWorld)), e.applyMatrix4(ms), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(xm), co.child = e, this.dispatchEvent(co), co.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const a = this.children[i].getObjectByProperty(e, n);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const r = this.children;
    for (let o = 0, a = r.length; o < a; o++)
      r[o].getObjectsByProperty(e, n, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ma, e, Bb), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ma, Vb, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) {
      const r = this.children;
      for (let o = 0, a = r.length; o < a; o++)
        r[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", i = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = {
      center: r.boundingSphere.center.toArray(),
      radius: r.boundingSphere.radius
    }), this.boundingBox !== null && (r.boundingBox = {
      min: r.boundingBox.min.toArray(),
      max: r.boundingBox.max.toArray()
    }));
    function o(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = o(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let u = 0, d = c.length; u < d; u++) {
            const h = c[u];
            o(e.shapes, h);
          }
        else
          o(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, u = this.material.length; c < u; c++)
          l.push(o(e.materials, this.material[c]));
        r.material = l;
      } else
        r.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let l = 0; l < this.children.length; l++)
        r.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        r.animations.push(o(e.animations, c));
      }
    }
    if (n) {
      const l = a(e.geometries), c = a(e.materials), u = a(e.textures), d = a(e.images), h = a(e.shapes), m = a(e.skeletons), p = a(e.animations), v = a(e.nodes);
      l.length > 0 && (i.geometries = l), c.length > 0 && (i.materials = c), u.length > 0 && (i.textures = u), d.length > 0 && (i.images = d), h.length > 0 && (i.shapes = h), m.length > 0 && (i.skeletons = m), p.length > 0 && (i.animations = p), v.length > 0 && (i.nodes = v);
    }
    return i.object = r, i;
    function a(l) {
      const c = [];
      for (const u in l) {
        const d = l[u];
        delete d.metadata, c.push(d);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
cn.DEFAULT_UP = /* @__PURE__ */ new de(0, 1, 0);
cn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
cn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Oi = /* @__PURE__ */ new de(), vs = /* @__PURE__ */ new de(), fd = /* @__PURE__ */ new de(), gs = /* @__PURE__ */ new de(), uo = /* @__PURE__ */ new de(), ho = /* @__PURE__ */ new de(), _m = /* @__PURE__ */ new de(), pd = /* @__PURE__ */ new de(), md = /* @__PURE__ */ new de(), vd = /* @__PURE__ */ new de(), gd = /* @__PURE__ */ new jt(), yd = /* @__PURE__ */ new jt(), xd = /* @__PURE__ */ new jt();
class Gi {
  constructor(e = new de(), n = new de(), i = new de()) {
    this.a = e, this.b = n, this.c = i;
  }
  static getNormal(e, n, i, r) {
    r.subVectors(i, n), Oi.subVectors(e, n), r.cross(Oi);
    const o = r.lengthSq();
    return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, i, r, o) {
    Oi.subVectors(r, n), vs.subVectors(i, n), fd.subVectors(e, n);
    const a = Oi.dot(Oi), l = Oi.dot(vs), c = Oi.dot(fd), u = vs.dot(vs), d = vs.dot(fd), h = a * u - l * l;
    if (h === 0)
      return o.set(0, 0, 0), null;
    const m = 1 / h, p = (u * c - l * d) * m, v = (a * d - l * c) * m;
    return o.set(1 - p - v, v, p);
  }
  static containsPoint(e, n, i, r) {
    return this.getBarycoord(e, n, i, r, gs) === null ? !1 : gs.x >= 0 && gs.y >= 0 && gs.x + gs.y <= 1;
  }
  static getInterpolation(e, n, i, r, o, a, l, c) {
    return this.getBarycoord(e, n, i, r, gs) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(o, gs.x), c.addScaledVector(a, gs.y), c.addScaledVector(l, gs.z), c);
  }
  static getInterpolatedAttribute(e, n, i, r, o, a) {
    return gd.setScalar(0), yd.setScalar(0), xd.setScalar(0), gd.fromBufferAttribute(e, n), yd.fromBufferAttribute(e, i), xd.fromBufferAttribute(e, r), a.setScalar(0), a.addScaledVector(gd, o.x), a.addScaledVector(yd, o.y), a.addScaledVector(xd, o.z), a;
  }
  static isFrontFacing(e, n, i, r) {
    return Oi.subVectors(i, n), vs.subVectors(e, n), Oi.cross(vs).dot(r) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, r) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, n, i, r) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Oi.subVectors(this.c, this.b), vs.subVectors(this.a, this.b), Oi.cross(vs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Gi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return Gi.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, i, r, o) {
    return Gi.getInterpolation(e, this.a, this.b, this.c, n, i, r, o);
  }
  containsPoint(e) {
    return Gi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Gi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a, r = this.b, o = this.c;
    let a, l;
    uo.subVectors(r, i), ho.subVectors(o, i), pd.subVectors(e, i);
    const c = uo.dot(pd), u = ho.dot(pd);
    if (c <= 0 && u <= 0)
      return n.copy(i);
    md.subVectors(e, r);
    const d = uo.dot(md), h = ho.dot(md);
    if (d >= 0 && h <= d)
      return n.copy(r);
    const m = c * h - d * u;
    if (m <= 0 && c >= 0 && d <= 0)
      return a = c / (c - d), n.copy(i).addScaledVector(uo, a);
    vd.subVectors(e, o);
    const p = uo.dot(vd), v = ho.dot(vd);
    if (v >= 0 && p <= v)
      return n.copy(o);
    const _ = p * u - c * v;
    if (_ <= 0 && u >= 0 && v <= 0)
      return l = u / (u - v), n.copy(i).addScaledVector(ho, l);
    const g = d * v - p * h;
    if (g <= 0 && h - d >= 0 && p - v >= 0)
      return _m.subVectors(o, r), l = (h - d) / (h - d + (p - v)), n.copy(r).addScaledVector(_m, l);
    const x = 1 / (g + _ + m);
    return a = _ * x, l = m * x, n.copy(i).addScaledVector(uo, a).addScaledVector(ho, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const iy = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ws = { h: 0, s: 0, l: 0 }, jl = { h: 0, s: 0, l: 0 };
function _d(s, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? s + (e - s) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - n) : s;
}
class Mt {
  constructor(e, n, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, i);
  }
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, n, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, n = dn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, It.toWorkingColorSpace(this, n), this;
  }
  setRGB(e, n, i, r = It.workingColorSpace) {
    return this.r = e, this.g = n, this.b = i, It.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, n, i, r = It.workingColorSpace) {
    if (e = If(e, 1), n = Fn(n, 0, 1), i = Fn(i, 0, 1), n === 0)
      this.r = this.g = this.b = i;
    else {
      const o = i <= 0.5 ? i * (1 + n) : i + n - i * n, a = 2 * i - o;
      this.r = _d(a, o, e + 1 / 3), this.g = _d(a, o, e), this.b = _d(a, o, e - 1 / 3);
    }
    return It.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, n = dn) {
    function i(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const a = r[1], l = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              n
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = r[1], a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          n
        );
      if (a === 6)
        return this.setHex(parseInt(o, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = dn) {
    const i = iy[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Ps(e.r), this.g = Ps(e.g), this.b = Ps(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Uo(e.r), this.g = Uo(e.g), this.b = Uo(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = dn) {
    return It.fromWorkingColorSpace($n.copy(this), e), Math.round(Fn($n.r * 255, 0, 255)) * 65536 + Math.round(Fn($n.g * 255, 0, 255)) * 256 + Math.round(Fn($n.b * 255, 0, 255));
  }
  getHexString(e = dn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = It.workingColorSpace) {
    It.fromWorkingColorSpace($n.copy(this), n);
    const i = $n.r, r = $n.g, o = $n.b, a = Math.max(i, r, o), l = Math.min(i, r, o);
    let c, u;
    const d = (l + a) / 2;
    if (l === a)
      c = 0, u = 0;
    else {
      const h = a - l;
      switch (u = d <= 0.5 ? h / (a + l) : h / (2 - a - l), a) {
        case i:
          c = (r - o) / h + (r < o ? 6 : 0);
          break;
        case r:
          c = (o - i) / h + 2;
          break;
        case o:
          c = (i - r) / h + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = u, e.l = d, e;
  }
  getRGB(e, n = It.workingColorSpace) {
    return It.fromWorkingColorSpace($n.copy(this), n), e.r = $n.r, e.g = $n.g, e.b = $n.b, e;
  }
  getStyle(e = dn) {
    It.fromWorkingColorSpace($n.copy(this), e);
    const n = $n.r, i = $n.g, r = $n.b;
    return e !== dn ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(Ws), this.setHSL(Ws.h + e, Ws.s + n, Ws.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpColors(e, n, i) {
    return this.r = e.r + (n.r - e.r) * i, this.g = e.g + (n.g - e.g) * i, this.b = e.b + (n.b - e.b) * i, this;
  }
  lerpHSL(e, n) {
    this.getHSL(Ws), e.getHSL(jl);
    const i = Wa(Ws.h, jl.h, n), r = Wa(Ws.s, jl.s, n), o = Wa(Ws.l, jl.l, n);
    return this.setHSL(i, r, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const n = this.r, i = this.g, r = this.b, o = e.elements;
    return this.r = o[0] * n + o[3] * i + o[6] * r, this.g = o[1] * n + o[4] * i + o[7] * r, this.b = o[2] * n + o[5] * i + o[8] * r, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const $n = /* @__PURE__ */ new Mt();
Mt.NAMES = iy;
let Hb = 0;
class qr extends jr {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Hb++ }), this.uuid = Yr(), this.name = "", this.blending = Hi, this.side = ar, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = eu, this.blendDst = cl, this.blendEquation = Vi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Mt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Vo, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = nm, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = to, this.stencilZFail = to, this.stencilZPass = to, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const i = e[n];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
          continue;
        }
        const r = this[n];
        if (r === void 0) {
          console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[n] = i;
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Hi && (i.blending = this.blending), this.side !== ar && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== eu && (i.blendSrc = this.blendSrc), this.blendDst !== cl && (i.blendDst = this.blendDst), this.blendEquation !== Vi && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Vo && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== nm && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== to && (i.stencilFail = this.stencilFail), this.stencilZFail !== to && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== to && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(o) {
      const a = [];
      for (const l in o) {
        const c = o[l];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (n) {
      const o = r(e.textures), a = r(e.images);
      o.length > 0 && (i.textures = o), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const r = n.length;
      i = new Array(r);
      for (let o = 0; o !== r; ++o)
        i[o] = n[o].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Tn extends qr {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Mi(), this.combine = O0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Mn = /* @__PURE__ */ new de(), Yl = /* @__PURE__ */ new rt();
class Si {
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = i, this.usage = im, this.updateRanges = [], this.gpuType = si, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, n, i) {
    e *= this.itemSize, i *= n.itemSize;
    for (let r = 0, o = this.itemSize; r < o; r++)
      this.array[e + r] = n.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        Yl.fromBufferAttribute(this, n), Yl.applyMatrix3(e), this.setXY(n, Yl.x, Yl.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        Mn.fromBufferAttribute(this, n), Mn.applyMatrix3(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Mn.fromBufferAttribute(this, n), Mn.applyMatrix4(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Mn.fromBufferAttribute(this, n), Mn.applyNormalMatrix(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Mn.fromBufferAttribute(this, n), Mn.transformDirection(e), this.setXYZ(n, Mn.x, Mn.y, Mn.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = So(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return this.normalized && (i = Qn(i, this.array)), this.array[e * this.itemSize + n] = i, this;
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = So(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = So(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = So(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = So(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = Qn(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  setXY(e, n, i) {
    return e *= this.itemSize, this.normalized && (n = Qn(n, this.array), i = Qn(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this;
  }
  setXYZ(e, n, i, r) {
    return e *= this.itemSize, this.normalized && (n = Qn(n, this.array), i = Qn(i, this.array), r = Qn(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, n, i, r, o) {
    return e *= this.itemSize, this.normalized && (n = Qn(n, this.array), i = Qn(i, this.array), r = Qn(r, this.array), o = Qn(o, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== im && (e.usage = this.usage), e;
  }
}
class sy extends Si {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class ry extends Si {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class Pt extends Si {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let $b = 0;
const Ci = /* @__PURE__ */ new Zt(), bd = /* @__PURE__ */ new cn(), fo = /* @__PURE__ */ new de(), xi = /* @__PURE__ */ new hr(), va = /* @__PURE__ */ new hr(), Pn = /* @__PURE__ */ new de();
class Vt extends jr {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: $b++ }), this.uuid = Yr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (ey(e) ? ry : sy)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const o = new Tt().getNormalMatrix(e);
      i.applyNormalMatrix(o), i.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Ci.makeRotationFromQuaternion(e), this.applyMatrix4(Ci), this;
  }
  rotateX(e) {
    return Ci.makeRotationX(e), this.applyMatrix4(Ci), this;
  }
  rotateY(e) {
    return Ci.makeRotationY(e), this.applyMatrix4(Ci), this;
  }
  rotateZ(e) {
    return Ci.makeRotationZ(e), this.applyMatrix4(Ci), this;
  }
  translate(e, n, i) {
    return Ci.makeTranslation(e, n, i), this.applyMatrix4(Ci), this;
  }
  scale(e, n, i) {
    return Ci.makeScale(e, n, i), this.applyMatrix4(Ci), this;
  }
  lookAt(e) {
    return bd.lookAt(e), bd.updateMatrix(), this.applyMatrix4(bd.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(fo).negate(), this.translate(fo.x, fo.y, fo.z), this;
  }
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const i = [];
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r];
        i.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new Pt(i, 3));
    } else {
      for (let i = 0, r = n.count; i < r; i++) {
        const o = e[i];
        n.setXYZ(i, o.x, o.y, o.z || 0);
      }
      e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new hr());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new de(-1 / 0, -1 / 0, -1 / 0),
        new de(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let i = 0, r = n.length; i < r; i++) {
          const o = n[i];
          xi.setFromBufferAttribute(o), this.morphTargetsRelative ? (Pn.addVectors(this.boundingBox.min, xi.min), this.boundingBox.expandByPoint(Pn), Pn.addVectors(this.boundingBox.max, xi.max), this.boundingBox.expandByPoint(Pn)) : (this.boundingBox.expandByPoint(xi.min), this.boundingBox.expandByPoint(xi.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sl());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new de(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (xi.setFromBufferAttribute(e), n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o];
          va.setFromBufferAttribute(l), this.morphTargetsRelative ? (Pn.addVectors(xi.min, va.min), xi.expandByPoint(Pn), Pn.addVectors(xi.max, va.max), xi.expandByPoint(Pn)) : (xi.expandByPoint(va.min), xi.expandByPoint(va.max));
        }
      xi.getCenter(i);
      let r = 0;
      for (let o = 0, a = e.count; o < a; o++)
        Pn.fromBufferAttribute(e, o), r = Math.max(r, i.distanceToSquared(Pn));
      if (n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o], c = this.morphTargetsRelative;
          for (let u = 0, d = l.count; u < d; u++)
            Pn.fromBufferAttribute(l, u), c && (fo.fromBufferAttribute(e, u), Pn.add(fo)), r = Math.max(r, i.distanceToSquared(Pn));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = n.position, r = n.normal, o = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Si(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute("tangent"), l = [], c = [];
    for (let E = 0; E < i.count; E++)
      l[E] = new de(), c[E] = new de();
    const u = new de(), d = new de(), h = new de(), m = new rt(), p = new rt(), v = new rt(), _ = new de(), g = new de();
    function x(E, y, w) {
      u.fromBufferAttribute(i, E), d.fromBufferAttribute(i, y), h.fromBufferAttribute(i, w), m.fromBufferAttribute(o, E), p.fromBufferAttribute(o, y), v.fromBufferAttribute(o, w), d.sub(u), h.sub(u), p.sub(m), v.sub(m);
      const D = 1 / (p.x * v.y - v.x * p.y);
      isFinite(D) && (_.copy(d).multiplyScalar(v.y).addScaledVector(h, -p.y).multiplyScalar(D), g.copy(h).multiplyScalar(p.x).addScaledVector(d, -v.x).multiplyScalar(D), l[E].add(_), l[y].add(_), l[w].add(_), c[E].add(g), c[y].add(g), c[w].add(g));
    }
    let M = this.groups;
    M.length === 0 && (M = [{
      start: 0,
      count: e.count
    }]);
    for (let E = 0, y = M.length; E < y; ++E) {
      const w = M[E], D = w.start, U = w.count;
      for (let R = D, O = D + U; R < O; R += 3)
        x(
          e.getX(R + 0),
          e.getX(R + 1),
          e.getX(R + 2)
        );
    }
    const S = new de(), b = new de(), C = new de(), T = new de();
    function P(E) {
      C.fromBufferAttribute(r, E), T.copy(C);
      const y = l[E];
      S.copy(y), S.sub(C.multiplyScalar(C.dot(y))).normalize(), b.crossVectors(T, y);
      const D = b.dot(c[E]) < 0 ? -1 : 1;
      a.setXYZW(E, S.x, S.y, S.z, D);
    }
    for (let E = 0, y = M.length; E < y; ++E) {
      const w = M[E], D = w.start, U = w.count;
      for (let R = D, O = D + U; R < O; R += 3)
        P(e.getX(R + 0)), P(e.getX(R + 1)), P(e.getX(R + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Si(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let m = 0, p = i.count; m < p; m++)
          i.setXYZ(m, 0, 0, 0);
      const r = new de(), o = new de(), a = new de(), l = new de(), c = new de(), u = new de(), d = new de(), h = new de();
      if (e)
        for (let m = 0, p = e.count; m < p; m += 3) {
          const v = e.getX(m + 0), _ = e.getX(m + 1), g = e.getX(m + 2);
          r.fromBufferAttribute(n, v), o.fromBufferAttribute(n, _), a.fromBufferAttribute(n, g), d.subVectors(a, o), h.subVectors(r, o), d.cross(h), l.fromBufferAttribute(i, v), c.fromBufferAttribute(i, _), u.fromBufferAttribute(i, g), l.add(d), c.add(d), u.add(d), i.setXYZ(v, l.x, l.y, l.z), i.setXYZ(_, c.x, c.y, c.z), i.setXYZ(g, u.x, u.y, u.z);
        }
      else
        for (let m = 0, p = n.count; m < p; m += 3)
          r.fromBufferAttribute(n, m + 0), o.fromBufferAttribute(n, m + 1), a.fromBufferAttribute(n, m + 2), d.subVectors(a, o), h.subVectors(r, o), d.cross(h), i.setXYZ(m + 0, d.x, d.y, d.z), i.setXYZ(m + 1, d.x, d.y, d.z), i.setXYZ(m + 2, d.x, d.y, d.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      Pn.fromBufferAttribute(e, n), Pn.normalize(), e.setXYZ(n, Pn.x, Pn.y, Pn.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const u = l.array, d = l.itemSize, h = l.normalized, m = new u.constructor(c.length * d);
      let p = 0, v = 0;
      for (let _ = 0, g = c.length; _ < g; _++) {
        l.isInterleavedBufferAttribute ? p = c[_] * l.data.stride + l.offset : p = c[_] * d;
        for (let x = 0; x < d; x++)
          m[v++] = u[p++];
      }
      return new Si(m, d, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new Vt(), i = this.index.array, r = this.attributes;
    for (const l in r) {
      const c = r[l], u = e(c, i);
      n.setAttribute(l, u);
    }
    const o = this.morphAttributes;
    for (const l in o) {
      const c = [], u = o[l];
      for (let d = 0, h = u.length; d < h; d++) {
        const m = u[d], p = e(m, i);
        c.push(p);
      }
      n.morphAttributes[l] = c;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let l = 0, c = a.length; l < c; l++) {
      const u = a[l];
      n.addGroup(u.start, u.count, u.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const u in c)
        c[u] !== void 0 && (e[u] = c[u]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const u = i[c];
      e.data.attributes[c] = u.toJSON(e.data);
    }
    const r = {};
    let o = !1;
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c], d = [];
      for (let h = 0, m = u.length; h < m; h++) {
        const p = u[h];
        d.push(p.toJSON(e.data));
      }
      d.length > 0 && (r[c] = d, o = !0);
    }
    o && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const r = e.attributes;
    for (const u in r) {
      const d = r[u];
      this.setAttribute(u, d.clone(n));
    }
    const o = e.morphAttributes;
    for (const u in o) {
      const d = [], h = o[u];
      for (let m = 0, p = h.length; m < p; m++)
        d.push(h[m].clone(n));
      this.morphAttributes[u] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let u = 0, d = a.length; u < d; u++) {
      const h = a[u];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const bm = /* @__PURE__ */ new Zt(), xr = /* @__PURE__ */ new Lf(), ql = /* @__PURE__ */ new Sl(), wm = /* @__PURE__ */ new de(), Zl = /* @__PURE__ */ new de(), Kl = /* @__PURE__ */ new de(), Jl = /* @__PURE__ */ new de(), wd = /* @__PURE__ */ new de(), Ql = /* @__PURE__ */ new de(), Sm = /* @__PURE__ */ new de(), ec = /* @__PURE__ */ new de();
class Ze extends cn {
  constructor(e = new Vt(), n = new Tn()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = r.length; o < a; o++) {
          const l = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const i = this.geometry, r = i.attributes.position, o = i.morphAttributes.position, a = i.morphTargetsRelative;
    n.fromBufferAttribute(r, e);
    const l = this.morphTargetInfluences;
    if (o && l) {
      Ql.set(0, 0, 0);
      for (let c = 0, u = o.length; c < u; c++) {
        const d = l[c], h = o[c];
        d !== 0 && (wd.fromBufferAttribute(h, e), a ? Ql.addScaledVector(wd, d) : Ql.addScaledVector(wd.sub(n), d));
      }
      n.add(Ql);
    }
    return n;
  }
  raycast(e, n) {
    const i = this.geometry, r = this.material, o = this.matrixWorld;
    r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), ql.copy(i.boundingSphere), ql.applyMatrix4(o), xr.copy(e.ray).recast(e.near), !(ql.containsPoint(xr.origin) === !1 && (xr.intersectSphere(ql, wm) === null || xr.origin.distanceToSquared(wm) > (e.far - e.near) ** 2)) && (bm.copy(o).invert(), xr.copy(e.ray).applyMatrix4(bm), !(i.boundingBox !== null && xr.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, n, xr)));
  }
  _computeIntersections(e, n, i) {
    let r;
    const o = this.geometry, a = this.material, l = o.index, c = o.attributes.position, u = o.attributes.uv, d = o.attributes.uv1, h = o.attributes.normal, m = o.groups, p = o.drawRange;
    if (l !== null)
      if (Array.isArray(a))
        for (let v = 0, _ = m.length; v < _; v++) {
          const g = m[v], x = a[g.materialIndex], M = Math.max(g.start, p.start), S = Math.min(l.count, Math.min(g.start + g.count, p.start + p.count));
          for (let b = M, C = S; b < C; b += 3) {
            const T = l.getX(b), P = l.getX(b + 1), E = l.getX(b + 2);
            r = tc(this, x, e, i, u, d, h, T, P, E), r && (r.faceIndex = Math.floor(b / 3), r.face.materialIndex = g.materialIndex, n.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start), _ = Math.min(l.count, p.start + p.count);
        for (let g = v, x = _; g < x; g += 3) {
          const M = l.getX(g), S = l.getX(g + 1), b = l.getX(g + 2);
          r = tc(this, a, e, i, u, d, h, M, S, b), r && (r.faceIndex = Math.floor(g / 3), n.push(r));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let v = 0, _ = m.length; v < _; v++) {
          const g = m[v], x = a[g.materialIndex], M = Math.max(g.start, p.start), S = Math.min(c.count, Math.min(g.start + g.count, p.start + p.count));
          for (let b = M, C = S; b < C; b += 3) {
            const T = b, P = b + 1, E = b + 2;
            r = tc(this, x, e, i, u, d, h, T, P, E), r && (r.faceIndex = Math.floor(b / 3), r.face.materialIndex = g.materialIndex, n.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start), _ = Math.min(c.count, p.start + p.count);
        for (let g = v, x = _; g < x; g += 3) {
          const M = g, S = g + 1, b = g + 2;
          r = tc(this, a, e, i, u, d, h, M, S, b), r && (r.faceIndex = Math.floor(g / 3), n.push(r));
        }
      }
  }
}
function Wb(s, e, n, i, r, o, a, l) {
  let c;
  if (e.side === hi ? c = i.intersectTriangle(a, o, r, !0, l) : c = i.intersectTriangle(r, o, a, e.side === ar, l), c === null) return null;
  ec.copy(l), ec.applyMatrix4(s.matrixWorld);
  const u = n.ray.origin.distanceTo(ec);
  return u < n.near || u > n.far ? null : {
    distance: u,
    point: ec.clone(),
    object: s
  };
}
function tc(s, e, n, i, r, o, a, l, c, u) {
  s.getVertexPosition(l, Zl), s.getVertexPosition(c, Kl), s.getVertexPosition(u, Jl);
  const d = Wb(s, e, n, i, Zl, Kl, Jl, Sm);
  if (d) {
    const h = new de();
    Gi.getBarycoord(Sm, Zl, Kl, Jl, h), r && (d.uv = Gi.getInterpolatedAttribute(r, l, c, u, h, new rt())), o && (d.uv1 = Gi.getInterpolatedAttribute(o, l, c, u, h, new rt())), a && (d.normal = Gi.getInterpolatedAttribute(a, l, c, u, h, new de()), d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
    const m = {
      a: l,
      b: c,
      c: u,
      normal: new de(),
      materialIndex: 0
    };
    Gi.getNormal(Zl, Kl, Jl, m.normal), d.face = m, d.barycoord = h;
  }
  return d;
}
class pn extends Vt {
  constructor(e = 1, n = 1, i = 1, r = 1, o = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: i,
      widthSegments: r,
      heightSegments: o,
      depthSegments: a
    };
    const l = this;
    r = Math.floor(r), o = Math.floor(o), a = Math.floor(a);
    const c = [], u = [], d = [], h = [];
    let m = 0, p = 0;
    v("z", "y", "x", -1, -1, i, n, e, a, o, 0), v("z", "y", "x", 1, -1, i, n, -e, a, o, 1), v("x", "z", "y", 1, 1, e, i, n, r, a, 2), v("x", "z", "y", 1, -1, e, i, -n, r, a, 3), v("x", "y", "z", 1, -1, e, n, i, r, o, 4), v("x", "y", "z", -1, -1, e, n, -i, r, o, 5), this.setIndex(c), this.setAttribute("position", new Pt(u, 3)), this.setAttribute("normal", new Pt(d, 3)), this.setAttribute("uv", new Pt(h, 2));
    function v(_, g, x, M, S, b, C, T, P, E, y) {
      const w = b / P, D = C / E, U = b / 2, R = C / 2, O = T / 2, A = P + 1, G = E + 1;
      let ue = 0, Q = 0;
      const le = new de();
      for (let re = 0; re < G; re++) {
        const j = re * D - R;
        for (let $ = 0; $ < A; $++) {
          const q = $ * w - U;
          le[_] = q * M, le[g] = j * S, le[x] = O, u.push(le.x, le.y, le.z), le[_] = 0, le[g] = 0, le[x] = T > 0 ? 1 : -1, d.push(le.x, le.y, le.z), h.push($ / P), h.push(1 - re / E), ue += 1;
        }
      }
      for (let re = 0; re < E; re++)
        for (let j = 0; j < P; j++) {
          const $ = m + j + A * re, q = m + j + A * (re + 1), oe = m + (j + 1) + A * (re + 1), ie = m + (j + 1) + A * re;
          c.push($, q, ie), c.push(q, oe, ie), Q += 6;
        }
      l.addGroup(p, Q, y), p += Q, m += ue;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function jo(s) {
  const e = {};
  for (const n in s) {
    e[n] = {};
    for (const i in s[n]) {
      const r = s[n][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r;
    }
  }
  return e;
}
function ei(s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = jo(s[n]);
    for (const r in i)
      e[r] = i[r];
  }
  return e;
}
function Xb(s) {
  const e = [];
  for (let n = 0; n < s.length; n++)
    e.push(s[n].clone());
  return e;
}
function oy(s) {
  const e = s.getRenderTarget();
  return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : It.workingColorSpace;
}
const Ml = { clone: jo, merge: ei };
var jb = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Yb = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class zn extends qr {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = jb, this.fragmentShader = Yb, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = jo(e.uniforms), this.uniformsGroups = Xb(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    n.glslVersion = this.glslVersion, n.uniforms = {};
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture ? n.uniforms[r] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? n.uniforms[r] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? n.uniforms[r] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? n.uniforms[r] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? n.uniforms[r] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? n.uniforms[r] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? n.uniforms[r] = {
        type: "m4",
        value: a.toArray()
      } : n.uniforms[r] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class ay extends cn {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Zt(), this.projectionMatrix = new Zt(), this.projectionMatrixInverse = new Zt(), this.coordinateSystem = Ts;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Xs = /* @__PURE__ */ new de(), Mm = /* @__PURE__ */ new rt(), Cm = /* @__PURE__ */ new rt();
class di extends ay {
  constructor(e = 50, n = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = Xo * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan($a * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Xo * 2 * Math.atan(
      Math.tan($a * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, n, i) {
    Xs.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Xs.x, Xs.y).multiplyScalar(-e / Xs.z), Xs.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Xs.x, Xs.y).multiplyScalar(-e / Xs.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, Mm, Cm), n.subVectors(Cm, Mm);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, n, i, r, o, a) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = r, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan($a * 0.5 * this.fov) / this.zoom, i = 2 * n, r = this.aspect * i, o = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth, u = a.fullHeight;
      o += a.offsetX * r / c, n -= a.offsetY * i / u, r *= a.width / c, i *= a.height / u;
    }
    const l = this.filmOffset;
    l !== 0 && (o += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, n, n - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
const po = -90, mo = 1;
class qb extends cn {
  constructor(e, n, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new di(po, mo, e, n);
    r.layers = this.layers, this.add(r);
    const o = new di(po, mo, e, n);
    o.layers = this.layers, this.add(o);
    const a = new di(po, mo, e, n);
    a.layers = this.layers, this.add(a);
    const l = new di(po, mo, e, n);
    l.layers = this.layers, this.add(l);
    const c = new di(po, mo, e, n);
    c.layers = this.layers, this.add(c);
    const u = new di(po, mo, e, n);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [i, r, o, a, l, c] = n;
    for (const u of n) this.remove(u);
    if (e === Ts)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === nu)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const u of n)
      this.add(u), u.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, a, l, c, u, d] = this.children, h = e.getRenderTarget(), m = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), v = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, r), e.render(n, o), e.setRenderTarget(i, 1, r), e.render(n, a), e.setRenderTarget(i, 2, r), e.render(n, l), e.setRenderTarget(i, 3, r), e.render(n, c), e.setRenderTarget(i, 4, r), e.render(n, u), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, r), e.render(n, d), e.setRenderTarget(h, m, p), e.xr.enabled = v, i.texture.needsPMREMUpdate = !0;
  }
}
class ly extends _n {
  constructor(e, n, i, r, o, a, l, c, u, d) {
    e = e !== void 0 ? e : [], n = n !== void 0 ? n : Go, super(e, n, i, r, o, a, l, c, u, d), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Zb extends Ri {
  constructor(e = 1, n = {}) {
    super(e, e, n), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    this.texture = new ly(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Bt;
  }
  fromEquirectangularTexture(e, n) {
    this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new pn(5, 5, 5), o = new zn({
      name: "CubemapFromEquirect",
      uniforms: jo(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: hi,
      blending: os
    });
    o.uniforms.tEquirect.value = n;
    const a = new Ze(r, o), l = n.minFilter;
    return n.minFilter === zr && (n.minFilter = Bt), new qb(1, 10, this).update(e, a), n.minFilter = l, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, n, i, r) {
    const o = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(n, i, r);
    e.setRenderTarget(o);
  }
}
const Sd = /* @__PURE__ */ new de(), Kb = /* @__PURE__ */ new de(), Jb = /* @__PURE__ */ new Tt();
class Ar {
  constructor(e = new de(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, i, r) {
    return this.normal.set(e, n, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const r = Sd.subVectors(i, n).cross(Kb.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const i = e.delta(Sd), r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / r;
    return o < 0 || o > 1 ? null : n.copy(e.start).addScaledVector(i, o);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return n < 0 && i > 0 || i < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || Jb.getNormalMatrix(e), r = this.coplanarPoint(Sd).applyMatrix4(e), o = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _r = /* @__PURE__ */ new Sl(), nc = /* @__PURE__ */ new de();
class Uf {
  constructor(e = new Ar(), n = new Ar(), i = new Ar(), r = new Ar(), o = new Ar(), a = new Ar()) {
    this.planes = [e, n, i, r, o, a];
  }
  set(e, n, i, r, o, a) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(n), l[2].copy(i), l[3].copy(r), l[4].copy(o), l[5].copy(a), this;
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, n = Ts) {
    const i = this.planes, r = e.elements, o = r[0], a = r[1], l = r[2], c = r[3], u = r[4], d = r[5], h = r[6], m = r[7], p = r[8], v = r[9], _ = r[10], g = r[11], x = r[12], M = r[13], S = r[14], b = r[15];
    if (i[0].setComponents(c - o, m - u, g - p, b - x).normalize(), i[1].setComponents(c + o, m + u, g + p, b + x).normalize(), i[2].setComponents(c + a, m + d, g + v, b + M).normalize(), i[3].setComponents(c - a, m - d, g - v, b - M).normalize(), i[4].setComponents(c - l, m - h, g - _, b - S).normalize(), n === Ts)
      i[5].setComponents(c + l, m + h, g + _, b + S).normalize();
    else if (n === nu)
      i[5].setComponents(l, h, _, S).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), _r.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), _r.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(_r);
  }
  intersectsSprite(e) {
    return _r.center.set(0, 0, 0), _r.radius = 0.7071067811865476, _r.applyMatrix4(e.matrixWorld), this.intersectsSphere(_r);
  }
  intersectsSphere(e) {
    const n = this.planes, i = e.center, r = -e.radius;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(i) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = n[i];
      if (nc.x = r.normal.x > 0 ? e.max.x : e.min.x, nc.y = r.normal.y > 0 ? e.max.y : e.min.y, nc.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(nc) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      if (n[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function cy() {
  let s = null, e = !1, n = null, i = null;
  function r(o, a) {
    n(o, a), i = s.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (i = s.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(o) {
      n = o;
    },
    setContext: function(o) {
      s = o;
    }
  };
}
function Qb(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function n(l, c) {
    const u = l.array, d = l.usage, h = u.byteLength, m = s.createBuffer();
    s.bindBuffer(c, m), s.bufferData(c, u, d), l.onUploadCallback();
    let p;
    if (u instanceof Float32Array)
      p = s.FLOAT;
    else if (u instanceof Uint16Array)
      l.isFloat16BufferAttribute ? p = s.HALF_FLOAT : p = s.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      p = s.SHORT;
    else if (u instanceof Uint32Array)
      p = s.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      p = s.INT;
    else if (u instanceof Int8Array)
      p = s.BYTE;
    else if (u instanceof Uint8Array)
      p = s.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      p = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: m,
      type: p,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: l.version,
      size: h
    };
  }
  function i(l, c, u) {
    const d = c.array, h = c.updateRanges;
    if (s.bindBuffer(u, l), h.length === 0)
      s.bufferSubData(u, 0, d);
    else {
      h.sort((p, v) => p.start - v.start);
      let m = 0;
      for (let p = 1; p < h.length; p++) {
        const v = h[m], _ = h[p];
        _.start <= v.start + v.count + 1 ? v.count = Math.max(
          v.count,
          _.start + _.count - v.start
        ) : (++m, h[m] = _);
      }
      h.length = m + 1;
      for (let p = 0, v = h.length; p < v; p++) {
        const _ = h[p];
        s.bufferSubData(
          u,
          _.start * d.BYTES_PER_ELEMENT,
          d,
          _.start,
          _.count
        );
      }
      c.clearUpdateRanges();
    }
    c.onUploadCallback();
  }
  function r(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const c = e.get(l);
    c && (s.deleteBuffer(c.buffer), e.delete(l));
  }
  function a(l, c) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const d = e.get(l);
      (!d || d.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const u = e.get(l);
    if (u === void 0)
      e.set(l, n(l, c));
    else if (u.version < l.version) {
      if (u.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      i(u.buffer, l, c), u.version = l.version;
    }
  }
  return {
    get: r,
    remove: o,
    update: a
  };
}
class un extends Vt {
  constructor(e = 1, n = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: i,
      heightSegments: r
    };
    const o = e / 2, a = n / 2, l = Math.floor(i), c = Math.floor(r), u = l + 1, d = c + 1, h = e / l, m = n / c, p = [], v = [], _ = [], g = [];
    for (let x = 0; x < d; x++) {
      const M = x * m - a;
      for (let S = 0; S < u; S++) {
        const b = S * h - o;
        v.push(b, -M, 0), _.push(0, 0, 1), g.push(S / l), g.push(1 - x / c);
      }
    }
    for (let x = 0; x < c; x++)
      for (let M = 0; M < l; M++) {
        const S = M + u * x, b = M + u * (x + 1), C = M + 1 + u * (x + 1), T = M + 1 + u * x;
        p.push(S, b, T), p.push(b, C, T);
      }
    this.setIndex(p), this.setAttribute("position", new Pt(v, 3)), this.setAttribute("normal", new Pt(_, 3)), this.setAttribute("uv", new Pt(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new un(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var ew = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, tw = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, nw = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, iw = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, sw = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, rw = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, ow = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, aw = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, lw = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, cw = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, uw = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, dw = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, hw = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, fw = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, pw = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, mw = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, vw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, gw = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, yw = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, xw = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, _w = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, bw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, ww = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, Sw = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, Mw = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Cw = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Tw = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, Ew = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, Aw = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, Pw = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Rw = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Dw = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, kw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Iw = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Lw = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Fw = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Uw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Ow = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, zw = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Nw = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Bw = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Vw = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Gw = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Hw = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, $w = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Ww = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Xw = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, jw = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Yw = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, qw = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Zw = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Kw = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Jw = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Qw = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, eS = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, tS = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, nS = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, iS = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, sS = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, rS = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, oS = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, aS = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, lS = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, cS = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, uS = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, dS = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, hS = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, fS = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, pS = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, mS = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, vS = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, gS = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, yS = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, xS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, _S = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, bS = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, wS = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, SS = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, MS = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, CS = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, TS = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, ES = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, AS = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, PS = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, RS = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, DS = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, kS = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, IS = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, LS = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, FS = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, US = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, OS = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, zS = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, NS = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, BS = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, VS = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, GS = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, HS = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, $S = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, WS = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, XS = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, jS = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, YS = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, qS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ZS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, KS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, JS = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const QS = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, eM = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, tM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, nM = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, iM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, sM = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, rM = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, oM = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, aM = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, lM = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, cM = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, uM = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, dM = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, hM = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, fM = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, pM = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, mM = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, vM = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gM = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, yM = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xM = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, _M = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, bM = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, wM = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, SM = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, MM = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, CM = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, TM = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, EM = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, AM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, PM = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, RM = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, DM = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, kM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Et = {
  alphahash_fragment: ew,
  alphahash_pars_fragment: tw,
  alphamap_fragment: nw,
  alphamap_pars_fragment: iw,
  alphatest_fragment: sw,
  alphatest_pars_fragment: rw,
  aomap_fragment: ow,
  aomap_pars_fragment: aw,
  batching_pars_vertex: lw,
  batching_vertex: cw,
  begin_vertex: uw,
  beginnormal_vertex: dw,
  bsdfs: hw,
  iridescence_fragment: fw,
  bumpmap_pars_fragment: pw,
  clipping_planes_fragment: mw,
  clipping_planes_pars_fragment: vw,
  clipping_planes_pars_vertex: gw,
  clipping_planes_vertex: yw,
  color_fragment: xw,
  color_pars_fragment: _w,
  color_pars_vertex: bw,
  color_vertex: ww,
  common: Sw,
  cube_uv_reflection_fragment: Mw,
  defaultnormal_vertex: Cw,
  displacementmap_pars_vertex: Tw,
  displacementmap_vertex: Ew,
  emissivemap_fragment: Aw,
  emissivemap_pars_fragment: Pw,
  colorspace_fragment: Rw,
  colorspace_pars_fragment: Dw,
  envmap_fragment: kw,
  envmap_common_pars_fragment: Iw,
  envmap_pars_fragment: Lw,
  envmap_pars_vertex: Fw,
  envmap_physical_pars_fragment: Xw,
  envmap_vertex: Uw,
  fog_vertex: Ow,
  fog_pars_vertex: zw,
  fog_fragment: Nw,
  fog_pars_fragment: Bw,
  gradientmap_pars_fragment: Vw,
  lightmap_pars_fragment: Gw,
  lights_lambert_fragment: Hw,
  lights_lambert_pars_fragment: $w,
  lights_pars_begin: Ww,
  lights_toon_fragment: jw,
  lights_toon_pars_fragment: Yw,
  lights_phong_fragment: qw,
  lights_phong_pars_fragment: Zw,
  lights_physical_fragment: Kw,
  lights_physical_pars_fragment: Jw,
  lights_fragment_begin: Qw,
  lights_fragment_maps: eS,
  lights_fragment_end: tS,
  logdepthbuf_fragment: nS,
  logdepthbuf_pars_fragment: iS,
  logdepthbuf_pars_vertex: sS,
  logdepthbuf_vertex: rS,
  map_fragment: oS,
  map_pars_fragment: aS,
  map_particle_fragment: lS,
  map_particle_pars_fragment: cS,
  metalnessmap_fragment: uS,
  metalnessmap_pars_fragment: dS,
  morphinstance_vertex: hS,
  morphcolor_vertex: fS,
  morphnormal_vertex: pS,
  morphtarget_pars_vertex: mS,
  morphtarget_vertex: vS,
  normal_fragment_begin: gS,
  normal_fragment_maps: yS,
  normal_pars_fragment: xS,
  normal_pars_vertex: _S,
  normal_vertex: bS,
  normalmap_pars_fragment: wS,
  clearcoat_normal_fragment_begin: SS,
  clearcoat_normal_fragment_maps: MS,
  clearcoat_pars_fragment: CS,
  iridescence_pars_fragment: TS,
  opaque_fragment: ES,
  packing: AS,
  premultiplied_alpha_fragment: PS,
  project_vertex: RS,
  dithering_fragment: DS,
  dithering_pars_fragment: kS,
  roughnessmap_fragment: IS,
  roughnessmap_pars_fragment: LS,
  shadowmap_pars_fragment: FS,
  shadowmap_pars_vertex: US,
  shadowmap_vertex: OS,
  shadowmask_pars_fragment: zS,
  skinbase_vertex: NS,
  skinning_pars_vertex: BS,
  skinning_vertex: VS,
  skinnormal_vertex: GS,
  specularmap_fragment: HS,
  specularmap_pars_fragment: $S,
  tonemapping_fragment: WS,
  tonemapping_pars_fragment: XS,
  transmission_fragment: jS,
  transmission_pars_fragment: YS,
  uv_pars_fragment: qS,
  uv_pars_vertex: ZS,
  uv_vertex: KS,
  worldpos_vertex: JS,
  background_vert: QS,
  background_frag: eM,
  backgroundCube_vert: tM,
  backgroundCube_frag: nM,
  cube_vert: iM,
  cube_frag: sM,
  depth_vert: rM,
  depth_frag: oM,
  distanceRGBA_vert: aM,
  distanceRGBA_frag: lM,
  equirect_vert: cM,
  equirect_frag: uM,
  linedashed_vert: dM,
  linedashed_frag: hM,
  meshbasic_vert: fM,
  meshbasic_frag: pM,
  meshlambert_vert: mM,
  meshlambert_frag: vM,
  meshmatcap_vert: gM,
  meshmatcap_frag: yM,
  meshnormal_vert: xM,
  meshnormal_frag: _M,
  meshphong_vert: bM,
  meshphong_frag: wM,
  meshphysical_vert: SM,
  meshphysical_frag: MM,
  meshtoon_vert: CM,
  meshtoon_frag: TM,
  points_vert: EM,
  points_frag: AM,
  shadow_vert: PM,
  shadow_frag: RM,
  sprite_vert: DM,
  sprite_frag: kM
}, tt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Tt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Tt() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Tt() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Tt() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Tt() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Tt() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Tt() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Tt() },
    normalScale: { value: /* @__PURE__ */ new rt(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Tt() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Tt() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Tt() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Tt() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Mt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Tt() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Tt() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new rt(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Tt() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Tt() },
    alphaTest: { value: 0 }
  }
}, ss = {
  basic: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.fog
    ]),
    vertexShader: Et.meshbasic_vert,
    fragmentShader: Et.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: Et.meshlambert_vert,
    fragmentShader: Et.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        specular: { value: /* @__PURE__ */ new Mt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Et.meshphong_vert,
    fragmentShader: Et.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.roughnessmap,
      tt.metalnessmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Et.meshphysical_vert,
    fragmentShader: Et.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.gradientmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: Et.meshtoon_vert,
    fragmentShader: Et.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Et.meshmatcap_vert,
    fragmentShader: Et.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ ei([
      tt.points,
      tt.fog
    ]),
    vertexShader: Et.points_vert,
    fragmentShader: Et.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Et.linedashed_vert,
    fragmentShader: Et.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.displacementmap
    ]),
    vertexShader: Et.depth_vert,
    fragmentShader: Et.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Et.meshnormal_vert,
    fragmentShader: Et.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ ei([
      tt.sprite,
      tt.fog
    ]),
    vertexShader: Et.sprite_vert,
    fragmentShader: Et.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Tt() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Et.background_vert,
    fragmentShader: Et.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Tt() }
    },
    vertexShader: Et.backgroundCube_vert,
    fragmentShader: Et.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Et.cube_vert,
    fragmentShader: Et.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Et.equirect_vert,
    fragmentShader: Et.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ ei([
      tt.common,
      tt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new de() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Et.distanceRGBA_vert,
    fragmentShader: Et.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ ei([
      tt.lights,
      tt.fog,
      {
        color: { value: /* @__PURE__ */ new Mt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Et.shadow_vert,
    fragmentShader: Et.shadow_frag
  }
};
ss.physical = {
  uniforms: /* @__PURE__ */ ei([
    ss.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Tt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Tt() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new rt(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Tt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Tt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Tt() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Mt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Tt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Tt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Tt() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new rt() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Tt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Mt(0) },
      specularColor: { value: /* @__PURE__ */ new Mt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Tt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Tt() },
      anisotropyVector: { value: /* @__PURE__ */ new rt() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Tt() }
    }
  ]),
  vertexShader: Et.meshphysical_vert,
  fragmentShader: Et.meshphysical_frag
};
const ic = { r: 0, b: 0, g: 0 }, br = /* @__PURE__ */ new Mi(), IM = /* @__PURE__ */ new Zt();
function LM(s, e, n, i, r, o, a) {
  const l = new Mt(0);
  let c = o === !0 ? 0 : 1, u, d, h = null, m = 0, p = null;
  function v(M) {
    let S = M.isScene === !0 ? M.background : null;
    return S && S.isTexture && (S = (M.backgroundBlurriness > 0 ? n : e).get(S)), S;
  }
  function _(M) {
    let S = !1;
    const b = v(M);
    b === null ? x(l, c) : b && b.isColor && (x(b, 1), S = !0);
    const C = s.xr.getEnvironmentBlendMode();
    C === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : C === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || S) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function g(M, S) {
    const b = v(S);
    b && (b.isCubeTexture || b.mapping === Tu) ? (d === void 0 && (d = new Ze(
      new pn(1, 1, 1),
      new zn({
        name: "BackgroundCubeMaterial",
        uniforms: jo(ss.backgroundCube.uniforms),
        vertexShader: ss.backgroundCube.vertexShader,
        fragmentShader: ss.backgroundCube.fragmentShader,
        side: hi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function(C, T, P) {
      this.matrixWorld.copyPosition(P.matrixWorld);
    }, Object.defineProperty(d.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(d)), br.copy(S.backgroundRotation), br.x *= -1, br.y *= -1, br.z *= -1, b.isCubeTexture && b.isRenderTargetTexture === !1 && (br.y *= -1, br.z *= -1), d.material.uniforms.envMap.value = b, d.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = S.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = S.backgroundIntensity, d.material.uniforms.backgroundRotation.value.setFromMatrix4(IM.makeRotationFromEuler(br)), d.material.toneMapped = It.getTransfer(b.colorSpace) !== qt, (h !== b || m !== b.version || p !== s.toneMapping) && (d.material.needsUpdate = !0, h = b, m = b.version, p = s.toneMapping), d.layers.enableAll(), M.unshift(d, d.geometry, d.material, 0, 0, null)) : b && b.isTexture && (u === void 0 && (u = new Ze(
      new un(2, 2),
      new zn({
        name: "BackgroundMaterial",
        uniforms: jo(ss.background.uniforms),
        vertexShader: ss.background.vertexShader,
        fragmentShader: ss.background.fragmentShader,
        side: ar,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(u)), u.material.uniforms.t2D.value = b, u.material.uniforms.backgroundIntensity.value = S.backgroundIntensity, u.material.toneMapped = It.getTransfer(b.colorSpace) !== qt, b.matrixAutoUpdate === !0 && b.updateMatrix(), u.material.uniforms.uvTransform.value.copy(b.matrix), (h !== b || m !== b.version || p !== s.toneMapping) && (u.material.needsUpdate = !0, h = b, m = b.version, p = s.toneMapping), u.layers.enableAll(), M.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function x(M, S) {
    M.getRGB(ic, oy(s)), i.buffers.color.setClear(ic.r, ic.g, ic.b, S, a);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(M, S = 1) {
      l.set(M), c = S, x(l, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(M) {
      c = M, x(l, c);
    },
    render: _,
    addToRenderList: g
  };
}
function FM(s, e) {
  const n = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, r = m(null);
  let o = r, a = !1;
  function l(w, D, U, R, O) {
    let A = !1;
    const G = h(R, U, D);
    o !== G && (o = G, u(o.object)), A = p(w, R, U, O), A && v(w, R, U, O), O !== null && e.update(O, s.ELEMENT_ARRAY_BUFFER), (A || a) && (a = !1, b(w, D, U, R), O !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(O).buffer));
  }
  function c() {
    return s.createVertexArray();
  }
  function u(w) {
    return s.bindVertexArray(w);
  }
  function d(w) {
    return s.deleteVertexArray(w);
  }
  function h(w, D, U) {
    const R = U.wireframe === !0;
    let O = i[w.id];
    O === void 0 && (O = {}, i[w.id] = O);
    let A = O[D.id];
    A === void 0 && (A = {}, O[D.id] = A);
    let G = A[R];
    return G === void 0 && (G = m(c()), A[R] = G), G;
  }
  function m(w) {
    const D = [], U = [], R = [];
    for (let O = 0; O < n; O++)
      D[O] = 0, U[O] = 0, R[O] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: D,
      enabledAttributes: U,
      attributeDivisors: R,
      object: w,
      attributes: {},
      index: null
    };
  }
  function p(w, D, U, R) {
    const O = o.attributes, A = D.attributes;
    let G = 0;
    const ue = U.getAttributes();
    for (const Q in ue)
      if (ue[Q].location >= 0) {
        const re = O[Q];
        let j = A[Q];
        if (j === void 0 && (Q === "instanceMatrix" && w.instanceMatrix && (j = w.instanceMatrix), Q === "instanceColor" && w.instanceColor && (j = w.instanceColor)), re === void 0 || re.attribute !== j || j && re.data !== j.data) return !0;
        G++;
      }
    return o.attributesNum !== G || o.index !== R;
  }
  function v(w, D, U, R) {
    const O = {}, A = D.attributes;
    let G = 0;
    const ue = U.getAttributes();
    for (const Q in ue)
      if (ue[Q].location >= 0) {
        let re = A[Q];
        re === void 0 && (Q === "instanceMatrix" && w.instanceMatrix && (re = w.instanceMatrix), Q === "instanceColor" && w.instanceColor && (re = w.instanceColor));
        const j = {};
        j.attribute = re, re && re.data && (j.data = re.data), O[Q] = j, G++;
      }
    o.attributes = O, o.attributesNum = G, o.index = R;
  }
  function _() {
    const w = o.newAttributes;
    for (let D = 0, U = w.length; D < U; D++)
      w[D] = 0;
  }
  function g(w) {
    x(w, 0);
  }
  function x(w, D) {
    const U = o.newAttributes, R = o.enabledAttributes, O = o.attributeDivisors;
    U[w] = 1, R[w] === 0 && (s.enableVertexAttribArray(w), R[w] = 1), O[w] !== D && (s.vertexAttribDivisor(w, D), O[w] = D);
  }
  function M() {
    const w = o.newAttributes, D = o.enabledAttributes;
    for (let U = 0, R = D.length; U < R; U++)
      D[U] !== w[U] && (s.disableVertexAttribArray(U), D[U] = 0);
  }
  function S(w, D, U, R, O, A, G) {
    G === !0 ? s.vertexAttribIPointer(w, D, U, O, A) : s.vertexAttribPointer(w, D, U, R, O, A);
  }
  function b(w, D, U, R) {
    _();
    const O = R.attributes, A = U.getAttributes(), G = D.defaultAttributeValues;
    for (const ue in A) {
      const Q = A[ue];
      if (Q.location >= 0) {
        let le = O[ue];
        if (le === void 0 && (ue === "instanceMatrix" && w.instanceMatrix && (le = w.instanceMatrix), ue === "instanceColor" && w.instanceColor && (le = w.instanceColor)), le !== void 0) {
          const re = le.normalized, j = le.itemSize, $ = e.get(le);
          if ($ === void 0) continue;
          const q = $.buffer, oe = $.type, ie = $.bytesPerElement, ce = oe === s.INT || oe === s.UNSIGNED_INT || le.gpuType === Cf;
          if (le.isInterleavedBufferAttribute) {
            const V = le.data, Y = V.stride, H = le.offset;
            if (V.isInstancedInterleavedBuffer) {
              for (let I = 0; I < Q.locationSize; I++)
                x(Q.location + I, V.meshPerAttribute);
              w.isInstancedMesh !== !0 && R._maxInstanceCount === void 0 && (R._maxInstanceCount = V.meshPerAttribute * V.count);
            } else
              for (let I = 0; I < Q.locationSize; I++)
                g(Q.location + I);
            s.bindBuffer(s.ARRAY_BUFFER, q);
            for (let I = 0; I < Q.locationSize; I++)
              S(
                Q.location + I,
                j / Q.locationSize,
                oe,
                re,
                Y * ie,
                (H + j / Q.locationSize * I) * ie,
                ce
              );
          } else {
            if (le.isInstancedBufferAttribute) {
              for (let V = 0; V < Q.locationSize; V++)
                x(Q.location + V, le.meshPerAttribute);
              w.isInstancedMesh !== !0 && R._maxInstanceCount === void 0 && (R._maxInstanceCount = le.meshPerAttribute * le.count);
            } else
              for (let V = 0; V < Q.locationSize; V++)
                g(Q.location + V);
            s.bindBuffer(s.ARRAY_BUFFER, q);
            for (let V = 0; V < Q.locationSize; V++)
              S(
                Q.location + V,
                j / Q.locationSize,
                oe,
                re,
                j * ie,
                j / Q.locationSize * V * ie,
                ce
              );
          }
        } else if (G !== void 0) {
          const re = G[ue];
          if (re !== void 0)
            switch (re.length) {
              case 2:
                s.vertexAttrib2fv(Q.location, re);
                break;
              case 3:
                s.vertexAttrib3fv(Q.location, re);
                break;
              case 4:
                s.vertexAttrib4fv(Q.location, re);
                break;
              default:
                s.vertexAttrib1fv(Q.location, re);
            }
        }
      }
    }
    M();
  }
  function C() {
    E();
    for (const w in i) {
      const D = i[w];
      for (const U in D) {
        const R = D[U];
        for (const O in R)
          d(R[O].object), delete R[O];
        delete D[U];
      }
      delete i[w];
    }
  }
  function T(w) {
    if (i[w.id] === void 0) return;
    const D = i[w.id];
    for (const U in D) {
      const R = D[U];
      for (const O in R)
        d(R[O].object), delete R[O];
      delete D[U];
    }
    delete i[w.id];
  }
  function P(w) {
    for (const D in i) {
      const U = i[D];
      if (U[w.id] === void 0) continue;
      const R = U[w.id];
      for (const O in R)
        d(R[O].object), delete R[O];
      delete U[w.id];
    }
  }
  function E() {
    y(), a = !0, o !== r && (o = r, u(o.object));
  }
  function y() {
    r.geometry = null, r.program = null, r.wireframe = !1;
  }
  return {
    setup: l,
    reset: E,
    resetDefaultState: y,
    dispose: C,
    releaseStatesOfGeometry: T,
    releaseStatesOfProgram: P,
    initAttributes: _,
    enableAttribute: g,
    disableUnusedAttributes: M
  };
}
function UM(s, e, n) {
  let i;
  function r(u) {
    i = u;
  }
  function o(u, d) {
    s.drawArrays(i, u, d), n.update(d, i, 1);
  }
  function a(u, d, h) {
    h !== 0 && (s.drawArraysInstanced(i, u, d, h), n.update(d, i, h));
  }
  function l(u, d, h) {
    if (h === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, u, 0, d, 0, h);
    let p = 0;
    for (let v = 0; v < h; v++)
      p += d[v];
    n.update(p, i, 1);
  }
  function c(u, d, h, m) {
    if (h === 0) return;
    const p = e.get("WEBGL_multi_draw");
    if (p === null)
      for (let v = 0; v < u.length; v++)
        a(u[v], d[v], m[v]);
    else {
      p.multiDrawArraysInstancedWEBGL(i, u, 0, d, 0, m, 0, h);
      let v = 0;
      for (let _ = 0; _ < h; _++)
        v += d[_] * m[_];
      n.update(v, i, 1);
    }
  }
  this.setMode = r, this.render = o, this.renderInstances = a, this.renderMultiDraw = l, this.renderMultiDrawInstances = c;
}
function OM(s, e, n, i) {
  let r;
  function o() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      r = s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function a(P) {
    return !(P !== Rn && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(P) {
    const E = P === dr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(P !== ji && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    P !== si && !E);
  }
  function c(P) {
    if (P === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      P = "mediump";
    }
    return P === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = n.precision !== void 0 ? n.precision : "highp";
  const d = c(u);
  d !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", d, "instead."), u = d);
  const h = n.logarithmicDepthBuffer === !0, m = n.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), p = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), v = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = s.getParameter(s.MAX_TEXTURE_SIZE), g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), x = s.getParameter(s.MAX_VERTEX_ATTRIBS), M = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), S = s.getParameter(s.MAX_VARYING_VECTORS), b = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), C = v > 0, T = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: o,
    getMaxPrecision: c,
    textureFormatReadable: a,
    textureTypeReadable: l,
    precision: u,
    logarithmicDepthBuffer: h,
    reverseDepthBuffer: m,
    maxTextures: p,
    maxVertexTextures: v,
    maxTextureSize: _,
    maxCubemapSize: g,
    maxAttributes: x,
    maxVertexUniforms: M,
    maxVaryings: S,
    maxFragmentUniforms: b,
    vertexTextures: C,
    maxSamples: T
  };
}
function zM(s) {
  const e = this;
  let n = null, i = 0, r = !1, o = !1;
  const a = new Ar(), l = new Tt(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, m) {
    const p = h.length !== 0 || m || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || r;
    return r = m, i = h.length, p;
  }, this.beginShadows = function() {
    o = !0, d(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(h, m) {
    n = d(h, m, 0);
  }, this.setState = function(h, m, p) {
    const v = h.clippingPlanes, _ = h.clipIntersection, g = h.clipShadows, x = s.get(h);
    if (!r || v === null || v.length === 0 || o && !g)
      o ? d(null) : u();
    else {
      const M = o ? 0 : i, S = M * 4;
      let b = x.clippingState || null;
      c.value = b, b = d(v, m, S, p);
      for (let C = 0; C !== S; ++C)
        b[C] = n[C];
      x.clippingState = b, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += M;
    }
  };
  function u() {
    c.value !== n && (c.value = n, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function d(h, m, p, v) {
    const _ = h !== null ? h.length : 0;
    let g = null;
    if (_ !== 0) {
      if (g = c.value, v !== !0 || g === null) {
        const x = p + _ * 4, M = m.matrixWorldInverse;
        l.getNormalMatrix(M), (g === null || g.length < x) && (g = new Float32Array(x));
        for (let S = 0, b = p; S !== _; ++S, b += 4)
          a.copy(h[S]).applyMatrix4(M, l), a.normal.toArray(g, b), g[b + 3] = a.constant;
      }
      c.value = g, c.needsUpdate = !0;
    }
    return e.numPlanes = _, e.numIntersection = 0, g;
  }
}
function NM(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(a, l) {
    return l === xh ? a.mapping = Go : l === _h && (a.mapping = Ho), a;
  }
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (l === xh || l === _h)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return n(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const u = new Zb(c.height);
            return u.fromEquirectangularTexture(s, a), e.set(a, u), a.addEventListener("dispose", r), n(u.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: o
  };
}
class Au extends ay {
  constructor(e = -1, n = 1, i = 1, r = -1, o = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = i, this.bottom = r, this.near = o, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, n, i, r, o, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = r, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let o = i - e, a = i + e, l = r + n, c = r - n;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += u * this.view.offsetX, a = o + u * this.view.width, l -= d * this.view.offsetY, c = l - d * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, a, l, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const Co = 4, Tm = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Ir = 20, Md = /* @__PURE__ */ new Au(), Em = /* @__PURE__ */ new Mt();
let Cd = null, Td = 0, Ed = 0, Ad = !1;
const Pr = (1 + Math.sqrt(5)) / 2, vo = 1 / Pr, Am = [
  /* @__PURE__ */ new de(-Pr, vo, 0),
  /* @__PURE__ */ new de(Pr, vo, 0),
  /* @__PURE__ */ new de(-vo, 0, Pr),
  /* @__PURE__ */ new de(vo, 0, Pr),
  /* @__PURE__ */ new de(0, Pr, -vo),
  /* @__PURE__ */ new de(0, Pr, vo),
  /* @__PURE__ */ new de(-1, 1, -1),
  /* @__PURE__ */ new de(1, 1, -1),
  /* @__PURE__ */ new de(-1, 1, 1),
  /* @__PURE__ */ new de(1, 1, 1)
];
class Pm {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, n = 0, i = 0.1, r = 100) {
    Cd = this._renderer.getRenderTarget(), Td = this._renderer.getActiveCubeFace(), Ed = this._renderer.getActiveMipmapLevel(), Ad = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, i, r, o), n > 0 && this._blur(o, 0, 0, n), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = km(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = Dm(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Cd, Td, Ed), this._renderer.xr.enabled = Ad, e.scissorTest = !1, sc(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === Go || e.mapping === Ho ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Cd = this._renderer.getRenderTarget(), Td = this._renderer.getActiveCubeFace(), Ed = this._renderer.getActiveMipmapLevel(), Ad = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = n || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, i = {
      magFilter: Bt,
      minFilter: Bt,
      generateMipmaps: !1,
      type: dr,
      format: Rn,
      colorSpace: Jo,
      depthBuffer: !1
    }, r = Rm(e, n, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Rm(e, n, i);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = BM(o)), this._blurMaterial = VM(o, e, n);
    }
    return r;
  }
  _compileMaterial(e) {
    const n = new Ze(this._lodPlanes[0], e);
    this._renderer.compile(n, Md);
  }
  _sceneToCubeUV(e, n, i, r) {
    const l = new di(90, 1, n, i), c = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], d = this._renderer, h = d.autoClear, m = d.toneMapping;
    d.getClearColor(Em), d.toneMapping = or, d.autoClear = !1;
    const p = new Tn({
      name: "PMREM.Background",
      side: hi,
      depthWrite: !1,
      depthTest: !1
    }), v = new Ze(new pn(), p);
    let _ = !1;
    const g = e.background;
    g ? g.isColor && (p.color.copy(g), e.background = null, _ = !0) : (p.color.copy(Em), _ = !0);
    for (let x = 0; x < 6; x++) {
      const M = x % 3;
      M === 0 ? (l.up.set(0, c[x], 0), l.lookAt(u[x], 0, 0)) : M === 1 ? (l.up.set(0, 0, c[x]), l.lookAt(0, u[x], 0)) : (l.up.set(0, c[x], 0), l.lookAt(0, 0, u[x]));
      const S = this._cubeSize;
      sc(r, M * S, x > 2 ? S : 0, S, S), d.setRenderTarget(r), _ && d.render(v, l), d.render(e, l);
    }
    v.geometry.dispose(), v.material.dispose(), d.toneMapping = m, d.autoClear = h, e.background = g;
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer, r = e.mapping === Go || e.mapping === Ho;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = km()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Dm());
    const o = r ? this._cubemapMaterial : this._equirectMaterial, a = new Ze(this._lodPlanes[0], o), l = o.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    sc(n, 0, 0, 3 * c, 2 * c), i.setRenderTarget(n), i.render(a, Md);
  }
  _applyPMREM(e) {
    const n = this._renderer, i = n.autoClear;
    n.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let o = 1; o < r; o++) {
      const a = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), l = Am[(r - o - 1) % Am.length];
      this._blur(e, o - 1, o, a, l);
    }
    n.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, n, i, r, o) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      n,
      i,
      r,
      "latitudinal",
      o
    ), this._halfBlur(
      a,
      e,
      i,
      i,
      r,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, n, i, r, o, a, l) {
    const c = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const d = 3, h = new Ze(this._lodPlanes[r], u), m = u.uniforms, p = this._sizeLods[i] - 1, v = isFinite(o) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Ir - 1), _ = o / v, g = isFinite(o) ? 1 + Math.floor(d * _) : Ir;
    g > Ir && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Ir}`);
    const x = [];
    let M = 0;
    for (let P = 0; P < Ir; ++P) {
      const E = P / _, y = Math.exp(-E * E / 2);
      x.push(y), P === 0 ? M += y : P < g && (M += 2 * y);
    }
    for (let P = 0; P < x.length; P++)
      x[P] = x[P] / M;
    m.envMap.value = e.texture, m.samples.value = g, m.weights.value = x, m.latitudinal.value = a === "latitudinal", l && (m.poleAxis.value = l);
    const { _lodMax: S } = this;
    m.dTheta.value = v, m.mipInt.value = S - i;
    const b = this._sizeLods[r], C = 3 * b * (r > S - Co ? r - S + Co : 0), T = 4 * (this._cubeSize - b);
    sc(n, C, T, 3 * b, 2 * b), c.setRenderTarget(n), c.render(h, Md);
  }
}
function BM(s) {
  const e = [], n = [], i = [];
  let r = s;
  const o = s - Co + 1 + Tm.length;
  for (let a = 0; a < o; a++) {
    const l = Math.pow(2, r);
    n.push(l);
    let c = 1 / l;
    a > s - Co ? c = Tm[a - s + Co - 1] : a === 0 && (c = 0), i.push(c);
    const u = 1 / (l - 2), d = -u, h = 1 + u, m = [d, d, h, d, h, h, d, d, h, h, d, h], p = 6, v = 6, _ = 3, g = 2, x = 1, M = new Float32Array(_ * v * p), S = new Float32Array(g * v * p), b = new Float32Array(x * v * p);
    for (let T = 0; T < p; T++) {
      const P = T % 3 * 2 / 3 - 1, E = T > 2 ? 0 : -1, y = [
        P,
        E,
        0,
        P + 2 / 3,
        E,
        0,
        P + 2 / 3,
        E + 1,
        0,
        P,
        E,
        0,
        P + 2 / 3,
        E + 1,
        0,
        P,
        E + 1,
        0
      ];
      M.set(y, _ * v * T), S.set(m, g * v * T);
      const w = [T, T, T, T, T, T];
      b.set(w, x * v * T);
    }
    const C = new Vt();
    C.setAttribute("position", new Si(M, _)), C.setAttribute("uv", new Si(S, g)), C.setAttribute("faceIndex", new Si(b, x)), e.push(C), r > Co && r--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i };
}
function Rm(s, e, n) {
  const i = new Ri(s, e, n);
  return i.texture.mapping = Tu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function sc(s, e, n, i, r) {
  s.viewport.set(e, n, i, r), s.scissor.set(e, n, i, r);
}
function VM(s, e, n) {
  const i = new Float32Array(Ir), r = new de(0, 1, 0);
  return new zn({
    name: "SphericalGaussianBlur",
    defines: {
      n: Ir,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: Of(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: os,
    depthTest: !1,
    depthWrite: !1
  });
}
function Dm() {
  return new zn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Of(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: os,
    depthTest: !1,
    depthWrite: !1
  });
}
function km() {
  return new zn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Of(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: os,
    depthTest: !1,
    depthWrite: !1
  });
}
function Of() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function GM(s) {
  let e = /* @__PURE__ */ new WeakMap(), n = null;
  function i(l) {
    if (l && l.isTexture) {
      const c = l.mapping, u = c === xh || c === _h, d = c === Go || c === Ho;
      if (u || d) {
        let h = e.get(l);
        const m = h !== void 0 ? h.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== m)
          return n === null && (n = new Pm(s)), h = u ? n.fromEquirectangular(l, h) : n.fromCubemap(l, h), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), h.texture;
        if (h !== void 0)
          return h.texture;
        {
          const p = l.image;
          return u && p && p.height > 0 || d && p && r(p) ? (n === null && (n = new Pm(s)), h = u ? n.fromEquirectangular(l) : n.fromCubemap(l), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), l.addEventListener("dispose", o), h.texture) : null;
        }
      }
    }
    return l;
  }
  function r(l) {
    let c = 0;
    const u = 6;
    for (let d = 0; d < u; d++)
      l[d] !== void 0 && c++;
    return c === u;
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o);
    const u = e.get(c);
    u !== void 0 && (e.delete(c), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
  }
  return {
    get: i,
    dispose: a
  };
}
function HM(s) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0)
      return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = s.getExtension(i);
    }
    return e[i] = r, r;
  }
  return {
    has: function(i) {
      return n(i) !== null;
    },
    init: function() {
      n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent");
    },
    get: function(i) {
      const r = n(i);
      return r === null && Da("THREE.WebGLRenderer: " + i + " extension not supported."), r;
    }
  };
}
function $M(s, e, n, i) {
  const r = {}, o = /* @__PURE__ */ new WeakMap();
  function a(h) {
    const m = h.target;
    m.index !== null && e.remove(m.index);
    for (const v in m.attributes)
      e.remove(m.attributes[v]);
    for (const v in m.morphAttributes) {
      const _ = m.morphAttributes[v];
      for (let g = 0, x = _.length; g < x; g++)
        e.remove(_[g]);
    }
    m.removeEventListener("dispose", a), delete r[m.id];
    const p = o.get(m);
    p && (e.remove(p), o.delete(m)), i.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount, n.memory.geometries--;
  }
  function l(h, m) {
    return r[m.id] === !0 || (m.addEventListener("dispose", a), r[m.id] = !0, n.memory.geometries++), m;
  }
  function c(h) {
    const m = h.attributes;
    for (const v in m)
      e.update(m[v], s.ARRAY_BUFFER);
    const p = h.morphAttributes;
    for (const v in p) {
      const _ = p[v];
      for (let g = 0, x = _.length; g < x; g++)
        e.update(_[g], s.ARRAY_BUFFER);
    }
  }
  function u(h) {
    const m = [], p = h.index, v = h.attributes.position;
    let _ = 0;
    if (p !== null) {
      const M = p.array;
      _ = p.version;
      for (let S = 0, b = M.length; S < b; S += 3) {
        const C = M[S + 0], T = M[S + 1], P = M[S + 2];
        m.push(C, T, T, P, P, C);
      }
    } else if (v !== void 0) {
      const M = v.array;
      _ = v.version;
      for (let S = 0, b = M.length / 3 - 1; S < b; S += 3) {
        const C = S + 0, T = S + 1, P = S + 2;
        m.push(C, T, T, P, P, C);
      }
    } else
      return;
    const g = new (ey(m) ? ry : sy)(m, 1);
    g.version = _;
    const x = o.get(h);
    x && e.remove(x), o.set(h, g);
  }
  function d(h) {
    const m = o.get(h);
    if (m) {
      const p = h.index;
      p !== null && m.version < p.version && u(h);
    } else
      u(h);
    return o.get(h);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: d
  };
}
function WM(s, e, n) {
  let i;
  function r(m) {
    i = m;
  }
  let o, a;
  function l(m) {
    o = m.type, a = m.bytesPerElement;
  }
  function c(m, p) {
    s.drawElements(i, p, o, m * a), n.update(p, i, 1);
  }
  function u(m, p, v) {
    v !== 0 && (s.drawElementsInstanced(i, p, o, m * a, v), n.update(p, i, v));
  }
  function d(m, p, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, o, m, 0, v);
    let g = 0;
    for (let x = 0; x < v; x++)
      g += p[x];
    n.update(g, i, 1);
  }
  function h(m, p, v, _) {
    if (v === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null)
      for (let x = 0; x < m.length; x++)
        u(m[x] / a, p[x], _[x]);
    else {
      g.multiDrawElementsInstancedWEBGL(i, p, 0, o, m, 0, _, 0, v);
      let x = 0;
      for (let M = 0; M < v; M++)
        x += p[M] * _[M];
      n.update(x, i, 1);
    }
  }
  this.setMode = r, this.setIndex = l, this.render = c, this.renderInstances = u, this.renderMultiDraw = d, this.renderMultiDrawInstances = h;
}
function XM(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(o, a, l) {
    switch (n.calls++, a) {
      case s.TRIANGLES:
        n.triangles += l * (o / 3);
        break;
      case s.LINES:
        n.lines += l * (o / 2);
        break;
      case s.LINE_STRIP:
        n.lines += l * (o - 1);
        break;
      case s.LINE_LOOP:
        n.lines += l * o;
        break;
      case s.POINTS:
        n.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function r() {
    n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i
  };
}
function jM(s, e, n) {
  const i = /* @__PURE__ */ new WeakMap(), r = new jt();
  function o(a, l, c) {
    const u = a.morphTargetInfluences, d = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, h = d !== void 0 ? d.length : 0;
    let m = i.get(l);
    if (m === void 0 || m.count !== h) {
      let p = function() {
        E.dispose(), i.delete(l), l.removeEventListener("dispose", p);
      };
      m !== void 0 && m.texture.dispose();
      const v = l.morphAttributes.position !== void 0, _ = l.morphAttributes.normal !== void 0, g = l.morphAttributes.color !== void 0, x = l.morphAttributes.position || [], M = l.morphAttributes.normal || [], S = l.morphAttributes.color || [];
      let b = 0;
      v === !0 && (b = 1), _ === !0 && (b = 2), g === !0 && (b = 3);
      let C = l.attributes.position.count * b, T = 1;
      C > e.maxTextureSize && (T = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
      const P = new Float32Array(C * T * 4 * h), E = new ny(P, C, T, h);
      E.type = si, E.needsUpdate = !0;
      const y = b * 4;
      for (let w = 0; w < h; w++) {
        const D = x[w], U = M[w], R = S[w], O = C * T * 4 * w;
        for (let A = 0; A < D.count; A++) {
          const G = A * y;
          v === !0 && (r.fromBufferAttribute(D, A), P[O + G + 0] = r.x, P[O + G + 1] = r.y, P[O + G + 2] = r.z, P[O + G + 3] = 0), _ === !0 && (r.fromBufferAttribute(U, A), P[O + G + 4] = r.x, P[O + G + 5] = r.y, P[O + G + 6] = r.z, P[O + G + 7] = 0), g === !0 && (r.fromBufferAttribute(R, A), P[O + G + 8] = r.x, P[O + G + 9] = r.y, P[O + G + 10] = r.z, P[O + G + 11] = R.itemSize === 4 ? r.w : 1);
        }
      }
      m = {
        count: h,
        texture: E,
        size: new rt(C, T)
      }, i.set(l, m), l.addEventListener("dispose", p);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      c.getUniforms().setValue(s, "morphTexture", a.morphTexture, n);
    else {
      let p = 0;
      for (let _ = 0; _ < u.length; _++)
        p += u[_];
      const v = l.morphTargetsRelative ? 1 : 1 - p;
      c.getUniforms().setValue(s, "morphTargetBaseInfluence", v), c.getUniforms().setValue(s, "morphTargetInfluences", u);
    }
    c.getUniforms().setValue(s, "morphTargetsTexture", m.texture, n), c.getUniforms().setValue(s, "morphTargetsTextureSize", m.size);
  }
  return {
    update: o
  };
}
function YM(s, e, n, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function o(c) {
    const u = i.render.frame, d = c.geometry, h = e.get(c, d);
    if (r.get(h) !== u && (e.update(h), r.set(h, u)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), r.get(c) !== u && (n.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && n.update(c.instanceColor, s.ARRAY_BUFFER), r.set(c, u))), c.isSkinnedMesh) {
      const m = c.skeleton;
      r.get(m) !== u && (m.update(), r.set(m, u));
    }
    return h;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const u = c.target;
    u.removeEventListener("dispose", l), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor);
  }
  return {
    update: o,
    dispose: a
  };
}
class zf extends _n {
  constructor(e, n, i, r, o, a, l, c, u, d = Vr) {
    if (d !== Vr && d !== Wo)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && d === Vr && (i = Wr), i === void 0 && d === Wo && (i = $o), super(null, r, o, a, l, c, d, i, u), this.isDepthTexture = !0, this.image = { width: e, height: n }, this.magFilter = l !== void 0 ? l : On, this.minFilter = c !== void 0 ? c : On, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
const uy = /* @__PURE__ */ new _n(), Im = /* @__PURE__ */ new zf(1, 1), dy = /* @__PURE__ */ new ny(), hy = /* @__PURE__ */ new Fb(), fy = /* @__PURE__ */ new ly(), Lm = [], Fm = [], Um = new Float32Array(16), Om = new Float32Array(9), zm = new Float32Array(4);
function Qo(s, e, n) {
  const i = s[0];
  if (i <= 0 || i > 0) return s;
  const r = e * n;
  let o = Lm[r];
  if (o === void 0 && (o = new Float32Array(r), Lm[r] = o), e !== 0) {
    i.toArray(o, 0);
    for (let a = 1, l = 0; a !== e; ++a)
      l += n, s[a].toArray(o, l);
  }
  return o;
}
function En(s, e) {
  if (s.length !== e.length) return !1;
  for (let n = 0, i = s.length; n < i; n++)
    if (s[n] !== e[n]) return !1;
  return !0;
}
function An(s, e) {
  for (let n = 0, i = e.length; n < i; n++)
    s[n] = e[n];
}
function Pu(s, e) {
  let n = Fm[e];
  n === void 0 && (n = new Int32Array(e), Fm[e] = n);
  for (let i = 0; i !== e; ++i)
    n[i] = s.allocateTextureUnit();
  return n;
}
function qM(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1f(this.addr, e), n[0] = e);
}
function ZM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (En(n, e)) return;
    s.uniform2fv(this.addr, e), An(n, e);
  }
}
function KM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (En(n, e)) return;
    s.uniform3fv(this.addr, e), An(n, e);
  }
}
function JM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (En(n, e)) return;
    s.uniform4fv(this.addr, e), An(n, e);
  }
}
function QM(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (En(n, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), An(n, e);
  } else {
    if (En(n, i)) return;
    zm.set(i), s.uniformMatrix2fv(this.addr, !1, zm), An(n, i);
  }
}
function eC(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (En(n, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), An(n, e);
  } else {
    if (En(n, i)) return;
    Om.set(i), s.uniformMatrix3fv(this.addr, !1, Om), An(n, i);
  }
}
function tC(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (En(n, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), An(n, e);
  } else {
    if (En(n, i)) return;
    Um.set(i), s.uniformMatrix4fv(this.addr, !1, Um), An(n, i);
  }
}
function nC(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1i(this.addr, e), n[0] = e);
}
function iC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (En(n, e)) return;
    s.uniform2iv(this.addr, e), An(n, e);
  }
}
function sC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (En(n, e)) return;
    s.uniform3iv(this.addr, e), An(n, e);
  }
}
function rC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (En(n, e)) return;
    s.uniform4iv(this.addr, e), An(n, e);
  }
}
function oC(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1ui(this.addr, e), n[0] = e);
}
function aC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (En(n, e)) return;
    s.uniform2uiv(this.addr, e), An(n, e);
  }
}
function lC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (En(n, e)) return;
    s.uniform3uiv(this.addr, e), An(n, e);
  }
}
function cC(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (En(n, e)) return;
    s.uniform4uiv(this.addr, e), An(n, e);
  }
}
function uC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r);
  let o;
  this.type === s.SAMPLER_2D_SHADOW ? (Im.compareFunction = Q0, o = Im) : o = uy, n.setTexture2D(e || o, r);
}
function dC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || hy, r);
}
function hC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || fy, r);
}
function fC(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || dy, r);
}
function pC(s) {
  switch (s) {
    case 5126:
      return qM;
    case 35664:
      return ZM;
    case 35665:
      return KM;
    case 35666:
      return JM;
    case 35674:
      return QM;
    case 35675:
      return eC;
    case 35676:
      return tC;
    case 5124:
    case 35670:
      return nC;
    case 35667:
    case 35671:
      return iC;
    case 35668:
    case 35672:
      return sC;
    case 35669:
    case 35673:
      return rC;
    case 5125:
      return oC;
    case 36294:
      return aC;
    case 36295:
      return lC;
    case 36296:
      return cC;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return uC;
    case 35679:
    case 36299:
    case 36307:
      return dC;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return hC;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return fC;
  }
}
function mC(s, e) {
  s.uniform1fv(this.addr, e);
}
function vC(s, e) {
  const n = Qo(e, this.size, 2);
  s.uniform2fv(this.addr, n);
}
function gC(s, e) {
  const n = Qo(e, this.size, 3);
  s.uniform3fv(this.addr, n);
}
function yC(s, e) {
  const n = Qo(e, this.size, 4);
  s.uniform4fv(this.addr, n);
}
function xC(s, e) {
  const n = Qo(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, n);
}
function _C(s, e) {
  const n = Qo(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, n);
}
function bC(s, e) {
  const n = Qo(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, n);
}
function wC(s, e) {
  s.uniform1iv(this.addr, e);
}
function SC(s, e) {
  s.uniform2iv(this.addr, e);
}
function MC(s, e) {
  s.uniform3iv(this.addr, e);
}
function CC(s, e) {
  s.uniform4iv(this.addr, e);
}
function TC(s, e) {
  s.uniform1uiv(this.addr, e);
}
function EC(s, e) {
  s.uniform2uiv(this.addr, e);
}
function AC(s, e) {
  s.uniform3uiv(this.addr, e);
}
function PC(s, e) {
  s.uniform4uiv(this.addr, e);
}
function RC(s, e, n) {
  const i = this.cache, r = e.length, o = Pu(n, r);
  En(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture2D(e[a] || uy, o[a]);
}
function DC(s, e, n) {
  const i = this.cache, r = e.length, o = Pu(n, r);
  En(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture3D(e[a] || hy, o[a]);
}
function kC(s, e, n) {
  const i = this.cache, r = e.length, o = Pu(n, r);
  En(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTextureCube(e[a] || fy, o[a]);
}
function IC(s, e, n) {
  const i = this.cache, r = e.length, o = Pu(n, r);
  En(i, o) || (s.uniform1iv(this.addr, o), An(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture2DArray(e[a] || dy, o[a]);
}
function LC(s) {
  switch (s) {
    case 5126:
      return mC;
    case 35664:
      return vC;
    case 35665:
      return gC;
    case 35666:
      return yC;
    case 35674:
      return xC;
    case 35675:
      return _C;
    case 35676:
      return bC;
    case 5124:
    case 35670:
      return wC;
    case 35667:
    case 35671:
      return SC;
    case 35668:
    case 35672:
      return MC;
    case 35669:
    case 35673:
      return CC;
    case 5125:
      return TC;
    case 36294:
      return EC;
    case 36295:
      return AC;
    case 36296:
      return PC;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return RC;
    case 35679:
    case 36299:
    case 36307:
      return DC;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return kC;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return IC;
  }
}
class FC {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.setValue = pC(n.type);
  }
}
class UC {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = LC(n.type);
  }
}
class OC {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, n, i) {
    const r = this.seq;
    for (let o = 0, a = r.length; o !== a; ++o) {
      const l = r[o];
      l.setValue(e, n[l.id], i);
    }
  }
}
const Pd = /(\w+)(\])?(\[|\.)?/g;
function Nm(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function zC(s, e, n) {
  const i = s.name, r = i.length;
  for (Pd.lastIndex = 0; ; ) {
    const o = Pd.exec(i), a = Pd.lastIndex;
    let l = o[1];
    const c = o[2] === "]", u = o[3];
    if (c && (l = l | 0), u === void 0 || u === "[" && a + 2 === r) {
      Nm(n, u === void 0 ? new FC(l, s, e) : new UC(l, s, e));
      break;
    } else {
      let h = n.map[l];
      h === void 0 && (h = new OC(l), Nm(n, h)), n = h;
    }
  }
}
class Nc {
  constructor(e, n) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const o = e.getActiveUniform(n, r), a = e.getUniformLocation(n, o.name);
      zC(o, a, this);
    }
  }
  setValue(e, n, i, r) {
    const o = this.map[n];
    o !== void 0 && o.setValue(e, i, r);
  }
  setOptional(e, n, i) {
    const r = n[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, n, i, r) {
    for (let o = 0, a = n.length; o !== a; ++o) {
      const l = n[o], c = i[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, r);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let r = 0, o = e.length; r !== o; ++r) {
      const a = e[r];
      a.id in n && i.push(a);
    }
    return i;
  }
}
function Bm(s, e, n) {
  const i = s.createShader(e);
  return s.shaderSource(i, n), s.compileShader(i), i;
}
const NC = 37297;
let BC = 0;
function VC(s, e) {
  const n = s.split(`
`), i = [], r = Math.max(e - 6, 0), o = Math.min(e + 6, n.length);
  for (let a = r; a < o; a++) {
    const l = a + 1;
    i.push(`${l === e ? ">" : " "} ${l}: ${n[a]}`);
  }
  return i.join(`
`);
}
const Vm = /* @__PURE__ */ new Tt();
function GC(s) {
  It._getMatrix(Vm, It.workingColorSpace, s);
  const e = `mat3( ${Vm.elements.map((n) => n.toFixed(4))} )`;
  switch (It.getTransfer(s)) {
    case Eu:
      return [e, "LinearTransferOETF"];
    case qt:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [e, "LinearTransferOETF"];
  }
}
function Gm(s, e, n) {
  const i = s.getShaderParameter(e, s.COMPILE_STATUS), r = s.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(r);
  if (o) {
    const a = parseInt(o[1]);
    return n.toUpperCase() + `

` + r + `

` + VC(s.getShaderSource(e), a);
  } else
    return r;
}
function HC(s, e) {
  const n = GC(e);
  return [
    `vec4 ${s}( vec4 value ) {`,
    `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function $C(s, e) {
  let n;
  switch (e) {
    case z0:
      n = "Linear";
      break;
    case N0:
      n = "Reinhard";
      break;
    case B0:
      n = "Cineon";
      break;
    case Mf:
      n = "ACESFilmic";
      break;
    case V0:
      n = "AgX";
      break;
    case G0:
      n = "Neutral";
      break;
    case eb:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
const rc = /* @__PURE__ */ new de();
function WC() {
  It.getLuminanceCoefficients(rc);
  const s = rc.x.toFixed(4), e = rc.y.toFixed(4), n = rc.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${n} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function XC(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(ka).join(`
`);
}
function jC(s) {
  const e = [];
  for (const n in s) {
    const i = s[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function YC(s, e) {
  const n = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const o = s.getActiveAttrib(e, r), a = o.name;
    let l = 1;
    o.type === s.FLOAT_MAT2 && (l = 2), o.type === s.FLOAT_MAT3 && (l = 3), o.type === s.FLOAT_MAT4 && (l = 4), n[a] = {
      type: o.type,
      location: s.getAttribLocation(e, a),
      locationSize: l
    };
  }
  return n;
}
function ka(s) {
  return s !== "";
}
function Hm(s, e) {
  const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function $m(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const qC = /^[ \t]*#include +<([\w\d./]+)>/gm;
function qh(s) {
  return s.replace(qC, KC);
}
const ZC = /* @__PURE__ */ new Map();
function KC(s, e) {
  let n = Et[e];
  if (n === void 0) {
    const i = ZC.get(e);
    if (i !== void 0)
      n = Et[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return qh(n);
}
const JC = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Wm(s) {
  return s.replace(JC, QC);
}
function QC(s, e, n, i) {
  let r = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    r += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return r;
}
function Xm(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function e2(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === D0 ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === k0 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === _s && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function t2(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case Go:
      case Ho:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Tu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function n2(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Ho:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function i2(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case O0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case J_:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Q_:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function s2(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: i, maxMip: n };
}
function r2(s, e, n, i) {
  const r = s.getContext(), o = n.defines;
  let a = n.vertexShader, l = n.fragmentShader;
  const c = e2(n), u = t2(n), d = n2(n), h = i2(n), m = s2(n), p = XC(n), v = jC(o), _ = r.createProgram();
  let g, x, M = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (g = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v
  ].filter(ka).join(`
`), g.length > 0 && (g += `
`), x = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v
  ].filter(ka).join(`
`), x.length > 0 && (x += `
`)) : (g = [
    Xm(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v,
    n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    n.batching ? "#define USE_BATCHING" : "",
    n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + d : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    n.mapUv ? "#define MAP_UV " + n.mapUv : "",
    n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
    n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
    n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
    n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
    n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
    n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
    n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
    n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
    n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
    n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
    n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
    n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "",
    n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "",
    n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
    n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "",
    n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
    n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "",
    n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
    n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
    n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "",
    n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
    n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
    //
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.morphColors ? "#define USE_MORPHCOLORS" : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ka).join(`
`), x = [
    Xm(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    v,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + u : "",
    n.envMap ? "#define " + d : "",
    n.envMap ? "#define " + h : "",
    m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
    m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
    m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoat ? "#define USE_CLEARCOAT" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.dispersion ? "#define USE_DISPERSION" : "",
    n.iridescence ? "#define USE_IRIDESCENCE" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaTest ? "#define USE_ALPHATEST" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== or ? "#define TONE_MAPPING" : "",
    n.toneMapping !== or ? Et.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== or ? $C("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    n.opaque ? "#define OPAQUE" : "",
    Et.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    HC("linearToOutputTexel", n.outputColorSpace),
    WC(),
    n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(ka).join(`
`)), a = qh(a), a = Hm(a, n), a = $m(a, n), l = qh(l), l = Hm(l, n), l = $m(l, n), a = Wm(a), l = Wm(l), n.isRawShaderMaterial !== !0 && (M = `#version 300 es
`, g = [
    p,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + g, x = [
    "#define varying in",
    n.glslVersion === sm ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    n.glslVersion === sm ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + x);
  const S = M + g + a, b = M + x + l, C = Bm(r, r.VERTEX_SHADER, S), T = Bm(r, r.FRAGMENT_SHADER, b);
  r.attachShader(_, C), r.attachShader(_, T), n.index0AttributeName !== void 0 ? r.bindAttribLocation(_, 0, n.index0AttributeName) : n.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"), r.linkProgram(_);
  function P(D) {
    if (s.debug.checkShaderErrors) {
      const U = r.getProgramInfoLog(_).trim(), R = r.getShaderInfoLog(C).trim(), O = r.getShaderInfoLog(T).trim();
      let A = !0, G = !0;
      if (r.getProgramParameter(_, r.LINK_STATUS) === !1)
        if (A = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(r, _, C, T);
        else {
          const ue = Gm(r, C, "vertex"), Q = Gm(r, T, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(_, r.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + U + `
` + ue + `
` + Q
          );
        }
      else U !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", U) : (R === "" || O === "") && (G = !1);
      G && (D.diagnostics = {
        runnable: A,
        programLog: U,
        vertexShader: {
          log: R,
          prefix: g
        },
        fragmentShader: {
          log: O,
          prefix: x
        }
      });
    }
    r.deleteShader(C), r.deleteShader(T), E = new Nc(r, _), y = YC(r, _);
  }
  let E;
  this.getUniforms = function() {
    return E === void 0 && P(this), E;
  };
  let y;
  this.getAttributes = function() {
    return y === void 0 && P(this), y;
  };
  let w = n.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return w === !1 && (w = r.getProgramParameter(_, NC)), w;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(_), this.program = void 0;
  }, this.type = n.shaderType, this.name = n.shaderName, this.id = BC++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = T, this;
}
let o2 = 0;
class a2 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const n = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(n), o = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
    return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(o) === !1 && (a.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let i = n.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let i = n.get(e);
    return i === void 0 && (i = new l2(e), n.set(e, i)), i;
  }
}
class l2 {
  constructor(e) {
    this.id = o2++, this.code = e, this.usedTimes = 0;
  }
}
function c2(s, e, n, i, r, o, a) {
  const l = new Ff(), c = new a2(), u = /* @__PURE__ */ new Set(), d = [], h = r.logarithmicDepthBuffer, m = r.vertexTextures;
  let p = r.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function _(y) {
    return u.add(y), y === 0 ? "uv" : `uv${y}`;
  }
  function g(y, w, D, U, R) {
    const O = U.fog, A = R.geometry, G = y.isMeshStandardMaterial ? U.environment : null, ue = (y.isMeshStandardMaterial ? n : e).get(y.envMap || G), Q = ue && ue.mapping === Tu ? ue.image.height : null, le = v[y.type];
    y.precision !== null && (p = r.getMaxPrecision(y.precision), p !== y.precision && console.warn("THREE.WebGLProgram.getParameters:", y.precision, "not supported, using", p, "instead."));
    const re = A.morphAttributes.position || A.morphAttributes.normal || A.morphAttributes.color, j = re !== void 0 ? re.length : 0;
    let $ = 0;
    A.morphAttributes.position !== void 0 && ($ = 1), A.morphAttributes.normal !== void 0 && ($ = 2), A.morphAttributes.color !== void 0 && ($ = 3);
    let q, oe, ie, ce;
    if (le) {
      const pt = ss[le];
      q = pt.vertexShader, oe = pt.fragmentShader;
    } else
      q = y.vertexShader, oe = y.fragmentShader, c.update(y), ie = c.getVertexShaderID(y), ce = c.getFragmentShaderID(y);
    const V = s.getRenderTarget(), Y = s.state.buffers.depth.getReversed(), H = R.isInstancedMesh === !0, I = R.isBatchedMesh === !0, F = !!y.map, L = !!y.matcap, ee = !!ue, Z = !!y.aoMap, k = !!y.lightMap, ne = !!y.bumpMap, J = !!y.normalMap, B = !!y.displacementMap, X = !!y.emissiveMap, se = !!y.metalnessMap, z = !!y.roughnessMap, N = y.anisotropy > 0, K = y.clearcoat > 0, he = y.dispersion > 0, me = y.iridescence > 0, ge = y.sheen > 0, Me = y.transmission > 0, Ee = N && !!y.anisotropyMap, Ae = K && !!y.clearcoatMap, Xe = K && !!y.clearcoatNormalMap, Oe = K && !!y.clearcoatRoughnessMap, He = me && !!y.iridescenceMap, Ye = me && !!y.iridescenceThicknessMap, $e = ge && !!y.sheenColorMap, Le = ge && !!y.sheenRoughnessMap, nt = !!y.specularMap, Je = !!y.specularColorMap, bt = !!y.specularIntensityMap, Se = Me && !!y.transmissionMap, Ne = Me && !!y.thicknessMap, Re = !!y.gradientMap, Be = !!y.alphaMap, je = y.alphaTest > 0, Ge = !!y.alphaHash, ut = !!y.extensions;
    let at = or;
    y.toneMapped && (V === null || V.isXRRenderTarget === !0) && (at = s.toneMapping);
    const dt = {
      shaderID: le,
      shaderType: y.type,
      shaderName: y.name,
      vertexShader: q,
      fragmentShader: oe,
      defines: y.defines,
      customVertexShaderID: ie,
      customFragmentShaderID: ce,
      isRawShaderMaterial: y.isRawShaderMaterial === !0,
      glslVersion: y.glslVersion,
      precision: p,
      batching: I,
      batchingColor: I && R._colorsTexture !== null,
      instancing: H,
      instancingColor: H && R.instanceColor !== null,
      instancingMorph: H && R.morphTexture !== null,
      supportsVertexTextures: m,
      outputColorSpace: V === null ? s.outputColorSpace : V.isXRRenderTarget === !0 ? V.texture.colorSpace : Jo,
      alphaToCoverage: !!y.alphaToCoverage,
      map: F,
      matcap: L,
      envMap: ee,
      envMapMode: ee && ue.mapping,
      envMapCubeUVHeight: Q,
      aoMap: Z,
      lightMap: k,
      bumpMap: ne,
      normalMap: J,
      displacementMap: m && B,
      emissiveMap: X,
      normalMapObjectSpace: J && y.normalMapType === ib,
      normalMapTangentSpace: J && y.normalMapType === kf,
      metalnessMap: se,
      roughnessMap: z,
      anisotropy: N,
      anisotropyMap: Ee,
      clearcoat: K,
      clearcoatMap: Ae,
      clearcoatNormalMap: Xe,
      clearcoatRoughnessMap: Oe,
      dispersion: he,
      iridescence: me,
      iridescenceMap: He,
      iridescenceThicknessMap: Ye,
      sheen: ge,
      sheenColorMap: $e,
      sheenRoughnessMap: Le,
      specularMap: nt,
      specularColorMap: Je,
      specularIntensityMap: bt,
      transmission: Me,
      transmissionMap: Se,
      thicknessMap: Ne,
      gradientMap: Re,
      opaque: y.transparent === !1 && y.blending === Hi && y.alphaToCoverage === !1,
      alphaMap: Be,
      alphaTest: je,
      alphaHash: Ge,
      combine: y.combine,
      //
      mapUv: F && _(y.map.channel),
      aoMapUv: Z && _(y.aoMap.channel),
      lightMapUv: k && _(y.lightMap.channel),
      bumpMapUv: ne && _(y.bumpMap.channel),
      normalMapUv: J && _(y.normalMap.channel),
      displacementMapUv: B && _(y.displacementMap.channel),
      emissiveMapUv: X && _(y.emissiveMap.channel),
      metalnessMapUv: se && _(y.metalnessMap.channel),
      roughnessMapUv: z && _(y.roughnessMap.channel),
      anisotropyMapUv: Ee && _(y.anisotropyMap.channel),
      clearcoatMapUv: Ae && _(y.clearcoatMap.channel),
      clearcoatNormalMapUv: Xe && _(y.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Oe && _(y.clearcoatRoughnessMap.channel),
      iridescenceMapUv: He && _(y.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ye && _(y.iridescenceThicknessMap.channel),
      sheenColorMapUv: $e && _(y.sheenColorMap.channel),
      sheenRoughnessMapUv: Le && _(y.sheenRoughnessMap.channel),
      specularMapUv: nt && _(y.specularMap.channel),
      specularColorMapUv: Je && _(y.specularColorMap.channel),
      specularIntensityMapUv: bt && _(y.specularIntensityMap.channel),
      transmissionMapUv: Se && _(y.transmissionMap.channel),
      thicknessMapUv: Ne && _(y.thicknessMap.channel),
      alphaMapUv: Be && _(y.alphaMap.channel),
      //
      vertexTangents: !!A.attributes.tangent && (J || N),
      vertexColors: y.vertexColors,
      vertexAlphas: y.vertexColors === !0 && !!A.attributes.color && A.attributes.color.itemSize === 4,
      pointsUvs: R.isPoints === !0 && !!A.attributes.uv && (F || Be),
      fog: !!O,
      useFog: y.fog === !0,
      fogExp2: !!O && O.isFogExp2,
      flatShading: y.flatShading === !0,
      sizeAttenuation: y.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reverseDepthBuffer: Y,
      skinning: R.isSkinnedMesh === !0,
      morphTargets: A.morphAttributes.position !== void 0,
      morphNormals: A.morphAttributes.normal !== void 0,
      morphColors: A.morphAttributes.color !== void 0,
      morphTargetsCount: j,
      morphTextureStride: $,
      numDirLights: w.directional.length,
      numPointLights: w.point.length,
      numSpotLights: w.spot.length,
      numSpotLightMaps: w.spotLightMap.length,
      numRectAreaLights: w.rectArea.length,
      numHemiLights: w.hemi.length,
      numDirLightShadows: w.directionalShadowMap.length,
      numPointLightShadows: w.pointShadowMap.length,
      numSpotLightShadows: w.spotShadowMap.length,
      numSpotLightShadowsWithMaps: w.numSpotLightShadowsWithMaps,
      numLightProbes: w.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: y.dithering,
      shadowMapEnabled: s.shadowMap.enabled && D.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: at,
      decodeVideoTexture: F && y.map.isVideoTexture === !0 && It.getTransfer(y.map.colorSpace) === qt,
      decodeVideoTextureEmissive: X && y.emissiveMap.isVideoTexture === !0 && It.getTransfer(y.emissiveMap.colorSpace) === qt,
      premultipliedAlpha: y.premultipliedAlpha,
      doubleSided: y.side === vn,
      flipSided: y.side === hi,
      useDepthPacking: y.depthPacking >= 0,
      depthPacking: y.depthPacking || 0,
      index0AttributeName: y.index0AttributeName,
      extensionClipCullDistance: ut && y.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (ut && y.extensions.multiDraw === !0 || I) && i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: y.customProgramCacheKey()
    };
    return dt.vertexUv1s = u.has(1), dt.vertexUv2s = u.has(2), dt.vertexUv3s = u.has(3), u.clear(), dt;
  }
  function x(y) {
    const w = [];
    if (y.shaderID ? w.push(y.shaderID) : (w.push(y.customVertexShaderID), w.push(y.customFragmentShaderID)), y.defines !== void 0)
      for (const D in y.defines)
        w.push(D), w.push(y.defines[D]);
    return y.isRawShaderMaterial === !1 && (M(w, y), S(w, y), w.push(s.outputColorSpace)), w.push(y.customProgramCacheKey), w.join();
  }
  function M(y, w) {
    y.push(w.precision), y.push(w.outputColorSpace), y.push(w.envMapMode), y.push(w.envMapCubeUVHeight), y.push(w.mapUv), y.push(w.alphaMapUv), y.push(w.lightMapUv), y.push(w.aoMapUv), y.push(w.bumpMapUv), y.push(w.normalMapUv), y.push(w.displacementMapUv), y.push(w.emissiveMapUv), y.push(w.metalnessMapUv), y.push(w.roughnessMapUv), y.push(w.anisotropyMapUv), y.push(w.clearcoatMapUv), y.push(w.clearcoatNormalMapUv), y.push(w.clearcoatRoughnessMapUv), y.push(w.iridescenceMapUv), y.push(w.iridescenceThicknessMapUv), y.push(w.sheenColorMapUv), y.push(w.sheenRoughnessMapUv), y.push(w.specularMapUv), y.push(w.specularColorMapUv), y.push(w.specularIntensityMapUv), y.push(w.transmissionMapUv), y.push(w.thicknessMapUv), y.push(w.combine), y.push(w.fogExp2), y.push(w.sizeAttenuation), y.push(w.morphTargetsCount), y.push(w.morphAttributeCount), y.push(w.numDirLights), y.push(w.numPointLights), y.push(w.numSpotLights), y.push(w.numSpotLightMaps), y.push(w.numHemiLights), y.push(w.numRectAreaLights), y.push(w.numDirLightShadows), y.push(w.numPointLightShadows), y.push(w.numSpotLightShadows), y.push(w.numSpotLightShadowsWithMaps), y.push(w.numLightProbes), y.push(w.shadowMapType), y.push(w.toneMapping), y.push(w.numClippingPlanes), y.push(w.numClipIntersection), y.push(w.depthPacking);
  }
  function S(y, w) {
    l.disableAll(), w.supportsVertexTextures && l.enable(0), w.instancing && l.enable(1), w.instancingColor && l.enable(2), w.instancingMorph && l.enable(3), w.matcap && l.enable(4), w.envMap && l.enable(5), w.normalMapObjectSpace && l.enable(6), w.normalMapTangentSpace && l.enable(7), w.clearcoat && l.enable(8), w.iridescence && l.enable(9), w.alphaTest && l.enable(10), w.vertexColors && l.enable(11), w.vertexAlphas && l.enable(12), w.vertexUv1s && l.enable(13), w.vertexUv2s && l.enable(14), w.vertexUv3s && l.enable(15), w.vertexTangents && l.enable(16), w.anisotropy && l.enable(17), w.alphaHash && l.enable(18), w.batching && l.enable(19), w.dispersion && l.enable(20), w.batchingColor && l.enable(21), y.push(l.mask), l.disableAll(), w.fog && l.enable(0), w.useFog && l.enable(1), w.flatShading && l.enable(2), w.logarithmicDepthBuffer && l.enable(3), w.reverseDepthBuffer && l.enable(4), w.skinning && l.enable(5), w.morphTargets && l.enable(6), w.morphNormals && l.enable(7), w.morphColors && l.enable(8), w.premultipliedAlpha && l.enable(9), w.shadowMapEnabled && l.enable(10), w.doubleSided && l.enable(11), w.flipSided && l.enable(12), w.useDepthPacking && l.enable(13), w.dithering && l.enable(14), w.transmission && l.enable(15), w.sheen && l.enable(16), w.opaque && l.enable(17), w.pointsUvs && l.enable(18), w.decodeVideoTexture && l.enable(19), w.decodeVideoTextureEmissive && l.enable(20), w.alphaToCoverage && l.enable(21), y.push(l.mask);
  }
  function b(y) {
    const w = v[y.type];
    let D;
    if (w) {
      const U = ss[w];
      D = Ml.clone(U.uniforms);
    } else
      D = y.uniforms;
    return D;
  }
  function C(y, w) {
    let D;
    for (let U = 0, R = d.length; U < R; U++) {
      const O = d[U];
      if (O.cacheKey === w) {
        D = O, ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && (D = new r2(s, w, y, o), d.push(D)), D;
  }
  function T(y) {
    if (--y.usedTimes === 0) {
      const w = d.indexOf(y);
      d[w] = d[d.length - 1], d.pop(), y.destroy();
    }
  }
  function P(y) {
    c.remove(y);
  }
  function E() {
    c.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: x,
    getUniforms: b,
    acquireProgram: C,
    releaseProgram: T,
    releaseShaderCache: P,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: d,
    dispose: E
  };
}
function u2() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(a) {
    return s.has(a);
  }
  function n(a) {
    let l = s.get(a);
    return l === void 0 && (l = {}, s.set(a, l)), l;
  }
  function i(a) {
    s.delete(a);
  }
  function r(a, l, c) {
    s.get(a)[l] = c;
  }
  function o() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: n,
    remove: i,
    update: r,
    dispose: o
  };
}
function d2(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function jm(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function Ym() {
  const s = [];
  let e = 0;
  const n = [], i = [], r = [];
  function o() {
    e = 0, n.length = 0, i.length = 0, r.length = 0;
  }
  function a(h, m, p, v, _, g) {
    let x = s[e];
    return x === void 0 ? (x = {
      id: h.id,
      object: h,
      geometry: m,
      material: p,
      groupOrder: v,
      renderOrder: h.renderOrder,
      z: _,
      group: g
    }, s[e] = x) : (x.id = h.id, x.object = h, x.geometry = m, x.material = p, x.groupOrder = v, x.renderOrder = h.renderOrder, x.z = _, x.group = g), e++, x;
  }
  function l(h, m, p, v, _, g) {
    const x = a(h, m, p, v, _, g);
    p.transmission > 0 ? i.push(x) : p.transparent === !0 ? r.push(x) : n.push(x);
  }
  function c(h, m, p, v, _, g) {
    const x = a(h, m, p, v, _, g);
    p.transmission > 0 ? i.unshift(x) : p.transparent === !0 ? r.unshift(x) : n.unshift(x);
  }
  function u(h, m) {
    n.length > 1 && n.sort(h || d2), i.length > 1 && i.sort(m || jm), r.length > 1 && r.sort(m || jm);
  }
  function d() {
    for (let h = e, m = s.length; h < m; h++) {
      const p = s[h];
      if (p.id === null) break;
      p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: r,
    init: o,
    push: l,
    unshift: c,
    finish: d,
    sort: u
  };
}
function h2() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(i, r) {
    const o = s.get(i);
    let a;
    return o === void 0 ? (a = new Ym(), s.set(i, [a])) : r >= o.length ? (a = new Ym(), o.push(a)) : a = o[r], a;
  }
  function n() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
function f2() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new de(),
            color: new Mt()
          };
          break;
        case "SpotLight":
          n = {
            position: new de(),
            direction: new de(),
            color: new Mt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new de(),
            color: new Mt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new de(),
            skyColor: new Mt(),
            groundColor: new Mt()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Mt(),
            position: new de(),
            halfWidth: new de(),
            halfHeight: new de()
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
function p2() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new rt()
          };
          break;
        case "SpotLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new rt()
          };
          break;
        case "PointLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new rt(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
let m2 = 0;
function v2(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function g2(s) {
  const e = new f2(), n = p2(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++) i.probe.push(new de());
  const r = new de(), o = new Zt(), a = new Zt();
  function l(u) {
    let d = 0, h = 0, m = 0;
    for (let y = 0; y < 9; y++) i.probe[y].set(0, 0, 0);
    let p = 0, v = 0, _ = 0, g = 0, x = 0, M = 0, S = 0, b = 0, C = 0, T = 0, P = 0;
    u.sort(v2);
    for (let y = 0, w = u.length; y < w; y++) {
      const D = u[y], U = D.color, R = D.intensity, O = D.distance, A = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        d += U.r * R, h += U.g * R, m += U.b * R;
      else if (D.isLightProbe) {
        for (let G = 0; G < 9; G++)
          i.probe[G].addScaledVector(D.sh.coefficients[G], R);
        P++;
      } else if (D.isDirectionalLight) {
        const G = e.get(D);
        if (G.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow) {
          const ue = D.shadow, Q = n.get(D);
          Q.shadowIntensity = ue.intensity, Q.shadowBias = ue.bias, Q.shadowNormalBias = ue.normalBias, Q.shadowRadius = ue.radius, Q.shadowMapSize = ue.mapSize, i.directionalShadow[p] = Q, i.directionalShadowMap[p] = A, i.directionalShadowMatrix[p] = D.shadow.matrix, M++;
        }
        i.directional[p] = G, p++;
      } else if (D.isSpotLight) {
        const G = e.get(D);
        G.position.setFromMatrixPosition(D.matrixWorld), G.color.copy(U).multiplyScalar(R), G.distance = O, G.coneCos = Math.cos(D.angle), G.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), G.decay = D.decay, i.spot[_] = G;
        const ue = D.shadow;
        if (D.map && (i.spotLightMap[C] = D.map, C++, ue.updateMatrices(D), D.castShadow && T++), i.spotLightMatrix[_] = ue.matrix, D.castShadow) {
          const Q = n.get(D);
          Q.shadowIntensity = ue.intensity, Q.shadowBias = ue.bias, Q.shadowNormalBias = ue.normalBias, Q.shadowRadius = ue.radius, Q.shadowMapSize = ue.mapSize, i.spotShadow[_] = Q, i.spotShadowMap[_] = A, b++;
        }
        _++;
      } else if (D.isRectAreaLight) {
        const G = e.get(D);
        G.color.copy(U).multiplyScalar(R), G.halfWidth.set(D.width * 0.5, 0, 0), G.halfHeight.set(0, D.height * 0.5, 0), i.rectArea[g] = G, g++;
      } else if (D.isPointLight) {
        const G = e.get(D);
        if (G.color.copy(D.color).multiplyScalar(D.intensity), G.distance = D.distance, G.decay = D.decay, D.castShadow) {
          const ue = D.shadow, Q = n.get(D);
          Q.shadowIntensity = ue.intensity, Q.shadowBias = ue.bias, Q.shadowNormalBias = ue.normalBias, Q.shadowRadius = ue.radius, Q.shadowMapSize = ue.mapSize, Q.shadowCameraNear = ue.camera.near, Q.shadowCameraFar = ue.camera.far, i.pointShadow[v] = Q, i.pointShadowMap[v] = A, i.pointShadowMatrix[v] = D.shadow.matrix, S++;
        }
        i.point[v] = G, v++;
      } else if (D.isHemisphereLight) {
        const G = e.get(D);
        G.skyColor.copy(D.color).multiplyScalar(R), G.groundColor.copy(D.groundColor).multiplyScalar(R), i.hemi[x] = G, x++;
      }
    }
    g > 0 && (s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = tt.LTC_FLOAT_1, i.rectAreaLTC2 = tt.LTC_FLOAT_2) : (i.rectAreaLTC1 = tt.LTC_HALF_1, i.rectAreaLTC2 = tt.LTC_HALF_2)), i.ambient[0] = d, i.ambient[1] = h, i.ambient[2] = m;
    const E = i.hash;
    (E.directionalLength !== p || E.pointLength !== v || E.spotLength !== _ || E.rectAreaLength !== g || E.hemiLength !== x || E.numDirectionalShadows !== M || E.numPointShadows !== S || E.numSpotShadows !== b || E.numSpotMaps !== C || E.numLightProbes !== P) && (i.directional.length = p, i.spot.length = _, i.rectArea.length = g, i.point.length = v, i.hemi.length = x, i.directionalShadow.length = M, i.directionalShadowMap.length = M, i.pointShadow.length = S, i.pointShadowMap.length = S, i.spotShadow.length = b, i.spotShadowMap.length = b, i.directionalShadowMatrix.length = M, i.pointShadowMatrix.length = S, i.spotLightMatrix.length = b + C - T, i.spotLightMap.length = C, i.numSpotLightShadowsWithMaps = T, i.numLightProbes = P, E.directionalLength = p, E.pointLength = v, E.spotLength = _, E.rectAreaLength = g, E.hemiLength = x, E.numDirectionalShadows = M, E.numPointShadows = S, E.numSpotShadows = b, E.numSpotMaps = C, E.numLightProbes = P, i.version = m2++);
  }
  function c(u, d) {
    let h = 0, m = 0, p = 0, v = 0, _ = 0;
    const g = d.matrixWorldInverse;
    for (let x = 0, M = u.length; x < M; x++) {
      const S = u[x];
      if (S.isDirectionalLight) {
        const b = i.directional[h];
        b.direction.setFromMatrixPosition(S.matrixWorld), r.setFromMatrixPosition(S.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(g), h++;
      } else if (S.isSpotLight) {
        const b = i.spot[p];
        b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(g), b.direction.setFromMatrixPosition(S.matrixWorld), r.setFromMatrixPosition(S.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(g), p++;
      } else if (S.isRectAreaLight) {
        const b = i.rectArea[v];
        b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(g), a.identity(), o.copy(S.matrixWorld), o.premultiply(g), a.extractRotation(o), b.halfWidth.set(S.width * 0.5, 0, 0), b.halfHeight.set(0, S.height * 0.5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), v++;
      } else if (S.isPointLight) {
        const b = i.point[m];
        b.position.setFromMatrixPosition(S.matrixWorld), b.position.applyMatrix4(g), m++;
      } else if (S.isHemisphereLight) {
        const b = i.hemi[_];
        b.direction.setFromMatrixPosition(S.matrixWorld), b.direction.transformDirection(g), _++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: i
  };
}
function qm(s) {
  const e = new g2(s), n = [], i = [];
  function r(d) {
    u.camera = d, n.length = 0, i.length = 0;
  }
  function o(d) {
    n.push(d);
  }
  function a(d) {
    i.push(d);
  }
  function l() {
    e.setup(n);
  }
  function c(d) {
    e.setupView(n, d);
  }
  const u = {
    lightsArray: n,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: r,
    state: u,
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a
  };
}
function y2(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(r, o = 0) {
    const a = e.get(r);
    let l;
    return a === void 0 ? (l = new qm(s), e.set(r, [l])) : o >= a.length ? (l = new qm(s), a.push(l)) : l = a[o], l;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class Nf extends qr {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = nb, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class py extends qr {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const x2 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, _2 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function b2(s, e, n) {
  let i = new Uf();
  const r = new rt(), o = new rt(), a = new jt(), l = new Nf({ depthPacking: Df }), c = new py(), u = {}, d = n.maxTextureSize, h = { [ar]: hi, [hi]: ar, [vn]: vn }, m = new zn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new rt() },
      radius: { value: 4 }
    },
    vertexShader: x2,
    fragmentShader: _2
  }), p = m.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const v = new Vt();
  v.setAttribute(
    "position",
    new Si(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const _ = new Ze(v, m), g = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = D0;
  let x = this.type;
  this.render = function(T, P, E) {
    if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || T.length === 0) return;
    const y = s.getRenderTarget(), w = s.getActiveCubeFace(), D = s.getActiveMipmapLevel(), U = s.state;
    U.setBlending(os), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1);
    const R = x !== _s && this.type === _s, O = x === _s && this.type !== _s;
    for (let A = 0, G = T.length; A < G; A++) {
      const ue = T[A], Q = ue.shadow;
      if (Q === void 0) {
        console.warn("THREE.WebGLShadowMap:", ue, "has no shadow.");
        continue;
      }
      if (Q.autoUpdate === !1 && Q.needsUpdate === !1) continue;
      r.copy(Q.mapSize);
      const le = Q.getFrameExtents();
      if (r.multiply(le), o.copy(Q.mapSize), (r.x > d || r.y > d) && (r.x > d && (o.x = Math.floor(d / le.x), r.x = o.x * le.x, Q.mapSize.x = o.x), r.y > d && (o.y = Math.floor(d / le.y), r.y = o.y * le.y, Q.mapSize.y = o.y)), Q.map === null || R === !0 || O === !0) {
        const j = this.type !== _s ? { minFilter: On, magFilter: On } : {};
        Q.map !== null && Q.map.dispose(), Q.map = new Ri(r.x, r.y, j), Q.map.texture.name = ue.name + ".shadowMap", Q.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(Q.map), s.clear();
      const re = Q.getViewportCount();
      for (let j = 0; j < re; j++) {
        const $ = Q.getViewport(j);
        a.set(
          o.x * $.x,
          o.y * $.y,
          o.x * $.z,
          o.y * $.w
        ), U.viewport(a), Q.updateMatrices(ue, j), i = Q.getFrustum(), b(P, E, Q.camera, ue, this.type);
      }
      Q.isPointLightShadow !== !0 && this.type === _s && M(Q, E), Q.needsUpdate = !1;
    }
    x = this.type, g.needsUpdate = !1, s.setRenderTarget(y, w, D);
  };
  function M(T, P) {
    const E = e.update(_);
    m.defines.VSM_SAMPLES !== T.blurSamples && (m.defines.VSM_SAMPLES = T.blurSamples, p.defines.VSM_SAMPLES = T.blurSamples, m.needsUpdate = !0, p.needsUpdate = !0), T.mapPass === null && (T.mapPass = new Ri(r.x, r.y)), m.uniforms.shadow_pass.value = T.map.texture, m.uniforms.resolution.value = T.mapSize, m.uniforms.radius.value = T.radius, s.setRenderTarget(T.mapPass), s.clear(), s.renderBufferDirect(P, null, E, m, _, null), p.uniforms.shadow_pass.value = T.mapPass.texture, p.uniforms.resolution.value = T.mapSize, p.uniforms.radius.value = T.radius, s.setRenderTarget(T.map), s.clear(), s.renderBufferDirect(P, null, E, p, _, null);
  }
  function S(T, P, E, y) {
    let w = null;
    const D = E.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
    if (D !== void 0)
      w = D;
    else if (w = E.isPointLight === !0 ? c : l, s.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
      const U = w.uuid, R = P.uuid;
      let O = u[U];
      O === void 0 && (O = {}, u[U] = O);
      let A = O[R];
      A === void 0 && (A = w.clone(), O[R] = A, P.addEventListener("dispose", C)), w = A;
    }
    if (w.visible = P.visible, w.wireframe = P.wireframe, y === _s ? w.side = P.shadowSide !== null ? P.shadowSide : P.side : w.side = P.shadowSide !== null ? P.shadowSide : h[P.side], w.alphaMap = P.alphaMap, w.alphaTest = P.alphaTest, w.map = P.map, w.clipShadows = P.clipShadows, w.clippingPlanes = P.clippingPlanes, w.clipIntersection = P.clipIntersection, w.displacementMap = P.displacementMap, w.displacementScale = P.displacementScale, w.displacementBias = P.displacementBias, w.wireframeLinewidth = P.wireframeLinewidth, w.linewidth = P.linewidth, E.isPointLight === !0 && w.isMeshDistanceMaterial === !0) {
      const U = s.properties.get(w);
      U.light = E;
    }
    return w;
  }
  function b(T, P, E, y, w) {
    if (T.visible === !1) return;
    if (T.layers.test(P.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && w === _s) && (!T.frustumCulled || i.intersectsObject(T))) {
      T.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, T.matrixWorld);
      const R = e.update(T), O = T.material;
      if (Array.isArray(O)) {
        const A = R.groups;
        for (let G = 0, ue = A.length; G < ue; G++) {
          const Q = A[G], le = O[Q.materialIndex];
          if (le && le.visible) {
            const re = S(T, le, y, w);
            T.onBeforeShadow(s, T, P, E, R, re, Q), s.renderBufferDirect(E, null, R, re, T, Q), T.onAfterShadow(s, T, P, E, R, re, Q);
          }
        }
      } else if (O.visible) {
        const A = S(T, O, y, w);
        T.onBeforeShadow(s, T, P, E, R, A, null), s.renderBufferDirect(E, null, R, A, T, null), T.onAfterShadow(s, T, P, E, R, A, null);
      }
    }
    const U = T.children;
    for (let R = 0, O = U.length; R < O; R++)
      b(U[R], P, E, y, w);
  }
  function C(T) {
    T.target.removeEventListener("dispose", C);
    for (const E in u) {
      const y = u[E], w = T.target.uuid;
      w in y && (y[w].dispose(), delete y[w]);
    }
  }
}
const w2 = {
  [hh]: fh,
  [ph]: gh,
  [mh]: yh,
  [Vo]: vh,
  [fh]: hh,
  [gh]: ph,
  [yh]: mh,
  [vh]: Vo
};
function S2(s, e) {
  function n() {
    let Se = !1;
    const Ne = new jt();
    let Re = null;
    const Be = new jt(0, 0, 0, 0);
    return {
      setMask: function(je) {
        Re !== je && !Se && (s.colorMask(je, je, je, je), Re = je);
      },
      setLocked: function(je) {
        Se = je;
      },
      setClear: function(je, Ge, ut, at, dt) {
        dt === !0 && (je *= at, Ge *= at, ut *= at), Ne.set(je, Ge, ut, at), Be.equals(Ne) === !1 && (s.clearColor(je, Ge, ut, at), Be.copy(Ne));
      },
      reset: function() {
        Se = !1, Re = null, Be.set(-1, 0, 0, 0);
      }
    };
  }
  function i() {
    let Se = !1, Ne = !1, Re = null, Be = null, je = null;
    return {
      setReversed: function(Ge) {
        if (Ne !== Ge) {
          const ut = e.get("EXT_clip_control");
          Ne ? ut.clipControlEXT(ut.LOWER_LEFT_EXT, ut.ZERO_TO_ONE_EXT) : ut.clipControlEXT(ut.LOWER_LEFT_EXT, ut.NEGATIVE_ONE_TO_ONE_EXT);
          const at = je;
          je = null, this.setClear(at);
        }
        Ne = Ge;
      },
      getReversed: function() {
        return Ne;
      },
      setTest: function(Ge) {
        Ge ? V(s.DEPTH_TEST) : Y(s.DEPTH_TEST);
      },
      setMask: function(Ge) {
        Re !== Ge && !Se && (s.depthMask(Ge), Re = Ge);
      },
      setFunc: function(Ge) {
        if (Ne && (Ge = w2[Ge]), Be !== Ge) {
          switch (Ge) {
            case hh:
              s.depthFunc(s.NEVER);
              break;
            case fh:
              s.depthFunc(s.ALWAYS);
              break;
            case ph:
              s.depthFunc(s.LESS);
              break;
            case Vo:
              s.depthFunc(s.LEQUAL);
              break;
            case mh:
              s.depthFunc(s.EQUAL);
              break;
            case vh:
              s.depthFunc(s.GEQUAL);
              break;
            case gh:
              s.depthFunc(s.GREATER);
              break;
            case yh:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Be = Ge;
        }
      },
      setLocked: function(Ge) {
        Se = Ge;
      },
      setClear: function(Ge) {
        je !== Ge && (Ne && (Ge = 1 - Ge), s.clearDepth(Ge), je = Ge);
      },
      reset: function() {
        Se = !1, Re = null, Be = null, je = null, Ne = !1;
      }
    };
  }
  function r() {
    let Se = !1, Ne = null, Re = null, Be = null, je = null, Ge = null, ut = null, at = null, dt = null;
    return {
      setTest: function(pt) {
        Se || (pt ? V(s.STENCIL_TEST) : Y(s.STENCIL_TEST));
      },
      setMask: function(pt) {
        Ne !== pt && !Se && (s.stencilMask(pt), Ne = pt);
      },
      setFunc: function(pt, zt, Kt) {
        (Re !== pt || Be !== zt || je !== Kt) && (s.stencilFunc(pt, zt, Kt), Re = pt, Be = zt, je = Kt);
      },
      setOp: function(pt, zt, Kt) {
        (Ge !== pt || ut !== zt || at !== Kt) && (s.stencilOp(pt, zt, Kt), Ge = pt, ut = zt, at = Kt);
      },
      setLocked: function(pt) {
        Se = pt;
      },
      setClear: function(pt) {
        dt !== pt && (s.clearStencil(pt), dt = pt);
      },
      reset: function() {
        Se = !1, Ne = null, Re = null, Be = null, je = null, Ge = null, ut = null, at = null, dt = null;
      }
    };
  }
  const o = new n(), a = new i(), l = new r(), c = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, h = {}, m = /* @__PURE__ */ new WeakMap(), p = [], v = null, _ = !1, g = null, x = null, M = null, S = null, b = null, C = null, T = null, P = new Mt(0, 0, 0), E = 0, y = !1, w = null, D = null, U = null, R = null, O = null;
  const A = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let G = !1, ue = 0;
  const Q = s.getParameter(s.VERSION);
  Q.indexOf("WebGL") !== -1 ? (ue = parseFloat(/^WebGL (\d)/.exec(Q)[1]), G = ue >= 1) : Q.indexOf("OpenGL ES") !== -1 && (ue = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), G = ue >= 2);
  let le = null, re = {};
  const j = s.getParameter(s.SCISSOR_BOX), $ = s.getParameter(s.VIEWPORT), q = new jt().fromArray(j), oe = new jt().fromArray($);
  function ie(Se, Ne, Re, Be) {
    const je = new Uint8Array(4), Ge = s.createTexture();
    s.bindTexture(Se, Ge), s.texParameteri(Se, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(Se, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let ut = 0; ut < Re; ut++)
      Se === s.TEXTURE_3D || Se === s.TEXTURE_2D_ARRAY ? s.texImage3D(Ne, 0, s.RGBA, 1, 1, Be, 0, s.RGBA, s.UNSIGNED_BYTE, je) : s.texImage2D(Ne + ut, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, je);
    return Ge;
  }
  const ce = {};
  ce[s.TEXTURE_2D] = ie(s.TEXTURE_2D, s.TEXTURE_2D, 1), ce[s.TEXTURE_CUBE_MAP] = ie(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), ce[s.TEXTURE_2D_ARRAY] = ie(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), ce[s.TEXTURE_3D] = ie(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), o.setClear(0, 0, 0, 1), a.setClear(1), l.setClear(0), V(s.DEPTH_TEST), a.setFunc(Vo), ne(!1), J(tm), V(s.CULL_FACE), Z(os);
  function V(Se) {
    d[Se] !== !0 && (s.enable(Se), d[Se] = !0);
  }
  function Y(Se) {
    d[Se] !== !1 && (s.disable(Se), d[Se] = !1);
  }
  function H(Se, Ne) {
    return h[Se] !== Ne ? (s.bindFramebuffer(Se, Ne), h[Se] = Ne, Se === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = Ne), Se === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = Ne), !0) : !1;
  }
  function I(Se, Ne) {
    let Re = p, Be = !1;
    if (Se) {
      Re = m.get(Ne), Re === void 0 && (Re = [], m.set(Ne, Re));
      const je = Se.textures;
      if (Re.length !== je.length || Re[0] !== s.COLOR_ATTACHMENT0) {
        for (let Ge = 0, ut = je.length; Ge < ut; Ge++)
          Re[Ge] = s.COLOR_ATTACHMENT0 + Ge;
        Re.length = je.length, Be = !0;
      }
    } else
      Re[0] !== s.BACK && (Re[0] = s.BACK, Be = !0);
    Be && s.drawBuffers(Re);
  }
  function F(Se) {
    return v !== Se ? (s.useProgram(Se), v = Se, !0) : !1;
  }
  const L = {
    [Vi]: s.FUNC_ADD,
    [I0]: s.FUNC_SUBTRACT,
    [V_]: s.FUNC_REVERSE_SUBTRACT
  };
  L[L0] = s.MIN, L[F0] = s.MAX;
  const ee = {
    [G_]: s.ZERO,
    [bs]: s.ONE,
    [H_]: s.SRC_COLOR,
    [eu]: s.SRC_ALPHA,
    [j_]: s.SRC_ALPHA_SATURATE,
    [X_]: s.DST_COLOR,
    [$_]: s.DST_ALPHA,
    [dh]: s.ONE_MINUS_SRC_COLOR,
    [cl]: s.ONE_MINUS_SRC_ALPHA,
    [U0]: s.ONE_MINUS_DST_COLOR,
    [W_]: s.ONE_MINUS_DST_ALPHA,
    [Y_]: s.CONSTANT_COLOR,
    [q_]: s.ONE_MINUS_CONSTANT_COLOR,
    [Z_]: s.CONSTANT_ALPHA,
    [K_]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function Z(Se, Ne, Re, Be, je, Ge, ut, at, dt, pt) {
    if (Se === os) {
      _ === !0 && (Y(s.BLEND), _ = !1);
      return;
    }
    if (_ === !1 && (V(s.BLEND), _ = !0), Se !== kr) {
      if (Se !== g || pt !== y) {
        if ((x !== Vi || b !== Vi) && (s.blendEquation(s.FUNC_ADD), x = Vi, b = Vi), pt)
          switch (Se) {
            case Hi:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case ll:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case uh:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Fo:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Se);
              break;
          }
        else
          switch (Se) {
            case Hi:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case ll:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case uh:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Fo:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Se);
              break;
          }
        M = null, S = null, C = null, T = null, P.set(0, 0, 0), E = 0, g = Se, y = pt;
      }
      return;
    }
    je = je || Ne, Ge = Ge || Re, ut = ut || Be, (Ne !== x || je !== b) && (s.blendEquationSeparate(L[Ne], L[je]), x = Ne, b = je), (Re !== M || Be !== S || Ge !== C || ut !== T) && (s.blendFuncSeparate(ee[Re], ee[Be], ee[Ge], ee[ut]), M = Re, S = Be, C = Ge, T = ut), (at.equals(P) === !1 || dt !== E) && (s.blendColor(at.r, at.g, at.b, dt), P.copy(at), E = dt), g = Se, y = !1;
  }
  function k(Se, Ne) {
    Se.side === vn ? Y(s.CULL_FACE) : V(s.CULL_FACE);
    let Re = Se.side === hi;
    Ne && (Re = !Re), ne(Re), Se.blending === Hi && Se.transparent === !1 ? Z(os) : Z(Se.blending, Se.blendEquation, Se.blendSrc, Se.blendDst, Se.blendEquationAlpha, Se.blendSrcAlpha, Se.blendDstAlpha, Se.blendColor, Se.blendAlpha, Se.premultipliedAlpha), a.setFunc(Se.depthFunc), a.setTest(Se.depthTest), a.setMask(Se.depthWrite), o.setMask(Se.colorWrite);
    const Be = Se.stencilWrite;
    l.setTest(Be), Be && (l.setMask(Se.stencilWriteMask), l.setFunc(Se.stencilFunc, Se.stencilRef, Se.stencilFuncMask), l.setOp(Se.stencilFail, Se.stencilZFail, Se.stencilZPass)), X(Se.polygonOffset, Se.polygonOffsetFactor, Se.polygonOffsetUnits), Se.alphaToCoverage === !0 ? V(s.SAMPLE_ALPHA_TO_COVERAGE) : Y(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ne(Se) {
    w !== Se && (Se ? s.frontFace(s.CW) : s.frontFace(s.CCW), w = Se);
  }
  function J(Se) {
    Se !== N_ ? (V(s.CULL_FACE), Se !== D && (Se === tm ? s.cullFace(s.BACK) : Se === B_ ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Y(s.CULL_FACE), D = Se;
  }
  function B(Se) {
    Se !== U && (G && s.lineWidth(Se), U = Se);
  }
  function X(Se, Ne, Re) {
    Se ? (V(s.POLYGON_OFFSET_FILL), (R !== Ne || O !== Re) && (s.polygonOffset(Ne, Re), R = Ne, O = Re)) : Y(s.POLYGON_OFFSET_FILL);
  }
  function se(Se) {
    Se ? V(s.SCISSOR_TEST) : Y(s.SCISSOR_TEST);
  }
  function z(Se) {
    Se === void 0 && (Se = s.TEXTURE0 + A - 1), le !== Se && (s.activeTexture(Se), le = Se);
  }
  function N(Se, Ne, Re) {
    Re === void 0 && (le === null ? Re = s.TEXTURE0 + A - 1 : Re = le);
    let Be = re[Re];
    Be === void 0 && (Be = { type: void 0, texture: void 0 }, re[Re] = Be), (Be.type !== Se || Be.texture !== Ne) && (le !== Re && (s.activeTexture(Re), le = Re), s.bindTexture(Se, Ne || ce[Se]), Be.type = Se, Be.texture = Ne);
  }
  function K() {
    const Se = re[le];
    Se !== void 0 && Se.type !== void 0 && (s.bindTexture(Se.type, null), Se.type = void 0, Se.texture = void 0);
  }
  function he() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function me() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function ge() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Me() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Ee() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Ae() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Xe() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Oe() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function He() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function Ye() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (Se) {
      console.error("THREE.WebGLState:", Se);
    }
  }
  function $e(Se) {
    q.equals(Se) === !1 && (s.scissor(Se.x, Se.y, Se.z, Se.w), q.copy(Se));
  }
  function Le(Se) {
    oe.equals(Se) === !1 && (s.viewport(Se.x, Se.y, Se.z, Se.w), oe.copy(Se));
  }
  function nt(Se, Ne) {
    let Re = u.get(Ne);
    Re === void 0 && (Re = /* @__PURE__ */ new WeakMap(), u.set(Ne, Re));
    let Be = Re.get(Se);
    Be === void 0 && (Be = s.getUniformBlockIndex(Ne, Se.name), Re.set(Se, Be));
  }
  function Je(Se, Ne) {
    const Be = u.get(Ne).get(Se);
    c.get(Ne) !== Be && (s.uniformBlockBinding(Ne, Be, Se.__bindingPointIndex), c.set(Ne, Be));
  }
  function bt() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), a.setReversed(!1), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), d = {}, le = null, re = {}, h = {}, m = /* @__PURE__ */ new WeakMap(), p = [], v = null, _ = !1, g = null, x = null, M = null, S = null, b = null, C = null, T = null, P = new Mt(0, 0, 0), E = 0, y = !1, w = null, D = null, U = null, R = null, O = null, q.set(0, 0, s.canvas.width, s.canvas.height), oe.set(0, 0, s.canvas.width, s.canvas.height), o.reset(), a.reset(), l.reset();
  }
  return {
    buffers: {
      color: o,
      depth: a,
      stencil: l
    },
    enable: V,
    disable: Y,
    bindFramebuffer: H,
    drawBuffers: I,
    useProgram: F,
    setBlending: Z,
    setMaterial: k,
    setFlipSided: ne,
    setCullFace: J,
    setLineWidth: B,
    setPolygonOffset: X,
    setScissorTest: se,
    activeTexture: z,
    bindTexture: N,
    unbindTexture: K,
    compressedTexImage2D: he,
    compressedTexImage3D: me,
    texImage2D: He,
    texImage3D: Ye,
    updateUBOMapping: nt,
    uniformBlockBinding: Je,
    texStorage2D: Xe,
    texStorage3D: Oe,
    texSubImage2D: ge,
    texSubImage3D: Me,
    compressedTexSubImage2D: Ee,
    compressedTexSubImage3D: Ae,
    scissor: $e,
    viewport: Le,
    reset: bt
  };
}
function Zm(s, e, n, i) {
  const r = M2(i);
  switch (n) {
    case j0:
      return s * e;
    case q0:
      return s * e;
    case Z0:
      return s * e * 2;
    case tu:
      return s * e / r.components * r.byteLength;
    case Af:
      return s * e / r.components * r.byteLength;
    case K0:
      return s * e * 2 / r.components * r.byteLength;
    case Pf:
      return s * e * 2 / r.components * r.byteLength;
    case Y0:
      return s * e * 3 / r.components * r.byteLength;
    case Rn:
      return s * e * 4 / r.components * r.byteLength;
    case Rf:
      return s * e * 4 / r.components * r.byteLength;
    case Lc:
    case Fc:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Uc:
    case Oc:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Mh:
    case Th:
      return Math.max(s, 16) * Math.max(e, 8) / 4;
    case Sh:
    case Ch:
      return Math.max(s, 8) * Math.max(e, 8) / 2;
    case Eh:
    case Ah:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Ph:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Rh:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Dh:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case kh:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Ih:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Lh:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Fh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Uh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Oh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case zh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Nh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Bh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Vh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Gh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Hh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case zc:
    case $h:
    case Wh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case J0:
    case Xh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case jh:
    case Yh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${n} format.`
  );
}
function M2(s) {
  switch (s) {
    case ji:
    case $0:
      return { byteLength: 1, components: 1 };
    case ul:
    case W0:
    case dr:
      return { byteLength: 2, components: 1 };
    case Tf:
    case Ef:
      return { byteLength: 2, components: 4 };
    case Wr:
    case Cf:
    case si:
      return { byteLength: 4, components: 1 };
    case X0:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
function C2(s, e, n, i, r, o, a) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new rt(), d = /* @__PURE__ */ new WeakMap();
  let h;
  const m = /* @__PURE__ */ new WeakMap();
  let p = !1;
  try {
    p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function v(z, N) {
    return p ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(z, N)
    ) : dl("canvas");
  }
  function _(z, N, K) {
    let he = 1;
    const me = se(z);
    if ((me.width > K || me.height > K) && (he = K / Math.max(me.width, me.height)), he < 1)
      if (typeof HTMLImageElement < "u" && z instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && z instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && z instanceof ImageBitmap || typeof VideoFrame < "u" && z instanceof VideoFrame) {
        const ge = Math.floor(he * me.width), Me = Math.floor(he * me.height);
        h === void 0 && (h = v(ge, Me));
        const Ee = N ? v(ge, Me) : h;
        return Ee.width = ge, Ee.height = Me, Ee.getContext("2d").drawImage(z, 0, 0, ge, Me), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + me.width + "x" + me.height + ") to (" + ge + "x" + Me + ")."), Ee;
      } else
        return "data" in z && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + me.width + "x" + me.height + ")."), z;
    return z;
  }
  function g(z) {
    return z.generateMipmaps;
  }
  function x(z) {
    s.generateMipmap(z);
  }
  function M(z) {
    return z.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : z.isWebGL3DRenderTarget ? s.TEXTURE_3D : z.isWebGLArrayRenderTarget || z.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
  }
  function S(z, N, K, he, me = !1) {
    if (z !== null) {
      if (s[z] !== void 0) return s[z];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + z + "'");
    }
    let ge = N;
    if (N === s.RED && (K === s.FLOAT && (ge = s.R32F), K === s.HALF_FLOAT && (ge = s.R16F), K === s.UNSIGNED_BYTE && (ge = s.R8)), N === s.RED_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.R8UI), K === s.UNSIGNED_SHORT && (ge = s.R16UI), K === s.UNSIGNED_INT && (ge = s.R32UI), K === s.BYTE && (ge = s.R8I), K === s.SHORT && (ge = s.R16I), K === s.INT && (ge = s.R32I)), N === s.RG && (K === s.FLOAT && (ge = s.RG32F), K === s.HALF_FLOAT && (ge = s.RG16F), K === s.UNSIGNED_BYTE && (ge = s.RG8)), N === s.RG_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RG8UI), K === s.UNSIGNED_SHORT && (ge = s.RG16UI), K === s.UNSIGNED_INT && (ge = s.RG32UI), K === s.BYTE && (ge = s.RG8I), K === s.SHORT && (ge = s.RG16I), K === s.INT && (ge = s.RG32I)), N === s.RGB_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RGB8UI), K === s.UNSIGNED_SHORT && (ge = s.RGB16UI), K === s.UNSIGNED_INT && (ge = s.RGB32UI), K === s.BYTE && (ge = s.RGB8I), K === s.SHORT && (ge = s.RGB16I), K === s.INT && (ge = s.RGB32I)), N === s.RGBA_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RGBA8UI), K === s.UNSIGNED_SHORT && (ge = s.RGBA16UI), K === s.UNSIGNED_INT && (ge = s.RGBA32UI), K === s.BYTE && (ge = s.RGBA8I), K === s.SHORT && (ge = s.RGBA16I), K === s.INT && (ge = s.RGBA32I)), N === s.RGB && K === s.UNSIGNED_INT_5_9_9_9_REV && (ge = s.RGB9_E5), N === s.RGBA) {
      const Me = me ? Eu : It.getTransfer(he);
      K === s.FLOAT && (ge = s.RGBA32F), K === s.HALF_FLOAT && (ge = s.RGBA16F), K === s.UNSIGNED_BYTE && (ge = Me === qt ? s.SRGB8_ALPHA8 : s.RGBA8), K === s.UNSIGNED_SHORT_4_4_4_4 && (ge = s.RGBA4), K === s.UNSIGNED_SHORT_5_5_5_1 && (ge = s.RGB5_A1);
    }
    return (ge === s.R16F || ge === s.R32F || ge === s.RG16F || ge === s.RG32F || ge === s.RGBA16F || ge === s.RGBA32F) && e.get("EXT_color_buffer_float"), ge;
  }
  function b(z, N) {
    let K;
    return z ? N === null || N === Wr || N === $o ? K = s.DEPTH24_STENCIL8 : N === si ? K = s.DEPTH32F_STENCIL8 : N === ul && (K = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : N === null || N === Wr || N === $o ? K = s.DEPTH_COMPONENT24 : N === si ? K = s.DEPTH_COMPONENT32F : N === ul && (K = s.DEPTH_COMPONENT16), K;
  }
  function C(z, N) {
    return g(z) === !0 || z.isFramebufferTexture && z.minFilter !== On && z.minFilter !== Bt ? Math.log2(Math.max(N.width, N.height)) + 1 : z.mipmaps !== void 0 && z.mipmaps.length > 0 ? z.mipmaps.length : z.isCompressedTexture && Array.isArray(z.image) ? N.mipmaps.length : 1;
  }
  function T(z) {
    const N = z.target;
    N.removeEventListener("dispose", T), E(N), N.isVideoTexture && d.delete(N);
  }
  function P(z) {
    const N = z.target;
    N.removeEventListener("dispose", P), w(N);
  }
  function E(z) {
    const N = i.get(z);
    if (N.__webglInit === void 0) return;
    const K = z.source, he = m.get(K);
    if (he) {
      const me = he[N.__cacheKey];
      me.usedTimes--, me.usedTimes === 0 && y(z), Object.keys(he).length === 0 && m.delete(K);
    }
    i.remove(z);
  }
  function y(z) {
    const N = i.get(z);
    s.deleteTexture(N.__webglTexture);
    const K = z.source, he = m.get(K);
    delete he[N.__cacheKey], a.memory.textures--;
  }
  function w(z) {
    const N = i.get(z);
    if (z.depthTexture && (z.depthTexture.dispose(), i.remove(z.depthTexture)), z.isWebGLCubeRenderTarget)
      for (let he = 0; he < 6; he++) {
        if (Array.isArray(N.__webglFramebuffer[he]))
          for (let me = 0; me < N.__webglFramebuffer[he].length; me++) s.deleteFramebuffer(N.__webglFramebuffer[he][me]);
        else
          s.deleteFramebuffer(N.__webglFramebuffer[he]);
        N.__webglDepthbuffer && s.deleteRenderbuffer(N.__webglDepthbuffer[he]);
      }
    else {
      if (Array.isArray(N.__webglFramebuffer))
        for (let he = 0; he < N.__webglFramebuffer.length; he++) s.deleteFramebuffer(N.__webglFramebuffer[he]);
      else
        s.deleteFramebuffer(N.__webglFramebuffer);
      if (N.__webglDepthbuffer && s.deleteRenderbuffer(N.__webglDepthbuffer), N.__webglMultisampledFramebuffer && s.deleteFramebuffer(N.__webglMultisampledFramebuffer), N.__webglColorRenderbuffer)
        for (let he = 0; he < N.__webglColorRenderbuffer.length; he++)
          N.__webglColorRenderbuffer[he] && s.deleteRenderbuffer(N.__webglColorRenderbuffer[he]);
      N.__webglDepthRenderbuffer && s.deleteRenderbuffer(N.__webglDepthRenderbuffer);
    }
    const K = z.textures;
    for (let he = 0, me = K.length; he < me; he++) {
      const ge = i.get(K[he]);
      ge.__webglTexture && (s.deleteTexture(ge.__webglTexture), a.memory.textures--), i.remove(K[he]);
    }
    i.remove(z);
  }
  let D = 0;
  function U() {
    D = 0;
  }
  function R() {
    const z = D;
    return z >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + z + " texture units while this GPU supports only " + r.maxTextures), D += 1, z;
  }
  function O(z) {
    const N = [];
    return N.push(z.wrapS), N.push(z.wrapT), N.push(z.wrapR || 0), N.push(z.magFilter), N.push(z.minFilter), N.push(z.anisotropy), N.push(z.internalFormat), N.push(z.format), N.push(z.type), N.push(z.generateMipmaps), N.push(z.premultiplyAlpha), N.push(z.flipY), N.push(z.unpackAlignment), N.push(z.colorSpace), N.join();
  }
  function A(z, N) {
    const K = i.get(z);
    if (z.isVideoTexture && B(z), z.isRenderTargetTexture === !1 && z.version > 0 && K.__version !== z.version) {
      const he = z.image;
      if (he === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (he.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        oe(K, z, N);
        return;
      }
    }
    n.bindTexture(s.TEXTURE_2D, K.__webglTexture, s.TEXTURE0 + N);
  }
  function G(z, N) {
    const K = i.get(z);
    if (z.version > 0 && K.__version !== z.version) {
      oe(K, z, N);
      return;
    }
    n.bindTexture(s.TEXTURE_2D_ARRAY, K.__webglTexture, s.TEXTURE0 + N);
  }
  function ue(z, N) {
    const K = i.get(z);
    if (z.version > 0 && K.__version !== z.version) {
      oe(K, z, N);
      return;
    }
    n.bindTexture(s.TEXTURE_3D, K.__webglTexture, s.TEXTURE0 + N);
  }
  function Q(z, N) {
    const K = i.get(z);
    if (z.version > 0 && K.__version !== z.version) {
      ie(K, z, N);
      return;
    }
    n.bindTexture(s.TEXTURE_CUBE_MAP, K.__webglTexture, s.TEXTURE0 + N);
  }
  const le = {
    [bh]: s.REPEAT,
    [Or]: s.CLAMP_TO_EDGE,
    [wh]: s.MIRRORED_REPEAT
  }, re = {
    [On]: s.NEAREST,
    [tb]: s.NEAREST_MIPMAP_NEAREST,
    [Nl]: s.NEAREST_MIPMAP_LINEAR,
    [Bt]: s.LINEAR,
    [id]: s.LINEAR_MIPMAP_NEAREST,
    [zr]: s.LINEAR_MIPMAP_LINEAR
  }, j = {
    [sb]: s.NEVER,
    [ub]: s.ALWAYS,
    [rb]: s.LESS,
    [Q0]: s.LEQUAL,
    [ob]: s.EQUAL,
    [cb]: s.GEQUAL,
    [ab]: s.GREATER,
    [lb]: s.NOTEQUAL
  };
  function $(z, N) {
    if (N.type === si && e.has("OES_texture_float_linear") === !1 && (N.magFilter === Bt || N.magFilter === id || N.magFilter === Nl || N.magFilter === zr || N.minFilter === Bt || N.minFilter === id || N.minFilter === Nl || N.minFilter === zr) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(z, s.TEXTURE_WRAP_S, le[N.wrapS]), s.texParameteri(z, s.TEXTURE_WRAP_T, le[N.wrapT]), (z === s.TEXTURE_3D || z === s.TEXTURE_2D_ARRAY) && s.texParameteri(z, s.TEXTURE_WRAP_R, le[N.wrapR]), s.texParameteri(z, s.TEXTURE_MAG_FILTER, re[N.magFilter]), s.texParameteri(z, s.TEXTURE_MIN_FILTER, re[N.minFilter]), N.compareFunction && (s.texParameteri(z, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(z, s.TEXTURE_COMPARE_FUNC, j[N.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (N.magFilter === On || N.minFilter !== Nl && N.minFilter !== zr || N.type === si && e.has("OES_texture_float_linear") === !1) return;
      if (N.anisotropy > 1 || i.get(N).__currentAnisotropy) {
        const K = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(z, K.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(N.anisotropy, r.getMaxAnisotropy())), i.get(N).__currentAnisotropy = N.anisotropy;
      }
    }
  }
  function q(z, N) {
    let K = !1;
    z.__webglInit === void 0 && (z.__webglInit = !0, N.addEventListener("dispose", T));
    const he = N.source;
    let me = m.get(he);
    me === void 0 && (me = {}, m.set(he, me));
    const ge = O(N);
    if (ge !== z.__cacheKey) {
      me[ge] === void 0 && (me[ge] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, K = !0), me[ge].usedTimes++;
      const Me = me[z.__cacheKey];
      Me !== void 0 && (me[z.__cacheKey].usedTimes--, Me.usedTimes === 0 && y(N)), z.__cacheKey = ge, z.__webglTexture = me[ge].texture;
    }
    return K;
  }
  function oe(z, N, K) {
    let he = s.TEXTURE_2D;
    (N.isDataArrayTexture || N.isCompressedArrayTexture) && (he = s.TEXTURE_2D_ARRAY), N.isData3DTexture && (he = s.TEXTURE_3D);
    const me = q(z, N), ge = N.source;
    n.bindTexture(he, z.__webglTexture, s.TEXTURE0 + K);
    const Me = i.get(ge);
    if (ge.version !== Me.__version || me === !0) {
      n.activeTexture(s.TEXTURE0 + K);
      const Ee = It.getPrimaries(It.workingColorSpace), Ae = N.colorSpace === sr ? null : It.getPrimaries(N.colorSpace), Xe = N.colorSpace === sr || Ee === Ae ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, N.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, N.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Xe);
      let Oe = _(N.image, !1, r.maxTextureSize);
      Oe = X(N, Oe);
      const He = o.convert(N.format, N.colorSpace), Ye = o.convert(N.type);
      let $e = S(N.internalFormat, He, Ye, N.colorSpace, N.isVideoTexture);
      $(he, N);
      let Le;
      const nt = N.mipmaps, Je = N.isVideoTexture !== !0, bt = Me.__version === void 0 || me === !0, Se = ge.dataReady, Ne = C(N, Oe);
      if (N.isDepthTexture)
        $e = b(N.format === Wo, N.type), bt && (Je ? n.texStorage2D(s.TEXTURE_2D, 1, $e, Oe.width, Oe.height) : n.texImage2D(s.TEXTURE_2D, 0, $e, Oe.width, Oe.height, 0, He, Ye, null));
      else if (N.isDataTexture)
        if (nt.length > 0) {
          Je && bt && n.texStorage2D(s.TEXTURE_2D, Ne, $e, nt[0].width, nt[0].height);
          for (let Re = 0, Be = nt.length; Re < Be; Re++)
            Le = nt[Re], Je ? Se && n.texSubImage2D(s.TEXTURE_2D, Re, 0, 0, Le.width, Le.height, He, Ye, Le.data) : n.texImage2D(s.TEXTURE_2D, Re, $e, Le.width, Le.height, 0, He, Ye, Le.data);
          N.generateMipmaps = !1;
        } else
          Je ? (bt && n.texStorage2D(s.TEXTURE_2D, Ne, $e, Oe.width, Oe.height), Se && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Oe.width, Oe.height, He, Ye, Oe.data)) : n.texImage2D(s.TEXTURE_2D, 0, $e, Oe.width, Oe.height, 0, He, Ye, Oe.data);
      else if (N.isCompressedTexture)
        if (N.isCompressedArrayTexture) {
          Je && bt && n.texStorage3D(s.TEXTURE_2D_ARRAY, Ne, $e, nt[0].width, nt[0].height, Oe.depth);
          for (let Re = 0, Be = nt.length; Re < Be; Re++)
            if (Le = nt[Re], N.format !== Rn)
              if (He !== null)
                if (Je) {
                  if (Se)
                    if (N.layerUpdates.size > 0) {
                      const je = Zm(Le.width, Le.height, N.format, N.type);
                      for (const Ge of N.layerUpdates) {
                        const ut = Le.data.subarray(
                          Ge * je / Le.data.BYTES_PER_ELEMENT,
                          (Ge + 1) * je / Le.data.BYTES_PER_ELEMENT
                        );
                        n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, Re, 0, 0, Ge, Le.width, Le.height, 1, He, ut);
                      }
                      N.clearLayerUpdates();
                    } else
                      n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, Re, 0, 0, 0, Le.width, Le.height, Oe.depth, He, Le.data);
                } else
                  n.compressedTexImage3D(s.TEXTURE_2D_ARRAY, Re, $e, Le.width, Le.height, Oe.depth, 0, Le.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Je ? Se && n.texSubImage3D(s.TEXTURE_2D_ARRAY, Re, 0, 0, 0, Le.width, Le.height, Oe.depth, He, Ye, Le.data) : n.texImage3D(s.TEXTURE_2D_ARRAY, Re, $e, Le.width, Le.height, Oe.depth, 0, He, Ye, Le.data);
        } else {
          Je && bt && n.texStorage2D(s.TEXTURE_2D, Ne, $e, nt[0].width, nt[0].height);
          for (let Re = 0, Be = nt.length; Re < Be; Re++)
            Le = nt[Re], N.format !== Rn ? He !== null ? Je ? Se && n.compressedTexSubImage2D(s.TEXTURE_2D, Re, 0, 0, Le.width, Le.height, He, Le.data) : n.compressedTexImage2D(s.TEXTURE_2D, Re, $e, Le.width, Le.height, 0, Le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Je ? Se && n.texSubImage2D(s.TEXTURE_2D, Re, 0, 0, Le.width, Le.height, He, Ye, Le.data) : n.texImage2D(s.TEXTURE_2D, Re, $e, Le.width, Le.height, 0, He, Ye, Le.data);
        }
      else if (N.isDataArrayTexture)
        if (Je) {
          if (bt && n.texStorage3D(s.TEXTURE_2D_ARRAY, Ne, $e, Oe.width, Oe.height, Oe.depth), Se)
            if (N.layerUpdates.size > 0) {
              const Re = Zm(Oe.width, Oe.height, N.format, N.type);
              for (const Be of N.layerUpdates) {
                const je = Oe.data.subarray(
                  Be * Re / Oe.data.BYTES_PER_ELEMENT,
                  (Be + 1) * Re / Oe.data.BYTES_PER_ELEMENT
                );
                n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, Be, Oe.width, Oe.height, 1, He, Ye, je);
              }
              N.clearLayerUpdates();
            } else
              n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Oe.width, Oe.height, Oe.depth, He, Ye, Oe.data);
        } else
          n.texImage3D(s.TEXTURE_2D_ARRAY, 0, $e, Oe.width, Oe.height, Oe.depth, 0, He, Ye, Oe.data);
      else if (N.isData3DTexture)
        Je ? (bt && n.texStorage3D(s.TEXTURE_3D, Ne, $e, Oe.width, Oe.height, Oe.depth), Se && n.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, Oe.width, Oe.height, Oe.depth, He, Ye, Oe.data)) : n.texImage3D(s.TEXTURE_3D, 0, $e, Oe.width, Oe.height, Oe.depth, 0, He, Ye, Oe.data);
      else if (N.isFramebufferTexture) {
        if (bt)
          if (Je)
            n.texStorage2D(s.TEXTURE_2D, Ne, $e, Oe.width, Oe.height);
          else {
            let Re = Oe.width, Be = Oe.height;
            for (let je = 0; je < Ne; je++)
              n.texImage2D(s.TEXTURE_2D, je, $e, Re, Be, 0, He, Ye, null), Re >>= 1, Be >>= 1;
          }
      } else if (nt.length > 0) {
        if (Je && bt) {
          const Re = se(nt[0]);
          n.texStorage2D(s.TEXTURE_2D, Ne, $e, Re.width, Re.height);
        }
        for (let Re = 0, Be = nt.length; Re < Be; Re++)
          Le = nt[Re], Je ? Se && n.texSubImage2D(s.TEXTURE_2D, Re, 0, 0, He, Ye, Le) : n.texImage2D(s.TEXTURE_2D, Re, $e, He, Ye, Le);
        N.generateMipmaps = !1;
      } else if (Je) {
        if (bt) {
          const Re = se(Oe);
          n.texStorage2D(s.TEXTURE_2D, Ne, $e, Re.width, Re.height);
        }
        Se && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, He, Ye, Oe);
      } else
        n.texImage2D(s.TEXTURE_2D, 0, $e, He, Ye, Oe);
      g(N) && x(he), Me.__version = ge.version, N.onUpdate && N.onUpdate(N);
    }
    z.__version = N.version;
  }
  function ie(z, N, K) {
    if (N.image.length !== 6) return;
    const he = q(z, N), me = N.source;
    n.bindTexture(s.TEXTURE_CUBE_MAP, z.__webglTexture, s.TEXTURE0 + K);
    const ge = i.get(me);
    if (me.version !== ge.__version || he === !0) {
      n.activeTexture(s.TEXTURE0 + K);
      const Me = It.getPrimaries(It.workingColorSpace), Ee = N.colorSpace === sr ? null : It.getPrimaries(N.colorSpace), Ae = N.colorSpace === sr || Me === Ee ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, N.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, N.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
      const Xe = N.isCompressedTexture || N.image[0].isCompressedTexture, Oe = N.image[0] && N.image[0].isDataTexture, He = [];
      for (let Be = 0; Be < 6; Be++)
        !Xe && !Oe ? He[Be] = _(N.image[Be], !0, r.maxCubemapSize) : He[Be] = Oe ? N.image[Be].image : N.image[Be], He[Be] = X(N, He[Be]);
      const Ye = He[0], $e = o.convert(N.format, N.colorSpace), Le = o.convert(N.type), nt = S(N.internalFormat, $e, Le, N.colorSpace), Je = N.isVideoTexture !== !0, bt = ge.__version === void 0 || he === !0, Se = me.dataReady;
      let Ne = C(N, Ye);
      $(s.TEXTURE_CUBE_MAP, N);
      let Re;
      if (Xe) {
        Je && bt && n.texStorage2D(s.TEXTURE_CUBE_MAP, Ne, nt, Ye.width, Ye.height);
        for (let Be = 0; Be < 6; Be++) {
          Re = He[Be].mipmaps;
          for (let je = 0; je < Re.length; je++) {
            const Ge = Re[je];
            N.format !== Rn ? $e !== null ? Je ? Se && n.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, 0, 0, Ge.width, Ge.height, $e, Ge.data) : n.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, nt, Ge.width, Ge.height, 0, Ge.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, 0, 0, Ge.width, Ge.height, $e, Le, Ge.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, nt, Ge.width, Ge.height, 0, $e, Le, Ge.data);
          }
        }
      } else {
        if (Re = N.mipmaps, Je && bt) {
          Re.length > 0 && Ne++;
          const Be = se(He[0]);
          n.texStorage2D(s.TEXTURE_CUBE_MAP, Ne, nt, Be.width, Be.height);
        }
        for (let Be = 0; Be < 6; Be++)
          if (Oe) {
            Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, He[Be].width, He[Be].height, $e, Le, He[Be].data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, nt, He[Be].width, He[Be].height, 0, $e, Le, He[Be].data);
            for (let je = 0; je < Re.length; je++) {
              const ut = Re[je].image[Be].image;
              Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, 0, 0, ut.width, ut.height, $e, Le, ut.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, nt, ut.width, ut.height, 0, $e, Le, ut.data);
            }
          } else {
            Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, $e, Le, He[Be]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, nt, $e, Le, He[Be]);
            for (let je = 0; je < Re.length; je++) {
              const Ge = Re[je];
              Je ? Se && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, 0, 0, $e, Le, Ge.image[Be]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, nt, $e, Le, Ge.image[Be]);
            }
          }
      }
      g(N) && x(s.TEXTURE_CUBE_MAP), ge.__version = me.version, N.onUpdate && N.onUpdate(N);
    }
    z.__version = N.version;
  }
  function ce(z, N, K, he, me, ge) {
    const Me = o.convert(K.format, K.colorSpace), Ee = o.convert(K.type), Ae = S(K.internalFormat, Me, Ee, K.colorSpace), Xe = i.get(N), Oe = i.get(K);
    if (Oe.__renderTarget = N, !Xe.__hasExternalTextures) {
      const He = Math.max(1, N.width >> ge), Ye = Math.max(1, N.height >> ge);
      me === s.TEXTURE_3D || me === s.TEXTURE_2D_ARRAY ? n.texImage3D(me, ge, Ae, He, Ye, N.depth, 0, Me, Ee, null) : n.texImage2D(me, ge, Ae, He, Ye, 0, Me, Ee, null);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, z), J(N) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, he, me, Oe.__webglTexture, 0, ne(N)) : (me === s.TEXTURE_2D || me >= s.TEXTURE_CUBE_MAP_POSITIVE_X && me <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, he, me, Oe.__webglTexture, ge), n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function V(z, N, K) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, z), N.depthBuffer) {
      const he = N.depthTexture, me = he && he.isDepthTexture ? he.type : null, ge = b(N.stencilBuffer, me), Me = N.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Ee = ne(N);
      J(N) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Ee, ge, N.width, N.height) : K ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Ee, ge, N.width, N.height) : s.renderbufferStorage(s.RENDERBUFFER, ge, N.width, N.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, Me, s.RENDERBUFFER, z);
    } else {
      const he = N.textures;
      for (let me = 0; me < he.length; me++) {
        const ge = he[me], Me = o.convert(ge.format, ge.colorSpace), Ee = o.convert(ge.type), Ae = S(ge.internalFormat, Me, Ee, ge.colorSpace), Xe = ne(N);
        K && J(N) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Xe, Ae, N.width, N.height) : J(N) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Xe, Ae, N.width, N.height) : s.renderbufferStorage(s.RENDERBUFFER, Ae, N.width, N.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function Y(z, N) {
    if (N && N.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (n.bindFramebuffer(s.FRAMEBUFFER, z), !(N.depthTexture && N.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const he = i.get(N.depthTexture);
    he.__renderTarget = N, (!he.__webglTexture || N.depthTexture.image.width !== N.width || N.depthTexture.image.height !== N.height) && (N.depthTexture.image.width = N.width, N.depthTexture.image.height = N.height, N.depthTexture.needsUpdate = !0), A(N.depthTexture, 0);
    const me = he.__webglTexture, ge = ne(N);
    if (N.depthTexture.format === Vr)
      J(N) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, me, 0, ge) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, me, 0);
    else if (N.depthTexture.format === Wo)
      J(N) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, me, 0, ge) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, me, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function H(z) {
    const N = i.get(z), K = z.isWebGLCubeRenderTarget === !0;
    if (N.__boundDepthTexture !== z.depthTexture) {
      const he = z.depthTexture;
      if (N.__depthDisposeCallback && N.__depthDisposeCallback(), he) {
        const me = () => {
          delete N.__boundDepthTexture, delete N.__depthDisposeCallback, he.removeEventListener("dispose", me);
        };
        he.addEventListener("dispose", me), N.__depthDisposeCallback = me;
      }
      N.__boundDepthTexture = he;
    }
    if (z.depthTexture && !N.__autoAllocateDepthBuffer) {
      if (K) throw new Error("target.depthTexture not supported in Cube render targets");
      Y(N.__webglFramebuffer, z);
    } else if (K) {
      N.__webglDepthbuffer = [];
      for (let he = 0; he < 6; he++)
        if (n.bindFramebuffer(s.FRAMEBUFFER, N.__webglFramebuffer[he]), N.__webglDepthbuffer[he] === void 0)
          N.__webglDepthbuffer[he] = s.createRenderbuffer(), V(N.__webglDepthbuffer[he], z, !1);
        else {
          const me = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, ge = N.__webglDepthbuffer[he];
          s.bindRenderbuffer(s.RENDERBUFFER, ge), s.framebufferRenderbuffer(s.FRAMEBUFFER, me, s.RENDERBUFFER, ge);
        }
    } else if (n.bindFramebuffer(s.FRAMEBUFFER, N.__webglFramebuffer), N.__webglDepthbuffer === void 0)
      N.__webglDepthbuffer = s.createRenderbuffer(), V(N.__webglDepthbuffer, z, !1);
    else {
      const he = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, me = N.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, me), s.framebufferRenderbuffer(s.FRAMEBUFFER, he, s.RENDERBUFFER, me);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function I(z, N, K) {
    const he = i.get(z);
    N !== void 0 && ce(he.__webglFramebuffer, z, z.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), K !== void 0 && H(z);
  }
  function F(z) {
    const N = z.texture, K = i.get(z), he = i.get(N);
    z.addEventListener("dispose", P);
    const me = z.textures, ge = z.isWebGLCubeRenderTarget === !0, Me = me.length > 1;
    if (Me || (he.__webglTexture === void 0 && (he.__webglTexture = s.createTexture()), he.__version = N.version, a.memory.textures++), ge) {
      K.__webglFramebuffer = [];
      for (let Ee = 0; Ee < 6; Ee++)
        if (N.mipmaps && N.mipmaps.length > 0) {
          K.__webglFramebuffer[Ee] = [];
          for (let Ae = 0; Ae < N.mipmaps.length; Ae++)
            K.__webglFramebuffer[Ee][Ae] = s.createFramebuffer();
        } else
          K.__webglFramebuffer[Ee] = s.createFramebuffer();
    } else {
      if (N.mipmaps && N.mipmaps.length > 0) {
        K.__webglFramebuffer = [];
        for (let Ee = 0; Ee < N.mipmaps.length; Ee++)
          K.__webglFramebuffer[Ee] = s.createFramebuffer();
      } else
        K.__webglFramebuffer = s.createFramebuffer();
      if (Me)
        for (let Ee = 0, Ae = me.length; Ee < Ae; Ee++) {
          const Xe = i.get(me[Ee]);
          Xe.__webglTexture === void 0 && (Xe.__webglTexture = s.createTexture(), a.memory.textures++);
        }
      if (z.samples > 0 && J(z) === !1) {
        K.__webglMultisampledFramebuffer = s.createFramebuffer(), K.__webglColorRenderbuffer = [], n.bindFramebuffer(s.FRAMEBUFFER, K.__webglMultisampledFramebuffer);
        for (let Ee = 0; Ee < me.length; Ee++) {
          const Ae = me[Ee];
          K.__webglColorRenderbuffer[Ee] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, K.__webglColorRenderbuffer[Ee]);
          const Xe = o.convert(Ae.format, Ae.colorSpace), Oe = o.convert(Ae.type), He = S(Ae.internalFormat, Xe, Oe, Ae.colorSpace, z.isXRRenderTarget === !0), Ye = ne(z);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, Ye, He, z.width, z.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ee, s.RENDERBUFFER, K.__webglColorRenderbuffer[Ee]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), z.depthBuffer && (K.__webglDepthRenderbuffer = s.createRenderbuffer(), V(K.__webglDepthRenderbuffer, z, !0)), n.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (ge) {
      n.bindTexture(s.TEXTURE_CUBE_MAP, he.__webglTexture), $(s.TEXTURE_CUBE_MAP, N);
      for (let Ee = 0; Ee < 6; Ee++)
        if (N.mipmaps && N.mipmaps.length > 0)
          for (let Ae = 0; Ae < N.mipmaps.length; Ae++)
            ce(K.__webglFramebuffer[Ee][Ae], z, N, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, Ae);
        else
          ce(K.__webglFramebuffer[Ee], z, N, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Ee, 0);
      g(N) && x(s.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (Me) {
      for (let Ee = 0, Ae = me.length; Ee < Ae; Ee++) {
        const Xe = me[Ee], Oe = i.get(Xe);
        n.bindTexture(s.TEXTURE_2D, Oe.__webglTexture), $(s.TEXTURE_2D, Xe), ce(K.__webglFramebuffer, z, Xe, s.COLOR_ATTACHMENT0 + Ee, s.TEXTURE_2D, 0), g(Xe) && x(s.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let Ee = s.TEXTURE_2D;
      if ((z.isWebGL3DRenderTarget || z.isWebGLArrayRenderTarget) && (Ee = z.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), n.bindTexture(Ee, he.__webglTexture), $(Ee, N), N.mipmaps && N.mipmaps.length > 0)
        for (let Ae = 0; Ae < N.mipmaps.length; Ae++)
          ce(K.__webglFramebuffer[Ae], z, N, s.COLOR_ATTACHMENT0, Ee, Ae);
      else
        ce(K.__webglFramebuffer, z, N, s.COLOR_ATTACHMENT0, Ee, 0);
      g(N) && x(Ee), n.unbindTexture();
    }
    z.depthBuffer && H(z);
  }
  function L(z) {
    const N = z.textures;
    for (let K = 0, he = N.length; K < he; K++) {
      const me = N[K];
      if (g(me)) {
        const ge = M(z), Me = i.get(me).__webglTexture;
        n.bindTexture(ge, Me), x(ge), n.unbindTexture();
      }
    }
  }
  const ee = [], Z = [];
  function k(z) {
    if (z.samples > 0) {
      if (J(z) === !1) {
        const N = z.textures, K = z.width, he = z.height;
        let me = s.COLOR_BUFFER_BIT;
        const ge = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Me = i.get(z), Ee = N.length > 1;
        if (Ee)
          for (let Ae = 0; Ae < N.length; Ae++)
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, null), n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, null, 0);
        n.bindFramebuffer(s.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
        for (let Ae = 0; Ae < N.length; Ae++) {
          if (z.resolveDepthBuffer && (z.depthBuffer && (me |= s.DEPTH_BUFFER_BIT), z.stencilBuffer && z.resolveStencilBuffer && (me |= s.STENCIL_BUFFER_BIT)), Ee) {
            s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Me.__webglColorRenderbuffer[Ae]);
            const Xe = i.get(N[Ae]).__webglTexture;
            s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Xe, 0);
          }
          s.blitFramebuffer(0, 0, K, he, 0, 0, K, he, me, s.NEAREST), c === !0 && (ee.length = 0, Z.length = 0, ee.push(s.COLOR_ATTACHMENT0 + Ae), z.depthBuffer && z.resolveDepthBuffer === !1 && (ee.push(ge), Z.push(ge), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, Z)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, ee));
        }
        if (n.bindFramebuffer(s.READ_FRAMEBUFFER, null), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Ee)
          for (let Ae = 0; Ae < N.length; Ae++) {
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, Me.__webglColorRenderbuffer[Ae]);
            const Xe = i.get(N[Ae]).__webglTexture;
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, Xe, 0);
          }
        n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer);
      } else if (z.depthBuffer && z.resolveDepthBuffer === !1 && c) {
        const N = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [N]);
      }
    }
  }
  function ne(z) {
    return Math.min(r.maxSamples, z.samples);
  }
  function J(z) {
    const N = i.get(z);
    return z.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && N.__useRenderToTexture !== !1;
  }
  function B(z) {
    const N = a.render.frame;
    d.get(z) !== N && (d.set(z, N), z.update());
  }
  function X(z, N) {
    const K = z.colorSpace, he = z.format, me = z.type;
    return z.isCompressedTexture === !0 || z.isVideoTexture === !0 || K !== Jo && K !== sr && (It.getTransfer(K) === qt ? (he !== Rn || me !== ji) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", K)), N;
  }
  function se(z) {
    return typeof HTMLImageElement < "u" && z instanceof HTMLImageElement ? (u.width = z.naturalWidth || z.width, u.height = z.naturalHeight || z.height) : typeof VideoFrame < "u" && z instanceof VideoFrame ? (u.width = z.displayWidth, u.height = z.displayHeight) : (u.width = z.width, u.height = z.height), u;
  }
  this.allocateTextureUnit = R, this.resetTextureUnits = U, this.setTexture2D = A, this.setTexture2DArray = G, this.setTexture3D = ue, this.setTextureCube = Q, this.rebindTextures = I, this.setupRenderTarget = F, this.updateRenderTargetMipmap = L, this.updateMultisampleRenderTarget = k, this.setupDepthRenderbuffer = H, this.setupFrameBufferTexture = ce, this.useMultisampledRTT = J;
}
function T2(s, e) {
  function n(i, r = sr) {
    let o;
    const a = It.getTransfer(r);
    if (i === ji) return s.UNSIGNED_BYTE;
    if (i === Tf) return s.UNSIGNED_SHORT_4_4_4_4;
    if (i === Ef) return s.UNSIGNED_SHORT_5_5_5_1;
    if (i === X0) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (i === $0) return s.BYTE;
    if (i === W0) return s.SHORT;
    if (i === ul) return s.UNSIGNED_SHORT;
    if (i === Cf) return s.INT;
    if (i === Wr) return s.UNSIGNED_INT;
    if (i === si) return s.FLOAT;
    if (i === dr) return s.HALF_FLOAT;
    if (i === j0) return s.ALPHA;
    if (i === Y0) return s.RGB;
    if (i === Rn) return s.RGBA;
    if (i === q0) return s.LUMINANCE;
    if (i === Z0) return s.LUMINANCE_ALPHA;
    if (i === Vr) return s.DEPTH_COMPONENT;
    if (i === Wo) return s.DEPTH_STENCIL;
    if (i === tu) return s.RED;
    if (i === Af) return s.RED_INTEGER;
    if (i === K0) return s.RG;
    if (i === Pf) return s.RG_INTEGER;
    if (i === Rf) return s.RGBA_INTEGER;
    if (i === Lc || i === Fc || i === Uc || i === Oc)
      if (a === qt)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (i === Lc) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === Fc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === Uc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === Oc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (i === Lc) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === Fc) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === Uc) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === Oc) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (i === Sh || i === Mh || i === Ch || i === Th)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (i === Sh) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === Mh) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === Ch) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === Th) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (i === Eh || i === Ah || i === Ph)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (i === Eh || i === Ah) return a === qt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (i === Ph) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (i === Rh || i === Dh || i === kh || i === Ih || i === Lh || i === Fh || i === Uh || i === Oh || i === zh || i === Nh || i === Bh || i === Vh || i === Gh || i === Hh)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (i === Rh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === Dh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === kh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === Ih) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === Lh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === Fh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === Uh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === Oh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === zh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Nh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === Bh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Vh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === Gh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === Hh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (i === zc || i === $h || i === Wh)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (i === zc) return a === qt ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === $h) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === Wh) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (i === J0 || i === Xh || i === jh || i === Yh)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (i === zc) return o.COMPRESSED_RED_RGTC1_EXT;
        if (i === Xh) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === jh) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Yh) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return i === $o ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
  }
  return { convert: n };
}
class E2 extends di {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Ai extends cn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const A2 = { type: "move" };
class Rd {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Ai(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Ai(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new de(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new de()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Ai(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new de(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new de()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n)
        for (const i of e.hand.values())
          this._getHandJoint(n, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, n, i) {
    let r = null, o = null, a = null;
    const l = this._targetRay, c = this._grip, u = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        a = !0;
        for (const _ of e.hand.values()) {
          const g = n.getJointPose(_, i), x = this._getHandJoint(u, _);
          g !== null && (x.matrix.fromArray(g.transform.matrix), x.matrix.decompose(x.position, x.rotation, x.scale), x.matrixWorldNeedsUpdate = !0, x.jointRadius = g.radius), x.visible = g !== null;
        }
        const d = u.joints["index-finger-tip"], h = u.joints["thumb-tip"], m = d.position.distanceTo(h.position), p = 0.02, v = 5e-3;
        u.inputState.pinching && m > p + v ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !u.inputState.pinching && m <= p - v && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (o = n.getPose(e.gripSpace, i), o !== null && (c.matrix.fromArray(o.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(o.linearVelocity)) : c.hasLinearVelocity = !1, o.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(o.angularVelocity)) : c.hasAngularVelocity = !1));
      l !== null && (r = n.getPose(e.targetRaySpace, i), r === null && o !== null && (r = o), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(A2)));
    }
    return l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), u !== null && (u.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const i = new Ai();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[n.jointName] = i, e.add(i);
    }
    return e.joints[n.jointName];
  }
}
const P2 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, R2 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class D2 {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, n, i) {
    if (this.texture === null) {
      const r = new _n(), o = e.properties.get(r);
      o.__webglTexture = n.texture, (n.depthNear != i.depthNear || n.depthFar != i.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = r;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const n = e.cameras[0].viewport, i = new zn({
        vertexShader: P2,
        fragmentShader: R2,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: n.z },
          depthHeight: { value: n.w }
        }
      });
      this.mesh = new Ze(new un(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class k2 extends jr {
  constructor(e, n) {
    super();
    const i = this;
    let r = null, o = 1, a = null, l = "local-floor", c = 1, u = null, d = null, h = null, m = null, p = null, v = null;
    const _ = new D2(), g = n.getContextAttributes();
    let x = null, M = null;
    const S = [], b = [], C = new rt();
    let T = null;
    const P = new di();
    P.viewport = new jt();
    const E = new di();
    E.viewport = new jt();
    const y = [P, E], w = new E2();
    let D = null, U = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(oe) {
      let ie = S[oe];
      return ie === void 0 && (ie = new Rd(), S[oe] = ie), ie.getTargetRaySpace();
    }, this.getControllerGrip = function(oe) {
      let ie = S[oe];
      return ie === void 0 && (ie = new Rd(), S[oe] = ie), ie.getGripSpace();
    }, this.getHand = function(oe) {
      let ie = S[oe];
      return ie === void 0 && (ie = new Rd(), S[oe] = ie), ie.getHandSpace();
    };
    function R(oe) {
      const ie = b.indexOf(oe.inputSource);
      if (ie === -1)
        return;
      const ce = S[ie];
      ce !== void 0 && (ce.update(oe.inputSource, oe.frame, u || a), ce.dispatchEvent({ type: oe.type, data: oe.inputSource }));
    }
    function O() {
      r.removeEventListener("select", R), r.removeEventListener("selectstart", R), r.removeEventListener("selectend", R), r.removeEventListener("squeeze", R), r.removeEventListener("squeezestart", R), r.removeEventListener("squeezeend", R), r.removeEventListener("end", O), r.removeEventListener("inputsourceschange", A);
      for (let oe = 0; oe < S.length; oe++) {
        const ie = b[oe];
        ie !== null && (b[oe] = null, S[oe].disconnect(ie));
      }
      D = null, U = null, _.reset(), e.setRenderTarget(x), p = null, m = null, h = null, r = null, M = null, q.stop(), i.isPresenting = !1, e.setPixelRatio(T), e.setSize(C.width, C.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(oe) {
      o = oe, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(oe) {
      l = oe, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || a;
    }, this.setReferenceSpace = function(oe) {
      u = oe;
    }, this.getBaseLayer = function() {
      return m !== null ? m : p;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return v;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(oe) {
      if (r = oe, r !== null) {
        if (x = e.getRenderTarget(), r.addEventListener("select", R), r.addEventListener("selectstart", R), r.addEventListener("selectend", R), r.addEventListener("squeeze", R), r.addEventListener("squeezestart", R), r.addEventListener("squeezeend", R), r.addEventListener("end", O), r.addEventListener("inputsourceschange", A), g.xrCompatible !== !0 && await n.makeXRCompatible(), T = e.getPixelRatio(), e.getSize(C), r.renderState.layers === void 0) {
          const ie = {
            antialias: g.antialias,
            alpha: !0,
            depth: g.depth,
            stencil: g.stencil,
            framebufferScaleFactor: o
          };
          p = new XRWebGLLayer(r, n, ie), r.updateRenderState({ baseLayer: p }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, !1), M = new Ri(
            p.framebufferWidth,
            p.framebufferHeight,
            {
              format: Rn,
              type: ji,
              colorSpace: e.outputColorSpace,
              stencilBuffer: g.stencil
            }
          );
        } else {
          let ie = null, ce = null, V = null;
          g.depth && (V = g.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, ie = g.stencil ? Wo : Vr, ce = g.stencil ? $o : Wr);
          const Y = {
            colorFormat: n.RGBA8,
            depthFormat: V,
            scaleFactor: o
          };
          h = new XRWebGLBinding(r, n), m = h.createProjectionLayer(Y), r.updateRenderState({ layers: [m] }), e.setPixelRatio(1), e.setSize(m.textureWidth, m.textureHeight, !1), M = new Ri(
            m.textureWidth,
            m.textureHeight,
            {
              format: Rn,
              type: ji,
              depthTexture: new zf(m.textureWidth, m.textureHeight, ce, void 0, void 0, void 0, void 0, void 0, void 0, ie),
              stencilBuffer: g.stencil,
              colorSpace: e.outputColorSpace,
              samples: g.antialias ? 4 : 0,
              resolveDepthBuffer: m.ignoreDepthValues === !1
            }
          );
        }
        M.isXRRenderTarget = !0, this.setFoveation(c), u = null, a = await r.requestReferenceSpace(l), q.setContext(r), q.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return _.getDepthTexture();
    };
    function A(oe) {
      for (let ie = 0; ie < oe.removed.length; ie++) {
        const ce = oe.removed[ie], V = b.indexOf(ce);
        V >= 0 && (b[V] = null, S[V].disconnect(ce));
      }
      for (let ie = 0; ie < oe.added.length; ie++) {
        const ce = oe.added[ie];
        let V = b.indexOf(ce);
        if (V === -1) {
          for (let H = 0; H < S.length; H++)
            if (H >= b.length) {
              b.push(ce), V = H;
              break;
            } else if (b[H] === null) {
              b[H] = ce, V = H;
              break;
            }
          if (V === -1) break;
        }
        const Y = S[V];
        Y && Y.connect(ce);
      }
    }
    const G = new de(), ue = new de();
    function Q(oe, ie, ce) {
      G.setFromMatrixPosition(ie.matrixWorld), ue.setFromMatrixPosition(ce.matrixWorld);
      const V = G.distanceTo(ue), Y = ie.projectionMatrix.elements, H = ce.projectionMatrix.elements, I = Y[14] / (Y[10] - 1), F = Y[14] / (Y[10] + 1), L = (Y[9] + 1) / Y[5], ee = (Y[9] - 1) / Y[5], Z = (Y[8] - 1) / Y[0], k = (H[8] + 1) / H[0], ne = I * Z, J = I * k, B = V / (-Z + k), X = B * -Z;
      if (ie.matrixWorld.decompose(oe.position, oe.quaternion, oe.scale), oe.translateX(X), oe.translateZ(B), oe.matrixWorld.compose(oe.position, oe.quaternion, oe.scale), oe.matrixWorldInverse.copy(oe.matrixWorld).invert(), Y[10] === -1)
        oe.projectionMatrix.copy(ie.projectionMatrix), oe.projectionMatrixInverse.copy(ie.projectionMatrixInverse);
      else {
        const se = I + B, z = F + B, N = ne - X, K = J + (V - X), he = L * F / z * se, me = ee * F / z * se;
        oe.projectionMatrix.makePerspective(N, K, he, me, se, z), oe.projectionMatrixInverse.copy(oe.projectionMatrix).invert();
      }
    }
    function le(oe, ie) {
      ie === null ? oe.matrixWorld.copy(oe.matrix) : oe.matrixWorld.multiplyMatrices(ie.matrixWorld, oe.matrix), oe.matrixWorldInverse.copy(oe.matrixWorld).invert();
    }
    this.updateCamera = function(oe) {
      if (r === null) return;
      let ie = oe.near, ce = oe.far;
      _.texture !== null && (_.depthNear > 0 && (ie = _.depthNear), _.depthFar > 0 && (ce = _.depthFar)), w.near = E.near = P.near = ie, w.far = E.far = P.far = ce, (D !== w.near || U !== w.far) && (r.updateRenderState({
        depthNear: w.near,
        depthFar: w.far
      }), D = w.near, U = w.far), P.layers.mask = oe.layers.mask | 2, E.layers.mask = oe.layers.mask | 4, w.layers.mask = P.layers.mask | E.layers.mask;
      const V = oe.parent, Y = w.cameras;
      le(w, V);
      for (let H = 0; H < Y.length; H++)
        le(Y[H], V);
      Y.length === 2 ? Q(w, P, E) : w.projectionMatrix.copy(P.projectionMatrix), re(oe, w, V);
    };
    function re(oe, ie, ce) {
      ce === null ? oe.matrix.copy(ie.matrixWorld) : (oe.matrix.copy(ce.matrixWorld), oe.matrix.invert(), oe.matrix.multiply(ie.matrixWorld)), oe.matrix.decompose(oe.position, oe.quaternion, oe.scale), oe.updateMatrixWorld(!0), oe.projectionMatrix.copy(ie.projectionMatrix), oe.projectionMatrixInverse.copy(ie.projectionMatrixInverse), oe.isPerspectiveCamera && (oe.fov = Xo * 2 * Math.atan(1 / oe.projectionMatrix.elements[5]), oe.zoom = 1);
    }
    this.getCamera = function() {
      return w;
    }, this.getFoveation = function() {
      if (!(m === null && p === null))
        return c;
    }, this.setFoveation = function(oe) {
      c = oe, m !== null && (m.fixedFoveation = oe), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = oe);
    }, this.hasDepthSensing = function() {
      return _.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return _.getMesh(w);
    };
    let j = null;
    function $(oe, ie) {
      if (d = ie.getViewerPose(u || a), v = ie, d !== null) {
        const ce = d.views;
        p !== null && (e.setRenderTargetFramebuffer(M, p.framebuffer), e.setRenderTarget(M));
        let V = !1;
        ce.length !== w.cameras.length && (w.cameras.length = 0, V = !0);
        for (let H = 0; H < ce.length; H++) {
          const I = ce[H];
          let F = null;
          if (p !== null)
            F = p.getViewport(I);
          else {
            const ee = h.getViewSubImage(m, I);
            F = ee.viewport, H === 0 && (e.setRenderTargetTextures(
              M,
              ee.colorTexture,
              m.ignoreDepthValues ? void 0 : ee.depthStencilTexture
            ), e.setRenderTarget(M));
          }
          let L = y[H];
          L === void 0 && (L = new di(), L.layers.enable(H), L.viewport = new jt(), y[H] = L), L.matrix.fromArray(I.transform.matrix), L.matrix.decompose(L.position, L.quaternion, L.scale), L.projectionMatrix.fromArray(I.projectionMatrix), L.projectionMatrixInverse.copy(L.projectionMatrix).invert(), L.viewport.set(F.x, F.y, F.width, F.height), H === 0 && (w.matrix.copy(L.matrix), w.matrix.decompose(w.position, w.quaternion, w.scale)), V === !0 && w.cameras.push(L);
        }
        const Y = r.enabledFeatures;
        if (Y && Y.includes("depth-sensing")) {
          const H = h.getDepthInformation(ce[0]);
          H && H.isValid && H.texture && _.init(e, H, r.renderState);
        }
      }
      for (let ce = 0; ce < S.length; ce++) {
        const V = b[ce], Y = S[ce];
        V !== null && Y !== void 0 && Y.update(V, ie, u || a);
      }
      j && j(oe, ie), ie.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: ie }), v = null;
    }
    const q = new cy();
    q.setAnimationLoop($), this.setAnimationLoop = function(oe) {
      j = oe;
    }, this.dispose = function() {
    };
  }
}
const wr = /* @__PURE__ */ new Mi(), I2 = /* @__PURE__ */ new Zt();
function L2(s, e) {
  function n(g, x) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), x.value.copy(g.matrix);
  }
  function i(g, x) {
    x.color.getRGB(g.fogColor.value, oy(s)), x.isFog ? (g.fogNear.value = x.near, g.fogFar.value = x.far) : x.isFogExp2 && (g.fogDensity.value = x.density);
  }
  function r(g, x, M, S, b) {
    x.isMeshBasicMaterial || x.isMeshLambertMaterial ? o(g, x) : x.isMeshToonMaterial ? (o(g, x), h(g, x)) : x.isMeshPhongMaterial ? (o(g, x), d(g, x)) : x.isMeshStandardMaterial ? (o(g, x), m(g, x), x.isMeshPhysicalMaterial && p(g, x, b)) : x.isMeshMatcapMaterial ? (o(g, x), v(g, x)) : x.isMeshDepthMaterial ? o(g, x) : x.isMeshDistanceMaterial ? (o(g, x), _(g, x)) : x.isMeshNormalMaterial ? o(g, x) : x.isLineBasicMaterial ? (a(g, x), x.isLineDashedMaterial && l(g, x)) : x.isPointsMaterial ? c(g, x, M, S) : x.isSpriteMaterial ? u(g, x) : x.isShadowMaterial ? (g.color.value.copy(x.color), g.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = !1);
  }
  function o(g, x) {
    g.opacity.value = x.opacity, x.color && g.diffuse.value.copy(x.color), x.emissive && g.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity), x.map && (g.map.value = x.map, n(x.map, g.mapTransform)), x.alphaMap && (g.alphaMap.value = x.alphaMap, n(x.alphaMap, g.alphaMapTransform)), x.bumpMap && (g.bumpMap.value = x.bumpMap, n(x.bumpMap, g.bumpMapTransform), g.bumpScale.value = x.bumpScale, x.side === hi && (g.bumpScale.value *= -1)), x.normalMap && (g.normalMap.value = x.normalMap, n(x.normalMap, g.normalMapTransform), g.normalScale.value.copy(x.normalScale), x.side === hi && g.normalScale.value.negate()), x.displacementMap && (g.displacementMap.value = x.displacementMap, n(x.displacementMap, g.displacementMapTransform), g.displacementScale.value = x.displacementScale, g.displacementBias.value = x.displacementBias), x.emissiveMap && (g.emissiveMap.value = x.emissiveMap, n(x.emissiveMap, g.emissiveMapTransform)), x.specularMap && (g.specularMap.value = x.specularMap, n(x.specularMap, g.specularMapTransform)), x.alphaTest > 0 && (g.alphaTest.value = x.alphaTest);
    const M = e.get(x), S = M.envMap, b = M.envMapRotation;
    S && (g.envMap.value = S, wr.copy(b), wr.x *= -1, wr.y *= -1, wr.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (wr.y *= -1, wr.z *= -1), g.envMapRotation.value.setFromMatrix4(I2.makeRotationFromEuler(wr)), g.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = x.reflectivity, g.ior.value = x.ior, g.refractionRatio.value = x.refractionRatio), x.lightMap && (g.lightMap.value = x.lightMap, g.lightMapIntensity.value = x.lightMapIntensity, n(x.lightMap, g.lightMapTransform)), x.aoMap && (g.aoMap.value = x.aoMap, g.aoMapIntensity.value = x.aoMapIntensity, n(x.aoMap, g.aoMapTransform));
  }
  function a(g, x) {
    g.diffuse.value.copy(x.color), g.opacity.value = x.opacity, x.map && (g.map.value = x.map, n(x.map, g.mapTransform));
  }
  function l(g, x) {
    g.dashSize.value = x.dashSize, g.totalSize.value = x.dashSize + x.gapSize, g.scale.value = x.scale;
  }
  function c(g, x, M, S) {
    g.diffuse.value.copy(x.color), g.opacity.value = x.opacity, g.size.value = x.size * M, g.scale.value = S * 0.5, x.map && (g.map.value = x.map, n(x.map, g.uvTransform)), x.alphaMap && (g.alphaMap.value = x.alphaMap, n(x.alphaMap, g.alphaMapTransform)), x.alphaTest > 0 && (g.alphaTest.value = x.alphaTest);
  }
  function u(g, x) {
    g.diffuse.value.copy(x.color), g.opacity.value = x.opacity, g.rotation.value = x.rotation, x.map && (g.map.value = x.map, n(x.map, g.mapTransform)), x.alphaMap && (g.alphaMap.value = x.alphaMap, n(x.alphaMap, g.alphaMapTransform)), x.alphaTest > 0 && (g.alphaTest.value = x.alphaTest);
  }
  function d(g, x) {
    g.specular.value.copy(x.specular), g.shininess.value = Math.max(x.shininess, 1e-4);
  }
  function h(g, x) {
    x.gradientMap && (g.gradientMap.value = x.gradientMap);
  }
  function m(g, x) {
    g.metalness.value = x.metalness, x.metalnessMap && (g.metalnessMap.value = x.metalnessMap, n(x.metalnessMap, g.metalnessMapTransform)), g.roughness.value = x.roughness, x.roughnessMap && (g.roughnessMap.value = x.roughnessMap, n(x.roughnessMap, g.roughnessMapTransform)), x.envMap && (g.envMapIntensity.value = x.envMapIntensity);
  }
  function p(g, x, M) {
    g.ior.value = x.ior, x.sheen > 0 && (g.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen), g.sheenRoughness.value = x.sheenRoughness, x.sheenColorMap && (g.sheenColorMap.value = x.sheenColorMap, n(x.sheenColorMap, g.sheenColorMapTransform)), x.sheenRoughnessMap && (g.sheenRoughnessMap.value = x.sheenRoughnessMap, n(x.sheenRoughnessMap, g.sheenRoughnessMapTransform))), x.clearcoat > 0 && (g.clearcoat.value = x.clearcoat, g.clearcoatRoughness.value = x.clearcoatRoughness, x.clearcoatMap && (g.clearcoatMap.value = x.clearcoatMap, n(x.clearcoatMap, g.clearcoatMapTransform)), x.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap, n(x.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), x.clearcoatNormalMap && (g.clearcoatNormalMap.value = x.clearcoatNormalMap, n(x.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(x.clearcoatNormalScale), x.side === hi && g.clearcoatNormalScale.value.negate())), x.dispersion > 0 && (g.dispersion.value = x.dispersion), x.iridescence > 0 && (g.iridescence.value = x.iridescence, g.iridescenceIOR.value = x.iridescenceIOR, g.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1], x.iridescenceMap && (g.iridescenceMap.value = x.iridescenceMap, n(x.iridescenceMap, g.iridescenceMapTransform)), x.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = x.iridescenceThicknessMap, n(x.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), x.transmission > 0 && (g.transmission.value = x.transmission, g.transmissionSamplerMap.value = M.texture, g.transmissionSamplerSize.value.set(M.width, M.height), x.transmissionMap && (g.transmissionMap.value = x.transmissionMap, n(x.transmissionMap, g.transmissionMapTransform)), g.thickness.value = x.thickness, x.thicknessMap && (g.thicknessMap.value = x.thicknessMap, n(x.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = x.attenuationDistance, g.attenuationColor.value.copy(x.attenuationColor)), x.anisotropy > 0 && (g.anisotropyVector.value.set(x.anisotropy * Math.cos(x.anisotropyRotation), x.anisotropy * Math.sin(x.anisotropyRotation)), x.anisotropyMap && (g.anisotropyMap.value = x.anisotropyMap, n(x.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = x.specularIntensity, g.specularColor.value.copy(x.specularColor), x.specularColorMap && (g.specularColorMap.value = x.specularColorMap, n(x.specularColorMap, g.specularColorMapTransform)), x.specularIntensityMap && (g.specularIntensityMap.value = x.specularIntensityMap, n(x.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function v(g, x) {
    x.matcap && (g.matcap.value = x.matcap);
  }
  function _(g, x) {
    const M = e.get(x).light;
    g.referencePosition.value.setFromMatrixPosition(M.matrixWorld), g.nearDistance.value = M.shadow.camera.near, g.farDistance.value = M.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: r
  };
}
function F2(s, e, n, i) {
  let r = {}, o = {}, a = [];
  const l = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function c(M, S) {
    const b = S.program;
    i.uniformBlockBinding(M, b);
  }
  function u(M, S) {
    let b = r[M.id];
    b === void 0 && (v(M), b = d(M), r[M.id] = b, M.addEventListener("dispose", g));
    const C = S.program;
    i.updateUBOMapping(M, C);
    const T = e.render.frame;
    o[M.id] !== T && (m(M), o[M.id] = T);
  }
  function d(M) {
    const S = h();
    M.__bindingPointIndex = S;
    const b = s.createBuffer(), C = M.__size, T = M.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, b), s.bufferData(s.UNIFORM_BUFFER, C, T), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, S, b), b;
  }
  function h() {
    for (let M = 0; M < l; M++)
      if (a.indexOf(M) === -1)
        return a.push(M), M;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function m(M) {
    const S = r[M.id], b = M.uniforms, C = M.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, S);
    for (let T = 0, P = b.length; T < P; T++) {
      const E = Array.isArray(b[T]) ? b[T] : [b[T]];
      for (let y = 0, w = E.length; y < w; y++) {
        const D = E[y];
        if (p(D, T, y, C) === !0) {
          const U = D.__offset, R = Array.isArray(D.value) ? D.value : [D.value];
          let O = 0;
          for (let A = 0; A < R.length; A++) {
            const G = R[A], ue = _(G);
            typeof G == "number" || typeof G == "boolean" ? (D.__data[0] = G, s.bufferSubData(s.UNIFORM_BUFFER, U + O, D.__data)) : G.isMatrix3 ? (D.__data[0] = G.elements[0], D.__data[1] = G.elements[1], D.__data[2] = G.elements[2], D.__data[3] = 0, D.__data[4] = G.elements[3], D.__data[5] = G.elements[4], D.__data[6] = G.elements[5], D.__data[7] = 0, D.__data[8] = G.elements[6], D.__data[9] = G.elements[7], D.__data[10] = G.elements[8], D.__data[11] = 0) : (G.toArray(D.__data, O), O += ue.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, U, D.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function p(M, S, b, C) {
    const T = M.value, P = S + "_" + b;
    if (C[P] === void 0)
      return typeof T == "number" || typeof T == "boolean" ? C[P] = T : C[P] = T.clone(), !0;
    {
      const E = C[P];
      if (typeof T == "number" || typeof T == "boolean") {
        if (E !== T)
          return C[P] = T, !0;
      } else if (E.equals(T) === !1)
        return E.copy(T), !0;
    }
    return !1;
  }
  function v(M) {
    const S = M.uniforms;
    let b = 0;
    const C = 16;
    for (let P = 0, E = S.length; P < E; P++) {
      const y = Array.isArray(S[P]) ? S[P] : [S[P]];
      for (let w = 0, D = y.length; w < D; w++) {
        const U = y[w], R = Array.isArray(U.value) ? U.value : [U.value];
        for (let O = 0, A = R.length; O < A; O++) {
          const G = R[O], ue = _(G), Q = b % C, le = Q % ue.boundary, re = Q + le;
          b += le, re !== 0 && C - re < ue.storage && (b += C - re), U.__data = new Float32Array(ue.storage / Float32Array.BYTES_PER_ELEMENT), U.__offset = b, b += ue.storage;
        }
      }
    }
    const T = b % C;
    return T > 0 && (b += C - T), M.__size = b, M.__cache = {}, this;
  }
  function _(M) {
    const S = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof M == "number" || typeof M == "boolean" ? (S.boundary = 4, S.storage = 4) : M.isVector2 ? (S.boundary = 8, S.storage = 8) : M.isVector3 || M.isColor ? (S.boundary = 16, S.storage = 12) : M.isVector4 ? (S.boundary = 16, S.storage = 16) : M.isMatrix3 ? (S.boundary = 48, S.storage = 48) : M.isMatrix4 ? (S.boundary = 64, S.storage = 64) : M.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", M), S;
  }
  function g(M) {
    const S = M.target;
    S.removeEventListener("dispose", g);
    const b = a.indexOf(S.__bindingPointIndex);
    a.splice(b, 1), s.deleteBuffer(r[S.id]), delete r[S.id], delete o[S.id];
  }
  function x() {
    for (const M in r)
      s.deleteBuffer(r[M]);
    a = [], r = {}, o = {};
  }
  return {
    bind: c,
    update: u,
    dispose: x
  };
}
class U2 {
  constructor(e = {}) {
    const {
      canvas: n = Eb(),
      context: i = null,
      depth: r = !0,
      stencil: o = !1,
      alpha: a = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: h = !1,
      reverseDepthBuffer: m = !1
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    if (i !== null) {
      if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      p = i.getContextAttributes().alpha;
    } else
      p = a;
    const v = new Uint32Array(4), _ = new Int32Array(4);
    let g = null, x = null;
    const M = [], S = [];
    this.domElement = n, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = dn, this.toneMapping = or, this.toneMappingExposure = 1;
    const b = this;
    let C = !1, T = 0, P = 0, E = null, y = -1, w = null;
    const D = new jt(), U = new jt();
    let R = null;
    const O = new Mt(0);
    let A = 0, G = n.width, ue = n.height, Q = 1, le = null, re = null;
    const j = new jt(0, 0, G, ue), $ = new jt(0, 0, G, ue);
    let q = !1;
    const oe = new Uf();
    let ie = !1, ce = !1;
    const V = new Zt(), Y = new Zt(), H = new de(), I = new jt(), F = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let L = !1;
    function ee() {
      return E === null ? Q : 1;
    }
    let Z = i;
    function k(W, ve) {
      return n.getContext(W, ve);
    }
    try {
      const W = {
        alpha: !0,
        depth: r,
        stencil: o,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: d,
        failIfMajorPerformanceCaveat: h
      };
      if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${Sf}`), n.addEventListener("webglcontextlost", Be, !1), n.addEventListener("webglcontextrestored", je, !1), n.addEventListener("webglcontextcreationerror", Ge, !1), Z === null) {
        const ve = "webgl2";
        if (Z = k(ve, W), Z === null)
          throw k(ve) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (W) {
      throw console.error("THREE.WebGLRenderer: " + W.message), W;
    }
    let ne, J, B, X, se, z, N, K, he, me, ge, Me, Ee, Ae, Xe, Oe, He, Ye, $e, Le, nt, Je, bt, Se;
    function Ne() {
      ne = new HM(Z), ne.init(), Je = new T2(Z, ne), J = new OM(Z, ne, e, Je), B = new S2(Z, ne), J.reverseDepthBuffer && m && B.buffers.depth.setReversed(!0), X = new XM(Z), se = new u2(), z = new C2(Z, ne, B, se, J, Je, X), N = new NM(b), K = new GM(b), he = new Qb(Z), bt = new FM(Z, he), me = new $M(Z, he, X, bt), ge = new YM(Z, me, he, X), $e = new jM(Z, J, z), Oe = new zM(se), Me = new c2(b, N, K, ne, J, bt, Oe), Ee = new L2(b, se), Ae = new h2(), Xe = new y2(ne), Ye = new LM(b, N, K, B, ge, p, c), He = new b2(b, ge, J), Se = new F2(Z, X, J, B), Le = new UM(Z, ne, X), nt = new WM(Z, ne, X), X.programs = Me.programs, b.capabilities = J, b.extensions = ne, b.properties = se, b.renderLists = Ae, b.shadowMap = He, b.state = B, b.info = X;
    }
    Ne();
    const Re = new k2(b, Z);
    this.xr = Re, this.getContext = function() {
      return Z;
    }, this.getContextAttributes = function() {
      return Z.getContextAttributes();
    }, this.forceContextLoss = function() {
      const W = ne.get("WEBGL_lose_context");
      W && W.loseContext();
    }, this.forceContextRestore = function() {
      const W = ne.get("WEBGL_lose_context");
      W && W.restoreContext();
    }, this.getPixelRatio = function() {
      return Q;
    }, this.setPixelRatio = function(W) {
      W !== void 0 && (Q = W, this.setSize(G, ue, !1));
    }, this.getSize = function(W) {
      return W.set(G, ue);
    }, this.setSize = function(W, ve, ye = !0) {
      if (Re.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      G = W, ue = ve, n.width = Math.floor(W * Q), n.height = Math.floor(ve * Q), ye === !0 && (n.style.width = W + "px", n.style.height = ve + "px"), this.setViewport(0, 0, W, ve);
    }, this.getDrawingBufferSize = function(W) {
      return W.set(G * Q, ue * Q).floor();
    }, this.setDrawingBufferSize = function(W, ve, ye) {
      G = W, ue = ve, Q = ye, n.width = Math.floor(W * ye), n.height = Math.floor(ve * ye), this.setViewport(0, 0, W, ve);
    }, this.getCurrentViewport = function(W) {
      return W.copy(D);
    }, this.getViewport = function(W) {
      return W.copy(j);
    }, this.setViewport = function(W, ve, ye, Ce) {
      W.isVector4 ? j.set(W.x, W.y, W.z, W.w) : j.set(W, ve, ye, Ce), B.viewport(D.copy(j).multiplyScalar(Q).round());
    }, this.getScissor = function(W) {
      return W.copy($);
    }, this.setScissor = function(W, ve, ye, Ce) {
      W.isVector4 ? $.set(W.x, W.y, W.z, W.w) : $.set(W, ve, ye, Ce), B.scissor(U.copy($).multiplyScalar(Q).round());
    }, this.getScissorTest = function() {
      return q;
    }, this.setScissorTest = function(W) {
      B.setScissorTest(q = W);
    }, this.setOpaqueSort = function(W) {
      le = W;
    }, this.setTransparentSort = function(W) {
      re = W;
    }, this.getClearColor = function(W) {
      return W.copy(Ye.getClearColor());
    }, this.setClearColor = function() {
      Ye.setClearColor.apply(Ye, arguments);
    }, this.getClearAlpha = function() {
      return Ye.getClearAlpha();
    }, this.setClearAlpha = function() {
      Ye.setClearAlpha.apply(Ye, arguments);
    }, this.clear = function(W = !0, ve = !0, ye = !0) {
      let Ce = 0;
      if (W) {
        let be = !1;
        if (E !== null) {
          const ke = E.texture.format;
          be = ke === Rf || ke === Pf || ke === Af;
        }
        if (be) {
          const ke = E.texture.type, De = ke === ji || ke === Wr || ke === ul || ke === $o || ke === Tf || ke === Ef, Qe = Ye.getClearColor(), it = Ye.getClearAlpha(), mt = Qe.r, gt = Qe.g, lt = Qe.b;
          De ? (v[0] = mt, v[1] = gt, v[2] = lt, v[3] = it, Z.clearBufferuiv(Z.COLOR, 0, v)) : (_[0] = mt, _[1] = gt, _[2] = lt, _[3] = it, Z.clearBufferiv(Z.COLOR, 0, _));
        } else
          Ce |= Z.COLOR_BUFFER_BIT;
      }
      ve && (Ce |= Z.DEPTH_BUFFER_BIT), ye && (Ce |= Z.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Z.clear(Ce);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      n.removeEventListener("webglcontextlost", Be, !1), n.removeEventListener("webglcontextrestored", je, !1), n.removeEventListener("webglcontextcreationerror", Ge, !1), Ae.dispose(), Xe.dispose(), se.dispose(), N.dispose(), K.dispose(), ge.dispose(), bt.dispose(), Se.dispose(), Me.dispose(), Re.dispose(), Re.removeEventListener("sessionstart", rn), Re.removeEventListener("sessionend", Bn), bn.stop();
    };
    function Be(W) {
      W.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0;
    }
    function je() {
      console.log("THREE.WebGLRenderer: Context Restored."), C = !1;
      const W = X.autoReset, ve = He.enabled, ye = He.autoUpdate, Ce = He.needsUpdate, be = He.type;
      Ne(), X.autoReset = W, He.enabled = ve, He.autoUpdate = ye, He.needsUpdate = Ce, He.type = be;
    }
    function Ge(W) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", W.statusMessage);
    }
    function ut(W) {
      const ve = W.target;
      ve.removeEventListener("dispose", ut), at(ve);
    }
    function at(W) {
      dt(W), se.remove(W);
    }
    function dt(W) {
      const ve = se.get(W).programs;
      ve !== void 0 && (ve.forEach(function(ye) {
        Me.releaseProgram(ye);
      }), W.isShaderMaterial && Me.releaseShaderCache(W));
    }
    this.renderBufferDirect = function(W, ve, ye, Ce, be, ke) {
      ve === null && (ve = F);
      const De = be.isMesh && be.matrixWorld.determinant() < 0, Qe = xe(W, ve, ye, Ce, be);
      B.setMaterial(Ce, De);
      let it = ye.index, mt = 1;
      if (Ce.wireframe === !0) {
        if (it = me.getWireframeAttribute(ye), it === void 0) return;
        mt = 2;
      }
      const gt = ye.drawRange, lt = ye.attributes.position;
      let Rt = gt.start * mt, Ht = (gt.start + gt.count) * mt;
      ke !== null && (Rt = Math.max(Rt, ke.start * mt), Ht = Math.min(Ht, (ke.start + ke.count) * mt)), it !== null ? (Rt = Math.max(Rt, 0), Ht = Math.min(Ht, it.count)) : lt != null && (Rt = Math.max(Rt, 0), Ht = Math.min(Ht, lt.count));
      const $t = Ht - Rt;
      if ($t < 0 || $t === 1 / 0) return;
      bt.setup(be, Ce, Qe, ye, it);
      let Dn, kt = Le;
      if (it !== null && (Dn = he.get(it), kt = nt, kt.setIndex(Dn)), be.isMesh)
        Ce.wireframe === !0 ? (B.setLineWidth(Ce.wireframeLinewidth * ee()), kt.setMode(Z.LINES)) : kt.setMode(Z.TRIANGLES);
      else if (be.isLine) {
        let ht = Ce.linewidth;
        ht === void 0 && (ht = 1), B.setLineWidth(ht * ee()), be.isLineSegments ? kt.setMode(Z.LINES) : be.isLineLoop ? kt.setMode(Z.LINE_LOOP) : kt.setMode(Z.LINE_STRIP);
      } else be.isPoints ? kt.setMode(Z.POINTS) : be.isSprite && kt.setMode(Z.TRIANGLES);
      if (be.isBatchedMesh)
        if (be._multiDrawInstances !== null)
          kt.renderMultiDrawInstances(be._multiDrawStarts, be._multiDrawCounts, be._multiDrawCount, be._multiDrawInstances);
        else if (ne.get("WEBGL_multi_draw"))
          kt.renderMultiDraw(be._multiDrawStarts, be._multiDrawCounts, be._multiDrawCount);
        else {
          const ht = be._multiDrawStarts, mi = be._multiDrawCounts, Lt = be._multiDrawCount, kn = it ? he.get(it).bytesPerElement : 1, Zi = se.get(Ce).currentProgram.getUniforms();
          for (let Sn = 0; Sn < Lt; Sn++)
            Zi.setValue(Z, "_gl_DrawID", Sn), kt.render(ht[Sn] / kn, mi[Sn]);
        }
      else if (be.isInstancedMesh)
        kt.renderInstances(Rt, $t, be.count);
      else if (ye.isInstancedBufferGeometry) {
        const ht = ye._maxInstanceCount !== void 0 ? ye._maxInstanceCount : 1 / 0, mi = Math.min(ye.instanceCount, ht);
        kt.renderInstances(Rt, $t, mi);
      } else
        kt.render(Rt, $t);
    };
    function pt(W, ve, ye) {
      W.transparent === !0 && W.side === vn && W.forceSinglePass === !1 ? (W.side = hi, W.needsUpdate = !0, ri(W, ve, ye), W.side = ar, W.needsUpdate = !0, ri(W, ve, ye), W.side = vn) : ri(W, ve, ye);
    }
    this.compile = function(W, ve, ye = null) {
      ye === null && (ye = W), x = Xe.get(ye), x.init(ve), S.push(x), ye.traverseVisible(function(be) {
        be.isLight && be.layers.test(ve.layers) && (x.pushLight(be), be.castShadow && x.pushShadow(be));
      }), W !== ye && W.traverseVisible(function(be) {
        be.isLight && be.layers.test(ve.layers) && (x.pushLight(be), be.castShadow && x.pushShadow(be));
      }), x.setupLights();
      const Ce = /* @__PURE__ */ new Set();
      return W.traverse(function(be) {
        if (!(be.isMesh || be.isPoints || be.isLine || be.isSprite))
          return;
        const ke = be.material;
        if (ke)
          if (Array.isArray(ke))
            for (let De = 0; De < ke.length; De++) {
              const Qe = ke[De];
              pt(Qe, ye, be), Ce.add(Qe);
            }
          else
            pt(ke, ye, be), Ce.add(ke);
      }), S.pop(), x = null, Ce;
    }, this.compileAsync = function(W, ve, ye = null) {
      const Ce = this.compile(W, ve, ye);
      return new Promise((be) => {
        function ke() {
          if (Ce.forEach(function(De) {
            se.get(De).currentProgram.isReady() && Ce.delete(De);
          }), Ce.size === 0) {
            be(W);
            return;
          }
          setTimeout(ke, 10);
        }
        ne.get("KHR_parallel_shader_compile") !== null ? ke() : setTimeout(ke, 10);
      });
    };
    let zt = null;
    function Kt(W) {
      zt && zt(W);
    }
    function rn() {
      bn.stop();
    }
    function Bn() {
      bn.start();
    }
    const bn = new cy();
    bn.setAnimationLoop(Kt), typeof self < "u" && bn.setContext(self), this.setAnimationLoop = function(W) {
      zt = W, Re.setAnimationLoop(W), W === null ? bn.stop() : bn.start();
    }, Re.addEventListener("sessionstart", rn), Re.addEventListener("sessionend", Bn), this.render = function(W, ve) {
      if (ve !== void 0 && ve.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (C === !0) return;
      if (W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), ve.parent === null && ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), Re.enabled === !0 && Re.isPresenting === !0 && (Re.cameraAutoUpdate === !0 && Re.updateCamera(ve), ve = Re.getCamera()), W.isScene === !0 && W.onBeforeRender(b, W, ve, E), x = Xe.get(W, S.length), x.init(ve), S.push(x), Y.multiplyMatrices(ve.projectionMatrix, ve.matrixWorldInverse), oe.setFromProjectionMatrix(Y), ce = this.localClippingEnabled, ie = Oe.init(this.clippingPlanes, ce), g = Ae.get(W, M.length), g.init(), M.push(g), Re.enabled === !0 && Re.isPresenting === !0) {
        const ke = b.xr.getDepthSensingMesh();
        ke !== null && Kn(ke, ve, -1 / 0, b.sortObjects);
      }
      Kn(W, ve, 0, b.sortObjects), g.finish(), b.sortObjects === !0 && g.sort(le, re), L = Re.enabled === !1 || Re.isPresenting === !1 || Re.hasDepthSensing() === !1, L && Ye.addToRenderList(g, W), this.info.render.frame++, ie === !0 && Oe.beginShadows();
      const ye = x.state.shadowsArray;
      He.render(ye, W, ve), ie === !0 && Oe.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Ce = g.opaque, be = g.transmissive;
      if (x.setupLights(), ve.isArrayCamera) {
        const ke = ve.cameras;
        if (be.length > 0)
          for (let De = 0, Qe = ke.length; De < Qe; De++) {
            const it = ke[De];
            pi(Ce, be, W, it);
          }
        L && Ye.render(W);
        for (let De = 0, Qe = ke.length; De < Qe; De++) {
          const it = ke[De];
          fi(g, W, it, it.viewport);
        }
      } else
        be.length > 0 && pi(Ce, be, W, ve), L && Ye.render(W), fi(g, W, ve);
      E !== null && (z.updateMultisampleRenderTarget(E), z.updateRenderTargetMipmap(E)), W.isScene === !0 && W.onAfterRender(b, W, ve), bt.resetDefaultState(), y = -1, w = null, S.pop(), S.length > 0 ? (x = S[S.length - 1], ie === !0 && Oe.setGlobalState(b.clippingPlanes, x.state.camera)) : x = null, M.pop(), M.length > 0 ? g = M[M.length - 1] : g = null;
    };
    function Kn(W, ve, ye, Ce) {
      if (W.visible === !1) return;
      if (W.layers.test(ve.layers)) {
        if (W.isGroup)
          ye = W.renderOrder;
        else if (W.isLOD)
          W.autoUpdate === !0 && W.update(ve);
        else if (W.isLight)
          x.pushLight(W), W.castShadow && x.pushShadow(W);
        else if (W.isSprite) {
          if (!W.frustumCulled || oe.intersectsSprite(W)) {
            Ce && I.setFromMatrixPosition(W.matrixWorld).applyMatrix4(Y);
            const De = ge.update(W), Qe = W.material;
            Qe.visible && g.push(W, De, Qe, ye, I.z, null);
          }
        } else if ((W.isMesh || W.isLine || W.isPoints) && (!W.frustumCulled || oe.intersectsObject(W))) {
          const De = ge.update(W), Qe = W.material;
          if (Ce && (W.boundingSphere !== void 0 ? (W.boundingSphere === null && W.computeBoundingSphere(), I.copy(W.boundingSphere.center)) : (De.boundingSphere === null && De.computeBoundingSphere(), I.copy(De.boundingSphere.center)), I.applyMatrix4(W.matrixWorld).applyMatrix4(Y)), Array.isArray(Qe)) {
            const it = De.groups;
            for (let mt = 0, gt = it.length; mt < gt; mt++) {
              const lt = it[mt], Rt = Qe[lt.materialIndex];
              Rt && Rt.visible && g.push(W, De, Rt, ye, I.z, lt);
            }
          } else Qe.visible && g.push(W, De, Qe, ye, I.z, null);
        }
      }
      const ke = W.children;
      for (let De = 0, Qe = ke.length; De < Qe; De++)
        Kn(ke[De], ve, ye, Ce);
    }
    function fi(W, ve, ye, Ce) {
      const be = W.opaque, ke = W.transmissive, De = W.transparent;
      x.setupLightsView(ye), ie === !0 && Oe.setGlobalState(b.clippingPlanes, ye), Ce && B.viewport(D.copy(Ce)), be.length > 0 && Vn(be, ve, ye), ke.length > 0 && Vn(ke, ve, ye), De.length > 0 && Vn(De, ve, ye), B.buffers.depth.setTest(!0), B.buffers.depth.setMask(!0), B.buffers.color.setMask(!0), B.setPolygonOffset(!1);
    }
    function pi(W, ve, ye, Ce) {
      if ((ye.isScene === !0 ? ye.overrideMaterial : null) !== null)
        return;
      x.state.transmissionRenderTarget[Ce.id] === void 0 && (x.state.transmissionRenderTarget[Ce.id] = new Ri(1, 1, {
        generateMipmaps: !0,
        type: ne.has("EXT_color_buffer_half_float") || ne.has("EXT_color_buffer_float") ? dr : ji,
        minFilter: zr,
        samples: 4,
        stencilBuffer: o,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: It.workingColorSpace
      }));
      const ke = x.state.transmissionRenderTarget[Ce.id], De = Ce.viewport || D;
      ke.setSize(De.z, De.w);
      const Qe = b.getRenderTarget();
      b.setRenderTarget(ke), b.getClearColor(O), A = b.getClearAlpha(), A < 1 && b.setClearColor(16777215, 0.5), b.clear(), L && Ye.render(ye);
      const it = b.toneMapping;
      b.toneMapping = or;
      const mt = Ce.viewport;
      if (Ce.viewport !== void 0 && (Ce.viewport = void 0), x.setupLightsView(Ce), ie === !0 && Oe.setGlobalState(b.clippingPlanes, Ce), Vn(W, ye, Ce), z.updateMultisampleRenderTarget(ke), z.updateRenderTargetMipmap(ke), ne.has("WEBGL_multisampled_render_to_texture") === !1) {
        let gt = !1;
        for (let lt = 0, Rt = ve.length; lt < Rt; lt++) {
          const Ht = ve[lt], $t = Ht.object, Dn = Ht.geometry, kt = Ht.material, ht = Ht.group;
          if (kt.side === vn && $t.layers.test(Ce.layers)) {
            const mi = kt.side;
            kt.side = hi, kt.needsUpdate = !0, wn($t, ye, Ce, Dn, kt, ht), kt.side = mi, kt.needsUpdate = !0, gt = !0;
          }
        }
        gt === !0 && (z.updateMultisampleRenderTarget(ke), z.updateRenderTargetMipmap(ke));
      }
      b.setRenderTarget(Qe), b.setClearColor(O, A), mt !== void 0 && (Ce.viewport = mt), b.toneMapping = it;
    }
    function Vn(W, ve, ye) {
      const Ce = ve.isScene === !0 ? ve.overrideMaterial : null;
      for (let be = 0, ke = W.length; be < ke; be++) {
        const De = W[be], Qe = De.object, it = De.geometry, mt = Ce === null ? De.material : Ce, gt = De.group;
        Qe.layers.test(ye.layers) && wn(Qe, ve, ye, it, mt, gt);
      }
    }
    function wn(W, ve, ye, Ce, be, ke) {
      W.onBeforeRender(b, ve, ye, Ce, be, ke), W.modelViewMatrix.multiplyMatrices(ye.matrixWorldInverse, W.matrixWorld), W.normalMatrix.getNormalMatrix(W.modelViewMatrix), be.onBeforeRender(b, ve, ye, Ce, W, ke), be.transparent === !0 && be.side === vn && be.forceSinglePass === !1 ? (be.side = hi, be.needsUpdate = !0, b.renderBufferDirect(ye, ve, Ce, be, W, ke), be.side = ar, be.needsUpdate = !0, b.renderBufferDirect(ye, ve, Ce, be, W, ke), be.side = vn) : b.renderBufferDirect(ye, ve, Ce, be, W, ke), W.onAfterRender(b, ve, ye, Ce, be, ke);
    }
    function ri(W, ve, ye) {
      ve.isScene !== !0 && (ve = F);
      const Ce = se.get(W), be = x.state.lights, ke = x.state.shadowsArray, De = be.state.version, Qe = Me.getParameters(W, be.state, ke, ve, ye), it = Me.getProgramCacheKey(Qe);
      let mt = Ce.programs;
      Ce.environment = W.isMeshStandardMaterial ? ve.environment : null, Ce.fog = ve.fog, Ce.envMap = (W.isMeshStandardMaterial ? K : N).get(W.envMap || Ce.environment), Ce.envMapRotation = Ce.environment !== null && W.envMap === null ? ve.environmentRotation : W.envMapRotation, mt === void 0 && (W.addEventListener("dispose", ut), mt = /* @__PURE__ */ new Map(), Ce.programs = mt);
      let gt = mt.get(it);
      if (gt !== void 0) {
        if (Ce.currentProgram === gt && Ce.lightsStateVersion === De)
          return pe(W, Qe), gt;
      } else
        Qe.uniforms = Me.getUniforms(W), W.onBeforeCompile(Qe, b), gt = Me.acquireProgram(Qe, it), mt.set(it, gt), Ce.uniforms = Qe.uniforms;
      const lt = Ce.uniforms;
      return (!W.isShaderMaterial && !W.isRawShaderMaterial || W.clipping === !0) && (lt.clippingPlanes = Oe.uniform), pe(W, Qe), Ce.needsLights = Ue(W), Ce.lightsStateVersion = De, Ce.needsLights && (lt.ambientLightColor.value = be.state.ambient, lt.lightProbe.value = be.state.probe, lt.directionalLights.value = be.state.directional, lt.directionalLightShadows.value = be.state.directionalShadow, lt.spotLights.value = be.state.spot, lt.spotLightShadows.value = be.state.spotShadow, lt.rectAreaLights.value = be.state.rectArea, lt.ltc_1.value = be.state.rectAreaLTC1, lt.ltc_2.value = be.state.rectAreaLTC2, lt.pointLights.value = be.state.point, lt.pointLightShadows.value = be.state.pointShadow, lt.hemisphereLights.value = be.state.hemi, lt.directionalShadowMap.value = be.state.directionalShadowMap, lt.directionalShadowMatrix.value = be.state.directionalShadowMatrix, lt.spotShadowMap.value = be.state.spotShadowMap, lt.spotLightMatrix.value = be.state.spotLightMatrix, lt.spotLightMap.value = be.state.spotLightMap, lt.pointShadowMap.value = be.state.pointShadowMap, lt.pointShadowMatrix.value = be.state.pointShadowMatrix), Ce.currentProgram = gt, Ce.uniformsList = null, gt;
    }
    function ki(W) {
      if (W.uniformsList === null) {
        const ve = W.currentProgram.getUniforms();
        W.uniformsList = Nc.seqWithValue(ve.seq, W.uniforms);
      }
      return W.uniformsList;
    }
    function pe(W, ve) {
      const ye = se.get(W);
      ye.outputColorSpace = ve.outputColorSpace, ye.batching = ve.batching, ye.batchingColor = ve.batchingColor, ye.instancing = ve.instancing, ye.instancingColor = ve.instancingColor, ye.instancingMorph = ve.instancingMorph, ye.skinning = ve.skinning, ye.morphTargets = ve.morphTargets, ye.morphNormals = ve.morphNormals, ye.morphColors = ve.morphColors, ye.morphTargetsCount = ve.morphTargetsCount, ye.numClippingPlanes = ve.numClippingPlanes, ye.numIntersection = ve.numClipIntersection, ye.vertexAlphas = ve.vertexAlphas, ye.vertexTangents = ve.vertexTangents, ye.toneMapping = ve.toneMapping;
    }
    function xe(W, ve, ye, Ce, be) {
      ve.isScene !== !0 && (ve = F), z.resetTextureUnits();
      const ke = ve.fog, De = Ce.isMeshStandardMaterial ? ve.environment : null, Qe = E === null ? b.outputColorSpace : E.isXRRenderTarget === !0 ? E.texture.colorSpace : Jo, it = (Ce.isMeshStandardMaterial ? K : N).get(Ce.envMap || De), mt = Ce.vertexColors === !0 && !!ye.attributes.color && ye.attributes.color.itemSize === 4, gt = !!ye.attributes.tangent && (!!Ce.normalMap || Ce.anisotropy > 0), lt = !!ye.morphAttributes.position, Rt = !!ye.morphAttributes.normal, Ht = !!ye.morphAttributes.color;
      let $t = or;
      Ce.toneMapped && (E === null || E.isXRRenderTarget === !0) && ($t = b.toneMapping);
      const Dn = ye.morphAttributes.position || ye.morphAttributes.normal || ye.morphAttributes.color, kt = Dn !== void 0 ? Dn.length : 0, ht = se.get(Ce), mi = x.state.lights;
      if (ie === !0 && (ce === !0 || W !== w)) {
        const ai = W === w && Ce.id === y;
        Oe.setState(Ce, W, ai);
      }
      let Lt = !1;
      Ce.version === ht.__version ? (ht.needsLights && ht.lightsStateVersion !== mi.state.version || ht.outputColorSpace !== Qe || be.isBatchedMesh && ht.batching === !1 || !be.isBatchedMesh && ht.batching === !0 || be.isBatchedMesh && ht.batchingColor === !0 && be.colorTexture === null || be.isBatchedMesh && ht.batchingColor === !1 && be.colorTexture !== null || be.isInstancedMesh && ht.instancing === !1 || !be.isInstancedMesh && ht.instancing === !0 || be.isSkinnedMesh && ht.skinning === !1 || !be.isSkinnedMesh && ht.skinning === !0 || be.isInstancedMesh && ht.instancingColor === !0 && be.instanceColor === null || be.isInstancedMesh && ht.instancingColor === !1 && be.instanceColor !== null || be.isInstancedMesh && ht.instancingMorph === !0 && be.morphTexture === null || be.isInstancedMesh && ht.instancingMorph === !1 && be.morphTexture !== null || ht.envMap !== it || Ce.fog === !0 && ht.fog !== ke || ht.numClippingPlanes !== void 0 && (ht.numClippingPlanes !== Oe.numPlanes || ht.numIntersection !== Oe.numIntersection) || ht.vertexAlphas !== mt || ht.vertexTangents !== gt || ht.morphTargets !== lt || ht.morphNormals !== Rt || ht.morphColors !== Ht || ht.toneMapping !== $t || ht.morphTargetsCount !== kt) && (Lt = !0) : (Lt = !0, ht.__version = Ce.version);
      let kn = ht.currentProgram;
      Lt === !0 && (kn = ri(Ce, ve, be));
      let Zi = !1, Sn = !1, us = !1;
      const Yt = kn.getUniforms(), oi = ht.uniforms;
      if (B.useProgram(kn.program) && (Zi = !0, Sn = !0, us = !0), Ce.id !== y && (y = Ce.id, Sn = !0), Zi || w !== W) {
        B.buffers.depth.getReversed() ? (V.copy(W.projectionMatrix), Pb(V), Rb(V), Yt.setValue(Z, "projectionMatrix", V)) : Yt.setValue(Z, "projectionMatrix", W.projectionMatrix), Yt.setValue(Z, "viewMatrix", W.matrixWorldInverse);
        const vi = Yt.map.cameraPosition;
        vi !== void 0 && vi.setValue(Z, H.setFromMatrixPosition(W.matrixWorld)), J.logarithmicDepthBuffer && Yt.setValue(
          Z,
          "logDepthBufFC",
          2 / (Math.log(W.far + 1) / Math.LN2)
        ), (Ce.isMeshPhongMaterial || Ce.isMeshToonMaterial || Ce.isMeshLambertMaterial || Ce.isMeshBasicMaterial || Ce.isMeshStandardMaterial || Ce.isShaderMaterial) && Yt.setValue(Z, "isOrthographic", W.isOrthographicCamera === !0), w !== W && (w = W, Sn = !0, us = !0);
      }
      if (be.isSkinnedMesh) {
        Yt.setOptional(Z, be, "bindMatrix"), Yt.setOptional(Z, be, "bindMatrixInverse");
        const ai = be.skeleton;
        ai && (ai.boneTexture === null && ai.computeBoneTexture(), Yt.setValue(Z, "boneTexture", ai.boneTexture, z));
      }
      be.isBatchedMesh && (Yt.setOptional(Z, be, "batchingTexture"), Yt.setValue(Z, "batchingTexture", be._matricesTexture, z), Yt.setOptional(Z, be, "batchingIdTexture"), Yt.setValue(Z, "batchingIdTexture", be._indirectTexture, z), Yt.setOptional(Z, be, "batchingColorTexture"), be._colorsTexture !== null && Yt.setValue(Z, "batchingColorTexture", be._colorsTexture, z));
      const Gn = ye.morphAttributes;
      if ((Gn.position !== void 0 || Gn.normal !== void 0 || Gn.color !== void 0) && $e.update(be, ye, kn), (Sn || ht.receiveShadow !== be.receiveShadow) && (ht.receiveShadow = be.receiveShadow, Yt.setValue(Z, "receiveShadow", be.receiveShadow)), Ce.isMeshGouraudMaterial && Ce.envMap !== null && (oi.envMap.value = it, oi.flipEnvMap.value = it.isCubeTexture && it.isRenderTargetTexture === !1 ? -1 : 1), Ce.isMeshStandardMaterial && Ce.envMap === null && ve.environment !== null && (oi.envMapIntensity.value = ve.environmentIntensity), Sn && (Yt.setValue(Z, "toneMappingExposure", b.toneMappingExposure), ht.needsLights && Te(oi, us), ke && Ce.fog === !0 && Ee.refreshFogUniforms(oi, ke), Ee.refreshMaterialUniforms(oi, Ce, Q, ue, x.state.transmissionRenderTarget[W.id]), Nc.upload(Z, ki(ht), oi, z)), Ce.isShaderMaterial && Ce.uniformsNeedUpdate === !0 && (Nc.upload(Z, ki(ht), oi, z), Ce.uniformsNeedUpdate = !1), Ce.isSpriteMaterial && Yt.setValue(Z, "center", be.center), Yt.setValue(Z, "modelViewMatrix", be.modelViewMatrix), Yt.setValue(Z, "normalMatrix", be.normalMatrix), Yt.setValue(Z, "modelMatrix", be.matrixWorld), Ce.isShaderMaterial || Ce.isRawShaderMaterial) {
        const ai = Ce.uniformsGroups;
        for (let vi = 0, li = ai.length; vi < li; vi++) {
          const na = ai[vi];
          Se.update(na, kn), Se.bind(na, kn);
        }
      }
      return kn;
    }
    function Te(W, ve) {
      W.ambientLightColor.needsUpdate = ve, W.lightProbe.needsUpdate = ve, W.directionalLights.needsUpdate = ve, W.directionalLightShadows.needsUpdate = ve, W.pointLights.needsUpdate = ve, W.pointLightShadows.needsUpdate = ve, W.spotLights.needsUpdate = ve, W.spotLightShadows.needsUpdate = ve, W.rectAreaLights.needsUpdate = ve, W.hemisphereLights.needsUpdate = ve;
    }
    function Ue(W) {
      return W.isMeshLambertMaterial || W.isMeshToonMaterial || W.isMeshPhongMaterial || W.isMeshStandardMaterial || W.isShadowMaterial || W.isShaderMaterial && W.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return T;
    }, this.getActiveMipmapLevel = function() {
      return P;
    }, this.getRenderTarget = function() {
      return E;
    }, this.setRenderTargetTextures = function(W, ve, ye) {
      se.get(W.texture).__webglTexture = ve, se.get(W.depthTexture).__webglTexture = ye;
      const Ce = se.get(W);
      Ce.__hasExternalTextures = !0, Ce.__autoAllocateDepthBuffer = ye === void 0, Ce.__autoAllocateDepthBuffer || ne.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Ce.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(W, ve) {
      const ye = se.get(W);
      ye.__webglFramebuffer = ve, ye.__useDefaultFramebuffer = ve === void 0;
    }, this.setRenderTarget = function(W, ve = 0, ye = 0) {
      E = W, T = ve, P = ye;
      let Ce = !0, be = null, ke = !1, De = !1;
      if (W) {
        const it = se.get(W);
        if (it.__useDefaultFramebuffer !== void 0)
          B.bindFramebuffer(Z.FRAMEBUFFER, null), Ce = !1;
        else if (it.__webglFramebuffer === void 0)
          z.setupRenderTarget(W);
        else if (it.__hasExternalTextures)
          z.rebindTextures(W, se.get(W.texture).__webglTexture, se.get(W.depthTexture).__webglTexture);
        else if (W.depthBuffer) {
          const lt = W.depthTexture;
          if (it.__boundDepthTexture !== lt) {
            if (lt !== null && se.has(lt) && (W.width !== lt.image.width || W.height !== lt.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            z.setupDepthRenderbuffer(W);
          }
        }
        const mt = W.texture;
        (mt.isData3DTexture || mt.isDataArrayTexture || mt.isCompressedArrayTexture) && (De = !0);
        const gt = se.get(W).__webglFramebuffer;
        W.isWebGLCubeRenderTarget ? (Array.isArray(gt[ve]) ? be = gt[ve][ye] : be = gt[ve], ke = !0) : W.samples > 0 && z.useMultisampledRTT(W) === !1 ? be = se.get(W).__webglMultisampledFramebuffer : Array.isArray(gt) ? be = gt[ye] : be = gt, D.copy(W.viewport), U.copy(W.scissor), R = W.scissorTest;
      } else
        D.copy(j).multiplyScalar(Q).floor(), U.copy($).multiplyScalar(Q).floor(), R = q;
      if (B.bindFramebuffer(Z.FRAMEBUFFER, be) && Ce && B.drawBuffers(W, be), B.viewport(D), B.scissor(U), B.setScissorTest(R), ke) {
        const it = se.get(W.texture);
        Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + ve, it.__webglTexture, ye);
      } else if (De) {
        const it = se.get(W.texture), mt = ve || 0;
        Z.framebufferTextureLayer(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, it.__webglTexture, ye || 0, mt);
      }
      y = -1;
    }, this.readRenderTargetPixels = function(W, ve, ye, Ce, be, ke, De) {
      if (!(W && W.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Qe = se.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && De !== void 0 && (Qe = Qe[De]), Qe) {
        B.bindFramebuffer(Z.FRAMEBUFFER, Qe);
        try {
          const it = W.texture, mt = it.format, gt = it.type;
          if (!J.textureFormatReadable(mt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!J.textureTypeReadable(gt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ve >= 0 && ve <= W.width - Ce && ye >= 0 && ye <= W.height - be && Z.readPixels(ve, ye, Ce, be, Je.convert(mt), Je.convert(gt), ke);
        } finally {
          const it = E !== null ? se.get(E).__webglFramebuffer : null;
          B.bindFramebuffer(Z.FRAMEBUFFER, it);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(W, ve, ye, Ce, be, ke, De) {
      if (!(W && W.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Qe = se.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && De !== void 0 && (Qe = Qe[De]), Qe) {
        const it = W.texture, mt = it.format, gt = it.type;
        if (!J.textureFormatReadable(mt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!J.textureTypeReadable(gt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (ve >= 0 && ve <= W.width - Ce && ye >= 0 && ye <= W.height - be) {
          B.bindFramebuffer(Z.FRAMEBUFFER, Qe);
          const lt = Z.createBuffer();
          Z.bindBuffer(Z.PIXEL_PACK_BUFFER, lt), Z.bufferData(Z.PIXEL_PACK_BUFFER, ke.byteLength, Z.STREAM_READ), Z.readPixels(ve, ye, Ce, be, Je.convert(mt), Je.convert(gt), 0);
          const Rt = E !== null ? se.get(E).__webglFramebuffer : null;
          B.bindFramebuffer(Z.FRAMEBUFFER, Rt);
          const Ht = Z.fenceSync(Z.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Z.flush(), await Ab(Z, Ht, 4), Z.bindBuffer(Z.PIXEL_PACK_BUFFER, lt), Z.getBufferSubData(Z.PIXEL_PACK_BUFFER, 0, ke), Z.deleteBuffer(lt), Z.deleteSync(Ht), ke;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(W, ve = null, ye = 0) {
      W.isTexture !== !0 && (Da("WebGLRenderer: copyFramebufferToTexture function signature has changed."), ve = arguments[0] || null, W = arguments[1]);
      const Ce = Math.pow(2, -ye), be = Math.floor(W.image.width * Ce), ke = Math.floor(W.image.height * Ce), De = ve !== null ? ve.x : 0, Qe = ve !== null ? ve.y : 0;
      z.setTexture2D(W, 0), Z.copyTexSubImage2D(Z.TEXTURE_2D, ye, 0, 0, De, Qe, be, ke), B.unbindTexture();
    }, this.copyTextureToTexture = function(W, ve, ye = null, Ce = null, be = 0) {
      W.isTexture !== !0 && (Da("WebGLRenderer: copyTextureToTexture function signature has changed."), Ce = arguments[0] || null, W = arguments[1], ve = arguments[2], be = arguments[3] || 0, ye = null);
      let ke, De, Qe, it, mt, gt, lt, Rt, Ht;
      const $t = W.isCompressedTexture ? W.mipmaps[be] : W.image;
      ye !== null ? (ke = ye.max.x - ye.min.x, De = ye.max.y - ye.min.y, Qe = ye.isBox3 ? ye.max.z - ye.min.z : 1, it = ye.min.x, mt = ye.min.y, gt = ye.isBox3 ? ye.min.z : 0) : (ke = $t.width, De = $t.height, Qe = $t.depth || 1, it = 0, mt = 0, gt = 0), Ce !== null ? (lt = Ce.x, Rt = Ce.y, Ht = Ce.z) : (lt = 0, Rt = 0, Ht = 0);
      const Dn = Je.convert(ve.format), kt = Je.convert(ve.type);
      let ht;
      ve.isData3DTexture ? (z.setTexture3D(ve, 0), ht = Z.TEXTURE_3D) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? (z.setTexture2DArray(ve, 0), ht = Z.TEXTURE_2D_ARRAY) : (z.setTexture2D(ve, 0), ht = Z.TEXTURE_2D), Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, ve.flipY), Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha), Z.pixelStorei(Z.UNPACK_ALIGNMENT, ve.unpackAlignment);
      const mi = Z.getParameter(Z.UNPACK_ROW_LENGTH), Lt = Z.getParameter(Z.UNPACK_IMAGE_HEIGHT), kn = Z.getParameter(Z.UNPACK_SKIP_PIXELS), Zi = Z.getParameter(Z.UNPACK_SKIP_ROWS), Sn = Z.getParameter(Z.UNPACK_SKIP_IMAGES);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, $t.width), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, $t.height), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, it), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, mt), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, gt);
      const us = W.isDataArrayTexture || W.isData3DTexture, Yt = ve.isDataArrayTexture || ve.isData3DTexture;
      if (W.isRenderTargetTexture || W.isDepthTexture) {
        const oi = se.get(W), Gn = se.get(ve), ai = se.get(oi.__renderTarget), vi = se.get(Gn.__renderTarget);
        B.bindFramebuffer(Z.READ_FRAMEBUFFER, ai.__webglFramebuffer), B.bindFramebuffer(Z.DRAW_FRAMEBUFFER, vi.__webglFramebuffer);
        for (let li = 0; li < Qe; li++)
          us && Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, se.get(W).__webglTexture, be, gt + li), W.isDepthTexture ? (Yt && Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, se.get(ve).__webglTexture, be, Ht + li), Z.blitFramebuffer(it, mt, ke, De, lt, Rt, ke, De, Z.DEPTH_BUFFER_BIT, Z.NEAREST)) : Yt ? Z.copyTexSubImage3D(ht, be, lt, Rt, Ht + li, it, mt, ke, De) : Z.copyTexSubImage2D(ht, be, lt, Rt, Ht + li, it, mt, ke, De);
        B.bindFramebuffer(Z.READ_FRAMEBUFFER, null), B.bindFramebuffer(Z.DRAW_FRAMEBUFFER, null);
      } else
        Yt ? W.isDataTexture || W.isData3DTexture ? Z.texSubImage3D(ht, be, lt, Rt, Ht, ke, De, Qe, Dn, kt, $t.data) : ve.isCompressedArrayTexture ? Z.compressedTexSubImage3D(ht, be, lt, Rt, Ht, ke, De, Qe, Dn, $t.data) : Z.texSubImage3D(ht, be, lt, Rt, Ht, ke, De, Qe, Dn, kt, $t) : W.isDataTexture ? Z.texSubImage2D(Z.TEXTURE_2D, be, lt, Rt, ke, De, Dn, kt, $t.data) : W.isCompressedTexture ? Z.compressedTexSubImage2D(Z.TEXTURE_2D, be, lt, Rt, $t.width, $t.height, Dn, $t.data) : Z.texSubImage2D(Z.TEXTURE_2D, be, lt, Rt, ke, De, Dn, kt, $t);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, mi), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Lt), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, kn), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, Zi), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, Sn), be === 0 && ve.generateMipmaps && Z.generateMipmap(ht), B.unbindTexture();
    }, this.copyTextureToTexture3D = function(W, ve, ye = null, Ce = null, be = 0) {
      return W.isTexture !== !0 && (Da("WebGLRenderer: copyTextureToTexture3D function signature has changed."), ye = arguments[0] || null, Ce = arguments[1] || null, W = arguments[2], ve = arguments[3], be = arguments[4] || 0), Da('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(W, ve, ye, Ce, be);
    }, this.initRenderTarget = function(W) {
      se.get(W).__webglFramebuffer === void 0 && z.setupRenderTarget(W);
    }, this.initTexture = function(W) {
      W.isCubeTexture ? z.setTextureCube(W, 0) : W.isData3DTexture ? z.setTexture3D(W, 0) : W.isDataArrayTexture || W.isCompressedArrayTexture ? z.setTexture2DArray(W, 0) : z.setTexture2D(W, 0), B.unbindTexture();
    }, this.resetState = function() {
      T = 0, P = 0, E = null, B.reset(), bt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Ts;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    n.drawingBufferColorspace = It._getDrawingBufferColorSpace(e), n.unpackColorSpace = It._getUnpackColorSpace();
  }
}
class O2 extends cn {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Mi(), this.environmentIntensity = 1, this.environmentRotation = new Mi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class To extends _n {
  constructor(e = null, n = 1, i = 1, r, o, a, l, c, u = On, d = On, h, m) {
    super(null, a, l, c, u, d, r, o, h, m), this.isDataTexture = !0, this.image = { data: e, width: n, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Rr extends Si {
  constructor(e, n, i, r = 1) {
    super(e, n, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class Yi extends qr {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const iu = /* @__PURE__ */ new de(), su = /* @__PURE__ */ new de(), Km = /* @__PURE__ */ new Zt(), ga = /* @__PURE__ */ new Lf(), oc = /* @__PURE__ */ new Sl(), Dd = /* @__PURE__ */ new de(), Jm = /* @__PURE__ */ new de();
class ln extends cn {
  constructor(e = new Vt(), n = new Yi()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [0];
      for (let r = 1, o = n.count; r < o; r++)
        iu.fromBufferAttribute(n, r - 1), su.fromBufferAttribute(n, r), i[r] = i[r - 1], i[r] += iu.distanceTo(su);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, n) {
    const i = this.geometry, r = this.matrixWorld, o = e.params.Line.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), oc.copy(i.boundingSphere), oc.applyMatrix4(r), oc.radius += o, e.ray.intersectsSphere(oc) === !1) return;
    Km.copy(r).invert(), ga.copy(e.ray).applyMatrix4(Km);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, u = this.isLineSegments ? 2 : 1, d = i.index, m = i.attributes.position;
    if (d !== null) {
      const p = Math.max(0, a.start), v = Math.min(d.count, a.start + a.count);
      for (let _ = p, g = v - 1; _ < g; _ += u) {
        const x = d.getX(_), M = d.getX(_ + 1), S = ac(this, e, ga, c, x, M);
        S && n.push(S);
      }
      if (this.isLineLoop) {
        const _ = d.getX(v - 1), g = d.getX(p), x = ac(this, e, ga, c, _, g);
        x && n.push(x);
      }
    } else {
      const p = Math.max(0, a.start), v = Math.min(m.count, a.start + a.count);
      for (let _ = p, g = v - 1; _ < g; _ += u) {
        const x = ac(this, e, ga, c, _, _ + 1);
        x && n.push(x);
      }
      if (this.isLineLoop) {
        const _ = ac(this, e, ga, c, v - 1, p);
        _ && n.push(_);
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = r.length; o < a; o++) {
          const l = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
}
function ac(s, e, n, i, r, o) {
  const a = s.geometry.attributes.position;
  if (iu.fromBufferAttribute(a, r), su.fromBufferAttribute(a, o), n.distanceSqToSegment(iu, su, Dd, Jm) > i) return;
  Dd.applyMatrix4(s.matrixWorld);
  const c = e.ray.origin.distanceTo(Dd);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: Jm.clone().applyMatrix4(s.matrixWorld),
      index: r,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s
    };
}
const Qm = /* @__PURE__ */ new de(), ev = /* @__PURE__ */ new de();
class Bf extends ln {
  constructor(e, n) {
    super(e, n), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [];
      for (let r = 0, o = n.count; r < o; r += 2)
        Qm.fromBufferAttribute(n, r), ev.fromBufferAttribute(n, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + Qm.distanceTo(ev);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class z2 extends ln {
  constructor(e, n) {
    super(e, n), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class N2 extends _n {
  constructor(e, n, i, r, o, a, l, c, u) {
    super(e, n, i, r, o, a, l, c, u), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Bt, this.magFilter = o !== void 0 ? o : Bt, this.generateMipmaps = !1;
    const d = this;
    function h() {
      d.needsUpdate = !0, e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class tv extends _n {
  constructor(e, n, i, r, o, a, l, c, u) {
    super(e, n, i, r, o, a, l, c, u), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class cs {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, n);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return n;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPointAt(i / e));
    return n;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let i, r = this.getPoint(0), o = 0;
    n.push(0);
    for (let a = 1; a <= e; a++)
      i = this.getPoint(a / e), o += i.distanceTo(r), n.push(o), r = i;
    return this.cacheArcLengths = n, n;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, n) {
    const i = this.getLengths();
    let r = 0;
    const o = i.length;
    let a;
    n ? a = n : a = e * i[o - 1];
    let l = 0, c = o - 1, u;
    for (; l <= c; )
      if (r = Math.floor(l + (c - l) / 2), u = i[r] - a, u < 0)
        l = r + 1;
      else if (u > 0)
        c = r - 1;
      else {
        c = r;
        break;
      }
    if (r = c, i[r] === a)
      return r / (o - 1);
    const d = i[r], m = i[r + 1] - d, p = (a - d) / m;
    return (r + p) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, n) {
    let r = e - 1e-4, o = e + 1e-4;
    r < 0 && (r = 0), o > 1 && (o = 1);
    const a = this.getPoint(r), l = this.getPoint(o), c = n || (a.isVector2 ? new rt() : new de());
    return c.copy(l).sub(a).normalize(), c;
  }
  getTangentAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, n);
  }
  computeFrenetFrames(e, n) {
    const i = new de(), r = [], o = [], a = [], l = new de(), c = new Zt();
    for (let p = 0; p <= e; p++) {
      const v = p / e;
      r[p] = this.getTangentAt(v, new de());
    }
    o[0] = new de(), a[0] = new de();
    let u = Number.MAX_VALUE;
    const d = Math.abs(r[0].x), h = Math.abs(r[0].y), m = Math.abs(r[0].z);
    d <= u && (u = d, i.set(1, 0, 0)), h <= u && (u = h, i.set(0, 1, 0)), m <= u && i.set(0, 0, 1), l.crossVectors(r[0], i).normalize(), o[0].crossVectors(r[0], l), a[0].crossVectors(r[0], o[0]);
    for (let p = 1; p <= e; p++) {
      if (o[p] = o[p - 1].clone(), a[p] = a[p - 1].clone(), l.crossVectors(r[p - 1], r[p]), l.length() > Number.EPSILON) {
        l.normalize();
        const v = Math.acos(Fn(r[p - 1].dot(r[p]), -1, 1));
        o[p].applyMatrix4(c.makeRotationAxis(l, v));
      }
      a[p].crossVectors(r[p], o[p]);
    }
    if (n === !0) {
      let p = Math.acos(Fn(o[0].dot(o[e]), -1, 1));
      p /= e, r[0].dot(l.crossVectors(o[0], o[e])) > 0 && (p = -p);
      for (let v = 1; v <= e; v++)
        o[v].applyMatrix4(c.makeRotationAxis(r[v], p * v)), a[v].crossVectors(r[v], o[v]);
    }
    return {
      tangents: r,
      normals: o,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Vf extends cs {
  constructor(e = 0, n = 0, i = 1, r = 1, o = 0, a = Math.PI * 2, l = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = i, this.yRadius = r, this.aStartAngle = o, this.aEndAngle = a, this.aClockwise = l, this.aRotation = c;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += r;
    for (; o > r; ) o -= r;
    o < Number.EPSILON && (a ? o = 0 : o = r), this.aClockwise === !0 && !a && (o === r ? o = -r : o = o - r);
    const l = this.aStartAngle + e * o;
    let c = this.aX + this.xRadius * Math.cos(l), u = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation), h = Math.sin(this.aRotation), m = c - this.aX, p = u - this.aY;
      c = m * d - p * h + this.aX, u = m * h + p * d + this.aY;
    }
    return i.set(c, u);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class B2 extends Vf {
  constructor(e, n, i, r, o, a) {
    super(e, n, i, i, r, o, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Gf() {
  let s = 0, e = 0, n = 0, i = 0;
  function r(o, a, l, c) {
    s = o, e = l, n = -3 * o + 3 * a - 2 * l - c, i = 2 * o - 2 * a + l + c;
  }
  return {
    initCatmullRom: function(o, a, l, c, u) {
      r(a, l, u * (l - o), u * (c - a));
    },
    initNonuniformCatmullRom: function(o, a, l, c, u, d, h) {
      let m = (a - o) / u - (l - o) / (u + d) + (l - a) / d, p = (l - a) / d - (c - a) / (d + h) + (c - l) / h;
      m *= d, p *= d, r(a, l, m, p);
    },
    calc: function(o) {
      const a = o * o, l = a * o;
      return s + e * o + n * a + i * l;
    }
  };
}
const lc = /* @__PURE__ */ new de(), kd = /* @__PURE__ */ new Gf(), Id = /* @__PURE__ */ new Gf(), Ld = /* @__PURE__ */ new Gf();
class V2 extends cs {
  constructor(e = [], n = !1, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = i, this.tension = r;
  }
  getPoint(e, n = new de()) {
    const i = n, r = this.points, o = r.length, a = (o - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(a), c = a - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o : c === 0 && l === o - 1 && (l = o - 2, c = 1);
    let u, d;
    this.closed || l > 0 ? u = r[(l - 1) % o] : (lc.subVectors(r[0], r[1]).add(r[0]), u = lc);
    const h = r[l % o], m = r[(l + 1) % o];
    if (this.closed || l + 2 < o ? d = r[(l + 2) % o] : (lc.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), d = lc), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(u.distanceToSquared(h), p), _ = Math.pow(h.distanceToSquared(m), p), g = Math.pow(m.distanceToSquared(d), p);
      _ < 1e-4 && (_ = 1), v < 1e-4 && (v = _), g < 1e-4 && (g = _), kd.initNonuniformCatmullRom(u.x, h.x, m.x, d.x, v, _, g), Id.initNonuniformCatmullRom(u.y, h.y, m.y, d.y, v, _, g), Ld.initNonuniformCatmullRom(u.z, h.z, m.z, d.z, v, _, g);
    } else this.curveType === "catmullrom" && (kd.initCatmullRom(u.x, h.x, m.x, d.x, this.tension), Id.initCatmullRom(u.y, h.y, m.y, d.y, this.tension), Ld.initCatmullRom(u.z, h.z, m.z, d.z, this.tension));
    return i.set(
      kd.calc(c),
      Id.calc(c),
      Ld.calc(c)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(new de().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function nv(s, e, n, i, r) {
  const o = (i - e) * 0.5, a = (r - n) * 0.5, l = s * s, c = s * l;
  return (2 * n - 2 * i + o + a) * c + (-3 * n + 3 * i - 2 * o - a) * l + o * s + n;
}
function G2(s, e) {
  const n = 1 - s;
  return n * n * e;
}
function H2(s, e) {
  return 2 * (1 - s) * s * e;
}
function $2(s, e) {
  return s * s * e;
}
function Xa(s, e, n, i) {
  return G2(s, e) + H2(s, n) + $2(s, i);
}
function W2(s, e) {
  const n = 1 - s;
  return n * n * n * e;
}
function X2(s, e) {
  const n = 1 - s;
  return 3 * n * n * s * e;
}
function j2(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function Y2(s, e) {
  return s * s * s * e;
}
function ja(s, e, n, i, r) {
  return W2(s, e) + X2(s, n) + j2(s, i) + Y2(s, r);
}
class my extends cs {
  constructor(e = new rt(), n = new rt(), i = new rt(), r = new rt()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = r;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      ja(e, r.x, o.x, a.x, l.x),
      ja(e, r.y, o.y, a.y, l.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class hl extends cs {
  constructor(e = new de(), n = new de(), i = new de(), r = new de()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = r;
  }
  getPoint(e, n = new de()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      ja(e, r.x, o.x, a.x, l.x),
      ja(e, r.y, o.y, a.y, l.y),
      ja(e, r.z, o.z, a.z, l.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class vy extends cs {
  constructor(e = new rt(), n = new rt()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new rt()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new rt()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class q2 extends cs {
  constructor(e = new de(), n = new de()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new de()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new de()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class gy extends cs {
  constructor(e = new rt(), n = new rt(), i = new rt()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2;
    return i.set(
      Xa(e, r.x, o.x, a.x),
      Xa(e, r.y, o.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Z2 extends cs {
  constructor(e = new de(), n = new de(), i = new de()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new de()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2;
    return i.set(
      Xa(e, r.x, o.x, a.x),
      Xa(e, r.y, o.y, a.y),
      Xa(e, r.z, o.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class yy extends cs {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, n = new rt()) {
    const i = n, r = this.points, o = (r.length - 1) * e, a = Math.floor(o), l = o - a, c = r[a === 0 ? a : a - 1], u = r[a], d = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return i.set(
      nv(l, c.x, u.x, d.x, h.x),
      nv(l, c.y, u.y, d.y, h.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(new rt().fromArray(r));
    }
    return this;
  }
}
var iv = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: B2,
  CatmullRomCurve3: V2,
  CubicBezierCurve: my,
  CubicBezierCurve3: hl,
  EllipseCurve: Vf,
  LineCurve: vy,
  LineCurve3: q2,
  QuadraticBezierCurve: gy,
  QuadraticBezierCurve3: Z2,
  SplineCurve: yy
});
class Hf extends cs {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new iv[i](n, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, n) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let o = 0;
    for (; o < r.length; ) {
      if (r[o] >= i) {
        const a = r[o] - i, l = this.curves[o], c = l.getLength(), u = c === 0 ? 0 : 1 - a / c;
        return l.getPointAt(u, n);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      n += this.curves[i].getLength(), e.push(n);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let i;
    for (let r = 0, o = this.curves; r < o.length; r++) {
      const a = o[r], l = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, c = a.getPoints(l);
      for (let u = 0; u < c.length; u++) {
        const d = c[u];
        i && i.equals(d) || (n.push(d), i = d);
      }
    }
    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const r = e.curves[n];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let n = 0, i = this.curves.length; n < i; n++) {
      const r = this.curves[n];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const r = e.curves[n];
      this.curves.push(new iv[r.type]().fromJSON(r));
    }
    return this;
  }
}
class sv extends Hf {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new rt(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, i = e.length; n < i; n++)
      this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const i = new vy(this.currentPoint.clone(), new rt(e, n));
    return this.curves.push(i), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, i, r) {
    const o = new gy(
      this.currentPoint.clone(),
      new rt(e, n),
      new rt(i, r)
    );
    return this.curves.push(o), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, n, i, r, o, a) {
    const l = new my(
      this.currentPoint.clone(),
      new rt(e, n),
      new rt(i, r),
      new rt(o, a)
    );
    return this.curves.push(l), this.currentPoint.set(o, a), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e), i = new yy(n);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, i, r, o, a) {
    const l = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + l,
      n + c,
      i,
      r,
      o,
      a
    ), this;
  }
  absarc(e, n, i, r, o, a) {
    return this.absellipse(e, n, i, i, r, o, a), this;
  }
  ellipse(e, n, i, r, o, a, l, c) {
    const u = this.currentPoint.x, d = this.currentPoint.y;
    return this.absellipse(e + u, n + d, i, r, o, a, l, c), this;
  }
  absellipse(e, n, i, r, o, a, l, c) {
    const u = new Vf(e, n, i, r, o, a, l, c);
    if (this.curves.length > 0) {
      const h = u.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(u);
    const d = u.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Ru extends Vt {
  constructor(e = 1, n = 32, i = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: n,
      thetaStart: i,
      thetaLength: r
    }, n = Math.max(3, n);
    const o = [], a = [], l = [], c = [], u = new de(), d = new rt();
    a.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let h = 0, m = 3; h <= n; h++, m += 3) {
      const p = i + h / n * r;
      u.x = e * Math.cos(p), u.y = e * Math.sin(p), a.push(u.x, u.y, u.z), l.push(0, 0, 1), d.x = (a[m] / e + 1) / 2, d.y = (a[m + 1] / e + 1) / 2, c.push(d.x, d.y);
    }
    for (let h = 1; h <= n; h++)
      o.push(h, h + 1, 0);
    this.setIndex(o), this.setAttribute("position", new Pt(a, 3)), this.setAttribute("normal", new Pt(l, 3)), this.setAttribute("uv", new Pt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ru(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Ln extends Vt {
  constructor(e = 1, n = 1, i = 1, r = 32, o = 1, a = !1, l = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: i,
      radialSegments: r,
      heightSegments: o,
      openEnded: a,
      thetaStart: l,
      thetaLength: c
    };
    const u = this;
    r = Math.floor(r), o = Math.floor(o);
    const d = [], h = [], m = [], p = [];
    let v = 0;
    const _ = [], g = i / 2;
    let x = 0;
    M(), a === !1 && (e > 0 && S(!0), n > 0 && S(!1)), this.setIndex(d), this.setAttribute("position", new Pt(h, 3)), this.setAttribute("normal", new Pt(m, 3)), this.setAttribute("uv", new Pt(p, 2));
    function M() {
      const b = new de(), C = new de();
      let T = 0;
      const P = (n - e) / i;
      for (let E = 0; E <= o; E++) {
        const y = [], w = E / o, D = w * (n - e) + e;
        for (let U = 0; U <= r; U++) {
          const R = U / r, O = R * c + l, A = Math.sin(O), G = Math.cos(O);
          C.x = D * A, C.y = -w * i + g, C.z = D * G, h.push(C.x, C.y, C.z), b.set(A, P, G).normalize(), m.push(b.x, b.y, b.z), p.push(R, 1 - w), y.push(v++);
        }
        _.push(y);
      }
      for (let E = 0; E < r; E++)
        for (let y = 0; y < o; y++) {
          const w = _[y][E], D = _[y + 1][E], U = _[y + 1][E + 1], R = _[y][E + 1];
          (e > 0 || y !== 0) && (d.push(w, D, R), T += 3), (n > 0 || y !== o - 1) && (d.push(D, U, R), T += 3);
        }
      u.addGroup(x, T, 0), x += T;
    }
    function S(b) {
      const C = v, T = new rt(), P = new de();
      let E = 0;
      const y = b === !0 ? e : n, w = b === !0 ? 1 : -1;
      for (let U = 1; U <= r; U++)
        h.push(0, g * w, 0), m.push(0, w, 0), p.push(0.5, 0.5), v++;
      const D = v;
      for (let U = 0; U <= r; U++) {
        const O = U / r * c + l, A = Math.cos(O), G = Math.sin(O);
        P.x = y * G, P.y = g * w, P.z = y * A, h.push(P.x, P.y, P.z), m.push(0, w, 0), T.x = A * 0.5 + 0.5, T.y = G * 0.5 * w + 0.5, p.push(T.x, T.y), v++;
      }
      for (let U = 0; U < r; U++) {
        const R = C + U, O = D + U;
        b === !0 ? d.push(O, O + 1, R) : d.push(O + 1, O, R), E += 3;
      }
      u.addGroup(x, E, b === !0 ? 1 : 2), x += E;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Ln(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class $f extends Ln {
  constructor(e = 1, n = 1, i = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(0, e, n, i, r, o, a, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new $f(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Wf extends Vt {
  constructor(e = [], n = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: n,
      radius: i,
      detail: r
    };
    const o = [], a = [];
    l(r), u(i), d(), this.setAttribute("position", new Pt(o, 3)), this.setAttribute("normal", new Pt(o.slice(), 3)), this.setAttribute("uv", new Pt(a, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(M) {
      const S = new de(), b = new de(), C = new de();
      for (let T = 0; T < n.length; T += 3)
        p(n[T + 0], S), p(n[T + 1], b), p(n[T + 2], C), c(S, b, C, M);
    }
    function c(M, S, b, C) {
      const T = C + 1, P = [];
      for (let E = 0; E <= T; E++) {
        P[E] = [];
        const y = M.clone().lerp(b, E / T), w = S.clone().lerp(b, E / T), D = T - E;
        for (let U = 0; U <= D; U++)
          U === 0 && E === T ? P[E][U] = y : P[E][U] = y.clone().lerp(w, U / D);
      }
      for (let E = 0; E < T; E++)
        for (let y = 0; y < 2 * (T - E) - 1; y++) {
          const w = Math.floor(y / 2);
          y % 2 === 0 ? (m(P[E][w + 1]), m(P[E + 1][w]), m(P[E][w])) : (m(P[E][w + 1]), m(P[E + 1][w + 1]), m(P[E + 1][w]));
        }
    }
    function u(M) {
      const S = new de();
      for (let b = 0; b < o.length; b += 3)
        S.x = o[b + 0], S.y = o[b + 1], S.z = o[b + 2], S.normalize().multiplyScalar(M), o[b + 0] = S.x, o[b + 1] = S.y, o[b + 2] = S.z;
    }
    function d() {
      const M = new de();
      for (let S = 0; S < o.length; S += 3) {
        M.x = o[S + 0], M.y = o[S + 1], M.z = o[S + 2];
        const b = g(M) / 2 / Math.PI + 0.5, C = x(M) / Math.PI + 0.5;
        a.push(b, 1 - C);
      }
      v(), h();
    }
    function h() {
      for (let M = 0; M < a.length; M += 6) {
        const S = a[M + 0], b = a[M + 2], C = a[M + 4], T = Math.max(S, b, C), P = Math.min(S, b, C);
        T > 0.9 && P < 0.1 && (S < 0.2 && (a[M + 0] += 1), b < 0.2 && (a[M + 2] += 1), C < 0.2 && (a[M + 4] += 1));
      }
    }
    function m(M) {
      o.push(M.x, M.y, M.z);
    }
    function p(M, S) {
      const b = M * 3;
      S.x = e[b + 0], S.y = e[b + 1], S.z = e[b + 2];
    }
    function v() {
      const M = new de(), S = new de(), b = new de(), C = new de(), T = new rt(), P = new rt(), E = new rt();
      for (let y = 0, w = 0; y < o.length; y += 9, w += 6) {
        M.set(o[y + 0], o[y + 1], o[y + 2]), S.set(o[y + 3], o[y + 4], o[y + 5]), b.set(o[y + 6], o[y + 7], o[y + 8]), T.set(a[w + 0], a[w + 1]), P.set(a[w + 2], a[w + 3]), E.set(a[w + 4], a[w + 5]), C.copy(M).add(S).add(b).divideScalar(3);
        const D = g(C);
        _(T, w + 0, M, D), _(P, w + 2, S, D), _(E, w + 4, b, D);
      }
    }
    function _(M, S, b, C) {
      C < 0 && M.x === 1 && (a[S] = M.x - 1), b.x === 0 && b.z === 0 && (a[S] = C / 2 / Math.PI + 0.5);
    }
    function g(M) {
      return Math.atan2(M.z, -M.x);
    }
    function x(M) {
      return Math.atan2(-M.y, Math.sqrt(M.x * M.x + M.z * M.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wf(e.vertices, e.indices, e.radius, e.details);
  }
}
class xy extends sv {
  constructor(e) {
    super(e), this.uuid = Yr(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const n = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      n[i] = this.holes[i].getPoints(e);
    return n;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const r = e.holes[n];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let n = 0, i = this.holes.length; n < i; n++) {
      const r = this.holes[n];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const r = e.holes[n];
      this.holes.push(new sv().fromJSON(r));
    }
    return this;
  }
}
const K2 = {
  triangulate: function(s, e, n = 2) {
    const i = e && e.length, r = i ? e[0] * n : s.length;
    let o = _y(s, 0, r, n, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let l, c, u, d, h, m, p;
    if (i && (o = nT(s, e, o, n)), s.length > 80 * n) {
      l = u = s[0], c = d = s[1];
      for (let v = n; v < r; v += n)
        h = s[v], m = s[v + 1], h < l && (l = h), m < c && (c = m), h > u && (u = h), m > d && (d = m);
      p = Math.max(u - l, d - c), p = p !== 0 ? 32767 / p : 0;
    }
    return fl(o, a, n, l, c, p, 0), a;
  }
};
function _y(s, e, n, i, r) {
  let o, a;
  if (r === fT(s, e, n, i) > 0)
    for (o = e; o < n; o += i) a = rv(o, s[o], s[o + 1], a);
  else
    for (o = n - i; o >= e; o -= i) a = rv(o, s[o], s[o + 1], a);
  return a && Du(a, a.next) && (ml(a), a = a.next), a;
}
function Xr(s, e) {
  if (!s) return s;
  e || (e = s);
  let n = s, i;
  do
    if (i = !1, !n.steiner && (Du(n, n.next) || hn(n.prev, n, n.next) === 0)) {
      if (ml(n), n = e = n.prev, n === n.next) break;
      i = !0;
    } else
      n = n.next;
  while (i || n !== e);
  return e;
}
function fl(s, e, n, i, r, o, a) {
  if (!s) return;
  !a && o && aT(s, i, r, o);
  let l = s, c, u;
  for (; s.prev !== s.next; ) {
    if (c = s.prev, u = s.next, o ? Q2(s, i, r, o) : J2(s)) {
      e.push(c.i / n | 0), e.push(s.i / n | 0), e.push(u.i / n | 0), ml(s), s = u.next, l = u.next;
      continue;
    }
    if (s = u, s === l) {
      a ? a === 1 ? (s = eT(Xr(s), e, n), fl(s, e, n, i, r, o, 2)) : a === 2 && tT(s, e, n, i, r, o) : fl(Xr(s), e, n, i, r, o, 1);
      break;
    }
  }
}
function J2(s) {
  const e = s.prev, n = s, i = s.next;
  if (hn(e, n, i) >= 0) return !1;
  const r = e.x, o = n.x, a = i.x, l = e.y, c = n.y, u = i.y, d = r < o ? r < a ? r : a : o < a ? o : a, h = l < c ? l < u ? l : u : c < u ? c : u, m = r > o ? r > a ? r : a : o > a ? o : a, p = l > c ? l > u ? l : u : c > u ? c : u;
  let v = i.next;
  for (; v !== e; ) {
    if (v.x >= d && v.x <= m && v.y >= h && v.y <= p && Eo(r, l, o, c, a, u, v.x, v.y) && hn(v.prev, v, v.next) >= 0) return !1;
    v = v.next;
  }
  return !0;
}
function Q2(s, e, n, i) {
  const r = s.prev, o = s, a = s.next;
  if (hn(r, o, a) >= 0) return !1;
  const l = r.x, c = o.x, u = a.x, d = r.y, h = o.y, m = a.y, p = l < c ? l < u ? l : u : c < u ? c : u, v = d < h ? d < m ? d : m : h < m ? h : m, _ = l > c ? l > u ? l : u : c > u ? c : u, g = d > h ? d > m ? d : m : h > m ? h : m, x = Zh(p, v, e, n, i), M = Zh(_, g, e, n, i);
  let S = s.prevZ, b = s.nextZ;
  for (; S && S.z >= x && b && b.z <= M; ) {
    if (S.x >= p && S.x <= _ && S.y >= v && S.y <= g && S !== r && S !== a && Eo(l, d, c, h, u, m, S.x, S.y) && hn(S.prev, S, S.next) >= 0 || (S = S.prevZ, b.x >= p && b.x <= _ && b.y >= v && b.y <= g && b !== r && b !== a && Eo(l, d, c, h, u, m, b.x, b.y) && hn(b.prev, b, b.next) >= 0)) return !1;
    b = b.nextZ;
  }
  for (; S && S.z >= x; ) {
    if (S.x >= p && S.x <= _ && S.y >= v && S.y <= g && S !== r && S !== a && Eo(l, d, c, h, u, m, S.x, S.y) && hn(S.prev, S, S.next) >= 0) return !1;
    S = S.prevZ;
  }
  for (; b && b.z <= M; ) {
    if (b.x >= p && b.x <= _ && b.y >= v && b.y <= g && b !== r && b !== a && Eo(l, d, c, h, u, m, b.x, b.y) && hn(b.prev, b, b.next) >= 0) return !1;
    b = b.nextZ;
  }
  return !0;
}
function eT(s, e, n) {
  let i = s;
  do {
    const r = i.prev, o = i.next.next;
    !Du(r, o) && by(r, i, i.next, o) && pl(r, o) && pl(o, r) && (e.push(r.i / n | 0), e.push(i.i / n | 0), e.push(o.i / n | 0), ml(i), ml(i.next), i = s = o), i = i.next;
  } while (i !== s);
  return Xr(i);
}
function tT(s, e, n, i, r, o) {
  let a = s;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && uT(a, l)) {
        let c = wy(a, l);
        a = Xr(a, a.next), c = Xr(c, c.next), fl(a, e, n, i, r, o, 0), fl(c, e, n, i, r, o, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== s);
}
function nT(s, e, n, i) {
  const r = [];
  let o, a, l, c, u;
  for (o = 0, a = e.length; o < a; o++)
    l = e[o] * i, c = o < a - 1 ? e[o + 1] * i : s.length, u = _y(s, l, c, i, !1), u === u.next && (u.steiner = !0), r.push(cT(u));
  for (r.sort(iT), o = 0; o < r.length; o++)
    n = sT(r[o], n);
  return n;
}
function iT(s, e) {
  return s.x - e.x;
}
function sT(s, e) {
  const n = rT(s, e);
  if (!n)
    return e;
  const i = wy(n, s);
  return Xr(i, i.next), Xr(n, n.next);
}
function rT(s, e) {
  let n = e, i = -1 / 0, r;
  const o = s.x, a = s.y;
  do {
    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
      const m = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (m <= o && m > i && (i = m, r = n.x < n.next.x ? n : n.next, m === o))
        return r;
    }
    n = n.next;
  } while (n !== e);
  if (!r) return null;
  const l = r, c = r.x, u = r.y;
  let d = 1 / 0, h;
  n = r;
  do
    o >= n.x && n.x >= c && o !== n.x && Eo(a < u ? o : i, a, c, u, a < u ? i : o, a, n.x, n.y) && (h = Math.abs(a - n.y) / (o - n.x), pl(n, s) && (h < d || h === d && (n.x > r.x || n.x === r.x && oT(r, n))) && (r = n, d = h)), n = n.next;
  while (n !== l);
  return r;
}
function oT(s, e) {
  return hn(s.prev, s, e.prev) < 0 && hn(e.next, s, s.next) < 0;
}
function aT(s, e, n, i) {
  let r = s;
  do
    r.z === 0 && (r.z = Zh(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== s);
  r.prevZ.nextZ = null, r.prevZ = null, lT(r);
}
function lT(s) {
  let e, n, i, r, o, a, l, c, u = 1;
  do {
    for (n = s, s = null, o = null, a = 0; n; ) {
      for (a++, i = n, l = 0, e = 0; e < u && (l++, i = i.nextZ, !!i); e++)
        ;
      for (c = u; l > 0 || c > 0 && i; )
        l !== 0 && (c === 0 || !i || n.z <= i.z) ? (r = n, n = n.nextZ, l--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : s = r, r.prevZ = o, o = r;
      n = i;
    }
    o.nextZ = null, u *= 2;
  } while (a > 1);
  return s;
}
function Zh(s, e, n, i, r) {
  return s = (s - n) * r | 0, e = (e - i) * r | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function cT(s) {
  let e = s, n = s;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== s);
  return n;
}
function Eo(s, e, n, i, r, o, a, l) {
  return (r - a) * (e - l) >= (s - a) * (o - l) && (s - a) * (i - l) >= (n - a) * (e - l) && (n - a) * (o - l) >= (r - a) * (i - l);
}
function uT(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !dT(s, e) && // dones't intersect other edges
  (pl(s, e) && pl(e, s) && hT(s, e) && // locally visible
  (hn(s.prev, s, e.prev) || hn(s, e.prev, e)) || // does not create opposite-facing sectors
  Du(s, e) && hn(s.prev, s, s.next) > 0 && hn(e.prev, e, e.next) > 0);
}
function hn(s, e, n) {
  return (e.y - s.y) * (n.x - e.x) - (e.x - s.x) * (n.y - e.y);
}
function Du(s, e) {
  return s.x === e.x && s.y === e.y;
}
function by(s, e, n, i) {
  const r = uc(hn(s, e, n)), o = uc(hn(s, e, i)), a = uc(hn(n, i, s)), l = uc(hn(n, i, e));
  return !!(r !== o && a !== l || r === 0 && cc(s, n, e) || o === 0 && cc(s, i, e) || a === 0 && cc(n, s, i) || l === 0 && cc(n, e, i));
}
function cc(s, e, n) {
  return e.x <= Math.max(s.x, n.x) && e.x >= Math.min(s.x, n.x) && e.y <= Math.max(s.y, n.y) && e.y >= Math.min(s.y, n.y);
}
function uc(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function dT(s, e) {
  let n = s;
  do {
    if (n.i !== s.i && n.next.i !== s.i && n.i !== e.i && n.next.i !== e.i && by(n, n.next, s, e)) return !0;
    n = n.next;
  } while (n !== s);
  return !1;
}
function pl(s, e) {
  return hn(s.prev, s, s.next) < 0 ? hn(s, e, s.next) >= 0 && hn(s, s.prev, e) >= 0 : hn(s, e, s.prev) < 0 || hn(s, s.next, e) < 0;
}
function hT(s, e) {
  let n = s, i = !1;
  const r = (s.x + e.x) / 2, o = (s.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
  while (n !== s);
  return i;
}
function wy(s, e) {
  const n = new Kh(s.i, s.x, s.y), i = new Kh(e.i, e.x, e.y), r = s.next, o = e.prev;
  return s.next = e, e.prev = s, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
}
function rv(s, e, n, i) {
  const r = new Kh(s, e, n);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function ml(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Kh(s, e, n) {
  this.i = s, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function fT(s, e, n, i) {
  let r = 0;
  for (let o = e, a = n - i; o < n; o += i)
    r += (s[a] - s[o]) * (s[o + 1] + s[a + 1]), a = o;
  return r;
}
class Ya {
  // calculate area of the contour polygon
  static area(e) {
    const n = e.length;
    let i = 0;
    for (let r = n - 1, o = 0; o < n; r = o++)
      i += e[r].x * e[o].y - e[o].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Ya.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const i = [], r = [], o = [];
    ov(e), av(i, e);
    let a = e.length;
    n.forEach(ov);
    for (let c = 0; c < n.length; c++)
      r.push(a), a += n[c].length, av(i, n[c]);
    const l = K2.triangulate(i, r);
    for (let c = 0; c < l.length; c += 3)
      o.push(l.slice(c, c + 3));
    return o;
  }
}
function ov(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function av(s, e) {
  for (let n = 0; n < e.length; n++)
    s.push(e[n].x), s.push(e[n].y);
}
class Ao extends Wf {
  constructor(e = 1, n = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, r, e, n), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  static fromJSON(e) {
    return new Ao(e.radius, e.detail);
  }
}
class Xf extends Vt {
  constructor(e = new xy([new rt(0, 0.5), new rt(-0.5, -0.5), new rt(0.5, -0.5)]), n = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const i = [], r = [], o = [], a = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      u(e);
    else
      for (let d = 0; d < e.length; d++)
        u(e[d]), this.addGroup(l, c, d), l += c, c = 0;
    this.setIndex(i), this.setAttribute("position", new Pt(r, 3)), this.setAttribute("normal", new Pt(o, 3)), this.setAttribute("uv", new Pt(a, 2));
    function u(d) {
      const h = r.length / 3, m = d.extractPoints(n);
      let p = m.shape;
      const v = m.holes;
      Ya.isClockWise(p) === !1 && (p = p.reverse());
      for (let g = 0, x = v.length; g < x; g++) {
        const M = v[g];
        Ya.isClockWise(M) === !0 && (v[g] = M.reverse());
      }
      const _ = Ya.triangulateShape(p, v);
      for (let g = 0, x = v.length; g < x; g++) {
        const M = v[g];
        p = p.concat(M);
      }
      for (let g = 0, x = p.length; g < x; g++) {
        const M = p[g];
        r.push(M.x, M.y, 0), o.push(0, 0, 1), a.push(M.x, M.y);
      }
      for (let g = 0, x = _.length; g < x; g++) {
        const M = _[g], S = M[0] + h, b = M[1] + h, C = M[2] + h;
        i.push(S, b, C), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes;
    return pT(n, e);
  }
  static fromJSON(e, n) {
    const i = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const a = n[e.shapes[r]];
      i.push(a);
    }
    return new Xf(i, e.curveSegments);
  }
}
function pT(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class ku extends Vt {
  constructor(e = 1, n = 32, i = 16, r = 0, o = Math.PI * 2, a = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: i,
      phiStart: r,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, n = Math.max(3, Math.floor(n)), i = Math.max(2, Math.floor(i));
    const c = Math.min(a + l, Math.PI);
    let u = 0;
    const d = [], h = new de(), m = new de(), p = [], v = [], _ = [], g = [];
    for (let x = 0; x <= i; x++) {
      const M = [], S = x / i;
      let b = 0;
      x === 0 && a === 0 ? b = 0.5 / n : x === i && c === Math.PI && (b = -0.5 / n);
      for (let C = 0; C <= n; C++) {
        const T = C / n;
        h.x = -e * Math.cos(r + T * o) * Math.sin(a + S * l), h.y = e * Math.cos(a + S * l), h.z = e * Math.sin(r + T * o) * Math.sin(a + S * l), v.push(h.x, h.y, h.z), m.copy(h).normalize(), _.push(m.x, m.y, m.z), g.push(T + b, 1 - S), M.push(u++);
      }
      d.push(M);
    }
    for (let x = 0; x < i; x++)
      for (let M = 0; M < n; M++) {
        const S = d[x][M + 1], b = d[x][M], C = d[x + 1][M], T = d[x + 1][M + 1];
        (x !== 0 || a > 0) && p.push(S, b, T), (x !== i - 1 || c < Math.PI) && p.push(b, C, T);
      }
    this.setIndex(p), this.setAttribute("position", new Pt(v, 3)), this.setAttribute("normal", new Pt(_, 3)), this.setAttribute("uv", new Pt(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ku(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Lr extends Vt {
  constructor(e = 1, n = 0.4, i = 12, r = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: n,
      radialSegments: i,
      tubularSegments: r,
      arc: o
    }, i = Math.floor(i), r = Math.floor(r);
    const a = [], l = [], c = [], u = [], d = new de(), h = new de(), m = new de();
    for (let p = 0; p <= i; p++)
      for (let v = 0; v <= r; v++) {
        const _ = v / r * o, g = p / i * Math.PI * 2;
        h.x = (e + n * Math.cos(g)) * Math.cos(_), h.y = (e + n * Math.cos(g)) * Math.sin(_), h.z = n * Math.sin(g), l.push(h.x, h.y, h.z), d.x = e * Math.cos(_), d.y = e * Math.sin(_), m.subVectors(h, d).normalize(), c.push(m.x, m.y, m.z), u.push(v / r), u.push(p / i);
      }
    for (let p = 1; p <= i; p++)
      for (let v = 1; v <= r; v++) {
        const _ = (r + 1) * p + v - 1, g = (r + 1) * (p - 1) + v - 1, x = (r + 1) * (p - 1) + v, M = (r + 1) * p + v;
        a.push(_, g, M), a.push(g, x, M);
      }
    this.setIndex(a), this.setAttribute("position", new Pt(l, 3)), this.setAttribute("normal", new Pt(c, 3)), this.setAttribute("uv", new Pt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Lr(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class mT extends zn {
  static get type() {
    return "RawShaderMaterial";
  }
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0;
  }
}
class vT extends qr {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Mt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Mt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kf, this.normalScale = new rt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Mi(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class gT extends qr {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = kf, this.normalScale = new rt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
const lv = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class yT {
  constructor(e, n, i) {
    const r = this;
    let o = !1, a = 0, l = 0, c;
    const u = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = i, this.itemStart = function(d) {
      l++, o === !1 && r.onStart !== void 0 && r.onStart(d, a, l), o = !0;
    }, this.itemEnd = function(d) {
      a++, r.onProgress !== void 0 && r.onProgress(d, a, l), a === l && (o = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(d) {
      r.onError !== void 0 && r.onError(d);
    }, this.resolveURL = function(d) {
      return c ? c(d) : d;
    }, this.setURLModifier = function(d) {
      return c = d, this;
    }, this.addHandler = function(d, h) {
      return u.push(d, h), this;
    }, this.removeHandler = function(d) {
      const h = u.indexOf(d);
      return h !== -1 && u.splice(h, 2), this;
    }, this.getHandler = function(d) {
      for (let h = 0, m = u.length; h < m; h += 2) {
        const p = u[h], v = u[h + 1];
        if (p.global && (p.lastIndex = 0), p.test(d))
          return v;
      }
      return null;
    };
  }
}
const xT = /* @__PURE__ */ new yT();
class jf {
  constructor(e) {
    this.manager = e !== void 0 ? e : xT, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, n) {
    const i = this;
    return new Promise(function(r, o) {
      i.load(e, r, n, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
jf.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class _T extends jf {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, a = lv.get(e);
    if (a !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        n && n(a), o.manager.itemEnd(e);
      }, 0), a;
    const l = dl("img");
    function c() {
      d(), lv.add(e, this), n && n(this), o.manager.itemEnd(e);
    }
    function u(h) {
      d(), r && r(h), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function d() {
      l.removeEventListener("load", c, !1), l.removeEventListener("error", u, !1);
    }
    return l.addEventListener("load", c, !1), l.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), o.manager.itemStart(e), l.src = e, l;
  }
}
class bT extends jf {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    const o = new _n(), a = new _T(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(l) {
      o.image = l, o.needsUpdate = !0, n !== void 0 && n(o);
    }, i, r), o;
  }
}
class Iu extends cn {
  constructor(e, n = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Mt(e), this.intensity = n;
  }
  dispose() {
  }
  copy(e, n) {
    return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (n.object.target = this.target.uuid), n;
  }
}
const Fd = /* @__PURE__ */ new Zt(), cv = /* @__PURE__ */ new de(), uv = /* @__PURE__ */ new de();
class Yf {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new rt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Uf(), this._frameExtents = new rt(1, 1), this._viewportCount = 1, this._viewports = [
      new jt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera, i = this.matrix;
    cv.setFromMatrixPosition(e.matrixWorld), n.position.copy(cv), uv.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(uv), n.updateMatrixWorld(), Fd.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Fd), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(Fd);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class wT extends Yf {
  constructor() {
    super(new di(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const n = this.camera, i = Xo * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, o = e.distance || n.far;
    (i !== n.fov || r !== n.aspect || o !== n.far) && (n.fov = i, n.aspect = r, n.far = o, n.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class js extends Iu {
  constructor(e, n, i = 0, r = Math.PI / 3, o = 0, a = 2) {
    super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(cn.DEFAULT_UP), this.updateMatrix(), this.target = new cn(), this.distance = i, this.angle = r, this.penumbra = o, this.decay = a, this.map = null, this.shadow = new wT();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const dv = /* @__PURE__ */ new Zt(), ya = /* @__PURE__ */ new de(), Ud = /* @__PURE__ */ new de();
class ST extends Yf {
  constructor() {
    super(new di(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new rt(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new jt(2, 1, 1, 1),
      // negative X
      new jt(0, 1, 1, 1),
      // positive Z
      new jt(3, 1, 1, 1),
      // negative Z
      new jt(1, 1, 1, 1),
      // positive Y
      new jt(3, 0, 1, 1),
      // negative Y
      new jt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new de(1, 0, 0),
      new de(-1, 0, 0),
      new de(0, 0, 1),
      new de(0, 0, -1),
      new de(0, 1, 0),
      new de(0, -1, 0)
    ], this._cubeUps = [
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 1, 0),
      new de(0, 0, 1),
      new de(0, 0, -1)
    ];
  }
  updateMatrices(e, n = 0) {
    const i = this.camera, r = this.matrix, o = e.distance || i.far;
    o !== i.far && (i.far = o, i.updateProjectionMatrix()), ya.setFromMatrixPosition(e.matrixWorld), i.position.copy(ya), Ud.copy(i.position), Ud.add(this._cubeDirections[n]), i.up.copy(this._cubeUps[n]), i.lookAt(Ud), i.updateMatrixWorld(), r.makeTranslation(-ya.x, -ya.y, -ya.z), dv.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(dv);
  }
}
class xa extends Iu {
  constructor(e, n, i = 0, r = 2) {
    super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new ST();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class MT extends Yf {
  constructor() {
    super(new Au(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class Po extends Iu {
  constructor(e, n) {
    super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(cn.DEFAULT_UP), this.updateMatrix(), this.target = new cn(), this.shadow = new MT();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Sy extends Iu {
  constructor(e, n) {
    super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class My extends Vt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class CT {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = hv(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const n = hv();
      e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e;
    }
    return e;
  }
}
function hv() {
  return performance.now();
}
const fv = /* @__PURE__ */ new Zt();
class qf {
  constructor(e, n, i = 0, r = 1 / 0) {
    this.ray = new Lf(e, n), this.near = i, this.far = r, this.camera = null, this.layers = new Ff(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  setFromXRController(e) {
    return fv.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(fv), this;
  }
  intersectObject(e, n = !0, i = []) {
    return Jh(e, this, i, n), i.sort(pv), i;
  }
  intersectObjects(e, n = !0, i = []) {
    for (let r = 0, o = e.length; r < o; r++)
      Jh(e[r], this, i, n);
    return i.sort(pv), i;
  }
}
function pv(s, e) {
  return s.distance - e.distance;
}
function Jh(s, e, n, i) {
  let r = !0;
  if (s.layers.test(e.layers) && s.raycast(e, n) === !1 && (r = !1), r === !0 && i === !0) {
    const o = s.children;
    for (let a = 0, l = o.length; a < l; a++)
      Jh(o[a], e, n, !0);
  }
}
const mv = /* @__PURE__ */ new de();
class dc extends cn {
  constructor(e, n) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
    const i = new Vt(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
      const u = a / c * Math.PI * 2, d = l / c * Math.PI * 2;
      r.push(
        Math.cos(u),
        Math.sin(u),
        1,
        Math.cos(d),
        Math.sin(d),
        1
      );
    }
    i.setAttribute("position", new Pt(r, 3));
    const o = new Yi({ fog: !1, toneMapped: !1 });
    this.cone = new Bf(i, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e), mv.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(mv), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
class vv extends Ze {
  constructor(e, n, i) {
    const r = new ku(n, 4, 2), o = new Tn({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, o), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
class TT extends Bf {
  constructor(e = 10, n = 10, i = 4473924, r = 8947848) {
    i = new Mt(i), r = new Mt(r);
    const o = n / 2, a = e / n, l = e / 2, c = [], u = [];
    for (let m = 0, p = 0, v = -l; m <= n; m++, v += a) {
      c.push(-l, 0, v, l, 0, v), c.push(v, 0, -l, v, 0, l);
      const _ = m === o ? i : r;
      _.toArray(u, p), p += 3, _.toArray(u, p), p += 3, _.toArray(u, p), p += 3, _.toArray(u, p), p += 3;
    }
    const d = new Vt();
    d.setAttribute("position", new Pt(c, 3)), d.setAttribute("color", new Pt(u, 3));
    const h = new Yi({ vertexColors: !0, toneMapped: !1 });
    super(d, h), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const gv = /* @__PURE__ */ new de(), hc = /* @__PURE__ */ new de(), yv = /* @__PURE__ */ new de();
class xv extends cn {
  constructor(e, n, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
    let r = new Vt();
    r.setAttribute("position", new Pt([
      -n,
      n,
      0,
      n,
      n,
      0,
      n,
      -n,
      0,
      -n,
      -n,
      0,
      -n,
      n,
      0
    ], 3));
    const o = new Yi({ fog: !1, toneMapped: !1 });
    this.lightPlane = new ln(r, o), this.add(this.lightPlane), r = new Vt(), r.setAttribute("position", new Pt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ln(r, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), gv.setFromMatrixPosition(this.light.matrixWorld), hc.setFromMatrixPosition(this.light.target.matrixWorld), yv.subVectors(hc, gv), this.lightPlane.lookAt(hc), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(hc), this.targetLine.scale.z = yv.length();
  }
}
class ET extends Bf {
  constructor(e = 1) {
    const n = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new Vt();
    r.setAttribute("position", new Pt(n, 3)), r.setAttribute("color", new Pt(i, 3));
    const o = new Yi({ vertexColors: !0, toneMapped: !1 });
    super(r, o), this.type = "AxesHelper";
  }
  setColors(e, n, i) {
    const r = new Mt(), o = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(o, 0), r.toArray(o, 3), r.set(n), r.toArray(o, 6), r.toArray(o, 9), r.set(i), r.toArray(o, 12), r.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class AT extends jr {
  constructor(e, n = null) {
    super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Sf
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Sf);
const Bc = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (s) => s,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (s) => 1 - Math.cos(s * Math.PI / 2),
  easeOutSine: (s) => Math.sin(s * Math.PI / 2),
  easeInOutSine: (s) => -(Math.cos(Math.PI * s) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (s) => 2.70158 * s * s * s - 1.70158 * s * s,
  easeOutBack: (s) => 1 + 2.70158 * Math.pow(s - 1, 3) + 1.70158 * Math.pow(s - 1, 2),
  easeInOutBack: (s) => {
    const n = 2.5949095;
    return s < 0.5 ? Math.pow(2 * s, 2) * ((n + 1) * 2 * s - n) / 2 : (Math.pow(2 * s - 2, 2) * ((n + 1) * (s * 2 - 2) + n) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * e);
  },
  easeOutElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * e) + 1;
  },
  easeInOutElastic: (s) => {
    const e = 2 * Math.PI / 4.5;
    return s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * e)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * e) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (s) => 1 - Bc.easeOutBounce(1 - s),
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInOutBounce: (s) => s < 0.5 ? (1 - Bc.easeOutBounce(1 - 2 * s)) / 2 : (1 + Bc.easeOutBounce(2 * s - 1)) / 2
};
class Cl {
  constructor() {
    // Cache for recent evaluations (cleared per frame batch)
    fe(this, "cache", /* @__PURE__ */ new Map());
  }
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(e, n) {
    const i = e.id, r = this.cache.get(i);
    if (r && r.frame === n)
      return r.value;
    let o;
    return !e.animated || !e.keyframes || e.keyframes.length === 0 ? o = e.value : o = this.evaluateKeyframes(e.keyframes, n, e.value), this.cache.set(i, { frame: n, value: o }), o;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(e, n, i) {
    const r = [...e].sort((d, h) => d.frame - h.frame);
    if (n <= r[0].frame)
      return r[0].value;
    if (n >= r[r.length - 1].frame)
      return r[r.length - 1].value;
    let o = r[0], a = r[r.length - 1];
    for (let d = 0; d < r.length - 1; d++)
      if (r[d].frame <= n && r[d + 1].frame > n) {
        o = r[d], a = r[d + 1];
        break;
      }
    const l = a.frame - o.frame, c = l > 0 ? (n - o.frame) / l : 0, u = this.applyEasing(c, o.interpolation, o, a);
    return this.interpolateValue(o.value, a.value, u, i);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(e, n, i, r) {
    switch (n) {
      case "hold":
        return 0;
      case "linear":
        return e;
      case "bezier":
        return this.evaluateBezier(e, i, r);
      default:
        const o = Bc[n];
        return o ? o(e) : e;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(e, n, i) {
    const r = n.outHandle, o = i.inHandle;
    if (!(r != null && r.enabled) && !(o != null && o.enabled))
      return e;
    const a = i.frame - n.frame, l = { x: 0, y: 0 }, c = {
      x: r != null && r.enabled ? Math.min(1, Math.max(0, r.frame / a)) : 0.33,
      y: r != null && r.enabled ? r.value : 0
    }, u = {
      x: o != null && o.enabled ? Math.min(1, Math.max(0, 1 + o.frame / a)) : 0.67,
      y: o != null && o.enabled ? 1 + o.value : 1
    }, d = { x: 1, y: 1 };
    return this.solveCubicBezier(e, l.x, c.x, u.x, d.x, l.y, c.y, u.y, d.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(e, n, i, r, o, a, l, c, u) {
    let d = e;
    const h = 1e-4;
    for (let m = 0; m < 10; m++) {
      const v = this.cubicBezier(d, n, i, r, o) - e;
      if (Math.abs(v) < h)
        break;
      const _ = this.cubicBezierDerivative(d, n, i, r, o);
      if (Math.abs(_) < h)
        break;
      d -= v / _, d = Math.max(0, Math.min(1, d));
    }
    return this.cubicBezier(d, a, l, c, u);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(e, n, i, r, o) {
    const a = 1 - e;
    return a * a * a * n + 3 * a * a * e * i + 3 * a * e * e * r + e * e * e * o;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(e, n, i, r, o) {
    const a = 1 - e;
    return 3 * a * a * (i - n) + 6 * a * e * (r - i) + 3 * e * e * (o - r);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(e, n, i, r) {
    return typeof e == "number" && typeof n == "number" ? e + (n - e) * i : this.isPositionLike(e) && this.isPositionLike(n) ? this.interpolatePosition(e, n, i) : typeof e == "string" && typeof n == "string" && e.startsWith("#") && n.startsWith("#") ? this.interpolateColor(e, n, i) : Array.isArray(e) && Array.isArray(n) ? this.interpolateArray(e, n, i) : i < 0.5 ? e : n;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(e) {
    return e !== null && typeof e == "object" && "x" in e && "y" in e;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(e, n, i) {
    const r = {
      x: e.x + (n.x - e.x) * i,
      y: e.y + (n.y - e.y) * i
    };
    return ("z" in e || "z" in n) && (r.z = (e.z ?? 0) + ((n.z ?? 0) - (e.z ?? 0)) * i), r;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(e, n, i) {
    const r = this.hexToRGB(e), o = this.hexToRGB(n), a = Math.round(r.r + (o.r - r.r) * i), l = Math.round(r.g + (o.g - r.g) * i), c = Math.round(r.b + (o.b - r.b) * i);
    return this.rgbToHex(a, l, c);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(e, n, i) {
    const r = Math.max(e.length, n.length), o = [];
    for (let a = 0; a < r; a++) {
      const l = e[a] ?? 0, c = n[a] ?? 0;
      o.push(l + (c - l) * i);
    }
    return o;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(e) {
    const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return n ? {
      r: parseInt(n[1], 16),
      g: parseInt(n[2], 16),
      b: parseInt(n[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(e, n, i) {
    return "#" + [e, n, i].map((r) => Math.max(0, Math.min(255, r)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}
const qa = Math.PI, ru = 1.70158, fc = ru * 1.525, _v = ru + 1, bv = 2 * qa / 3, wv = 2 * qa / 4.5, Gr = {
  // Linear - no easing
  linear: (s) => s,
  // Sine easing
  easeInSine: (s) => 1 - Math.cos(s * qa / 2),
  easeOutSine: (s) => Math.sin(s * qa / 2),
  easeInOutSine: (s) => -(Math.cos(qa * s) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // Circ (circular)
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (s) => _v * s * s * s - ru * s * s,
  easeOutBack: (s) => 1 + _v * Math.pow(s - 1, 3) + ru * Math.pow(s - 1, 2),
  easeInOutBack: (s) => s < 0.5 ? Math.pow(2 * s, 2) * ((fc + 1) * 2 * s - fc) / 2 : (Math.pow(2 * s - 2, 2) * ((fc + 1) * (s * 2 - 2) + fc) + 2) / 2,
  // Elastic
  easeInElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * bv),
  easeOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * bv) + 1,
  easeInOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * wv)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * wv) / 2 + 1,
  // Bounce
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInBounce: (s) => 1 - Gr.easeOutBounce(1 - s),
  easeInOutBounce: (s) => s < 0.5 ? (1 - Gr.easeOutBounce(1 - 2 * s)) / 2 : (1 + Gr.easeOutBounce(2 * s - 1)) / 2
};
function PT(s) {
  return s in Gr ? Gr[s] : Gr.linear;
}
function RT(s, e) {
  let n = 0, i = s.length - 2;
  for (; n <= i; ) {
    const r = n + i >>> 1, o = s[r].frame, a = s[r + 1].frame;
    if (e >= o && e <= a)
      return r;
    e < o ? i = r - 1 : n = r + 1;
  }
  return Math.max(0, Math.min(n, s.length - 2));
}
function DT(s, e) {
  if (typeof s == "number" && typeof e == "number")
    return e - s;
  if (typeof s == "object" && s !== null && "x" in s && "y" in s && typeof e == "object" && e !== null && "x" in e && "y" in e) {
    const n = e.x - s.x, i = e.y - s.y;
    return Math.sqrt(n * n + i * i) || 1;
  }
  return 1;
}
function an(s, e) {
  if (!s.animated || s.keyframes.length === 0)
    return s.value;
  const n = s.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  const i = RT(n, e), r = n[i], o = n[i + 1], a = o.frame - r.frame, l = e - r.frame;
  let c = a > 0 ? l / a : 0;
  const u = r.interpolation || "linear";
  if (u === "hold")
    return r.value;
  if (u === "bezier") {
    const d = DT(r.value, o.value);
    c = kT(c, r.outHandle, o.inHandle, a, d);
  } else u === "linear" || (u in Gr ? c = PT(u)(c) : al.warn(`Unknown interpolation type: ${u}, using linear`));
  return LT(r.value, o.value, c);
}
function kT(s, e, n, i = 1, r = 1) {
  if (!e.enabled && !n.enabled)
    return s;
  const o = i > 0 ? Math.abs(e.frame) / i : 0.33, a = r !== 0 ? e.value / r : 0.33, l = i > 0 ? 1 - Math.abs(n.frame) / i : 0.67, c = r !== 0 ? 1 - n.value / r : 0.67;
  let u = s;
  const d = 1e-6, h = 8;
  for (let m = 0; m < h; m++) {
    const v = ou(u, 0, o, l, 1) - s;
    if (Math.abs(v) < d) break;
    const _ = IT(u, 0, o, l, 1);
    if (Math.abs(_) < d) break;
    u -= v / _, u = Math.max(0, Math.min(1, u));
  }
  return ou(u, 0, a, c, 1);
}
function ou(s, e, n, i, r) {
  const o = 1 - s;
  return o * o * o * e + 3 * o * o * s * n + 3 * o * s * s * i + s * s * s * r;
}
function IT(s, e, n, i, r) {
  const o = 1 - s;
  return 3 * o * o * (n - e) + 6 * o * s * (i - n) + 3 * s * s * (r - i);
}
function LT(s, e, n) {
  if (typeof s == "number" && typeof e == "number")
    return s + (e - s) * n;
  if (typeof s == "object" && s !== null && typeof e == "object" && e !== null && "x" in s && "y" in s && "x" in e && "y" in e) {
    const i = s, r = e, o = {
      x: i.x + (r.x - i.x) * n,
      y: i.y + (r.y - i.y) * n
    };
    return "z" in i && "z" in r ? o.z = i.z + (r.z - i.z) * n : "z" in i ? o.z = i.z * (1 - n) : "z" in r && (o.z = r.z * n), o;
  }
  return typeof s == "string" && typeof e == "string" && s.startsWith("#") && e.startsWith("#") ? FT(s, e, n) : n < 0.5 ? s : e;
}
function FT(s, e, n) {
  const i = parseInt(s.slice(1, 3), 16), r = parseInt(s.slice(3, 5), 16), o = parseInt(s.slice(5, 7), 16), a = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), c = parseInt(e.slice(5, 7), 16), u = Math.round(i + (a - i) * n), d = Math.round(r + (l - r) * n), h = Math.round(o + (c - o) * n);
  return `#${u.toString(16).padStart(2, "0")}${d.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}`;
}
const UT = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
}, au = UT;
function OT(s, e, n) {
  const i = e.x, r = e.y, o = 1 - n.x, a = 1 - n.y;
  return {
    x: ou(s, 0, i, o, 1),
    y: ou(s, 0, r, a, 1)
  };
}
function zT(s, e) {
  const n = Math.max(0, Math.min(1, s));
  return OT(n, e.outHandle, e.inHandle).y;
}
const Cy = /* @__PURE__ */ new Map();
function Qs(s, e) {
  Cy.set(s, e);
}
function NT(s, e) {
  const n = {};
  for (const [i, r] of Object.entries(s.parameters)) {
    const o = r;
    n[i] = an(o, e);
  }
  return n;
}
function BT(s, e, n) {
  const i = document.createElement("canvas");
  i.width = e.width, i.height = e.height;
  const r = i.getContext("2d");
  r.drawImage(e, 0, 0);
  let o = {
    canvas: i,
    ctx: r
  };
  for (const a of s) {
    if (!a.enabled)
      continue;
    const l = Cy.get(a.effectKey);
    if (!l) {
      al.warn(`No renderer registered for effect: ${a.effectKey}`);
      continue;
    }
    const c = NT(a, n);
    try {
      o = l(o, c);
    } catch (u) {
      al.error(`Error applying effect ${a.name}:`, u);
    }
  }
  return o;
}
function fr(s) {
  const e = document.createElement("canvas");
  e.width = s.width, e.height = s.height;
  const n = e.getContext("2d");
  return { canvas: e, ctx: n };
}
function VT(s) {
  return s.some((e) => e.enabled);
}
class qi {
  constructor(e) {
    /** Unique layer identifier */
    fe(this, "id");
    /** Layer type */
    fe(this, "type");
    /** The Three.js group containing this layer's content */
    fe(this, "group");
    /** Keyframe evaluator for animated properties */
    fe(this, "evaluator");
    /** Layer visibility */
    fe(this, "visible");
    /** Layer locked state */
    fe(this, "locked");
    /** In point (start frame) */
    fe(this, "inPoint");
    /** Out point (end frame) */
    fe(this, "outPoint");
    /** Layer opacity (0-100) */
    fe(this, "opacity");
    /** Layer transform */
    fe(this, "transform");
    /** 3D layer flag */
    fe(this, "threeD");
    /** Blend mode */
    fe(this, "blendMode");
    /** Parent layer ID (for parenting hierarchy) */
    fe(this, "parentId");
    /** Reference to parent layer (set by LayerManager) */
    fe(this, "parentLayer", null);
    /** Driven values override (from property drivers/expressions) */
    fe(this, "drivenValues", /* @__PURE__ */ new Map());
    /** Audio reactive values (from audio analysis mapping) */
    fe(this, "audioReactiveValues", /* @__PURE__ */ new Map());
    /** Effects stack for this layer */
    fe(this, "effects", []);
    /** Source canvas for effect processing (lazy initialized) */
    fe(this, "effectSourceCanvas", null);
    /** Flag to track if effects need processing */
    fe(this, "effectsDirty", !1);
    this.id = e.id, this.type = e.type, this.group = new Ai(), this.group.name = `layer_${this.id}`, this.group.userData.layerId = this.id, this.group.userData.layerType = this.type, this.evaluator = new Cl(), this.visible = e.visible, this.locked = e.locked, this.inPoint = e.inPoint, this.outPoint = e.outPoint, this.opacity = e.opacity, this.transform = e.transform, this.threeD = e.threeD ?? !1, this.blendMode = e.blendMode ?? "normal", this.parentId = e.parentId ?? null, this.effects = e.effects ?? [];
  }
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    this.blendMode !== "normal" && this.applyBlendMode(this.blendMode);
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(e) {
    const n = e >= this.inPoint && e <= this.outPoint;
    if (this.group.visible = this.visible && n, !this.group.visible)
      return;
    let i = this.evaluator.evaluate(this.opacity, e);
    i = this.getDrivenOrBase("opacity", i);
    const r = this.applyAudioModulation(i, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(r), this.evaluateTransform(e), this.onEvaluateFrame(e);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(e) {
    const n = this.evaluator.evaluate(this.transform.position, e);
    let i = this.getDrivenOrBase("transform.position.x", n.x), r = this.getDrivenOrBase("transform.position.y", n.y);
    const o = this.getDrivenOrBase("transform.position.z", n.z ?? 0);
    i = this.applyAudioModulation(i, "layer.x", "add"), r = this.applyAudioModulation(r, "layer.y", "add");
    const a = { x: i, y: r, z: o }, l = this.evaluator.evaluate(this.transform.scale, e);
    let c = this.getDrivenOrBase("transform.scale.x", l.x ?? 100), u = this.getDrivenOrBase("transform.scale.y", l.y ?? 100);
    const d = this.getDrivenOrBase("transform.scale.z", l.z ?? 100), h = this.getAudioReactiveValue("layer.scale");
    if (h !== 0) {
      const S = 0.5 + h;
      c *= S, u *= S;
    }
    const m = { x: c, y: u, z: d }, p = this.evaluator.evaluate(this.transform.anchorPoint, e), v = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", p.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", p.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", p.z ?? 0)
    };
    let _ = 0, g = 0, x = 0;
    if (this.threeD) {
      const S = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, e) : 0;
      g = this.getDrivenOrBase("transform.rotationX", S);
      const b = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, e) : 0;
      x = this.getDrivenOrBase("transform.rotationY", b);
      const C = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, e) : 0;
      _ = this.getDrivenOrBase("transform.rotationZ", C);
    } else {
      const S = this.evaluator.evaluate(this.transform.rotation, e);
      _ = this.getDrivenOrBase("transform.rotation", S);
    }
    const M = this.getAudioReactiveValue("layer.rotation");
    M !== 0 && (_ += M * 360), this.applyTransform({
      position: {
        x: a.x,
        y: a.y,
        z: a.z
      },
      rotation: {
        x: g,
        y: x,
        z: _
      },
      scale: {
        x: m.x / 100,
        y: m.y / 100,
        z: m.z / 100
      },
      anchorPoint: {
        x: v.x,
        y: v.y,
        z: v.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(e) {
    const { position: n, rotation: i, scale: r, anchorPoint: o } = e;
    this.group.position.set(
      n.x - o.x,
      -(n.y - o.y),
      // Negate for screen coords
      n.z - o.z
    ), this.group.rotation.set(
      mn.degToRad(i.x),
      mn.degToRad(i.y),
      mn.degToRad(-i.z)
    ), this.group.scale.set(r.x, r.y, r.z), this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(e) {
    const n = Math.max(0, Math.min(100, e)) / 100;
    this.group.traverse((i) => {
      if (i instanceof Ze && i.material) {
        const r = i.material;
        "opacity" in r && (r.opacity = n, r.transparent = n < 1, r.needsUpdate = !0);
      }
    });
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(e) {
    e.visible !== void 0 && (this.visible = e.visible, this.group.visible = this.visible), e.locked !== void 0 && (this.locked = e.locked), e.inPoint !== void 0 && (this.inPoint = e.inPoint), e.outPoint !== void 0 && (this.outPoint = e.outPoint), e.opacity !== void 0 && (this.opacity = e.opacity), e.transform !== void 0 && (this.transform = e.transform), e.threeD !== void 0 && (this.threeD = e.threeD), e.blendMode !== void 0 && (this.blendMode = e.blendMode, this.applyBlendMode(this.blendMode)), e.effects !== void 0 && this.setEffects(e.effects), this.onUpdate(e);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(e) {
    this.visible = e, this.group.visible = e;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(e) {
    this.drivenValues = e;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(e, n) {
    return this.drivenValues.get(e) ?? n;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(e) {
    this.audioReactiveValues = e;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(e) {
    return this.audioReactiveValues.get(e) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(e, n, i = "add", r = {}) {
    const o = this.getAudioReactiveValue(n);
    if (o === 0) return e;
    let a;
    switch (i) {
      case "multiply":
        a = e * (0.5 + o);
        break;
      case "replace":
        a = o;
        break;
      case "add":
      default:
        a = e + o * 100;
        break;
    }
    return r.min !== void 0 && (a = Math.max(r.min, a)), r.max !== void 0 && (a = Math.min(r.max, a)), a;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(e) {
    this.effects = e, this.effectsDirty = !0;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   */
  hasEnabledEffects() {
    return VT(this.effects);
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(e) {
    if (!this.hasEnabledEffects())
      return null;
    const n = this.getSourceCanvas();
    if (!n)
      return null;
    try {
      return BT(this.effects, n, e).canvas;
    } catch (i) {
      return Ei.error(`Error processing effects for layer ${this.id}:`, i), null;
    }
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(e) {
  }
  /**
   * Called after frame evaluation to apply effects
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(e) {
    if (!this.hasEnabledEffects())
      return;
    const n = this.processEffects(e);
    n && this.applyProcessedEffects(n);
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(e) {
    this.parentLayer && this.parentLayer.getObject().remove(this.group), this.parentLayer = e, e && e.getObject().add(this.group);
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(e) {
    this.group.traverse((n) => {
      if (n instanceof Ze && n.material) {
        const i = n.material;
        this.setMaterialBlendMode(i, e), i.needsUpdate = !0;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(e, n) {
    switch (e.blending = Hi, e.blendEquation = Vi, e.blendSrc = eu, e.blendDst = cl, e.blendEquationAlpha = Vi, e.blendSrcAlpha = bs, e.blendDstAlpha = cl, n) {
      case "normal":
        e.blending = Hi;
        break;
      case "add":
        e.blending = ll;
        break;
      case "multiply":
        e.blending = Fo;
        break;
      case "screen":
        e.blending = kr, e.blendEquation = Vi, e.blendSrc = bs, e.blendDst = dh;
        break;
      case "overlay":
        e.blending = Fo;
        break;
      case "soft-light":
        e.blending = Hi;
        break;
      case "hard-light":
        e.blending = Fo;
        break;
      case "color-dodge":
        e.blending = ll;
        break;
      case "color-burn":
        e.blending = uh;
        break;
      case "difference":
        e.blending = kr, e.blendEquation = I0, e.blendSrc = bs, e.blendDst = bs;
        break;
      case "exclusion":
        e.blending = kr, e.blendEquation = Vi, e.blendSrc = U0, e.blendDst = dh;
        break;
      case "darken":
        e.blending = kr, e.blendEquation = L0, e.blendSrc = bs, e.blendDst = bs;
        break;
      case "lighten":
        e.blending = kr, e.blendEquation = F0, e.blendSrc = bs, e.blendDst = bs;
        break;
      default:
        e.blending = Hi;
        break;
    }
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const e = new hr();
    return e.setFromObject(this.group), e;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const e = this.getBoundingBox(), n = new de();
    return e.getCenter(n), n;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    this.group.traverse((e) => {
      var n;
      e instanceof Ze && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => i.dispose()) : e.material && e.material.dispose());
    }), this.group.clear(), this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}
class GT extends qi {
  constructor(n, i) {
    super(n);
    fe(this, "resources");
    // Video elements
    fe(this, "videoElement", null);
    fe(this, "videoTexture", null);
    fe(this, "mesh", null);
    fe(this, "material", null);
    // Video data
    fe(this, "videoData");
    fe(this, "assetRef", null);
    // Metadata (populated after video loads)
    fe(this, "metadata", null);
    // Animation evaluator
    fe(this, "videoEvaluator");
    // Playback state
    fe(this, "lastEvaluatedFrame", -1);
    fe(this, "isPlaying", !1);
    // Callbacks for composition auto-resize
    fe(this, "onMetadataLoaded");
    // Composition FPS for time calculation
    fe(this, "compositionFPS", 30);
    // Canvas for effect processing
    fe(this, "effectCanvas", null);
    fe(this, "effectCanvasCtx", null);
    this.resources = i, this.videoEvaluator = new Cl(), this.videoData = this.extractVideoData(n), this.createPlaceholderMesh(), this.videoData.assetId && this.loadVideo(this.videoData.assetId), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(n) {
    const i = n.data;
    return {
      assetId: (i == null ? void 0 : i.assetId) ?? null,
      loop: (i == null ? void 0 : i.loop) ?? !1,
      pingPong: (i == null ? void 0 : i.pingPong) ?? !1,
      startTime: (i == null ? void 0 : i.startTime) ?? 0,
      endTime: i == null ? void 0 : i.endTime,
      speed: (i == null ? void 0 : i.speed) ?? 1,
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      frameBlending: (i == null ? void 0 : i.frameBlending) ?? "none",
      audioEnabled: (i == null ? void 0 : i.audioEnabled) ?? !0,
      audioLevel: (i == null ? void 0 : i.audioLevel) ?? 100,
      posterFrame: (i == null ? void 0 : i.posterFrame) ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const n = new un(1, 1);
    this.material = new Tn({
      color: 3355443,
      transparent: !0,
      side: vn
    }), this.mesh = new Ze(n, this.material), this.mesh.name = `video_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(n) {
    const i = this.resources.getAsset(n);
    if (!i || i.type !== "video") {
      Ei.warn(`VideoLayer: Asset ${n} not found or not a video`);
      return;
    }
    this.assetRef = i, this.videoData.assetId = n, this.videoElement = document.createElement("video"), this.videoElement.crossOrigin = "anonymous", this.videoElement.playsInline = !0, this.videoElement.muted = !this.videoData.audioEnabled, this.videoElement.loop = !1, this.videoElement.preload = "auto", i.data && (this.videoElement.src = i.data), await this.waitForMetadata(), this.createVideoTexture(), this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((n, i) => {
      if (!this.videoElement) {
        i(new Error("No video element"));
        return;
      }
      const r = () => {
        this.extractMetadata(), a(), n();
      }, o = (l) => {
        a(), i(new Error(`Video load error: ${l}`));
      }, a = () => {
        var l, c;
        (l = this.videoElement) == null || l.removeEventListener("loadedmetadata", r), (c = this.videoElement) == null || c.removeEventListener("error", o);
      };
      this.videoElement.addEventListener("loadedmetadata", r), this.videoElement.addEventListener("error", o), this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    var l, c;
    if (!this.videoElement) return;
    const n = this.videoElement.duration, i = this.videoElement.videoWidth, r = this.videoElement.videoHeight, o = ((l = this.assetRef) == null ? void 0 : l.fps) ?? 30, a = Math.ceil(n * o);
    this.metadata = {
      duration: n,
      frameCount: a,
      fps: o,
      width: i,
      height: r,
      hasAudio: this.hasAudioTrack()
    }, this.assetRef && (this.assetRef.duration = n, this.assetRef.frameCount = a, this.assetRef.fps = o, this.assetRef.hasAudio = this.metadata.hasAudio), (c = this.onMetadataLoaded) == null || c.call(this, this.metadata), Ei.debug(`VideoLayer: Loaded: ${i}x${r}, ${a} frames @ ${o}fps, ${n.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return !1;
    const n = this.videoElement.audioTracks;
    return n ? n.length > 0 : !0;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    !this.videoElement || !this.metadata || (this.videoTexture = new N2(this.videoElement), this.videoTexture.minFilter = Bt, this.videoTexture.magFilter = Bt, this.videoTexture.format = Rn, this.videoTexture.colorSpace = dn, this.material && (this.material.map = this.videoTexture, this.material.color.setHex(16777215), this.material.needsUpdate = !0), this.resizeMesh(this.metadata.width, this.metadata.height));
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new un(n, i));
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(n) {
    if (!this.videoElement || !this.metadata) return;
    const i = this.calculateVideoTime(n), r = Math.max(0, Math.min(i, this.videoElement.duration));
    this.videoElement.currentTime = r;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(n) {
    var l;
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && ((l = this.videoData.timeRemap) != null && l.animated))
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, n);
    const i = this.compositionFPS;
    let o = n / i * this.videoData.speed;
    o += this.videoData.startTime;
    const a = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && a > 0) {
      if (this.videoData.pingPong) {
        const c = Math.floor(o / a), u = o % a;
        o = c % 2 === 0 ? u : a - u;
      } else
        o = o % a;
      o += this.videoData.startTime;
    }
    return o;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(n) {
    this.videoData.audioLevel = n, this.videoElement && (this.videoElement.volume = Math.max(0, Math.min(1, n / 100)));
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(n) {
    this.videoData.audioEnabled = n, this.videoElement && (this.videoElement.muted = !n);
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.compositionFPS = n;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(n) {
    this.onMetadataLoaded = n, this.metadata && n(this.metadata);
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(n) {
    this.videoData.loop = n;
  }
  setPingPong(n) {
    this.videoData.pingPong = n;
  }
  setSpeed(n) {
    this.videoData.speed = n, this.videoElement && (this.videoElement.playbackRate = n);
  }
  setStartTime(n) {
    this.videoData.startTime = n;
  }
  setEndTime(n) {
    this.videoData.endTime = n;
  }
  setFrameBlending(n) {
    this.videoData.frameBlending = n;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata)
      return null;
    const n = this.metadata.width, i = this.metadata.height;
    return (!this.effectCanvas || this.effectCanvas.width !== n || this.effectCanvas.height !== i) && (this.effectCanvas = document.createElement("canvas"), this.effectCanvas.width = n, this.effectCanvas.height = i, this.effectCanvasCtx = this.effectCanvas.getContext("2d")), this.effectCanvasCtx ? (this.effectCanvasCtx.clearRect(0, 0, n, i), this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, n, i), this.effectCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    if (!this.material || !this.metadata) return;
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    n !== this.lastEvaluatedFrame && (this.lastEvaluatedFrame = n, this.seekToFrame(n), this.videoTexture && (this.videoTexture.needsUpdate = !0), this.hasEnabledEffects() ? this.evaluateEffects(n) : this.material && this.videoTexture && (this.material.map = this.videoTexture, this.material.needsUpdate = !0));
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.assetId !== void 0 && i.assetId !== this.videoData.assetId && (i.assetId ? this.loadVideo(i.assetId) : this.clearVideo()), i.loop !== void 0 && this.setLoop(i.loop), i.pingPong !== void 0 && this.setPingPong(i.pingPong), i.speed !== void 0 && this.setSpeed(i.speed), i.startTime !== void 0 && this.setStartTime(i.startTime), i.endTime !== void 0 && this.setEndTime(i.endTime), i.frameBlending !== void 0 && this.setFrameBlending(i.frameBlending), i.audioEnabled !== void 0 && this.setAudioEnabled(i.audioEnabled), i.audioLevel !== void 0 && this.setAudioLevel(i.audioLevel));
  }
  /**
   * Clear current video
   */
  clearVideo() {
    this.videoElement && (this.videoElement.pause(), this.videoElement.src = "", this.videoElement = null), this.videoTexture && (this.videoTexture.dispose(), this.videoTexture = null), this.material && (this.material.map = null, this.material.color.setHex(3355443)), this.metadata = null, this.videoData.assetId = null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo(), this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh));
  }
}
async function HT(s) {
  return new Promise((e, n) => {
    const i = document.createElement("video");
    i.crossOrigin = "anonymous", i.preload = "metadata";
    const r = () => {
      i.removeEventListener("loadedmetadata", o), i.removeEventListener("error", a), URL.revokeObjectURL(i.src);
    }, o = () => {
      const l = {
        duration: i.duration,
        frameCount: Math.ceil(i.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: i.videoWidth,
        height: i.videoHeight,
        hasAudio: !0
        // Assume true
      };
      r(), e(l);
    }, a = () => {
      r(), n(new Error("Failed to load video metadata"));
    };
    i.addEventListener("loadedmetadata", o), i.addEventListener("error", a), typeof s == "string" ? i.src = s : i.src = URL.createObjectURL(s);
  });
}
function $T(s, e = 16) {
  const n = Math.round(s.width / 8) * 8, i = Math.round(s.height / 8) * 8, r = Math.ceil(s.duration * e);
  return { width: n, height: i, frameCount: r };
}
const WT = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function Ty(s, e, n) {
  const i = e / 2, r = n / 2;
  return {
    id: s,
    name: "Camera 1",
    type: "two-node",
    position: { x: i, y: r, z: -1500 },
    pointOfInterest: { x: i, y: r, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function Ey() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function XT() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: !0,
    showLayerHandles: !0,
    showSafeZones: !1,
    showGrid: !1,
    showRulers: !0,
    show3DReferenceAxes: !0,
    showCompositionBounds: !0,
    showFocalPlane: !1
  };
}
function wt(s, e, n) {
  return { x: s, y: e, z: n };
}
function At(s, e) {
  return { x: s.x + e.x, y: s.y + e.y, z: s.z + e.z };
}
function Zf(s, e) {
  return { x: s.x - e.x, y: s.y - e.y, z: s.z - e.z };
}
function Dt(s, e) {
  return { x: s.x * e, y: s.y * e, z: s.z * e };
}
function jT(s) {
  return Math.sqrt(s.x * s.x + s.y * s.y + s.z * s.z);
}
function Rs(s) {
  const e = jT(s);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: s.x / e, y: s.y / e, z: s.z / e };
}
function Yo(s, e) {
  return {
    x: s.y * e.z - s.z * e.y,
    y: s.z * e.x - s.x * e.z,
    z: s.x * e.y - s.y * e.x
  };
}
function Od(s, e) {
  return s.x * e.x + s.y * e.y + s.z * e.z;
}
function YT(s, e, n, i) {
  const r = new Float32Array(16), o = 1 / Math.tan(s / 2), a = 1 / (n - i);
  return r[0] = o / e, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = (i + n) * a, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = 2 * i * n * a, r[15] = 0, { elements: r };
}
function qT(s, e, n, i, r, o) {
  const a = new Float32Array(16), l = 1 / (e - s), c = 1 / (i - n), u = 1 / (o - r);
  return a[0] = 2 * l, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * c, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = -2 * u, a[11] = 0, a[12] = -(e + s) * l, a[13] = -(i + n) * c, a[14] = -10001 * u, a[15] = 1, { elements: a };
}
function es(s, e, n) {
  const i = new Float32Array(16);
  let r = s.x - e.x, o = s.y - e.y, a = s.z - e.z, l = Math.sqrt(r * r + o * o + a * a);
  l === 0 ? a = 1 : (l = 1 / l, r *= l, o *= l, a *= l);
  let c = n.y * a - n.z * o, u = n.z * r - n.x * a, d = n.x * o - n.y * r;
  l = Math.sqrt(c * c + u * u + d * d), l === 0 ? (c = 0, u = 0, d = 0) : (l = 1 / l, c *= l, u *= l, d *= l);
  let h = o * d - a * u, m = a * c - r * d, p = r * u - o * c;
  return l = Math.sqrt(h * h + m * m + p * p), l === 0 ? (h = 0, m = 0, p = 0) : (l = 1 / l, h *= l, m *= l, p *= l), i[0] = c, i[4] = u, i[8] = d, i[12] = -Od({ x: c, y: u, z: d }, s), i[1] = h, i[5] = m, i[9] = p, i[13] = -Od({ x: h, y: m, z: p }, s), i[2] = r, i[6] = o, i[10] = a, i[14] = -Od({ x: r, y: o, z: a }, s), i[3] = 0, i[7] = 0, i[11] = 0, i[15] = 1, { elements: i };
}
function ZT(s, e) {
  const n = s.elements, i = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / i,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / i,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / i
  };
}
function Tl(s, e) {
  return 2 * Math.atan(e / (2 * s));
}
function KT(s, e) {
  return e / (2 * Math.tan(s / 2));
}
function vl(s, e, n) {
  if (!e || e.length === 0)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  let i = null, r = null;
  for (const _ of e)
    _.frame <= n && (i = _), _.frame >= n && !r && (r = _);
  if (!i && !r)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  i || (i = r), r || (r = i);
  const o = (_) => (_ == null ? void 0 : _.position) ?? s.position, a = (_) => (_ == null ? void 0 : _.orientation) ?? s.orientation, l = (_) => (_ == null ? void 0 : _.focalLength) ?? s.focalLength, c = (_) => (_ == null ? void 0 : _.zoom) ?? s.zoom, u = (_) => (_ == null ? void 0 : _.focusDistance) ?? s.depthOfField.focusDistance;
  if (i.frame === r.frame)
    return {
      position: o(i),
      rotation: a(i),
      focalLength: l(i),
      zoom: c(i),
      focusDistance: u(i)
    };
  const d = (n - i.frame) / (r.frame - i.frame), h = o(i), m = o(r), p = a(i), v = a(r);
  return {
    position: {
      x: go(h.x, m.x, d),
      y: go(h.y, m.y, d),
      z: go(h.z, m.z, d)
    },
    rotation: {
      x: zd(p.x, v.x, d),
      y: zd(p.y, v.y, d),
      z: zd(p.z, v.z, d)
    },
    focalLength: go(l(i), l(r), d),
    zoom: go(c(i), c(r), d),
    focusDistance: go(u(i), u(r), d)
  };
}
function go(s, e, n) {
  return s + (e - s) * n;
}
function zd(s, e, n) {
  let i = e - s;
  return i > 180 && (i -= 360), i < -180 && (i += 360), s + i * n;
}
function Ay(s) {
  const { position: e, rotation: n } = s, i = n.x * Math.PI / 180, r = n.y * Math.PI / 180, o = n.z * Math.PI / 180, a = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r), d = Math.cos(o), h = Math.sin(o), m = c * d + u * l * h, p = -c * h + u * l * d, v = u * a, _ = a * h, g = a * d, x = -l, M = -u * d + c * l * h, S = u * h + c * l * d, b = c * a, C = -(m * e.x + _ * e.y + M * e.z), T = -(p * e.x + g * e.y + S * e.z), P = -(v * e.x + x * e.y + b * e.z);
  return [
    [m, p, v, C],
    [_, g, x, T],
    [M, S, b, P],
    [0, 0, 0, 1]
  ];
}
function JT(s, e, n = 0.1, i = 1e3) {
  const o = Tl(s.focalLength, 36) * Math.PI / 180, l = 1 / Math.tan(o / 2), c = 1 / (n - i);
  return [
    [l / e, 0, 0, 0],
    [0, l, 0, 0],
    [0, 0, (i + n) * c, 2 * i * n * c],
    [0, 0, -1, 0]
  ];
}
function Py(s, e, n) {
  const i = [];
  for (let r = 0; r < n; r++) {
    const o = vl(s, e, r), a = Ay(o);
    i.push({
      RT: a
    });
  }
  return { camera_poses: i };
}
function QT(s) {
  if (!s || s.length < 2) return "static";
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, r = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = r.x - i.x, c = r.y - i.y, u = r.z - i.z, d = a.y - o.y, h = 50;
  return Math.abs(u) > h ? u < 0 ? "zoom_in" : "zoom_out" : Math.abs(d) > 15 ? d > 0 ? "rotate_cw" : "rotate_ccw" : Math.abs(l) > h ? l > 0 ? "pan_right" : "pan_left" : Math.abs(c) > h ? c > 0 ? "pan_down" : "pan_up" : "static";
}
function eE(s, e, n) {
  const i = QT(e);
  if (i !== "static" && e.length <= 2)
    return { motion_camera: i };
  const r = Py(s, e, n);
  return {
    motion_camera: i,
    camera_poses: JSON.stringify(r.camera_poses)
  };
}
function Lu(s) {
  if (!s || s.length < 2)
    return {
      hasPan: !1,
      panMagnitude: 0,
      hasZoom: !1,
      zoomMagnitude: 0,
      hasOrbit: !1,
      orbitMagnitude: 0,
      hasRotation: !1,
      rotationMagnitude: 0
    };
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, r = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = r.x - i.x, c = r.y - i.y, u = r.z - i.z, d = a.y - o.y, h = 30, m = 50, p = 20;
  let v;
  const _ = Math.abs(l), g = Math.abs(c);
  (_ > h || g > h) && (_ > g ? v = l > 0 ? "right" : "left" : v = c > 0 ? "down" : "up");
  let x;
  Math.abs(u) > m && (x = u < 0 ? "in" : "out");
  let M;
  return Math.abs(d) > p && Math.abs(l) > h && (M = d > 0 ? "right" : "left"), {
    hasPan: !!v,
    panDirection: v,
    panMagnitude: Math.max(_, g),
    hasZoom: !!x,
    zoomDirection: x,
    zoomMagnitude: Math.abs(u),
    hasOrbit: !!M,
    orbitDirection: M,
    orbitMagnitude: Math.abs(d),
    hasRotation: Math.abs(d) > 5,
    rotationMagnitude: Math.abs(d)
  };
}
function tE(s) {
  const e = Lu(s);
  let n = "Static";
  if (e.hasOrbit)
    n = e.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  else if (e.hasZoom && e.hasPan) {
    const i = Sv(e.panDirection || "up"), r = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    n = `Pan ${i} + ${r}`;
  } else e.hasZoom ? n = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out" : e.hasPan && (n = `Pan ${Sv(e.panDirection || "up")}`);
  return { camera_motion: n };
}
function Sv(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function nE(s) {
  const e = Lu(s);
  return e.hasOrbit && e.orbitMagnitude > 45 ? "orbit" : e.hasPan && e.hasZoom ? "custom" : !e.hasPan && !e.hasZoom && !e.hasOrbit ? "free1" : "custom";
}
function iE(s, e, n, i, r) {
  const o = nE(e);
  if (o !== "custom")
    return { traj_type: o };
  const a = [], l = vl(s, e, 0);
  for (let c = 0; c < n; c++) {
    const u = vl(s, e, c);
    a.push({
      zoom: u.zoom / l.zoom,
      x_offset: (u.position.x - l.position.x) / i,
      y_offset: (u.position.y - l.position.y) / r,
      z_offset: (u.position.z - l.position.z) / 1e3,
      pitch: u.rotation.x,
      yaw: u.rotation.y,
      roll: u.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: a
  };
}
function sE(s) {
  const e = Lu(s);
  if (!e.hasPan && !e.hasZoom && !e.hasRotation)
    return "Static";
  if (e.hasZoom)
    return e.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  if (e.hasPan)
    switch (e.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  if (e.hasRotation) {
    const n = s[0], i = s[s.length - 1], r = n.orientation ?? { x: 0, y: 0, z: 0 }, o = i.orientation ?? { x: 0, y: 0, z: 0 }, a = o.x - r.x, l = o.y - r.y, c = o.z - r.z;
    return Math.abs(l) > Math.abs(a) && Math.abs(l) > Math.abs(c) ? l > 0 ? "Rotate Right" : "Rotate Left" : Math.abs(a) > Math.abs(c) ? a > 0 ? "Rotate Down" : "Rotate Up" : c > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function rE(s, e) {
  const n = sE(s), i = Lu(s);
  let r = 0;
  return i.hasZoom ? r = Math.min(100, i.zoomMagnitude / 5) : i.hasPan ? r = Math.min(100, i.panMagnitude / 3) : i.hasRotation && (r = Math.min(100, i.rotationMagnitude * 2)), {
    motion_type: n,
    speed: Math.round(r),
    frame_length: e
  };
}
function oE(s, e, n) {
  const i = [], r = n.width / n.height;
  for (let o = 0; o < n.frameCount; o++) {
    const a = vl(s, e, o), l = Ay(a), c = JT(a, r);
    i.push({
      frame: o,
      timestamp: o / n.fps,
      view_matrix: l,
      projection_matrix: c,
      position: [a.position.x, a.position.y, a.position.z],
      rotation: [a.rotation.x, a.rotation.y, a.rotation.z],
      fov: Tl(a.focalLength, s.filmSize),
      focal_length: a.focalLength,
      focus_distance: a.focusDistance
    });
  }
  return {
    frames: i,
    metadata: {
      width: n.width,
      height: n.height,
      fps: n.fps,
      total_frames: n.frameCount,
      camera_type: s.type,
      film_size: s.filmSize
    }
  };
}
function aE(s, e, n, i, r = 1920, o = 1080, a = 24) {
  switch (s) {
    case "motionctrl":
      return Py(e, n, i);
    case "motionctrl-svd":
      return eE(e, n, i);
    case "wan22-fun-camera":
      return tE(n);
    case "uni3c-camera":
    case "uni3c-motion":
      return iE(e, n, i, r, o);
    case "animatediff-cameractrl":
      return rE(n, i);
    default:
      return oE(e, n, {
        frameCount: i,
        width: r,
        height: o,
        fps: a
      });
  }
}
function gl(s, e, n) {
  var r, o, a, l, c, u, d, h, m, p, v, _, g, x, M, S, b, C, T, P, E, y, w, D, U, R, O, A, G;
  const i = Math.max(0, Math.min(n, s.frameCount - 1));
  switch (e) {
    case "amplitude":
      return s.amplitudeEnvelope[i] ?? 0;
    case "rms":
      return s.rmsEnergy[i] ?? 0;
    case "spectralCentroid":
      return s.spectralCentroid[i] ?? 0;
    case "sub":
      return s.frequencyBands.sub[i] ?? 0;
    case "bass":
      return s.frequencyBands.bass[i] ?? 0;
    case "lowMid":
      return s.frequencyBands.lowMid[i] ?? 0;
    case "mid":
      return s.frequencyBands.mid[i] ?? 0;
    case "highMid":
      return s.frequencyBands.highMid[i] ?? 0;
    case "high":
      return s.frequencyBands.high[i] ?? 0;
    case "onsets":
      return s.onsets.includes(i) ? 1 : 0;
    case "spectralFlux":
      return ((r = s.spectralFlux) == null ? void 0 : r[i]) ?? 0;
    case "zeroCrossingRate":
    case "zcr":
      return ((o = s.zeroCrossingRate) == null ? void 0 : o[i]) ?? 0;
    case "spectralRolloff":
    case "rolloff":
      return ((a = s.spectralRolloff) == null ? void 0 : a[i]) ?? 0;
    case "spectralFlatness":
    case "flatness":
      return ((l = s.spectralFlatness) == null ? void 0 : l[i]) ?? 0;
    case "chromaEnergy":
      return ((c = s.chromaFeatures) == null ? void 0 : c.chromaEnergy[i]) ?? 0;
    case "chromaC":
      return ((d = (u = s.chromaFeatures) == null ? void 0 : u.chroma[i]) == null ? void 0 : d[0]) ?? 0;
    case "chromaCs":
    case "chromaDb":
      return ((m = (h = s.chromaFeatures) == null ? void 0 : h.chroma[i]) == null ? void 0 : m[1]) ?? 0;
    case "chromaD":
      return ((v = (p = s.chromaFeatures) == null ? void 0 : p.chroma[i]) == null ? void 0 : v[2]) ?? 0;
    case "chromaDs":
    case "chromaEb":
      return ((g = (_ = s.chromaFeatures) == null ? void 0 : _.chroma[i]) == null ? void 0 : g[3]) ?? 0;
    case "chromaE":
      return ((M = (x = s.chromaFeatures) == null ? void 0 : x.chroma[i]) == null ? void 0 : M[4]) ?? 0;
    case "chromaF":
      return ((b = (S = s.chromaFeatures) == null ? void 0 : S.chroma[i]) == null ? void 0 : b[5]) ?? 0;
    case "chromaFs":
    case "chromaGb":
      return ((T = (C = s.chromaFeatures) == null ? void 0 : C.chroma[i]) == null ? void 0 : T[6]) ?? 0;
    case "chromaG":
      return ((E = (P = s.chromaFeatures) == null ? void 0 : P.chroma[i]) == null ? void 0 : E[7]) ?? 0;
    case "chromaGs":
    case "chromaAb":
      return ((w = (y = s.chromaFeatures) == null ? void 0 : y.chroma[i]) == null ? void 0 : w[8]) ?? 0;
    case "chromaA":
      return ((U = (D = s.chromaFeatures) == null ? void 0 : D.chroma[i]) == null ? void 0 : U[9]) ?? 0;
    case "chromaAs":
    case "chromaBb":
      return ((O = (R = s.chromaFeatures) == null ? void 0 : R.chroma[i]) == null ? void 0 : O[10]) ?? 0;
    case "chromaB":
      return ((G = (A = s.chromaFeatures) == null ? void 0 : A.chroma[i]) == null ? void 0 : G[11]) ?? 0;
    default:
      return 0;
  }
}
function Ry(s, e) {
  const { threshold: n, minPeaksDistance: i, multiply: r } = e, o = s.map((d) => Math.min(1, d * r)), a = [];
  for (let d = 1; d < o.length - 1; d++) {
    const h = o[d - 1], m = o[d], p = o[d + 1];
    m > h && m > p && m >= n && a.push({ index: d, value: m });
  }
  const l = [];
  for (const d of a) {
    const h = l.findIndex(
      (m) => Math.abs(m.index - d.index) < i
    );
    h === -1 ? l.push(d) : d.value > l[h].value && (l[h] = d);
  }
  l.sort((d, h) => d.index - h.index);
  const c = new Array(s.length).fill(0);
  let u = 0;
  for (let d = 0; d < s.length; d++)
    l.some((m) => m.index === d) && (u = 1 - u), c[d] = u;
  return {
    indices: l.map((d) => d.index),
    values: l.map((d) => d.value),
    count: l.length,
    alternating: c
  };
}
function Mv(s, e) {
  return s.onsets.includes(e);
}
function lE(s, e) {
  return s.indices.includes(e);
}
let Fr = null, yl = null, Ro = null, lu = null;
function cE() {
  return Fr || (Fr = new Worker(
    new URL(
      /* @vite-ignore */
      "/assets/audioWorker-DAB3gMSK.js",
      import.meta.url
    ),
    { type: "module" }
  ), Fr.onmessage = (s) => {
    const e = s.data;
    switch (e.type) {
      case "progress":
        lu && lu({
          phase: e.payload.phase,
          progress: e.payload.progress,
          message: e.payload.message
        });
        break;
      case "complete":
        yl && (yl(e.payload), Nd());
        break;
      case "error":
        Ro && (Ro(new Error(e.payload.message)), Nd());
        break;
    }
  }, Fr.onerror = (s) => {
    console.error("[AudioWorker] Worker error:", s), Ro && (Ro(new Error(`Worker error: ${s.message}`)), Nd());
  }), Fr;
}
function Nd() {
  yl = null, Ro = null, lu = null;
}
function uE() {
  Fr && Fr.postMessage({ type: "cancel" });
}
async function dE(s, e, n = {}) {
  const i = cE();
  if (yl)
    throw new Error("Analysis already in progress. Cancel it first.");
  const r = s.getChannelData(0), o = new Float32Array(r);
  return new Promise((a, l) => {
    yl = a, Ro = l, lu = n.onProgress || null, i.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: o,
          sampleRate: s.sampleRate,
          fps: e
        }
      },
      [o.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function hE(s, e, n = {}) {
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 0,
    message: "Decoding audio file..."
  });
  const i = await s.arrayBuffer(), r = new AudioContext();
  let o;
  try {
    o = await r.decodeAudioData(i);
  } finally {
    await r.close();
  }
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 1,
    message: "Audio decoded successfully"
  });
  const a = await dE(o, e, n);
  return { buffer: o, analysis: a };
}
function Wt(s, e, n = "number", i) {
  return {
    id: `prop_${s}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name: s,
    type: n,
    value: e,
    animated: !1,
    keyframes: [],
    group: i
  };
}
function Bd() {
  return {
    position: Wt("position", { x: 0, y: 0 }, "position"),
    anchorPoint: Wt("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: Wt("scale", { x: 100, y: 100 }, "position"),
    rotation: Wt("rotation", 0, "number")
  };
}
function fE(s, e) {
  const n = "main", i = {
    width: s,
    height: e,
    frameCount: 81,
    fps: 16,
    duration: 5.0625,
    backgroundColor: "#000000",
    autoResizeToContent: !0
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [n]: {
        id: n,
        name: "Main Comp",
        settings: i,
        layers: [],
        currentFrame: 0,
        isPrecomp: !1
      }
    },
    mainCompositionId: n,
    // Legacy alias
    composition: i,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
function pE(s, e = "amplitude", n = "particle.emissionRate") {
  return {
    id: s || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature: e,
    target: n,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    // Core
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: !1,
    threshold: 0,
    enabled: !0,
    // ATI style
    amplitudeCurve: 1,
    // Linear by default
    release: 0.5,
    // Medium decay
    beatResponse: "none",
    beatThreshold: 0.5,
    curve: "linear"
  };
}
class mE {
  constructor(e) {
    fe(this, "analysis");
    fe(this, "mappings", /* @__PURE__ */ new Map());
    fe(this, "smoothedValues", /* @__PURE__ */ new Map());
    fe(this, "releaseEnvelopes", /* @__PURE__ */ new Map());
    // ATI-style release tracking
    fe(this, "beatToggleStates", /* @__PURE__ */ new Map());
    // For beat toggle/flip
    fe(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0), this.releaseEnvelopes.set(e.id, 0), this.beatToggleStates.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e), this.releaseEnvelopes.delete(e), this.beatToggleStates.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const i = this.mappings.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && lE(this.peakData, n) ? 1 : 0 : gl(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const i = this.mappings.get(e);
    if (!i || !i.enabled) return 0;
    let r = this.getFeatureAtFrame(i.feature, n);
    r < i.threshold && (r = 0), i.amplitudeCurve !== 1 && (r = Math.pow(r, i.amplitudeCurve));
    const o = this.releaseEnvelopes.get(e) || 0;
    if (r > o)
      this.releaseEnvelopes.set(e, r);
    else {
      const c = 1 - i.release * 0.98, u = o * c;
      this.releaseEnvelopes.set(e, u), r = Math.max(r, u);
    }
    if (i.beatResponse !== "none") {
      if (this.analysis.onsets.includes(n) && this.getFeatureAtFrame(i.feature, n) > i.beatThreshold) {
        const u = this.beatToggleStates.get(e) || 0;
        switch (i.beatResponse) {
          case "flip":
            this.beatToggleStates.set(e, u === 0 ? 1 : 0);
            break;
          case "pulse":
            r = 1;
            break;
          case "toggle":
            const d = u === 0 ? 1 : 0;
            this.beatToggleStates.set(e, d), r = d;
            break;
        }
      }
      i.beatResponse === "flip" && (this.beatToggleStates.get(e) || 0) === 1 && (r = 1 - r);
    }
    r = this.applyCurve(r, i.curve), i.invert && (r = 1 - r), r *= i.sensitivity, r += i.offset, r = Math.max(i.min, Math.min(i.max, r));
    const l = (this.smoothedValues.get(e) || 0) * i.smoothing + r * (1 - i.smoothing);
    return this.smoothedValues.set(e, l), l;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const i of this.mappings.values()) {
      if (!i.enabled) continue;
      const r = this.getValueAtFrame(i.id, e), o = n.get(i.target);
      o !== void 0 ? n.set(i.target, o + r) : n.set(i.target, r);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const i = /* @__PURE__ */ new Map();
    for (const r of this.mappings.values()) {
      if (!r.enabled || r.targetLayerId && r.targetLayerId !== e) continue;
      const o = this.getValueAtFrame(r.id, n), a = i.get(r.target);
      a !== void 0 ? i.set(r.target, a + o) : i.set(r.target, o);
    }
    return i;
  }
  /**
   * Apply curve shaping to a value
   */
  applyCurve(e, n) {
    const i = Math.max(0, Math.min(1, e));
    switch (n) {
      case "exponential":
        return i * i;
      case "logarithmic":
        return Math.sqrt(i);
      case "smoothstep":
        return i * i * (3 - 2 * i);
      case "bounce":
        if (i < 0.5)
          return 2 * i * i;
        {
          const r = i - 0.5;
          return 0.5 + 0.5 * (1 - Math.pow(1 - 2 * r, 2));
        }
      case "linear":
      default:
        return i;
    }
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear(), this.releaseEnvelopes.clear(), this.beatToggleStates.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0), this.releaseEnvelopes.set(e.id, 0), this.beatToggleStates.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear(), this.releaseEnvelopes.clear(), this.beatToggleStates.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
function Vd(s) {
  return {
    // Core
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    // Frequency bands
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    // Events
    onsets: "Beat Onsets",
    peaks: "Detected Peaks",
    // Enhanced features
    spectralFlux: "Spectral Flux (Transients)",
    zeroCrossingRate: "Zero Crossing (Percussive)",
    spectralRolloff: "Spectral Rolloff (High Freq)",
    spectralFlatness: "Spectral Flatness (Noise)",
    chromaEnergy: "Chroma Energy (Harmonic)",
    // Pitch classes
    chromaC: "Chroma: C",
    chromaCs: "Chroma: C#/Db",
    chromaD: "Chroma: D",
    chromaDs: "Chroma: D#/Eb",
    chromaE: "Chroma: E",
    chromaF: "Chroma: F",
    chromaFs: "Chroma: F#/Gb",
    chromaG: "Chroma: G",
    chromaGs: "Chroma: G#/Ab",
    chromaA: "Chroma: A",
    chromaAs: "Chroma: A#/Bb",
    chromaB: "Chroma: B"
  }[s] || s;
}
function Cv(s) {
  return {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  }[s] || s;
}
function vE() {
  return [
    // Core
    "amplitude",
    "rms",
    "spectralCentroid",
    // Frequency bands
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    // Events
    "onsets",
    "peaks",
    // Enhanced
    "spectralFlux",
    "zeroCrossingRate",
    "spectralRolloff",
    "spectralFlatness",
    "chromaEnergy",
    // Pitch classes
    "chromaC",
    "chromaCs",
    "chromaD",
    "chromaDs",
    "chromaE",
    "chromaF",
    "chromaFs",
    "chromaG",
    "chromaGs",
    "chromaA",
    "chromaAs",
    "chromaB"
  ];
}
function gE() {
  return {
    Energy: ["amplitude", "rms"],
    "Frequency Bands": ["sub", "bass", "lowMid", "mid", "highMid", "high"],
    Spectral: ["spectralCentroid", "spectralFlux", "spectralRolloff", "spectralFlatness"],
    Events: ["onsets", "peaks"],
    Harmonic: ["chromaEnergy", "zeroCrossingRate"],
    "Pitch Classes": [
      "chromaC",
      "chromaCs",
      "chromaD",
      "chromaDs",
      "chromaE",
      "chromaF",
      "chromaFs",
      "chromaG",
      "chromaGs",
      "chromaA",
      "chromaAs",
      "chromaB"
    ]
  };
}
function yE() {
  return {
    Particle: [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    Depthflow: [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    Path: ["path.position"],
    Layer: [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
  };
}
const xE = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class _E {
  // For amplitude mode release tracking
  constructor(e = {}) {
    fe(this, "config");
    fe(this, "state");
    fe(this, "pathSegments", []);
    fe(this, "totalLength", 0);
    fe(this, "releaseState", 0);
    this.config = { ...xE, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], i = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let r = 0, o = 0;
    for (const a of i) {
      const l = a[0].toUpperCase(), c = a.slice(1).trim().split(/[\s,]+/).map(Number).filter((u) => !isNaN(u));
      switch (l) {
        case "M":
          r = c[0] || 0, o = c[1] || 0, n.push({
            type: "M",
            points: [r, o],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [r, o, c[0], c[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[0], o = c[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [r, o, c[0], c[1], c[2], c[3], c[4], c[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[4], o = c[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [r, o, c[0], c[1], c[2], c[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[2], o = c[3];
          break;
        case "Z":
          const u = n.find((d) => d.type === "M");
          u && n.push({
            type: "L",
            points: [r, o, u.points[0], u.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], i = e[3] - e[1];
    return Math.sqrt(n * n + i * i);
  }
  bezierLength(e, n) {
    let r = 0, o = e[0], a = e[1];
    for (let l = 1; l <= 20; l++) {
      const c = l / 20, { x: u, y: d } = this.getBezierPoint(e, c, n), h = u - o, m = d - a;
      r += Math.sqrt(h * h + m * m), o = u, a = d;
    }
    return r;
  }
  getBezierPoint(e, n, i) {
    if (i === 2) {
      const r = 1 - n;
      return {
        x: r * r * e[0] + 2 * r * n * e[2] + n * n * e[4],
        y: r * r * e[1] + 2 * r * n * e[3] + n * n * e[5]
      };
    } else {
      const r = 1 - n, o = r * r, a = n * n;
      return {
        x: o * r * e[0] + 3 * o * n * e[2] + 3 * r * a * e[4] + a * n * e[6],
        y: o * r * e[1] + 3 * o * n * e[3] + 3 * r * a * e[5] + a * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const i = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = i, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(i) : this.updateAccumulateMode(i, n);
    const r = this.getPositionOnPath(this.state.position);
    return this.state.x = r.x, this.state.y = r.y, this.state.angle = r.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const r = 1 - this.config.release * 0.95;
      this.releaseState *= r;
    }
    const i = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, i * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const i = e * this.config.sensitivity * 0.02 * this.state.direction;
    let r = this.state.position + i;
    r > 1 ? (r = 2 - r, this.state.direction = -1) : r < 0 && (r = -r, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, r));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const u of this.pathSegments)
      if (u.type !== "M" && e >= u.startT && e <= u.endT) {
        n = u;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const i = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let r, o, a, l;
    switch (n.type) {
      case "L":
        r = n.points[0] + (n.points[2] - n.points[0]) * i, o = n.points[1] + (n.points[3] - n.points[1]) * i, a = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const u = this.getBezierPoint(n.points, i, 2);
        r = u.x, o = u.y;
        const d = 1 - i;
        a = 2 * d * (n.points[2] - n.points[0]) + 2 * i * (n.points[4] - n.points[2]), l = 2 * d * (n.points[3] - n.points[1]) + 2 * i * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const u = this.getBezierPoint(n.points, i, 3);
        r = u.x, o = u.y;
        const d = 1 - i, h = d * d, m = i * i;
        a = 3 * h * (n.points[2] - n.points[0]) + 6 * d * i * (n.points[4] - n.points[2]) + 3 * m * (n.points[6] - n.points[4]), l = 3 * h * (n.points[3] - n.points[1]) + 6 * d * i * (n.points[5] - n.points[3]) + 3 * m * (n.points[7] - n.points[5]);
        break;
      }
      default:
        r = 0, o = 0, a = 1, l = 0;
    }
    const c = Math.atan2(l, a);
    return { x: r, y: o, angle: c };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], i = this.state.previousPosition, r = this.state.position;
    for (let o = 0; o <= e; o++) {
      const a = i + (r - i) * (o / e), l = this.getPositionOnPath(a), c = o / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: c });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
function bE(s) {
  switch (s) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "point3d":
      return "vector3";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const cu = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, Qh = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function wE(s) {
  const e = cu[s];
  if (!e) return null;
  const n = {};
  return e.parameters.forEach((i, r) => {
    const o = i.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    n[o] = {
      id: `${s}-${o}-${r}`,
      name: i.name,
      type: bE(i.type),
      value: i.defaultValue,
      animated: !1,
      keyframes: []
    };
  }), {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: s,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: n
  };
}
const SE = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];
class ME {
  constructor() {
    fe(this, "drivers", /* @__PURE__ */ new Map());
    fe(this, "smoothedValues", /* @__PURE__ */ new Map());
    fe(this, "audioAnalysis", null);
    fe(this, "propertyGetter", null);
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(e) {
    this.audioAnalysis = e;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(e) {
    this.propertyGetter = e;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(e) {
    return e.sourceType === "property" && e.sourceLayerId && e.sourceProperty && this.wouldCreateCycle(e) ? (Jt.warn("PropertyDriverSystem: Cannot add driver: would create circular dependency"), !1) : (this.drivers.set(e.id, e), this.smoothedValues.set(e.id, 0), !0);
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(e) {
    if (e.sourceType !== "property" || !e.sourceLayerId || !e.sourceProperty) return !1;
    const n = /* @__PURE__ */ new Set(), i = `${e.targetLayerId}:${e.targetProperty}`, r = (o, a) => {
      const l = `${o}:${a}`;
      if (l === i) return !0;
      if (n.has(l)) return !1;
      n.add(l);
      for (const c of this.drivers.values())
        if (c.sourceType === "property" && !(c.targetLayerId !== o || c.targetProperty !== a) && !(!c.sourceLayerId || !c.sourceProperty) && r(c.sourceLayerId, c.sourceProperty))
          return !0;
      return !1;
    };
    return r(e.sourceLayerId, e.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(e) {
    this.drivers.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update a driver
   */
  updateDriver(e, n) {
    const i = this.drivers.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a driver by ID
   */
  getDriver(e) {
    return this.drivers.get(e);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(e) {
    return Array.from(this.drivers.values()).filter((n) => n.targetLayerId === e);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(e, n) {
    return Array.from(this.drivers.values()).filter(
      (i) => i.targetLayerId === e && i.targetProperty === n && i.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(e, n, i) {
    if (!e.enabled) return i;
    let r = this.getSourceValue(e, n);
    return r === null ? i : (r = this.applyTransforms(e, r), this.blendValue(i, r, e.blendMode, e.blendAmount));
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(e, n) {
    switch (e.sourceType) {
      case "property":
        return this.getPropertySourceValue(e, n);
      case "audio":
        return this.getAudioSourceValue(e, n);
      case "time":
        return n;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(e, n) {
    return !this.propertyGetter || !e.sourceLayerId || !e.sourceProperty ? null : this.propertyGetter(e.sourceLayerId, e.sourceProperty, n);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(e, n) {
    if (!this.audioAnalysis || !e.audioFeature)
      return null;
    let i = gl(this.audioAnalysis, e.audioFeature, n);
    return e.audioThreshold !== void 0 && (e.audioAboveThreshold ? i = i > e.audioThreshold ? i : 0 : i = i >= e.audioThreshold ? i : 0), i;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(e, n) {
    for (const i of e.transforms)
      n = this.applyTransform(e.id, i, n);
    return n;
  }
  /**
   * Apply a single transform
   */
  applyTransform(e, n, i) {
    switch (n.type) {
      case "scale":
        return i * (n.factor ?? 1);
      case "offset":
        return i + (n.amount ?? 0);
      case "clamp":
        return Math.max(n.min ?? -1 / 0, Math.min(n.max ?? 1 / 0, i));
      case "smooth": {
        const r = this.smoothedValues.get(e) ?? i, o = n.smoothing ?? 0.5, a = r * o + i * (1 - o);
        return this.smoothedValues.set(e, a), a;
      }
      case "invert":
        return 1 - i;
      case "remap": {
        const r = n.inMin ?? 0, o = n.inMax ?? 1, a = n.outMin ?? 0, l = n.outMax ?? 1, c = (i - r) / (o - r);
        return a + c * (l - a);
      }
      case "threshold":
        return i > (n.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const r = n.frequency ?? 1, o = n.amplitude ?? 1, a = n.phase ?? 0;
        return Math.sin((i * r + a) * Math.PI * 2) * o;
      }
      default:
        return i;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(e, n, i, r) {
    let o;
    switch (i) {
      case "replace":
        o = n;
        break;
      case "add":
        o = e + n;
        break;
      case "multiply":
        o = e * n;
        break;
      default:
        o = n;
    }
    return e * (1 - r) + o * r;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(e, n, i) {
    const r = /* @__PURE__ */ new Map(), o = this.getDriversForLayer(e);
    for (const a of o) {
      if (!a.enabled) continue;
      const l = i.get(a.targetProperty) ?? 0, c = this.evaluateDriver(a, n, l), u = r.get(a.targetProperty);
      u !== void 0 ? r.set(a.targetProperty, u + c - l) : r.set(a.targetProperty, c);
    }
    return r;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addDriver(n);
  }
}
function Dy(s, e, n = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: !0,
    targetLayerId: s,
    targetProperty: e,
    sourceType: n,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function CE(s, e, n, i = {}) {
  const r = Dy(s, e, "audio");
  return r.audioFeature = n, r.audioThreshold = i.threshold ?? 0, r.audioAboveThreshold = i.threshold !== void 0, i.scale !== void 0 && i.scale !== 1 && r.transforms.push({ type: "scale", factor: i.scale }), i.offset !== void 0 && i.offset !== 0 && r.transforms.push({ type: "offset", amount: i.offset }), i.smoothing !== void 0 && i.smoothing > 0 && r.transforms.push({ type: "smooth", smoothing: i.smoothing }), r;
}
function TE(s, e, n, i, r = {}) {
  const o = Dy(s, e, "property");
  return o.sourceLayerId = n, o.sourceProperty = i, o.blendMode = r.blendMode ?? "add", r.scale !== void 0 && r.scale !== 1 && o.transforms.push({ type: "scale", factor: r.scale }), r.offset !== void 0 && r.offset !== 0 && o.transforms.push({ type: "offset", amount: r.offset }), o;
}
const EE = {
  enabled: !0,
  snapToGrid: !0,
  snapToKeyframes: !0,
  snapToBeats: !0,
  snapToPeaks: !0,
  snapToLayerBounds: !0,
  snapToPlayhead: !0,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function Kf(s, e, n, i) {
  var l, c;
  if (!e.enabled)
    return null;
  const r = [], o = e.threshold / n;
  if (e.snapToGrid) {
    const u = Math.round(s / e.gridInterval) * e.gridInterval, d = Math.abs(s - u);
    d <= o && r.push({
      frame: u,
      type: "frame",
      distance: d * n
    });
  }
  if (e.snapToKeyframes && i.layers)
    for (const u of i.layers)
      u.id !== i.selectedLayerId && AE(u, s, o, n, r);
  if (e.snapToBeats && ((l = i.audioAnalysis) != null && l.onsets))
    for (const u of i.audioAnalysis.onsets) {
      const d = Math.abs(s - u);
      d <= o && r.push({
        frame: u,
        type: "beat",
        distance: d * n
      });
    }
  if (e.snapToPeaks && ((c = i.peakData) != null && c.indices))
    for (const u of i.peakData.indices) {
      const d = Math.abs(s - u);
      d <= o && r.push({
        frame: u,
        type: "peak",
        distance: d * n
      });
    }
  if (e.snapToLayerBounds && i.layers)
    for (const u of i.layers) {
      if (u.id === i.selectedLayerId) continue;
      const d = Math.abs(s - u.inPoint), h = Math.abs(s - u.outPoint);
      d <= o && r.push({
        frame: u.inPoint,
        type: "layer-in",
        distance: d * n
      }), h <= o && r.push({
        frame: u.outPoint,
        type: "layer-out",
        distance: h * n
      });
    }
  if (e.snapToPlayhead && i.currentFrame !== void 0) {
    const u = Math.abs(s - i.currentFrame);
    u <= o && u > 0 && r.push({
      frame: i.currentFrame,
      type: "playhead",
      distance: u * n
    });
  }
  if (r.length === 0)
    return null;
  const a = {
    playhead: 5,
    beat: 4,
    peak: 4,
    keyframe: 3,
    "layer-in": 2,
    "layer-out": 2,
    frame: 1
  };
  return r.sort((u, d) => {
    const h = u.distance - d.distance;
    return Math.abs(h) < 0.5 ? a[d.type] - a[u.type] : h;
  }), r[0];
}
function AE(s, e, n, i, r) {
  const o = [
    s.transform.position,
    s.transform.scale,
    s.transform.rotation,
    s.opacity,
    ...s.properties
  ];
  for (const a of o)
    if (!(!a.animated || !a.keyframes))
      for (const l of a.keyframes) {
        const c = Math.abs(e - l.frame);
        c <= n && (r.some((u) => u.frame === l.frame && u.type === "keyframe") || r.push({
          frame: l.frame,
          type: "keyframe",
          distance: c * i
        }));
      }
}
function PE(s) {
  return (s == null ? void 0 : s.onsets) ?? [];
}
function RE(s) {
  return (s == null ? void 0 : s.indices) ?? [];
}
const sn = /* @__PURE__ */ z_("compositor", {
  state: () => ({
    project: fE(1024, 1024),
    activeCompositionId: "main",
    openCompositionIds: ["main"],
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    selectedPropertyPath: null,
    currentTool: "select",
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: Ey(),
    viewOptions: XT(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ...EE },
    // Clipboard
    clipboard: {
      layers: [],
      keyframes: []
    }
  }),
  getters: {
    // Active composition helper
    activeComposition: (s) => s.project.compositions[s.activeCompositionId] || null,
    // Project info - now uses active composition
    hasProject: (s) => s.sourceImage !== null,
    width(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.width) || 1024;
    },
    height(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.height) || 1024;
    },
    frameCount(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.frameCount) || 81;
    },
    fps(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.fps) || 16;
    },
    duration(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.duration) || 5;
    },
    // Current frame - per composition
    currentFrame(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.currentFrame) || 0;
    },
    currentTime(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return e ? e.currentFrame / e.settings.fps : 0;
    },
    // Layers - from active composition
    layers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.layers) || [];
    },
    visibleLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.visible);
    },
    // Selection
    selectedLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => s.selectedLayerIds.includes(n.id));
    },
    selectedLayer(s) {
      if (s.selectedLayerIds.length !== 1) return null;
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).find((n) => n.id === s.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (s) => Object.values(s.project.compositions),
    openCompositions(s) {
      return s.openCompositionIds.map((e) => s.project.compositions[e]).filter(Boolean);
    },
    // Assets
    assets: (s) => s.project.assets,
    // History
    canUndo: (s) => s.historyIndex > 0,
    canRedo: (s) => s.historyIndex < s.historyStack.length - 1,
    // Camera
    activeCamera: (s) => s.activeCameraId && s.cameras.get(s.activeCameraId) || null,
    allCameras: (s) => Array.from(s.cameras.values()),
    cameraLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const s = this.project.compositions[this.activeCompositionId];
      return (s == null ? void 0 : s.layers) || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(s, e, n = !1) {
      const i = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, r = this.project.compositions[this.activeCompositionId], o = {
        width: (e == null ? void 0 : e.width) ?? (r == null ? void 0 : r.settings.width) ?? 1024,
        height: (e == null ? void 0 : e.height) ?? (r == null ? void 0 : r.settings.height) ?? 1024,
        frameCount: (e == null ? void 0 : e.frameCount) ?? (r == null ? void 0 : r.settings.frameCount) ?? 81,
        fps: (e == null ? void 0 : e.fps) ?? (r == null ? void 0 : r.settings.fps) ?? 16,
        duration: 0,
        backgroundColor: (e == null ? void 0 : e.backgroundColor) ?? "#000000",
        autoResizeToContent: (e == null ? void 0 : e.autoResizeToContent) ?? !0
      };
      o.duration = o.frameCount / o.fps;
      const a = {
        id: i,
        name: s,
        settings: o,
        layers: [],
        currentFrame: 0,
        isPrecomp: n
      };
      return this.project.compositions[i] = a, this.openCompositionIds.includes(i) || this.openCompositionIds.push(i), this.activeCompositionId = i, Jt.debug("Created composition:", s, i), a;
    },
    /**
     * Delete a composition
     */
    deleteComposition(s) {
      if (s === this.project.mainCompositionId)
        return Jt.warn("Cannot delete main composition"), !1;
      if (!this.project.compositions[s]) return !1;
      delete this.project.compositions[s];
      const n = this.openCompositionIds.indexOf(s);
      return n >= 0 && this.openCompositionIds.splice(n, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId), Jt.debug("Deleted composition:", s), !0;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(s) {
      if (!this.project.compositions[s]) {
        Jt.warn("Composition not found:", s);
        return;
      }
      this.openCompositionIds.includes(s) || this.openCompositionIds.push(s), this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.activeCompositionId = s, Jt.debug("Switched to composition:", s);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(s) {
      if (this.openCompositionIds.length <= 1) {
        Jt.warn("Cannot close the last tab");
        return;
      }
      const e = this.openCompositionIds.indexOf(s);
      e >= 0 && this.openCompositionIds.splice(e, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[Math.max(0, e - 1)]);
    },
    /**
     * Rename a composition
     */
    renameComposition(s, e) {
      const n = this.project.compositions[s];
      n && (n.name = e);
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(s, e) {
      const n = this.project.compositions[s];
      if (!n) return;
      const i = n.settings.frameCount;
      if (Object.assign(n.settings, e), n.settings.duration = n.settings.frameCount / n.settings.fps, e.frameCount && e.frameCount > i)
        for (const r of n.layers)
          r.outPoint === i - 1 && (r.outPoint = e.frameCount - 1);
      s === this.project.mainCompositionId && Object.assign(this.project.composition, n.settings);
    },
    /**
     * Get a composition by ID
     */
    getComposition(s) {
      return this.project.compositions[s] || null;
    },
    /**
     * Pre-compose selected layers into a new composition
     */
    precomposeSelectedLayers(s) {
      if (this.selectedLayerIds.length === 0)
        return Jt.warn("No layers selected for pre-compose"), null;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return null;
      const n = this.createComposition(
        s || "Pre-comp",
        e.settings,
        !0
      ), i = e.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      ), r = Math.min(...i.map((l) => l.inPoint));
      for (const l of i) {
        l.inPoint -= r, l.outPoint -= r;
        const c = e.layers.indexOf(l);
        c >= 0 && e.layers.splice(c, 1), n.layers.push(l);
      }
      const o = Math.max(...n.layers.map((l) => l.outPoint));
      n.settings.frameCount = o + 1, n.settings.duration = n.settings.frameCount / n.settings.fps;
      const a = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: n.name,
        type: "precomp",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        inPoint: r,
        outPoint: r + n.settings.frameCount - 1,
        parentId: null,
        transform: Bd(),
        opacity: Wt("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: !1,
        data: {
          compositionId: n.id,
          timeRemapEnabled: !1,
          collapseTransformations: !1
        }
      };
      return e.layers.push(a), this.selectedLayerIds = [], this.activeCompositionId = e.id, Jt.debug("Pre-composed layers into:", n.name), n;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(s) {
      this.comfyuiNodeId = s.node_id, this.sourceImage = s.source_image, this.depthMap = s.depth_map;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return;
      const n = e.settings.frameCount;
      if (e.settings.width = s.width, e.settings.height = s.height, e.settings.frameCount = s.frame_count, e.settings.duration = s.frame_count / e.settings.fps, this.project.composition.width = s.width, this.project.composition.height = s.height, this.project.composition.frameCount = s.frame_count, this.project.composition.duration = s.frame_count / this.project.composition.fps, s.frame_count > n)
        for (const i of e.layers)
          i.outPoint === n - 1 && (i.outPoint = s.frame_count - 1);
      s.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.source_image
      }), s.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.depth_map
      }), e && (e.currentFrame = 0), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), Jt.debug("Loaded inputs from ComfyUI:", {
        width: s.width,
        height: s.height,
        frameCount: s.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(s, e) {
      const n = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let i = null;
      switch (s) {
        case "text":
          i = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: !1,
            pathPerpendicularToPath: !0,
            pathForceAlignment: !1,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          i = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          i = {
            size: 40
          };
          break;
        case "spline":
          i = {
            pathData: "",
            controlPoints: [],
            closed: !1,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          i = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: !1,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: !0,
              burstOnBeat: !1,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: !1,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: !1,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: !1,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: !1,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: !0
              }
            }
          };
          break;
        case "depthflow":
          i = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: !1
            }
          };
          break;
        case "light":
          i = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: !1,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          i = {
            cameraId: null,
            isActiveCamera: !1
          };
          break;
        case "image":
          i = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          i = {
            assetId: null,
            loop: !1,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let r;
      (s === "video" || s === "audio") && (r = {
        level: Wt("Audio Levels", 0, "number")
        // 0dB default
      });
      const o = this.getActiveComp(), a = this.getActiveCompLayers(), l = {
        id: n,
        name: e || `${s.charAt(0).toUpperCase() + s.slice(1)} ${a.length + 1}`,
        type: s,
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((o == null ? void 0 : o.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Wt("opacity", 100, "number"),
        transform: Bd(),
        audio: r,
        properties: [],
        effects: [],
        data: i
      };
      return s === "camera" && Jt.warn("Use createCameraLayer() for camera layers"), a.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), l;
    },
    /**
     * Delete a layer
     */
    deleteLayer(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex((i) => i.id === s);
      n !== -1 && (e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((i) => i !== s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(s) {
      const e = this.getActiveCompLayers(), n = e.find((o) => o.id === s);
      if (!n) return null;
      const i = JSON.parse(JSON.stringify(n));
      if (i.id = crypto.randomUUID(), i.name = n.name + " Copy", i.transform)
        for (const o of Object.keys(i.transform)) {
          const a = i.transform[o];
          a != null && a.keyframes && (a.keyframes = a.keyframes.map((l) => ({
            ...l,
            id: crypto.randomUUID()
          })));
        }
      if (i.properties)
        for (const o of i.properties)
          o.keyframes && (o.keyframes = o.keyframes.map((a) => ({
            ...a,
            id: crypto.randomUUID()
          })));
      const r = e.findIndex((o) => o.id === s);
      return e.splice(r, 0, i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), i;
    },
    /**
     * Copy selected layers to clipboard
     */
    copySelectedLayers() {
      const e = this.getActiveCompLayers().filter((n) => this.selectedLayerIds.includes(n.id));
      e.length !== 0 && (this.clipboard.layers = e.map((n) => JSON.parse(JSON.stringify(n))), Jt.debug(`Copied ${this.clipboard.layers.length} layer(s) to clipboard`));
    },
    /**
     * Paste layers from clipboard
     */
    pasteLayers() {
      if (this.clipboard.layers.length === 0) return [];
      const s = this.getActiveCompLayers(), e = [];
      for (const n of this.clipboard.layers) {
        const i = JSON.parse(JSON.stringify(n));
        if (i.id = crypto.randomUUID(), i.name = n.name + " Copy", i.transform)
          for (const r of Object.keys(i.transform)) {
            const o = i.transform[r];
            o != null && o.keyframes && (o.keyframes = o.keyframes.map((a) => ({
              ...a,
              id: crypto.randomUUID()
            })));
          }
        if (i.properties)
          for (const r of i.properties)
            r.keyframes && (r.keyframes = r.keyframes.map((o) => ({
              ...o,
              id: crypto.randomUUID()
            })));
        i.parentId = null, s.unshift(i), e.push(i);
      }
      return this.selectedLayerIds = e.map((n) => n.id), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), Jt.debug(`Pasted ${e.length} layer(s)`), e;
    },
    /**
     * Cut selected layers (copy + delete)
     */
    cutSelectedLayers() {
      this.copySelectedLayers();
      const s = [...this.selectedLayerIds];
      for (const e of s)
        this.deleteLayer(e);
    },
    /**
     * Update layer properties
     */
    updateLayer(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      !n || !n.data || (Object.assign(n.data, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      i.controlPoints || (i.controlPoints = []), i.controlPoints.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(s, e, n) {
      var a;
      const i = this.getActiveCompLayers().find((l) => l.id === s);
      if (!i || i.type !== "spline" || !i.data) return;
      const o = (a = i.data.controlPoints) == null ? void 0 : a.find((l) => l.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      if (!i.controlPoints) return;
      const r = i.controlPoints.findIndex((o) => o.id === e);
      r >= 0 && (i.controlPoints.splice(r, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(s) {
      const e = this.getActiveCompLayers().find((n) => n.id === s);
      if (e) {
        if (e.threeD = !e.threeD, e.threeD) {
          const n = e.transform, i = n.position.value;
          n.position.value = { x: i.x, y: i.y, z: i.z ?? 0 }, n.position.type = "vector3";
          const r = n.anchorPoint.value;
          n.anchorPoint.value = { x: r.x, y: r.y, z: r.z ?? 0 }, n.anchorPoint.type = "vector3";
          const o = n.scale.value;
          n.scale.value = { x: o.x, y: o.y, z: o.z ?? 100 }, n.scale.type = "vector3", n.orientation || (n.orientation = Wt("orientation", { x: 0, y: 0, z: 0 }, "vector3")), n.rotationX || (n.rotationX = Wt("rotationX", 0, "number")), n.rotationY || (n.rotationY = Wt("rotationY", 0, "number")), n.rotationZ || (n.rotationZ = Wt("rotationZ", 0, "number"), n.rotationZ.value = n.rotation.value);
        } else
          e.transform.rotationZ && (e.transform.rotation.value = e.transform.rotationZ.value);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Reorder layers
     */
    moveLayer(s, e) {
      const n = this.getActiveCompLayers(), i = n.findIndex((o) => o.id === s);
      if (i === -1) return;
      const [r] = n.splice(i, 1);
      n.splice(e, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(s, e = !1) {
      e ? this.selectedLayerIds.includes(s) || this.selectedLayerIds.push(s) : this.selectedLayerIds = [s];
    },
    deselectLayer(s) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== s);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(s, e) {
      const n = this.getActiveCompLayers(), i = n.find((r) => r.id === s);
      if (i && e !== s) {
        if (e) {
          const r = (a) => {
            const l = n.filter((u) => u.parentId === a);
            let c = l.map((u) => u.id);
            for (const u of l)
              c = c.concat(r(u.id));
            return c;
          };
          if (new Set(r(s)).has(e)) {
            Jt.warn("Cannot set parent: would create circular reference");
            return;
          }
        }
        i.parentId = e, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
      }
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.selectedPropertyPath = null;
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(s) {
      this.selectedPropertyPath = s;
    },
    /**
     * Playback controls
     */
    play() {
      if (this.isPlaying) return;
      const s = this.getActiveComp();
      s && (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = s.currentFrame, this.playbackLoop());
    },
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const s = this.getActiveComp();
      if (!s) return;
      const e = performance.now() - (this.playbackStartTime || 0), n = s.settings.fps, i = s.settings.frameCount, r = Math.floor(e / 1e3 * n);
      let o = this.playbackStartFrame + r;
      o >= i && (o = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), s.currentFrame = o, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    setFrame(s) {
      const e = this.getActiveComp();
      e && (e.currentFrame = Math.max(0, Math.min(s, e.settings.frameCount - 1)));
    },
    nextFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame < s.settings.frameCount - 1 && s.currentFrame++;
    },
    prevFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame > 0 && s.currentFrame--;
    },
    goToStart() {
      const s = this.getActiveComp();
      s && (s.currentFrame = 0);
    },
    goToEnd() {
      const s = this.getActiveComp();
      s && (s.currentFrame = s.settings.frameCount - 1);
    },
    /**
     * Tool selection
     */
    setTool(s) {
      this.currentTool = s;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const s = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(s), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(s) {
      try {
        const e = JSON.parse(s);
        this.project = e, this.pushHistory();
      } catch (e) {
        Jt.error("Failed to import project:", e);
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(s) {
      var e;
      return an(s, ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(s, e, n, i) {
      var u, d, h;
      const r = i ?? ((u = this.getActiveComp()) == null ? void 0 : u.currentFrame) ?? 0;
      Jt.debug("addKeyframe called:", { layerId: s, propertyName: e, value: n, frame: r });
      const o = this.getActiveCompLayers().find((m) => m.id === s);
      if (!o)
        return Jt.debug("addKeyframe: layer not found"), null;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : e === "opacity" ? a = o.opacity : a = o.properties.find((m) => m.name === e), !a)
        return Jt.debug("addKeyframe: property not found:", e), null;
      a.animated = !0;
      const l = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: r,
        value: n,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 },
        controlMode: "smooth"
      }, c = a.keyframes.findIndex((m) => m.frame === r);
      return c >= 0 ? (a.keyframes[c] = l, Jt.debug("addKeyframe: replaced existing keyframe at frame", ((d = this.getActiveComp()) == null ? void 0 : d.currentFrame) ?? 0)) : (a.keyframes.push(l), a.keyframes.sort((m, p) => m.frame - p.frame), Jt.debug("addKeyframe: added new keyframe at frame", ((h = this.getActiveComp()) == null ? void 0 : h.currentFrame) ?? 0, "total keyframes:", a.keyframes.length)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), l;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((a) => a.name === e), !r) return;
      const o = r.keyframes.findIndex((a) => a.id === n);
      o >= 0 && (r.keyframes.splice(o, 1), r.keyframes.length === 0 && (r.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((o) => o.name === e), !!r) {
        if (r.value = n, r.animated && r.keyframes.length > 0) {
          const o = r.keyframes.find((a) => {
            var l;
            return a.frame === (((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0);
          });
          o && (o.value = n);
        }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return;
      let r;
      e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((o) => o.name === e), r && (r.animated = n, n && r.keyframes.length === 0 && this.addKeyframe(s, e, r.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(s, e, n, i) {
      const r = this.getActiveCompLayers().find((c) => c.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((c) => c.name === e), !o) return;
      const a = o.keyframes.find((c) => c.id === n);
      if (!a) return;
      const l = o.keyframes.find((c) => c.frame === i && c.id !== n);
      l && (o.keyframes = o.keyframes.filter((c) => c.id !== l.id)), a.frame = i, o.keyframes.sort((c, u) => c.frame - u.frame), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set keyframe value (for graph editor numeric input)
     */
    setKeyframeValue(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((l) => l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (typeof a.value == "object" && a.value !== null ? Jt.warn("setKeyframeValue: Cannot directly update vector keyframes from graph editor. Use separate dimension curves.") : a.value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((l) => l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (a.interpolation = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "opacity" ? o = r.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : o = r.properties.find((l) => l.id === e || l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (i.frame !== void 0 && (a.frame = i.frame, o.keyframes.sort((l, c) => l.frame - c.frame)), i.value !== void 0 && (a.value = i.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(s, e, n, i, r) {
      const o = this.getActiveCompLayers().find((c) => c.id === s);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "opacity" ? a = o.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : a = o.properties.find((c) => c.id === e || c.name === e), !a) return;
      const l = a.keyframes.find((c) => c.id === n);
      l && (i === "in" ? l.inHandle = { ...r } : l.outHandle = { ...r }, r.enabled && l.interpolation === "linear" && (l.interpolation = "bezier"), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(s = "Text") {
      const e = this.createLayer("text", s.substring(0, 20)), n = {
        text: s,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: !1,
        pathPerpendicularToPath: !0,
        pathForceAlignment: !1,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: !1
      };
      return e.data = n, e.properties.push(Wt("Font Size", 72, "number", "Text")), e.properties.push(Wt("Fill Color", "#ffffff", "color", "Text")), e.properties.push(Wt("Stroke Color", "#000000", "color", "Text")), e.properties.push(Wt("Stroke Width", 0, "number", "Text")), e.properties.push(Wt("Path Offset", 0, "number", "Path Options")), e.properties.push(Wt("First Margin", 0, "number", "Path Options")), e.properties.push(Wt("Last Margin", 0, "number", "Path Options")), e.properties.push(Wt("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options")), e.properties.push(Wt("Tracking", 0, "number", "Advanced")), e.properties.push(Wt("Line Spacing", 0, "number", "Advanced")), e.properties.push(Wt("Character Offset", 0, "number", "Advanced")), e.properties.push(Wt("Character Value", 0, "number", "Advanced")), e.properties.push(Wt("Blur", { x: 0, y: 0 }, "position", "Advanced")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const s = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return s.data = e, s;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const s = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return s.data = e, s;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i || i.type !== "particles") return;
      const o = i.data.emitters.find((a) => a.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      i.emitters = i.emitters.filter((r) => r.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(s = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), i = {
        sourceLayerId: s,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: Wt("zoom", 1, "number"),
        animatedOffsetX: Wt("offsetX", 0, "number"),
        animatedOffsetY: Wt("offsetY", 0, "number"),
        animatedRotation: Wt("rotation", 0, "number"),
        animatedDepthScale: Wt("depthScale", 1, "number")
      };
      return n.data = i, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "depthflow") return;
      const i = n.data;
      Object.assign(i.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(s, e = !0) {
      let n;
      try {
        n = URL.createObjectURL(s);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let i;
      try {
        i = await HT(n);
      } catch (c) {
        throw URL.revokeObjectURL(n), new Error(`Failed to load video metadata: ${c.message}`);
      }
      const r = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = {
        id: r,
        type: "video",
        source: "file",
        width: i.width,
        height: i.height,
        data: n,
        // Video-specific metadata
        duration: i.duration,
        frameCount: i.frameCount,
        fps: i.fps,
        hasAudio: i.hasAudio
      };
      if (this.project.assets[r] = o, e) {
        const c = $T(i, this.project.composition.fps);
        Jt.debug("Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: c.width,
          newHeight: c.height,
          newFrameCount: c.frameCount,
          videoDuration: i.duration
        }), this.project.composition.width = c.width, this.project.composition.height = c.height, this.project.composition.frameCount = c.frameCount, this.project.composition.duration = c.frameCount / this.project.composition.fps;
      }
      const a = this.createLayer("video", s.name.replace(/\.[^.]+$/, "")), l = {
        assetId: r,
        loop: !1,
        pingPong: !1,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: i.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      if (a.data = l, !e) {
        const c = Math.ceil(i.duration * this.project.composition.fps);
        a.outPoint = Math.min(c - 1, this.project.composition.frameCount - 1);
      }
      return this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), Jt.debug("Created video layer:", {
        layerId: a.id,
        assetId: r,
        dimensions: `${i.width}x${i.height}`,
        duration: `${i.duration.toFixed(2)}s`,
        frameCount: i.frameCount,
        hasAudio: i.hasAudio
      }), a;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      if (!i.assetId) return;
      const r = this.project.assets[i.assetId];
      r && (r.width = e.width, r.height = e.height, r.duration = e.duration, r.frameCount = e.frameCount, r.fps = e.fps, r.hasAudio = e.hasAudio), Jt.debug("Video metadata loaded:", { layerId: s, metadata: e });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(s, e, n) {
      const i = this.getActiveComp();
      if (!i) return;
      const r = i.settings.frameCount;
      if (i.settings.width = s, i.settings.height = e, this.project.composition.width = s, this.project.composition.height = e, n !== void 0 && (i.settings.frameCount = n, i.settings.duration = n / i.settings.fps, this.project.composition.frameCount = n, this.project.composition.duration = n / this.project.composition.fps, n > r))
        for (const o of i.layers)
          o.outPoint === r - 1 && (o.outPoint = n - 1);
      i.currentFrame >= i.settings.frameCount && (i.currentFrame = i.settings.frameCount - 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), Jt.debug("Composition resized:", {
        width: s,
        height: e,
        frameCount: i.settings.frameCount
      });
    },
    // ============================================================
    // PRECOMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a precomp layer referencing another composition
     * (For future multi-composition architecture)
     */
    createPrecompLayer(s, e) {
      const n = this.createLayer("precomp", e || "Precomp"), i = {
        compositionId: s,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        collapseTransformations: !1,
        overrideFrameRate: !1,
        frameRate: void 0
      };
      return n.data = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), n;
    },
    /**
     * Update precomp layer data
     */
    updatePrecompLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "precomp") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // EFFECT ACTIONS
    // ============================================================
    /**
     * Add effect to layer
     */
    addEffectToLayer(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n) return;
      const i = wE(e);
      i && (n.effects || (n.effects = []), n.effects.push(i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Remove effect from layer
     */
    removeEffectFromLayer(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.findIndex((r) => r.id === e);
      i >= 0 && (n.effects.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update effect parameter value
     */
    updateEffectParameter(s, e, n, i) {
      const r = this.getActiveCompLayers().find((a) => a.id === s);
      if (!r || !r.effects) return;
      const o = r.effects.find((a) => a.id === e);
      !o || !o.parameters[n] || (o.parameters[n].value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle effect parameter animation state
     */
    setEffectParamAnimated(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r || !r.effects) return;
      const o = r.effects.find((l) => l.id === e);
      if (!o || !o.parameters[n]) return;
      const a = o.parameters[n];
      a.animated = i, i && (!a.keyframes || a.keyframes.length === 0) && (a.keyframes = [{
        id: `kf_${Date.now()}`,
        frame: this.currentFrame,
        value: a.value,
        interpolation: "linear",
        inHandle: { frame: -5, value: 0, enabled: !1 },
        outHandle: { frame: 5, value: 0, enabled: !1 },
        controlMode: "smooth"
      }]), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Toggle effect enabled state
     */
    toggleEffect(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.find((r) => r.id === e);
      i && (i.enabled = !i.enabled, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder effects in stack
     */
    reorderEffects(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i || !i.effects || e < 0 || e >= i.effects.length || n < 0 || n >= i.effects.length) return;
      const [r] = i.effects.splice(e, 1);
      i.effects.splice(n, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get evaluated effect parameter value at a given frame
     */
    getEffectParameterValue(s, e, n, i) {
      var c;
      const r = this.getActiveCompLayers().find((u) => u.id === s);
      if (!r || !r.effects) return null;
      const o = r.effects.find((u) => u.id === e);
      if (!o || !o.parameters[n]) return null;
      const a = o.parameters[n], l = i ?? ((c = this.getActiveComp()) == null ? void 0 : c.currentFrame) ?? 0;
      return a.animated && a.keyframes.length > 0 ? an(a, l) : a.value;
    },
    // ============================================================
    // CAMERA ACTIONS
    // ============================================================
    /**
     * Create a new camera and corresponding layer
     * Returns both the camera and the layer
     */
    createCameraLayer(s) {
      const e = this.getActiveComp(), n = this.getActiveCompLayers(), i = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, r = s || `Camera ${this.cameras.size + 1}`, o = Ty(
        i,
        (e == null ? void 0 : e.settings.width) || 1024,
        (e == null ? void 0 : e.settings.height) || 1024
      );
      o.name = r, this.cameras.set(i, o), this.activeCameraId || (this.activeCameraId = i);
      const a = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, l = {
        id: a,
        name: r,
        type: "camera",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !0,
        // Cameras are always 3D
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((e == null ? void 0 : e.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Wt("opacity", 100, "number"),
        transform: Bd(),
        properties: [],
        effects: [],
        data: {
          cameraId: i,
          isActiveCamera: !this.activeCameraId || this.activeCameraId === i
        }
      };
      return n.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), this.selectLayer(a), { camera: o, layer: l };
    },
    /**
     * Get a camera by ID
     */
    getCamera(s) {
      return this.cameras.get(s) || null;
    },
    /**
     * Update camera properties
     */
    updateCamera(s, e) {
      const n = this.cameras.get(s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set the active camera
     */
    setActiveCamera(s) {
      if (!this.cameras.has(s)) return;
      this.activeCameraId = s;
      const e = this.getActiveCompLayers();
      for (const n of e)
        if (n.type === "camera" && n.data) {
          const i = n.data;
          i.isActiveCamera = i.cameraId === s;
        }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Delete a camera (and its layer)
     */
    deleteCamera(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex(
        (i) => {
          var r;
          return i.type === "camera" && ((r = i.data) == null ? void 0 : r.cameraId) === s;
        }
      );
      if (n !== -1) {
        const i = e[n].id;
        e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((r) => r !== i);
      }
      if (this.cameras.delete(s), this.activeCameraId === s) {
        const i = Array.from(this.cameras.keys());
        this.activeCameraId = i.length > 0 ? i[0] : null, this.activeCameraId && this.setActiveCamera(this.activeCameraId);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get camera keyframes for a specific camera
     */
    getCameraKeyframes(s) {
      return this.cameraKeyframes.get(s) || [];
    },
    /**
     * Add a keyframe to a camera
     */
    addCameraKeyframe(s, e) {
      let n = this.cameraKeyframes.get(s);
      n || (n = [], this.cameraKeyframes.set(s, n));
      const i = n.findIndex((r) => r.frame === e.frame);
      i >= 0 ? n[i] = e : (n.push(e), n.sort((r, o) => r.frame - o.frame)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Remove a keyframe from a camera
     */
    removeCameraKeyframe(s, e) {
      const n = this.cameraKeyframes.get(s);
      if (!n) return;
      const i = n.findIndex((r) => r.frame === e);
      i >= 0 && (n.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Get camera with keyframe interpolation applied at a specific frame
     * This is the main method for getting animated camera values
     */
    getCameraAtFrame(s, e) {
      const n = this.cameras.get(s);
      if (!n) return null;
      const i = this.cameraKeyframes.get(s);
      if (!i || i.length === 0)
        return n;
      const r = vl(n, i, e);
      return {
        ...n,
        position: r.position,
        orientation: r.rotation,
        focalLength: r.focalLength,
        zoom: r.zoom,
        depthOfField: {
          ...n.depthOfField,
          focusDistance: r.focusDistance
        }
      };
    },
    /**
     * Get the active camera with interpolation at current frame
     */
    getActiveCameraAtFrame(s) {
      return this.activeCameraId ? this.getCameraAtFrame(this.activeCameraId, s ?? this.currentFrame) : null;
    },
    /**
     * Update viewport state
     */
    updateViewportState(s) {
      Object.assign(this.viewportState, s);
    },
    /**
     * Update view options
     */
    updateViewOptions(s) {
      Object.assign(this.viewOptions, s);
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(s) {
      this.audioFile = s, this.audioBuffer = null, this.audioAnalysis = null, this.audioLoadingState = "decoding", this.audioLoadingProgress = 0, this.audioLoadingPhase = "Preparing...", this.audioLoadingError = null;
      try {
        const e = await hE(
          s,
          this.project.composition.fps,
          {
            onProgress: (n) => {
              n.phase === "decoding" ? this.audioLoadingState = "decoding" : this.audioLoadingState = "analyzing", this.audioLoadingProgress = n.progress, this.audioLoadingPhase = n.message;
            }
          }
        );
        this.audioBuffer = e.buffer, this.audioAnalysis = e.analysis, this.audioLoadingState = "complete", this.audioLoadingProgress = 1, this.audioLoadingPhase = "Complete", this.initializeAudioReactiveMapper(), this.propertyDriverSystem && this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis), Jt.debug("Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        Jt.error("Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null, this.audioLoadingState = "error", this.audioLoadingError = e.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelAudioLoad() {
      uE(), this.audioLoadingState = "idle", this.audioLoadingProgress = 0, this.audioLoadingPhase = "", this.audioLoadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.cancelAudioLoad(), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(s, e) {
      var n;
      return this.audioAnalysis ? gl(this.audioAnalysis, s, e ?? ((n = this.getActiveComp()) == null ? void 0 : n.currentFrame) ?? 0) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(s, e) {
      const n = this.audioMappings.get(s) || [];
      n.push(e), this.audioMappings.set(s, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(s, e) {
      const n = this.audioMappings.get(s);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(s));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(s) {
      return this.audioMappings.get(s) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(s) {
      this.peakData = s, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(s);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(s) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = Ry(e, s);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(s) {
      this.audioReactiveMappings.push(s), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(s);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(s) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === s);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(s);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(s, e) {
      const n = this.audioReactiveMappings.find((i) => i.id === s);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(s, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(s, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(s) {
      var e;
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(s ?? ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(s) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === s || e.targetLayerId === void 0)
      );
    },
    /**
     * Get audio reactive values for a specific layer at a specific frame
     * This is called by the engine during frame evaluation
     */
    getAudioReactiveValuesForLayer(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValuesForLayerAtFrame(s, e) : /* @__PURE__ */ new Map();
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      var s;
      return this.audioAnalysis ? Mv(this.audioAnalysis, ((s = this.getActiveComp()) == null ? void 0 : s.currentFrame) ?? 0) : !1;
    },
    // ============================================================
    // TIMELINE SNAPPING
    // ============================================================
    /**
     * Find nearest snap point for a given frame
     * @param frame - The frame to snap
     * @param pixelsPerFrame - Current zoom level
     * @param selectedLayerId - Currently selected layer (excluded from keyframe snapping)
     */
    findSnapPoint(s, e, n) {
      var i;
      return Kf(s, this.snapConfig, e, {
        layers: this.layers,
        selectedLayerId: n,
        currentFrame: ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    /**
     * Get all beat frames from audio analysis
     */
    getAudioBeatFrames() {
      return PE(this.audioAnalysis);
    },
    /**
     * Get all peak frames from peak data
     */
    getAudioPeakFrames() {
      return RE(this.peakData);
    },
    /**
     * Update snap configuration
     */
    setSnapConfig(s) {
      this.snapConfig = { ...this.snapConfig, ...s };
    },
    /**
     * Toggle snapping enabled
     */
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    /**
     * Toggle specific snap type
     */
    toggleSnapType(s) {
      const n = {
        grid: "snapToGrid",
        keyframes: "snapToKeyframes",
        beats: "snapToBeats",
        peaks: "snapToPeaks",
        layerBounds: "snapToLayerBounds",
        playhead: "snapToPlayhead"
      }[s];
      n && typeof this.snapConfig[n] == "boolean" && (this.snapConfig[n] = !this.snapConfig[n]);
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(s, e = {}) {
      const n = new _E(e);
      this.pathAnimators.set(s, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(s) {
      this.pathAnimators.delete(s);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(s) {
      return this.pathAnimators.get(s);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      var i;
      if (!this.audioAnalysis) return;
      const s = ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0, e = gl(this.audioAnalysis, "amplitude", s), n = Mv(this.audioAnalysis, s);
      for (const [r, o] of this.pathAnimators)
        o.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const s of this.pathAnimators.values())
        s.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new mE(this.audioAnalysis);
        for (const s of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(s);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (Expressions/Links)
    // ============================================================
    /**
     * Initialize the property driver system
     */
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new ME(), this.propertyDriverSystem.setPropertyGetter((s, e, n) => this.getPropertyValueAtFrame(s, e, n)), this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const s of this.propertyDrivers)
        this.propertyDriverSystem.addDriver(s);
    },
    /**
     * Get a property value at a specific frame
     * Used by the driver system to read source properties
     */
    getPropertyValueAtFrame(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return null;
      const r = e.split(".");
      if (r[0] === "transform") {
        const o = i.transform;
        if (r[1] === "position") {
          const a = an(o.position, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 0;
        }
        if (r[1] === "anchorPoint") {
          const a = an(o.anchorPoint, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 0;
        }
        if (r[1] === "scale") {
          const a = an(o.scale, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 100;
        }
        if (r[1] === "rotation")
          return an(o.rotation, n);
        if (r[1] === "rotationX" && o.rotationX)
          return an(o.rotationX, n);
        if (r[1] === "rotationY" && o.rotationY)
          return an(o.rotationY, n);
        if (r[1] === "rotationZ" && o.rotationZ)
          return an(o.rotationZ, n);
      }
      return r[0] === "opacity" ? an(i.opacity, n) : null;
    },
    /**
     * Get driven property values for a layer at current frame
     */
    getDrivenValuesForLayer(s) {
      var l;
      if (!this.propertyDriverSystem)
        return /* @__PURE__ */ new Map();
      const e = this.getActiveCompLayers().find((c) => c.id === s);
      if (!e) return /* @__PURE__ */ new Map();
      const n = /* @__PURE__ */ new Map(), i = ((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0, r = an(e.transform.position, i);
      n.set("transform.position.x", r.x), n.set("transform.position.y", r.y), n.set("transform.position.z", r.z ?? 0);
      const o = an(e.transform.anchorPoint, i);
      n.set("transform.anchorPoint.x", o.x), n.set("transform.anchorPoint.y", o.y), n.set("transform.anchorPoint.z", o.z ?? 0);
      const a = an(e.transform.scale, i);
      return n.set("transform.scale.x", a.x), n.set("transform.scale.y", a.y), n.set("transform.scale.z", a.z ?? 100), n.set("transform.rotation", an(e.transform.rotation, i)), e.transform.rotationX && n.set("transform.rotationX", an(e.transform.rotationX, i)), e.transform.rotationY && n.set("transform.rotationY", an(e.transform.rotationY, i)), e.transform.rotationZ && n.set("transform.rotationZ", an(e.transform.rotationZ, i)), n.set("opacity", an(e.opacity, i)), this.propertyDriverSystem.evaluateLayerDrivers(s, i, n);
    },
    /**
     * Add a property driver
     * Returns false if adding would create a circular dependency
     */
    addPropertyDriver(s) {
      return this.propertyDriverSystem && !this.propertyDriverSystem.addDriver(s) ? (Jt.warn("Cannot add property driver: would create circular dependency"), !1) : (this.propertyDrivers.push(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), !0);
    },
    /**
     * Create and add an audio-driven property driver
     */
    createAudioPropertyDriver(s, e, n, i = {}) {
      const r = CE(s, e, n, i);
      return this.addPropertyDriver(r), r;
    },
    /**
     * Create and add a property-to-property link
     * Returns null if creating would cause a circular dependency
     */
    createPropertyLink(s, e, n, i, r = {}) {
      const o = TE(
        s,
        e,
        n,
        i,
        r
      );
      return this.addPropertyDriver(o) ? o : null;
    },
    /**
     * Remove a property driver
     */
    removePropertyDriver(s) {
      const e = this.propertyDrivers.findIndex((n) => n.id === s);
      e >= 0 && this.propertyDrivers.splice(e, 1), this.propertyDriverSystem && this.propertyDriverSystem.removeDriver(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Update a property driver
     */
    updatePropertyDriver(s, e) {
      const n = this.propertyDrivers.find((i) => i.id === s);
      n && Object.assign(n, e), this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Get all drivers for a layer
     */
    getDriversForLayer(s) {
      return this.propertyDrivers.filter((e) => e.targetLayerId === s);
    },
    /**
     * Toggle driver enabled state
     */
    togglePropertyDriver(s) {
      const e = this.propertyDrivers.find((n) => n.id === s);
      e && (e.enabled = !e.enabled, this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, { enabled: e.enabled }), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
  }
});
async function Tv(s) {
  try {
    const e = await s.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function DE() {
  if ("gpu" in navigator)
    try {
      const i = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (i) {
        let r = "";
        if ("info" in i) {
          const o = i.info;
          r = (o == null ? void 0 : o.device) || (o == null ? void 0 : o.description) || "";
        }
        return r.includes("RTX 50") || r.toLowerCase().includes("blackwell") || r.includes("B100") || r.includes("B200") ? {
          tier: "blackwell",
          vram: await Tv(i),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await Tv(i),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      ns.warn("WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), i = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return ns.debug("WebGL renderer:", i), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const kE = { class: "project-panel" }, IE = { class: "panel-header" }, LE = { class: "header-actions" }, FE = { class: "dropdown-container" }, UE = {
  key: 0,
  class: "dropdown-menu"
}, OE = {
  key: 0,
  class: "search-bar"
}, zE = { class: "panel-content" }, NE = { class: "folder-tree" }, BE = ["onClick", "onDblclick"], VE = ["onClick"], GE = { class: "folder-name" }, HE = { class: "item-count" }, $E = {
  key: 0,
  class: "folder-contents"
}, WE = ["onClick", "onDblclick", "onDragstart"], XE = { class: "item-icon" }, jE = { class: "item-name" }, YE = { class: "item-info" }, qE = ["onClick", "onDblclick", "onDragstart"], ZE = { class: "item-icon" }, KE = { class: "item-name" }, JE = { class: "item-info" }, QE = {
  key: 0,
  class: "empty-state"
}, eA = {
  key: 1,
  class: "panel-footer"
}, tA = { class: "item-details" }, nA = { class: "detail-label" }, iA = { class: "detail-info" }, sA = /* @__PURE__ */ Ot({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(null), o = we(!1), a = we(!1), l = we(""), c = we(null), u = we(["compositions", "footage"]), d = we([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), h = we([]), m = Ie(() => {
      if (!l.value) return d.value;
      const R = l.value.toLowerCase();
      return d.value.map((O) => ({
        ...O,
        items: O.items.filter(
          (A) => A.name.toLowerCase().includes(R)
        )
      })).filter((O) => O.items.length > 0 || O.name.toLowerCase().includes(R));
    }), p = Ie(() => {
      if (!l.value) return h.value;
      const R = l.value.toLowerCase();
      return h.value.filter(
        (O) => O.name.toLowerCase().includes(R)
      );
    }), v = Ie(() => {
      if (!c.value) return null;
      for (const O of d.value) {
        const A = O.items.find((G) => G.id === c.value);
        if (A)
          return {
            name: A.name,
            info: D(A)
          };
      }
      const R = h.value.find((O) => O.id === c.value);
      return R ? {
        name: R.name,
        info: D(R)
      } : null;
    });
    function _(R) {
      const O = u.value.indexOf(R);
      O >= 0 ? u.value.splice(O, 1) : u.value.push(R);
    }
    function g(R) {
      c.value = R;
    }
    function x(R) {
      R.type === "composition" && console.log("Opening composition:", R.name);
    }
    function M() {
      a.value = !1, n("openCompositionSettings");
    }
    function S() {
      a.value = !1;
      const R = i.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", R.id);
    }
    function b() {
      a.value = !1;
      const R = i.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", R.id);
    }
    function C() {
      a.value = !1;
      const R = i.createLayer("null", "Null");
      console.log("[ProjectPanel] Created null layer:", R.id);
    }
    function T() {
      a.value = !1;
      const R = i.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", R.id);
    }
    function P() {
      var R;
      (R = r.value) == null || R.click();
    }
    async function E(R) {
      const O = R.target, A = O.files;
      if (!(!A || A.length === 0)) {
        for (const G of Array.from(A)) {
          const ue = y(G), Q = {
            id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: G.name,
            type: ue
          };
          if (ue === "audio")
            i.loadAudio(G);
          else if (G.type.startsWith("video/"))
            try {
              const re = await i.createVideoLayer(G, !0);
              Q.id = re.id, Q.width = i.width, Q.height = i.height, Q.duration = i.frameCount, Q.fps = i.fps, console.log("[ProjectPanel] Video layer created:", re.id, re.name);
            } catch (re) {
              console.error("[ProjectPanel] Failed to import video:", re);
              continue;
            }
          else if (G.type.startsWith("image/")) {
            const re = URL.createObjectURL(G), j = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            i.project.assets[j] = {
              id: j,
              type: "image",
              source: "file",
              width: 0,
              // Will be updated when image loads
              height: 0,
              data: re
            };
            const $ = i.createLayer("image", G.name.replace(/\.[^.]+$/, ""));
            $.data = { assetId: j }, Q.id = $.id;
          }
          const le = d.value.find((re) => re.id === "footage");
          le ? le.items.push(Q) : h.value.push(Q), console.log("[ProjectPanel] Imported:", G.name, ue);
        }
        O.value = "";
      }
    }
    function y(R) {
      const O = R.type;
      return O.startsWith("audio/") ? "audio" : (O.startsWith("video/") || O.startsWith("image/"), "footage");
    }
    function w(R) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[R] || "";
    }
    function D(R) {
      if (R.type === "composition" || R.type === "footage") {
        const O = [];
        if (R.width && R.height && O.push(`${R.width}${R.height}`), R.fps && O.push(`${R.fps}fps`), R.duration) {
          const A = R.duration / (R.fps || 30);
          O.push(`${A.toFixed(1)}s`);
        }
        return O.join("  ");
      }
      return "";
    }
    function U(R, O) {
      var A;
      (A = O.dataTransfer) == null || A.setData("application/project-item", JSON.stringify(R));
    }
    return (R, O) => (te(), ae("div", kE, [
      f("div", IE, [
        O[3] || (O[3] = f("span", { class: "panel-title" }, "Project", -1)),
        f("div", LE, [
          f("button", {
            onClick: P,
            title: "Import File (Ctrl+I)"
          }, ""),
          f("div", FE, [
            f("button", {
              onClick: O[0] || (O[0] = (A) => a.value = !a.value),
              title: "New Item"
            }, "+"),
            a.value ? (te(), ae("div", UE, [
              f("button", { onClick: M }, " New Composition"),
              f("button", { onClick: S }, " New Solid"),
              f("button", { onClick: b }, "T New Text"),
              f("button", { onClick: C }, " New Null"),
              f("button", { onClick: T }, " New Spline")
            ])) : Pe("", !0)
          ]),
          f("button", {
            onClick: O[1] || (O[1] = (A) => o.value = !o.value),
            title: "Search"
          }, "")
        ])
      ]),
      f("input", {
        ref_key: "fileInputRef",
        ref: r,
        type: "file",
        multiple: "",
        accept: "image/*,video/*,audio/*,.json",
        style: { display: "none" },
        onChange: E
      }, null, 544),
      o.value ? (te(), ae("div", OE, [
        st(f("input", {
          type: "text",
          "onUpdate:modelValue": O[2] || (O[2] = (A) => l.value = A),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [Ut, l.value]
        ])
      ])) : Pe("", !0),
      f("div", zE, [
        f("div", NE, [
          (te(!0), ae(qe, null, ot(m.value, (A) => (te(), ae("div", {
            key: A.id,
            class: "folder-item"
          }, [
            f("div", {
              class: Fe(["folder-header", { selected: c.value === A.id }]),
              onClick: (G) => g(A.id),
              onDblclick: (G) => _(A.id)
            }, [
              f("span", {
                class: "expand-icon",
                onClick: xt((G) => _(A.id), ["stop"])
              }, _e(u.value.includes(A.id) ? "" : ""), 9, VE),
              O[4] || (O[4] = f("span", { class: "folder-icon" }, "", -1)),
              f("span", GE, _e(A.name), 1),
              f("span", HE, _e(A.items.length), 1)
            ], 42, BE),
            u.value.includes(A.id) ? (te(), ae("div", $E, [
              (te(!0), ae(qe, null, ot(A.items, (G) => (te(), ae("div", {
                key: G.id,
                class: Fe(["project-item", { selected: c.value === G.id }]),
                onClick: (ue) => g(G.id),
                onDblclick: (ue) => x(G),
                draggable: "true",
                onDragstart: (ue) => U(G, ue)
              }, [
                f("span", XE, _e(w(G.type)), 1),
                f("span", jE, _e(G.name), 1),
                f("span", YE, _e(D(G)), 1)
              ], 42, WE))), 128))
            ])) : Pe("", !0)
          ]))), 128)),
          (te(!0), ae(qe, null, ot(p.value, (A) => (te(), ae("div", {
            key: A.id,
            class: Fe(["project-item", { selected: c.value === A.id }]),
            onClick: (G) => g(A.id),
            onDblclick: (G) => x(A),
            draggable: "true",
            onDragstart: (G) => U(A, G)
          }, [
            f("span", ZE, _e(w(A.type)), 1),
            f("span", KE, _e(A.name), 1),
            f("span", JE, _e(D(A)), 1)
          ], 42, qE))), 128))
        ]),
        h.value.length === 0 ? (te(), ae("div", QE, [...O[5] || (O[5] = [
          f("p", null, "No items in project", -1),
          f("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : Pe("", !0)
      ]),
      v.value ? (te(), ae("div", eA, [
        f("div", tA, [
          f("span", nA, _e(v.value.name), 1),
          f("span", iA, _e(v.value.info), 1)
        ])
      ])) : Pe("", !0)
    ]));
  }
}), Gt = (s, e) => {
  const n = s.__vccOpts || s;
  for (const [i, r] of e)
    n[i] = r;
  return n;
}, rA = /* @__PURE__ */ Gt(sA, [["__scopeId", "data-v-8f208c83"]]), oA = { class: "effects-panel" }, aA = { class: "panel-header" }, lA = { class: "header-actions" }, cA = { class: "panel-content" }, uA = { class: "tabs" }, dA = {
  key: 0,
  class: "effects-list"
}, hA = ["onClick"], fA = { class: "expand-icon" }, pA = { class: "category-icon" }, mA = { class: "category-name" }, vA = { class: "effect-count" }, gA = {
  key: 0,
  class: "category-effects"
}, yA = ["onDblclick", "onDragstart"], xA = { class: "effect-name" }, _A = ["onClick", "title"], bA = {
  key: 1,
  class: "presets-list"
}, wA = ["onClick"], SA = { class: "expand-icon" }, MA = { class: "category-name" }, CA = { class: "preset-count" }, TA = {
  key: 0,
  class: "category-presets"
}, EA = ["onDblclick", "onDragstart"], AA = { class: "preset-info" }, PA = { class: "preset-name" }, RA = { class: "preset-description" }, DA = {
  key: 2,
  class: "favorites-list"
}, kA = {
  key: 0,
  class: "empty-favorites"
}, IA = ["onDblclick", "onDragstart"], LA = { class: "category-badge" }, FA = { class: "effect-name" }, UA = ["onClick"], OA = /* @__PURE__ */ Ot({
  __name: "EffectsPanel",
  setup(s) {
    const e = sn(), n = we("effects"), i = we(""), r = we(["blur-sharpen", "color-correction"]), o = we(["Fade", "Scale"]), a = we([]);
    xn(() => {
      const b = localStorage.getItem("effect-favorites");
      if (b)
        try {
          a.value = JSON.parse(b);
        } catch {
          a.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(a.value));
    }
    const c = Ie(() => Object.entries(cu).map(([b, C]) => ({
      key: b,
      name: C.name,
      category: C.category,
      description: C.description
    }))), u = Ie(() => {
      const b = i.value.toLowerCase();
      return Object.entries(Qh).map(([C, T]) => {
        const P = c.value.filter((E) => !(E.category !== C || b && !E.name.toLowerCase().includes(b)));
        return {
          key: C,
          label: T.label,
          icon: T.icon,
          effects: P
        };
      }).filter((C) => C.effects.length > 0);
    }), d = Ie(() => {
      const b = i.value.toLowerCase(), C = {};
      for (const T of SE)
        b && !T.name.toLowerCase().includes(b) || (C[T.category] || (C[T.category] = []), C[T.category].push(T));
      return Object.entries(C).map(([T, P]) => ({
        category: T,
        presets: P
      }));
    }), h = Ie(() => c.value.filter((b) => a.value.includes(b.key)));
    function m(b) {
      const C = r.value.indexOf(b);
      C >= 0 ? r.value.splice(C, 1) : r.value.push(b);
    }
    function p(b) {
      const C = o.value.indexOf(b);
      C >= 0 ? o.value.splice(C, 1) : o.value.push(b);
    }
    function v(b) {
      const C = a.value.indexOf(b);
      C >= 0 ? a.value.splice(C, 1) : a.value.push(b), l();
    }
    function _(b) {
      var C;
      return ((C = Qh[b]) == null ? void 0 : C.icon) || "?";
    }
    function g(b) {
      const C = e.selectedLayer;
      if (!C) {
        console.warn("No layer selected to apply effect");
        return;
      }
      e.addEffectToLayer(C.id, b);
    }
    function x(b) {
      const C = e.selectedLayer;
      if (!C || !e.getActiveComp()) return;
      const P = C.inPoint, y = C.outPoint - P;
      for (const w of b.keyframes)
        for (const D of w.keyframes) {
          const U = Math.round(P + D.time * y);
          e.addKeyframe(C.id, w.property, D.value, U);
        }
    }
    function M(b, C) {
      var T;
      (T = C.dataTransfer) == null || T.setData("application/effect", b);
    }
    function S(b, C) {
      var T;
      (T = C.dataTransfer) == null || T.setData("application/preset", JSON.stringify(b));
    }
    return (b, C) => (te(), ae("div", oA, [
      f("div", aA, [
        C[4] || (C[4] = f("span", { class: "panel-title" }, "Effects & Presets", -1)),
        f("div", lA, [
          st(f("input", {
            type: "text",
            "onUpdate:modelValue": C[0] || (C[0] = (T) => i.value = T),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [Ut, i.value]
          ])
        ])
      ]),
      f("div", cA, [
        f("div", uA, [
          f("button", {
            class: Fe({ active: n.value === "effects" }),
            onClick: C[1] || (C[1] = (T) => n.value = "effects")
          }, " Effects ", 2),
          f("button", {
            class: Fe({ active: n.value === "presets" }),
            onClick: C[2] || (C[2] = (T) => n.value = "presets")
          }, " Presets ", 2),
          f("button", {
            class: Fe({ active: n.value === "favorites" }),
            onClick: C[3] || (C[3] = (T) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? (te(), ae("div", dA, [
          (te(!0), ae(qe, null, ot(u.value, (T) => (te(), ae("div", {
            key: T.key,
            class: "effect-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (P) => m(T.key)
            }, [
              f("span", fA, _e(r.value.includes(T.key) ? "" : ""), 1),
              f("span", pA, _e(T.icon), 1),
              f("span", mA, _e(T.label), 1),
              f("span", vA, _e(T.effects.length), 1)
            ], 8, hA),
            r.value.includes(T.key) ? (te(), ae("div", gA, [
              (te(!0), ae(qe, null, ot(T.effects, (P) => (te(), ae("div", {
                key: P.key,
                class: Fe(["effect-item", { favorite: a.value.includes(P.key) }]),
                onDblclick: (E) => g(P.key),
                onDragstart: (E) => M(P.key, E),
                draggable: "true"
              }, [
                f("span", xA, _e(P.name), 1),
                f("button", {
                  class: "favorite-btn",
                  onClick: xt((E) => v(P.key), ["stop"]),
                  title: a.value.includes(P.key) ? "Remove from favorites" : "Add to favorites"
                }, _e(a.value.includes(P.key) ? "" : ""), 9, _A)
              ], 42, yA))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? (te(), ae("div", bA, [
          (te(!0), ae(qe, null, ot(d.value, (T) => (te(), ae("div", {
            key: T.category,
            class: "preset-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (P) => p(T.category)
            }, [
              f("span", SA, _e(o.value.includes(T.category) ? "" : ""), 1),
              f("span", MA, _e(T.category), 1),
              f("span", CA, _e(T.presets.length), 1)
            ], 8, wA),
            o.value.includes(T.category) ? (te(), ae("div", TA, [
              (te(!0), ae(qe, null, ot(T.presets, (P) => (te(), ae("div", {
                key: P.id,
                class: "preset-item",
                onDblclick: (E) => x(P),
                onDragstart: (E) => S(P, E),
                draggable: "true"
              }, [
                C[5] || (C[5] = f("div", { class: "preset-preview" }, [
                  f("span", { class: "preview-icon" }, "")
                ], -1)),
                f("div", AA, [
                  f("span", PA, _e(P.name), 1),
                  f("span", RA, _e(P.description), 1)
                ])
              ], 40, EA))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? (te(), ae("div", DA, [
          h.value.length === 0 ? (te(), ae("div", kA, [...C[6] || (C[6] = [
            f("p", null, "No favorites yet", -1),
            f("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : Pe("", !0),
          (te(!0), ae(qe, null, ot(h.value, (T) => (te(), ae("div", {
            key: T.key,
            class: "effect-item",
            onDblclick: (P) => g(T.key),
            onDragstart: (P) => M(T.key, P),
            draggable: "true"
          }, [
            f("span", LA, _e(_(T.category)), 1),
            f("span", FA, _e(T.name), 1),
            f("button", {
              class: "favorite-btn active",
              onClick: xt((P) => v(T.key), ["stop"])
            }, "  ", 8, UA)
          ], 40, IA))), 128))
        ])) : Pe("", !0)
      ]),
      C[7] || (C[7] = f("div", { class: "panel-footer" }, [
        f("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), zA = /* @__PURE__ */ Gt(OA, [["__scopeId", "data-v-5e081b38"]]), NA = ["value", "min", "max", "step", "disabled"], BA = {
  key: 1,
  class: "scrub-unit"
}, VA = /* @__PURE__ */ Ot({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(!1), o = we(0), a = we(0), l = Ie(() => n.default ?? n.modelValue), c = Ie(() => n.default !== void 0), u = Ie(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function d(S) {
      return Math.max(n.min, Math.min(n.max, S));
    }
    function h(S) {
      const b = Math.pow(10, n.precision);
      return Math.round(S * b) / b;
    }
    function m(S) {
      n.disabled || (r.value = !0, o.value = S.clientX, a.value = n.modelValue, document.addEventListener("mousemove", p), document.addEventListener("mouseup", v), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function p(S) {
      const b = S.clientX - o.value;
      let C = n.sensitivity;
      S.shiftKey && (C *= 10), (S.ctrlKey || S.metaKey) && (C *= 0.1);
      const T = b * n.step * C * 0.5, P = h(d(a.value + T));
      P !== n.modelValue && i("update:modelValue", P);
    }
    function v() {
      r.value = !1, document.removeEventListener("mousemove", p), document.removeEventListener("mouseup", v), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function _(S) {
      const b = S.target, C = parseFloat(b.value);
      isNaN(C) || i("update:modelValue", h(d(C)));
    }
    function g(S) {
      if (n.disabled) return;
      let b = 0;
      S.key === "ArrowUp" ? b = n.step : S.key === "ArrowDown" && (b = -n.step), b !== 0 && (S.preventDefault(), S.shiftKey && (b *= 10), (S.ctrlKey || S.metaKey) && (b *= 0.1), i("update:modelValue", h(d(n.modelValue + b))));
    }
    function x(S) {
      const b = S.target, C = parseFloat(b.value);
      isNaN(C) && (b.value = u.value.toString());
    }
    function M() {
      n.default !== void 0 && i("update:modelValue", n.default);
    }
    return (S, b) => (te(), ae("div", {
      class: Fe(["scrubable-number", { disabled: s.disabled }])
    }, [
      s.label ? (te(), ae("label", {
        key: 0,
        class: Fe(["scrub-label", { scrubbing: r.value }]),
        onMousedown: m
      }, _e(s.label), 35)) : Pe("", !0),
      f("input", {
        type: "number",
        class: "scrub-input",
        value: u.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: _,
        onKeydown: g,
        onBlur: x
      }, null, 40, NA),
      s.unit ? (te(), ae("span", BA, _e(s.unit), 1)) : Pe("", !0),
      c.value && s.modelValue !== l.value ? (te(), ae("button", {
        key: 2,
        class: "reset-btn",
        onClick: M,
        title: "Reset to default"
      }, [...b[0] || (b[0] = [
        f("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : Pe("", !0)
    ], 2));
  }
}), et = /* @__PURE__ */ Gt(VA, [["__scopeId", "data-v-dcc786e6"]]), GA = ["value", "min", "max", "step", "disabled"], HA = {
  key: 2,
  class: "slider-unit"
}, $A = /* @__PURE__ */ Ot({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(null), o = we(!1), a = we(!1), l = we(0), c = we(0), u = Ie(() => {
      const T = n.max - n.min;
      return T === 0 ? 0 : (n.modelValue - n.min) / T * 100;
    }), d = Ie(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function h(T) {
      return Math.max(n.min, Math.min(n.max, T));
    }
    function m(T) {
      const P = Math.pow(10, n.precision);
      return Math.round(T * P) / P;
    }
    function p(T) {
      n.disabled || (o.value = !0, l.value = T.clientX, c.value = n.modelValue, document.addEventListener("mousemove", v), document.addEventListener("mouseup", _), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function v(T) {
      const P = T.clientX - l.value, E = n.max - n.min;
      let y = 1;
      T.shiftKey && (y *= 10), (T.ctrlKey || T.metaKey) && (y *= 0.1);
      const w = P / 200 * E * y, D = m(h(c.value + w));
      D !== n.modelValue && i("update:modelValue", D);
    }
    function _() {
      o.value = !1, document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", _), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function g(T) {
      if (n.disabled || !r.value) return;
      const P = r.value.getBoundingClientRect(), E = (T.clientX - P.left) / P.width, y = n.min + E * (n.max - n.min);
      i("update:modelValue", m(h(y)));
    }
    function x(T) {
      n.disabled || (a.value = !0, document.addEventListener("mousemove", M), document.addEventListener("mouseup", S), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function M(T) {
      if (!r.value) return;
      const P = r.value.getBoundingClientRect(), E = (T.clientX - P.left) / P.width, y = n.min + Math.max(0, Math.min(1, E)) * (n.max - n.min);
      i("update:modelValue", m(h(y)));
    }
    function S() {
      a.value = !1, document.removeEventListener("mousemove", M), document.removeEventListener("mouseup", S), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function b(T) {
      const P = T.target, E = parseFloat(P.value);
      isNaN(E) || i("update:modelValue", m(h(E)));
    }
    function C(T) {
      const P = T.target, E = parseFloat(P.value);
      isNaN(E) && (P.value = d.value.toString());
    }
    return (T, P) => (te(), ae("div", {
      class: Fe(["slider-input", { disabled: s.disabled }])
    }, [
      s.label ? (te(), ae("label", {
        key: 0,
        class: Fe(["slider-label", { scrubbing: o.value }]),
        onMousedown: p
      }, _e(s.label), 35)) : Pe("", !0),
      f("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: r,
        onMousedown: g
      }, [
        f("div", {
          class: "slider-fill",
          style: yt({ width: u.value + "%", background: s.gradient || void 0 })
        }, null, 4),
        f("div", {
          class: "slider-thumb",
          style: yt({ left: u.value + "%" }),
          onMousedown: xt(x, ["stop"])
        }, null, 36)
      ], 544),
      s.showValue ? (te(), ae("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: d.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: b,
        onBlur: C
      }, null, 40, GA)) : Pe("", !0),
      s.unit ? (te(), ae("span", HA, _e(s.unit), 1)) : Pe("", !0)
    ], 2));
  }
}), jn = /* @__PURE__ */ Gt($A, [["__scopeId", "data-v-9dd40416"]]), WA = { class: "dial-marks" }, XA = {
  key: 0,
  class: "angle-value"
}, jA = ["value", "disabled"], YA = /* @__PURE__ */ Ot({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(null), o = we(!1), a = Ie(() => Math.round(n.modelValue * 10) / 10);
    function l(v) {
      return (v % 360 + 360) % 360;
    }
    function c(v) {
      n.disabled || (o.value = !0, d(v), document.addEventListener("mousemove", u), document.addEventListener("mouseup", h), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function u(v) {
      o.value && d(v);
    }
    function d(v) {
      if (!r.value) return;
      const _ = r.value.getBoundingClientRect(), g = _.left + _.width / 2, x = _.top + _.height / 2, M = v.clientX - g, S = v.clientY - x;
      let b = Math.atan2(M, -S) * (180 / Math.PI);
      b = l(b), v.shiftKey && (b = Math.round(b / 45) * 45), i("update:modelValue", b);
    }
    function h() {
      o.value = !1, document.removeEventListener("mousemove", u), document.removeEventListener("mouseup", h), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function m(v) {
      const _ = v.target, g = parseFloat(_.value);
      isNaN(g) || i("update:modelValue", l(g));
    }
    function p(v) {
      const _ = v.target, g = parseFloat(_.value);
      isNaN(g) && (_.value = a.value.toString());
    }
    return (v, _) => (te(), ae("div", {
      class: Fe(["angle-dial", { disabled: s.disabled }])
    }, [
      f("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: r,
        style: yt({ width: s.size + "px", height: s.size + "px" }),
        onMousedown: c
      }, [
        _[0] || (_[0] = f("div", { class: "dial-ring" }, null, -1)),
        _[1] || (_[1] = f("div", { class: "dial-center" }, null, -1)),
        f("div", {
          class: "dial-indicator",
          style: yt({ transform: `rotate(${s.modelValue}deg)` })
        }, null, 4),
        f("div", WA, [
          (te(), ae(qe, null, ot(8, (g) => f("div", {
            class: "dial-mark",
            key: g,
            style: yt({ transform: `rotate(${g * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      s.showValue ? (te(), ae("div", XA, [
        f("input", {
          type: "number",
          class: "angle-input",
          value: a.value,
          disabled: s.disabled,
          onInput: m,
          onBlur: p
        }, null, 40, jA),
        _[2] || (_[2] = f("span", { class: "angle-unit" }, "", -1))
      ])) : Pe("", !0)
    ], 2));
  }
}), Jf = /* @__PURE__ */ Gt(YA, [["__scopeId", "data-v-04a5caf6"]]);
function Ev(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = n * e, r = i * (1 - Math.abs(s / 60 % 2 - 1)), o = n - i;
  let a = 0, l = 0, c = 0;
  return s < 60 ? (a = i, l = r, c = 0) : s < 120 ? (a = r, l = i, c = 0) : s < 180 ? (a = 0, l = i, c = r) : s < 240 ? (a = 0, l = r, c = i) : s < 300 ? (a = r, l = 0, c = i) : (a = i, l = 0, c = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function ys(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = i - r;
  let a = 0;
  const l = i === 0 ? 0 : o / i, c = i;
  if (o !== 0)
    switch (i) {
      case s:
        a = ((e - n) / o + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - s) / o + 2) * 60;
        break;
      case n:
        a = ((s - e) / o + 4) * 60;
        break;
    }
  return [a, l, c];
}
function pc(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = (1 - Math.abs(2 * n - 1)) * e, r = i * (1 - Math.abs(s / 60 % 2 - 1)), o = n - i / 2;
  let a = 0, l = 0, c = 0;
  return s < 60 ? (a = i, l = r, c = 0) : s < 120 ? (a = r, l = i, c = 0) : s < 180 ? (a = 0, l = i, c = r) : s < 240 ? (a = 0, l = r, c = i) : s < 300 ? (a = r, l = 0, c = i) : (a = i, l = 0, c = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function Sr(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = (i + r) / 2;
  let a = 0, l = 0;
  if (i !== r) {
    const c = i - r;
    switch (l = o > 0.5 ? c / (2 - i - r) : c / (i + r), i) {
      case s:
        a = ((e - n) / c + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - s) / c + 2) * 60;
        break;
      case n:
        a = ((s - e) / c + 4) * 60;
        break;
    }
  }
  return [a, l, o];
}
function qA(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2]), s.length === 6 || s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16);
    if (!isNaN(e) && !isNaN(n) && !isNaN(i))
      return [e, n, i];
  }
  return null;
}
function ZA(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2] + "ff"), s.length === 6 && (s = s + "ff"), s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16), r = parseInt(s.slice(6, 8), 16) / 255;
    if (!isNaN(e) && !isNaN(n) && !isNaN(i) && !isNaN(r))
      return [e, n, i, r];
  }
  return null;
}
function KA(s, e, n) {
  const i = (r) => Math.max(0, Math.min(255, Math.round(r))).toString(16).padStart(2, "0");
  return `#${i(s)}${i(e)}${i(n)}`;
}
function JA(s, e, n, i) {
  const r = (o) => Math.max(0, Math.min(255, Math.round(o))).toString(16).padStart(2, "0");
  return `#${r(s)}${r(e)}${r(n)}${r(i * 255)}`;
}
const QA = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
], e3 = {
  key: 0,
  class: "checkerboard"
}, t3 = ["value"], n3 = { class: "mode-tabs" }, i3 = ["onClick"], s3 = {
  key: 1,
  class: "rgb-sliders"
}, r3 = { class: "color-slider" }, o3 = ["value"], a3 = { class: "color-slider" }, l3 = ["value"], c3 = { class: "color-slider" }, u3 = ["value"], d3 = {
  key: 2,
  class: "hsl-sliders"
}, h3 = { class: "color-slider" }, f3 = ["value"], p3 = { class: "color-slider" }, m3 = ["value"], v3 = { class: "color-slider" }, g3 = ["value"], y3 = {
  key: 3,
  class: "alpha-slider"
}, x3 = ["value"], _3 = { class: "swatches-section" }, b3 = { class: "swatches-grid" }, w3 = ["onClick"], S3 = {
  key: 4,
  class: "recent-section"
}, M3 = { class: "swatches-grid" }, C3 = ["onClick"], T3 = /* @__PURE__ */ Ot({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: !1 },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = ["hsv", "rgb", "hsl"], o = we(null), a = we(null), l = we(null), c = we(null), u = we(null), d = we(!1), h = we("hsv"), m = we(1), p = we([]), v = we([255, 255, 255]), _ = we([0, 0, 1]), g = we([0, 0, 1]), x = Ie(() => n.swatches || QA), M = Ie(() => {
      if (!o.value || !n.teleport) return {};
      const ne = o.value.getBoundingClientRect();
      return {
        top: `${ne.bottom + 4}px`,
        left: `${ne.left}px`
      };
    });
    function S(ne) {
      const J = qA(ne);
      J && (v.value = J, _.value = ys(J[0], J[1], J[2]), g.value = Sr(J[0], J[1], J[2]));
    }
    function b() {
      const ne = KA(v.value[0], v.value[1], v.value[2]);
      i("update:modelValue", ne);
    }
    function C() {
      d.value = !d.value;
    }
    function T() {
      d.value && (d.value = !1, P(n.modelValue));
    }
    function P(ne) {
      const J = p.value.indexOf(ne);
      J !== -1 && p.value.splice(J, 1), p.value.unshift(ne), p.value.length > n.recentCount && p.value.pop();
    }
    function E(ne) {
      i("update:modelValue", ne);
    }
    let y = !1;
    function w(ne) {
      y = !0, U(ne), document.addEventListener("mousemove", D), document.addEventListener("mouseup", R);
    }
    function D(ne) {
      y && U(ne);
    }
    function U(ne) {
      if (!l.value) return;
      const J = l.value.getBoundingClientRect(), B = Math.max(0, Math.min(1, (ne.clientX - J.left) / J.width)), X = Math.max(0, Math.min(1, 1 - (ne.clientY - J.top) / J.height));
      _.value = [_.value[0], B, X], v.value = Ev(_.value[0], _.value[1], _.value[2]), g.value = Sr(v.value[0], v.value[1], v.value[2]), b();
    }
    function R() {
      y = !1, document.removeEventListener("mousemove", D), document.removeEventListener("mouseup", R);
    }
    let O = !1;
    function A(ne) {
      O = !0, ue(ne), document.addEventListener("mousemove", G), document.addEventListener("mouseup", Q);
    }
    function G(ne) {
      O && ue(ne);
    }
    function ue(ne) {
      if (!c.value) return;
      const J = c.value.getBoundingClientRect(), B = Math.max(0, Math.min(360, (ne.clientX - J.left) / J.width * 360));
      _.value = [B, _.value[1], _.value[2]], v.value = Ev(_.value[0], _.value[1], _.value[2]), g.value = Sr(v.value[0], v.value[1], v.value[2]), b();
    }
    function Q() {
      O = !1, document.removeEventListener("mousemove", G), document.removeEventListener("mouseup", Q);
    }
    let le = null, re = null;
    function j(ne, J) {
      le = ne;
      const B = J.target.closest(".slider-track");
      B && (re = B.getBoundingClientRect(), q(J), document.addEventListener("mousemove", $), document.addEventListener("mouseup", oe));
    }
    function $(ne) {
      le && q(ne);
    }
    function q(ne) {
      if (!re || !le) return;
      const J = Math.max(0, Math.min(1, (ne.clientX - re.left) / re.width));
      switch (le) {
        case "r":
          v.value = [Math.round(J * 255), v.value[1], v.value[2]], _.value = ys(v.value[0], v.value[1], v.value[2]), g.value = Sr(v.value[0], v.value[1], v.value[2]);
          break;
        case "g":
          v.value = [v.value[0], Math.round(J * 255), v.value[2]], _.value = ys(v.value[0], v.value[1], v.value[2]), g.value = Sr(v.value[0], v.value[1], v.value[2]);
          break;
        case "b":
          v.value = [v.value[0], v.value[1], Math.round(J * 255)], _.value = ys(v.value[0], v.value[1], v.value[2]), g.value = Sr(v.value[0], v.value[1], v.value[2]);
          break;
        case "h":
          g.value = [J * 360, g.value[1], g.value[2]], v.value = pc(g.value[0], g.value[1], g.value[2]), _.value = ys(v.value[0], v.value[1], v.value[2]);
          break;
        case "s":
          g.value = [g.value[0], J, g.value[2]], v.value = pc(g.value[0], g.value[1], g.value[2]), _.value = ys(v.value[0], v.value[1], v.value[2]);
          break;
        case "l":
          g.value = [g.value[0], g.value[1], J], v.value = pc(g.value[0], g.value[1], g.value[2]), _.value = ys(v.value[0], v.value[1], v.value[2]);
          break;
      }
      b();
    }
    function oe() {
      le = null, re = null, document.removeEventListener("mousemove", $), document.removeEventListener("mouseup", oe);
    }
    let ie = !1;
    function ce(ne) {
      ie = !0, Y(ne), document.addEventListener("mousemove", V), document.addEventListener("mouseup", H);
    }
    function V(ne) {
      ie && Y(ne);
    }
    function Y(ne) {
      if (!u.value) return;
      const J = u.value.getBoundingClientRect();
      m.value = Math.max(0, Math.min(1, (ne.clientX - J.left) / J.width));
    }
    function H() {
      ie = !1, document.removeEventListener("mousemove", V), document.removeEventListener("mouseup", H);
    }
    function I(ne) {
      let B = ne.target.value.trim();
      B.startsWith("#") || (B = "#" + B), /^#[0-9a-f]{6}$/i.test(B) && i("update:modelValue", B.toLowerCase());
    }
    function F(ne) {
      const J = ne.target;
      J.value = n.modelValue;
    }
    function L(ne, J) {
      const B = J.target, X = Math.max(0, Math.min(255, parseInt(B.value) || 0)), se = [...v.value];
      se[ne] = X, v.value = se, _.value = ys(v.value[0], v.value[1], v.value[2]), g.value = Sr(v.value[0], v.value[1], v.value[2]), b();
    }
    function ee(ne, J) {
      const B = J.target;
      let X = parseFloat(B.value) || 0;
      ne === 0 ? (X = Math.max(0, Math.min(360, X)), g.value = [X, g.value[1], g.value[2]]) : (X = Math.max(0, Math.min(100, X)) / 100, ne === 1 ? g.value = [g.value[0], X, g.value[2]] : g.value = [g.value[0], g.value[1], X]), v.value = pc(g.value[0], g.value[1], g.value[2]), _.value = ys(v.value[0], v.value[1], v.value[2]), b();
    }
    function Z(ne) {
      const J = ne.target;
      m.value = Math.max(0, Math.min(100, parseInt(J.value) || 0)) / 100;
    }
    function k(ne) {
      o.value && !o.value.contains(ne.target) && a.value && !a.value.contains(ne.target) && T();
    }
    return Ft(() => n.modelValue, (ne) => {
      S(ne);
    }, { immediate: !0 }), xn(() => {
      document.addEventListener("mousedown", k);
    }), Nn(() => {
      document.removeEventListener("mousedown", k);
    }), (ne, J) => (te(), ae("div", {
      class: "color-picker",
      ref_key: "containerRef",
      ref: o
    }, [
      f("button", {
        class: "color-swatch",
        style: yt({ backgroundColor: s.modelValue }),
        onClick: C
      }, [
        s.alpha ? (te(), ae("span", e3)) : Pe("", !0)
      ], 4),
      f("input", {
        type: "text",
        class: "hex-input",
        value: s.modelValue,
        onInput: I,
        onBlur: F,
        onKeydown: J[0] || (J[0] = ol((B) => B.target.blur(), ["enter"]))
      }, null, 40, t3),
      (te(), St(zo, {
        to: "body",
        disabled: !s.teleport
      }, [
        d.value ? (te(), ae("div", {
          key: 0,
          class: "picker-panel",
          style: yt(M.value),
          ref_key: "panelRef",
          ref: a
        }, [
          f("div", n3, [
            (te(), ae(qe, null, ot(r, (B) => f("button", {
              key: B,
              class: Fe({ active: h.value === B }),
              onClick: (X) => h.value = B
            }, _e(B.toUpperCase()), 11, i3)), 64))
          ]),
          h.value === "hsv" ? (te(), ae(qe, { key: 0 }, [
            f("div", {
              class: "sv-square",
              style: yt({ backgroundColor: `hsl(${_.value[0]}, 100%, 50%)` }),
              onMousedown: w,
              ref_key: "svSquareRef",
              ref: l
            }, [
              J[13] || (J[13] = f("div", { class: "sv-white" }, null, -1)),
              J[14] || (J[14] = f("div", { class: "sv-black" }, null, -1)),
              f("div", {
                class: "sv-cursor",
                style: yt({ left: _.value[1] * 100 + "%", top: (1 - _.value[2]) * 100 + "%" })
              }, null, 4)
            ], 36),
            f("div", {
              class: "hue-slider",
              onMousedown: A,
              ref_key: "hueSliderRef",
              ref: c
            }, [
              f("div", {
                class: "hue-cursor",
                style: yt({ left: _.value[0] / 360 * 100 + "%" })
              }, null, 4)
            ], 544)
          ], 64)) : h.value === "rgb" ? (te(), ae("div", s3, [
            f("div", r3, [
              J[15] || (J[15] = f("label", null, "R", -1)),
              f("div", {
                class: "slider-track r-track",
                onMousedown: J[1] || (J[1] = (B) => j("r", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: v.value[0] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: v.value[0],
                min: "0",
                max: "255",
                onInput: J[2] || (J[2] = (B) => L(0, B))
              }, null, 40, o3)
            ]),
            f("div", a3, [
              J[16] || (J[16] = f("label", null, "G", -1)),
              f("div", {
                class: "slider-track g-track",
                onMousedown: J[3] || (J[3] = (B) => j("g", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: v.value[1] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: v.value[1],
                min: "0",
                max: "255",
                onInput: J[4] || (J[4] = (B) => L(1, B))
              }, null, 40, l3)
            ]),
            f("div", c3, [
              J[17] || (J[17] = f("label", null, "B", -1)),
              f("div", {
                class: "slider-track b-track",
                onMousedown: J[5] || (J[5] = (B) => j("b", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: v.value[2] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: v.value[2],
                min: "0",
                max: "255",
                onInput: J[6] || (J[6] = (B) => L(2, B))
              }, null, 40, u3)
            ])
          ])) : h.value === "hsl" ? (te(), ae("div", d3, [
            f("div", h3, [
              J[18] || (J[18] = f("label", null, "H", -1)),
              f("div", {
                class: "slider-track hue-track",
                onMousedown: J[7] || (J[7] = (B) => j("h", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: g.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: Math.round(g.value[0]),
                min: "0",
                max: "360",
                onInput: J[8] || (J[8] = (B) => ee(0, B))
              }, null, 40, f3)
            ]),
            f("div", p3, [
              J[19] || (J[19] = f("label", null, "S", -1)),
              f("div", {
                class: "slider-track sat-track",
                style: yt({ "--hue": g.value[0] }),
                onMousedown: J[9] || (J[9] = (B) => j("s", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: g.value[1] * 100 + "%" })
                }, null, 4)
              ], 36),
              f("input", {
                type: "number",
                value: Math.round(g.value[1] * 100),
                min: "0",
                max: "100",
                onInput: J[10] || (J[10] = (B) => ee(1, B))
              }, null, 40, m3)
            ]),
            f("div", v3, [
              J[20] || (J[20] = f("label", null, "L", -1)),
              f("div", {
                class: "slider-track light-track",
                style: yt({ "--hue": g.value[0] }),
                onMousedown: J[11] || (J[11] = (B) => j("l", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: yt({ left: g.value[2] * 100 + "%" })
                }, null, 4)
              ], 36),
              f("input", {
                type: "number",
                value: Math.round(g.value[2] * 100),
                min: "0",
                max: "100",
                onInput: J[12] || (J[12] = (B) => ee(2, B))
              }, null, 40, g3)
            ])
          ])) : Pe("", !0),
          s.alpha ? (te(), ae("div", y3, [
            J[21] || (J[21] = f("label", null, "A", -1)),
            f("div", {
              class: "slider-track alpha-track",
              style: yt({ "--color": s.modelValue }),
              onMousedown: ce,
              ref_key: "alphaSliderRef",
              ref: u
            }, [
              f("div", {
                class: "slider-cursor",
                style: yt({ left: m.value * 100 + "%" })
              }, null, 4)
            ], 36),
            f("input", {
              type: "number",
              value: Math.round(m.value * 100),
              min: "0",
              max: "100",
              onInput: Z
            }, null, 40, x3)
          ])) : Pe("", !0),
          f("div", _3, [
            J[22] || (J[22] = f("div", { class: "swatches-label" }, "Swatches", -1)),
            f("div", b3, [
              (te(!0), ae(qe, null, ot(x.value, (B) => (te(), ae("button", {
                key: B,
                class: "swatch",
                style: yt({ backgroundColor: B }),
                onClick: (X) => E(B)
              }, null, 12, w3))), 128))
            ])
          ]),
          p.value.length > 0 ? (te(), ae("div", S3, [
            J[23] || (J[23] = f("div", { class: "swatches-label" }, "Recent", -1)),
            f("div", M3, [
              (te(!0), ae(qe, null, ot(p.value, (B) => (te(), ae("button", {
                key: B,
                class: "swatch",
                style: yt({ backgroundColor: B }),
                onClick: (X) => E(B)
              }, null, 12, C3))), 128))
            ])
          ])) : Pe("", !0)
        ], 4)) : Pe("", !0)
      ], 8, ["disabled"]))
    ], 512));
  }
}), uu = /* @__PURE__ */ Gt(T3, [["__scopeId", "data-v-05165efb"]]), E3 = { class: "effect-controls" }, A3 = { class: "panel-header" }, P3 = { class: "header-row" }, R3 = {
  key: 0,
  class: "layer-badge"
}, D3 = { class: "layer-type-icon" }, k3 = ["disabled"], I3 = {
  key: 0,
  class: "effect-menu"
}, L3 = { class: "category-label" }, F3 = { class: "cat-icon" }, U3 = { class: "category-items" }, O3 = ["onClick"], z3 = { class: "panel-content" }, N3 = {
  key: 0,
  class: "empty-state"
}, B3 = {
  key: 1,
  class: "empty-state"
}, V3 = {
  key: 2,
  class: "effects-list"
}, G3 = ["onClick"], H3 = { class: "header-left" }, $3 = { class: "arrow" }, W3 = ["onClick"], X3 = { class: "effect-name" }, j3 = { class: "header-right" }, Y3 = ["onClick"], q3 = {
  key: 0,
  class: "effect-params"
}, Z3 = { class: "param-header" }, K3 = ["title"], J3 = ["onClick"], Q3 = { class: "param-control" }, eP = {
  key: 0,
  class: "control-group"
}, tP = {
  key: 1,
  class: "control-group"
}, nP = {
  key: 2,
  class: "control-group point-group"
}, iP = ["checked", "onChange"], sP = ["value", "onChange"], rP = ["value"], oP = /* @__PURE__ */ Ot({
  __name: "EffectControlsPanel",
  setup(s) {
    const e = sn(), n = we(!1), i = we(null), r = Ie(() => e.selectedLayer), o = Qh;
    function a(E) {
      return Object.entries(cu).filter(([y, w]) => w.category === E).map(([y, w]) => ({ key: y, ...w }));
    }
    function l(E, y) {
      const w = cu[E];
      return w == null ? void 0 : w.parameters.find((D) => c(D.name) === y);
    }
    function c(E) {
      return E.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function u(E, y) {
      const w = l(E, y);
      return w && (w.min !== void 0 || w.max !== void 0);
    }
    function d(E, y) {
      const w = l(E, y);
      return (w == null ? void 0 : w.type) === "checkbox";
    }
    function h(E, y) {
      const w = l(E, y);
      return (w == null ? void 0 : w.type) === "angle";
    }
    function m(E, y) {
      const w = l(E, y);
      return (w == null ? void 0 : w.options) || [];
    }
    function p(E) {
      return {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      }[E] || "";
    }
    function v(E) {
      r.value && (e.addEffectToLayer(r.value.id, E), n.value = !1);
    }
    function _(E) {
      r.value && e.removeEffectFromLayer(r.value.id, E.id);
    }
    function g(E) {
      r.value && e.toggleEffect(r.value.id, E.id);
    }
    function x(E) {
      E.expanded = !E.expanded;
    }
    function M(E, y, w) {
      r.value && e.updateEffectParameter(r.value.id, E, y, w);
    }
    function S(E, y, w, D) {
      if (!r.value) return;
      const U = r.value.effects.find((A) => A.id === E);
      if (!U) return;
      const O = { ...U.parameters[y].value, [w]: D };
      e.updateEffectParameter(r.value.id, E, y, O);
    }
    function b(E) {
      return typeof E == "string" ? E : JA(E.r, E.g, E.b, E.a ?? 1);
    }
    function C(E, y, w) {
      const D = ZA(w);
      if (D && r.value) {
        const U = { r: D[0], g: D[1], b: D[2], a: D[3] };
        e.updateEffectParameter(r.value.id, E, y, U);
      }
    }
    function T(E, y) {
      if (!r.value) return;
      const w = r.value.effects.find((U) => U.id === E), D = w == null ? void 0 : w.parameters[y];
      D && e.setEffectParamAnimated(r.value.id, E, y, !D.animated);
    }
    function P(E) {
      i.value && !i.value.contains(E.target) && (n.value = !1);
    }
    return xn(() => window.addEventListener("mousedown", P)), Nn(() => window.removeEventListener("mousedown", P)), (E, y) => (te(), ae("div", E3, [
      f("div", A3, [
        f("div", P3, [
          y[1] || (y[1] = f("h3", null, "Effect Controls", -1)),
          r.value ? (te(), ae("div", R3, [
            f("span", D3, _e(p(r.value.type)), 1),
            ct(" " + _e(r.value.name), 1)
          ])) : Pe("", !0)
        ]),
        f("div", {
          class: "add-effect-wrapper",
          ref_key: "menuRef",
          ref: i
        }, [
          f("button", {
            class: "add-btn",
            onClick: y[0] || (y[0] = (w) => n.value = !n.value),
            disabled: !r.value
          }, [...y[2] || (y[2] = [
            f("span", { class: "icon" }, "+", -1),
            ct(" Add Effect ", -1)
          ])], 8, k3),
          n.value ? (te(), ae("div", I3, [
            (te(!0), ae(qe, null, ot(Ve(o), (w, D) => (te(), ae("div", {
              key: D,
              class: "effect-category"
            }, [
              f("div", L3, [
                f("span", F3, _e(w.icon), 1),
                ct(" " + _e(w.label), 1)
              ]),
              f("div", U3, [
                (te(!0), ae(qe, null, ot(a(D), (U) => (te(), ae("button", {
                  key: U.key,
                  onClick: (R) => v(U.key)
                }, _e(U.name), 9, O3))), 128))
              ])
            ]))), 128))
          ])) : Pe("", !0)
        ], 512)
      ]),
      f("div", z3, [
        r.value ? !r.value.effects || r.value.effects.length === 0 ? (te(), ae("div", B3, " No effects applied ")) : (te(), ae("div", V3, [
          (te(!0), ae(qe, null, ot(r.value.effects, (w, D) => (te(), ae("div", {
            key: w.id,
            class: Fe(["effect-item", { collapsed: !w.expanded }])
          }, [
            f("div", {
              class: "effect-header",
              onClick: (U) => x(w)
            }, [
              f("div", H3, [
                f("span", $3, _e(w.expanded ? "" : ""), 1),
                f("button", {
                  class: "icon-btn",
                  onClick: xt((U) => g(w), ["stop"])
                }, [
                  f("span", {
                    class: Fe(["fx-icon", { disabled: !w.enabled }])
                  }, "fx", 2)
                ], 8, W3),
                f("span", X3, _e(w.name), 1)
              ]),
              f("div", j3, [
                f("button", {
                  class: "icon-btn delete",
                  onClick: xt((U) => _(w), ["stop"]),
                  title: "Remove Effect"
                }, "", 8, Y3)
              ])
            ], 8, G3),
            w.expanded ? (te(), ae("div", q3, [
              (te(!0), ae(qe, null, ot(w.parameters, (U, R) => {
                var O, A, G, ue;
                return te(), ae("div", {
                  key: R,
                  class: "param-row"
                }, [
                  f("div", Z3, [
                    f("span", {
                      class: "param-name",
                      title: String(R)
                    }, _e(U.name), 9, K3),
                    f("button", {
                      class: Fe(["stopwatch", { active: U.animated }]),
                      onClick: (Q) => T(w.id, String(R)),
                      title: "Toggle Animation"
                    }, "", 10, J3)
                  ]),
                  f("div", Q3, [
                    U.type === "number" && h(w.effectKey, String(R)) ? (te(), ae("div", eP, [
                      ze(Jf, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        size: 32,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      ze(et, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : U.type === "number" ? (te(), ae("div", tP, [
                      u(w.effectKey, String(R)) ? (te(), St(jn, {
                        key: 0,
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        min: ((O = l(w.effectKey, String(R))) == null ? void 0 : O.min) ?? 0,
                        max: ((A = l(w.effectKey, String(R))) == null ? void 0 : A.max) ?? 100,
                        step: ((G = l(w.effectKey, String(R))) == null ? void 0 : G.step) ?? 1,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : Pe("", !0),
                      ze(et, {
                        modelValue: U.value,
                        "onUpdate:modelValue": (Q) => M(w.id, String(R), Q),
                        step: ((ue = l(w.effectKey, String(R))) == null ? void 0 : ue.step) ?? 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                    ])) : U.type === "position" ? (te(), ae("div", nP, [
                      ze(et, {
                        modelValue: U.value.x,
                        "onUpdate:modelValue": (Q) => S(w.id, String(R), "x", Q),
                        label: "X"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      ze(et, {
                        modelValue: U.value.y,
                        "onUpdate:modelValue": (Q) => S(w.id, String(R), "y", Q),
                        label: "Y"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : U.type === "color" ? (te(), St(uu, {
                      key: 3,
                      modelValue: b(U.value),
                      "onUpdate:modelValue": (Q) => C(w.id, String(R), Q),
                      alpha: !0
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : U.type === "enum" && d(w.effectKey, String(R)) ? (te(), ae("input", {
                      key: 4,
                      type: "checkbox",
                      checked: U.value,
                      onChange: (Q) => M(w.id, String(R), Q.target.checked)
                    }, null, 40, iP)) : U.type === "enum" ? (te(), ae("select", {
                      key: 5,
                      value: U.value,
                      onChange: (Q) => M(w.id, String(R), Q.target.value),
                      class: "param-select"
                    }, [
                      (te(!0), ae(qe, null, ot(m(w.effectKey, String(R)), (Q) => (te(), ae("option", {
                        key: Q.value,
                        value: Q.value
                      }, _e(Q.label), 9, rP))), 128))
                    ], 40, sP)) : Pe("", !0)
                  ])
                ]);
              }), 128))
            ])) : Pe("", !0)
          ], 2))), 128))
        ])) : (te(), ae("div", N3, " Select a layer to edit effects "))
      ])
    ]));
  }
}), aP = /* @__PURE__ */ Gt(oP, [["__scopeId", "data-v-8ac57c6b"]]), yo = Ko("Font"), mc = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], vc = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class lP {
  constructor() {
    fe(this, "systemFonts", []);
    fe(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    fe(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const i of e)
        (!n.has(i.family) || i.style === "Regular") && n.set(i.family, {
          family: i.family,
          fullName: i.fullName,
          style: i.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((i, r) => i.family.localeCompare(r.family)), yo.debug(`Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? yo.info("User denied font access permission") : yo.error("Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: mc
    }), e.push({
      name: "Google Fonts",
      fonts: vc.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return mc.forEach((n) => e.add(n.family)), vc.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const i = n.join(";"), r = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${i}&display=swap`, o = document.createElement("link");
    o.rel = "stylesheet", o.href = r, document.head.appendChild(o);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), yo.debug(`Loaded Google Font: ${e}`);
    } catch (a) {
      yo.error(`Failed to load Google Font: ${e}`, a);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return mc.some((n) => n.family === e) ? !0 : vc.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", r = document.createElement("canvas").getContext("2d");
    r.font = "72px monospace";
    const o = r.measureText(n).width;
    r.font = `72px "${e}", monospace`;
    const a = r.measureText(n).width;
    return o !== a;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return mc;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return vc;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (yo.info("Local Font Access API not available"), !1);
  }
}
const xo = new lP(), cP = { class: "text-properties" }, uP = { class: "prop-section" }, dP = ["value"], hP = { class: "prop-section" }, fP = { class: "row font-row" }, pP = ["value"], mP = ["label"], vP = ["value"], gP = { class: "style-toggles" }, yP = {
  key: 0,
  class: "row"
}, xP = ["disabled"], _P = { class: "row" }, bP = { class: "row color-row" }, wP = { class: "color-item" }, SP = ["value"], MP = { class: "color-item" }, CP = ["value"], TP = { class: "row" }, EP = { class: "row" }, AP = { class: "align-buttons" }, PP = { class: "prop-section" }, RP = { class: "row" }, DP = { class: "vec2" }, kP = { class: "row" }, IP = { class: "vec2" }, LP = { class: "row" }, FP = { class: "vec2" }, UP = { class: "row" }, OP = { class: "row" }, zP = { class: "prop-section" }, NP = { class: "row" }, BP = ["value"], VP = ["value"], GP = { class: "row" }, HP = { class: "row" }, $P = { class: "row" }, WP = { class: "row checkbox-row" }, XP = ["checked"], jP = { class: "row checkbox-row" }, YP = ["checked"], qP = { class: "row checkbox-row" }, ZP = ["checked"], KP = { class: "prop-section" }, JP = { class: "row" }, QP = { class: "row" }, eR = { class: "row" }, tR = { class: "prop-section checkbox" }, nR = ["checked"], iR = /* @__PURE__ */ Ot({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we([]), a = we(!1), l = we(!1);
    xn(async () => {
      await xo.initialize(), o.value = xo.getFontCategories(), a.value = xo.hasSystemFonts();
    });
    async function c() {
      l.value = !0;
      try {
        await xo.requestSystemFontAccess() && (o.value = xo.getFontCategories(), a.value = !0);
      } finally {
        l.value = !1;
      }
    }
    const u = Ie(() => n.layer.data), d = Ie(() => n.layer.transform), h = Ie(() => r.layers.filter((E) => E.type === "spline"));
    function m(E) {
      var y;
      return (y = n.layer.properties) == null ? void 0 : y.find((w) => w.name === E);
    }
    function p(E) {
      const y = m(E);
      return y ? y.value : null;
    }
    function v(E) {
      r.setPropertyValue(n.layer.id, "Source Text", E), r.updateLayerData(n.layer.id, { text: E }), i("update");
    }
    function _(E, y) {
      r.updateLayerData(n.layer.id, { [E]: y });
      const w = {
        fill: "Fill Color",
        stroke: "Stroke Color",
        fontSize: "Font Size",
        strokeWidth: "Stroke Width"
      };
      w[E] && r.setPropertyValue(n.layer.id, w[E], y), i("update");
    }
    function g(E, y) {
      r.setPropertyValue(n.layer.id, E, y);
      const w = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        Tracking: "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      w[E] && r.updateLayerData(n.layer.id, { [w[E]]: y }), i("update");
    }
    function x(E) {
      const y = m(E);
      return (y == null ? void 0 : y.animated) ?? !1;
    }
    function M(E) {
      var U;
      const y = m(E);
      if (!y) return;
      const w = r.currentFrame, D = (U = y.keyframes) == null ? void 0 : U.find((R) => R.frame === w);
      D ? r.removeKeyframe(n.layer.id, E, D.id) : r.addKeyframe(n.layer.id, E, y.value, w), i("update");
    }
    function S(E, y, w) {
      const D = d.value[E];
      let U;
      y ? U = { ...D.value, [y]: w } : U = w, r.setPropertyValue(n.layer.id, `transform.${E}`, U), i("update");
    }
    function b(E) {
      r.setPropertyValue(n.layer.id, "opacity", E), i("update");
    }
    function C() {
      _("fontWeight", u.value.fontWeight === "bold" ? "400" : "bold");
    }
    function T() {
      _("fontStyle", u.value.fontStyle === "italic" ? "normal" : "italic");
    }
    async function P(E) {
      await xo.ensureFont(E), _("fontFamily", E);
    }
    return (E, y) => {
      var w;
      return te(), ae("div", cP, [
        f("div", uP, [
          y[29] || (y[29] = f("div", { class: "section-title" }, "Source Text", -1)),
          f("textarea", {
            value: u.value.text,
            onInput: y[0] || (y[0] = (D) => v(D.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, dP)
        ]),
        f("div", hP, [
          y[35] || (y[35] = f("div", { class: "section-title" }, "Character", -1)),
          f("div", fP, [
            f("select", {
              value: u.value.fontFamily,
              onChange: y[1] || (y[1] = (D) => P(D.target.value)),
              class: "font-select"
            }, [
              (te(!0), ae(qe, null, ot(o.value, (D) => (te(), ae("optgroup", {
                key: D.name,
                label: D.name
              }, [
                (te(!0), ae(qe, null, ot(D.fonts, (U) => (te(), ae("option", {
                  key: U.family,
                  value: U.family
                }, _e(U.family), 9, vP))), 128))
              ], 8, mP))), 128))
            ], 40, pP),
            f("div", gP, [
              f("button", {
                class: Fe({ active: u.value.fontWeight === "bold" }),
                onClick: C
              }, "B", 2),
              f("button", {
                class: Fe({ active: u.value.fontStyle === "italic" }),
                onClick: T
              }, "I", 2)
            ])
          ]),
          a.value ? Pe("", !0) : (te(), ae("div", yP, [
            f("button", {
              class: "font-access-btn",
              onClick: c,
              disabled: l.value
            }, _e(l.value ? "Loading..." : "+ Load System Fonts"), 9, xP)
          ])),
          f("div", _P, [
            y[30] || (y[30] = f("label", null, "Size", -1)),
            ze(Ve(et), {
              modelValue: p("Font Size") || u.value.fontSize,
              "onUpdate:modelValue": y[2] || (y[2] = (D) => g("Font Size", D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", bP, [
            f("div", wP, [
              f("input", {
                type: "color",
                value: u.value.fill,
                onInput: y[3] || (y[3] = (D) => _("fill", D.target.value))
              }, null, 40, SP),
              y[31] || (y[31] = f("span", null, "Fill", -1))
            ]),
            f("div", MP, [
              f("input", {
                type: "color",
                value: u.value.stroke || "#000000",
                onInput: y[4] || (y[4] = (D) => _("stroke", D.target.value))
              }, null, 40, CP),
              y[32] || (y[32] = f("span", null, "Stroke", -1))
            ])
          ]),
          f("div", TP, [
            y[33] || (y[33] = f("label", null, "Stroke Width", -1)),
            ze(Ve(et), {
              modelValue: p("Stroke Width") || u.value.strokeWidth || 0,
              "onUpdate:modelValue": y[5] || (y[5] = (D) => g("Stroke Width", D)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          f("div", EP, [
            y[34] || (y[34] = f("label", null, "Alignment", -1)),
            f("div", AP, [
              f("button", {
                class: Fe({ active: u.value.textAlign === "left" }),
                onClick: y[6] || (y[6] = (D) => _("textAlign", "left"))
              }, "", 2),
              f("button", {
                class: Fe({ active: u.value.textAlign === "center" }),
                onClick: y[7] || (y[7] = (D) => _("textAlign", "center"))
              }, "", 2),
              f("button", {
                class: Fe({ active: u.value.textAlign === "right" }),
                onClick: y[8] || (y[8] = (D) => _("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        f("div", PP, [
          y[41] || (y[41] = f("div", { class: "section-title" }, "Transform", -1)),
          f("div", RP, [
            y[36] || (y[36] = f("label", null, "Position", -1)),
            f("div", DP, [
              ze(Ve(et), {
                modelValue: d.value.position.value.x,
                "onUpdate:modelValue": y[9] || (y[9] = (D) => S("position", "x", D))
              }, null, 8, ["modelValue"]),
              ze(Ve(et), {
                modelValue: d.value.position.value.y,
                "onUpdate:modelValue": y[10] || (y[10] = (D) => S("position", "y", D))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", kP, [
            y[37] || (y[37] = f("label", null, "Anchor Pt", -1)),
            f("div", IP, [
              ze(Ve(et), {
                modelValue: d.value.anchorPoint.value.x,
                "onUpdate:modelValue": y[11] || (y[11] = (D) => S("anchorPoint", "x", D))
              }, null, 8, ["modelValue"]),
              ze(Ve(et), {
                modelValue: d.value.anchorPoint.value.y,
                "onUpdate:modelValue": y[12] || (y[12] = (D) => S("anchorPoint", "y", D))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", LP, [
            y[38] || (y[38] = f("label", null, "Scale %", -1)),
            f("div", FP, [
              ze(Ve(et), {
                modelValue: d.value.scale.value.x,
                "onUpdate:modelValue": y[13] || (y[13] = (D) => S("scale", "x", D))
              }, null, 8, ["modelValue"]),
              ze(Ve(et), {
                modelValue: d.value.scale.value.y,
                "onUpdate:modelValue": y[14] || (y[14] = (D) => S("scale", "y", D))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", UP, [
            y[39] || (y[39] = f("label", null, "Rotation", -1)),
            ze(Ve(et), {
              modelValue: d.value.rotation.value,
              "onUpdate:modelValue": y[15] || (y[15] = (D) => S("rotation", null, D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", OP, [
            y[40] || (y[40] = f("label", null, "Opacity", -1)),
            ze(Ve(et), {
              modelValue: ((w = s.layer.opacity) == null ? void 0 : w.value) ?? 100,
              "onUpdate:modelValue": y[16] || (y[16] = (D) => b(D)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        f("div", zP, [
          y[50] || (y[50] = f("div", { class: "section-title" }, "Path Options", -1)),
          f("div", NP, [
            y[43] || (y[43] = f("label", null, "Path", -1)),
            f("select", {
              value: u.value.pathLayerId || "",
              onChange: y[17] || (y[17] = (D) => _("pathLayerId", D.target.value || null)),
              class: "full-select"
            }, [
              y[42] || (y[42] = f("option", { value: "" }, "None", -1)),
              (te(!0), ae(qe, null, ot(h.value, (D) => (te(), ae("option", {
                key: D.id,
                value: D.id
              }, _e(D.name), 9, VP))), 128))
            ], 40, BP)
          ]),
          u.value.pathLayerId ? (te(), ae(qe, { key: 0 }, [
            f("div", GP, [
              y[44] || (y[44] = f("label", null, "Path Offset %", -1)),
              ze(Ve(et), {
                modelValue: p("Path Offset") ?? u.value.pathOffset ?? 0,
                "onUpdate:modelValue": y[18] || (y[18] = (D) => g("Path Offset", D)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              f("button", {
                class: Fe(["keyframe-btn", { active: x("Path Offset") }]),
                onClick: y[19] || (y[19] = (D) => M("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            f("div", HP, [
              y[45] || (y[45] = f("label", null, "First Margin", -1)),
              ze(Ve(et), {
                modelValue: p("First Margin") ?? u.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": y[20] || (y[20] = (D) => g("First Margin", D)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            f("div", $P, [
              y[46] || (y[46] = f("label", null, "Last Margin", -1)),
              ze(Ve(et), {
                modelValue: p("Last Margin") ?? u.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": y[21] || (y[21] = (D) => g("Last Margin", D)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            f("div", WP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathReversed,
                  onChange: y[22] || (y[22] = (D) => _("pathReversed", !u.value.pathReversed))
                }, null, 40, XP),
                y[47] || (y[47] = ct(" Reverse Path ", -1))
              ])
            ]),
            f("div", jP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathPerpendicularToPath ?? !0,
                  onChange: y[23] || (y[23] = (D) => _("pathPerpendicularToPath", !u.value.pathPerpendicularToPath))
                }, null, 40, YP),
                y[48] || (y[48] = ct(" Perpendicular to Path ", -1))
              ])
            ]),
            f("div", qP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathForceAlignment,
                  onChange: y[24] || (y[24] = (D) => _("pathForceAlignment", !u.value.pathForceAlignment))
                }, null, 40, ZP),
                y[49] || (y[49] = ct(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : Pe("", !0)
        ]),
        f("div", KP, [
          y[54] || (y[54] = f("div", { class: "section-title" }, "Advanced", -1)),
          f("div", JP, [
            y[51] || (y[51] = f("label", null, "Tracking", -1)),
            ze(Ve(et), {
              modelValue: p("Tracking") || u.value.tracking || 0,
              "onUpdate:modelValue": y[25] || (y[25] = (D) => g("Tracking", D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", QP, [
            y[52] || (y[52] = f("label", null, "Line Spacing", -1)),
            ze(Ve(et), {
              modelValue: p("Line Spacing") || u.value.lineSpacing || 0,
              "onUpdate:modelValue": y[26] || (y[26] = (D) => g("Line Spacing", D))
            }, null, 8, ["modelValue"])
          ]),
          f("div", eR, [
            y[53] || (y[53] = f("label", null, "Char Offset", -1)),
            ze(Ve(et), {
              modelValue: p("Character Offset") || u.value.characterOffset || 0,
              "onUpdate:modelValue": y[27] || (y[27] = (D) => g("Character Offset", D)),
              precision: 0
            }, null, 8, ["modelValue"])
          ])
        ]),
        f("div", tR, [
          f("label", null, [
            f("input", {
              type: "checkbox",
              checked: u.value.perCharacter3D,
              onChange: y[28] || (y[28] = (D) => _("perCharacter3D", !u.value.perCharacter3D))
            }, null, 40, nR),
            y[55] || (y[55] = ct(" Enable Per-Character 3D ", -1))
          ])
        ])
      ]);
    };
  }
}), sR = /* @__PURE__ */ Gt(iR, [["__scopeId", "data-v-947c42b2"]]), rR = { class: "particle-properties" }, oR = { class: "property-section" }, aR = {
  key: 0,
  class: "section-content"
}, lR = { class: "property-row" }, cR = ["value"], uR = { class: "value-display" }, dR = { class: "property-row" }, hR = ["value"], fR = { class: "value-display" }, pR = { class: "property-row" }, mR = ["value"], vR = { class: "value-display" }, gR = { class: "property-row" }, yR = ["value"], xR = { class: "value-display" }, _R = { class: "property-row" }, bR = ["value"], wR = { class: "value-display" }, SR = { class: "property-row" }, MR = ["value"], CR = { class: "property-section" }, TR = {
  key: 0,
  class: "section-content"
}, ER = ["onClick"], AR = ["value", "onInput"], PR = { class: "enabled-toggle" }, RR = ["checked", "onChange"], DR = ["onClick"], kR = {
  key: 0,
  class: "emitter-content"
}, IR = { class: "property-row" }, LR = ["value", "onInput"], FR = { class: "value-display" }, UR = { class: "property-row" }, OR = ["value", "onInput"], zR = { class: "value-display" }, NR = { class: "property-row" }, BR = ["value", "onInput"], VR = { class: "value-display" }, GR = { class: "property-row" }, HR = ["value", "onInput"], $R = { class: "value-display" }, WR = { class: "property-row" }, XR = ["value", "onInput"], jR = { class: "value-display" }, YR = { class: "property-row" }, qR = ["value", "onInput"], ZR = { class: "value-display" }, KR = { class: "property-row" }, JR = ["value", "onInput"], QR = { class: "value-display" }, eD = { class: "property-row" }, tD = ["value", "onInput"], nD = { class: "value-display" }, iD = { class: "property-row" }, sD = ["value", "onInput"], rD = { class: "property-row" }, oD = ["value", "onInput"], aD = { class: "value-display" }, lD = { class: "property-row" }, cD = ["value", "onInput"], uD = { class: "value-display" }, dD = { class: "property-row" }, hD = ["value", "onInput"], fD = { class: "value-display" }, pD = { class: "property-row checkbox-row" }, mD = ["checked", "onChange"], vD = {
  key: 0,
  class: "property-row"
}, gD = ["value", "onInput"], yD = { class: "value-display" }, xD = {
  key: 0,
  class: "empty-message"
}, _D = { class: "property-section" }, bD = {
  key: 0,
  class: "section-content"
}, wD = { class: "force-tabs" }, SD = {
  key: 0,
  class: "force-list"
}, MD = { class: "force-header" }, CD = ["value", "onInput"], TD = { class: "enabled-toggle" }, ED = ["checked", "onChange"], AD = ["onClick"], PD = { class: "property-row" }, RD = ["value", "onInput"], DD = { class: "value-display" }, kD = { class: "property-row" }, ID = ["value", "onInput"], LD = { class: "value-display" }, FD = { class: "property-row" }, UD = ["value", "onInput"], OD = { class: "value-display" }, zD = { class: "property-row" }, ND = ["value", "onInput"], BD = { class: "value-display" }, VD = { class: "property-row" }, GD = ["value", "onChange"], HD = {
  key: 1,
  class: "force-list"
}, $D = { class: "force-header" }, WD = ["value", "onInput"], XD = { class: "enabled-toggle" }, jD = ["checked", "onChange"], YD = ["onClick"], qD = { class: "property-row" }, ZD = ["value", "onInput"], KD = { class: "value-display" }, JD = { class: "property-row" }, QD = ["value", "onInput"], ek = { class: "value-display" }, tk = { class: "property-row" }, nk = ["value", "onInput"], ik = { class: "value-display" }, sk = { class: "property-row" }, rk = ["value", "onInput"], ok = { class: "value-display" }, ak = { class: "property-row" }, lk = ["value", "onInput"], ck = { class: "value-display" }, uk = { class: "property-row" }, dk = ["value", "onInput"], hk = { class: "value-display" }, fk = { class: "property-section" }, pk = {
  key: 0,
  class: "section-content"
}, mk = { class: "force-header" }, vk = { class: "enabled-toggle" }, gk = ["checked", "onChange"], yk = ["onClick"], xk = { class: "property-row" }, _k = ["value", "onInput"], bk = { class: "value-display" }, wk = { class: "property-row" }, Sk = ["value", "onInput"], Mk = { class: "value-display" }, Ck = { class: "property-row" }, Tk = ["value", "onInput"], Ek = { class: "value-display" }, Ak = {
  key: 0,
  class: "empty-message"
}, Pk = { class: "property-section" }, Rk = {
  key: 0,
  class: "section-content"
}, Dk = { class: "force-header" }, kk = ["value", "onChange"], Ik = ["value"], Lk = { class: "enabled-toggle" }, Fk = ["checked", "onChange"], Uk = ["onClick"], Ok = { class: "property-row" }, zk = ["value", "onChange"], Nk = { class: "property-row" }, Bk = ["value", "onInput"], Vk = { class: "value-display" }, Gk = { class: "property-row" }, Hk = ["value", "onInput"], $k = { class: "value-display" }, Wk = { class: "property-row" }, Xk = ["value", "onInput"], jk = { class: "value-display" }, Yk = { class: "property-row" }, qk = ["value", "onInput"], Zk = { class: "value-display" }, Kk = { class: "property-row" }, Jk = ["value", "onInput"], Qk = { class: "value-display" }, eI = { class: "property-row" }, tI = ["value", "onInput"], nI = { class: "value-display" }, iI = { class: "property-row" }, sI = ["value", "onInput"], rI = {
  key: 0,
  class: "empty-message"
}, oI = { class: "property-section" }, aI = {
  key: 0,
  class: "section-content"
}, lI = { class: "modulation-header" }, cI = ["value", "onChange"], uI = ["value"], dI = ["onClick"], hI = { class: "property-row" }, fI = ["value", "onChange"], pI = { class: "property-row" }, mI = ["value", "onInput"], vI = { class: "property-row" }, gI = ["value", "onInput"], yI = { class: "property-row" }, xI = ["value", "onChange"], _I = {
  key: 0,
  class: "empty-message"
}, bI = { class: "property-section" }, wI = {
  key: 0,
  class: "section-content"
}, SI = { class: "property-row" }, MI = ["value"], CI = { class: "property-row" }, TI = ["value"], EI = { class: "property-row checkbox-row" }, AI = ["checked"], PI = {
  key: 0,
  class: "property-row"
}, RI = ["value"], DI = { class: "value-display" }, kI = { class: "property-row checkbox-row" }, II = ["checked"], LI = {
  key: 1,
  class: "property-row"
}, FI = ["value"], UI = { class: "value-display" }, OI = {
  key: 2,
  class: "property-row"
}, zI = ["value"], NI = { class: "value-display" }, BI = { class: "property-row checkbox-row" }, VI = ["checked"], GI = {
  key: 3,
  class: "property-row"
}, HI = ["value"], $I = { class: "value-display" }, WI = {
  key: 4,
  class: "property-row"
}, XI = ["value"], jI = { class: "value-display" }, YI = {
  key: 5,
  class: "property-row"
}, qI = ["value"], ZI = { class: "value-display" }, KI = {
  key: 6,
  class: "property-row"
}, JI = ["value"], QI = { class: "value-display" }, eL = {
  key: 7,
  class: "property-row checkbox-row"
}, tL = ["checked"], nL = { class: "particle-count" }, iL = /* @__PURE__ */ Ot({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(/* @__PURE__ */ new Set(["system", "emitters"])), o = we(/* @__PURE__ */ new Set()), a = we("wells"), l = Ie(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), c = Ie(() => l.value.systemConfig), u = Ie(() => l.value.emitters), d = Ie(() => l.value.gravityWells), h = Ie(() => l.value.vortices), m = Ie(() => l.value.modulations), p = Ie(() => l.value.renderOptions), v = Ie(() => l.value.turbulenceFields || []), _ = Ie(() => l.value.subEmitters || []), g = Ie(() => p.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), x = Ie(() => n.particleCount);
    function M(H) {
      r.value.has(H) ? r.value.delete(H) : r.value.add(H);
    }
    function S(H) {
      o.value.has(H) ? o.value.delete(H) : o.value.add(H);
    }
    function b(H, I) {
      i("update", {
        systemConfig: { ...c.value, [H]: I }
      });
    }
    function C(H, I, F) {
      const L = u.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { emitters: L });
    }
    function T(H, I) {
      const F = Y(I);
      C(H, "color", F);
    }
    function P() {
      const H = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${u.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      i("update", { emitters: [...u.value, H] }), o.value.add(H.id);
    }
    function E(H) {
      i("update", { emitters: u.value.filter((I) => I.id !== H) });
    }
    function y(H, I, F) {
      const L = d.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { gravityWells: L });
    }
    function w() {
      const H = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${d.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      i("update", { gravityWells: [...d.value, H] });
    }
    function D(H) {
      i("update", { gravityWells: d.value.filter((I) => I.id !== H) });
    }
    function U(H, I, F) {
      const L = h.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { vortices: L });
    }
    function R() {
      const H = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${h.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      i("update", { vortices: [...h.value, H] });
    }
    function O(H) {
      i("update", { vortices: h.value.filter((I) => I.id !== H) });
    }
    function A(H, I, F) {
      const L = m.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { modulations: L });
    }
    function G() {
      const H = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      i("update", { modulations: [...m.value, H] });
    }
    function ue(H) {
      i("update", { modulations: m.value.filter((I) => I.id !== H) });
    }
    function Q(H, I) {
      i("update", {
        renderOptions: { ...p.value, [H]: I }
      });
    }
    function le(H, I) {
      i("update", {
        renderOptions: {
          ...p.value,
          connections: { ...g.value, [H]: I }
        }
      });
    }
    function re(H, I, F) {
      const L = v.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { turbulenceFields: L });
    }
    function j() {
      const H = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      i("update", { turbulenceFields: [...v.value, H] });
    }
    function $(H) {
      i("update", { turbulenceFields: v.value.filter((I) => I.id !== H) });
    }
    function q(H, I, F) {
      const L = _.value.map(
        (ee) => ee.id === H ? { ...ee, [I]: F } : ee
      );
      i("update", { subEmitters: L });
    }
    function oe(H, I) {
      const F = Y(I);
      q(H, "color", F);
    }
    function ie() {
      const H = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      i("update", { subEmitters: [..._.value, H] });
    }
    function ce(H) {
      i("update", { subEmitters: _.value.filter((I) => I.id !== H) });
    }
    function V(H) {
      return "#" + H.map((I) => I.toString(16).padStart(2, "0")).join("");
    }
    function Y(H) {
      const I = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(H);
      return I ? [parseInt(I[1], 16), parseInt(I[2], 16), parseInt(I[3], 16)] : [255, 255, 255];
    }
    return (H, I) => (te(), ae("div", rR, [
      f("div", oR, [
        f("div", {
          class: "section-header",
          onClick: I[0] || (I[0] = (F) => M("system"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[30] || (I[30] = f("span", null, "System Settings", -1))
        ]),
        r.value.has("system") ? (te(), ae("div", aR, [
          f("div", lR, [
            I[31] || (I[31] = f("label", null, "Max Particles", -1)),
            f("input", {
              type: "range",
              value: c.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: I[1] || (I[1] = (F) => b("maxParticles", Number(F.target.value)))
            }, null, 40, cR),
            f("span", uR, _e(c.value.maxParticles), 1)
          ]),
          f("div", dR, [
            I[32] || (I[32] = f("label", null, "Gravity", -1)),
            f("input", {
              type: "range",
              value: c.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: I[2] || (I[2] = (F) => b("gravity", Number(F.target.value)))
            }, null, 40, hR),
            f("span", fR, _e(c.value.gravity), 1)
          ]),
          f("div", pR, [
            I[33] || (I[33] = f("label", null, "Wind Strength", -1)),
            f("input", {
              type: "range",
              value: c.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: I[3] || (I[3] = (F) => b("windStrength", Number(F.target.value)))
            }, null, 40, mR),
            f("span", vR, _e(c.value.windStrength), 1)
          ]),
          f("div", gR, [
            I[34] || (I[34] = f("label", null, "Wind Direction", -1)),
            f("input", {
              type: "range",
              value: c.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: I[4] || (I[4] = (F) => b("windDirection", Number(F.target.value)))
            }, null, 40, yR),
            f("span", xR, _e(c.value.windDirection) + "", 1)
          ]),
          f("div", _R, [
            I[35] || (I[35] = f("label", null, "Friction", -1)),
            f("input", {
              type: "range",
              value: c.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: I[5] || (I[5] = (F) => b("friction", Number(F.target.value)))
            }, null, 40, bR),
            f("span", wR, _e(c.value.friction.toFixed(2)), 1)
          ]),
          f("div", SR, [
            I[37] || (I[37] = f("label", null, "Boundary", -1)),
            f("select", {
              value: c.value.boundaryBehavior,
              onChange: I[6] || (I[6] = (F) => b("boundaryBehavior", F.target.value))
            }, [...I[36] || (I[36] = [
              f("option", { value: "kill" }, "Kill", -1),
              f("option", { value: "bounce" }, "Bounce", -1),
              f("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, MR)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", CR, [
        f("div", {
          class: "section-header",
          onClick: I[7] || (I[7] = (F) => M("emitters"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[39] || (I[39] = f("span", null, "Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: xt(P, ["stop"]),
            title: "Add Emitter"
          }, [...I[38] || (I[38] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("emitters") ? (te(), ae("div", TR, [
          (te(!0), ae(qe, null, ot(u.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "emitter-item"
          }, [
            f("div", {
              class: "emitter-header",
              onClick: (L) => S(F.id)
            }, [
              f("i", {
                class: Fe(["pi", o.value.has(F.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              f("input", {
                type: "text",
                value: F.name,
                onInput: (L) => C(F.id, "name", L.target.value),
                onClick: I[8] || (I[8] = xt(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, AR),
              f("label", PR, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (L) => C(F.id, "enabled", L.target.checked),
                  onClick: I[9] || (I[9] = xt(() => {
                  }, ["stop"]))
                }, null, 40, RR)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: xt((L) => E(F.id), ["stop"]),
                title: "Remove"
              }, [...I[40] || (I[40] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, DR)
            ], 8, ER),
            o.value.has(F.id) ? (te(), ae("div", kR, [
              f("div", IR, [
                I[41] || (I[41] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => C(F.id, "x", Number(L.target.value))
                }, null, 40, LR),
                f("span", FR, _e(F.x.toFixed(2)), 1)
              ]),
              f("div", UR, [
                I[42] || (I[42] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => C(F.id, "y", Number(L.target.value))
                }, null, 40, OR),
                f("span", zR, _e(F.y.toFixed(2)), 1)
              ]),
              f("div", NR, [
                I[43] || (I[43] = f("label", null, "Direction", -1)),
                f("input", {
                  type: "range",
                  value: F.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (L) => C(F.id, "direction", Number(L.target.value))
                }, null, 40, BR),
                f("span", VR, _e(F.direction) + "", 1)
              ]),
              f("div", GR, [
                I[44] || (I[44] = f("label", null, "Spread", -1)),
                f("input", {
                  type: "range",
                  value: F.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (L) => C(F.id, "spread", Number(L.target.value))
                }, null, 40, HR),
                f("span", $R, _e(F.spread) + "", 1)
              ]),
              f("div", WR, [
                I[45] || (I[45] = f("label", null, "Speed", -1)),
                f("input", {
                  type: "range",
                  value: F.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (L) => C(F.id, "speed", Number(L.target.value))
                }, null, 40, XR),
                f("span", jR, _e(F.speed), 1)
              ]),
              f("div", YR, [
                I[46] || (I[46] = f("label", null, "Speed Variance", -1)),
                f("input", {
                  type: "range",
                  value: F.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (L) => C(F.id, "speedVariance", Number(L.target.value))
                }, null, 40, qR),
                f("span", ZR, _e(F.speedVariance), 1)
              ]),
              f("div", KR, [
                I[47] || (I[47] = f("label", null, "Size", -1)),
                f("input", {
                  type: "range",
                  value: F.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (L) => C(F.id, "size", Number(L.target.value))
                }, null, 40, JR),
                f("span", QR, _e(F.size) + "px", 1)
              ]),
              f("div", eD, [
                I[48] || (I[48] = f("label", null, "Size Variance", -1)),
                f("input", {
                  type: "range",
                  value: F.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (L) => C(F.id, "sizeVariance", Number(L.target.value))
                }, null, 40, tD),
                f("span", nD, _e(F.sizeVariance), 1)
              ]),
              f("div", iD, [
                I[49] || (I[49] = f("label", null, "Color", -1)),
                f("input", {
                  type: "color",
                  value: V(F.color),
                  onInput: (L) => T(F.id, L.target.value)
                }, null, 40, sD)
              ]),
              f("div", rD, [
                I[50] || (I[50] = f("label", null, "Emission Rate", -1)),
                f("input", {
                  type: "range",
                  value: F.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (L) => C(F.id, "emissionRate", Number(L.target.value))
                }, null, 40, oD),
                f("span", aD, _e(F.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              f("div", lD, [
                I[51] || (I[51] = f("label", null, "Lifetime", -1)),
                f("input", {
                  type: "range",
                  value: F.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (L) => C(F.id, "particleLifetime", Number(L.target.value))
                }, null, 40, cD),
                f("span", uD, _e(F.particleLifetime) + "f", 1)
              ]),
              f("div", dD, [
                I[52] || (I[52] = f("label", null, "Initial Burst", -1)),
                f("input", {
                  type: "range",
                  value: F.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (L) => C(F.id, "initialBurst", Number(L.target.value))
                }, null, 40, hD),
                f("span", fD, _e((F.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              f("div", pD, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: F.burstOnBeat,
                    onChange: (L) => C(F.id, "burstOnBeat", L.target.checked)
                  }, null, 40, mD),
                  I[53] || (I[53] = ct(" Burst on Beat ", -1))
                ])
              ]),
              F.burstOnBeat ? (te(), ae("div", vD, [
                I[54] || (I[54] = f("label", null, "Burst Count", -1)),
                f("input", {
                  type: "range",
                  value: F.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (L) => C(F.id, "burstCount", Number(L.target.value))
                }, null, 40, gD),
                f("span", yD, _e(F.burstCount), 1)
              ])) : Pe("", !0)
            ])) : Pe("", !0)
          ]))), 128)),
          u.value.length === 0 ? (te(), ae("div", xD, " No emitters. Click + to add one. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", _D, [
        f("div", {
          class: "section-header",
          onClick: I[10] || (I[10] = (F) => M("forces"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[55] || (I[55] = f("span", null, "Force Fields", -1))
        ]),
        r.value.has("forces") ? (te(), ae("div", bD, [
          f("div", wD, [
            f("button", {
              class: Fe({ active: a.value === "wells" }),
              onClick: I[11] || (I[11] = (F) => a.value = "wells")
            }, " Gravity Wells ", 2),
            f("button", {
              class: Fe({ active: a.value === "vortices" }),
              onClick: I[12] || (I[12] = (F) => a.value = "vortices")
            }, " Vortices ", 2)
          ]),
          a.value === "wells" ? (te(), ae("div", SD, [
            f("button", {
              class: "add-btn full-width",
              onClick: w
            }, [...I[56] || (I[56] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              ct(" Add Gravity Well ", -1)
            ])]),
            (te(!0), ae(qe, null, ot(d.value, (F) => (te(), ae("div", {
              key: F.id,
              class: "force-item"
            }, [
              f("div", MD, [
                f("input", {
                  type: "text",
                  value: F.name,
                  onInput: (L) => y(F.id, "name", L.target.value),
                  class: "force-name"
                }, null, 40, CD),
                f("label", TD, [
                  f("input", {
                    type: "checkbox",
                    checked: F.enabled,
                    onChange: (L) => y(F.id, "enabled", L.target.checked)
                  }, null, 40, ED)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (L) => D(F.id)
                }, [...I[57] || (I[57] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, AD)
              ]),
              f("div", PD, [
                I[58] || (I[58] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => y(F.id, "x", Number(L.target.value))
                }, null, 40, RD),
                f("span", DD, _e(F.x.toFixed(2)), 1)
              ]),
              f("div", kD, [
                I[59] || (I[59] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => y(F.id, "y", Number(L.target.value))
                }, null, 40, ID),
                f("span", LD, _e(F.y.toFixed(2)), 1)
              ]),
              f("div", FD, [
                I[60] || (I[60] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: F.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (L) => y(F.id, "strength", Number(L.target.value))
                }, null, 40, UD),
                f("span", OD, _e(F.strength), 1)
              ]),
              f("div", zD, [
                I[61] || (I[61] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: F.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => y(F.id, "radius", Number(L.target.value))
                }, null, 40, ND),
                f("span", BD, _e(F.radius.toFixed(2)), 1)
              ]),
              f("div", VD, [
                I[63] || (I[63] = f("label", null, "Falloff", -1)),
                f("select", {
                  value: F.falloff,
                  onChange: (L) => y(F.id, "falloff", L.target.value)
                }, [...I[62] || (I[62] = [
                  f("option", { value: "linear" }, "Linear", -1),
                  f("option", { value: "quadratic" }, "Quadratic", -1),
                  f("option", { value: "constant" }, "Constant", -1)
                ])], 40, GD)
              ])
            ]))), 128))
          ])) : Pe("", !0),
          a.value === "vortices" ? (te(), ae("div", HD, [
            f("button", {
              class: "add-btn full-width",
              onClick: R
            }, [...I[64] || (I[64] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              ct(" Add Vortex ", -1)
            ])]),
            (te(!0), ae(qe, null, ot(h.value, (F) => (te(), ae("div", {
              key: F.id,
              class: "force-item"
            }, [
              f("div", $D, [
                f("input", {
                  type: "text",
                  value: F.name,
                  onInput: (L) => U(F.id, "name", L.target.value),
                  class: "force-name"
                }, null, 40, WD),
                f("label", XD, [
                  f("input", {
                    type: "checkbox",
                    checked: F.enabled,
                    onChange: (L) => U(F.id, "enabled", L.target.checked)
                  }, null, 40, jD)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (L) => O(F.id)
                }, [...I[65] || (I[65] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, YD)
              ]),
              f("div", qD, [
                I[66] || (I[66] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => U(F.id, "x", Number(L.target.value))
                }, null, 40, ZD),
                f("span", KD, _e(F.x.toFixed(2)), 1)
              ]),
              f("div", JD, [
                I[67] || (I[67] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => U(F.id, "y", Number(L.target.value))
                }, null, 40, QD),
                f("span", ek, _e(F.y.toFixed(2)), 1)
              ]),
              f("div", tk, [
                I[68] || (I[68] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: F.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (L) => U(F.id, "strength", Number(L.target.value))
                }, null, 40, nk),
                f("span", ik, _e(F.strength), 1)
              ]),
              f("div", sk, [
                I[69] || (I[69] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: F.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (L) => U(F.id, "radius", Number(L.target.value))
                }, null, 40, rk),
                f("span", ok, _e(F.radius.toFixed(2)), 1)
              ]),
              f("div", ak, [
                I[70] || (I[70] = f("label", null, "Rotation Speed", -1)),
                f("input", {
                  type: "range",
                  value: F.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (L) => U(F.id, "rotationSpeed", Number(L.target.value))
                }, null, 40, lk),
                f("span", ck, _e(F.rotationSpeed) + "/f", 1)
              ]),
              f("div", uk, [
                I[71] || (I[71] = f("label", null, "Inward Pull", -1)),
                f("input", {
                  type: "range",
                  value: F.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (L) => U(F.id, "inwardPull", Number(L.target.value))
                }, null, 40, dk),
                f("span", hk, _e(F.inwardPull), 1)
              ])
            ]))), 128))
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", fk, [
        f("div", {
          class: "section-header",
          onClick: I[13] || (I[13] = (F) => M("turbulence"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[73] || (I[73] = f("span", null, "Turbulence", -1)),
          f("button", {
            class: "add-btn",
            onClick: xt(j, ["stop"]),
            title: "Add Turbulence Field"
          }, [...I[72] || (I[72] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("turbulence") ? (te(), ae("div", pk, [
          (te(!0), ae(qe, null, ot(v.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "force-item"
          }, [
            f("div", mk, [
              I[75] || (I[75] = f("span", { class: "force-label" }, "Turbulence Field", -1)),
              f("label", vk, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (L) => re(F.id, "enabled", L.target.checked)
                }, null, 40, gk)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (L) => $(F.id)
              }, [...I[74] || (I[74] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, yk)
            ]),
            f("div", xk, [
              I[76] || (I[76] = f("label", null, "Scale", -1)),
              f("input", {
                type: "range",
                value: F.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (L) => re(F.id, "scale", Number(L.target.value))
              }, null, 40, _k),
              f("span", bk, _e(F.scale.toFixed(3)), 1)
            ]),
            f("div", wk, [
              I[77] || (I[77] = f("label", null, "Strength", -1)),
              f("input", {
                type: "range",
                value: F.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (L) => re(F.id, "strength", Number(L.target.value))
              }, null, 40, Sk),
              f("span", Mk, _e(F.strength), 1)
            ]),
            f("div", Ck, [
              I[78] || (I[78] = f("label", null, "Evolution", -1)),
              f("input", {
                type: "range",
                value: F.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (L) => re(F.id, "evolutionSpeed", Number(L.target.value))
              }, null, 40, Tk),
              f("span", Ek, _e(F.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          v.value.length === 0 ? (te(), ae("div", Ak, " No turbulence fields. Add one for organic particle motion. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", Pk, [
        f("div", {
          class: "section-header",
          onClick: I[14] || (I[14] = (F) => M("subEmitters"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[80] || (I[80] = f("span", null, "Sub-Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: xt(ie, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...I[79] || (I[79] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("subEmitters") ? (te(), ae("div", Rk, [
          (te(!0), ae(qe, null, ot(_.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "force-item"
          }, [
            f("div", Dk, [
              f("select", {
                value: F.parentEmitterId,
                onChange: (L) => q(F.id, "parentEmitterId", L.target.value),
                class: "sub-emitter-parent"
              }, [
                I[81] || (I[81] = f("option", { value: "*" }, "All Emitters", -1)),
                (te(!0), ae(qe, null, ot(u.value, (L) => (te(), ae("option", {
                  key: L.id,
                  value: L.id
                }, _e(L.name), 9, Ik))), 128))
              ], 40, kk),
              f("label", Lk, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (L) => q(F.id, "enabled", L.target.checked)
                }, null, 40, Fk)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (L) => ce(F.id)
              }, [...I[82] || (I[82] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, Uk)
            ]),
            f("div", Ok, [
              I[84] || (I[84] = f("label", null, "Trigger", -1)),
              f("select", {
                value: F.trigger,
                onChange: (L) => q(F.id, "trigger", L.target.value)
              }, [...I[83] || (I[83] = [
                f("option", { value: "death" }, "On Death", -1)
              ])], 40, zk)
            ]),
            f("div", Nk, [
              I[85] || (I[85] = f("label", null, "Spawn Count", -1)),
              f("input", {
                type: "range",
                value: F.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (L) => q(F.id, "spawnCount", Number(L.target.value))
              }, null, 40, Bk),
              f("span", Vk, _e(F.spawnCount), 1)
            ]),
            f("div", Gk, [
              I[86] || (I[86] = f("label", null, "Inherit Velocity", -1)),
              f("input", {
                type: "range",
                value: F.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (L) => q(F.id, "inheritVelocity", Number(L.target.value))
              }, null, 40, Hk),
              f("span", $k, _e((F.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            f("div", Wk, [
              I[87] || (I[87] = f("label", null, "Size", -1)),
              f("input", {
                type: "range",
                value: F.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (L) => q(F.id, "size", Number(L.target.value))
              }, null, 40, Xk),
              f("span", jk, _e(F.size) + "px", 1)
            ]),
            f("div", Yk, [
              I[88] || (I[88] = f("label", null, "Lifetime", -1)),
              f("input", {
                type: "range",
                value: F.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (L) => q(F.id, "lifetime", Number(L.target.value))
              }, null, 40, qk),
              f("span", Zk, _e(F.lifetime) + "f", 1)
            ]),
            f("div", Kk, [
              I[89] || (I[89] = f("label", null, "Speed", -1)),
              f("input", {
                type: "range",
                value: F.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (L) => q(F.id, "speed", Number(L.target.value))
              }, null, 40, Jk),
              f("span", Qk, _e(F.speed), 1)
            ]),
            f("div", eI, [
              I[90] || (I[90] = f("label", null, "Spread", -1)),
              f("input", {
                type: "range",
                value: F.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (L) => q(F.id, "spread", Number(L.target.value))
              }, null, 40, tI),
              f("span", nI, _e(F.spread) + "", 1)
            ]),
            f("div", iI, [
              I[91] || (I[91] = f("label", null, "Color", -1)),
              f("input", {
                type: "color",
                value: V(F.color),
                onInput: (L) => oe(F.id, L.target.value)
              }, null, 40, sI)
            ])
          ]))), 128)),
          _.value.length === 0 ? (te(), ae("div", rI, " No sub-emitters. Add one for particle death effects. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", oI, [
        f("div", {
          class: "section-header",
          onClick: I[15] || (I[15] = (F) => M("modulations"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[93] || (I[93] = f("span", null, "Modulations", -1)),
          f("button", {
            class: "add-btn",
            onClick: xt(G, ["stop"]),
            title: "Add Modulation"
          }, [...I[92] || (I[92] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("modulations") ? (te(), ae("div", aI, [
          (te(!0), ae(qe, null, ot(m.value, (F) => (te(), ae("div", {
            key: F.id,
            class: "modulation-item"
          }, [
            f("div", lI, [
              f("select", {
                value: F.emitterId,
                onChange: (L) => A(F.id, "emitterId", L.target.value)
              }, [
                I[94] || (I[94] = f("option", { value: "*" }, "All Emitters", -1)),
                (te(!0), ae(qe, null, ot(u.value, (L) => (te(), ae("option", {
                  key: L.id,
                  value: L.id
                }, _e(L.name), 9, uI))), 128))
              ], 40, cI),
              f("button", {
                class: "remove-btn",
                onClick: (L) => ue(F.id)
              }, [...I[95] || (I[95] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, dI)
            ]),
            f("div", hI, [
              I[97] || (I[97] = f("label", null, "Property", -1)),
              f("select", {
                value: F.property,
                onChange: (L) => A(F.id, "property", L.target.value)
              }, [...I[96] || (I[96] = [
                ls('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, fI)
            ]),
            f("div", pI, [
              I[98] || (I[98] = f("label", null, "Start Value", -1)),
              f("input", {
                type: "number",
                value: F.startValue,
                step: "0.1",
                onInput: (L) => A(F.id, "startValue", Number(L.target.value))
              }, null, 40, mI)
            ]),
            f("div", vI, [
              I[99] || (I[99] = f("label", null, "End Value", -1)),
              f("input", {
                type: "number",
                value: F.endValue,
                step: "0.1",
                onInput: (L) => A(F.id, "endValue", Number(L.target.value))
              }, null, 40, gI)
            ]),
            f("div", yI, [
              I[101] || (I[101] = f("label", null, "Easing", -1)),
              f("select", {
                value: F.easing,
                onChange: (L) => A(F.id, "easing", L.target.value)
              }, [...I[100] || (I[100] = [
                ls('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, xI)
            ])
          ]))), 128)),
          m.value.length === 0 ? (te(), ae("div", _I, " No modulations. Add one to animate particle properties over lifetime. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", bI, [
        f("div", {
          class: "section-header",
          onClick: I[16] || (I[16] = (F) => M("render"))
        }, [
          f("i", {
            class: Fe(["pi", r.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[102] || (I[102] = f("span", null, "Render Options", -1))
        ]),
        r.value.has("render") ? (te(), ae("div", wI, [
          f("div", SI, [
            I[104] || (I[104] = f("label", null, "Blend Mode", -1)),
            f("select", {
              value: p.value.blendMode,
              onChange: I[17] || (I[17] = (F) => Q("blendMode", F.target.value))
            }, [...I[103] || (I[103] = [
              f("option", { value: "normal" }, "Normal", -1),
              f("option", { value: "additive" }, "Additive", -1),
              f("option", { value: "multiply" }, "Multiply", -1),
              f("option", { value: "screen" }, "Screen", -1)
            ])], 40, MI)
          ]),
          f("div", CI, [
            I[106] || (I[106] = f("label", null, "Shape", -1)),
            f("select", {
              value: p.value.particleShape,
              onChange: I[18] || (I[18] = (F) => Q("particleShape", F.target.value))
            }, [...I[105] || (I[105] = [
              f("option", { value: "circle" }, "Circle", -1),
              f("option", { value: "square" }, "Square", -1),
              f("option", { value: "triangle" }, "Triangle", -1),
              f("option", { value: "star" }, "Star", -1)
            ])], 40, TI)
          ]),
          f("div", EI, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.renderTrails,
                onChange: I[19] || (I[19] = (F) => Q("renderTrails", F.target.checked))
              }, null, 40, AI),
              I[107] || (I[107] = ct(" Render Trails ", -1))
            ])
          ]),
          p.value.renderTrails ? (te(), ae("div", PI, [
            I[108] || (I[108] = f("label", null, "Trail Length", -1)),
            f("input", {
              type: "range",
              value: p.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: I[20] || (I[20] = (F) => Q("trailLength", Number(F.target.value)))
            }, null, 40, RI),
            f("span", DI, _e(p.value.trailLength), 1)
          ])) : Pe("", !0),
          f("div", kI, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.glowEnabled,
                onChange: I[21] || (I[21] = (F) => Q("glowEnabled", F.target.checked))
              }, null, 40, II),
              I[109] || (I[109] = ct(" Enable Glow ", -1))
            ])
          ]),
          p.value.glowEnabled ? (te(), ae("div", LI, [
            I[110] || (I[110] = f("label", null, "Glow Radius", -1)),
            f("input", {
              type: "range",
              value: p.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: I[22] || (I[22] = (F) => Q("glowRadius", Number(F.target.value)))
            }, null, 40, FI),
            f("span", UI, _e(p.value.glowRadius) + "px", 1)
          ])) : Pe("", !0),
          p.value.glowEnabled ? (te(), ae("div", OI, [
            I[111] || (I[111] = f("label", null, "Glow Intensity", -1)),
            f("input", {
              type: "range",
              value: p.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: I[23] || (I[23] = (F) => Q("glowIntensity", Number(F.target.value)))
            }, null, 40, zI),
            f("span", NI, _e(p.value.glowIntensity.toFixed(2)), 1)
          ])) : Pe("", !0),
          I[118] || (I[118] = f("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          f("div", BI, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: g.value.enabled,
                onChange: I[24] || (I[24] = (F) => le("enabled", F.target.checked))
              }, null, 40, VI),
              I[112] || (I[112] = ct(" Enable Connections ", -1))
            ])
          ]),
          g.value.enabled ? (te(), ae("div", GI, [
            I[113] || (I[113] = f("label", null, "Max Distance", -1)),
            f("input", {
              type: "range",
              value: g.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: I[25] || (I[25] = (F) => le("maxDistance", Number(F.target.value)))
            }, null, 40, HI),
            f("span", $I, _e(g.value.maxDistance) + "px", 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", WI, [
            I[114] || (I[114] = f("label", null, "Max Connections", -1)),
            f("input", {
              type: "range",
              value: g.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: I[26] || (I[26] = (F) => le("maxConnections", Number(F.target.value)))
            }, null, 40, XI),
            f("span", jI, _e(g.value.maxConnections), 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", YI, [
            I[115] || (I[115] = f("label", null, "Line Width", -1)),
            f("input", {
              type: "range",
              value: g.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: I[27] || (I[27] = (F) => le("lineWidth", Number(F.target.value)))
            }, null, 40, qI),
            f("span", ZI, _e(g.value.lineWidth.toFixed(1)), 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", KI, [
            I[116] || (I[116] = f("label", null, "Line Opacity", -1)),
            f("input", {
              type: "range",
              value: g.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: I[28] || (I[28] = (F) => le("lineOpacity", Number(F.target.value)))
            }, null, 40, JI),
            f("span", QI, _e(g.value.lineOpacity.toFixed(2)), 1)
          ])) : Pe("", !0),
          g.value.enabled ? (te(), ae("div", eL, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: g.value.fadeByDistance,
                onChange: I[29] || (I[29] = (F) => le("fadeByDistance", F.target.checked))
              }, null, 40, tL),
              I[117] || (I[117] = ct(" Fade by Distance ", -1))
            ])
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", nL, [
        I[119] || (I[119] = f("i", { class: "pi pi-circle-fill" }, null, -1)),
        f("span", null, _e(x.value) + " particles", 1)
      ])
    ]));
  }
}), sL = /* @__PURE__ */ Gt(iL, [["__scopeId", "data-v-60b9bdc8"]]), rL = ["title"], oL = /* @__PURE__ */ Ot({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.property.animated ? n.property.keyframes.some((m) => m.frame === r.currentFrame) : !1), a = Ie(() => n.property.animated && n.property.keyframes.find((m) => m.frame === r.currentFrame) || null), l = Ie(() => o.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), c = Ie(() => o.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function u() {
      o.value ? h() : d();
    }
    function d() {
      const m = { frame: 0, value: 0, enabled: !1 }, p = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: r.currentFrame,
        value: n.property.value,
        interpolation: "linear",
        inHandle: { ...m },
        outHandle: { ...m },
        controlMode: "smooth"
      };
      n.property.animated || (n.property.animated = !0, i("animationToggled", !0)), n.property.keyframes.push(p), n.property.keyframes.sort((v, _) => v.frame - _.frame), i("keyframeAdded", p);
    }
    function h() {
      const m = a.value;
      if (!m) return;
      const p = n.property.keyframes.findIndex((v) => v.id === m.id);
      p >= 0 && (n.property.keyframes.splice(p, 1), i("keyframeRemoved", m.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, i("animationToggled", !1));
    }
    return (m, p) => (te(), ae("button", {
      class: Fe(["keyframe-toggle", {
        animated: s.property.animated,
        "has-keyframe": o.value
      }]),
      onClick: u,
      title: c.value
    }, [
      f("i", {
        class: Fe(["pi", l.value])
      }, null, 2)
    ], 10, rL));
  }
}), Ur = /* @__PURE__ */ Gt(oL, [["__scopeId", "data-v-b9271c8f"]]), aL = { class: "depthflow-properties" }, lL = { class: "property-section" }, cL = {
  key: 0,
  class: "section-content"
}, uL = { class: "property-row" }, dL = ["value"], hL = ["value"], fL = { class: "property-row" }, pL = ["value"], mL = ["value"], vL = { class: "property-section" }, gL = {
  key: 0,
  class: "section-content"
}, yL = { class: "preset-grid" }, xL = ["onClick"], _L = {
  key: 0,
  class: "property-row"
}, bL = ["value"], wL = { class: "value-display" }, SL = { class: "property-section" }, ML = {
  key: 0,
  class: "section-content"
}, CL = { class: "property-row" }, TL = ["value"], EL = { class: "value-display" }, AL = { class: "property-row" }, PL = ["value"], RL = { class: "value-display" }, DL = { class: "property-row" }, kL = ["value"], IL = { class: "value-display" }, LL = { class: "property-row" }, FL = ["value"], UL = { class: "value-display" }, OL = { class: "property-section" }, zL = {
  key: 0,
  class: "section-content"
}, NL = { class: "property-row" }, BL = ["value"], VL = { class: "value-display" }, GL = { class: "property-row" }, HL = ["value"], $L = { class: "value-display" }, WL = {
  key: 0,
  class: "property-section"
}, XL = {
  key: 0,
  class: "section-content"
}, jL = { class: "property-row" }, YL = ["value"], qL = { class: "value-display" }, ZL = { class: "property-row" }, KL = ["value"], JL = { class: "value-display" }, QL = { class: "property-row" }, e5 = ["value"], t5 = { class: "value-display" }, n5 = { class: "property-row" }, i5 = ["value"], s5 = { class: "value-display" }, r5 = {
  key: 2,
  class: "property-row"
}, o5 = ["value"], a5 = { class: "value-display" }, l5 = { class: "property-section" }, c5 = {
  key: 0,
  class: "section-content"
}, u5 = { class: "property-row" }, d5 = ["value"], h5 = { class: "value-display" }, f5 = { class: "property-row checkbox-row" }, p5 = ["checked"], m5 = { class: "property-section" }, v5 = {
  key: 0,
  class: "section-content"
}, g5 = { class: "preview-container" }, y5 = { class: "preview-controls" }, x5 = { class: "frame-indicator" }, Ji = 200, _5 = /* @__PURE__ */ Ot({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we(null), a = we(!1), l = we(0), c = we(null), u = we(/* @__PURE__ */ new Set(["source", "preset", "camera"])), d = we(1), h = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], m = Ie(() => n.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), p = Ie(() => m.value.config), v = Ie(() => r.frameCount), _ = Ie(
      () => r.layers.filter((O) => O.type === "image" || O.type === "generated")
    ), g = Ie(
      () => r.layers.filter((O) => O.type === "depth" || O.type === "generated")
    ), x = Ie(
      () => ["circle_cw", "circle_ccw"].includes(p.value.preset)
    ), M = Ie(
      () => ["horizontal_swing", "vertical_swing"].includes(p.value.preset)
    ), S = Ie(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(p.value.preset)
    ), b = Ie(
      () => x.value || M.value || S.value
    ), C = Ie(() => x.value ? "Orbit Settings" : M.value ? "Swing Settings" : S.value ? "Dolly Zoom Settings" : "Preset Settings");
    function T(O) {
      u.value.has(O) ? u.value.delete(O) : u.value.add(O);
    }
    function P(O, A) {
      i("update", { [O]: A });
    }
    function E(O, A) {
      i("update", {
        config: { ...p.value, [O]: A }
      });
    }
    function y(O) {
      E("preset", O);
    }
    function w(O) {
      d.value = O, x.value ? E("orbitRadius", 0.1 * O) : M.value ? E("swingAmplitude", 0.1 * O) : E("depthScale", 1 * O);
    }
    function D() {
      a.value = !a.value, a.value ? U() : c.value !== null && (cancelAnimationFrame(c.value), c.value = null);
    }
    function U() {
      a.value && (l.value = (l.value + 1) % v.value, R(), c.value = requestAnimationFrame(() => {
        setTimeout(U, 1e3 / r.fps);
      }));
    }
    function R() {
      const O = o.value;
      if (!O) return;
      const A = O.getContext("2d");
      A && (A.fillStyle = "#1e1e1e", A.fillRect(0, 0, Ji, Ji), A.fillStyle = "#333", A.fillRect(10, 10, Ji - 20, Ji - 20), A.fillStyle = "#666", A.font = "12px sans-serif", A.textAlign = "center", A.fillText("Depthflow Preview", Ji / 2, Ji / 2), A.fillText(`Frame ${l.value}`, Ji / 2, Ji / 2 + 16));
    }
    return xn(() => {
      R();
    }), Nn(() => {
      c.value !== null && cancelAnimationFrame(c.value);
    }), (O, A) => (te(), ae("div", aL, [
      f("div", lL, [
        f("div", {
          class: "section-header",
          onClick: A[0] || (A[0] = (G) => T("source"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[23] || (A[23] = f("span", null, "Source Selection", -1))
        ]),
        u.value.has("source") ? (te(), ae("div", cL, [
          f("div", uL, [
            A[25] || (A[25] = f("label", null, "Source Layer", -1)),
            f("select", {
              value: m.value.sourceLayerId,
              onChange: A[1] || (A[1] = (G) => P("sourceLayerId", G.target.value))
            }, [
              A[24] || (A[24] = f("option", { value: "" }, "Select source...", -1)),
              (te(!0), ae(qe, null, ot(_.value, (G) => (te(), ae("option", {
                key: G.id,
                value: G.id
              }, _e(G.name), 9, hL))), 128))
            ], 40, dL)
          ]),
          f("div", fL, [
            A[27] || (A[27] = f("label", null, "Depth Layer", -1)),
            f("select", {
              value: m.value.depthLayerId,
              onChange: A[2] || (A[2] = (G) => P("depthLayerId", G.target.value))
            }, [
              A[26] || (A[26] = f("option", { value: "" }, "Select depth map...", -1)),
              (te(!0), ae(qe, null, ot(g.value, (G) => (te(), ae("option", {
                key: G.id,
                value: G.id
              }, _e(G.name), 9, mL))), 128))
            ], 40, pL)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", vL, [
        f("div", {
          class: "section-header",
          onClick: A[3] || (A[3] = (G) => T("preset"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[28] || (A[28] = f("span", null, "Motion Preset", -1))
        ]),
        u.value.has("preset") ? (te(), ae("div", gL, [
          f("div", yL, [
            (te(), ae(qe, null, ot(h, (G) => f("button", {
              key: G.value,
              class: Fe(["preset-btn", { active: p.value.preset === G.value }]),
              onClick: (ue) => y(G.value)
            }, [
              f("i", {
                class: Fe(G.icon)
              }, null, 2),
              f("span", null, _e(G.label), 1)
            ], 10, xL)), 64))
          ]),
          p.value.preset !== "static" ? (te(), ae("div", _L, [
            A[29] || (A[29] = f("label", null, "Intensity", -1)),
            f("input", {
              type: "range",
              value: d.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: A[4] || (A[4] = (G) => w(Number(G.target.value)))
            }, null, 40, bL),
            f("span", wL, _e(d.value.toFixed(1)) + "x", 1)
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", SL, [
        f("div", {
          class: "section-header",
          onClick: A[5] || (A[5] = (G) => T("camera"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[30] || (A[30] = f("span", null, "Camera Controls", -1))
        ]),
        u.value.has("camera") ? (te(), ae("div", ML, [
          f("div", CL, [
            A[31] || (A[31] = f("label", null, "Zoom", -1)),
            m.value.animatedZoom ? (te(), St(Ur, {
              key: 0,
              property: m.value.animatedZoom,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: A[6] || (A[6] = (G) => E("zoom", Number(G.target.value)))
            }, null, 40, TL),
            f("span", EL, _e(p.value.zoom.toFixed(2)), 1)
          ]),
          f("div", AL, [
            A[32] || (A[32] = f("label", null, "Offset X", -1)),
            m.value.animatedOffsetX ? (te(), St(Ur, {
              key: 0,
              property: m.value.animatedOffsetX,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: A[7] || (A[7] = (G) => E("offsetX", Number(G.target.value)))
            }, null, 40, PL),
            f("span", RL, _e(p.value.offsetX.toFixed(2)), 1)
          ]),
          f("div", DL, [
            A[33] || (A[33] = f("label", null, "Offset Y", -1)),
            m.value.animatedOffsetY ? (te(), St(Ur, {
              key: 0,
              property: m.value.animatedOffsetY,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: A[8] || (A[8] = (G) => E("offsetY", Number(G.target.value)))
            }, null, 40, kL),
            f("span", IL, _e(p.value.offsetY.toFixed(2)), 1)
          ]),
          f("div", LL, [
            A[34] || (A[34] = f("label", null, "Rotation", -1)),
            m.value.animatedRotation ? (te(), St(Ur, {
              key: 0,
              property: m.value.animatedRotation,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: A[9] || (A[9] = (G) => E("rotation", Number(G.target.value)))
            }, null, 40, FL),
            f("span", UL, _e(p.value.rotation) + "", 1)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", OL, [
        f("div", {
          class: "section-header",
          onClick: A[10] || (A[10] = (G) => T("depth"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[35] || (A[35] = f("span", null, "Depth Settings", -1))
        ]),
        u.value.has("depth") ? (te(), ae("div", zL, [
          f("div", NL, [
            A[36] || (A[36] = f("label", null, "Depth Scale", -1)),
            m.value.animatedDepthScale ? (te(), St(Ur, {
              key: 0,
              property: m.value.animatedDepthScale,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: A[11] || (A[11] = (G) => E("depthScale", Number(G.target.value)))
            }, null, 40, BL),
            f("span", VL, _e(p.value.depthScale.toFixed(2)), 1)
          ]),
          f("div", GL, [
            A[37] || (A[37] = f("label", null, "Focus Depth", -1)),
            f("input", {
              type: "range",
              value: p.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: A[12] || (A[12] = (G) => E("focusDepth", Number(G.target.value)))
            }, null, 40, HL),
            f("span", $L, _e(p.value.focusDepth.toFixed(2)), 1)
          ]),
          A[38] || (A[38] = f("div", { class: "depth-hint" }, [
            ct(" Objects at focus depth stay stationary."),
            f("br"),
            ct(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : Pe("", !0)
      ]),
      b.value ? (te(), ae("div", WL, [
        f("div", {
          class: "section-header",
          onClick: A[13] || (A[13] = (G) => T("presetSettings"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          f("span", null, _e(C.value), 1)
        ]),
        u.value.has("presetSettings") ? (te(), ae("div", XL, [
          x.value ? (te(), ae(qe, { key: 0 }, [
            f("div", jL, [
              A[39] || (A[39] = f("label", null, "Orbit Radius", -1)),
              f("input", {
                type: "range",
                value: p.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: A[14] || (A[14] = (G) => E("orbitRadius", Number(G.target.value)))
              }, null, 40, YL),
              f("span", qL, _e(p.value.orbitRadius.toFixed(2)), 1)
            ]),
            f("div", ZL, [
              A[40] || (A[40] = f("label", null, "Orbit Speed", -1)),
              f("input", {
                type: "range",
                value: p.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: A[15] || (A[15] = (G) => E("orbitSpeed", Number(G.target.value)))
              }, null, 40, KL),
              f("span", JL, _e(p.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : Pe("", !0),
          M.value ? (te(), ae(qe, { key: 1 }, [
            f("div", QL, [
              A[41] || (A[41] = f("label", null, "Amplitude", -1)),
              f("input", {
                type: "range",
                value: p.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: A[16] || (A[16] = (G) => E("swingAmplitude", Number(G.target.value)))
              }, null, 40, e5),
              f("span", t5, _e(p.value.swingAmplitude.toFixed(2)), 1)
            ]),
            f("div", n5, [
              A[42] || (A[42] = f("label", null, "Frequency", -1)),
              f("input", {
                type: "range",
                value: p.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: A[17] || (A[17] = (G) => E("swingFrequency", Number(G.target.value)))
              }, null, 40, i5),
              f("span", s5, _e(p.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : Pe("", !0),
          S.value ? (te(), ae("div", r5, [
            A[43] || (A[43] = f("label", null, "Dolly Rate", -1)),
            f("input", {
              type: "range",
              value: p.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: A[18] || (A[18] = (G) => E("dollyZoom", Number(G.target.value)))
            }, null, 40, o5),
            f("span", a5, _e(p.value.dollyZoom.toFixed(2)), 1)
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ])) : Pe("", !0),
      f("div", l5, [
        f("div", {
          class: "section-header",
          onClick: A[19] || (A[19] = (G) => T("quality"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[44] || (A[44] = f("span", null, "Quality", -1))
        ]),
        u.value.has("quality") ? (te(), ae("div", c5, [
          f("div", u5, [
            A[45] || (A[45] = f("label", null, "Edge Dilation", -1)),
            f("input", {
              type: "range",
              value: p.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: A[20] || (A[20] = (G) => E("edgeDilation", Number(G.target.value)))
            }, null, 40, d5),
            f("span", h5, _e(p.value.edgeDilation) + "px", 1)
          ]),
          f("div", f5, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.inpaintEdges,
                onChange: A[21] || (A[21] = (G) => E("inpaintEdges", G.target.checked))
              }, null, 40, p5),
              A[46] || (A[46] = ct(" Inpaint Edges ", -1))
            ])
          ])
        ])) : Pe("", !0)
      ]),
      f("div", m5, [
        f("div", {
          class: "section-header",
          onClick: A[22] || (A[22] = (G) => T("preview"))
        }, [
          f("i", {
            class: Fe(["pi", u.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[47] || (A[47] = f("span", null, "Preview", -1))
        ]),
        u.value.has("preview") ? (te(), ae("div", v5, [
          f("div", g5, [
            f("canvas", {
              ref_key: "previewCanvas",
              ref: o,
              class: "preview-canvas",
              width: Ji,
              height: Ji
            }, null, 512)
          ]),
          f("div", y5, [
            f("button", {
              class: Fe(["preview-btn", { active: a.value }]),
              onClick: D
            }, [
              f("i", {
                class: Fe(a.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              ct(" " + _e(a.value ? "Pause" : "Play"), 1)
            ], 2),
            f("span", x5, " Frame " + _e(l.value) + " / " + _e(v.value - 1), 1)
          ])
        ])) : Pe("", !0)
      ])
    ]));
  }
}), b5 = /* @__PURE__ */ Gt(_5, [["__scopeId", "data-v-ffaf4c8a"]]), w5 = { class: "light-properties" }, S5 = { class: "property-section" }, M5 = { class: "section-content" }, C5 = { class: "property-row" }, T5 = ["value"], E5 = { class: "property-group" }, A5 = { class: "property-group" }, P5 = { class: "control-row" }, R5 = { class: "property-group" }, D5 = { class: "control-row" }, k5 = { class: "property-group" }, I5 = {
  key: 1,
  class: "property-row"
}, L5 = ["value"], F5 = {
  key: 2,
  class: "property-group"
}, U5 = {
  key: 3,
  class: "property-group"
}, O5 = { class: "property-group checkbox-row" }, z5 = ["checked"], N5 = { class: "property-group" }, B5 = { class: "property-group" }, V5 = {
  key: 5,
  class: "note"
}, G5 = /* @__PURE__ */ Ot({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.layer.data || {
      lightType: "spot",
      color: "#ffffff",
      intensity: 100,
      radius: 500,
      falloff: "none",
      falloffDistance: 500,
      castShadows: !1,
      shadowDarkness: 100,
      shadowDiffusion: 0,
      coneAngle: 90,
      coneFeather: 50
    });
    function a(l, c) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [l]: c }
      }), i("update");
    }
    return (l, c) => (te(), ae("div", w5, [
      f("div", S5, [
        c[25] || (c[25] = f("div", { class: "section-header" }, "Light Settings", -1)),
        f("div", M5, [
          f("div", C5, [
            c[13] || (c[13] = f("label", null, "Type", -1)),
            f("select", {
              value: o.value.lightType,
              onChange: c[0] || (c[0] = (u) => a("lightType", u.target.value)),
              class: "type-select"
            }, [...c[12] || (c[12] = [
              f("option", { value: "parallel" }, "Parallel", -1),
              f("option", { value: "spot" }, "Spot", -1),
              f("option", { value: "point" }, "Point", -1),
              f("option", { value: "ambient" }, "Ambient", -1)
            ])], 40, T5)
          ]),
          f("div", E5, [
            c[14] || (c[14] = f("label", null, "Color", -1)),
            ze(Ve(uu), {
              modelValue: o.value.color,
              "onUpdate:modelValue": c[1] || (c[1] = (u) => a("color", u))
            }, null, 8, ["modelValue"])
          ]),
          f("div", A5, [
            c[15] || (c[15] = f("label", null, "Intensity", -1)),
            f("div", P5, [
              ze(Ve(jn), {
                modelValue: o.value.intensity,
                "onUpdate:modelValue": c[2] || (c[2] = (u) => a("intensity", u)),
                min: 0,
                max: 500,
                step: 1,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ]),
          o.value.lightType === "spot" ? (te(), ae(qe, { key: 0 }, [
            f("div", R5, [
              c[16] || (c[16] = f("label", null, "Cone Angle", -1)),
              f("div", D5, [
                ze(Ve(Jf), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[3] || (c[3] = (u) => a("coneAngle", u)),
                  size: 32
                }, null, 8, ["modelValue"]),
                ze(Ve(et), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[4] || (c[4] = (u) => a("coneAngle", u)),
                  unit: ""
                }, null, 8, ["modelValue"])
              ])
            ]),
            f("div", k5, [
              c[17] || (c[17] = f("label", null, "Cone Feather", -1)),
              ze(Ve(jn), {
                modelValue: o.value.coneFeather ?? 50,
                "onUpdate:modelValue": c[5] || (c[5] = (u) => a("coneFeather", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Pe("", !0),
          o.value.lightType !== "ambient" ? (te(), ae("div", I5, [
            c[19] || (c[19] = f("label", null, "Falloff", -1)),
            f("select", {
              value: o.value.falloff,
              onChange: c[6] || (c[6] = (u) => a("falloff", u.target.value)),
              class: "type-select"
            }, [...c[18] || (c[18] = [
              f("option", { value: "none" }, "None", -1),
              f("option", { value: "smooth" }, "Smooth", -1),
              f("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
            ])], 40, L5)
          ])) : Pe("", !0),
          o.value.lightType !== "ambient" && o.value.lightType !== "parallel" ? (te(), ae("div", F5, [
            c[20] || (c[20] = f("label", null, "Radius", -1)),
            ze(Ve(et), {
              modelValue: o.value.radius,
              "onUpdate:modelValue": c[7] || (c[7] = (u) => a("radius", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Pe("", !0),
          o.value.lightType !== "ambient" ? (te(), ae("div", U5, [
            c[21] || (c[21] = f("label", null, "Falloff Distance", -1)),
            ze(Ve(et), {
              modelValue: o.value.falloffDistance ?? 500,
              "onUpdate:modelValue": c[8] || (c[8] = (u) => a("falloffDistance", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Pe("", !0),
          f("div", O5, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: o.value.castShadows,
                onChange: c[9] || (c[9] = (u) => a("castShadows", u.target.checked))
              }, null, 40, z5),
              c[22] || (c[22] = ct(" Casts Shadows ", -1))
            ])
          ]),
          o.value.castShadows ? (te(), ae(qe, { key: 4 }, [
            f("div", N5, [
              c[23] || (c[23] = f("label", null, "Shadow Darkness", -1)),
              ze(Ve(jn), {
                modelValue: o.value.shadowDarkness ?? 100,
                "onUpdate:modelValue": c[10] || (c[10] = (u) => a("shadowDarkness", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            f("div", B5, [
              c[24] || (c[24] = f("label", null, "Shadow Diffusion", -1)),
              ze(Ve(et), {
                modelValue: o.value.shadowDiffusion ?? 0,
                "onUpdate:modelValue": c[11] || (c[11] = (u) => a("shadowDiffusion", u)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Pe("", !0),
          o.value.castShadows ? (te(), ae("div", V5, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : Pe("", !0)
        ])
      ])
    ]));
  }
}), H5 = /* @__PURE__ */ Gt(G5, [["__scopeId", "data-v-7bf0f1bf"]]), $5 = { class: "shape-properties" }, W5 = { class: "property-section" }, X5 = { class: "section-content" }, j5 = { class: "property-group" }, Y5 = { class: "group-header" }, q5 = ["checked"], Z5 = {
  key: 0,
  class: "control-row"
}, K5 = { class: "property-group" }, J5 = { class: "group-header" }, Q5 = ["checked"], e4 = {
  key: 0,
  class: "stroke-controls"
}, t4 = { class: "control-row" }, n4 = { class: "property-row" }, i4 = { class: "property-row" }, s4 = { class: "icon-toggle-group" }, r4 = { class: "property-group" }, o4 = { class: "control-row checkbox-row" }, a4 = ["checked"], l4 = /* @__PURE__ */ Ot({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.layer.data || {
      pathData: "",
      controlPoints: [],
      closed: !1,
      stroke: "#ffffff",
      strokeWidth: 2,
      fill: ""
    }), a = Ie(() => !!o.value.fill && o.value.fill !== "transparent"), l = Ie(() => !!o.value.stroke && o.value.strokeWidth > 0), c = Ie(() => o.value.strokeLineCap || "round");
    function u(m, p) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [m]: p }
      }), i("update");
    }
    function d(m) {
      const p = m.target.checked;
      u("fill", p ? "#ffffff" : "");
    }
    function h(m) {
      m.target.checked ? (u("stroke", "#ffffff"), u("strokeWidth", 2)) : u("strokeWidth", 0);
    }
    return (m, p) => (te(), ae("div", $5, [
      f("div", W5, [
        p[13] || (p[13] = f("div", { class: "section-header" }, "Shape Appearance", -1)),
        f("div", X5, [
          f("div", j5, [
            f("div", Y5, [
              p[7] || (p[7] = f("label", null, "Fill", -1)),
              f("input", {
                type: "checkbox",
                checked: a.value,
                onChange: d
              }, null, 40, q5)
            ]),
            a.value ? (te(), ae("div", Z5, [
              ze(Ve(uu), {
                modelValue: o.value.fill || "#ffffff",
                "onUpdate:modelValue": p[0] || (p[0] = (v) => u("fill", v)),
                alpha: !0
              }, null, 8, ["modelValue"])
            ])) : Pe("", !0)
          ]),
          f("div", K5, [
            f("div", J5, [
              p[8] || (p[8] = f("label", null, "Stroke", -1)),
              f("input", {
                type: "checkbox",
                checked: l.value,
                onChange: h
              }, null, 40, Q5)
            ]),
            l.value ? (te(), ae("div", e4, [
              f("div", t4, [
                ze(Ve(uu), {
                  modelValue: o.value.stroke || "#ffffff",
                  "onUpdate:modelValue": p[1] || (p[1] = (v) => u("stroke", v)),
                  alpha: !0
                }, null, 8, ["modelValue"])
              ]),
              f("div", n4, [
                p[9] || (p[9] = f("label", { class: "sub-label" }, "Width", -1)),
                ze(Ve(et), {
                  modelValue: o.value.strokeWidth || 0,
                  "onUpdate:modelValue": p[2] || (p[2] = (v) => u("strokeWidth", v)),
                  min: 0,
                  max: 500,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              f("div", i4, [
                p[10] || (p[10] = f("label", { class: "sub-label" }, "Cap", -1)),
                f("div", s4, [
                  f("button", {
                    class: Fe({ active: c.value === "butt" }),
                    onClick: p[3] || (p[3] = (v) => u("strokeLineCap", "butt")),
                    title: "Butt Cap"
                  }, "I", 2),
                  f("button", {
                    class: Fe({ active: c.value === "round" }),
                    onClick: p[4] || (p[4] = (v) => u("strokeLineCap", "round")),
                    title: "Round Cap"
                  }, "C", 2),
                  f("button", {
                    class: Fe({ active: c.value === "square" }),
                    onClick: p[5] || (p[5] = (v) => u("strokeLineCap", "square")),
                    title: "Square Cap"
                  }, "H", 2)
                ])
              ])
            ])) : Pe("", !0)
          ]),
          f("div", r4, [
            p[12] || (p[12] = f("label", null, "Path", -1)),
            f("div", o4, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.closed,
                  onChange: p[6] || (p[6] = (v) => u("closed", v.target.checked))
                }, null, 40, a4),
                p[11] || (p[11] = ct(" Closed Path ", -1))
              ])
            ])
          ])
        ])
      ])
    ]));
  }
}), c4 = /* @__PURE__ */ Gt(l4, [["__scopeId", "data-v-e2af8c92"]]), u4 = { class: "video-properties" }, d4 = {
  key: 0,
  class: "property-section"
}, h4 = { class: "section-content info-grid" }, f4 = { class: "info-row" }, p4 = { class: "info-value" }, m4 = { class: "info-row" }, v4 = { class: "info-value" }, g4 = { class: "info-row" }, y4 = { class: "info-value" }, x4 = { class: "info-row" }, _4 = { class: "info-value" }, b4 = { class: "property-section" }, w4 = { class: "section-content" }, S4 = { class: "property-row" }, M4 = { class: "property-row" }, C4 = { class: "property-row" }, T4 = { class: "checkbox-group" }, E4 = { class: "checkbox-row" }, A4 = ["checked"], P4 = { class: "checkbox-row" }, R4 = ["checked"], D4 = { class: "property-section" }, k4 = { class: "section-header" }, I4 = { class: "header-toggle" }, L4 = ["checked"], F4 = {
  key: 0,
  class: "section-content"
}, U4 = { class: "property-row" }, O4 = { class: "control-with-keyframe" }, z4 = { class: "property-section" }, N4 = { class: "section-content" }, B4 = { class: "property-row" }, V4 = ["value"], G4 = {
  key: 1,
  class: "property-section"
}, H4 = { class: "section-content" }, $4 = { class: "checkbox-group" }, W4 = { class: "checkbox-row" }, X4 = ["checked"], j4 = {
  key: 0,
  class: "property-row"
}, Y4 = { class: "control-with-keyframe" }, q4 = {
  key: 1,
  class: "property-row"
}, Z4 = {
  key: 2,
  class: "waveform-container"
}, K4 = /* @__PURE__ */ Ot({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = Ie(() => n.layer.data || {
      assetId: null,
      loop: !1,
      pingPong: !1,
      startTime: 0,
      endTime: void 0,
      speed: 1,
      timeRemapEnabled: !1,
      timeRemap: void 0,
      frameBlending: "none",
      audioEnabled: !0,
      audioLevel: 100,
      posterFrame: 0
    }), a = Ie(() => {
      const C = o.value.assetId;
      return C && r.assets[C] || null;
    }), l = Ie(() => {
      var C;
      return (C = n.layer.audio) == null ? void 0 : C.level;
    }), c = Ie(() => o.value.timeRemap ? o.value.timeRemap.value : 0);
    function u(C) {
      var y;
      if (!C) return "0:00";
      const T = Math.floor(C / 60), P = Math.floor(C % 60), E = Math.floor(C % 1 * (((y = a.value) == null ? void 0 : y.fps) || 30));
      return `${T}:${P.toString().padStart(2, "0")}:${E.toString().padStart(2, "0")}`;
    }
    function d(C) {
      r.updateVideoLayerData(n.layer.id, { speed: C }), i("update");
    }
    function h(C) {
      r.updateVideoLayerData(n.layer.id, { startTime: C }), i("update");
    }
    function m(C) {
      r.updateVideoLayerData(n.layer.id, { endTime: C }), i("update");
    }
    function p(C) {
      const T = C.target;
      r.updateVideoLayerData(n.layer.id, { loop: T.checked }), i("update");
    }
    function v(C) {
      const T = C.target;
      r.updateVideoLayerData(n.layer.id, { pingPong: T.checked }), i("update");
    }
    function _(C) {
      const T = C.target;
      r.updateVideoLayerData(n.layer.id, { timeRemapEnabled: T.checked }), i("update");
    }
    function g(C) {
      const T = n.layer.data;
      T.timeRemap && (T.timeRemap.value = C), i("update");
    }
    function x(C) {
      const T = C.target;
      r.updateVideoLayerData(n.layer.id, { frameBlending: T.value }), i("update");
    }
    function M(C) {
      const T = C.target;
      r.updateVideoLayerData(n.layer.id, { audioEnabled: T.checked }), i("update");
    }
    function S(C) {
      r.updateVideoLayerData(n.layer.id, { audioLevel: C }), i("update");
    }
    function b(C) {
      var T;
      (T = n.layer.audio) != null && T.level && (n.layer.audio.level.value = C, i("update"));
    }
    return (C, T) => {
      var P, E, y;
      return te(), ae("div", u4, [
        a.value ? (te(), ae("div", d4, [
          T[4] || (T[4] = f("div", { class: "section-header" }, "Video Info", -1)),
          f("div", h4, [
            f("div", f4, [
              T[0] || (T[0] = f("span", { class: "info-label" }, "Dimensions", -1)),
              f("span", p4, _e(a.value.width) + "  " + _e(a.value.height), 1)
            ]),
            f("div", m4, [
              T[1] || (T[1] = f("span", { class: "info-label" }, "Duration", -1)),
              f("span", v4, _e(u(a.value.duration)), 1)
            ]),
            f("div", g4, [
              T[2] || (T[2] = f("span", { class: "info-label" }, "Frame Rate", -1)),
              f("span", y4, _e(((P = a.value.fps) == null ? void 0 : P.toFixed(2)) || "?") + " fps", 1)
            ]),
            f("div", x4, [
              T[3] || (T[3] = f("span", { class: "info-label" }, "Has Audio", -1)),
              f("span", _4, _e(a.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : Pe("", !0),
        f("div", b4, [
          T[10] || (T[10] = f("div", { class: "section-header" }, "Playback", -1)),
          f("div", w4, [
            f("div", S4, [
              T[5] || (T[5] = f("label", null, "Speed", -1)),
              ze(Ve(et), {
                modelValue: o.value.speed,
                "onUpdate:modelValue": d,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            f("div", M4, [
              T[6] || (T[6] = f("label", null, "Start Time", -1)),
              ze(Ve(et), {
                modelValue: o.value.startTime,
                "onUpdate:modelValue": h,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            f("div", C4, [
              T[7] || (T[7] = f("label", null, "End Time", -1)),
              ze(Ve(et), {
                modelValue: o.value.endTime || ((E = a.value) == null ? void 0 : E.duration) || 0,
                "onUpdate:modelValue": m,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            f("div", T4, [
              f("label", E4, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.loop,
                  onChange: p
                }, null, 40, A4),
                T[8] || (T[8] = f("span", null, "Loop", -1))
              ]),
              f("label", P4, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.pingPong,
                  onChange: v
                }, null, 40, R4),
                T[9] || (T[9] = f("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        f("div", D4, [
          f("div", k4, [
            T[11] || (T[11] = f("span", null, "Time Remap", -1)),
            f("label", I4, [
              f("input", {
                type: "checkbox",
                checked: o.value.timeRemapEnabled,
                onChange: _
              }, null, 40, L4)
            ])
          ]),
          o.value.timeRemapEnabled ? (te(), ae("div", F4, [
            f("div", U4, [
              T[12] || (T[12] = f("label", null, "Remap Time", -1)),
              f("div", O4, [
                ze(Ve(et), {
                  modelValue: c.value,
                  "onUpdate:modelValue": g,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                o.value.timeRemap ? (te(), St(Ur, {
                  key: 0,
                  property: o.value.timeRemap,
                  layerId: s.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : Pe("", !0)
              ])
            ]),
            T[13] || (T[13] = f("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : Pe("", !0)
        ]),
        f("div", z4, [
          T[16] || (T[16] = f("div", { class: "section-header" }, "Frame Blending", -1)),
          f("div", N4, [
            f("div", B4, [
              T[15] || (T[15] = f("label", null, "Mode", -1)),
              f("select", {
                value: o.value.frameBlending,
                onChange: x,
                class: "select-input"
              }, [...T[14] || (T[14] = [
                f("option", { value: "none" }, "None", -1),
                f("option", { value: "frame-mix" }, "Frame Mix", -1),
                f("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, V4)
            ])
          ])
        ]),
        ((y = a.value) == null ? void 0 : y.hasAudio) !== !1 ? (te(), ae("div", G4, [
          T[21] || (T[21] = f("div", { class: "section-header" }, "Audio", -1)),
          f("div", H4, [
            f("div", $4, [
              f("label", W4, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.audioEnabled,
                  onChange: M
                }, null, 40, X4),
                T[17] || (T[17] = f("span", null, "Audio Enabled", -1))
              ])
            ]),
            o.value.audioEnabled ? (te(), ae("div", j4, [
              T[18] || (T[18] = f("label", null, "Level", -1)),
              f("div", Y4, [
                l.value ? (te(), St(Ve(et), {
                  key: 0,
                  modelValue: l.value.value,
                  "onUpdate:modelValue": b,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : Pe("", !0),
                l.value ? (te(), St(Ur, {
                  key: 1,
                  property: l.value,
                  layerId: s.layer.id
                }, null, 8, ["property", "layerId"])) : Pe("", !0)
              ])
            ])) : Pe("", !0),
            o.value.audioEnabled ? (te(), ae("div", q4, [
              T[19] || (T[19] = f("label", null, "Volume", -1)),
              ze(Ve(et), {
                modelValue: o.value.audioLevel,
                "onUpdate:modelValue": S,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : Pe("", !0),
            o.value.audioEnabled ? (te(), ae("div", Z4, [...T[20] || (T[20] = [
              f("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : Pe("", !0)
          ])
        ])) : Pe("", !0)
      ]);
    };
  }
}), J4 = /* @__PURE__ */ Gt(K4, [["__scopeId", "data-v-5f46759a"]]), Q4 = ["title"], eF = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
}, tF = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, nF = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, iF = ["x1", "y1", "x2", "y2"], sF = ["cx", "cy"], rF = { class: "drop-label" }, oF = /* @__PURE__ */ Ot({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we(null), o = we(!1), a = we({ x: 0, y: 0 }), l = we({ x: 0, y: 0 }), c = we(null), u = Ie(() => !!n.linkedTo), d = Ie(() => n.linkedTo ? `${n.linkedTo.layerId}.${n.linkedTo.property}` : ""), h = Ie(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    })), m = Ie(() => {
      if (!c.value) return {};
      const b = c.value.rect;
      return {
        position: "fixed",
        top: `${b.top}px`,
        left: `${b.left}px`,
        width: `${b.width}px`,
        height: `${b.height}px`,
        zIndex: 9999
      };
    });
    function p() {
      const b = [];
      return document.querySelectorAll("[data-pickwhip-target]").forEach((T) => {
        const P = T, E = P.dataset.pickwhipLayerId, y = P.dataset.pickwhipTarget, w = P.dataset.pickwhipLabel || y;
        E === n.layerId && y === n.property || E && y && b.push({
          layerId: E,
          property: y,
          label: w,
          element: P,
          rect: P.getBoundingClientRect()
        });
      }), b;
    }
    function v(b, C, T) {
      for (const P of T) {
        const E = P.rect;
        if (b >= E.left && b <= E.right && C >= E.top && C <= E.bottom)
          return P;
      }
      return null;
    }
    let _ = [];
    function g(b) {
      var E;
      b.preventDefault(), b.stopPropagation();
      const C = "touches" in b ? b.touches[0].clientX : b.clientX, T = "touches" in b ? b.touches[0].clientY : b.clientY, P = (E = r.value) == null ? void 0 : E.getBoundingClientRect();
      P ? a.value = { x: P.left + P.width / 2, y: P.top + P.height / 2 } : a.value = { x: C, y: T }, l.value = { x: C, y: T }, o.value = !0, _ = p(), window.addEventListener("mousemove", x), window.addEventListener("mouseup", M), window.addEventListener("touchmove", x), window.addEventListener("touchend", M);
    }
    function x(b) {
      if (!o.value) return;
      const C = "touches" in b ? b.touches[0].clientX : b.clientX, T = "touches" in b ? b.touches[0].clientY : b.clientY;
      l.value = { x: C, y: T }, _.forEach((P) => {
        P.rect = P.element.getBoundingClientRect();
      }), c.value = v(C, T, _);
    }
    function M(b) {
      if (!o.value) return;
      const C = "changedTouches" in b ? b.changedTouches[0].clientX : b.clientX, T = "changedTouches" in b ? b.changedTouches[0].clientY : b.clientY, P = v(C, T, _);
      P && i("link", { layerId: P.layerId, property: P.property }), o.value = !1, c.value = null, _ = [], window.removeEventListener("mousemove", x), window.removeEventListener("mouseup", M), window.removeEventListener("touchmove", x), window.removeEventListener("touchend", M);
    }
    function S() {
      i("unlink");
    }
    return Nn(() => {
      window.removeEventListener("mousemove", x), window.removeEventListener("mouseup", M), window.removeEventListener("touchmove", x), window.removeEventListener("touchend", M);
    }), (b, C) => (te(), ae("div", {
      class: "pickwhip-container",
      ref_key: "containerRef",
      ref: r
    }, [
      f("div", {
        class: Fe(["pickwhip-handle", { dragging: o.value, linked: u.value }]),
        onMousedown: g,
        onTouchstart: xt(g, ["prevent"]),
        title: u.value ? `Linked to: ${d.value}` : "Drag to link property"
      }, [
        (te(), ae("svg", eF, [
          C[0] || (C[0] = f("circle", {
            cx: "8",
            cy: "8",
            r: "3",
            fill: "currentColor"
          }, null, -1)),
          u.value ? (te(), ae("path", nF)) : (te(), ae("path", tF))
        ]))
      ], 42, Q4),
      u.value ? (te(), ae("button", {
        key: 0,
        class: "clear-link-btn",
        onClick: S,
        title: "Remove link"
      }, "  ")) : Pe("", !0),
      (te(), St(zo, { to: "body" }, [
        o.value ? (te(), ae("svg", {
          key: 0,
          class: "pickwhip-line",
          style: yt(h.value)
        }, [
          f("line", {
            x1: a.value.x,
            y1: a.value.y,
            x2: l.value.x,
            y2: l.value.y,
            stroke: "#4a90d9",
            "stroke-width": "2",
            "stroke-dasharray": "4 2"
          }, null, 8, iF),
          f("circle", {
            cx: l.value.x,
            cy: l.value.y,
            r: "6",
            fill: "#4a90d9",
            stroke: "#fff",
            "stroke-width": "1"
          }, null, 8, sF)
        ], 4)) : Pe("", !0)
      ])),
      (te(), St(zo, { to: "body" }, [
        o.value && c.value ? (te(), ae("div", {
          key: 0,
          class: "drop-target-highlight",
          style: yt(m.value)
        }, [
          f("span", rF, _e(c.value.label), 1)
        ], 4)) : Pe("", !0)
      ]))
    ], 512));
  }
}), gc = /* @__PURE__ */ Gt(oF, [["__scopeId", "data-v-da1938e3"]]), aF = {
  key: 0,
  class: "driver-list"
}, lF = { class: "expand-icon" }, cF = { class: "count" }, uF = {
  key: 0,
  class: "driver-items"
}, dF = { class: "driver-header" }, hF = ["onClick"], fF = { class: "driver-info" }, pF = { class: "target" }, mF = {
  key: 0,
  class: "source"
}, vF = {
  key: 1,
  class: "source audio"
}, gF = {
  key: 2,
  class: "source time"
}, yF = ["onClick"], xF = {
  key: 0,
  class: "driver-transforms"
}, _F = ["title"], bF = {
  key: 1,
  class: "add-driver-section"
}, wF = {
  key: 0,
  class: "add-menu"
}, SF = { class: "menu-section" }, MF = { class: "menu-section" }, CF = { class: "menu-section" }, TF = { class: "menu-section" }, EF = { class: "menu-actions" }, AF = /* @__PURE__ */ Ot({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(s) {
    const e = s, n = sn(), i = we(!0), r = we(!1), o = we({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    }), a = Ie(() => n.getDriversForLayer(e.layerId));
    function l(p) {
      return p ? {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        opacity: "Opacity"
      }[p] || p : "?";
    }
    function c(p) {
      if (!p) return "?";
      const v = n.layers.find((_) => _.id === p);
      return (v == null ? void 0 : v.name) || p.slice(0, 8);
    }
    function u(p) {
      switch (p.type) {
        case "scale":
          return `Scale: ${p.factor}`;
        case "offset":
          return `Offset: ${p.amount}`;
        case "clamp":
          return `Clamp: ${p.min}-${p.max}`;
        case "smooth":
          return `Smooth: ${p.smoothing}`;
        case "threshold":
          return `Threshold: ${p.threshold}`;
        default:
          return p.type;
      }
    }
    function d(p) {
      n.togglePropertyDriver(p);
    }
    function h(p) {
      n.removePropertyDriver(p);
    }
    function m() {
      n.createAudioPropertyDriver(
        e.layerId,
        o.value.targetProperty,
        o.value.audioFeature,
        {
          scale: o.value.scale,
          threshold: o.value.threshold > 0 ? o.value.threshold : void 0
        }
      ), r.value = !1;
    }
    return (p, v) => a.value.length > 0 ? (te(), ae("div", aF, [
      f("div", {
        class: "driver-list-header",
        onClick: v[0] || (v[0] = (_) => i.value = !i.value)
      }, [
        f("span", lF, _e(i.value ? "" : ""), 1),
        v[7] || (v[7] = f("span", { class: "title" }, "Property Drivers", -1)),
        f("span", cF, "(" + _e(a.value.length) + ")", 1)
      ]),
      i.value ? (te(), ae("div", uF, [
        (te(!0), ae(qe, null, ot(a.value, (_) => (te(), ae("div", {
          key: _.id,
          class: Fe(["driver-item", { disabled: !_.enabled }])
        }, [
          f("div", dF, [
            f("button", {
              class: Fe(["toggle-btn", { active: _.enabled }]),
              onClick: (g) => d(_.id),
              title: "Toggle driver"
            }, "  ", 10, hF),
            f("div", fF, [
              f("span", pF, _e(l(_.targetProperty)), 1),
              v[8] || (v[8] = f("span", { class: "arrow" }, "", -1)),
              _.sourceType === "property" ? (te(), ae("span", mF, _e(c(_.sourceLayerId)) + "." + _e(l(_.sourceProperty)), 1)) : _.sourceType === "audio" ? (te(), ae("span", vF, "  " + _e(_.audioFeature), 1)) : _.sourceType === "time" ? (te(), ae("span", gF, "  Time ")) : Pe("", !0)
            ]),
            f("button", {
              class: "remove-btn",
              onClick: (g) => h(_.id),
              title: "Remove driver"
            }, "  ", 8, yF)
          ]),
          _.transforms.length > 0 ? (te(), ae("div", xF, [
            (te(!0), ae(qe, null, ot(_.transforms, (g, x) => (te(), ae("span", {
              key: x,
              class: "transform-chip",
              title: u(g)
            }, _e(g.type), 9, _F))), 128))
          ])) : Pe("", !0)
        ], 2))), 128))
      ])) : Pe("", !0),
      i.value ? (te(), ae("div", bF, [
        f("button", {
          class: "add-driver-btn",
          onClick: v[1] || (v[1] = (_) => r.value = !r.value)
        }, " + Add Audio Driver "),
        r.value ? (te(), ae("div", wF, [
          f("div", SF, [
            v[10] || (v[10] = f("label", null, "Audio Feature:", -1)),
            st(f("select", {
              "onUpdate:modelValue": v[2] || (v[2] = (_) => o.value.audioFeature = _)
            }, [...v[9] || (v[9] = [
              ls('<option value="amplitude" data-v-d3107912>Amplitude</option><option value="bass" data-v-d3107912>Bass</option><option value="mid" data-v-d3107912>Mid</option><option value="high" data-v-d3107912>High</option><option value="rms" data-v-d3107912>RMS</option>', 5)
            ])], 512), [
              [Cn, o.value.audioFeature]
            ])
          ]),
          f("div", MF, [
            v[12] || (v[12] = f("label", null, "Target Property:", -1)),
            st(f("select", {
              "onUpdate:modelValue": v[3] || (v[3] = (_) => o.value.targetProperty = _)
            }, [...v[11] || (v[11] = [
              ls('<option value="transform.position.x" data-v-d3107912>Position X</option><option value="transform.position.y" data-v-d3107912>Position Y</option><option value="transform.scale.x" data-v-d3107912>Scale X</option><option value="transform.scale.y" data-v-d3107912>Scale Y</option><option value="transform.rotation" data-v-d3107912>Rotation</option><option value="opacity" data-v-d3107912>Opacity</option>', 6)
            ])], 512), [
              [Cn, o.value.targetProperty]
            ])
          ]),
          f("div", CF, [
            v[13] || (v[13] = f("label", null, "Scale:", -1)),
            st(f("input", {
              type: "number",
              "onUpdate:modelValue": v[4] || (v[4] = (_) => o.value.scale = _),
              step: "10"
            }, null, 512), [
              [
                Ut,
                o.value.scale,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          f("div", TF, [
            v[14] || (v[14] = f("label", null, "Threshold:", -1)),
            st(f("input", {
              type: "number",
              "onUpdate:modelValue": v[5] || (v[5] = (_) => o.value.threshold = _),
              min: "0",
              max: "1",
              step: "0.1"
            }, null, 512), [
              [
                Ut,
                o.value.threshold,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          f("div", EF, [
            f("button", { onClick: m }, "Create"),
            f("button", {
              onClick: v[6] || (v[6] = (_) => r.value = !1)
            }, "Cancel")
          ])
        ])) : Pe("", !0)
      ])) : Pe("", !0)
    ])) : Pe("", !0);
  }
}), PF = /* @__PURE__ */ Gt(AF, [["__scopeId", "data-v-d3107912"]]), RF = { class: "properties-panel" }, DF = {
  key: 0,
  class: "panel-content"
}, kF = { class: "property-section" }, IF = { class: "property-row" }, LF = { class: "property-section" }, FF = { class: "property-row" }, UF = ["value"], OF = ["value"], zF = { class: "property-section" }, NF = { class: "expand-icon" }, BF = {
  key: 0,
  class: "section-content"
}, VF = ["data-pickwhip-layer-id"], GF = { class: "multi-value" }, HF = { class: "multi-value" }, $F = { class: "property-row" }, WF = { class: "multi-value orientation-row" }, XF = { class: "property-row" }, jF = { class: "single-value" }, YF = { class: "property-row" }, qF = { class: "single-value" }, ZF = { class: "property-row" }, KF = { class: "single-value" }, JF = { class: "single-value" }, QF = { class: "property-row" }, eU = { class: "multi-value" }, tU = { class: "single-value" }, nU = { class: "property-section" }, iU = { class: "property-row" }, sU = ["value"], rU = {
  key: 1,
  class: "empty-state"
}, oU = /* @__PURE__ */ Ot({
  __name: "PropertiesPanel",
  setup(s) {
    const e = sn(), n = we(["transform"]), i = we(!0), r = we(""), o = we({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    }), a = we("normal"), l = we([]), c = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], u = Ie(() => e.selectedLayer), d = Ie(() => {
      if (!u.value) return [];
      const E = u.value.id, y = (D) => {
        const U = e.layers.filter((O) => O.parentId === D);
        let R = U.map((O) => O.id);
        for (const O of U)
          R = R.concat(y(O.id));
        return R;
      }, w = new Set(y(E));
      return e.layers.filter(
        (D) => D.id !== E && !w.has(D.id) && D.type !== "camera"
        // Camera layers shouldn't be parents
      );
    }), h = Ie(() => {
      if (!u.value) return null;
      switch (u.value.type) {
        case "text":
          return Ss(sR);
        case "particles":
          return Ss(sL);
        case "depthflow":
          return Ss(b5);
        case "light":
          return Ss(H5);
        case "spline":
          return Ss(c4);
        case "video":
          return Ss(J4);
        default:
          return null;
      }
    });
    Ft(u, (E) => {
      var y, w, D, U, R, O, A, G, ue, Q, le, re, j, $, q, oe, ie, ce, V, Y, H, I, F, L, ee;
      if (E) {
        r.value = E.name;
        const Z = E.transform;
        o.value = {
          position: {
            x: ((w = (y = Z == null ? void 0 : Z.position) == null ? void 0 : y.value) == null ? void 0 : w.x) || 0,
            y: ((U = (D = Z == null ? void 0 : Z.position) == null ? void 0 : D.value) == null ? void 0 : U.y) || 0,
            z: ((O = (R = Z == null ? void 0 : Z.position) == null ? void 0 : R.value) == null ? void 0 : O.z) || 0
          },
          scale: { x: ((G = (A = Z == null ? void 0 : Z.scale) == null ? void 0 : A.value) == null ? void 0 : G.x) || 100, y: ((Q = (ue = Z == null ? void 0 : Z.scale) == null ? void 0 : ue.value) == null ? void 0 : Q.y) || 100 },
          rotation: ((le = Z == null ? void 0 : Z.rotation) == null ? void 0 : le.value) || 0,
          anchorPoint: { x: ((j = (re = Z == null ? void 0 : Z.anchorPoint) == null ? void 0 : re.value) == null ? void 0 : j.x) || 0, y: ((q = ($ = Z == null ? void 0 : Z.anchorPoint) == null ? void 0 : $.value) == null ? void 0 : q.y) || 0 },
          opacity: ((oe = E.opacity) == null ? void 0 : oe.value) || 100,
          // 3D properties
          orientationX: ((ce = (ie = Z == null ? void 0 : Z.orientation) == null ? void 0 : ie.value) == null ? void 0 : ce.x) || 0,
          orientationY: ((Y = (V = Z == null ? void 0 : Z.orientation) == null ? void 0 : V.value) == null ? void 0 : Y.y) || 0,
          orientationZ: ((I = (H = Z == null ? void 0 : Z.orientation) == null ? void 0 : H.value) == null ? void 0 : I.z) || 0,
          rotationX: ((F = Z == null ? void 0 : Z.rotationX) == null ? void 0 : F.value) || 0,
          rotationY: ((L = Z == null ? void 0 : Z.rotationY) == null ? void 0 : L.value) || 0,
          rotationZ: ((ee = Z == null ? void 0 : Z.rotationZ) == null ? void 0 : ee.value) || 0
        }, a.value = E.blendMode || "normal";
      }
    }, { immediate: !0 }), Ft(() => o.value.scale.x, (E, y) => {
      if (i.value && E !== y) {
        const w = E / y;
        o.value.scale.y = Math.round(o.value.scale.y * w * 10) / 10;
      }
    });
    function m(E) {
      const y = n.value.indexOf(E);
      y >= 0 ? n.value.splice(y, 1) : n.value.push(E);
    }
    function p() {
      u.value && r.value && (u.value.name = r.value);
    }
    function v() {
      if (!u.value) return;
      const E = u.value.transform, y = o.value;
      E != null && E.position && (E.position.value = { x: y.position.x, y: y.position.y, z: y.position.z }), E != null && E.scale && (E.scale.value = { x: y.scale.x, y: y.scale.y }), E != null && E.rotation && (E.rotation.value = y.rotation), E != null && E.anchorPoint && (E.anchorPoint.value = { x: y.anchorPoint.x, y: y.anchorPoint.y }), u.value.opacity && (u.value.opacity.value = y.opacity), u.value.threeD && (E != null && E.orientation && (E.orientation.value = { x: y.orientationX, y: y.orientationY, z: y.orientationZ }), E != null && E.rotationX && (E.rotationX.value = y.rotationX), E != null && E.rotationY && (E.rotationY.value = y.rotationY), E != null && E.rotationZ && (E.rotationZ.value = y.rotationZ)), M();
    }
    function _() {
      u.value && (u.value.blendMode = a.value);
    }
    function g(E) {
      return l.value.includes(E);
    }
    function x(E) {
      const y = l.value.indexOf(E);
      y >= 0 ? l.value.splice(y, 1) : (l.value.push(E), console.log(`Added keyframe for ${E} at frame ${e.currentFrame}`));
    }
    function M(E) {
      u.value && (E && Object.keys(E).length > 0 ? e.updateLayerData(u.value.id, E) : e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
    function S(E) {
      if (!u.value) return;
      const y = E.target.value || null;
      e.setLayerParent(u.value.id, y);
    }
    function b(E) {
      if (!u.value) return null;
      const w = e.getDriversForLayer(u.value.id).find((D) => D.targetProperty === E && D.sourceType === "property");
      return w && w.sourceLayerId && w.sourceProperty ? {
        layerId: w.sourceLayerId,
        property: w.sourceProperty
      } : null;
    }
    function C(E, y) {
      u.value && (e.createPropertyLink(
        u.value.id,
        E,
        y.layerId,
        y.property,
        { blendMode: "add" }
      ), console.log(`[PropertiesPanel] Linked ${u.value.id}.${E} <- ${y.layerId}.${y.property}`));
    }
    function T(E) {
      if (!u.value) return;
      const w = e.getDriversForLayer(u.value.id).find((D) => D.targetProperty === E && D.sourceType === "property");
      w && (e.removePropertyDriver(w.id), console.log(`[PropertiesPanel] Unlinked ${u.value.id}.${E}`));
    }
    function P(E) {
      return u.value ? e.getDriversForLayer(u.value.id).some((w) => w.targetProperty === E && w.enabled) : !1;
    }
    return (E, y) => {
      var w, D, U, R, O, A, G, ue, Q, le, re;
      return te(), ae("div", RF, [
        y[49] || (y[49] = f("div", { class: "panel-header" }, [
          f("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        u.value ? (te(), ae("div", DF, [
          f("div", kF, [
            f("div", IF, [
              st(f("input", {
                type: "text",
                "onUpdate:modelValue": y[0] || (y[0] = (j) => r.value = j),
                class: "layer-name-input",
                onBlur: p,
                onKeydown: y[1] || (y[1] = ol((j) => j.target.blur(), ["enter"]))
              }, null, 544), [
                [Ut, r.value]
              ])
            ])
          ]),
          f("div", LF, [
            f("div", FF, [
              y[37] || (y[37] = f("label", null, "Parent", -1)),
              f("select", {
                class: "parent-select",
                value: ((w = u.value) == null ? void 0 : w.parentId) || "",
                onChange: S
              }, [
                y[36] || (y[36] = f("option", { value: "" }, "None", -1)),
                (te(!0), ae(qe, null, ot(d.value, (j) => (te(), ae("option", {
                  key: j.id,
                  value: j.id
                }, _e(j.name), 9, OF))), 128))
              ], 40, UF)
            ])
          ]),
          f("div", zF, [
            f("div", {
              class: "section-header",
              onClick: y[2] || (y[2] = (j) => m("transform"))
            }, [
              f("span", NF, _e(n.value.includes("transform") ? "" : ""), 1),
              y[38] || (y[38] = f("span", { class: "section-title" }, "Transform", -1))
            ]),
            n.value.includes("transform") ? (te(), ae("div", BF, [
              f("div", {
                class: Fe(["property-row", { "has-driver": P("transform.position.x") }])
              }, [
                u.value ? (te(), St(gc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.position.x",
                  linkedTo: b("transform.position.x"),
                  onLink: y[3] || (y[3] = (j) => C("transform.position.x", j)),
                  onUnlink: y[4] || (y[4] = () => T("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                f("label", {
                  "data-pickwhip-target": "transform.position.x",
                  "data-pickwhip-layer-id": (D = u.value) == null ? void 0 : D.id,
                  "data-pickwhip-label": "Position X"
                }, "Position", 8, VF),
                f("div", GF, [
                  ze(Ve(et), {
                    modelValue: o.value.position.x,
                    "onUpdate:modelValue": [
                      y[5] || (y[5] = (j) => o.value.position.x = j),
                      v
                    ],
                    precision: 1,
                    unit: "X",
                    "data-pickwhip-target": "transform.position.x",
                    "data-pickwhip-layer-id": (U = u.value) == null ? void 0 : U.id,
                    "data-pickwhip-label": "Position X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  ze(Ve(et), {
                    modelValue: o.value.position.y,
                    "onUpdate:modelValue": [
                      y[6] || (y[6] = (j) => o.value.position.y = j),
                      v
                    ],
                    precision: 1,
                    unit: "Y",
                    "data-pickwhip-target": "transform.position.y",
                    "data-pickwhip-layer-id": (R = u.value) == null ? void 0 : R.id,
                    "data-pickwhip-label": "Position Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  (O = u.value) != null && O.threeD ? (te(), St(Ve(et), {
                    key: 0,
                    modelValue: o.value.position.z,
                    "onUpdate:modelValue": [
                      y[7] || (y[7] = (j) => o.value.position.z = j),
                      v
                    ],
                    precision: 1,
                    unit: "Z",
                    "data-pickwhip-target": "transform.position.z",
                    "data-pickwhip-layer-id": (A = u.value) == null ? void 0 : A.id,
                    "data-pickwhip-label": "Position Z"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])) : Pe("", !0)
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("position") }]),
                  onClick: y[8] || (y[8] = (j) => x("position"))
                }, "", 2)
              ], 2),
              f("div", {
                class: Fe(["property-row", { "has-driver": P("transform.scale.x") || P("transform.scale.y") }])
              }, [
                u.value ? (te(), St(gc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.scale.x",
                  linkedTo: b("transform.scale.x"),
                  onLink: y[9] || (y[9] = (j) => C("transform.scale.x", j)),
                  onUnlink: y[10] || (y[10] = () => T("transform.scale.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                y[39] || (y[39] = f("label", null, "Scale", -1)),
                f("div", HF, [
                  ze(Ve(et), {
                    modelValue: o.value.scale.x,
                    "onUpdate:modelValue": [
                      y[11] || (y[11] = (j) => o.value.scale.x = j),
                      v
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.x",
                    "data-pickwhip-layer-id": (G = u.value) == null ? void 0 : G.id,
                    "data-pickwhip-label": "Scale X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  f("button", {
                    class: Fe(["link-btn", { active: i.value }]),
                    onClick: y[12] || (y[12] = (j) => i.value = !i.value),
                    title: "Link scale values"
                  }, "  ", 2),
                  ze(Ve(et), {
                    modelValue: o.value.scale.y,
                    "onUpdate:modelValue": [
                      y[13] || (y[13] = (j) => o.value.scale.y = j),
                      v
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.y",
                    "data-pickwhip-layer-id": (ue = u.value) == null ? void 0 : ue.id,
                    "data-pickwhip-label": "Scale Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("scale") }]),
                  onClick: y[14] || (y[14] = (j) => x("scale"))
                }, "", 2)
              ], 2),
              (Q = u.value) != null && Q.threeD ? (te(), ae(qe, { key: 0 }, [
                f("div", $F, [
                  y[40] || (y[40] = f("label", null, "Orientation", -1)),
                  f("div", WF, [
                    ze(Ve(et), {
                      modelValue: o.value.orientationX,
                      "onUpdate:modelValue": [
                        y[15] || (y[15] = (j) => o.value.orientationX = j),
                        v
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    ze(Ve(et), {
                      modelValue: o.value.orientationY,
                      "onUpdate:modelValue": [
                        y[16] || (y[16] = (j) => o.value.orientationY = j),
                        v
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    ze(Ve(et), {
                      modelValue: o.value.orientationZ,
                      "onUpdate:modelValue": [
                        y[17] || (y[17] = (j) => o.value.orientationZ = j),
                        v
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                f("div", XF, [
                  y[41] || (y[41] = f("label", null, "X Rotation", -1)),
                  f("div", jF, [
                    ze(Ve(et), {
                      modelValue: o.value.rotationX,
                      "onUpdate:modelValue": [
                        y[18] || (y[18] = (j) => o.value.rotationX = j),
                        v
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Fe(["keyframe-btn", { active: g("rotationX") }]),
                    onClick: y[19] || (y[19] = (j) => x("rotationX"))
                  }, "", 2)
                ]),
                f("div", YF, [
                  y[42] || (y[42] = f("label", null, "Y Rotation", -1)),
                  f("div", qF, [
                    ze(Ve(et), {
                      modelValue: o.value.rotationY,
                      "onUpdate:modelValue": [
                        y[20] || (y[20] = (j) => o.value.rotationY = j),
                        v
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Fe(["keyframe-btn", { active: g("rotationY") }]),
                    onClick: y[21] || (y[21] = (j) => x("rotationY"))
                  }, "", 2)
                ]),
                f("div", ZF, [
                  y[43] || (y[43] = f("label", null, "Z Rotation", -1)),
                  f("div", KF, [
                    ze(Ve(et), {
                      modelValue: o.value.rotationZ,
                      "onUpdate:modelValue": [
                        y[22] || (y[22] = (j) => o.value.rotationZ = j),
                        v
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Fe(["keyframe-btn", { active: g("rotationZ") }]),
                    onClick: y[23] || (y[23] = (j) => x("rotationZ"))
                  }, "", 2)
                ])
              ], 64)) : (te(), ae("div", {
                key: 1,
                class: Fe(["property-row", { "has-driver": P("transform.rotation") }])
              }, [
                u.value ? (te(), St(gc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.rotation",
                  linkedTo: b("transform.rotation"),
                  onLink: y[24] || (y[24] = (j) => C("transform.rotation", j)),
                  onUnlink: y[25] || (y[25] = () => T("transform.rotation"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                y[44] || (y[44] = f("label", null, "Rotation", -1)),
                f("div", JF, [
                  ze(Ve(et), {
                    modelValue: o.value.rotation,
                    "onUpdate:modelValue": [
                      y[26] || (y[26] = (j) => o.value.rotation = j),
                      v
                    ],
                    min: -360,
                    max: 360,
                    unit: "",
                    "data-pickwhip-target": "transform.rotation",
                    "data-pickwhip-layer-id": (le = u.value) == null ? void 0 : le.id,
                    "data-pickwhip-label": "Rotation"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("rotation") }]),
                  onClick: y[27] || (y[27] = (j) => x("rotation"))
                }, "", 2)
              ], 2)),
              f("div", QF, [
                y[45] || (y[45] = f("label", null, "Anchor Point", -1)),
                f("div", eU, [
                  ze(Ve(et), {
                    modelValue: o.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      y[28] || (y[28] = (j) => o.value.anchorPoint.x = j),
                      v
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: o.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      y[29] || (y[29] = (j) => o.value.anchorPoint.y = j),
                      v
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("anchorPoint") }]),
                  onClick: y[30] || (y[30] = (j) => x("anchorPoint"))
                }, "", 2)
              ]),
              f("div", {
                class: Fe(["property-row", { "has-driver": P("opacity") }])
              }, [
                u.value ? (te(), St(gc, {
                  key: 0,
                  layerId: u.value.id,
                  property: "opacity",
                  linkedTo: b("opacity"),
                  onLink: y[31] || (y[31] = (j) => C("opacity", j)),
                  onUnlink: y[32] || (y[32] = () => T("opacity"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                y[46] || (y[46] = f("label", null, "Opacity", -1)),
                f("div", tU, [
                  ze(Ve(jn), {
                    modelValue: o.value.opacity,
                    "onUpdate:modelValue": [
                      y[33] || (y[33] = (j) => o.value.opacity = j),
                      v
                    ],
                    min: 0,
                    max: 100,
                    unit: "%",
                    "data-pickwhip-target": "opacity",
                    "data-pickwhip-layer-id": (re = u.value) == null ? void 0 : re.id,
                    "data-pickwhip-label": "Opacity"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Fe(["keyframe-btn", { active: g("opacity") }]),
                  onClick: y[34] || (y[34] = (j) => x("opacity"))
                }, "", 2)
              ], 2)
            ])) : Pe("", !0)
          ]),
          f("div", nU, [
            f("div", iU, [
              y[47] || (y[47] = f("label", null, "Blend Mode", -1)),
              st(f("select", {
                "onUpdate:modelValue": y[35] || (y[35] = (j) => a.value = j),
                class: "blend-select",
                onChange: _
              }, [
                (te(), ae(qe, null, ot(c, (j) => f("option", {
                  key: j.value,
                  value: j.value
                }, _e(j.label), 9, sU)), 64))
              ], 544), [
                [Cn, a.value]
              ])
            ])
          ]),
          h.value ? (te(), St(t0(h.value), {
            key: 0,
            layer: u.value,
            onUpdate: M
          }, null, 40, ["layer"])) : Pe("", !0),
          u.value ? (te(), St(PF, {
            key: 1,
            layerId: u.value.id
          }, null, 8, ["layerId"])) : Pe("", !0)
        ])) : (te(), ae("div", rU, [...y[48] || (y[48] = [
          f("p", null, "No layer selected", -1),
          f("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
}), aU = /* @__PURE__ */ Gt(oU, [["__scopeId", "data-v-a5a9c7d6"]]), lU = {
  type: "custom",
  baseDistance: 1500,
  center: { x: 960, y: 540, z: 0 },
  duration: 150,
  // 5 seconds at 30fps
  startPhase: 0,
  loops: 1,
  amplitude: 1,
  easing: "ease-in-out",
  audioReactive: !1
}, cU = {
  custom: {},
  orbit: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  orbit_reverse: {
    loops: 1,
    amplitude: -1,
    // Negative for reverse
    easing: "linear"
  },
  swing1: {
    amplitude: 0.25,
    // Smaller arc
    easing: "ease-in-out"
  },
  swing2: {
    amplitude: 0.5,
    // Larger arc
    easing: "ease-in-out"
  },
  dolly_in: {
    amplitude: 0.5,
    // Move 50% closer
    easing: "ease-out"
  },
  dolly_out: {
    amplitude: -0.5,
    // Move 50% away
    easing: "ease-in"
  },
  pan_left: {
    amplitude: 30,
    // 30 degree pan
    easing: "ease-in-out"
  },
  pan_right: {
    amplitude: -30,
    easing: "ease-in-out"
  },
  tilt_up: {
    amplitude: 20,
    // 20 degree tilt
    easing: "ease-in-out"
  },
  tilt_down: {
    amplitude: -20,
    easing: "ease-in-out"
  },
  zoom_in: {
    amplitude: 0.5,
    // 50% zoom increase
    easing: "ease-out"
  },
  zoom_out: {
    amplitude: -0.3,
    // 30% zoom decrease
    easing: "ease-in"
  },
  circle: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  figure8: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  spiral_in: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-out"
  },
  spiral_out: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-in"
  },
  crane_up: {
    amplitude: 500,
    // Pixels to move up
    easing: "ease-in-out"
  },
  crane_down: {
    amplitude: -500,
    easing: "ease-in-out"
  },
  truck_left: {
    amplitude: 300,
    // Pixels to move left
    easing: "ease-in-out"
  },
  truck_right: {
    amplitude: -300,
    easing: "ease-in-out"
  },
  arc_left: {
    amplitude: 0.25,
    // Quarter circle left
    easing: "ease-in-out"
  },
  arc_right: {
    amplitude: -0.25,
    easing: "ease-in-out"
  }
};
function ky(s, e) {
  switch (e) {
    case "linear":
      return s;
    case "ease-in":
      return s * s;
    case "ease-out":
      return 1 - (1 - s) * (1 - s);
    case "ease-in-out":
      return s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2;
    case "bounce":
      if (s < 0.5)
        return 8 * s * s * s * s;
      const n = s - 1;
      return 1 - 8 * n * n * n * n;
    default:
      return s;
  }
}
function Iy(s, e) {
  const n = ky(e, s.easing), { center: i, baseDistance: r, amplitude: o, loops: a, startPhase: l, type: c } = s;
  let u = { x: i.x, y: i.y, z: i.z - r }, d = { ...i };
  switch (c) {
    case "orbit":
    case "orbit_reverse": {
      const h = (l + n * a) * 2 * Math.PI * Math.sign(o);
      u = {
        x: i.x + Math.sin(h) * r,
        y: i.y,
        z: i.z - Math.cos(h) * r
      };
      break;
    }
    case "swing1":
    case "swing2": {
      const h = Math.abs(o) * Math.PI, m = Math.sin(n * Math.PI) * h;
      u = {
        x: i.x + Math.sin(m) * r,
        y: i.y,
        z: i.z - Math.cos(m) * r
      };
      break;
    }
    case "dolly_in": {
      const h = r * (1 - n * Math.abs(o));
      u = {
        x: i.x,
        y: i.y,
        z: i.z - h
      };
      break;
    }
    case "dolly_out": {
      const h = r * (1 + n * Math.abs(o));
      u = {
        x: i.x,
        y: i.y,
        z: i.z - h
      };
      break;
    }
    case "pan_left":
    case "pan_right": {
      const h = n * o * (Math.PI / 180);
      d = {
        x: i.x + Math.sin(h) * r,
        y: i.y,
        z: i.z + Math.cos(h) * r - r
      };
      break;
    }
    case "tilt_up":
    case "tilt_down": {
      const h = n * o * (Math.PI / 180);
      d = {
        x: i.x,
        y: i.y + Math.sin(h) * r,
        z: i.z
      };
      break;
    }
    case "circle": {
      const h = (l + n * a) * 2 * Math.PI, m = r * 0.3 * Math.abs(o);
      u = {
        x: i.x + Math.sin(h) * m,
        y: i.y + Math.cos(h) * m * 0.5,
        // Elliptical
        z: i.z - r + Math.cos(h) * m * 0.3
      };
      break;
    }
    case "figure8": {
      const h = (l + n * a) * 2 * Math.PI, m = r * 0.3 * Math.abs(o);
      u = {
        x: i.x + Math.sin(h) * m,
        y: i.y + Math.sin(h * 2) * m * 0.3,
        z: i.z - r
      };
      break;
    }
    case "spiral_in": {
      const h = (l + n * a) * 2 * Math.PI, m = r * (1 - n * Math.abs(o));
      u = {
        x: i.x + Math.sin(h) * m * 0.3,
        y: i.y,
        z: i.z - m
      };
      break;
    }
    case "spiral_out": {
      const h = (l + n * a) * 2 * Math.PI, m = r * (1 + n * Math.abs(o));
      u = {
        x: i.x + Math.sin(h) * m * 0.3,
        y: i.y,
        z: i.z - m
      };
      break;
    }
    case "crane_up":
    case "crane_down": {
      u = {
        x: i.x,
        y: i.y + n * o,
        z: i.z - r
      }, d = {
        x: i.x,
        y: i.y + n * o * 0.5,
        // Target moves less
        z: i.z
      };
      break;
    }
    case "truck_left":
    case "truck_right": {
      u = {
        x: i.x + n * o,
        y: i.y,
        z: i.z - r
      }, d = {
        x: i.x + n * o,
        y: i.y,
        z: i.z
      };
      break;
    }
    case "arc_left":
    case "arc_right": {
      const h = n * o * 2 * Math.PI;
      u = {
        x: i.x + Math.sin(h) * r,
        y: i.y,
        z: i.z - Math.cos(h) * r
      };
      break;
    }
  }
  return { position: u, target: d };
}
function uU(s, e = 0, n = 5) {
  const i = [], r = [], o = [], a = Math.ceil(s.duration / n) + 1;
  for (let l = 0; l < a; l++) {
    const c = e + Math.min(l * n, s.duration), u = Math.min(l * n, s.duration) / s.duration, { position: d, target: h } = Iy(s, u);
    if (i.push({
      frame: c,
      position: d,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    }), r.push({
      frame: c,
      pointOfInterest: h,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    }), s.type === "zoom_in" || s.type === "zoom_out") {
      const m = ky(u, s.easing), p = s.type === "zoom_in" ? 1 + m * Math.abs(s.amplitude) : 1 - m * Math.abs(s.amplitude);
      o.push({
        frame: c,
        zoom: 1778 * p,
        // Base 50mm zoom
        temporalInterpolation: "linear"
      });
    }
  }
  return {
    position: i,
    pointOfInterest: r,
    zoom: o.length > 0 ? o : void 0
  };
}
function dU(s) {
  return {
    custom: "Custom trajectory with manual keyframes",
    orbit: "360 horizontal orbit around target",
    orbit_reverse: "360 reverse orbit around target",
    swing1: "Gentle pendulum swing (45)",
    swing2: "Wide pendulum swing (90)",
    dolly_in: "Move camera toward target",
    dolly_out: "Move camera away from target",
    pan_left: "Rotate camera left while stationary",
    pan_right: "Rotate camera right while stationary",
    tilt_up: "Tilt camera up while stationary",
    tilt_down: "Tilt camera down while stationary",
    zoom_in: "Zoom lens in (narrower FOV)",
    zoom_out: "Zoom lens out (wider FOV)",
    circle: "Elliptical circling motion",
    figure8: "Figure-8 weaving pattern",
    spiral_in: "Spiral toward target",
    spiral_out: "Spiral away from target",
    crane_up: "Vertical lift (crane shot up)",
    crane_down: "Vertical descent (crane shot down)",
    truck_left: "Horizontal slide left",
    truck_right: "Horizontal slide right",
    arc_left: "Curved arc movement left",
    arc_right: "Curved arc movement right"
  }[s] || "Unknown trajectory";
}
function hU(s) {
  return {
    custom: "Custom",
    orbit: "Orbital",
    orbit_reverse: "Orbital",
    swing1: "Orbital",
    swing2: "Orbital",
    circle: "Orbital",
    figure8: "Orbital",
    arc_left: "Orbital",
    arc_right: "Orbital",
    dolly_in: "Dolly",
    dolly_out: "Dolly",
    spiral_in: "Dolly",
    spiral_out: "Dolly",
    pan_left: "Pan/Tilt",
    pan_right: "Pan/Tilt",
    tilt_up: "Pan/Tilt",
    tilt_down: "Pan/Tilt",
    crane_up: "Crane",
    crane_down: "Crane",
    truck_left: "Truck",
    truck_right: "Truck",
    zoom_in: "Zoom",
    zoom_out: "Zoom"
  }[s] || "Other";
}
function fU() {
  const s = Object.keys(cU), e = {};
  for (const n of s) {
    const i = hU(n);
    e[i] || (e[i] = []), e[i].push(n);
  }
  return e;
}
const pU = { class: "camera-properties" }, mU = { class: "panel-header" }, vU = { class: "camera-name" }, gU = {
  key: 0,
  class: "properties-content"
}, yU = { class: "property-section" }, xU = { class: "property-row" }, _U = ["value"], bU = { class: "property-section" }, wU = { class: "toggle-icon" }, SU = { class: "section-content" }, MU = { class: "property-group" }, CU = { class: "xyz-inputs" }, TU = {
  key: 0,
  class: "property-group"
}, EU = { class: "xyz-inputs" }, AU = { class: "property-group" }, PU = { class: "xyz-inputs" }, RU = { class: "property-group" }, DU = { class: "property-group" }, kU = { class: "property-group" }, IU = { class: "property-section" }, LU = { class: "toggle-icon" }, FU = { class: "section-content" }, UU = { class: "preset-row" }, OU = ["onClick"], zU = { class: "property-group" }, NU = { class: "property-group" }, BU = { class: "property-group" }, VU = { class: "property-group" }, GU = ["value"], HU = { class: "property-section" }, $U = { class: "toggle-icon" }, WU = { class: "section-content" }, XU = { class: "property-group checkbox-group" }, jU = ["checked"], YU = { class: "property-group" }, qU = { class: "property-group" }, ZU = { class: "property-group" }, KU = { class: "property-group checkbox-group" }, JU = ["checked"], QU = { class: "property-section" }, eO = { class: "toggle-icon" }, tO = { class: "section-content" }, nO = { class: "property-group" }, iO = { class: "property-group" }, sO = { class: "property-group" }, rO = { class: "property-group" }, oO = { class: "property-group" }, aO = { class: "property-section" }, lO = { class: "toggle-icon" }, cO = { class: "section-content" }, uO = { class: "property-group" }, dO = { class: "property-group" }, hO = { class: "property-group" }, fO = { class: "property-section" }, pO = { class: "toggle-icon" }, mO = { class: "section-content" }, vO = { class: "property-group" }, gO = ["value"], yO = { class: "property-section" }, xO = { class: "toggle-icon" }, _O = { class: "section-content" }, bO = { class: "property-group" }, wO = { class: "property-group" }, SO = { class: "property-section" }, MO = { class: "toggle-icon" }, CO = { class: "section-content" }, TO = { class: "property-group" }, EO = ["label"], AO = ["value"], PO = { class: "trajectory-description" }, RO = { class: "property-group" }, DO = { class: "property-group" }, kO = {
  key: 0,
  class: "property-group"
}, IO = { class: "property-group" }, LO = { class: "property-group checkbox-group" }, FO = { class: "property-group" }, UO = { class: "property-group" }, OO = {
  key: 1,
  class: "no-camera"
}, zO = /* @__PURE__ */ Ot({
  __name: "CameraProperties",
  setup(s) {
    const e = sn(), n = Ie(() => {
      const E = e.selectedLayer;
      if ((E == null ? void 0 : E.type) === "camera" && E.data) {
        const y = E.data;
        return e.getCamera(y.cameraId);
      }
      return e.activeCamera;
    }), i = $r({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1,
      trajectory: !1
    }), r = $r({
      ...lU
    }), o = Ie(() => fU()), a = Ie(() => dU(r.type)), l = Ie(() => ["orbit", "orbit_reverse", "circle", "figure8", "spiral_in", "spiral_out"].includes(r.type));
    function c(E) {
      return E.split("_").map((y) => y.charAt(0).toUpperCase() + y.slice(1)).join(" ");
    }
    const u = we(null);
    function d() {
      if (!n.value) return;
      u.value !== null && cancelAnimationFrame(u.value);
      const E = performance.now(), y = r.duration / 30 * 1e3, w = {
        ...r,
        center: { ...n.value.pointOfInterest },
        baseDistance: Math.sqrt(
          Math.pow(n.value.position.x - n.value.pointOfInterest.x, 2) + Math.pow(n.value.position.y - n.value.pointOfInterest.y, 2) + Math.pow(n.value.position.z - n.value.pointOfInterest.z, 2)
        )
      };
      function D() {
        const U = performance.now() - E, R = Math.min(U / y, 1), { position: O, target: A } = Iy(w, R);
        e.updateCamera(n.value.id, {
          position: O,
          pointOfInterest: A
        }), R < 1 ? u.value = requestAnimationFrame(D) : u.value = null;
      }
      D();
    }
    function h() {
      if (!n.value) return;
      const E = Math.sqrt(
        Math.pow(n.value.position.x - n.value.pointOfInterest.x, 2) + Math.pow(n.value.position.y - n.value.pointOfInterest.y, 2) + Math.pow(n.value.position.z - n.value.pointOfInterest.z, 2)
      ), y = {
        ...r,
        center: { ...n.value.pointOfInterest },
        baseDistance: E
      }, w = uU(y, e.currentFrame);
      console.log("Generated trajectory keyframes:", w), alert(`Generated ${w.position.length} keyframes for camera trajectory.
Keyframe application will be added in a future update.`);
    }
    function m(E) {
      i[E] = !i[E];
    }
    function p(E, y) {
      n.value && e.updateCamera(n.value.id, { [E]: y });
    }
    function v(E, y) {
      n.value && e.updateCamera(n.value.id, {
        position: { ...n.value.position, [E]: y }
      });
    }
    function _(E, y) {
      n.value && e.updateCamera(n.value.id, {
        pointOfInterest: { ...n.value.pointOfInterest, [E]: y }
      });
    }
    function g(E, y) {
      n.value && e.updateCamera(n.value.id, {
        orientation: { ...n.value.orientation, [E]: y }
      });
    }
    function x(E) {
      if (!n.value) return;
      const y = Tl(E, n.value.filmSize);
      e.updateCamera(n.value.id, {
        focalLength: E,
        angleOfView: y
      });
    }
    function M(E) {
      if (!n.value) return;
      const y = KT(E, n.value.filmSize);
      e.updateCamera(n.value.id, {
        angleOfView: E,
        focalLength: y
      });
    }
    function S(E, y) {
      n.value && e.updateCamera(n.value.id, {
        depthOfField: { ...n.value.depthOfField, [E]: y }
      });
    }
    function b(E, y) {
      n.value && e.updateCamera(n.value.id, {
        iris: { ...n.value.iris, [E]: y }
      });
    }
    function C(E, y) {
      n.value && e.updateCamera(n.value.id, {
        highlight: { ...n.value.highlight, [E]: y }
      });
    }
    function T(E) {
      n.value && e.updateCamera(n.value.id, {
        focalLength: E.focalLength,
        angleOfView: E.angleOfView,
        zoom: E.zoom
      });
    }
    function P() {
      e.createCameraLayer();
    }
    return (E, y) => {
      var w;
      return te(), ae("div", pU, [
        f("div", mU, [
          y[47] || (y[47] = f("span", { class: "panel-title" }, "Camera", -1)),
          f("span", vU, _e(((w = n.value) == null ? void 0 : w.name) ?? "No Camera"), 1)
        ]),
        n.value ? (te(), ae("div", gU, [
          f("div", yU, [
            y[49] || (y[49] = f("div", { class: "section-header" }, "Type", -1)),
            f("div", xU, [
              f("select", {
                value: n.value.type,
                onChange: y[0] || (y[0] = (D) => p("type", D.target.value)),
                class: "type-select"
              }, [...y[48] || (y[48] = [
                f("option", { value: "one-node" }, "One-Node Camera", -1),
                f("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, _U)
            ])
          ]),
          f("div", bU, [
            f("div", {
              class: "section-header",
              onClick: y[1] || (y[1] = (D) => m("transform"))
            }, [
              f("span", wU, _e(i.transform ? "" : ""), 1),
              y[50] || (y[50] = ct(" Transform ", -1))
            ]),
            st(f("div", SU, [
              f("div", MU, [
                y[51] || (y[51] = f("label", null, "Position", -1)),
                f("div", CU, [
                  ze(Ve(et), {
                    modelValue: n.value.position.x,
                    "onUpdate:modelValue": y[2] || (y[2] = (D) => v("x", D)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.position.y,
                    "onUpdate:modelValue": y[3] || (y[3] = (D) => v("y", D)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.position.z,
                    "onUpdate:modelValue": y[4] || (y[4] = (D) => v("z", D)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              n.value.type === "two-node" ? (te(), ae("div", TU, [
                y[52] || (y[52] = f("label", null, "Point of Interest", -1)),
                f("div", EU, [
                  ze(Ve(et), {
                    modelValue: n.value.pointOfInterest.x,
                    "onUpdate:modelValue": y[5] || (y[5] = (D) => _("x", D)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.pointOfInterest.y,
                    "onUpdate:modelValue": y[6] || (y[6] = (D) => _("y", D)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.pointOfInterest.z,
                    "onUpdate:modelValue": y[7] || (y[7] = (D) => _("z", D)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : Pe("", !0),
              f("div", AU, [
                y[53] || (y[53] = f("label", null, "Orientation", -1)),
                f("div", PU, [
                  ze(Ve(et), {
                    modelValue: n.value.orientation.x,
                    "onUpdate:modelValue": y[8] || (y[8] = (D) => g("x", D)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.orientation.y,
                    "onUpdate:modelValue": y[9] || (y[9] = (D) => g("y", D)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  ze(Ve(et), {
                    modelValue: n.value.orientation.z,
                    "onUpdate:modelValue": y[10] || (y[10] = (D) => g("z", D)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              f("div", RU, [
                y[54] || (y[54] = f("label", null, "X Rotation", -1)),
                ze(Ve(et), {
                  modelValue: n.value.xRotation,
                  "onUpdate:modelValue": y[11] || (y[11] = (D) => p("xRotation", D)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", DU, [
                y[55] || (y[55] = f("label", null, "Y Rotation", -1)),
                ze(Ve(et), {
                  modelValue: n.value.yRotation,
                  "onUpdate:modelValue": y[12] || (y[12] = (D) => p("yRotation", D)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", kU, [
                y[56] || (y[56] = f("label", null, "Z Rotation", -1)),
                ze(Ve(et), {
                  modelValue: n.value.zRotation,
                  "onUpdate:modelValue": y[13] || (y[13] = (D) => p("zRotation", D)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.transform]
            ])
          ]),
          f("div", IU, [
            f("div", {
              class: "section-header",
              onClick: y[14] || (y[14] = (D) => m("lens"))
            }, [
              f("span", LU, _e(i.lens ? "" : ""), 1),
              y[57] || (y[57] = ct(" Lens ", -1))
            ]),
            st(f("div", FU, [
              f("div", UU, [
                (te(!0), ae(qe, null, ot(Ve(WT), (D) => (te(), ae("button", {
                  key: D.name,
                  class: Fe({ active: Math.abs(n.value.focalLength - D.focalLength) < 0.5 }),
                  onClick: (U) => T(D)
                }, _e(D.name), 11, OU))), 128))
              ]),
              f("div", zU, [
                y[58] || (y[58] = f("label", null, "Focal Length", -1)),
                ze(Ve(et), {
                  modelValue: n.value.focalLength,
                  "onUpdate:modelValue": x,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", NU, [
                y[59] || (y[59] = f("label", null, "Angle of View", -1)),
                ze(Ve(et), {
                  modelValue: n.value.angleOfView,
                  "onUpdate:modelValue": M,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", BU, [
                y[60] || (y[60] = f("label", null, "Film Size", -1)),
                ze(Ve(et), {
                  modelValue: n.value.filmSize,
                  "onUpdate:modelValue": y[15] || (y[15] = (D) => p("filmSize", D)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", VU, [
                y[62] || (y[62] = f("label", null, "Measure Film Size", -1)),
                f("select", {
                  value: n.value.measureFilmSize,
                  onChange: y[16] || (y[16] = (D) => p("measureFilmSize", D.target.value))
                }, [...y[61] || (y[61] = [
                  f("option", { value: "horizontal" }, "Horizontal", -1),
                  f("option", { value: "vertical" }, "Vertical", -1),
                  f("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, GU)
              ])
            ], 512), [
              [Bs, i.lens]
            ])
          ]),
          f("div", HU, [
            f("div", {
              class: "section-header",
              onClick: y[17] || (y[17] = (D) => m("dof"))
            }, [
              f("span", $U, _e(i.dof ? "" : ""), 1),
              y[63] || (y[63] = ct(" Depth of Field ", -1))
            ]),
            st(f("div", WU, [
              f("div", XU, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: n.value.depthOfField.enabled,
                    onChange: y[18] || (y[18] = (D) => S("enabled", D.target.checked))
                  }, null, 40, jU),
                  y[64] || (y[64] = ct(" Enable DOF ", -1))
                ])
              ]),
              n.value.depthOfField.enabled ? (te(), ae(qe, { key: 0 }, [
                f("div", YU, [
                  y[65] || (y[65] = f("label", null, "Focus Distance", -1)),
                  ze(Ve(et), {
                    modelValue: n.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": y[19] || (y[19] = (D) => S("focusDistance", D)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                f("div", qU, [
                  y[66] || (y[66] = f("label", null, "f-Stop", -1)),
                  ze(Ve(et), {
                    modelValue: n.value.depthOfField.fStop,
                    "onUpdate:modelValue": y[20] || (y[20] = (D) => S("fStop", D)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                f("div", ZU, [
                  y[67] || (y[67] = f("label", null, "Blur Level", -1)),
                  ze(Ve(jn), {
                    modelValue: n.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": y[21] || (y[21] = (D) => S("blurLevel", D)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                f("div", KU, [
                  f("label", null, [
                    f("input", {
                      type: "checkbox",
                      checked: n.value.depthOfField.lockToZoom,
                      onChange: y[22] || (y[22] = (D) => S("lockToZoom", D.target.checked))
                    }, null, 40, JU),
                    y[68] || (y[68] = ct(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : Pe("", !0)
            ], 512), [
              [Bs, i.dof]
            ])
          ]),
          f("div", QU, [
            f("div", {
              class: "section-header",
              onClick: y[23] || (y[23] = (D) => m("iris"))
            }, [
              f("span", eO, _e(i.iris ? "" : ""), 1),
              y[69] || (y[69] = ct(" Iris ", -1))
            ]),
            st(f("div", tO, [
              f("div", nO, [
                f("label", null, "Shape (" + _e(Math.round(n.value.iris.shape)) + "-gon)", 1),
                ze(Ve(jn), {
                  modelValue: n.value.iris.shape,
                  "onUpdate:modelValue": y[24] || (y[24] = (D) => b("shape", D)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", iO, [
                y[70] || (y[70] = f("label", null, "Rotation", -1)),
                ze(Ve(Jf), {
                  modelValue: n.value.iris.rotation,
                  "onUpdate:modelValue": y[25] || (y[25] = (D) => b("rotation", D)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              f("div", sO, [
                y[71] || (y[71] = f("label", null, "Roundness", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.iris.roundness,
                  "onUpdate:modelValue": y[26] || (y[26] = (D) => b("roundness", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", rO, [
                y[72] || (y[72] = f("label", null, "Aspect Ratio", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.iris.aspectRatio,
                  "onUpdate:modelValue": y[27] || (y[27] = (D) => b("aspectRatio", D)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", oO, [
                y[73] || (y[73] = f("label", null, "Diffraction Fringe", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.iris.diffractionFringe,
                  "onUpdate:modelValue": y[28] || (y[28] = (D) => b("diffractionFringe", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.iris]
            ])
          ]),
          f("div", aO, [
            f("div", {
              class: "section-header",
              onClick: y[29] || (y[29] = (D) => m("highlight"))
            }, [
              f("span", lO, _e(i.highlight ? "" : ""), 1),
              y[74] || (y[74] = ct(" Highlight ", -1))
            ]),
            st(f("div", cO, [
              f("div", uO, [
                y[75] || (y[75] = f("label", null, "Gain", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.highlight.gain,
                  "onUpdate:modelValue": y[30] || (y[30] = (D) => C("gain", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", dO, [
                y[76] || (y[76] = f("label", null, "Threshold", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.highlight.threshold,
                  "onUpdate:modelValue": y[31] || (y[31] = (D) => C("threshold", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", hO, [
                y[77] || (y[77] = f("label", null, "Saturation", -1)),
                ze(Ve(jn), {
                  modelValue: n.value.highlight.saturation,
                  "onUpdate:modelValue": y[32] || (y[32] = (D) => C("saturation", D)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.highlight]
            ])
          ]),
          f("div", fO, [
            f("div", {
              class: "section-header",
              onClick: y[33] || (y[33] = (D) => m("autoOrient"))
            }, [
              f("span", pO, _e(i.autoOrient ? "" : ""), 1),
              y[78] || (y[78] = ct(" Auto-Orient ", -1))
            ]),
            st(f("div", mO, [
              f("div", vO, [
                f("select", {
                  value: n.value.autoOrient,
                  onChange: y[34] || (y[34] = (D) => p("autoOrient", D.target.value))
                }, [...y[79] || (y[79] = [
                  f("option", { value: "off" }, "Off", -1),
                  f("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  f("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, gO)
              ])
            ], 512), [
              [Bs, i.autoOrient]
            ])
          ]),
          f("div", yO, [
            f("div", {
              class: "section-header",
              onClick: y[35] || (y[35] = (D) => m("clipping"))
            }, [
              f("span", xO, _e(i.clipping ? "" : ""), 1),
              y[80] || (y[80] = ct(" Clipping ", -1))
            ]),
            st(f("div", _O, [
              f("div", bO, [
                y[81] || (y[81] = f("label", null, "Near Clip", -1)),
                ze(Ve(et), {
                  modelValue: n.value.nearClip,
                  "onUpdate:modelValue": y[36] || (y[36] = (D) => p("nearClip", D)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", wO, [
                y[82] || (y[82] = f("label", null, "Far Clip", -1)),
                ze(Ve(et), {
                  modelValue: n.value.farClip,
                  "onUpdate:modelValue": y[37] || (y[37] = (D) => p("farClip", D)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [Bs, i.clipping]
            ])
          ]),
          f("div", SO, [
            f("div", {
              class: "section-header",
              onClick: y[38] || (y[38] = (D) => m("trajectory"))
            }, [
              f("span", MO, _e(i.trajectory ? "" : ""), 1),
              y[83] || (y[83] = ct(" Trajectory ", -1))
            ]),
            st(f("div", CO, [
              f("div", TO, [
                y[84] || (y[84] = f("label", null, "Motion Preset", -1)),
                st(f("select", {
                  "onUpdate:modelValue": y[39] || (y[39] = (D) => r.type = D),
                  class: "trajectory-select"
                }, [
                  (te(!0), ae(qe, null, ot(o.value, (D, U) => (te(), ae("optgroup", {
                    key: U,
                    label: U
                  }, [
                    (te(!0), ae(qe, null, ot(D, (R) => (te(), ae("option", {
                      key: R,
                      value: R
                    }, _e(c(R)), 9, AO))), 128))
                  ], 8, EO))), 128))
                ], 512), [
                  [Cn, r.type]
                ])
              ]),
              f("div", PO, _e(a.value), 1),
              f("div", RO, [
                y[85] || (y[85] = f("label", null, "Duration (frames)", -1)),
                ze(Ve(et), {
                  modelValue: r.duration,
                  "onUpdate:modelValue": y[40] || (y[40] = (D) => r.duration = D),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              f("div", DO, [
                y[86] || (y[86] = f("label", null, "Amplitude", -1)),
                ze(Ve(jn), {
                  modelValue: Math.abs(r.amplitude),
                  "onUpdate:modelValue": y[41] || (y[41] = (D) => r.amplitude = D * Math.sign(r.amplitude || 1)),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              l.value ? (te(), ae("div", kO, [
                y[87] || (y[87] = f("label", null, "Loops", -1)),
                ze(Ve(et), {
                  modelValue: r.loops,
                  "onUpdate:modelValue": y[42] || (y[42] = (D) => r.loops = D),
                  min: 0.25,
                  max: 5,
                  precision: 2
                }, null, 8, ["modelValue"])
              ])) : Pe("", !0),
              f("div", IO, [
                y[89] || (y[89] = f("label", null, "Easing", -1)),
                st(f("select", {
                  "onUpdate:modelValue": y[43] || (y[43] = (D) => r.easing = D)
                }, [...y[88] || (y[88] = [
                  ls('<option value="linear" data-v-5af5ddc6>Linear</option><option value="ease-in" data-v-5af5ddc6>Ease In</option><option value="ease-out" data-v-5af5ddc6>Ease Out</option><option value="ease-in-out" data-v-5af5ddc6>Ease In-Out</option><option value="bounce" data-v-5af5ddc6>Bounce</option>', 5)
                ])], 512), [
                  [Cn, r.easing]
                ])
              ]),
              f("div", LO, [
                f("label", null, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": y[44] || (y[44] = (D) => r.audioReactive = D)
                  }, null, 512), [
                    [_i, r.audioReactive]
                  ]),
                  y[90] || (y[90] = ct(" Audio Reactive ", -1))
                ])
              ]),
              r.audioReactive ? (te(), ae(qe, { key: 1 }, [
                f("div", FO, [
                  y[92] || (y[92] = f("label", null, "Audio Feature", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": y[45] || (y[45] = (D) => r.audioFeature = D)
                  }, [...y[91] || (y[91] = [
                    ls('<option value="amplitude" data-v-5af5ddc6>Amplitude</option><option value="bass" data-v-5af5ddc6>Bass</option><option value="mid" data-v-5af5ddc6>Mid</option><option value="high" data-v-5af5ddc6>High</option><option value="onsets" data-v-5af5ddc6>Onsets</option>', 5)
                  ])], 512), [
                    [Cn, r.audioFeature]
                  ])
                ]),
                f("div", UO, [
                  y[93] || (y[93] = f("label", null, "Sensitivity", -1)),
                  ze(Ve(jn), {
                    modelValue: r.audioSensitivity ?? 1,
                    "onUpdate:modelValue": y[46] || (y[46] = (D) => r.audioSensitivity = D),
                    min: 0.1,
                    max: 3,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : Pe("", !0),
              f("div", { class: "trajectory-actions" }, [
                f("button", {
                  class: "action-btn preview",
                  onClick: d
                }, " Preview "),
                f("button", {
                  class: "action-btn apply",
                  onClick: h
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [Bs, i.trajectory]
            ])
          ])
        ])) : (te(), ae("div", OO, [
          y[94] || (y[94] = f("p", null, "No camera selected", -1)),
          f("button", { onClick: P }, "Create Camera")
        ]))
      ]);
    };
  }
}), NO = /* @__PURE__ */ Gt(zO, [["__scopeId", "data-v-5af5ddc6"]]), BO = { class: "audio-properties" }, VO = { class: "property-section" }, GO = {
  key: 0,
  class: "section-content"
}, HO = { class: "property-row" }, $O = { class: "value-display" }, WO = { class: "property-row" }, XO = { class: "value-display" }, jO = { class: "property-row" }, YO = { class: "value-display" }, qO = { class: "property-row" }, ZO = {
  key: 0,
  class: "peak-count"
}, KO = { class: "property-section" }, JO = { class: "mapping-count" }, QO = {
  key: 0,
  class: "section-content"
}, ez = { class: "mapping-header" }, tz = { class: "mapping-enabled" }, nz = ["onUpdate:modelValue"], iz = { class: "mapping-name" }, sz = ["onClick"], rz = {
  key: 0,
  class: "mapping-details"
}, oz = { class: "property-row" }, az = ["onUpdate:modelValue"], lz = ["label"], cz = ["value"], uz = { class: "property-row" }, dz = ["onUpdate:modelValue"], hz = ["label"], fz = ["value"], pz = { class: "property-row" }, mz = ["onUpdate:modelValue"], vz = { class: "value-display" }, gz = { class: "property-row" }, yz = ["onUpdate:modelValue"], xz = { class: "value-display" }, _z = { class: "property-row" }, bz = ["onUpdate:modelValue"], wz = { class: "value-display" }, Sz = { class: "property-row" }, Mz = ["onUpdate:modelValue"], Cz = ["onUpdate:modelValue"], Tz = { class: "property-row" }, Ez = ["onUpdate:modelValue"], Az = { class: "value-display" }, Pz = { class: "property-row" }, Rz = ["onUpdate:modelValue"], Dz = { class: "value-display" }, kz = { class: "property-row" }, Iz = ["onUpdate:modelValue"], Lz = { class: "property-row" }, Fz = ["onUpdate:modelValue"], Uz = {
  key: 0,
  class: "property-row"
}, Oz = ["onUpdate:modelValue"], zz = { class: "value-display" }, Nz = { class: "property-row checkbox-row" }, Bz = ["onUpdate:modelValue"], Vz = ["onClick"], Gz = { class: "property-section" }, Hz = {
  key: 0,
  class: "section-content"
}, $z = { class: "property-row" }, Wz = ["value"], Xz = { class: "visualizer-canvas-container" }, jz = { class: "visualizer-value" }, Yz = /* @__PURE__ */ Ot({
  __name: "AudioProperties",
  setup(s) {
    const e = sn(), n = we(/* @__PURE__ */ new Set(["peaks", "mappings"])), i = we(/* @__PURE__ */ new Set()), r = we({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    }), o = we(null), a = we([]), l = we("amplitude"), c = we(null), u = Ie(() => vE()), d = Ie(() => gE()), h = Ie(() => yE()), m = Ie(
      () => e.currentFrame / e.frameCount * 100
    ), p = Ie(() => e.audioAnalysis ? gl(e.audioAnalysis, l.value, e.currentFrame) : 0);
    function v(b) {
      n.value.has(b) ? n.value.delete(b) : n.value.add(b);
    }
    function _(b) {
      i.value.has(b) ? i.value.delete(b) : i.value.add(b);
    }
    function g() {
      if (!e.audioAnalysis) return;
      const b = e.audioAnalysis.amplitudeEnvelope;
      o.value = Ry(b, r.value), e.setPeakData(o.value);
    }
    function x() {
      const b = pE();
      a.value.push(b), i.value.add(b.id), e.addAudioMapping(b);
    }
    function M(b) {
      const C = a.value.findIndex((T) => T.id === b);
      C >= 0 && (a.value.splice(C, 1), i.value.delete(b), e.removeAudioMapping(b));
    }
    function S() {
      var w, D;
      const b = c.value;
      if (!b || !e.audioAnalysis) return;
      const C = b.getContext("2d");
      if (!C) return;
      const T = b.width, P = b.height;
      C.fillStyle = "#1e1e1e", C.fillRect(0, 0, T, P);
      let E = [];
      const y = e.audioAnalysis;
      switch (l.value) {
        case "amplitude":
          E = y.amplitudeEnvelope;
          break;
        case "rms":
          E = y.rmsEnergy;
          break;
        case "spectralCentroid":
          E = y.spectralCentroid;
          break;
        case "bass":
          E = y.frequencyBands.bass;
          break;
        case "mid":
          E = y.frequencyBands.mid;
          break;
        case "high":
          E = y.frequencyBands.high;
          break;
        case "sub":
          E = y.frequencyBands.sub;
          break;
        case "lowMid":
          E = y.frequencyBands.lowMid;
          break;
        case "highMid":
          E = y.frequencyBands.highMid;
          break;
        case "spectralFlux":
          E = y.spectralFlux || [];
          break;
        case "zeroCrossingRate":
          E = y.zeroCrossingRate || [];
          break;
        case "spectralRolloff":
          E = y.spectralRolloff || [];
          break;
        case "spectralFlatness":
          E = y.spectralFlatness || [];
          break;
        case "chromaEnergy":
          E = ((w = y.chromaFeatures) == null ? void 0 : w.chromaEnergy) || [];
          break;
        case "chromaC":
        case "chromaCs":
        case "chromaD":
        case "chromaDs":
        case "chromaE":
        case "chromaF":
        case "chromaFs":
        case "chromaG":
        case "chromaGs":
        case "chromaA":
        case "chromaAs":
        case "chromaB":
          if ((D = y.chromaFeatures) != null && D.chroma) {
            const U = [
              "chromaC",
              "chromaCs",
              "chromaD",
              "chromaDs",
              "chromaE",
              "chromaF",
              "chromaFs",
              "chromaG",
              "chromaGs",
              "chromaA",
              "chromaAs",
              "chromaB"
            ].indexOf(l.value);
            E = y.chromaFeatures.chroma.map((R) => R[U] || 0);
          }
          break;
        case "onsets":
          E = new Array(y.frameCount).fill(0);
          for (const U of y.onsets)
            U < E.length && (E[U] = 1);
          break;
        case "peaks":
          if (o.value) {
            E = new Array(y.frameCount).fill(0);
            for (const U of o.value.indices)
              U < E.length && (E[U] = 1);
          }
          break;
      }
      if (E.length !== 0) {
        C.strokeStyle = "#4a90d9", C.lineWidth = 1.5, C.beginPath();
        for (let U = 0; U < E.length; U++) {
          const R = U / E.length * T, O = P - E[U] * P * 0.9 - 5;
          U === 0 ? C.moveTo(R, O) : C.lineTo(R, O);
        }
        if (C.stroke(), o.value && l.value !== "peaks") {
          C.fillStyle = "#ff6b6b";
          for (const U of o.value.indices) {
            const R = U / E.length * T;
            C.beginPath(), C.moveTo(R, 0), C.lineTo(R, P), C.strokeStyle = "rgba(255, 107, 107, 0.3)", C.stroke();
          }
        }
      }
    }
    return Ft(
      () => [e.audioAnalysis, l.value, o.value],
      () => {
        S();
      }
    ), Ft(
      a,
      (b) => {
        for (const C of b)
          e.updateAudioMapping(C.id, C);
      },
      { deep: !0 }
    ), xn(() => {
      S();
      const b = e.getAudioMappings();
      b.length > 0 && (a.value = [...b]);
    }), (b, C) => (te(), ae("div", BO, [
      f("div", VO, [
        f("div", {
          class: "section-header",
          onClick: C[0] || (C[0] = (T) => v("peaks"))
        }, [
          f("i", {
            class: Fe(["pi", n.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[7] || (C[7] = f("span", null, "Peak Detection", -1))
        ]),
        n.value.has("peaks") ? (te(), ae("div", GO, [
          f("div", HO, [
            C[8] || (C[8] = f("label", null, "Threshold", -1)),
            st(f("input", {
              type: "range",
              "onUpdate:modelValue": C[1] || (C[1] = (T) => r.value.threshold = T),
              min: "0",
              max: "1",
              step: "0.01"
            }, null, 512), [
              [
                Ut,
                r.value.threshold,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", $O, _e(r.value.threshold.toFixed(2)), 1)
          ]),
          f("div", WO, [
            C[9] || (C[9] = f("label", null, "Min Peak Distance", -1)),
            st(f("input", {
              type: "range",
              "onUpdate:modelValue": C[2] || (C[2] = (T) => r.value.minPeaksDistance = T),
              min: "1",
              max: "60",
              step: "1"
            }, null, 512), [
              [
                Ut,
                r.value.minPeaksDistance,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", XO, _e(r.value.minPeaksDistance) + " frames", 1)
          ]),
          f("div", jO, [
            C[10] || (C[10] = f("label", null, "Multiply", -1)),
            st(f("input", {
              type: "range",
              "onUpdate:modelValue": C[3] || (C[3] = (T) => r.value.multiply = T),
              min: "0.1",
              max: "5",
              step: "0.1"
            }, null, 512), [
              [
                Ut,
                r.value.multiply,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", YO, _e(r.value.multiply.toFixed(1)) + "x", 1)
          ]),
          f("div", qO, [
            f("button", {
              class: "action-btn",
              onClick: g
            }, [...C[11] || (C[11] = [
              f("i", { class: "pi pi-bolt" }, null, -1),
              ct(" Detect Peaks ", -1)
            ])]),
            o.value ? (te(), ae("span", ZO, _e(o.value.count) + " peaks found ", 1)) : Pe("", !0)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", KO, [
        f("div", {
          class: "section-header",
          onClick: C[4] || (C[4] = (T) => v("mappings"))
        }, [
          f("i", {
            class: Fe(["pi", n.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[12] || (C[12] = f("span", null, "Audio Mappings", -1)),
          f("span", JO, _e(a.value.length), 1)
        ]),
        n.value.has("mappings") ? (te(), ae("div", QO, [
          f("button", {
            class: "action-btn add-mapping-btn",
            onClick: x
          }, [...C[13] || (C[13] = [
            f("i", { class: "pi pi-plus" }, null, -1),
            ct(" Add Mapping ", -1)
          ])]),
          (te(!0), ae(qe, null, ot(a.value, (T) => {
            var P, E, y;
            return te(), ae("div", {
              key: T.id,
              class: "mapping-item"
            }, [
              f("div", ez, [
                f("label", tz, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": (w) => T.enabled = w
                  }, null, 8, nz), [
                    [_i, T.enabled]
                  ])
                ]),
                f("span", iz, _e(Ve(Vd)(T.feature)) + "  " + _e(Ve(Cv)(T.target)), 1),
                f("button", {
                  class: "delete-btn",
                  onClick: (w) => M(T.id)
                }, [...C[14] || (C[14] = [
                  f("i", { class: "pi pi-times" }, null, -1)
                ])], 8, sz)
              ]),
              i.value.has(T.id) ? (te(), ae("div", rz, [
                f("div", oz, [
                  C[15] || (C[15] = f("label", null, "Feature", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => T.feature = w
                  }, [
                    (te(!0), ae(qe, null, ot(d.value, (w, D) => (te(), ae("optgroup", {
                      key: D,
                      label: D
                    }, [
                      (te(!0), ae(qe, null, ot(w, (U) => (te(), ae("option", {
                        key: U,
                        value: U
                      }, _e(Ve(Vd)(U)), 9, cz))), 128))
                    ], 8, lz))), 128))
                  ], 8, az), [
                    [Cn, T.feature]
                  ])
                ]),
                f("div", uz, [
                  C[16] || (C[16] = f("label", null, "Target", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => T.target = w
                  }, [
                    (te(!0), ae(qe, null, ot(h.value, (w, D) => (te(), ae("optgroup", {
                      key: D,
                      label: D
                    }, [
                      (te(!0), ae(qe, null, ot(w, (U) => (te(), ae("option", {
                        key: U,
                        value: U
                      }, _e(Ve(Cv)(U)), 9, fz))), 128))
                    ], 8, hz))), 128))
                  ], 8, dz), [
                    [Cn, T.target]
                  ])
                ]),
                C[30] || (C[30] = f("div", { class: "subsection-header" }, "Basic Controls", -1)),
                f("div", pz, [
                  C[17] || (C[17] = f("label", null, "Sensitivity", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => T.sensitivity = w,
                    min: "0.1",
                    max: "5",
                    step: "0.1"
                  }, null, 8, mz), [
                    [
                      Ut,
                      T.sensitivity,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", vz, _e(T.sensitivity.toFixed(1)) + "x", 1)
                ]),
                f("div", gz, [
                  C[18] || (C[18] = f("label", null, "Threshold", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => T.threshold = w,
                    min: "0",
                    max: "1",
                    step: "0.01"
                  }, null, 8, yz), [
                    [
                      Ut,
                      T.threshold,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", xz, _e(T.threshold.toFixed(2)), 1)
                ]),
                f("div", _z, [
                  C[19] || (C[19] = f("label", null, "Smoothing", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => T.smoothing = w,
                    min: "0",
                    max: "0.99",
                    step: "0.01"
                  }, null, 8, bz), [
                    [
                      Ut,
                      T.smoothing,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", wz, _e(T.smoothing.toFixed(2)), 1)
                ]),
                f("div", Sz, [
                  C[20] || (C[20] = f("label", null, "Min/Max", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": (w) => T.min = w,
                    step: "0.1",
                    class: "small-input"
                  }, null, 8, Mz), [
                    [
                      Ut,
                      T.min,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  C[21] || (C[21] = f("span", { class: "separator" }, "-", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": (w) => T.max = w,
                    step: "0.1",
                    class: "small-input"
                  }, null, 8, Cz), [
                    [
                      Ut,
                      T.max,
                      void 0,
                      { number: !0 }
                    ]
                  ])
                ]),
                C[31] || (C[31] = f("div", { class: "subsection-header" }, "ATI-Style Effects", -1)),
                f("div", Tz, [
                  C[22] || (C[22] = f("label", { title: ">1 = expander (emphasize loud), <1 = compressor (boost quiet)" }, "Amp Curve", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => T.amplitudeCurve = w,
                    min: "0.1",
                    max: "4",
                    step: "0.1"
                  }, null, 8, Ez), [
                    [
                      Ut,
                      T.amplitudeCurve,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", Az, _e(((P = T.amplitudeCurve) == null ? void 0 : P.toFixed(1)) || "1.0"), 1)
                ]),
                f("div", Pz, [
                  C[23] || (C[23] = f("label", { title: "How slowly the value decays after a peak (0=instant, 1=slow)" }, "Release", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => T.release = w,
                    min: "0",
                    max: "1",
                    step: "0.01"
                  }, null, 8, Rz), [
                    [
                      Ut,
                      T.release,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", Dz, _e(((E = T.release) == null ? void 0 : E.toFixed(2)) || "0.50"), 1)
                ]),
                f("div", kz, [
                  C[25] || (C[25] = f("label", null, "Curve", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => T.curve = w,
                    class: "curve-select"
                  }, [...C[24] || (C[24] = [
                    ls('<option value="linear" data-v-0611c34c>Linear</option><option value="exponential" data-v-0611c34c>Exponential</option><option value="logarithmic" data-v-0611c34c>Logarithmic</option><option value="smoothstep" data-v-0611c34c>Smoothstep</option><option value="bounce" data-v-0611c34c>Bounce</option>', 5)
                  ])], 8, Iz), [
                    [Cn, T.curve]
                  ])
                ]),
                C[32] || (C[32] = f("div", { class: "subsection-header" }, "Beat Response", -1)),
                f("div", Lz, [
                  C[27] || (C[27] = f("label", null, "On Beat", -1)),
                  st(f("select", {
                    "onUpdate:modelValue": (w) => T.beatResponse = w,
                    class: "beat-select"
                  }, [...C[26] || (C[26] = [
                    f("option", { value: "none" }, "None", -1),
                    f("option", { value: "flip" }, "Flip (reverse direction)", -1),
                    f("option", { value: "pulse" }, "Pulse (spike to max)", -1),
                    f("option", { value: "toggle" }, "Toggle (0/1 switch)", -1)
                  ])], 8, Fz), [
                    [Cn, T.beatResponse]
                  ])
                ]),
                T.beatResponse !== "none" ? (te(), ae("div", Uz, [
                  C[28] || (C[28] = f("label", { title: "Lower = more sensitive to quieter beats" }, "Beat Sens.", -1)),
                  st(f("input", {
                    type: "range",
                    "onUpdate:modelValue": (w) => T.beatThreshold = w,
                    min: "0.01",
                    max: "1",
                    step: "0.01"
                  }, null, 8, Oz), [
                    [
                      Ut,
                      T.beatThreshold,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  f("span", zz, _e(((y = T.beatThreshold) == null ? void 0 : y.toFixed(2)) || "0.50"), 1)
                ])) : Pe("", !0),
                f("div", Nz, [
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": (w) => T.invert = w
                    }, null, 8, Bz), [
                      [_i, T.invert]
                    ]),
                    C[29] || (C[29] = ct(" Invert Output ", -1))
                  ])
                ])
              ])) : Pe("", !0),
              f("button", {
                class: "expand-btn",
                onClick: (w) => _(T.id)
              }, [
                f("i", {
                  class: Fe(["pi", i.value.has(T.id) ? "pi-chevron-up" : "pi-chevron-down"])
                }, null, 2)
              ], 8, Vz)
            ]);
          }), 128))
        ])) : Pe("", !0)
      ]),
      f("div", Gz, [
        f("div", {
          class: "section-header",
          onClick: C[5] || (C[5] = (T) => v("visualizer"))
        }, [
          f("i", {
            class: Fe(["pi", n.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[33] || (C[33] = f("span", null, "Feature Visualizer", -1))
        ]),
        n.value.has("visualizer") ? (te(), ae("div", Hz, [
          f("div", $z, [
            C[34] || (C[34] = f("label", null, "Feature", -1)),
            st(f("select", {
              "onUpdate:modelValue": C[6] || (C[6] = (T) => l.value = T)
            }, [
              (te(!0), ae(qe, null, ot(u.value, (T) => (te(), ae("option", {
                key: T,
                value: T
              }, _e(Ve(Vd)(T)), 9, Wz))), 128))
            ], 512), [
              [Cn, l.value]
            ])
          ]),
          f("div", Xz, [
            f("canvas", {
              ref_key: "visualizerCanvas",
              ref: c,
              class: "visualizer-canvas",
              width: "240",
              height: "60"
            }, null, 512),
            f("div", {
              class: "visualizer-playhead",
              style: yt({ left: `${m.value}%` })
            }, null, 4)
          ]),
          f("div", jz, " Current: " + _e(p.value.toFixed(3)), 1)
        ])) : Pe("", !0)
      ])
    ]));
  }
}), qz = /* @__PURE__ */ Gt(Yz, [["__scopeId", "data-v-0611c34c"]]), Zz = { class: "audio-panel" }, Kz = {
  key: 0,
  class: "panel-content"
}, Jz = { class: "audio-info" }, Qz = { class: "file-info" }, e6 = { class: "file-details" }, t6 = { class: "file-name" }, n6 = { class: "file-meta" }, i6 = { class: "control-section" }, s6 = { class: "control-row" }, r6 = { class: "waveform-section" }, o6 = { class: "waveform-display" }, a6 = { class: "linker-section" }, l6 = {
  key: 1,
  class: "empty-state"
}, c6 = /* @__PURE__ */ Ot({
  __name: "AudioPanel",
  setup(s) {
    const e = sn(), n = we(null), i = we(null), r = we(100), o = we(!1), a = Ie(() => !!e.audioBuffer), l = Ie(() => {
      var _;
      return ((_ = e.audioFile) == null ? void 0 : _.name) || "Unknown";
    }), c = Ie(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : ""), u = Ie(() => {
      if (!e.audioBuffer) return "0:00";
      const _ = Math.floor(e.audioBuffer.duration / 60), g = Math.floor(e.audioBuffer.duration % 60);
      return `${_}:${g.toString().padStart(2, "0")}`;
    });
    function d() {
      var _;
      (_ = n.value) == null || _.click();
    }
    async function h(_) {
      var x;
      const g = _.target;
      (x = g.files) != null && x.length && await e.loadAudio(g.files[0]), g.value = "";
    }
    function m() {
      e.clearAudio();
    }
    function p() {
      o.value = !o.value;
    }
    function v() {
      if (!i.value || !e.audioBuffer) return;
      const _ = i.value, g = _.getContext("2d");
      if (!g) return;
      const x = _.getBoundingClientRect();
      _.width = x.width * window.devicePixelRatio, _.height = 60 * window.devicePixelRatio, g.scale(window.devicePixelRatio, window.devicePixelRatio);
      const M = e.audioBuffer.getChannelData(0), S = Math.ceil(M.length / x.width), b = 30;
      g.fillStyle = "#1a1a1a", g.fillRect(0, 0, x.width, 60), g.beginPath(), g.strokeStyle = "#4a90d9", g.lineWidth = 1;
      for (let T = 0; T < x.width; T++) {
        let P = 1, E = -1;
        for (let y = 0; y < S; y++) {
          const w = M[T * S + y];
          w < P && (P = w), w > E && (E = w);
        }
        g.moveTo(T, (1 + P) * b), g.lineTo(T, (1 + E) * b);
      }
      g.stroke();
      const C = e.currentFrame / e.frameCount * x.width;
      g.fillStyle = "#fff", g.fillRect(C, 0, 1, 60);
    }
    return Ft(() => [e.audioBuffer, e.currentFrame], v), xn(() => {
      a.value && setTimeout(v, 100);
    }), (_, g) => (te(), ae("div", Zz, [
      f("div", { class: "panel-header" }, [
        g[2] || (g[2] = f("span", { class: "panel-title" }, "Audio Source", -1)),
        f("div", { class: "header-actions" }, [
          f("button", {
            onClick: d,
            title: "Load Audio"
          }, [...g[1] || (g[1] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      a.value ? (te(), ae("div", Kz, [
        f("div", Jz, [
          f("div", Qz, [
            g[3] || (g[3] = f("span", { class: "file-icon" }, "", -1)),
            f("div", e6, [
              f("span", t6, _e(l.value), 1),
              f("span", n6, _e(u.value) + "  " + _e(c.value), 1)
            ]),
            f("button", {
              class: "remove-btn",
              onClick: m,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        f("div", i6, [
          f("div", s6, [
            g[4] || (g[4] = f("label", null, "Master Vol", -1)),
            ze(Ve(jn), {
              modelValue: r.value,
              "onUpdate:modelValue": g[0] || (g[0] = (x) => r.value = x),
              min: 0,
              max: 100,
              unit: "%"
            }, null, 8, ["modelValue"]),
            f("button", {
              class: Fe(["mute-btn", { active: o.value }]),
              onClick: p,
              title: "Mute"
            }, _e(o.value ? "" : ""), 3)
          ])
        ]),
        f("div", r6, [
          g[5] || (g[5] = f("div", { class: "section-header" }, [
            f("span", { class: "section-title" }, "Waveform")
          ], -1)),
          f("div", o6, [
            f("canvas", {
              ref_key: "waveformCanvas",
              ref: i,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        f("div", a6, [
          g[6] || (g[6] = f("div", { class: "linker-header" }, "Audio Linker", -1)),
          ze(qz)
        ])
      ])) : (te(), ae("div", l6, [
        g[7] || (g[7] = f("div", { class: "empty-icon" }, "", -1)),
        g[8] || (g[8] = f("p", null, "No audio loaded", -1)),
        f("button", {
          class: "load-btn",
          onClick: d
        }, "Load Audio File"),
        g[9] || (g[9] = f("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      f("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: h
      }, null, 544)
    ]));
  }
}), u6 = /* @__PURE__ */ Gt(c6, [["__scopeId", "data-v-66384e06"]]), Av = 40, d6 = 30;
function h6(s) {
  const e = [], n = "#ffcc00", i = s.position;
  let r;
  if (s.type === "two-node")
    r = Rs(Zf(s.pointOfInterest, i));
  else {
    const p = s.orientation.x * Math.PI / 180, v = s.orientation.y * Math.PI / 180;
    r = wt(
      Math.sin(v) * Math.cos(p),
      -Math.sin(p),
      Math.cos(v) * Math.cos(p)
    );
  }
  const o = wt(0, -1, 0);
  let a = Rs(Yo(r, o));
  isNaN(a.x) && (a = wt(1, 0, 0));
  const l = Rs(Yo(a, r)), c = Av / 2, u = At(i, Dt(r, -Av)), d = [];
  for (let p = 0; p < 2; p++) {
    const v = p === 0 ? i : u;
    for (let _ = -1; _ <= 1; _ += 2)
      for (let g = -1; g <= 1; g += 2)
        d.push(At(
          At(v, Dt(a, _ * c)),
          Dt(l, g * c)
        ));
  }
  e.push({ start: d[0], end: d[1], color: n }), e.push({ start: d[1], end: d[3], color: n }), e.push({ start: d[3], end: d[2], color: n }), e.push({ start: d[2], end: d[0], color: n }), e.push({ start: d[4], end: d[5], color: n }), e.push({ start: d[5], end: d[7], color: n }), e.push({ start: d[7], end: d[6], color: n }), e.push({ start: d[6], end: d[4], color: n }), e.push({ start: d[0], end: d[4], color: n }), e.push({ start: d[1], end: d[5], color: n }), e.push({ start: d[2], end: d[6], color: n }), e.push({ start: d[3], end: d[7], color: n });
  const h = At(i, Dt(r, d6)), m = 8;
  for (let p = 0; p < m; p++) {
    const v = p / m * Math.PI * 2, _ = (p + 1) / m * Math.PI * 2, g = At(
      At(i, Dt(a, Math.cos(v) * c * 0.5)),
      Dt(l, Math.sin(v) * c * 0.5)
    ), x = At(
      At(i, Dt(a, Math.cos(_) * c * 0.5)),
      Dt(l, Math.sin(_) * c * 0.5)
    );
    e.push({ start: g, end: x, color: n }), e.push({ start: g, end: h, color: n });
  }
  return e;
}
function f6(s, e, n, i = 2e3) {
  const r = [], o = "#7c9cff", a = Tl(s.focalLength, s.filmSize), l = e / n, c = s.position;
  let u;
  if (s.type === "two-node")
    u = Rs(Zf(s.pointOfInterest, c));
  else {
    const P = s.orientation.x * Math.PI / 180, E = s.orientation.y * Math.PI / 180;
    u = wt(
      Math.sin(E) * Math.cos(P),
      -Math.sin(P),
      Math.cos(E) * Math.cos(P)
    );
  }
  const d = wt(0, -1, 0);
  let h = Rs(Yo(u, d));
  isNaN(h.x) && (h = wt(1, 0, 0));
  const m = Rs(Yo(h, u)), p = s.nearClip, v = Math.min(s.farClip, i), _ = p * Math.tan(a * Math.PI / 360), g = _ * l, x = v * Math.tan(a * Math.PI / 360), M = x * l, S = At(c, Dt(u, p)), b = [
    At(At(S, Dt(h, -g)), Dt(m, _)),
    At(At(S, Dt(h, g)), Dt(m, _)),
    At(At(S, Dt(h, g)), Dt(m, -_)),
    At(At(S, Dt(h, -g)), Dt(m, -_))
  ], C = At(c, Dt(u, v)), T = [
    At(At(C, Dt(h, -M)), Dt(m, x)),
    At(At(C, Dt(h, M)), Dt(m, x)),
    At(At(C, Dt(h, M)), Dt(m, -x)),
    At(At(C, Dt(h, -M)), Dt(m, -x))
  ];
  for (let P = 0; P < 4; P++)
    r.push({ start: b[P], end: b[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    r.push({ start: T[P], end: T[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    r.push({ start: b[P], end: T[P], color: o });
  return r;
}
function p6(s, e) {
  const n = "#00ff88", i = [
    wt(0, 0, 0),
    wt(s, 0, 0),
    wt(s, e, 0),
    wt(0, e, 0)
  ], r = [];
  for (let o = 0; o < 4; o++)
    r.push({ start: i[o], end: i[(o + 1) % 4], color: n });
  return r.push({ start: i[0], end: i[2], color: "#005533" }), r.push({ start: i[1], end: i[3], color: "#005533" }), r;
}
function m6(s) {
  return s.type !== "two-node" ? null : {
    start: s.position,
    end: s.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function v6(s, e, n) {
  if (!s.depthOfField.enabled)
    return [];
  const i = "#ff00ff", r = [], o = s.position, a = s.depthOfField.focusDistance;
  let l;
  if (s.type === "two-node")
    l = Rs(Zf(s.pointOfInterest, o));
  else {
    const _ = s.orientation.x * Math.PI / 180, g = s.orientation.y * Math.PI / 180;
    l = wt(
      Math.sin(g) * Math.cos(_),
      -Math.sin(_),
      Math.cos(g) * Math.cos(_)
    );
  }
  const c = wt(0, -1, 0);
  let u = Rs(Yo(l, c));
  isNaN(u.x) && (u = wt(1, 0, 0));
  const d = Rs(Yo(u, l)), h = At(o, Dt(l, a)), m = e / 4, p = n / 4, v = [
    At(At(h, Dt(u, -m)), Dt(d, p)),
    At(At(h, Dt(u, m)), Dt(d, p)),
    At(At(h, Dt(u, m)), Dt(d, -p)),
    At(At(h, Dt(u, -m)), Dt(d, -p))
  ];
  for (let _ = 0; _ < 4; _++)
    r.push({ start: v[_], end: v[(_ + 1) % 4], color: i });
  return r;
}
function Pv(s, e, n, i = !0, r = !0, o = !1) {
  return {
    body: h6(s),
    frustum: i ? f6(s, e, n) : [],
    compositionBounds: r ? p6(e, n) : [],
    poiLine: m6(s),
    focalPlane: o ? v6(s, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function g6(s, e, n) {
  const i = e / n, r = Tl(s.focalLength, s.filmSize);
  let o;
  if (s.type === "two-node")
    o = s.pointOfInterest;
  else {
    const u = s.orientation.x * Math.PI / 180, d = s.orientation.y * Math.PI / 180, h = wt(
      Math.sin(d) * Math.cos(u),
      -Math.sin(u),
      Math.cos(d) * Math.cos(u)
    );
    o = At(s.position, Dt(h, 1e3));
  }
  const a = es(s.position, o, wt(0, -1, 0)), l = YT(r, i, s.nearClip, s.farClip), c = Ly(l, a);
  return { view: a, projection: l, viewProjection: c };
}
function Rv(s, e, n, i) {
  const r = e / n;
  let o, a = 1e3;
  const l = e / 2, c = n / 2;
  switch (s) {
    case "front":
      o = es(
        wt(l, c, -2e3),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "back":
      o = es(
        wt(l, c, 2e3),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "left":
      o = es(
        wt(-2e3, c, 0),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "right":
      o = es(
        wt(l + 2e3, c, 0),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
      break;
    case "top":
      o = es(
        wt(l, -2e3, 0),
        wt(l, c, 0),
        wt(0, 0, 1)
      );
      break;
    case "bottom":
      o = es(
        wt(l, c + 2e3, 0),
        wt(l, c, 0),
        wt(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (i) {
        const h = i.orbitPhi * Math.PI / 180, m = i.orbitTheta * Math.PI / 180, p = i.orbitDistance, v = wt(
          i.orbitCenter.x + p * Math.sin(h) * Math.sin(m),
          i.orbitCenter.y + p * Math.cos(h),
          i.orbitCenter.z + p * Math.sin(h) * Math.cos(m)
        );
        o = es(
          v,
          i.orbitCenter,
          wt(0, -1, 0)
        ), a = 1e3 / i.orthoZoom;
      } else
        o = es(
          wt(l, c, -2e3),
          wt(l, c, 0),
          wt(0, -1, 0)
        );
      break;
    default:
      o = es(
        wt(l, c, -2e3),
        wt(l, c, 0),
        wt(0, -1, 0)
      );
  }
  const u = qT(
    -a * r,
    a * r,
    -a,
    a,
    1,
    1e4
  ), d = Ly(u, o);
  return { view: o, projection: u, viewProjection: d };
}
function Ly(s, e) {
  const n = s.elements, i = e.elements, r = new Float32Array(16);
  for (let o = 0; o < 4; o++)
    for (let a = 0; a < 4; a++) {
      let l = 0;
      for (let c = 0; c < 4; c++)
        l += n[o + c * 4] * i[c + a * 4];
      r[o + a * 4] = l;
    }
  return { elements: r };
}
function Gd(s, e, n, i) {
  const r = ZT(e, s), o = e.elements, a = s.x * o[3] + s.y * o[7] + s.z * o[11] + o[15];
  if (a <= 0)
    return { x: 0, y: 0, z: r.z, visible: !1 };
  const l = (r.x / a * 0.5 + 0.5) * n, c = (-r.y / a * 0.5 + 0.5) * i;
  return {
    x: l,
    y: c,
    z: r.z / a,
    visible: !0
  };
}
function y6(s, e = 100) {
  return [
    { start: s, end: At(s, wt(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: s, end: At(s, wt(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: s, end: At(s, wt(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function x6(s, e, n = 100) {
  const i = [], r = "#333333", o = "#444444", a = s / 2, l = e / 2, c = Math.max(s, e);
  for (let u = -c; u <= c + s; u += n) {
    const d = Math.abs(u - a) < n / 2;
    i.push({
      start: wt(u, -c, 0),
      end: wt(u, c + e, 0),
      color: d ? o : r
    });
  }
  for (let u = -c; u <= c + e; u += n) {
    const d = Math.abs(u - l) < n / 2;
    i.push({
      start: wt(-c, u, 0),
      end: wt(c + s, u, 0),
      color: d ? o : r
    });
  }
  return i;
}
const _6 = ["onClick"], b6 = { class: "view-header" }, w6 = ["value", "onChange"], S6 = { class: "view-tools" }, M6 = ["onClick"], C6 = ["onMousedown", "onWheel"], T6 = { class: "view-info" }, E6 = { class: "view-name" }, A6 = {
  key: 0,
  class: "view-coords"
}, P6 = { class: "layout-controls" }, R6 = ["onClick", "title"], D6 = /* @__PURE__ */ Ot({
  __name: "ViewportRenderer",
  setup(s) {
    const e = sn(), n = Ie(() => e.activeCamera), i = Ie(() => e.width), r = Ie(() => e.height), o = Ie(() => e.viewportState), a = Ie(() => e.viewOptions), l = Ie(() => e.layers.filter((le) => le.type !== "camera").map((le) => ({
      id: le.id,
      name: le.name,
      position: {
        x: le.transform.position.value.x,
        y: le.transform.position.value.y,
        z: 0
        // 2D layers at z=0
      },
      selected: e.selectedLayerIds.includes(le.id)
    }))), c = we([null, null, null, null]), u = we([null, null, null, null]), d = we(!1), h = we({ x: 0, y: 0 }), m = we(0), p = we(0), v = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], _ = Ie(() => o.value.layout), g = Ie(() => o.value.activeViewIndex), x = Ie(() => o.value.customViews), M = Ie(() => {
      switch (o.value.layout) {
        case "1-view":
          return [o.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return o.value.views.slice(0, 2);
        case "4-view":
          return o.value.views.slice(0, 4);
        default:
          return [o.value.views[0]];
      }
    });
    function S(le, re) {
      c.value[re] = le, le && (u.value[re] = le.getContext("2d"));
    }
    function b(le) {
      return le.startsWith("custom-");
    }
    function C(le) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[le];
    }
    function T(le) {
      e.updateViewportState({
        activeViewIndex: le
      });
    }
    function P(le, re) {
      const j = [...o.value.views];
      j[le] = re, e.updateViewportState({
        views: j
      });
    }
    function E(le) {
      const re = ["active-camera", "top", "front", "right"];
      let j = [...o.value.views];
      for (; j.length < 4; )
        j.push(re[j.length] || "front");
      e.updateViewportState({
        layout: le,
        views: j,
        activeViewIndex: Math.min(o.value.activeViewIndex, y(le) - 1)
      });
    }
    function y(le) {
      switch (le) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function w(le) {
      const re = {
        orbitCenter: { x: i.value / 2, y: r.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      e.updateViewportState({
        customViews: {
          ...o.value.customViews,
          [le]: re
        }
      });
    }
    function D(le, re) {
      d.value = !0, h.value = { x: le.clientX, y: le.clientY }, m.value = re, p.value = le.button, document.addEventListener("mousemove", U), document.addEventListener("mouseup", R);
    }
    function U(le) {
      if (!d.value) return;
      const re = le.clientX - h.value.x, j = le.clientY - h.value.y;
      h.value = { x: le.clientX, y: le.clientY };
      const $ = M.value[m.value];
      if (b($)) {
        const q = x.value[$];
        if (p.value === 0) {
          const oe = q.orbitTheta + re * 0.5, ie = Math.max(1, Math.min(179, q.orbitPhi + j * 0.5));
          e.updateViewportState({
            customViews: {
              ...o.value.customViews,
              [$]: {
                ...q,
                orbitTheta: oe,
                orbitPhi: ie
              }
            }
          });
        } else (p.value === 1 || p.value === 2) && e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [$]: {
              ...q,
              orthoOffset: {
                x: q.orthoOffset.x + re,
                y: q.orthoOffset.y + j
              }
            }
          }
        });
      }
    }
    function R() {
      d.value = !1, document.removeEventListener("mousemove", U), document.removeEventListener("mouseup", R);
    }
    function O(le, re) {
      le.preventDefault();
      const j = M.value[re];
      if (b(j)) {
        const $ = x.value[j], q = le.deltaY > 0 ? 1.1 : 0.9;
        e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [j]: {
              ...$,
              orbitDistance: $.orbitDistance * q
            }
          }
        });
      }
    }
    function A() {
      M.value.forEach((le, re) => {
        const j = c.value[re], $ = u.value[re];
        if (!j || !$) return;
        const q = j.getBoundingClientRect(), oe = window.devicePixelRatio || 1;
        j.width = q.width * oe, j.height = q.height * oe, $.scale(oe, oe), $.fillStyle = "#1a1a1a", $.fillRect(0, 0, q.width, q.height);
        let ie;
        le === "active-camera" && n.value ? ie = g6(n.value, i.value, r.value) : b(le) ? ie = Rv(le, i.value, r.value, x.value[le]) : ie = Rv(le, i.value, r.value);
        const ce = [];
        if (a.value.showGrid && ce.push(...x6(i.value, r.value)), a.value.show3DReferenceAxes && ce.push(...y6(wt(i.value / 2, r.value / 2, 0))), a.value.showCompositionBounds) {
          const V = Pv(
            n.value ?? G(),
            i.value,
            r.value,
            !1,
            !0,
            !1
          );
          ce.push(...V.compositionBounds);
        }
        if (le !== "active-camera" && n.value && (a.value.cameraWireframes === "always" || a.value.cameraWireframes === "selected")) {
          const Y = Pv(
            n.value,
            i.value,
            r.value,
            !0,
            !1,
            a.value.showFocalPlane
          );
          ce.push(...Y.body), ce.push(...Y.frustum), ce.push(...Y.focalPlane), Y.poiLine && ce.push(Y.poiLine);
        }
        for (const V of ce) {
          const Y = Gd(V.start, ie.viewProjection, q.width, q.height), H = Gd(V.end, ie.viewProjection, q.width, q.height);
          !Y.visible && !H.visible || ($.beginPath(), $.strokeStyle = V.color, $.lineWidth = 1, $.moveTo(Y.x, Y.y), $.lineTo(H.x, H.y), $.stroke());
        }
        if (a.value.showLayerHandles)
          for (const V of l.value) {
            const Y = Gd(V.position, ie.viewProjection, q.width, q.height);
            Y.visible && ($.beginPath(), $.fillStyle = V.selected ? "#ffcc00" : "#888888", $.arc(Y.x, Y.y, V.selected ? 6 : 4, 0, Math.PI * 2), $.fill(), $.fillStyle = "#ffffff", $.font = "10px sans-serif", $.fillText(V.name, Y.x + 8, Y.y + 4));
          }
      });
    }
    function G() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: i.value / 2, y: r.value / 2, z: -1500 },
        pointOfInterest: { x: i.value / 2, y: r.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let ue;
    function Q() {
      A(), ue = requestAnimationFrame(Q);
    }
    return xn(() => {
      Q();
    }), Nn(() => {
      cancelAnimationFrame(ue);
    }), Ft([n, o, a, l], () => {
    }, { deep: !0 }), (le, re) => (te(), ae("div", {
      class: Fe(["viewport-renderer", [`layout-${_.value}`]])
    }, [
      (te(!0), ae(qe, null, ot(M.value, (j, $) => {
        var q, oe;
        return te(), ae("div", {
          key: $,
          class: Fe(["view-panel", { active: $ === g.value }]),
          onClick: (ie) => T($)
        }, [
          f("div", b6, [
            f("select", {
              value: j,
              onChange: (ie) => P($, ie.target.value),
              class: "view-select"
            }, [...re[1] || (re[1] = [
              ls('<option value="active-camera" data-v-cdf0e094>Active Camera</option><option value="custom-1" data-v-cdf0e094>Custom View 1</option><option value="custom-2" data-v-cdf0e094>Custom View 2</option><option value="custom-3" data-v-cdf0e094>Custom View 3</option><option value="front" data-v-cdf0e094>Front</option><option value="back" data-v-cdf0e094>Back</option><option value="left" data-v-cdf0e094>Left</option><option value="right" data-v-cdf0e094>Right</option><option value="top" data-v-cdf0e094>Top</option><option value="bottom" data-v-cdf0e094>Bottom</option>', 10)
            ])], 40, w6),
            f("div", S6, [
              b(j) ? (te(), ae("button", {
                key: 0,
                onClick: xt((ie) => w(j), ["stop"]),
                title: "Reset View"
              }, [...re[2] || (re[2] = [
                f("span", { class: "icon" }, "", -1)
              ])], 8, M6)) : Pe("", !0)
            ])
          ]),
          f("canvas", {
            ref_for: !0,
            ref: (ie) => S(ie, $),
            class: "view-canvas",
            onMousedown: (ie) => D(ie, $),
            onWheel: (ie) => O(ie, $),
            onContextmenu: re[0] || (re[0] = xt(() => {
            }, ["prevent"]))
          }, null, 40, C6),
          f("div", T6, [
            f("span", E6, _e(C(j)), 1),
            b(j) ? (te(), ae("span", A6, " : " + _e(Math.round(((q = x.value[j]) == null ? void 0 : q.orbitTheta) ?? 0)) + " : " + _e(Math.round(((oe = x.value[j]) == null ? void 0 : oe.orbitPhi) ?? 0)) + " ", 1)) : Pe("", !0)
          ])
        ], 10, _6);
      }), 128)),
      f("div", P6, [
        (te(), ae(qe, null, ot(v, (j) => f("button", {
          key: j.value,
          class: Fe({ active: _.value === j.value }),
          onClick: ($) => E(j.value),
          title: j.label
        }, _e(j.icon), 11, R6)), 64))
      ])
    ], 2));
  }
}), k6 = /* @__PURE__ */ Gt(D6, [["__scopeId", "data-v-cdf0e094"]]), Mr = new qf(), Wn = new de(), Ys = new de(), on = new ni(), Dv = {
  X: new de(1, 0, 0),
  Y: new de(0, 1, 0),
  Z: new de(0, 0, 1)
}, Hd = { type: "change" }, kv = { type: "mouseDown", mode: null }, Iv = { type: "mouseUp", mode: null }, Lv = { type: "objectChange" };
class I6 extends AT {
  constructor(e, n = null) {
    super(void 0, n);
    const i = new N6(this);
    this._root = i;
    const r = new B6();
    this._gizmo = r, i.add(r);
    const o = new V6();
    this._plane = o, i.add(o);
    const a = this;
    function l(S, b) {
      let C = b;
      Object.defineProperty(a, S, {
        get: function() {
          return C !== void 0 ? C : b;
        },
        set: function(T) {
          C !== T && (C = T, o[S] = T, r[S] = T, a.dispatchEvent({ type: S + "-changed", value: T }), a.dispatchEvent(Hd));
        }
      }), a[S] = b, o[S] = b, r[S] = b;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "world"), l("size", 1), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0), l("minX", -1 / 0), l("maxX", 1 / 0), l("minY", -1 / 0), l("maxY", 1 / 0), l("minZ", -1 / 0), l("maxZ", 1 / 0);
    const c = new de(), u = new de(), d = new ni(), h = new ni(), m = new de(), p = new ni(), v = new de(), _ = new de(), g = new de(), x = 0, M = new de();
    l("worldPosition", c), l("worldPositionStart", u), l("worldQuaternion", d), l("worldQuaternionStart", h), l("cameraPosition", m), l("cameraQuaternion", p), l("pointStart", v), l("pointEnd", _), l("rotationAxis", g), l("rotationAngle", x), l("eye", M), this._offset = new de(), this._startNorm = new de(), this._endNorm = new de(), this._cameraScale = new de(), this._parentPosition = new de(), this._parentQuaternion = new ni(), this._parentQuaternionInv = new ni(), this._parentScale = new de(), this._worldScaleStart = new de(), this._worldQuaternionInv = new ni(), this._worldScale = new de(), this._positionStart = new de(), this._quaternionStart = new ni(), this._scaleStart = new de(), this._getPointer = L6.bind(this), this._onPointerDown = U6.bind(this), this._onPointerHover = F6.bind(this), this._onPointerMove = O6.bind(this), this._onPointerUp = z6.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && Mr.setFromCamera(e, this.camera);
    const n = $d(this._gizmo.picker[this.mode], Mr);
    n ? this.axis = n.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && Mr.setFromCamera(e, this.camera);
      const n = $d(this._plane, Mr, !0);
      n && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(n.point).sub(this.worldPositionStart)), this.dragging = !0, kv.mode = this.mode, this.dispatchEvent(kv);
    }
  }
  pointerMove(e) {
    const n = this.axis, i = this.mode, r = this.object;
    let o = this.space;
    if (i === "scale" ? o = "local" : (n === "E" || n === "XYZE" || n === "XYZ") && (o = "world"), r === void 0 || n === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && Mr.setFromCamera(e, this.camera);
    const a = $d(this._plane, Mr, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), i === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && n !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), n.indexOf("X") === -1 && (this._offset.x = 0), n.indexOf("Y") === -1 && (this._offset.y = 0), n.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && n !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (r.position.applyQuaternion(on.copy(this._quaternionStart).invert()), n.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), o === "world" && (r.parent && r.position.add(Wn.setFromMatrixPosition(r.parent.matrixWorld)), n.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(Wn.setFromMatrixPosition(r.parent.matrixWorld)))), r.position.x = Math.max(this.minX, Math.min(this.maxX, r.position.x)), r.position.y = Math.max(this.minY, Math.min(this.maxY, r.position.y)), r.position.z = Math.max(this.minZ, Math.min(this.maxZ, r.position.z));
      else if (i === "scale") {
        if (n.search("XYZ") !== -1) {
          let l = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (l *= -1), Ys.set(l, l, l);
        } else
          Wn.copy(this.pointStart), Ys.copy(this.pointEnd), Wn.applyQuaternion(this._worldQuaternionInv), Ys.applyQuaternion(this._worldQuaternionInv), Ys.divide(Wn), n.search("X") === -1 && (Ys.x = 1), n.search("Y") === -1 && (Ys.y = 1), n.search("Z") === -1 && (Ys.z = 1);
        r.scale.copy(this._scaleStart).multiply(Ys), this.scaleSnap && (n.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const l = 20 / this.worldPosition.distanceTo(Wn.setFromMatrixPosition(this.camera.matrixWorld));
        let c = !1;
        n === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Wn.copy(this.rotationAxis).cross(this.eye)) * l) : (n === "X" || n === "Y" || n === "Z") && (this.rotationAxis.copy(Dv[n]), Wn.copy(Dv[n]), o === "local" && Wn.applyQuaternion(this.worldQuaternion), Wn.cross(this.eye), Wn.length() === 0 ? c = !0 : this.rotationAngle = this._offset.dot(Wn.normalize()) * l), (n === "E" || c) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && n !== "E" && n !== "XYZE" ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(on.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(on.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Hd), this.dispatchEvent(Lv);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (Iv.mode = this.mode, this.dispatchEvent(Iv)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Hd), this.dispatchEvent(Lv), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Mr;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function L6(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button
    };
  }
}
function F6(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function U6(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function O6(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function z6(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function $d(s, e, n) {
  const i = e.intersectObject(s, !0);
  for (let r = 0; r < i.length; r++)
    if (i[r].object.visible || n)
      return i[r];
  return !1;
}
const yc = new Mi(), Qt = new de(0, 1, 0), Fv = new de(0, 0, 0), Uv = new Zt(), xc = new ni(), Vc = new ni(), Qi = new de(), Ov = new Zt(), Ia = new de(1, 0, 0), Dr = new de(0, 1, 0), La = new de(0, 0, 1), _c = new de(), _a = new de(), ba = new de();
class N6 extends cn {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const n = this.controls;
    n.object !== void 0 && (n.object.updateMatrixWorld(), n.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : n.object.parent.matrixWorld.decompose(n._parentPosition, n._parentQuaternion, n._parentScale), n.object.matrixWorld.decompose(n.worldPosition, n.worldQuaternion, n._worldScale), n._parentQuaternionInv.copy(n._parentQuaternion).invert(), n._worldQuaternionInv.copy(n.worldQuaternion).invert()), n.camera.updateMatrixWorld(), n.camera.matrixWorld.decompose(n.cameraPosition, n.cameraQuaternion, n._cameraScale), n.camera.isOrthographicCamera ? n.camera.getWorldDirection(n.eye).negate() : n.eye.copy(n.cameraPosition).sub(n.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  dispose() {
    this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
}
class B6 extends cn {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Tn({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = new Yi({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = e.clone();
    i.opacity = 0.15;
    const r = n.clone();
    r.opacity = 0.5;
    const o = e.clone();
    o.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const l = e.clone();
    l.color.setHex(255);
    const c = e.clone();
    c.color.setHex(16711680), c.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(65280), u.opacity = 0.5;
    const d = e.clone();
    d.color.setHex(255), d.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const m = e.clone();
    m.color.setHex(16776960), m.opacity = 0.25, e.clone().color.setHex(16776960);
    const v = e.clone();
    v.color.setHex(7895160);
    const _ = new Ln(0, 0.04, 0.1, 12);
    _.translate(0, 0.05, 0);
    const g = new pn(0.08, 0.08, 0.08);
    g.translate(0, 0.04, 0);
    const x = new Vt();
    x.setAttribute("position", new Pt([0, 0, 0, 1, 0, 0], 3));
    const M = new Ln(75e-4, 75e-4, 0.5, 3);
    M.translate(0, 0.25, 0);
    function S(A, G) {
      const ue = new Lr(A, 75e-4, 3, 64, G * Math.PI * 2);
      return ue.rotateY(Math.PI / 2), ue.rotateX(Math.PI / 2), ue;
    }
    function b() {
      const A = new Vt();
      return A.setAttribute("position", new Pt([0, 0, 0, 1, 1, 1], 3)), A;
    }
    const C = {
      X: [
        [new Ze(_, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(_, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Ze(M, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Ze(_, a), [0, 0.5, 0]],
        [new Ze(_, a), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Ze(M, a)]
      ],
      Z: [
        [new Ze(_, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ze(_, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Ze(M, l), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new Ao(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Ze(new pn(0.15, 0.15, 0.01), d.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), c.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), u.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, T = {
      X: [
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new Ao(0.2, 0), i)]
      ],
      XY: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, P = {
      START: [
        [new Ze(new Ao(0.01, 2), r), null, null, null, "helper"]
      ],
      END: [
        [new Ze(new Ao(0.01, 2), r), null, null, null, "helper"]
      ],
      DELTA: [
        [new ln(b(), r), null, null, null, "helper"]
      ],
      X: [
        [new ln(x, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new ln(x, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new ln(x, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, E = {
      XYZE: [
        [new Ze(S(0.5, 1), v), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Ze(S(0.5, 0.5), o)]
      ],
      Y: [
        [new Ze(S(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Ze(S(0.5, 0.5), l), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Ze(S(0.75, 1), m), null, [0, Math.PI / 2, 0]]
      ]
    }, y = {
      AXIS: [
        [new ln(x, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, w = {
      XYZE: [
        [new Ze(new ku(0.25, 10, 8), i)]
      ],
      X: [
        [new Ze(new Lr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Ze(new Lr(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Ze(new Lr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Ze(new Lr(0.75, 0.1, 2, 24), i)]
      ]
    }, D = {
      X: [
        [new Ze(g, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(M, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(g, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ze(g, a), [0, 0.5, 0]],
        [new Ze(M, a)],
        [new Ze(g, a), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ze(g, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ze(M, l), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Ze(g, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ze(new pn(0.15, 0.15, 0.01), d), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), c), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.15, 0.15, 0.01), u), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new pn(0.1, 0.1, 0.1), h.clone())]
      ]
    }, U = {
      X: [
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ze(new Ln(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ze(new pn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ze(new pn(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, R = {
      X: [
        [new ln(x, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new ln(x, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new ln(x, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function O(A) {
      const G = new cn();
      for (const ue in A)
        for (let Q = A[ue].length; Q--; ) {
          const le = A[ue][Q][0].clone(), re = A[ue][Q][1], j = A[ue][Q][2], $ = A[ue][Q][3], q = A[ue][Q][4];
          le.name = ue, le.tag = q, re && le.position.set(re[0], re[1], re[2]), j && le.rotation.set(j[0], j[1], j[2]), $ && le.scale.set($[0], $[1], $[2]), le.updateMatrix();
          const oe = le.geometry.clone();
          oe.applyMatrix4(le.matrix), le.geometry = oe, le.renderOrder = 1 / 0, le.position.set(0, 0, 0), le.rotation.set(0, 0, 0), le.scale.set(1, 1, 1), G.add(le);
        }
      return G;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = O(C)), this.add(this.gizmo.rotate = O(E)), this.add(this.gizmo.scale = O(D)), this.add(this.picker.translate = O(T)), this.add(this.picker.rotate = O(w)), this.add(this.picker.scale = O(U)), this.add(this.helper.translate = O(P)), this.add(this.helper.rotate = O(y)), this.add(this.helper.scale = O(R)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Vc;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let r = [];
    r = r.concat(this.picker[this.mode].children), r = r.concat(this.gizmo[this.mode].children), r = r.concat(this.helper[this.mode].children);
    for (let o = 0; o < r.length; o++) {
      const a = r[o];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let l;
      if (this.camera.isOrthographicCamera ? l = (this.camera.top - this.camera.bottom) / this.camera.zoom : l = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(l * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (on.setFromEuler(yc.set(0, 0, 0)), a.quaternion.copy(i).multiply(on), Math.abs(Qt.copy(Ia).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (on.setFromEuler(yc.set(0, 0, Math.PI / 2)), a.quaternion.copy(i).multiply(on), Math.abs(Qt.copy(Dr).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (on.setFromEuler(yc.set(0, Math.PI / 2, 0)), a.quaternion.copy(i).multiply(on), Math.abs(Qt.copy(La).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (on.setFromEuler(yc.set(0, Math.PI / 2, 0)), Qt.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(Uv.lookAt(Fv, Qt, Dr)), a.quaternion.multiply(on), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), Wn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Wn.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(Wn), a.visible = this.dragging) : (a.quaternion.copy(i), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(i), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(Qt.copy(Ia).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(Qt.copy(Dr).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(Qt.copy(La).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(Qt.copy(La).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(Qt.copy(Ia).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(Qt.copy(Dr).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (xc.copy(i), Qt.copy(this.eye).applyQuaternion(on.copy(i).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(Uv.lookAt(this.eye, Fv, Dr)), a.name === "X" && (on.setFromAxisAngle(Ia, Math.atan2(-Qt.y, Qt.z)), on.multiplyQuaternions(xc, on), a.quaternion.copy(on)), a.name === "Y" && (on.setFromAxisAngle(Dr, Math.atan2(Qt.x, Qt.z)), on.multiplyQuaternions(xc, on), a.quaternion.copy(on)), a.name === "Z" && (on.setFromAxisAngle(La, Math.atan2(Qt.y, Qt.x)), on.multiplyQuaternions(xc, on), a.quaternion.copy(on))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(c) {
        return a.name === c;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class V6 extends Ze {
  constructor() {
    super(
      new un(1e5, 1e5, 2, 2),
      new Tn({ visible: !1, wireframe: !0, side: vn, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let n = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (n = "local"), _c.copy(Ia).applyQuaternion(n === "local" ? this.worldQuaternion : Vc), _a.copy(Dr).applyQuaternion(n === "local" ? this.worldQuaternion : Vc), ba.copy(La).applyQuaternion(n === "local" ? this.worldQuaternion : Vc), Qt.copy(_a), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Qt.copy(this.eye).cross(_c), Qi.copy(_c).cross(Qt);
            break;
          case "Y":
            Qt.copy(this.eye).cross(_a), Qi.copy(_a).cross(Qt);
            break;
          case "Z":
            Qt.copy(this.eye).cross(ba), Qi.copy(ba).cross(Qt);
            break;
          case "XY":
            Qi.copy(ba);
            break;
          case "YZ":
            Qi.copy(_c);
            break;
          case "XZ":
            Qt.copy(ba), Qi.copy(_a);
            break;
          case "XYZ":
          case "E":
            Qi.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        Qi.set(0, 0, 0);
    }
    Qi.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (Ov.lookAt(Wn.set(0, 0, 0), Qi, Qt), this.quaternion.setFromRotationMatrix(Ov)), super.updateMatrixWorld(e);
  }
}
class G6 {
  constructor(e = null) {
    /** The main Three.js scene */
    fe(this, "scene");
    /** Group for composition layers (rendered content) */
    fe(this, "compositionGroup");
    /** Group for UI overlay elements */
    fe(this, "overlayGroup");
    /** Group for debug helpers */
    fe(this, "debugGroup");
    /** Composition bounds frame */
    fe(this, "compositionBounds", null);
    /** Composition dimensions */
    fe(this, "compositionWidth", 1920);
    fe(this, "compositionHeight", 1080);
    /** O(1) layer lookup map - optimization for frequent ID-based lookups */
    fe(this, "layerLookupMap", /* @__PURE__ */ new Map());
    /** Track Z positions to avoid unnecessary sorting */
    fe(this, "zPositionCache", /* @__PURE__ */ new Map());
    fe(this, "needsZSort", !1);
    this.scene = new O2(), this.scene.name = "WeylScene", e ? this.scene.background = new Mt(e) : this.scene.background = null, this.compositionGroup = new Ai(), this.compositionGroup.name = "composition", this.scene.add(this.compositionGroup), this.overlayGroup = new Ai(), this.overlayGroup.name = "overlay", this.overlayGroup.renderOrder = 1e3, this.scene.add(this.overlayGroup), this.debugGroup = new Ai(), this.debugGroup.name = "debug", this.debugGroup.visible = !1, this.scene.add(this.debugGroup), this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const e = new Sy(16777215, 0.6);
    e.name = "ambientLight", this.scene.add(e);
    const n = new Po(16777215, 0.8);
    n.name = "keyLight", n.position.set(1e3, -1e3, 2e3), n.castShadow = !0, n.shadow.mapSize.width = 2048, n.shadow.mapSize.height = 2048, this.scene.add(n);
    const i = new Po(16777215, 0.3);
    i.name = "fillLight", i.position.set(-500, 500, 1e3), this.scene.add(i);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(e) {
    var i;
    this.compositionGroup.add(e), this.markNeedsZSort();
    const n = (i = e.userData) == null ? void 0 : i.layerId;
    n && this.layerLookupMap.set(n, e);
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(e) {
    var i;
    this.compositionGroup.remove(e);
    const n = (i = e.userData) == null ? void 0 : i.layerId;
    n && this.layerLookupMap.delete(n), this.zPositionCache.delete(e);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   * Optimized to only sort when Z positions have actually changed
   */
  sortByZ() {
    if (!this.needsZSort) {
      let e = !1;
      for (const n of this.compositionGroup.children) {
        const i = this.zPositionCache.get(n), r = n.position.z || 0;
        if (i === void 0 || i !== r) {
          e = !0;
          break;
        }
      }
      if (!e)
        return;
    }
    this.compositionGroup.children.sort((e, n) => (e.position.z || 0) - (n.position.z || 0));
    for (const e of this.compositionGroup.children)
      this.zPositionCache.set(e, e.position.z || 0);
    this.needsZSort = !1;
  }
  /**
   * Mark that Z sorting is needed (call when Z positions may have changed)
   */
  markNeedsZSort() {
    this.needsZSort = !0;
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(e) {
    this.overlayGroup.add(e);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(e) {
    this.overlayGroup.remove(e);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    for (; this.overlayGroup.children.length > 0; ) {
      const e = this.overlayGroup.children[0];
      this.overlayGroup.remove(e), this.disposeObject(e);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(e) {
    this.scene.add(e);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(e) {
    this.scene.remove(e);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(e) {
    this.debugGroup.visible = e;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(e = 500) {
    const n = this.debugGroup.getObjectByName("axisHelper");
    n && this.debugGroup.remove(n);
    const i = new ET(e);
    i.name = "axisHelper", this.debugGroup.add(i);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(e = 2e3, n = 40) {
    const i = this.debugGroup.getObjectByName("gridHelper");
    i && this.debugGroup.remove(i);
    const r = new TT(e, n, 4473924, 2236962);
    r.name = "gridHelper", r.rotation.x = Math.PI / 2, this.debugGroup.add(r);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(e) {
    e ? this.scene.background = new Mt(e) : this.scene.background = null;
  }
  /**
   * Get current background color
   */
  getBackground() {
    return this.scene.background instanceof Mt ? "#" + this.scene.background.getHexString() : null;
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(e, n) {
    this.compositionWidth = e, this.compositionHeight = n, this.updateCompositionBounds();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    this.compositionBounds && (this.overlayGroup.remove(this.compositionBounds), this.compositionBounds.geometry.dispose(), this.compositionBounds.material.dispose());
    const e = this.compositionWidth, n = this.compositionHeight, i = [
      new de(0, 0, 0),
      new de(e, 0, 0),
      new de(e, -n, 0),
      new de(0, -n, 0)
    ], r = new Vt().setFromPoints(i), o = new Yi({
      color: 4886745,
      linewidth: 2,
      depthTest: !1
    });
    this.compositionBounds = new z2(r, o), this.compositionBounds.name = "compositionBounds", this.compositionBounds.renderOrder = 998, this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(e) {
    this.compositionBounds && (this.compositionBounds.visible = e);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(e) {
    return e.intersectObjects(this.compositionGroup.children, !0);
  }
  /**
   * Find layer object by ID - O(1) lookup via Map
   */
  findLayerById(e) {
    return this.layerLookupMap.get(e) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(e) {
    var n;
    for (e instanceof Ze && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => {
      this.disposeMaterial(i);
    }) : e.material && this.disposeMaterial(e.material)); e.children.length > 0; ) {
      const i = e.children[0];
      e.remove(i), this.disposeObject(i);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(e) {
    var i, r, o, a, l, c, u, d;
    const n = e;
    (i = n.map) == null || i.dispose(), (r = n.normalMap) == null || r.dispose(), (o = n.roughnessMap) == null || o.dispose(), (a = n.metalnessMap) == null || a.dispose(), (l = n.aoMap) == null || l.dispose(), (c = n.emissiveMap) == null || c.dispose(), (u = n.alphaMap) == null || u.dispose(), (d = n.envMap) == null || d.dispose(), e.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    for (; this.compositionGroup.children.length > 0; ) {
      const e = this.compositionGroup.children[0];
      this.compositionGroup.remove(e), this.disposeObject(e);
    }
    for (this.layerLookupMap.clear(), this.zPositionCache.clear(), this.clearOverlay(); this.debugGroup.children.length > 0; ) {
      const e = this.debugGroup.children[0];
      this.debugGroup.remove(e), this.disposeObject(e);
    }
    this.scene.clear();
  }
}
const H6 = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class ea {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const $6 = new Au(-1, 1, 1, -1, 0, 1);
class W6 extends Vt {
  constructor() {
    super(), this.setAttribute("position", new Pt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Pt([0, 2, 0, 0, 2, 0], 2));
  }
}
const X6 = new W6();
class Qf {
  constructor(e) {
    this._mesh = new Ze(X6, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, $6);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class j6 extends ea {
  constructor(e, n) {
    super(), this.textureID = n !== void 0 ? n : "tDiffuse", e instanceof zn ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Ml.clone(e.uniforms), this.material = new zn({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new Qf(this.material);
  }
  render(e, n, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class zv extends ea {
  constructor(e, n) {
    super(), this.scene = e, this.camera = n, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, n, i) {
    const r = e.getContext(), o = e.state;
    o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0);
    let a, l;
    this.inverse ? (a = 0, l = 1) : (a = 1, l = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), o.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295), o.buffers.stencil.setClear(l), o.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.color.setMask(!0), o.buffers.depth.setMask(!0), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), o.buffers.stencil.setLocked(!0);
  }
}
class Y6 extends ea {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class q6 {
  constructor(e, n) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), n === void 0) {
      const i = e.getSize(new rt());
      this._width = i.width, this._height = i.height, n = new Ri(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: dr }), n.texture.name = "EffectComposer.rt1";
    } else
      this._width = n.width, this._height = n.height;
    this.renderTarget1 = n, this.renderTarget2 = n.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new j6(H6), this.copyPass.material.blending = os, this.clock = new CT();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, n) {
    this.passes.splice(n, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const n = this.passes.indexOf(e);
    n !== -1 && this.passes.splice(n, 1);
  }
  isLastEnabledPass(e) {
    for (let n = e + 1; n < this.passes.length; n++)
      if (this.passes[n].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const n = this.renderer.getRenderTarget();
    let i = !1;
    for (let r = 0, o = this.passes.length; r < o; r++) {
      const a = this.passes[r];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
          if (i) {
            const l = this.renderer.getContext(), c = this.renderer.state.buffers.stencil;
            c.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), c.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        zv !== void 0 && (a instanceof zv ? i = !0 : a instanceof Y6 && (i = !1));
      }
    }
    this.renderer.setRenderTarget(n);
  }
  reset(e) {
    if (e === void 0) {
      const n = this.renderer.getSize(new rt());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = n.width, this._height = n.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, n) {
    this._width = e, this._height = n;
    const i = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, r), this.renderTarget2.setSize(i, r);
    for (let o = 0; o < this.passes.length; o++)
      this.passes[o].setSize(i, r);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class Z6 extends ea {
  constructor(e, n, i = null, r = null, o = null) {
    super(), this.scene = e, this.camera = n, this.overrideMaterial = i, this.clearColor = r, this.clearAlpha = o, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    const r = e.autoClear;
    e.autoClear = !1;
    let o, a;
    this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (o = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(o), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = r;
  }
}
const K6 = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
  )
};
class J6 extends ea {
  constructor() {
    super();
    const e = K6;
    this.uniforms = Ml.clone(e.uniforms), this.material = new mT({
      name: e.name,
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    }), this.fsQuad = new Qf(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(e, n, i) {
    this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, (this._outputColorSpace !== e.outputColorSpace || this._toneMapping !== e.toneMapping) && (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, It.getTransfer(this._outputColorSpace) === qt && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === z0 ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === N0 ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === B0 ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === Mf ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === V0 ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === G0 && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const Q6 = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: { value: null },
    tDepth: { value: null },
    focus: { value: 1 },
    aspect: { value: 1 },
    aperture: { value: 0.025 },
    maxblur: { value: 0.01 },
    nearClip: { value: 1 },
    farClip: { value: 1e3 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`
  )
};
class eN extends ea {
  constructor(e, n, i) {
    super(), this.scene = e, this.camera = n;
    const r = i.focus !== void 0 ? i.focus : 1, o = i.aperture !== void 0 ? i.aperture : 0.025, a = i.maxblur !== void 0 ? i.maxblur : 1;
    this.renderTargetDepth = new Ri(1, 1, {
      // will be resized later
      minFilter: On,
      magFilter: On,
      type: dr
    }), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new Nf(), this.materialDepth.depthPacking = Df, this.materialDepth.blending = os;
    const l = Q6, c = Ml.clone(l.uniforms);
    c.tDepth.value = this.renderTargetDepth.texture, c.focus.value = r, c.aspect.value = n.aspect, c.aperture.value = o, c.maxblur.value = a, c.nearClip.value = n.near, c.farClip.value = n.far, this.materialBokeh = new zn({
      defines: Object.assign({}, l.defines),
      uniforms: c,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader
    }), this.uniforms = c, this.fsQuad = new Qf(this.materialBokeh), this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this._oldClearColor);
    const r = e.getClearAlpha(), o = e.autoClear;
    e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = i.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), e.clear(), this.fsQuad.render(e)), this.scene.overrideMaterial = null, e.setClearColor(this._oldClearColor), e.setClearAlpha(r), e.autoClear = o;
  }
  setSize(e, n) {
    this.materialBokeh.uniforms.aspect.value = e / n, this.renderTargetDepth.setSize(e, n);
  }
  dispose() {
    this.renderTargetDepth.dispose(), this.materialDepth.dispose(), this.materialBokeh.dispose(), this.fsQuad.dispose();
  }
}
class tN {
  constructor(e, n, i) {
    fe(this, "renderer");
    fe(this, "composer");
    fe(this, "scene");
    fe(this, "camera");
    // Render targets
    fe(this, "colorTarget");
    fe(this, "depthTarget");
    // Frame capture
    fe(this, "captureCanvas");
    fe(this, "captureCtx");
    // Depth capture material
    fe(this, "depthMaterial");
    // Normal material for normal pass
    fe(this, "normalMaterial");
    // Dimensions
    fe(this, "width");
    fe(this, "height");
    fe(this, "pixelRatio");
    // Render mode
    fe(this, "renderMode", "color");
    // DOF pass
    fe(this, "bokehPass", null);
    fe(this, "dofConfig", {
      enabled: !1,
      focusDistance: 500,
      aperture: 0.025,
      maxBlur: 0.01
    });
    // ============================================================================
    // PRECOMP RENDER-TO-TEXTURE
    // ============================================================================
    /** Cache of render targets for precomps (keyed by compositionId) */
    fe(this, "precompTargets", /* @__PURE__ */ new Map());
    this.scene = n, this.camera = i, this.width = e.width, this.height = e.height, this.pixelRatio = e.pixelRatio ?? Math.min(window.devicePixelRatio, 2), this.renderer = new U2({
      canvas: e.canvas,
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      preserveDrawingBuffer: !0,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: !1,
      depth: !0
    }), this.renderer.setPixelRatio(this.pixelRatio), this.renderer.setSize(this.width, this.height), this.renderer.outputColorSpace = dn, this.renderer.toneMapping = Mf, this.renderer.toneMappingExposure = 1, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = k0;
    const r = Math.floor(this.width * this.pixelRatio), o = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(r, o), this.depthTarget = this.createDepthTarget(r, o), this.composer = new q6(this.renderer, this.colorTarget), this.setupDefaultPasses(), this.captureCanvas = new OffscreenCanvas(r, o), this.captureCtx = this.captureCanvas.getContext("2d"), this.depthMaterial = this.createDepthMaterial(), this.normalMaterial = new gT();
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(e, n) {
    return new Ri(e, n, {
      minFilter: Bt,
      magFilter: Bt,
      format: Rn,
      type: dr,
      colorSpace: dn,
      depthBuffer: !0,
      stencilBuffer: !1,
      samples: 4
      // MSAA
    });
  }
  createDepthTarget(e, n) {
    const i = new Ri(e, n, {
      minFilter: On,
      magFilter: On,
      format: Rn,
      type: si,
      depthBuffer: !0,
      stencilBuffer: !1
    });
    return i.depthTexture = new zf(e, n), i.depthTexture.format = Vr, i.depthTexture.type = si, i;
  }
  createDepthMaterial() {
    return new zn({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: !1,
      depthTest: !1
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const e = new Z6(this.scene.scene, this.camera.camera);
    this.composer.addPass(e);
    const n = new J6();
    this.composer.addPass(n);
  }
  /**
   * Add a post-processing pass
   */
  addPass(e) {
    const n = this.composer.passes.findIndex(
      (i) => i.constructor.name === "OutputPass"
    );
    n > -1 ? this.composer.insertPass(e, n) : this.composer.addPass(e);
  }
  /**
   * Remove a post-processing pass
   */
  removePass(e) {
    this.composer.removePass(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(e) {
    this.dofConfig = { ...this.dofConfig, ...e }, this.dofConfig.enabled ? (this.bokehPass || this.createBokehPass(), this.updateBokehPass()) : this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    Math.floor(this.width * this.pixelRatio), Math.floor(this.height * this.pixelRatio), this.bokehPass = new eN(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    ), this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const e = this.bokehPass.uniforms;
    e && (e.focus.value = this.dofConfig.focusDistance, e.aperture.value = this.dofConfig.aperture, e.maxblur.value = this.dofConfig.maxBlur);
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(e) {
    this.setDOF({ focusDistance: e });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(e) {
    this.setDOF({ aperture: e });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(e) {
    this.setDOF({ enabled: e });
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ(), this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(e) {
    const n = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(e), this.renderer.render(this.scene.scene, this.camera.camera), this.renderer.setRenderTarget(n);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, e === "depth" || e === "normal" ? this.scene.scene.overrideMaterial = e === "depth" ? this.depthMaterial : this.normalMaterial : this.scene.scene.overrideMaterial = null;
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio), i = new Uint8Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      e,
      n,
      i
    );
    const r = new Uint8ClampedArray(i.length), o = e * 4;
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * o, c = a * o;
      r.set(i.subarray(l, l + o), c);
    }
    return new ImageData(r, e, n);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const i = new Float32Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      e,
      n,
      i
    );
    const r = new Float32Array(e * n);
    for (let a = 0; a < e * n; a++)
      r[a] = i[a * 4];
    const o = new Float32Array(e * n);
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * e, c = a * e;
      o.set(r.subarray(l, l + e), c);
    }
    return o;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(e, n) {
    this.width = e, this.height = n;
    const i = Math.floor(e * this.pixelRatio), r = Math.floor(n * this.pixelRatio);
    this.renderer.setSize(e, n), this.composer.setSize(i, r), this.colorTarget.dispose(), this.depthTarget.dispose(), this.colorTarget = this.createColorTarget(i, r), this.depthTarget = this.createDepthTarget(i, r), this.composer.renderTarget1.dispose(), this.composer.renderTarget2.dispose(), this.composer.renderTarget1 = this.colorTarget.clone(), this.composer.renderTarget2 = this.colorTarget.clone(), this.captureCanvas.width = i, this.captureCanvas.height = r, this.bokehPass && this.dofConfig.enabled && (this.composer.removePass(this.bokehPass), this.bokehPass = null, this.createBokehPass());
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  /**
   * Create or get a render target for a precomp composition
   */
  getPrecompRenderTarget(e, n, i) {
    const r = `${e}_${n}_${i}`;
    let o = this.precompTargets.get(r);
    return o || (o = new Ri(n, i, {
      minFilter: Bt,
      magFilter: Bt,
      format: Rn,
      type: ji,
      colorSpace: dn,
      depthBuffer: !0,
      stencilBuffer: !1
    }), this.precompTargets.set(r, o)), o;
  }
  /**
   * Render a scene to an offscreen target and return the texture
   * Used for precomp rendering
   */
  renderSceneToTexture(e, n, i) {
    const r = this.renderer.getRenderTarget();
    return this.renderer.setRenderTarget(i), this.renderer.clear(), this.renderer.render(e, n), this.renderer.setRenderTarget(r), i.texture;
  }
  /**
   * Dispose a precomp render target
   */
  disposePrecompTarget(e) {
    for (const [n, i] of this.precompTargets.entries())
      n.startsWith(e + "_") && (i.dispose(), this.precompTargets.delete(n));
  }
  /**
   * Dispose all precomp render targets
   */
  disposeAllPrecompTargets() {
    for (const e of this.precompTargets.values())
      e.dispose();
    this.precompTargets.clear();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null), this.disposeAllPrecompTargets(), this.colorTarget.dispose(), this.depthTarget.dispose(), this.depthMaterial.dispose(), this.normalMaterial.dispose(), this.composer.dispose(), this.renderer.dispose();
  }
}
class nN extends qi {
  constructor(n, i) {
    super(n);
    fe(this, "mesh");
    fe(this, "geometry");
    fe(this, "material");
    fe(this, "texture", null);
    /** Resource manager for texture loading */
    fe(this, "resources");
    /** Image dimensions */
    fe(this, "imageWidth", 100);
    fe(this, "imageHeight", 100);
    /** Source URL or asset ID */
    fe(this, "sourceUrl", null);
    /** Original (unprocessed) texture for effects source */
    fe(this, "originalTexture", null);
    /** Canvas for rendering texture to 2D for effect processing */
    fe(this, "textureCanvas", null);
    fe(this, "textureCanvasCtx", null);
    this.resources = i, this.geometry = new un(1, 1), this.material = new Tn({
      color: 16777215,
      transparent: !0,
      side: vn,
      depthWrite: !1
    }), this.mesh = new Ze(this.geometry, this.material), this.mesh.name = `image_${this.id}`, this.group.add(this.mesh);
    const r = this.extractImageData(n);
    r.source && this.loadImage(r.source), this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(n) {
    const i = n.data;
    return {
      source: (i == null ? void 0 : i.source) ?? (i == null ? void 0 : i.url) ?? (i == null ? void 0 : i.assetId) ?? null,
      width: (i == null ? void 0 : i.width) ?? 100,
      height: (i == null ? void 0 : i.height) ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(n) {
    this.sourceUrl = n;
    try {
      const i = await this.resources.loadTexture(n, {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      });
      this.setTexture(i);
    } catch (i) {
      Ei.error(`ImageLayer: Failed to load image: ${n}`, i);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(n) {
    this.texture = n, this.originalTexture = n, this.material.map = n, this.material.needsUpdate = !0, n.image && (this.imageWidth = n.image.width || n.image.videoWidth || 100, this.imageHeight = n.image.height || n.image.videoHeight || 100, this.updateMeshSize(), this.textureCanvas = null, this.textureCanvasCtx = null, this.effectsDirty = !0);
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(n) {
    const i = this.resources.createTextureFromImageData(
      n,
      `layer_${this.id}_imagedata`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.setTexture(i);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_canvas`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.setTexture(i);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose(), this.geometry = new un(this.imageWidth, this.imageHeight), this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(n, i) {
    this.imageWidth = n, this.imageHeight = i, this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(n) {
    this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215), this.material.needsUpdate = !0;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    var i;
    if (!((i = this.originalTexture) != null && i.image))
      return null;
    const n = this.originalTexture.image;
    return (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) && (this.textureCanvas = document.createElement("canvas"), this.textureCanvas.width = this.imageWidth, this.textureCanvas.height = this.imageHeight, this.textureCanvasCtx = this.textureCanvas.getContext("2d")), this.textureCanvasCtx ? (this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight), this.textureCanvasCtx.drawImage(n, 0, 0, this.imageWidth, this.imageHeight), this.textureCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Bt,
        magFilter: Bt,
        generateMipmaps: !1,
        colorSpace: dn
      }
    );
    this.texture = i, this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.evaluateEffects(n);
  }
  onUpdate(n) {
    const i = n.data;
    if (i != null && i.source || i != null && i.url || i != null && i.assetId) {
      const r = i.source ?? i.url ?? i.assetId;
      r !== this.sourceUrl && this.loadImage(r);
    }
    ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      i.width ?? this.imageWidth,
      i.height ?? this.imageHeight
    );
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class iN extends qi {
  constructor(n) {
    super(n);
    fe(this, "mesh");
    fe(this, "geometry");
    fe(this, "material");
    /** Solid color */
    fe(this, "color");
    /** Solid dimensions */
    fe(this, "width");
    fe(this, "height");
    /** Animated color property */
    fe(this, "animatedColor");
    const i = this.extractSolidData(n);
    this.color = i.color, this.width = i.width, this.height = i.height, this.animatedColor = i.animatedColor, this.geometry = new un(this.width, this.height), this.material = new Tn({
      color: this.color,
      transparent: !0,
      side: vn,
      depthWrite: !1
    }), this.mesh = new Ze(this.geometry, this.material), this.mesh.name = `solid_${this.id}`, this.group.add(this.mesh), this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(n) {
    const i = n.data;
    return {
      color: (i == null ? void 0 : i.color) ?? "#808080",
      width: (i == null ? void 0 : i.width) ?? 1920,
      height: (i == null ? void 0 : i.height) ?? 1080,
      animatedColor: i == null ? void 0 : i.animatedColor
    };
  }
  /**
   * Set solid color
   */
  setColor(n) {
    this.color = n, this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new un(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    var i;
    if ((i = this.animatedColor) != null && i.animated) {
      const r = this.evaluator.evaluate(this.animatedColor, n);
      this.material.color.set(r), this.material.needsUpdate = !0;
    }
  }
  onUpdate(n) {
    const i = n.data;
    (i == null ? void 0 : i.color) !== void 0 && this.setColor(i.color), ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      (i == null ? void 0 : i.width) ?? this.width,
      (i == null ? void 0 : i.height) ?? this.height
    ), (i == null ? void 0 : i.animatedColor) !== void 0 && (this.animatedColor = i.animatedColor), i === void 0 && n.labelColor !== void 0 && this.setColor(n.labelColor);
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Nv extends qi {
  constructor(n, i = !0) {
    super(n);
    /** Visual indicator (crosshair) for editor visibility */
    fe(this, "indicator", null);
    /** Whether to show the null indicator */
    fe(this, "showIndicator");
    /** Indicator size */
    fe(this, "indicatorSize");
    this.showIndicator = i, this.indicatorSize = 50, this.showIndicator && this.createIndicator();
  }
  /**
   * Create visual indicator (crosshair) for the null object
   */
  createIndicator() {
    this.indicator = new Ai(), this.indicator.name = `null_indicator_${this.id}`;
    const n = this.indicatorSize, i = 16737792, r = new Yi({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), o = [
      new de(-n / 2, 0, 0),
      new de(n / 2, 0, 0)
    ], a = new Vt().setFromPoints(o), l = new ln(a, r);
    this.indicator.add(l);
    const c = [
      new de(0, -n / 2, 0),
      new de(0, n / 2, 0)
    ], u = new Vt().setFromPoints(c), d = new ln(u, r);
    if (this.indicator.add(d), this.threeD) {
      const v = [
        new de(0, 0, -n / 2),
        new de(0, 0, n / 2)
      ], _ = new Vt().setFromPoints(v), g = new ln(_, r);
      this.indicator.add(g);
    }
    const h = new Ru(3, 16), m = new Tn({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1,
      side: vn
    }), p = new Ze(h, m);
    this.indicator.add(p), this.group.add(this.indicator), this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(n) {
    this.indicator && (this.indicator.visible = n);
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(n) {
    n !== this.indicatorSize && (this.indicatorSize = n, this.indicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    this.indicator && (this.indicator.traverse((n) => {
      n instanceof ln && (n.geometry.dispose(), n.material.dispose()), n instanceof Ze && (n.geometry.dispose(), n.material.dispose());
    }), this.indicator.clear(), this.indicator = null);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    n.threeD !== void 0 && n.threeD !== this.threeD && (this.threeD = n.threeD, this.indicator && this.showIndicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  onDispose() {
    this.disposeIndicator();
  }
}
function sN() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(r, o) {
    var a = r.id, l = r.name, c = r.dependencies;
    c === void 0 && (c = []);
    var u = r.init;
    u === void 0 && (u = function() {
    });
    var d = r.getTransferables;
    if (d === void 0 && (d = null), !s[a])
      try {
        c = c.map(function(m) {
          return m && m.isWorkerModule && (e(m, function(p) {
            if (p instanceof Error)
              throw p;
          }), m = s[m.id].value), m;
        }), u = i("<" + l + ">.init", u), d && (d = i("<" + l + ">.getTransferables", d));
        var h = null;
        typeof u == "function" ? h = u.apply(void 0, c) : console.error("worker module init function failed to rehydrate"), s[a] = {
          id: a,
          value: h,
          getTransferables: d
        }, o(h);
      } catch (m) {
        m && m.noLog || console.error(m), o(m);
      }
  }
  function n(r, o) {
    var a, l = r.id, c = r.args;
    (!s[l] || typeof s[l].value != "function") && o(new Error("Worker module " + l + ": not found or its 'init' did not return a function"));
    try {
      var u = (a = s[l]).value.apply(a, c);
      u && typeof u.then == "function" ? u.then(d, function(h) {
        return o(h instanceof Error ? h : new Error("" + h));
      }) : d(u);
    } catch (h) {
      o(h);
    }
    function d(h) {
      try {
        var m = s[l].getTransferables && s[l].getTransferables(h);
        (!m || !Array.isArray(m) || !m.length) && (m = void 0), o(h, m);
      } catch (p) {
        console.error(p), o(p);
      }
    }
  }
  function i(r, o) {
    var a = void 0;
    self.troikaDefine = function(c) {
      return a = c;
    };
    var l = URL.createObjectURL(
      new Blob(
        ["/** " + r.replace(/\*/g, "") + ` **/

troikaDefine(
` + o + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(l);
    } catch (c) {
      console.error(c);
    }
    return URL.revokeObjectURL(l), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function(r) {
    var o = r.data, a = o.messageId, l = o.action, c = o.data;
    try {
      l === "registerModule" && e(c, function(u) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: { isCallable: typeof u == "function" }
        });
      }), l === "callModule" && n(c, function(u, d) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: u
        }, d || void 0);
      });
    } catch (u) {
      postMessage({
        messageId: a,
        success: !1,
        error: u.stack
      });
    }
  });
}
function rN(s) {
  var e = function() {
    for (var n = [], i = arguments.length; i--; ) n[i] = arguments[i];
    return e._getInitResult().then(function(r) {
      if (typeof r == "function")
        return r.apply(void 0, n);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var n = s.dependencies, i = s.init;
    n = Array.isArray(n) ? n.map(function(o) {
      return o && (o = o.onMainThread || o, o._getInitResult && (o = o._getInitResult())), o;
    }) : [];
    var r = Promise.all(n).then(function(o) {
      return i.apply(null, o);
    });
    return e._getInitResult = function() {
      return r;
    }, r;
  }, e;
}
var Fy = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (n) {
      console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + n.message + "]"
      );
    }
  return Fy = function() {
    return s;
  }, s;
}, oN = 0, aN = 0, Wd = !1, Za = /* @__PURE__ */ Object.create(null), Ka = /* @__PURE__ */ Object.create(null), ef = /* @__PURE__ */ Object.create(null);
function ta(s) {
  if ((!s || typeof s.init != "function") && !Wd)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, n = s.init, i = s.getTransferables, r = s.workerId, o = rN(s);
  r == null && (r = "#default");
  var a = "workerModule" + ++oN, l = s.name || a, c = null;
  e = e && e.map(function(d) {
    return typeof d == "function" && !d.workerModuleData && (Wd = !0, d = ta({
      workerId: r,
      name: "<" + l + "> function dependency: " + d.name,
      init: `function(){return (
` + Gc(d) + `
)}`
    }), Wd = !1), d && d.workerModuleData && (d = d.workerModuleData), d;
  });
  function u() {
    for (var d = [], h = arguments.length; h--; ) d[h] = arguments[h];
    if (!Fy())
      return o.apply(void 0, d);
    if (!c) {
      c = Bv(r, "registerModule", u.workerModuleData);
      var m = function() {
        c = null, Ka[r].delete(m);
      };
      (Ka[r] || (Ka[r] = /* @__PURE__ */ new Set())).add(m);
    }
    return c.then(function(p) {
      var v = p.isCallable;
      if (v)
        return Bv(r, "callModule", { id: a, args: d });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return u.workerModuleData = {
    isWorkerModule: !0,
    id: a,
    name: l,
    dependencies: e,
    init: Gc(n),
    getTransferables: i && Gc(i)
  }, u.onMainThread = o, u;
}
function lN(s) {
  Ka[s] && Ka[s].forEach(function(e) {
    e();
  }), Za[s] && (Za[s].terminate(), delete Za[s]);
}
function Gc(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function cN(s) {
  var e = Za[s];
  if (!e) {
    var n = Gc(sN);
    e = Za[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + n + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var r = i.data, o = r.messageId, a = ef[o];
      if (!a)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete ef[o], a(r);
    };
  }
  return e;
}
function Bv(s, e, n) {
  return new Promise(function(i, r) {
    var o = ++aN;
    ef[o] = function(a) {
      a.success ? i(a.result) : r(new Error("Error in worker " + e + " call: " + a.error));
    }, cN(s).postMessage({
      messageId: o,
      action: e,
      data: n
    });
  });
}
function Uy() {
  var s = function(e) {
    function n(le, re, j, $, q, oe, ie, ce) {
      var V = 1 - ie;
      ce.x = V * V * le + 2 * V * ie * j + ie * ie * q, ce.y = V * V * re + 2 * V * ie * $ + ie * ie * oe;
    }
    function i(le, re, j, $, q, oe, ie, ce, V, Y) {
      var H = 1 - V;
      Y.x = H * H * H * le + 3 * H * H * V * j + 3 * H * V * V * q + V * V * V * ie, Y.y = H * H * H * re + 3 * H * H * V * $ + 3 * H * V * V * oe + V * V * V * ce;
    }
    function r(le, re) {
      for (var j = /([MLQCZ])([^MLQCZ]*)/g, $, q, oe, ie, ce; $ = j.exec(le); ) {
        var V = $[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(Y) {
          return parseFloat(Y);
        });
        switch ($[1]) {
          case "M":
            ie = q = V[0], ce = oe = V[1];
            break;
          case "L":
            (V[0] !== ie || V[1] !== ce) && re("L", ie, ce, ie = V[0], ce = V[1]);
            break;
          case "Q": {
            re("Q", ie, ce, ie = V[2], ce = V[3], V[0], V[1]);
            break;
          }
          case "C": {
            re("C", ie, ce, ie = V[4], ce = V[5], V[0], V[1], V[2], V[3]);
            break;
          }
          case "Z":
            (ie !== q || ce !== oe) && re("L", ie, ce, q, oe);
            break;
        }
      }
    }
    function o(le, re, j) {
      j === void 0 && (j = 16);
      var $ = { x: 0, y: 0 };
      r(le, function(q, oe, ie, ce, V, Y, H, I, F) {
        switch (q) {
          case "L":
            re(oe, ie, ce, V);
            break;
          case "Q": {
            for (var L = oe, ee = ie, Z = 1; Z < j; Z++)
              n(
                oe,
                ie,
                Y,
                H,
                ce,
                V,
                Z / (j - 1),
                $
              ), re(L, ee, $.x, $.y), L = $.x, ee = $.y;
            break;
          }
          case "C": {
            for (var k = oe, ne = ie, J = 1; J < j; J++)
              i(
                oe,
                ie,
                Y,
                H,
                I,
                F,
                ce,
                V,
                J / (j - 1),
                $
              ), re(k, ne, $.x, $.y), k = $.x, ne = $.y;
            break;
          }
        }
      });
    }
    var a = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", l = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", c = /* @__PURE__ */ new WeakMap(), u = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function d(le, re) {
      var j = le.getContext ? le.getContext("webgl", u) : le, $ = c.get(j);
      if (!$) {
        let H = function(k) {
          var ne = oe[k];
          if (!ne && (ne = oe[k] = j.getExtension(k), !ne))
            throw new Error(k + " not supported");
          return ne;
        }, I = function(k, ne) {
          var J = j.createShader(ne);
          return j.shaderSource(J, k), j.compileShader(J), J;
        }, F = function(k, ne, J, B) {
          if (!ie[k]) {
            var X = {}, se = {}, z = j.createProgram();
            j.attachShader(z, I(ne, j.VERTEX_SHADER)), j.attachShader(z, I(J, j.FRAGMENT_SHADER)), j.linkProgram(z), ie[k] = {
              program: z,
              transaction: function(K) {
                j.useProgram(z), K({
                  setUniform: function(me, ge) {
                    for (var Me = [], Ee = arguments.length - 2; Ee-- > 0; ) Me[Ee] = arguments[Ee + 2];
                    var Ae = se[ge] || (se[ge] = j.getUniformLocation(z, ge));
                    j["uniform" + me].apply(j, [Ae].concat(Me));
                  },
                  setAttribute: function(me, ge, Me, Ee, Ae) {
                    var Xe = X[me];
                    Xe || (Xe = X[me] = {
                      buf: j.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: j.getAttribLocation(z, me),
                      data: null
                    }), j.bindBuffer(j.ARRAY_BUFFER, Xe.buf), j.vertexAttribPointer(Xe.loc, ge, j.FLOAT, !1, 0, 0), j.enableVertexAttribArray(Xe.loc), q ? j.vertexAttribDivisor(Xe.loc, Ee) : H("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Xe.loc, Ee), Ae !== Xe.data && (j.bufferData(j.ARRAY_BUFFER, Ae, Me), Xe.data = Ae);
                  }
                });
              }
            };
          }
          ie[k].transaction(B);
        }, L = function(k, ne) {
          V++;
          try {
            j.activeTexture(j.TEXTURE0 + V);
            var J = ce[k];
            J || (J = ce[k] = j.createTexture(), j.bindTexture(j.TEXTURE_2D, J), j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MIN_FILTER, j.NEAREST), j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MAG_FILTER, j.NEAREST)), j.bindTexture(j.TEXTURE_2D, J), ne(J, V);
          } finally {
            V--;
          }
        }, ee = function(k, ne, J) {
          var B = j.createFramebuffer();
          Y.push(B), j.bindFramebuffer(j.FRAMEBUFFER, B), j.activeTexture(j.TEXTURE0 + ne), j.bindTexture(j.TEXTURE_2D, k), j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_2D, k, 0);
          try {
            J(B);
          } finally {
            j.deleteFramebuffer(B), j.bindFramebuffer(j.FRAMEBUFFER, Y[--Y.length - 1] || null);
          }
        }, Z = function() {
          oe = {}, ie = {}, ce = {}, V = -1, Y.length = 0;
        };
        var q = typeof WebGL2RenderingContext < "u" && j instanceof WebGL2RenderingContext, oe = {}, ie = {}, ce = {}, V = -1, Y = [];
        j.canvas.addEventListener("webglcontextlost", function(k) {
          Z(), k.preventDefault();
        }, !1), c.set(j, $ = {
          gl: j,
          isWebGL2: q,
          getExtension: H,
          withProgram: F,
          withTexture: L,
          withTextureFramebuffer: ee,
          handleContextLoss: Z
        });
      }
      re($);
    }
    function h(le, re, j, $, q, oe, ie, ce) {
      ie === void 0 && (ie = 15), ce === void 0 && (ce = null), d(le, function(V) {
        var Y = V.gl, H = V.withProgram, I = V.withTexture;
        I("copy", function(F, L) {
          Y.texImage2D(Y.TEXTURE_2D, 0, Y.RGBA, q, oe, 0, Y.RGBA, Y.UNSIGNED_BYTE, re), H("copy", a, l, function(ee) {
            var Z = ee.setUniform, k = ee.setAttribute;
            k("aUV", 2, Y.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Z("1i", "image", L), Y.bindFramebuffer(Y.FRAMEBUFFER, ce || null), Y.disable(Y.BLEND), Y.colorMask(ie & 8, ie & 4, ie & 2, ie & 1), Y.viewport(j, $, q, oe), Y.scissor(j, $, q, oe), Y.drawArrays(Y.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function m(le, re, j) {
      var $ = le.width, q = le.height;
      d(le, function(oe) {
        var ie = oe.gl, ce = new Uint8Array($ * q * 4);
        ie.readPixels(0, 0, $, q, ie.RGBA, ie.UNSIGNED_BYTE, ce), le.width = re, le.height = j, h(ie, ce, 0, 0, $, q);
      });
    }
    var p = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: d,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: m
    });
    function v(le, re, j, $, q, oe) {
      oe === void 0 && (oe = 1);
      var ie = new Uint8Array(le * re), ce = $[2] - $[0], V = $[3] - $[1], Y = [];
      o(j, function(k, ne, J, B) {
        Y.push({
          x1: k,
          y1: ne,
          x2: J,
          y2: B,
          minX: Math.min(k, J),
          minY: Math.min(ne, B),
          maxX: Math.max(k, J),
          maxY: Math.max(ne, B)
        });
      }), Y.sort(function(k, ne) {
        return k.maxX - ne.maxX;
      });
      for (var H = 0; H < le; H++)
        for (var I = 0; I < re; I++) {
          var F = ee(
            $[0] + ce * (H + 0.5) / le,
            $[1] + V * (I + 0.5) / re
          ), L = Math.pow(1 - Math.abs(F) / q, oe) / 2;
          F < 0 && (L = 1 - L), L = Math.max(0, Math.min(255, Math.round(L * 255))), ie[I * le + H] = L;
        }
      return ie;
      function ee(k, ne) {
        for (var J = 1 / 0, B = 1 / 0, X = Y.length; X--; ) {
          var se = Y[X];
          if (se.maxX + B <= k)
            break;
          if (k + B > se.minX && ne - B < se.maxY && ne + B > se.minY) {
            var z = x(k, ne, se.x1, se.y1, se.x2, se.y2);
            z < J && (J = z, B = Math.sqrt(J));
          }
        }
        return Z(k, ne) && (B = -B), B;
      }
      function Z(k, ne) {
        for (var J = 0, B = Y.length; B--; ) {
          var X = Y[B];
          if (X.maxX <= k)
            break;
          var se = X.y1 > ne != X.y2 > ne && k < (X.x2 - X.x1) * (ne - X.y1) / (X.y2 - X.y1) + X.x1;
          se && (J += X.y1 < X.y2 ? 1 : -1);
        }
        return J !== 0;
      }
    }
    function _(le, re, j, $, q, oe, ie, ce, V, Y) {
      oe === void 0 && (oe = 1), ce === void 0 && (ce = 0), V === void 0 && (V = 0), Y === void 0 && (Y = 0), g(le, re, j, $, q, oe, ie, null, ce, V, Y);
    }
    function g(le, re, j, $, q, oe, ie, ce, V, Y, H) {
      oe === void 0 && (oe = 1), V === void 0 && (V = 0), Y === void 0 && (Y = 0), H === void 0 && (H = 0);
      for (var I = v(le, re, j, $, q, oe), F = new Uint8Array(I.length * 4), L = 0; L < I.length; L++)
        F[L * 4 + H] = I[L];
      h(ie, F, V, Y, le, re, 1 << 3 - H, ce);
    }
    function x(le, re, j, $, q, oe) {
      var ie = q - j, ce = oe - $, V = ie * ie + ce * ce, Y = V ? Math.max(0, Math.min(1, ((le - j) * ie + (re - $) * ce) / V)) : 0, H = le - (j + Y * ie), I = re - ($ + Y * ce);
      return H * H + I * I;
    }
    var M = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: v,
      generateIntoCanvas: _,
      generateIntoFramebuffer: g
    }), S = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", b = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", C = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", T = new Float32Array([0, 0, 2, 0, 0, 2]), P = null, E = !1, y = {}, w = /* @__PURE__ */ new WeakMap();
    function D(le) {
      if (!E && !A(le))
        throw new Error("WebGL generation not supported");
    }
    function U(le, re, j, $, q, oe, ie) {
      if (oe === void 0 && (oe = 1), ie === void 0 && (ie = null), !ie && (ie = P, !ie)) {
        var ce = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!ce)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        ie = P = ce.getContext("webgl", { depth: !1 });
      }
      D(ie);
      var V = new Uint8Array(le * re * 4);
      d(ie, function(F) {
        var L = F.gl, ee = F.withTexture, Z = F.withTextureFramebuffer;
        ee("readable", function(k, ne) {
          L.texImage2D(L.TEXTURE_2D, 0, L.RGBA, le, re, 0, L.RGBA, L.UNSIGNED_BYTE, null), Z(k, ne, function(J) {
            O(
              le,
              re,
              j,
              $,
              q,
              oe,
              L,
              J,
              0,
              0,
              0
              // red channel
            ), L.readPixels(0, 0, le, re, L.RGBA, L.UNSIGNED_BYTE, V);
          });
        });
      });
      for (var Y = new Uint8Array(le * re), H = 0, I = 0; H < V.length; H += 4)
        Y[I++] = V[H];
      return Y;
    }
    function R(le, re, j, $, q, oe, ie, ce, V, Y) {
      oe === void 0 && (oe = 1), ce === void 0 && (ce = 0), V === void 0 && (V = 0), Y === void 0 && (Y = 0), O(le, re, j, $, q, oe, ie, null, ce, V, Y);
    }
    function O(le, re, j, $, q, oe, ie, ce, V, Y, H) {
      oe === void 0 && (oe = 1), V === void 0 && (V = 0), Y === void 0 && (Y = 0), H === void 0 && (H = 0), D(ie);
      var I = [];
      o(j, function(F, L, ee, Z) {
        I.push(F, L, ee, Z);
      }), I = new Float32Array(I), d(ie, function(F) {
        var L = F.gl, ee = F.isWebGL2, Z = F.getExtension, k = F.withProgram, ne = F.withTexture, J = F.withTextureFramebuffer, B = F.handleContextLoss;
        if (ne("rawDistances", function(X, se) {
          (le !== X._lastWidth || re !== X._lastHeight) && L.texImage2D(
            L.TEXTURE_2D,
            0,
            L.RGBA,
            X._lastWidth = le,
            X._lastHeight = re,
            0,
            L.RGBA,
            L.UNSIGNED_BYTE,
            null
          ), k("main", S, b, function(z) {
            var N = z.setAttribute, K = z.setUniform, he = !ee && Z("ANGLE_instanced_arrays"), me = !ee && Z("EXT_blend_minmax");
            N("aUV", 2, L.STATIC_DRAW, 0, T), N("aLineSegment", 4, L.DYNAMIC_DRAW, 1, I), K.apply(void 0, ["4f", "uGlyphBounds"].concat($)), K("1f", "uMaxDistance", q), K("1f", "uExponent", oe), J(X, se, function(ge) {
              L.enable(L.BLEND), L.colorMask(!0, !0, !0, !0), L.viewport(0, 0, le, re), L.scissor(0, 0, le, re), L.blendFunc(L.ONE, L.ONE), L.blendEquationSeparate(L.FUNC_ADD, ee ? L.MAX : me.MAX_EXT), L.clear(L.COLOR_BUFFER_BIT), ee ? L.drawArraysInstanced(L.TRIANGLES, 0, 3, I.length / 4) : he.drawArraysInstancedANGLE(L.TRIANGLES, 0, 3, I.length / 4);
            });
          }), k("post", a, C, function(z) {
            z.setAttribute("aUV", 2, L.STATIC_DRAW, 0, T), z.setUniform("1i", "tex", se), L.bindFramebuffer(L.FRAMEBUFFER, ce), L.disable(L.BLEND), L.colorMask(H === 0, H === 1, H === 2, H === 3), L.viewport(V, Y, le, re), L.scissor(V, Y, le, re), L.drawArrays(L.TRIANGLES, 0, 3);
          });
        }), L.isContextLost())
          throw B(), new Error("webgl context lost");
      });
    }
    function A(le) {
      var re = !le || le === P ? y : le.canvas || le, j = w.get(re);
      if (j === void 0) {
        E = !0;
        var $ = null;
        try {
          var q = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], oe = U(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            le
          );
          j = oe && q.length === oe.length && oe.every(function(ie, ce) {
            return ie === q[ce];
          }), j || ($ = "bad trial run results", console.info(q, oe));
        } catch (ie) {
          j = !1, $ = ie.message;
        }
        $ && console.warn("WebGL SDF generation not supported:", $), E = !1, w.set(re, j);
      }
      return j;
    }
    var G = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: U,
      generateIntoCanvas: R,
      generateIntoFramebuffer: O,
      isSupported: A
    });
    function ue(le, re, j, $, q, oe) {
      q === void 0 && (q = Math.max($[2] - $[0], $[3] - $[1]) / 2), oe === void 0 && (oe = 1);
      try {
        return U.apply(G, arguments);
      } catch (ie) {
        return console.info("WebGL SDF generation failed, falling back to JS", ie), v.apply(M, arguments);
      }
    }
    function Q(le, re, j, $, q, oe, ie, ce, V, Y) {
      q === void 0 && (q = Math.max($[2] - $[0], $[3] - $[1]) / 2), oe === void 0 && (oe = 1), ce === void 0 && (ce = 0), V === void 0 && (V = 0), Y === void 0 && (Y = 0);
      try {
        return R.apply(G, arguments);
      } catch (H) {
        return console.info("WebGL SDF generation failed, falling back to JS", H), _.apply(M, arguments);
      }
    }
    return e.forEachPathCommand = r, e.generate = ue, e.generateIntoCanvas = Q, e.javascript = M, e.pathToLineSegments = o, e.webgl = G, e.webglUtils = p, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
function uN() {
  var s = function(e) {
    var n = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, i = {}, r = {};
    i.L = 1, r[1] = "L", Object.keys(n).forEach(function(B, X) {
      i[B] = 1 << X + 1, r[i[B]] = B;
    }), Object.freeze(i);
    var o = i.LRI | i.RLI | i.FSI, a = i.L | i.R | i.AL, l = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, c = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, u = i.S | i.WS | i.B | o | i.PDI | c, d = null;
    function h() {
      if (!d) {
        d = /* @__PURE__ */ new Map();
        var B = function(se) {
          if (n.hasOwnProperty(se)) {
            var z = 0;
            n[se].split(",").forEach(function(N) {
              var K = N.split("+"), he = K[0], me = K[1];
              he = parseInt(he, 36), me = me ? parseInt(me, 36) : 0, d.set(z += he, i[se]);
              for (var ge = 0; ge < me; ge++)
                d.set(++z, i[se]);
            });
          }
        };
        for (var X in n) B(X);
      }
    }
    function m(B) {
      return h(), d.get(B.codePointAt(0)) || i.L;
    }
    function p(B) {
      return r[m(B)];
    }
    var v = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function _(B, X) {
      var se = 36, z = 0, N = /* @__PURE__ */ new Map(), K = X && /* @__PURE__ */ new Map(), he;
      return B.split(",").forEach(function me(ge) {
        if (ge.indexOf("+") !== -1)
          for (var Me = +ge; Me--; )
            me(he);
        else {
          he = ge;
          var Ee = ge.split(">"), Ae = Ee[0], Xe = Ee[1];
          Ae = String.fromCodePoint(z += parseInt(Ae, se)), Xe = String.fromCodePoint(z += parseInt(Xe, se)), N.set(Ae, Xe), X && K.set(Xe, Ae);
        }
      }), { map: N, reverseMap: K };
    }
    var g, x, M;
    function S() {
      if (!g) {
        var B = _(v.pairs, !0), X = B.map, se = B.reverseMap;
        g = X, x = se, M = _(v.canonical, !1).map;
      }
    }
    function b(B) {
      return S(), g.get(B) || null;
    }
    function C(B) {
      return S(), x.get(B) || null;
    }
    function T(B) {
      return S(), M.get(B) || null;
    }
    var P = i.L, E = i.R, y = i.EN, w = i.ES, D = i.ET, U = i.AN, R = i.CS, O = i.B, A = i.S, G = i.ON, ue = i.BN, Q = i.NSM, le = i.AL, re = i.LRO, j = i.RLO, $ = i.LRE, q = i.RLE, oe = i.PDF, ie = i.LRI, ce = i.RLI, V = i.FSI, Y = i.PDI;
    function H(B, X) {
      for (var se = 125, z = new Uint32Array(B.length), N = 0; N < B.length; N++)
        z[N] = m(B[N]);
      var K = /* @__PURE__ */ new Map();
      function he(ci, Li) {
        var ui = z[ci];
        z[ci] = Li, K.set(ui, K.get(ui) - 1), ui & l && K.set(l, K.get(l) - 1), K.set(Li, (K.get(Li) || 0) + 1), Li & l && K.set(l, (K.get(l) || 0) + 1);
      }
      for (var me = new Uint8Array(B.length), ge = /* @__PURE__ */ new Map(), Me = [], Ee = null, Ae = 0; Ae < B.length; Ae++)
        Ee || Me.push(Ee = {
          start: Ae,
          end: B.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: X === "rtl" ? 1 : X === "ltr" ? 0 : mp(Ae, !1)
        }), z[Ae] & O && (Ee.end = Ae, Ee = null);
      for (var Xe = q | $ | j | re | o | Y | oe | O, Oe = function(ci) {
        return ci + (ci & 1 ? 1 : 2);
      }, He = function(ci) {
        return ci + (ci & 1 ? 2 : 1);
      }, Ye = 0; Ye < Me.length; Ye++) {
        Ee = Me[Ye];
        var $e = [{
          _level: Ee.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Le = void 0, nt = 0, Je = 0, bt = 0;
        K.clear();
        for (var Se = Ee.start; Se <= Ee.end; Se++) {
          var Ne = z[Se];
          if (Le = $e[$e.length - 1], K.set(Ne, (K.get(Ne) || 0) + 1), Ne & l && K.set(l, (K.get(l) || 0) + 1), Ne & Xe)
            if (Ne & (q | $)) {
              me[Se] = Le._level;
              var Re = (Ne === q ? He : Oe)(Le._level);
              Re <= se && !nt && !Je ? $e.push({
                _level: Re,
                _override: 0,
                _isolate: 0
              }) : nt || Je++;
            } else if (Ne & (j | re)) {
              me[Se] = Le._level;
              var Be = (Ne === j ? He : Oe)(Le._level);
              Be <= se && !nt && !Je ? $e.push({
                _level: Be,
                _override: Ne & j ? E : P,
                _isolate: 0
              }) : nt || Je++;
            } else if (Ne & o) {
              Ne & V && (Ne = mp(Se + 1, !0) === 1 ? ce : ie), me[Se] = Le._level, Le._override && he(Se, Le._override);
              var je = (Ne === ce ? He : Oe)(Le._level);
              je <= se && nt === 0 && Je === 0 ? (bt++, $e.push({
                _level: je,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Se
              })) : nt++;
            } else if (Ne & Y) {
              if (nt > 0)
                nt--;
              else if (bt > 0) {
                for (Je = 0; !$e[$e.length - 1]._isolate; )
                  $e.pop();
                var Ge = $e[$e.length - 1]._isolInitIndex;
                Ge != null && (ge.set(Ge, Se), ge.set(Se, Ge)), $e.pop(), bt--;
              }
              Le = $e[$e.length - 1], me[Se] = Le._level, Le._override && he(Se, Le._override);
            } else Ne & oe ? (nt === 0 && (Je > 0 ? Je-- : !Le._isolate && $e.length > 1 && ($e.pop(), Le = $e[$e.length - 1])), me[Se] = Le._level) : Ne & O && (me[Se] = Ee.level);
          else
            me[Se] = Le._level, Le._override && Ne !== ue && he(Se, Le._override);
        }
        for (var ut = [], at = null, dt = Ee.start; dt <= Ee.end; dt++) {
          var pt = z[dt];
          if (!(pt & c)) {
            var zt = me[dt], Kt = pt & o, rn = pt === Y;
            at && zt === at._level ? (at._end = dt, at._endsWithIsolInit = Kt) : ut.push(at = {
              _start: dt,
              _end: dt,
              _level: zt,
              _startsWithPDI: rn,
              _endsWithIsolInit: Kt
            });
          }
        }
        for (var Bn = [], bn = 0; bn < ut.length; bn++) {
          var Kn = ut[bn];
          if (!Kn._startsWithPDI || Kn._startsWithPDI && !ge.has(Kn._start)) {
            for (var fi = [at = Kn], pi = void 0; at && at._endsWithIsolInit && (pi = ge.get(at._end)) != null; )
              for (var Vn = bn + 1; Vn < ut.length; Vn++)
                if (ut[Vn]._start === pi) {
                  fi.push(at = ut[Vn]);
                  break;
                }
            for (var wn = [], ri = 0; ri < fi.length; ri++)
              for (var ki = fi[ri], pe = ki._start; pe <= ki._end; pe++)
                wn.push(pe);
            for (var xe = me[wn[0]], Te = Ee.level, Ue = wn[0] - 1; Ue >= 0; Ue--)
              if (!(z[Ue] & c)) {
                Te = me[Ue];
                break;
              }
            var W = wn[wn.length - 1], ve = me[W], ye = Ee.level;
            if (!(z[W] & o)) {
              for (var Ce = W + 1; Ce <= Ee.end; Ce++)
                if (!(z[Ce] & c)) {
                  ye = me[Ce];
                  break;
                }
            }
            Bn.push({
              _seqIndices: wn,
              _sosType: Math.max(Te, xe) % 2 ? E : P,
              _eosType: Math.max(ye, ve) % 2 ? E : P
            });
          }
        }
        for (var be = 0; be < Bn.length; be++) {
          var ke = Bn[be], De = ke._seqIndices, Qe = ke._sosType, it = ke._eosType, mt = me[De[0]] & 1 ? E : P;
          if (K.get(Q))
            for (var gt = 0; gt < De.length; gt++) {
              var lt = De[gt];
              if (z[lt] & Q) {
                for (var Rt = Qe, Ht = gt - 1; Ht >= 0; Ht--)
                  if (!(z[De[Ht]] & c)) {
                    Rt = z[De[Ht]];
                    break;
                  }
                he(lt, Rt & (o | Y) ? G : Rt);
              }
            }
          if (K.get(y))
            for (var $t = 0; $t < De.length; $t++) {
              var Dn = De[$t];
              if (z[Dn] & y)
                for (var kt = $t - 1; kt >= -1; kt--) {
                  var ht = kt === -1 ? Qe : z[De[kt]];
                  if (ht & a) {
                    ht === le && he(Dn, U);
                    break;
                  }
                }
            }
          if (K.get(le))
            for (var mi = 0; mi < De.length; mi++) {
              var Lt = De[mi];
              z[Lt] & le && he(Lt, E);
            }
          if (K.get(w) || K.get(R))
            for (var kn = 1; kn < De.length - 1; kn++) {
              var Zi = De[kn];
              if (z[Zi] & (w | R)) {
                for (var Sn = 0, us = 0, Yt = kn - 1; Yt >= 0 && (Sn = z[De[Yt]], !!(Sn & c)); Yt--)
                  ;
                for (var oi = kn + 1; oi < De.length && (us = z[De[oi]], !!(us & c)); oi++)
                  ;
                Sn === us && (z[Zi] === w ? Sn === y : Sn & (y | U)) && he(Zi, Sn);
              }
            }
          if (K.get(y))
            for (var Gn = 0; Gn < De.length; Gn++) {
              var ai = De[Gn];
              if (z[ai] & y) {
                for (var vi = Gn - 1; vi >= 0 && z[De[vi]] & (D | c); vi--)
                  he(De[vi], y);
                for (Gn++; Gn < De.length && z[De[Gn]] & (D | c | y); Gn++)
                  z[De[Gn]] !== y && he(De[Gn], y);
              }
            }
          if (K.get(D) || K.get(w) || K.get(R))
            for (var li = 0; li < De.length; li++) {
              var na = De[li];
              if (z[na] & (D | w | R)) {
                he(na, G);
                for (var Pl = li - 1; Pl >= 0 && z[De[Pl]] & c; Pl--)
                  he(De[Pl], G);
                for (var Rl = li + 1; Rl < De.length && z[De[Rl]] & c; Rl++)
                  he(De[Rl], G);
              }
            }
          if (K.get(y))
            for (var Uu = 0, ip = Qe; Uu < De.length; Uu++) {
              var sp = De[Uu], Ou = z[sp];
              Ou & y ? ip === P && he(sp, P) : Ou & a && (ip = Ou);
            }
          if (K.get(l)) {
            var ia = E | y | U, rp = ia | P, Dl = [];
            {
              for (var Zr = [], Kr = 0; Kr < De.length; Kr++)
                if (z[De[Kr]] & l) {
                  var sa = B[De[Kr]], op = void 0;
                  if (b(sa) !== null)
                    if (Zr.length < 63)
                      Zr.push({ char: sa, seqIndex: Kr });
                    else
                      break;
                  else if ((op = C(sa)) !== null)
                    for (var ra = Zr.length - 1; ra >= 0; ra--) {
                      var zu = Zr[ra].char;
                      if (zu === op || zu === C(T(sa)) || b(T(zu)) === sa) {
                        Dl.push([Zr[ra].seqIndex, Kr]), Zr.length = ra;
                        break;
                      }
                    }
                }
              Dl.sort(function(ci, Li) {
                return ci[0] - Li[0];
              });
            }
            for (var Nu = 0; Nu < Dl.length; Nu++) {
              for (var ap = Dl[Nu], kl = ap[0], Bu = ap[1], lp = !1, Ii = 0, Vu = kl + 1; Vu < Bu; Vu++) {
                var cp = De[Vu];
                if (z[cp] & rp) {
                  lp = !0;
                  var up = z[cp] & ia ? E : P;
                  if (up === mt) {
                    Ii = up;
                    break;
                  }
                }
              }
              if (lp && !Ii) {
                Ii = Qe;
                for (var Gu = kl - 1; Gu >= 0; Gu--) {
                  var dp = De[Gu];
                  if (z[dp] & rp) {
                    var hp = z[dp] & ia ? E : P;
                    hp !== mt ? Ii = hp : Ii = mt;
                    break;
                  }
                }
              }
              if (Ii) {
                if (z[De[kl]] = z[De[Bu]] = Ii, Ii !== mt) {
                  for (var oa = kl + 1; oa < De.length; oa++)
                    if (!(z[De[oa]] & c)) {
                      m(B[De[oa]]) & Q && (z[De[oa]] = Ii);
                      break;
                    }
                }
                if (Ii !== mt) {
                  for (var aa = Bu + 1; aa < De.length; aa++)
                    if (!(z[De[aa]] & c)) {
                      m(B[De[aa]]) & Q && (z[De[aa]] = Ii);
                      break;
                    }
                }
              }
            }
            for (var zs = 0; zs < De.length; zs++)
              if (z[De[zs]] & l) {
                for (var fp = zs, Hu = zs, $u = Qe, la = zs - 1; la >= 0; la--)
                  if (z[De[la]] & c)
                    fp = la;
                  else {
                    $u = z[De[la]] & ia ? E : P;
                    break;
                  }
                for (var pp = it, ca = zs + 1; ca < De.length; ca++)
                  if (z[De[ca]] & (l | c))
                    Hu = ca;
                  else {
                    pp = z[De[ca]] & ia ? E : P;
                    break;
                  }
                for (var Wu = fp; Wu <= Hu; Wu++)
                  z[De[Wu]] = $u === pp ? $u : mt;
                zs = Hu;
              }
          }
        }
        for (var gi = Ee.start; gi <= Ee.end; gi++) {
          var n1 = me[gi], Il = z[gi];
          if (n1 & 1 ? Il & (P | y | U) && me[gi]++ : Il & E ? me[gi]++ : Il & (U | y) && (me[gi] += 2), Il & c && (me[gi] = gi === 0 ? Ee.level : me[gi - 1]), gi === Ee.end || m(B[gi]) & (A | O))
            for (var Ll = gi; Ll >= 0 && m(B[Ll]) & u; Ll--)
              me[Ll] = Ee.level;
        }
      }
      return {
        levels: me,
        paragraphs: Me
      };
      function mp(ci, Li) {
        for (var ui = ci; ui < B.length; ui++) {
          var Ns = z[ui];
          if (Ns & (E | le))
            return 1;
          if (Ns & (O | P) || Li && Ns === Y)
            return 0;
          if (Ns & o) {
            var vp = i1(ui);
            ui = vp === -1 ? B.length : vp;
          }
        }
        return 0;
      }
      function i1(ci) {
        for (var Li = 1, ui = ci + 1; ui < B.length; ui++) {
          var Ns = z[ui];
          if (Ns & O)
            break;
          if (Ns & Y) {
            if (--Li === 0)
              return ui;
          } else Ns & o && Li++;
        }
        return -1;
      }
    }
    var I = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", F;
    function L() {
      if (!F) {
        var B = _(I, !0), X = B.map, se = B.reverseMap;
        se.forEach(function(z, N) {
          X.set(N, z);
        }), F = X;
      }
    }
    function ee(B) {
      return L(), F.get(B) || null;
    }
    function Z(B, X, se, z) {
      var N = B.length;
      se = Math.max(0, se == null ? 0 : +se), z = Math.min(N - 1, z == null ? N - 1 : +z);
      for (var K = /* @__PURE__ */ new Map(), he = se; he <= z; he++)
        if (X[he] & 1) {
          var me = ee(B[he]);
          me !== null && K.set(he, me);
        }
      return K;
    }
    function k(B, X, se, z) {
      var N = B.length;
      se = Math.max(0, se == null ? 0 : +se), z = Math.min(N - 1, z == null ? N - 1 : +z);
      var K = [];
      return X.paragraphs.forEach(function(he) {
        var me = Math.max(se, he.start), ge = Math.min(z, he.end);
        if (me < ge) {
          for (var Me = X.levels.slice(me, ge + 1), Ee = ge; Ee >= me && m(B[Ee]) & u; Ee--)
            Me[Ee] = he.level;
          for (var Ae = he.level, Xe = 1 / 0, Oe = 0; Oe < Me.length; Oe++) {
            var He = Me[Oe];
            He > Ae && (Ae = He), He < Xe && (Xe = He | 1);
          }
          for (var Ye = Ae; Ye >= Xe; Ye--)
            for (var $e = 0; $e < Me.length; $e++)
              if (Me[$e] >= Ye) {
                for (var Le = $e; $e + 1 < Me.length && Me[$e + 1] >= Ye; )
                  $e++;
                $e > Le && K.push([Le + me, $e + me]);
              }
        }
      }), K;
    }
    function ne(B, X, se, z) {
      var N = J(B, X, se, z), K = [].concat(B);
      return N.forEach(function(he, me) {
        K[me] = (X.levels[he] & 1 ? ee(B[he]) : null) || B[he];
      }), K.join("");
    }
    function J(B, X, se, z) {
      for (var N = k(B, X, se, z), K = [], he = 0; he < B.length; he++)
        K[he] = he;
      return N.forEach(function(me) {
        for (var ge = me[0], Me = me[1], Ee = K.slice(ge, Me + 1), Ae = Ee.length; Ae--; )
          K[Me - Ae] = Ee[Ae];
      }), K;
    }
    return e.closingToOpeningBracket = C, e.getBidiCharType = m, e.getBidiCharTypeName = p, e.getCanonicalBracket = T, e.getEmbeddingLevels = H, e.getMirroredCharacter = ee, e.getMirroredCharactersMap = Z, e.getReorderSegments = k, e.getReorderedIndices = J, e.getReorderedString = ne, e.openingToClosingBracket = b, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
const Oy = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function tf(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function n(i, r) {
    let o = Et[r];
    return o ? tf(o) : i;
  }
  return s.replace(e, n);
}
const In = [];
for (let s = 0; s < 256; s++)
  In[s] = (s < 16 ? "0" : "") + s.toString(16);
function dN() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (In[s & 255] + In[s >> 8 & 255] + In[s >> 16 & 255] + In[s >> 24 & 255] + "-" + In[e & 255] + In[e >> 8 & 255] + "-" + In[e >> 16 & 15 | 64] + In[e >> 24 & 255] + "-" + In[n & 63 | 128] + In[n >> 8 & 255] + "-" + In[n >> 16 & 255] + In[n >> 24 & 255] + In[i & 255] + In[i >> 8 & 255] + In[i >> 16 & 255] + In[i >> 24 & 255]).toUpperCase();
}
const Cr = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, n = arguments.length; e < n; e++) {
    let i = arguments[e];
    if (i)
      for (let r in i)
        Object.prototype.hasOwnProperty.call(i, r) && (s[r] = i[r]);
  }
  return s;
}, hN = Date.now(), Vv = /* @__PURE__ */ new WeakMap(), Gv = /* @__PURE__ */ new Map();
let fN = 1e10;
function nf(s, e) {
  const n = gN(e);
  let i = Vv.get(s);
  if (i || Vv.set(s, i = /* @__PURE__ */ Object.create(null)), i[n])
    return new i[n]();
  const r = `_onBeforeCompile${n}`, o = function(u, d) {
    s.onBeforeCompile.call(this, u, d);
    const h = this.customProgramCacheKey() + "|" + u.vertexShader + "|" + u.fragmentShader;
    let m = Gv[h];
    if (!m) {
      const p = pN(this, u, e, n);
      m = Gv[h] = p;
    }
    u.vertexShader = m.vertexShader, u.fragmentShader = m.fragmentShader, Cr(u.uniforms, this.uniforms), e.timeUniform && (u.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - hN;
      }
    }), this[r] && this[r](u);
  }, a = function() {
    return l(e.chained ? s : s.clone());
  }, l = function(u) {
    const d = Object.create(u, c);
    return Object.defineProperty(d, "baseMaterial", { value: s }), Object.defineProperty(d, "id", { value: fN++ }), d.uuid = dN(), d.uniforms = Cr({}, u.uniforms, e.uniforms), d.defines = Cr({}, u.defines, e.defines), d.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = "", d.extensions = Cr({}, u.extensions, e.extensions), d._listeners = void 0, d;
  }, c = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => s.type,
      set: (u) => {
        s.type = u;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        const d = this.baseMaterial;
        return u === d || d.isDerivedMaterial && d.isDerivedFrom(u) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + n;
      }
    },
    onBeforeCompile: {
      get() {
        return o;
      },
      set(u) {
        this[r] = u;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        return s.copy.call(this, u), !s.isShaderMaterial && !s.isDerivedMaterial && (Cr(this.extensions, u.extensions), Cr(this.defines, u.defines), Cr(this.uniforms, Ml.clone(u.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const u = new s.constructor();
        return l(u).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._depthMaterial;
        return u || (u = this._depthMaterial = nf(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Nf({ depthPacking: Df }),
          e
        ), u.defines.IS_DEPTH_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._distanceMaterial;
        return u || (u = this._distanceMaterial = nf(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new py(),
          e
        ), u.defines.IS_DISTANCE_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: u, _distanceMaterial: d } = this;
        u && u.dispose(), d && d.dispose(), s.dispose.call(this);
      }
    }
  };
  return i[n] = a, new a();
}
function pN(s, { vertexShader: e, fragmentShader: n }, i, r) {
  let {
    vertexDefs: o,
    vertexMainIntro: a,
    vertexMainOutro: l,
    vertexTransform: c,
    fragmentDefs: u,
    fragmentMainIntro: d,
    fragmentMainOutro: h,
    fragmentColorTransform: m,
    customRewriter: p,
    timeUniform: v
  } = i;
  if (o = o || "", a = a || "", l = l || "", u = u || "", d = d || "", h = h || "", (c || p) && (e = tf(e)), (m || p) && (n = n.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), n = tf(n)), p) {
    let _ = p({ vertexShader: e, fragmentShader: n });
    e = _.vertexShader, n = _.fragmentShader;
  }
  if (m) {
    let _ = [];
    n = n.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (_.push(g), "")
    ), h = `${m}
${_.join(`
`)}
${h}`;
  }
  if (v) {
    const _ = `
uniform float ${v};
`;
    o = _ + o, u = _ + u;
  }
  return c && (e = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${e}
`, o = `${o}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${c}
}
`, a = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (_, g, x, M) => /\battribute\s+vec[23]\s+$/.test(M.substr(0, x)) ? g : `troika_${g}_${r}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${r}`))), e = Hv(e, r, o, a, l), n = Hv(n, r, u, d, h), {
    vertexShader: e,
    fragmentShader: n
  };
}
function Hv(s, e, n, i, r) {
  return (i || r || n) && (s = s.replace(
    Oy,
    `
${n}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${r}
}`), s;
}
function mN(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let vN = 0;
const $v = /* @__PURE__ */ new Map();
function gN(s) {
  const e = JSON.stringify(s, mN);
  let n = $v.get(e);
  return n == null && $v.set(e, n = ++vN), n;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function yN() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(r) {
      var o = e._bin, a = new Uint8Array(r);
      if (o.readASCII(a, 0, 4) == "ttcf") {
        var l = 4;
        o.readUshort(a, l), l += 2, o.readUshort(a, l), l += 2;
        var c = o.readUint(a, l);
        l += 4;
        for (var u = [], d = 0; d < c; d++) {
          var h = o.readUint(a, l);
          l += 4, u.push(e._readFont(a, h));
        }
        return u;
      }
      return [e._readFont(a, 0)];
    }, _readFont: function(r, o) {
      var a = e._bin, l = o;
      a.readFixed(r, o), o += 4;
      var c = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2;
      for (var u = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], d = { _data: r, _offset: l }, h = {}, m = 0; m < c; m++) {
        var p = a.readASCII(r, o, 4);
        o += 4, a.readUint(r, o), o += 4;
        var v = a.readUint(r, o);
        o += 4;
        var _ = a.readUint(r, o);
        o += 4, h[p] = { offset: v, length: _ };
      }
      for (m = 0; m < u.length; m++) {
        var g = u[m];
        h[g] && (d[g.trim()] = e[g.trim()].parse(r, h[g].offset, h[g].length, d));
      }
      return d;
    }, _tabOffset: function(r, o, a) {
      for (var l = e._bin, c = l.readUshort(r, a + 4), u = a + 12, d = 0; d < c; d++) {
        var h = l.readASCII(r, u, 4);
        u += 4, l.readUint(r, u), u += 4;
        var m = l.readUint(r, u);
        if (u += 4, l.readUint(r, u), u += 4, h == o) return m;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r, o) {
      return (r[o] << 8 | r[o + 1]) + (r[o + 2] << 8 | r[o + 3]) / 65540;
    }, readF2dot14: function(r, o) {
      return e._bin.readShort(r, o) / 16384;
    }, readInt: function(r, o) {
      return e._bin._view(r).getInt32(o);
    }, readInt8: function(r, o) {
      return e._bin._view(r).getInt8(o);
    }, readShort: function(r, o) {
      return e._bin._view(r).getInt16(o);
    }, readUshort: function(r, o) {
      return e._bin._view(r).getUint16(o);
    }, readUshorts: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(e._bin.readUshort(r, o + 2 * c));
      return l;
    }, readUint: function(r, o) {
      return e._bin._view(r).getUint32(o);
    }, readUint64: function(r, o) {
      return 4294967296 * e._bin.readUint(r, o) + e._bin.readUint(r, o + 4);
    }, readASCII: function(r, o, a) {
      for (var l = "", c = 0; c < a; c++) l += String.fromCharCode(r[o + c]);
      return l;
    }, readUnicode: function(r, o, a) {
      for (var l = "", c = 0; c < a; c++) {
        var u = r[o++] << 8 | r[o++];
        l += String.fromCharCode(u);
      }
      return l;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r, o, a) {
      var l = e._bin._tdec;
      return l && o == 0 && a == r.length ? l.decode(r) : e._bin.readASCII(r, o, a);
    }, readBytes: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(r[o + c]);
      return l;
    }, readASCIIArray: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(String.fromCharCode(r[o + c]));
      return l;
    }, _view: function(r) {
      return r._dataView || (r._dataView = r.buffer ? new DataView(r.buffer, r.byteOffset, r.byteLength) : new DataView(new Uint8Array(r).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r, o, a, l, c) {
      var u = e._bin, d = {}, h = o;
      u.readFixed(r, o), o += 4;
      var m = u.readUshort(r, o);
      o += 2;
      var p = u.readUshort(r, o);
      o += 2;
      var v = u.readUshort(r, o);
      return o += 2, d.scriptList = e._lctf.readScriptList(r, h + m), d.featureList = e._lctf.readFeatureList(r, h + p), d.lookupList = e._lctf.readLookupList(r, h + v, c), d;
    }, e._lctf.readLookupList = function(r, o, a) {
      var l = e._bin, c = o, u = [], d = l.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        var m = l.readUshort(r, o);
        o += 2;
        var p = e._lctf.readLookupTable(r, c + m, a);
        u.push(p);
      }
      return u;
    }, e._lctf.readLookupTable = function(r, o, a) {
      var l = e._bin, c = o, u = { tabs: [] };
      u.ltype = l.readUshort(r, o), o += 2, u.flag = l.readUshort(r, o), o += 2;
      var d = l.readUshort(r, o);
      o += 2;
      for (var h = u.ltype, m = 0; m < d; m++) {
        var p = l.readUshort(r, o);
        o += 2;
        var v = a(r, h, c + p, u);
        u.tabs.push(v);
      }
      return u;
    }, e._lctf.numOfOnes = function(r) {
      for (var o = 0, a = 0; a < 32; a++) r >>> a & 1 && o++;
      return o;
    }, e._lctf.readClassDef = function(r, o) {
      var a = e._bin, l = [], c = a.readUshort(r, o);
      if (o += 2, c == 1) {
        var u = a.readUshort(r, o);
        o += 2;
        var d = a.readUshort(r, o);
        o += 2;
        for (var h = 0; h < d; h++) l.push(u + h), l.push(u + h), l.push(a.readUshort(r, o)), o += 2;
      }
      if (c == 2) {
        var m = a.readUshort(r, o);
        for (o += 2, h = 0; h < m; h++) l.push(a.readUshort(r, o)), o += 2, l.push(a.readUshort(r, o)), o += 2, l.push(a.readUshort(r, o)), o += 2;
      }
      return l;
    }, e._lctf.getInterval = function(r, o) {
      for (var a = 0; a < r.length; a += 3) {
        var l = r[a], c = r[a + 1];
        if (r[a + 2], l <= o && o <= c) return a;
      }
      return -1;
    }, e._lctf.readCoverage = function(r, o) {
      var a = e._bin, l = {};
      l.fmt = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      return o += 2, l.fmt == 1 && (l.tab = a.readUshorts(r, o, c)), l.fmt == 2 && (l.tab = a.readUshorts(r, o, 3 * c)), l;
    }, e._lctf.coverageIndex = function(r, o) {
      var a = r.tab;
      if (r.fmt == 1) return a.indexOf(o);
      if (r.fmt == 2) {
        var l = e._lctf.getInterval(a, o);
        if (l != -1) return a[l + 2] + (o - a[l]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readASCII(r, o, 4);
        o += 4;
        var m = a.readUshort(r, o);
        o += 2;
        var p = e._lctf.readFeatureTable(r, l + m);
        p.tag = h.trim(), c.push(p);
      }
      return c;
    }, e._lctf.readFeatureTable = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2, u > 0 && (c.featureParams = l + u);
      var d = a.readUshort(r, o);
      o += 2, c.tab = [];
      for (var h = 0; h < d; h++) c.tab.push(a.readUshort(r, o + 2 * h));
      return c;
    }, e._lctf.readScriptList = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readASCII(r, o, 4);
        o += 4;
        var m = a.readUshort(r, o);
        o += 2, c[h.trim()] = e._lctf.readScriptTable(r, l + m);
      }
      return c;
    }, e._lctf.readScriptTable = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2, u > 0 && (c.default = e._lctf.readLangSysTable(r, l + u));
      var d = a.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        var m = a.readASCII(r, o, 4);
        o += 4;
        var p = a.readUshort(r, o);
        o += 2, c[m.trim()] = e._lctf.readLangSysTable(r, l + p);
      }
      return c;
    }, e._lctf.readLangSysTable = function(r, o) {
      var a = e._bin, l = {};
      a.readUshort(r, o), o += 2, l.reqFeature = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      return o += 2, l.features = a.readUshorts(r, o, c), l;
    }, e.CFF = {}, e.CFF.parse = function(r, o, a) {
      var l = e._bin;
      (r = new Uint8Array(r.buffer, o, a))[o = 0], r[++o], r[++o], r[++o], o++;
      var c = [];
      o = e.CFF.readIndex(r, o, c);
      for (var u = [], d = 0; d < c.length - 1; d++) u.push(l.readASCII(r, o + c[d], c[d + 1] - c[d]));
      o += c[c.length - 1];
      var h = [];
      o = e.CFF.readIndex(r, o, h);
      var m = [];
      for (d = 0; d < h.length - 1; d++) m.push(e.CFF.readDict(r, o + h[d], o + h[d + 1]));
      o += h[h.length - 1];
      var p = m[0], v = [];
      o = e.CFF.readIndex(r, o, v);
      var _ = [];
      for (d = 0; d < v.length - 1; d++) _.push(l.readASCII(r, o + v[d], v[d + 1] - v[d]));
      if (o += v[v.length - 1], e.CFF.readSubrs(r, o, p), p.CharStrings) {
        o = p.CharStrings, v = [], o = e.CFF.readIndex(r, o, v);
        var g = [];
        for (d = 0; d < v.length - 1; d++) g.push(l.readBytes(r, o + v[d], v[d + 1] - v[d]));
        p.CharStrings = g;
      }
      if (p.ROS) {
        o = p.FDArray;
        var x = [];
        for (o = e.CFF.readIndex(r, o, x), p.FDArray = [], d = 0; d < x.length - 1; d++) {
          var M = e.CFF.readDict(r, o + x[d], o + x[d + 1]);
          e.CFF._readFDict(r, M, _), p.FDArray.push(M);
        }
        o += x[x.length - 1], o = p.FDSelect, p.FDSelect = [];
        var S = r[o];
        if (o++, S != 3) throw S;
        var b = l.readUshort(r, o);
        for (o += 2, d = 0; d < b + 1; d++) p.FDSelect.push(l.readUshort(r, o), r[o + 2]), o += 3;
      }
      return p.Encoding && (p.Encoding = e.CFF.readEncoding(r, p.Encoding, p.CharStrings.length)), p.charset && (p.charset = e.CFF.readCharset(r, p.charset, p.CharStrings.length)), e.CFF._readFDict(r, p, _), p;
    }, e.CFF._readFDict = function(r, o, a) {
      var l;
      for (var c in o.Private && (l = o.Private[1], o.Private = e.CFF.readDict(r, l, l + o.Private[0]), o.Private.Subrs && e.CFF.readSubrs(r, l + o.Private.Subrs, o.Private)), o) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(c) != -1 && (o[c] = a[o[c] - 426 + 35]);
    }, e.CFF.readSubrs = function(r, o, a) {
      var l = e._bin, c = [];
      o = e.CFF.readIndex(r, o, c);
      var u, d = c.length;
      u = d < 1240 ? 107 : d < 33900 ? 1131 : 32768, a.Bias = u, a.Subrs = [];
      for (var h = 0; h < c.length - 1; h++) a.Subrs.push(l.readBytes(r, o + c[h], c[h + 1] - c[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r, o) {
      for (var a = 0; a < r.charset.length; a++) if (r.charset[a] == o) return a;
      return -1;
    }, e.CFF.glyphBySE = function(r, o) {
      return o < 0 || o > 255 ? -1 : e.CFF.glyphByUnicode(r, e.CFF.tableSE[o]);
    }, e.CFF.readEncoding = function(r, o, a) {
      e._bin;
      var l = [".notdef"], c = r[o];
      if (o++, c != 0) throw "error: unknown encoding format: " + c;
      var u = r[o];
      o++;
      for (var d = 0; d < u; d++) l.push(r[o + d]);
      return l;
    }, e.CFF.readCharset = function(r, o, a) {
      var l = e._bin, c = [".notdef"], u = r[o];
      if (o++, u == 0) for (var d = 0; d < a; d++) {
        var h = l.readUshort(r, o);
        o += 2, c.push(h);
      }
      else {
        if (u != 1 && u != 2) throw "error: format: " + u;
        for (; c.length < a; ) {
          h = l.readUshort(r, o), o += 2;
          var m = 0;
          for (u == 1 ? (m = r[o], o++) : (m = l.readUshort(r, o), o += 2), d = 0; d <= m; d++) c.push(h), h++;
        }
      }
      return c;
    }, e.CFF.readIndex = function(r, o, a) {
      var l = e._bin, c = l.readUshort(r, o) + 1, u = r[o += 2];
      if (o++, u == 1) for (var d = 0; d < c; d++) a.push(r[o + d]);
      else if (u == 2) for (d = 0; d < c; d++) a.push(l.readUshort(r, o + 2 * d));
      else if (u == 3) for (d = 0; d < c; d++) a.push(16777215 & l.readUint(r, o + 3 * d - 1));
      else if (c != 1) throw "unsupported offset size: " + u + ", count: " + c;
      return (o += c * u) - 1;
    }, e.CFF.getCharString = function(r, o, a) {
      var l = e._bin, c = r[o], u = r[o + 1];
      r[o + 2], r[o + 3], r[o + 4];
      var d = 1, h = null, m = null;
      c <= 20 && (h = c, d = 1), c == 12 && (h = 100 * c + u, d = 2), 21 <= c && c <= 27 && (h = c, d = 1), c == 28 && (m = l.readShort(r, o + 1), d = 3), 29 <= c && c <= 31 && (h = c, d = 1), 32 <= c && c <= 246 && (m = c - 139, d = 1), 247 <= c && c <= 250 && (m = 256 * (c - 247) + u + 108, d = 2), 251 <= c && c <= 254 && (m = 256 * -(c - 251) - u - 108, d = 2), c == 255 && (m = l.readInt(r, o + 1) / 65535, d = 5), a.val = m ?? "o" + h, a.size = d;
    }, e.CFF.readCharString = function(r, o, a) {
      for (var l = o + a, c = e._bin, u = []; o < l; ) {
        var d = r[o], h = r[o + 1];
        r[o + 2], r[o + 3], r[o + 4];
        var m = 1, p = null, v = null;
        d <= 20 && (p = d, m = 1), d == 12 && (p = 100 * d + h, m = 2), d != 19 && d != 20 || (p = d, m = 2), 21 <= d && d <= 27 && (p = d, m = 1), d == 28 && (v = c.readShort(r, o + 1), m = 3), 29 <= d && d <= 31 && (p = d, m = 1), 32 <= d && d <= 246 && (v = d - 139, m = 1), 247 <= d && d <= 250 && (v = 256 * (d - 247) + h + 108, m = 2), 251 <= d && d <= 254 && (v = 256 * -(d - 251) - h - 108, m = 2), d == 255 && (v = c.readInt(r, o + 1) / 65535, m = 5), u.push(v ?? "o" + p), o += m;
      }
      return u;
    }, e.CFF.readDict = function(r, o, a) {
      for (var l = e._bin, c = {}, u = []; o < a; ) {
        var d = r[o], h = r[o + 1];
        r[o + 2], r[o + 3], r[o + 4];
        var m = 1, p = null, v = null;
        if (d == 28 && (v = l.readShort(r, o + 1), m = 3), d == 29 && (v = l.readInt(r, o + 1), m = 5), 32 <= d && d <= 246 && (v = d - 139, m = 1), 247 <= d && d <= 250 && (v = 256 * (d - 247) + h + 108, m = 2), 251 <= d && d <= 254 && (v = 256 * -(d - 251) - h - 108, m = 2), d == 255) throw v = l.readInt(r, o + 1) / 65535, m = 5, "unknown number";
        if (d == 30) {
          var _ = [];
          for (m = 1; ; ) {
            var g = r[o + m];
            m++;
            var x = g >> 4, M = 15 & g;
            if (x != 15 && _.push(x), M != 15 && _.push(M), M == 15) break;
          }
          for (var S = "", b = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], C = 0; C < _.length; C++) S += b[_[C]];
          v = parseFloat(S);
        }
        d <= 21 && (p = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][d], m = 1, d == 12 && (p = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], m = 2)), p != null ? (c[p] = u.length == 1 ? u[0] : u, u = []) : u.push(v), o += m;
      }
      return c;
    }, e.cmap = {}, e.cmap.parse = function(r, o, a) {
      r = new Uint8Array(r.buffer, o, a), o = 0;
      var l = e._bin, c = {};
      l.readUshort(r, o), o += 2;
      var u = l.readUshort(r, o);
      o += 2;
      var d = [];
      c.tables = [];
      for (var h = 0; h < u; h++) {
        var m = l.readUshort(r, o);
        o += 2;
        var p = l.readUshort(r, o);
        o += 2;
        var v = l.readUint(r, o);
        o += 4;
        var _ = "p" + m + "e" + p, g = d.indexOf(v);
        if (g == -1) {
          var x;
          g = c.tables.length, d.push(v);
          var M = l.readUshort(r, v);
          M == 0 ? x = e.cmap.parse0(r, v) : M == 4 ? x = e.cmap.parse4(r, v) : M == 6 ? x = e.cmap.parse6(r, v) : M == 12 ? x = e.cmap.parse12(r, v) : console.debug("unknown format: " + M, m, p, v), c.tables.push(x);
        }
        if (c[_] != null) throw "multiple tables for one platform+encoding";
        c[_] = g;
      }
      return c;
    }, e.cmap.parse0 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2, l.map = [];
      for (var u = 0; u < c - 6; u++) l.map.push(r[o + u]);
      return l;
    }, e.cmap.parse4 = function(r, o) {
      var a = e._bin, l = o, c = {};
      c.format = a.readUshort(r, o), o += 2;
      var u = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2;
      var d = a.readUshort(r, o);
      o += 2;
      var h = d / 2;
      c.searchRange = a.readUshort(r, o), o += 2, c.entrySelector = a.readUshort(r, o), o += 2, c.rangeShift = a.readUshort(r, o), o += 2, c.endCount = a.readUshorts(r, o, h), o += 2 * h, o += 2, c.startCount = a.readUshorts(r, o, h), o += 2 * h, c.idDelta = [];
      for (var m = 0; m < h; m++) c.idDelta.push(a.readShort(r, o)), o += 2;
      for (c.idRangeOffset = a.readUshorts(r, o, h), o += 2 * h, c.glyphIdArray = []; o < l + u; ) c.glyphIdArray.push(a.readUshort(r, o)), o += 2;
      return c;
    }, e.cmap.parse6 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, l.firstCode = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2, l.glyphIdArray = [];
      for (var u = 0; u < c; u++) l.glyphIdArray.push(a.readUshort(r, o)), o += 2;
      return l;
    }, e.cmap.parse12 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2, o += 2, a.readUint(r, o), o += 4, a.readUint(r, o), o += 4;
      var c = a.readUint(r, o);
      o += 4, l.groups = [];
      for (var u = 0; u < c; u++) {
        var d = o + 12 * u, h = a.readUint(r, d + 0), m = a.readUint(r, d + 4), p = a.readUint(r, d + 8);
        l.groups.push([h, m, p]);
      }
      return l;
    }, e.glyf = {}, e.glyf.parse = function(r, o, a, l) {
      for (var c = [], u = 0; u < l.maxp.numGlyphs; u++) c.push(null);
      return c;
    }, e.glyf._parseGlyf = function(r, o) {
      var a = e._bin, l = r._data, c = e._tabOffset(l, "glyf", r._offset) + r.loca[o];
      if (r.loca[o] == r.loca[o + 1]) return null;
      var u = {};
      if (u.noc = a.readShort(l, c), c += 2, u.xMin = a.readShort(l, c), c += 2, u.yMin = a.readShort(l, c), c += 2, u.xMax = a.readShort(l, c), c += 2, u.yMax = a.readShort(l, c), c += 2, u.xMin >= u.xMax || u.yMin >= u.yMax) return null;
      if (u.noc > 0) {
        u.endPts = [];
        for (var d = 0; d < u.noc; d++) u.endPts.push(a.readUshort(l, c)), c += 2;
        var h = a.readUshort(l, c);
        if (c += 2, l.length - c < h) return null;
        u.instructions = a.readBytes(l, c, h), c += h;
        var m = u.endPts[u.noc - 1] + 1;
        for (u.flags = [], d = 0; d < m; d++) {
          var p = l[c];
          if (c++, u.flags.push(p), (8 & p) != 0) {
            var v = l[c];
            c++;
            for (var _ = 0; _ < v; _++) u.flags.push(p), d++;
          }
        }
        for (u.xs = [], d = 0; d < m; d++) {
          var g = (2 & u.flags[d]) != 0, x = (16 & u.flags[d]) != 0;
          g ? (u.xs.push(x ? l[c] : -l[c]), c++) : x ? u.xs.push(0) : (u.xs.push(a.readShort(l, c)), c += 2);
        }
        for (u.ys = [], d = 0; d < m; d++)
          g = (4 & u.flags[d]) != 0, x = (32 & u.flags[d]) != 0, g ? (u.ys.push(x ? l[c] : -l[c]), c++) : x ? u.ys.push(0) : (u.ys.push(a.readShort(l, c)), c += 2);
        var M = 0, S = 0;
        for (d = 0; d < m; d++) M += u.xs[d], S += u.ys[d], u.xs[d] = M, u.ys[d] = S;
      } else {
        var b;
        u.parts = [];
        do {
          b = a.readUshort(l, c), c += 2;
          var C = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (u.parts.push(C), C.glyphIndex = a.readUshort(l, c), c += 2, 1 & b) {
            var T = a.readShort(l, c);
            c += 2;
            var P = a.readShort(l, c);
            c += 2;
          } else
            T = a.readInt8(l, c), c++, P = a.readInt8(l, c), c++;
          2 & b ? (C.m.tx = T, C.m.ty = P) : (C.p1 = T, C.p2 = P), 8 & b ? (C.m.a = C.m.d = a.readF2dot14(l, c), c += 2) : 64 & b ? (C.m.a = a.readF2dot14(l, c), c += 2, C.m.d = a.readF2dot14(l, c), c += 2) : 128 & b && (C.m.a = a.readF2dot14(l, c), c += 2, C.m.b = a.readF2dot14(l, c), c += 2, C.m.c = a.readF2dot14(l, c), c += 2, C.m.d = a.readF2dot14(l, c), c += 2);
        } while (32 & b);
        if (256 & b) {
          var E = a.readUshort(l, c);
          for (c += 2, u.instr = [], d = 0; d < E; d++) u.instr.push(l[c]), c++;
        }
      }
      return u;
    }, e.GDEF = {}, e.GDEF.parse = function(r, o, a, l) {
      var c = o;
      o += 4;
      var u = e._bin.readUshort(r, o);
      return { glyphClassDef: u === 0 ? null : e._lctf.readClassDef(r, c + u) };
    }, e.GPOS = {}, e.GPOS.parse = function(r, o, a, l) {
      return e._lctf.parse(r, o, a, l, e.GPOS.subt);
    }, e.GPOS.subt = function(r, o, a, l) {
      var c = e._bin, u = a, d = {};
      if (d.fmt = c.readUshort(r, a), a += 2, o == 1 || o == 2 || o == 3 || o == 7 || o == 8 && d.fmt <= 2) {
        var h = c.readUshort(r, a);
        a += 2, d.coverage = e._lctf.readCoverage(r, h + u);
      }
      if (o == 1 && d.fmt == 1) {
        var m = c.readUshort(r, a);
        a += 2, m != 0 && (d.pos = e.GPOS.readValueRecord(r, a, m));
      } else if (o == 2 && d.fmt >= 1 && d.fmt <= 2) {
        m = c.readUshort(r, a), a += 2;
        var p = c.readUshort(r, a);
        a += 2;
        var v = e._lctf.numOfOnes(m), _ = e._lctf.numOfOnes(p);
        if (d.fmt == 1) {
          d.pairsets = [];
          var g = c.readUshort(r, a);
          a += 2;
          for (var x = 0; x < g; x++) {
            var M = u + c.readUshort(r, a);
            a += 2;
            var S = c.readUshort(r, M);
            M += 2;
            for (var b = [], C = 0; C < S; C++) {
              var T = c.readUshort(r, M);
              M += 2, m != 0 && (U = e.GPOS.readValueRecord(r, M, m), M += 2 * v), p != 0 && (R = e.GPOS.readValueRecord(r, M, p), M += 2 * _), b.push({ gid2: T, val1: U, val2: R });
            }
            d.pairsets.push(b);
          }
        }
        if (d.fmt == 2) {
          var P = c.readUshort(r, a);
          a += 2;
          var E = c.readUshort(r, a);
          a += 2;
          var y = c.readUshort(r, a);
          a += 2;
          var w = c.readUshort(r, a);
          for (a += 2, d.classDef1 = e._lctf.readClassDef(r, u + P), d.classDef2 = e._lctf.readClassDef(r, u + E), d.matrix = [], x = 0; x < y; x++) {
            var D = [];
            for (C = 0; C < w; C++) {
              var U = null, R = null;
              m != 0 && (U = e.GPOS.readValueRecord(r, a, m), a += 2 * v), p != 0 && (R = e.GPOS.readValueRecord(r, a, p), a += 2 * _), D.push({ val1: U, val2: R });
            }
            d.matrix.push(D);
          }
        }
      } else if (o == 4 && d.fmt == 1) d.markCoverage = e._lctf.readCoverage(r, c.readUshort(r, a) + u), d.baseCoverage = e._lctf.readCoverage(r, c.readUshort(r, a + 2) + u), d.markClassCount = c.readUshort(r, a + 4), d.markArray = e.GPOS.readMarkArray(r, c.readUshort(r, a + 6) + u), d.baseArray = e.GPOS.readBaseArray(r, c.readUshort(r, a + 8) + u, d.markClassCount);
      else if (o == 6 && d.fmt == 1) d.mark1Coverage = e._lctf.readCoverage(r, c.readUshort(r, a) + u), d.mark2Coverage = e._lctf.readCoverage(r, c.readUshort(r, a + 2) + u), d.markClassCount = c.readUshort(r, a + 4), d.mark1Array = e.GPOS.readMarkArray(r, c.readUshort(r, a + 6) + u), d.mark2Array = e.GPOS.readBaseArray(r, c.readUshort(r, a + 8) + u, d.markClassCount);
      else {
        if (o == 9 && d.fmt == 1) {
          var O = c.readUshort(r, a);
          a += 2;
          var A = c.readUint(r, a);
          if (a += 4, l.ltype == 9) l.ltype = O;
          else if (l.ltype != O) throw "invalid extension substitution";
          return e.GPOS.subt(r, l.ltype, u + A);
        }
        console.debug("unsupported GPOS table LookupType", o, "format", d.fmt);
      }
      return d;
    }, e.GPOS.readValueRecord = function(r, o, a) {
      var l = e._bin, c = [];
      return c.push(1 & a ? l.readShort(r, o) : 0), o += 1 & a ? 2 : 0, c.push(2 & a ? l.readShort(r, o) : 0), o += 2 & a ? 2 : 0, c.push(4 & a ? l.readShort(r, o) : 0), o += 4 & a ? 2 : 0, c.push(8 & a ? l.readShort(r, o) : 0), o += 8 & a ? 2 : 0, c;
    }, e.GPOS.readBaseArray = function(r, o, a) {
      var l = e._bin, c = [], u = o, d = l.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        for (var m = [], p = 0; p < a; p++) m.push(e.GPOS.readAnchorRecord(r, u + l.readUshort(r, o))), o += 2;
        c.push(m);
      }
      return c;
    }, e.GPOS.readMarkArray = function(r, o) {
      var a = e._bin, l = [], c = o, u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = e.GPOS.readAnchorRecord(r, a.readUshort(r, o + 2) + c);
        h.markClass = a.readUshort(r, o), l.push(h), o += 4;
      }
      return l;
    }, e.GPOS.readAnchorRecord = function(r, o) {
      var a = e._bin, l = {};
      return l.fmt = a.readUshort(r, o), l.x = a.readShort(r, o + 2), l.y = a.readShort(r, o + 4), l;
    }, e.GSUB = {}, e.GSUB.parse = function(r, o, a, l) {
      return e._lctf.parse(r, o, a, l, e.GSUB.subt);
    }, e.GSUB.subt = function(r, o, a, l) {
      var c = e._bin, u = a, d = {};
      if (d.fmt = c.readUshort(r, a), a += 2, o != 1 && o != 2 && o != 4 && o != 5 && o != 6) return null;
      if (o == 1 || o == 2 || o == 4 || o == 5 && d.fmt <= 2 || o == 6 && d.fmt <= 2) {
        var h = c.readUshort(r, a);
        a += 2, d.coverage = e._lctf.readCoverage(r, u + h);
      }
      if (o == 1 && d.fmt >= 1 && d.fmt <= 2) {
        if (d.fmt == 1) d.delta = c.readShort(r, a), a += 2;
        else if (d.fmt == 2) {
          var m = c.readUshort(r, a);
          a += 2, d.newg = c.readUshorts(r, a, m), a += 2 * d.newg.length;
        }
      } else if (o == 2 && d.fmt == 1) {
        m = c.readUshort(r, a), a += 2, d.seqs = [];
        for (var p = 0; p < m; p++) {
          var v = c.readUshort(r, a) + u;
          a += 2;
          var _ = c.readUshort(r, v);
          d.seqs.push(c.readUshorts(r, v + 2, _));
        }
      } else if (o == 4)
        for (d.vals = [], m = c.readUshort(r, a), a += 2, p = 0; p < m; p++) {
          var g = c.readUshort(r, a);
          a += 2, d.vals.push(e.GSUB.readLigatureSet(r, u + g));
        }
      else if (o == 5 && d.fmt == 2) {
        if (d.fmt == 2) {
          var x = c.readUshort(r, a);
          a += 2, d.cDef = e._lctf.readClassDef(r, u + x), d.scset = [];
          var M = c.readUshort(r, a);
          for (a += 2, p = 0; p < M; p++) {
            var S = c.readUshort(r, a);
            a += 2, d.scset.push(S == 0 ? null : e.GSUB.readSubClassSet(r, u + S));
          }
        }
      } else if (o == 6 && d.fmt == 3) {
        if (d.fmt == 3) {
          for (p = 0; p < 3; p++) {
            m = c.readUshort(r, a), a += 2;
            for (var b = [], C = 0; C < m; C++) b.push(e._lctf.readCoverage(r, u + c.readUshort(r, a + 2 * C)));
            a += 2 * m, p == 0 && (d.backCvg = b), p == 1 && (d.inptCvg = b), p == 2 && (d.ahedCvg = b);
          }
          m = c.readUshort(r, a), a += 2, d.lookupRec = e.GSUB.readSubstLookupRecords(r, a, m);
        }
      } else {
        if (o == 7 && d.fmt == 1) {
          var T = c.readUshort(r, a);
          a += 2;
          var P = c.readUint(r, a);
          if (a += 4, l.ltype == 9) l.ltype = T;
          else if (l.ltype != T) throw "invalid extension substitution";
          return e.GSUB.subt(r, l.ltype, u + P);
        }
        console.debug("unsupported GSUB table LookupType", o, "format", d.fmt);
      }
      return d;
    }, e.GSUB.readSubClassSet = function(r, o) {
      var a = e._bin.readUshort, l = o, c = [], u = a(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a(r, o);
        o += 2, c.push(e.GSUB.readSubClassRule(r, l + h));
      }
      return c;
    }, e.GSUB.readSubClassRule = function(r, o) {
      var a = e._bin.readUshort, l = {}, c = a(r, o), u = a(r, o += 2);
      o += 2, l.input = [];
      for (var d = 0; d < c - 1; d++) l.input.push(a(r, o)), o += 2;
      return l.substLookupRecords = e.GSUB.readSubstLookupRecords(r, o, u), l;
    }, e.GSUB.readSubstLookupRecords = function(r, o, a) {
      for (var l = e._bin.readUshort, c = [], u = 0; u < a; u++) c.push(l(r, o), l(r, o + 2)), o += 4;
      return c;
    }, e.GSUB.readChainSubClassSet = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readUshort(r, o);
        o += 2, c.push(e.GSUB.readChainSubClassRule(r, l + h));
      }
      return c;
    }, e.GSUB.readChainSubClassRule = function(r, o) {
      for (var a = e._bin, l = {}, c = ["backtrack", "input", "lookahead"], u = 0; u < c.length; u++) {
        var d = a.readUshort(r, o);
        o += 2, u == 1 && d--, l[c[u]] = a.readUshorts(r, o, d), o += 2 * l[c[u]].length;
      }
      return d = a.readUshort(r, o), o += 2, l.subst = a.readUshorts(r, o, 2 * d), o += 2 * l.subst.length, l;
    }, e.GSUB.readLigatureSet = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readUshort(r, o);
        o += 2, c.push(e.GSUB.readLigature(r, l + h));
      }
      return c;
    }, e.GSUB.readLigature = function(r, o) {
      var a = e._bin, l = { chain: [] };
      l.nglyph = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2;
      for (var u = 0; u < c - 1; u++) l.chain.push(a.readUshort(r, o)), o += 2;
      return l;
    }, e.head = {}, e.head.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(r, o), o += 4, c.fontRevision = l.readFixed(r, o), o += 4, l.readUint(r, o), o += 4, l.readUint(r, o), o += 4, c.flags = l.readUshort(r, o), o += 2, c.unitsPerEm = l.readUshort(r, o), o += 2, c.created = l.readUint64(r, o), o += 8, c.modified = l.readUint64(r, o), o += 8, c.xMin = l.readShort(r, o), o += 2, c.yMin = l.readShort(r, o), o += 2, c.xMax = l.readShort(r, o), o += 2, c.yMax = l.readShort(r, o), o += 2, c.macStyle = l.readUshort(r, o), o += 2, c.lowestRecPPEM = l.readUshort(r, o), o += 2, c.fontDirectionHint = l.readShort(r, o), o += 2, c.indexToLocFormat = l.readShort(r, o), o += 2, c.glyphDataFormat = l.readShort(r, o), o += 2, c;
    }, e.hhea = {}, e.hhea.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(r, o), o += 4, c.ascender = l.readShort(r, o), o += 2, c.descender = l.readShort(r, o), o += 2, c.lineGap = l.readShort(r, o), o += 2, c.advanceWidthMax = l.readUshort(r, o), o += 2, c.minLeftSideBearing = l.readShort(r, o), o += 2, c.minRightSideBearing = l.readShort(r, o), o += 2, c.xMaxExtent = l.readShort(r, o), o += 2, c.caretSlopeRise = l.readShort(r, o), o += 2, c.caretSlopeRun = l.readShort(r, o), o += 2, c.caretOffset = l.readShort(r, o), o += 2, o += 8, c.metricDataFormat = l.readShort(r, o), o += 2, c.numberOfHMetrics = l.readUshort(r, o), o += 2, c;
    }, e.hmtx = {}, e.hmtx.parse = function(r, o, a, l) {
      for (var c = e._bin, u = { aWidth: [], lsBearing: [] }, d = 0, h = 0, m = 0; m < l.maxp.numGlyphs; m++) m < l.hhea.numberOfHMetrics && (d = c.readUshort(r, o), o += 2, h = c.readShort(r, o), o += 2), u.aWidth.push(d), u.lsBearing.push(h);
      return u;
    }, e.kern = {}, e.kern.parse = function(r, o, a, l) {
      var c = e._bin, u = c.readUshort(r, o);
      if (o += 2, u == 1) return e.kern.parseV1(r, o - 2, a, l);
      var d = c.readUshort(r, o);
      o += 2;
      for (var h = { glyph1: [], rval: [] }, m = 0; m < d; m++) {
        o += 2, a = c.readUshort(r, o), o += 2;
        var p = c.readUshort(r, o);
        o += 2;
        var v = p >>> 8;
        if ((v &= 15) != 0) throw "unknown kern table format: " + v;
        o = e.kern.readFormat0(r, o, h);
      }
      return h;
    }, e.kern.parseV1 = function(r, o, a, l) {
      var c = e._bin;
      c.readFixed(r, o), o += 4;
      var u = c.readUint(r, o);
      o += 4;
      for (var d = { glyph1: [], rval: [] }, h = 0; h < u; h++) {
        c.readUint(r, o), o += 4;
        var m = c.readUshort(r, o);
        o += 2, c.readUshort(r, o), o += 2;
        var p = m >>> 8;
        if ((p &= 15) != 0) throw "unknown kern table format: " + p;
        o = e.kern.readFormat0(r, o, d);
      }
      return d;
    }, e.kern.readFormat0 = function(r, o, a) {
      var l = e._bin, c = -1, u = l.readUshort(r, o);
      o += 2, l.readUshort(r, o), o += 2, l.readUshort(r, o), o += 2, l.readUshort(r, o), o += 2;
      for (var d = 0; d < u; d++) {
        var h = l.readUshort(r, o);
        o += 2;
        var m = l.readUshort(r, o);
        o += 2;
        var p = l.readShort(r, o);
        o += 2, h != c && (a.glyph1.push(h), a.rval.push({ glyph2: [], vals: [] }));
        var v = a.rval[a.rval.length - 1];
        v.glyph2.push(m), v.vals.push(p), c = h;
      }
      return o;
    }, e.loca = {}, e.loca.parse = function(r, o, a, l) {
      var c = e._bin, u = [], d = l.head.indexToLocFormat, h = l.maxp.numGlyphs + 1;
      if (d == 0) for (var m = 0; m < h; m++) u.push(c.readUshort(r, o + (m << 1)) << 1);
      if (d == 1) for (m = 0; m < h; m++) u.push(c.readUint(r, o + (m << 2)));
      return u;
    }, e.maxp = {}, e.maxp.parse = function(r, o, a) {
      var l = e._bin, c = {}, u = l.readUint(r, o);
      return o += 4, c.numGlyphs = l.readUshort(r, o), o += 2, u == 65536 && (c.maxPoints = l.readUshort(r, o), o += 2, c.maxContours = l.readUshort(r, o), o += 2, c.maxCompositePoints = l.readUshort(r, o), o += 2, c.maxCompositeContours = l.readUshort(r, o), o += 2, c.maxZones = l.readUshort(r, o), o += 2, c.maxTwilightPoints = l.readUshort(r, o), o += 2, c.maxStorage = l.readUshort(r, o), o += 2, c.maxFunctionDefs = l.readUshort(r, o), o += 2, c.maxInstructionDefs = l.readUshort(r, o), o += 2, c.maxStackElements = l.readUshort(r, o), o += 2, c.maxSizeOfInstructions = l.readUshort(r, o), o += 2, c.maxComponentElements = l.readUshort(r, o), o += 2, c.maxComponentDepth = l.readUshort(r, o), o += 2), c;
    }, e.name = {}, e.name.parse = function(r, o, a) {
      var l = e._bin, c = {};
      l.readUshort(r, o), o += 2;
      var u = l.readUshort(r, o);
      o += 2, l.readUshort(r, o);
      for (var d, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], m = o += 2, p = 0; p < u; p++) {
        var v = l.readUshort(r, o);
        o += 2;
        var _ = l.readUshort(r, o);
        o += 2;
        var g = l.readUshort(r, o);
        o += 2;
        var x = l.readUshort(r, o);
        o += 2;
        var M = l.readUshort(r, o);
        o += 2;
        var S = l.readUshort(r, o);
        o += 2;
        var b, C = h[x], T = m + 12 * u + S;
        if (v == 0) b = l.readUnicode(r, T, M / 2);
        else if (v == 3 && _ == 0) b = l.readUnicode(r, T, M / 2);
        else if (_ == 0) b = l.readASCII(r, T, M);
        else if (_ == 1) b = l.readUnicode(r, T, M / 2);
        else if (_ == 3) b = l.readUnicode(r, T, M / 2);
        else {
          if (v != 1) throw "unknown encoding " + _ + ", platformID: " + v;
          b = l.readASCII(r, T, M), console.debug("reading unknown MAC encoding " + _ + " as ASCII");
        }
        var P = "p" + v + "," + g.toString(16);
        c[P] == null && (c[P] = {}), c[P][C !== void 0 ? C : x] = b, c[P]._lang = g;
      }
      for (var E in c) if (c[E].postScriptName != null && c[E]._lang == 1033) return c[E];
      for (var E in c) if (c[E].postScriptName != null && c[E]._lang == 0) return c[E];
      for (var E in c) if (c[E].postScriptName != null && c[E]._lang == 3084) return c[E];
      for (var E in c) if (c[E].postScriptName != null) return c[E];
      for (var E in c) {
        d = E;
        break;
      }
      return console.debug("returning name table with languageID " + c[d]._lang), c[d];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r, o, a) {
      var l = e._bin.readUshort(r, o);
      o += 2;
      var c = {};
      if (l == 0) e["OS/2"].version0(r, o, c);
      else if (l == 1) e["OS/2"].version1(r, o, c);
      else if (l == 2 || l == 3 || l == 4) e["OS/2"].version2(r, o, c);
      else {
        if (l != 5) throw "unknown OS/2 table version: " + l;
        e["OS/2"].version5(r, o, c);
      }
      return c;
    }, e["OS/2"].version0 = function(r, o, a) {
      var l = e._bin;
      return a.xAvgCharWidth = l.readShort(r, o), o += 2, a.usWeightClass = l.readUshort(r, o), o += 2, a.usWidthClass = l.readUshort(r, o), o += 2, a.fsType = l.readUshort(r, o), o += 2, a.ySubscriptXSize = l.readShort(r, o), o += 2, a.ySubscriptYSize = l.readShort(r, o), o += 2, a.ySubscriptXOffset = l.readShort(r, o), o += 2, a.ySubscriptYOffset = l.readShort(r, o), o += 2, a.ySuperscriptXSize = l.readShort(r, o), o += 2, a.ySuperscriptYSize = l.readShort(r, o), o += 2, a.ySuperscriptXOffset = l.readShort(r, o), o += 2, a.ySuperscriptYOffset = l.readShort(r, o), o += 2, a.yStrikeoutSize = l.readShort(r, o), o += 2, a.yStrikeoutPosition = l.readShort(r, o), o += 2, a.sFamilyClass = l.readShort(r, o), o += 2, a.panose = l.readBytes(r, o, 10), o += 10, a.ulUnicodeRange1 = l.readUint(r, o), o += 4, a.ulUnicodeRange2 = l.readUint(r, o), o += 4, a.ulUnicodeRange3 = l.readUint(r, o), o += 4, a.ulUnicodeRange4 = l.readUint(r, o), o += 4, a.achVendID = [l.readInt8(r, o), l.readInt8(r, o + 1), l.readInt8(r, o + 2), l.readInt8(r, o + 3)], o += 4, a.fsSelection = l.readUshort(r, o), o += 2, a.usFirstCharIndex = l.readUshort(r, o), o += 2, a.usLastCharIndex = l.readUshort(r, o), o += 2, a.sTypoAscender = l.readShort(r, o), o += 2, a.sTypoDescender = l.readShort(r, o), o += 2, a.sTypoLineGap = l.readShort(r, o), o += 2, a.usWinAscent = l.readUshort(r, o), o += 2, a.usWinDescent = l.readUshort(r, o), o += 2;
    }, e["OS/2"].version1 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version0(r, o, a), a.ulCodePageRange1 = l.readUint(r, o), o += 4, a.ulCodePageRange2 = l.readUint(r, o), o += 4;
    }, e["OS/2"].version2 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version1(r, o, a), a.sxHeight = l.readShort(r, o), o += 2, a.sCapHeight = l.readShort(r, o), o += 2, a.usDefault = l.readUshort(r, o), o += 2, a.usBreak = l.readUshort(r, o), o += 2, a.usMaxContext = l.readUshort(r, o), o += 2;
    }, e["OS/2"].version5 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version2(r, o, a), a.usLowerOpticalPointSize = l.readUshort(r, o), o += 2, a.usUpperOpticalPointSize = l.readUshort(r, o), o += 2;
    }, e.post = {}, e.post.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return c.version = l.readFixed(r, o), o += 4, c.italicAngle = l.readFixed(r, o), o += 4, c.underlinePosition = l.readShort(r, o), o += 2, c.underlineThickness = l.readShort(r, o), o += 2, c;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(r, o) {
      var a = r.cmap, l = -1;
      if (a.p0e4 != null ? l = a.p0e4 : a.p3e1 != null ? l = a.p3e1 : a.p1e0 != null ? l = a.p1e0 : a.p0e3 != null && (l = a.p0e3), l == -1) throw "no familiar platform and encoding!";
      var c = a.tables[l];
      if (c.format == 0) return o >= c.map.length ? 0 : c.map[o];
      if (c.format == 4) {
        for (var u = -1, d = 0; d < c.endCount.length; d++) if (o <= c.endCount[d]) {
          u = d;
          break;
        }
        return u == -1 || c.startCount[u] > o ? 0 : 65535 & (c.idRangeOffset[u] != 0 ? c.glyphIdArray[o - c.startCount[u] + (c.idRangeOffset[u] >> 1) - (c.idRangeOffset.length - u)] : o + c.idDelta[u]);
      }
      if (c.format == 12) {
        if (o > c.groups[c.groups.length - 1][1]) return 0;
        for (d = 0; d < c.groups.length; d++) {
          var h = c.groups[d];
          if (h[0] <= o && o <= h[1]) return h[2] + (o - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + c.format;
    }, e.U.glyphToPath = function(r, o) {
      var a = { cmds: [], crds: [] };
      if (r.SVG && r.SVG.entries[o]) {
        var l = r.SVG.entries[o];
        return l == null ? a : (typeof l == "string" && (l = e.SVG.toPath(l), r.SVG.entries[o] = l), l);
      }
      if (r.CFF) {
        var c = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0, open: !1 }, u = r.CFF, d = r.CFF.Private;
        if (u.ROS) {
          for (var h = 0; u.FDSelect[h + 2] <= o; ) h += 2;
          d = u.FDArray[u.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r.CFF.CharStrings[o], c, u, d, a);
      } else r.glyf && e.U._drawGlyf(o, r, a);
      return a;
    }, e.U._drawGlyf = function(r, o, a) {
      var l = o.glyf[r];
      l == null && (l = o.glyf[r] = e.glyf._parseGlyf(o, r)), l != null && (l.noc > -1 ? e.U._simpleGlyph(l, a) : e.U._compoGlyph(l, o, a));
    }, e.U._simpleGlyph = function(r, o) {
      for (var a = 0; a < r.noc; a++) {
        for (var l = a == 0 ? 0 : r.endPts[a - 1] + 1, c = r.endPts[a], u = l; u <= c; u++) {
          var d = u == l ? c : u - 1, h = u == c ? l : u + 1, m = 1 & r.flags[u], p = 1 & r.flags[d], v = 1 & r.flags[h], _ = r.xs[u], g = r.ys[u];
          if (u == l) if (m) {
            if (!p) {
              e.U.P.moveTo(o, _, g);
              continue;
            }
            e.U.P.moveTo(o, r.xs[d], r.ys[d]);
          } else p ? e.U.P.moveTo(o, r.xs[d], r.ys[d]) : e.U.P.moveTo(o, (r.xs[d] + _) / 2, (r.ys[d] + g) / 2);
          m ? p && e.U.P.lineTo(o, _, g) : v ? e.U.P.qcurveTo(o, _, g, r.xs[h], r.ys[h]) : e.U.P.qcurveTo(o, _, g, (_ + r.xs[h]) / 2, (g + r.ys[h]) / 2);
        }
        e.U.P.closePath(o);
      }
    }, e.U._compoGlyph = function(r, o, a) {
      for (var l = 0; l < r.parts.length; l++) {
        var c = { cmds: [], crds: [] }, u = r.parts[l];
        e.U._drawGlyf(u.glyphIndex, o, c);
        for (var d = u.m, h = 0; h < c.crds.length; h += 2) {
          var m = c.crds[h], p = c.crds[h + 1];
          a.crds.push(m * d.a + p * d.b + d.tx), a.crds.push(m * d.c + p * d.d + d.ty);
        }
        for (h = 0; h < c.cmds.length; h++) a.cmds.push(c.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r, o) {
      var a = e._lctf.getInterval(o, r);
      return a == -1 ? 0 : o[a + 2];
    }, e.U._applySubs = function(r, o, a, l) {
      for (var c = r.length - o - 1, u = 0; u < a.tabs.length; u++) if (a.tabs[u] != null) {
        var d, h = a.tabs[u];
        if (!h.coverage || (d = e._lctf.coverageIndex(h.coverage, r[o])) != -1) {
          if (a.ltype == 1) r[o], h.fmt == 1 ? r[o] = r[o] + h.delta : r[o] = h.newg[d];
          else if (a.ltype == 4) for (var m = h.vals[d], p = 0; p < m.length; p++) {
            var v = m[p], _ = v.chain.length;
            if (!(_ > c)) {
              for (var g = !0, x = 0, M = 0; M < _; M++) {
                for (; r[o + x + (1 + M)] == -1; ) x++;
                v.chain[M] != r[o + x + (1 + M)] && (g = !1);
              }
              if (g) {
                for (r[o] = v.nglyph, M = 0; M < _ + x; M++) r[o + M + 1] = -1;
                break;
              }
            }
          }
          else if (a.ltype == 5 && h.fmt == 2) for (var S = e._lctf.getInterval(h.cDef, r[o]), b = h.cDef[S + 2], C = h.scset[b], T = 0; T < C.length; T++) {
            var P = C[T], E = P.input;
            if (!(E.length > c)) {
              for (g = !0, M = 0; M < E.length; M++) {
                var y = e._lctf.getInterval(h.cDef, r[o + 1 + M]);
                if (S == -1 && h.cDef[y + 2] != E[M]) {
                  g = !1;
                  break;
                }
              }
              if (g) {
                var w = P.substLookupRecords;
                for (p = 0; p < w.length; p += 2) w[p], w[p + 1];
              }
            }
          }
          else if (a.ltype == 6 && h.fmt == 3) {
            if (!e.U._glsCovered(r, h.backCvg, o - h.backCvg.length) || !e.U._glsCovered(r, h.inptCvg, o) || !e.U._glsCovered(r, h.ahedCvg, o + h.inptCvg.length)) continue;
            var D = h.lookupRec;
            for (T = 0; T < D.length; T += 2) {
              S = D[T];
              var U = l[D[T + 1]];
              e.U._applySubs(r, o + S, U, l);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r, o, a) {
      for (var l = 0; l < o.length; l++)
        if (e._lctf.coverageIndex(o[l], r[a + l]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(r, o, a) {
      for (var l = { cmds: [], crds: [] }, c = 0, u = 0; u < o.length; u++) {
        var d = o[u];
        if (d != -1) {
          for (var h = u < o.length - 1 && o[u + 1] != -1 ? o[u + 1] : 0, m = e.U.glyphToPath(r, d), p = 0; p < m.crds.length; p += 2) l.crds.push(m.crds[p] + c), l.crds.push(m.crds[p + 1]);
          for (a && l.cmds.push(a), p = 0; p < m.cmds.length; p++) l.cmds.push(m.cmds[p]);
          a && l.cmds.push("X"), c += r.hmtx.aWidth[d], u < o.length - 1 && (c += e.U.getPairAdjustment(r, d, h));
        }
      }
      return l;
    }, e.U.P = {}, e.U.P.moveTo = function(r, o, a) {
      r.cmds.push("M"), r.crds.push(o, a);
    }, e.U.P.lineTo = function(r, o, a) {
      r.cmds.push("L"), r.crds.push(o, a);
    }, e.U.P.curveTo = function(r, o, a, l, c, u, d) {
      r.cmds.push("C"), r.crds.push(o, a, l, c, u, d);
    }, e.U.P.qcurveTo = function(r, o, a, l, c) {
      r.cmds.push("Q"), r.crds.push(o, a, l, c);
    }, e.U.P.closePath = function(r) {
      r.cmds.push("Z");
    }, e.U._drawCFF = function(r, o, a, l, c) {
      for (var u = o.stack, d = o.nStems, h = o.haveWidth, m = o.width, p = o.open, v = 0, _ = o.x, g = o.y, x = 0, M = 0, S = 0, b = 0, C = 0, T = 0, P = 0, E = 0, y = 0, w = 0, D = { val: 0, size: 0 }; v < r.length; ) {
        e.CFF.getCharString(r, v, D);
        var U = D.val;
        if (v += D.size, U == "o1" || U == "o18") u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (U == "o3" || U == "o23")
          u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (U == "o4") u.length > 1 && !h && (m = u.shift() + l.nominalWidthX, h = !0), p && e.U.P.closePath(c), g += u.pop(), e.U.P.moveTo(c, _, g), p = !0;
        else if (U == "o5") for (; u.length > 0; ) _ += u.shift(), g += u.shift(), e.U.P.lineTo(c, _, g);
        else if (U == "o6" || U == "o7") for (var R = u.length, O = U == "o6", A = 0; A < R; A++) {
          var G = u.shift();
          O ? _ += G : g += G, O = !O, e.U.P.lineTo(c, _, g);
        }
        else if (U == "o8" || U == "o24") {
          R = u.length;
          for (var ue = 0; ue + 6 <= R; ) x = _ + u.shift(), M = g + u.shift(), S = x + u.shift(), b = M + u.shift(), _ = S + u.shift(), g = b + u.shift(), e.U.P.curveTo(c, x, M, S, b, _, g), ue += 6;
          U == "o24" && (_ += u.shift(), g += u.shift(), e.U.P.lineTo(c, _, g));
        } else {
          if (U == "o11") break;
          if (U == "o1234" || U == "o1235" || U == "o1236" || U == "o1237") U == "o1234" && (M = g, S = (x = _ + u.shift()) + u.shift(), w = b = M + u.shift(), T = b, E = g, _ = (P = (C = (y = S + u.shift()) + u.shift()) + u.shift()) + u.shift(), e.U.P.curveTo(c, x, M, S, b, y, w), e.U.P.curveTo(c, C, T, P, E, _, g)), U == "o1235" && (x = _ + u.shift(), M = g + u.shift(), S = x + u.shift(), b = M + u.shift(), y = S + u.shift(), w = b + u.shift(), C = y + u.shift(), T = w + u.shift(), P = C + u.shift(), E = T + u.shift(), _ = P + u.shift(), g = E + u.shift(), u.shift(), e.U.P.curveTo(c, x, M, S, b, y, w), e.U.P.curveTo(c, C, T, P, E, _, g)), U == "o1236" && (x = _ + u.shift(), M = g + u.shift(), S = x + u.shift(), w = b = M + u.shift(), T = b, P = (C = (y = S + u.shift()) + u.shift()) + u.shift(), E = T + u.shift(), _ = P + u.shift(), e.U.P.curveTo(c, x, M, S, b, y, w), e.U.P.curveTo(c, C, T, P, E, _, g)), U == "o1237" && (x = _ + u.shift(), M = g + u.shift(), S = x + u.shift(), b = M + u.shift(), y = S + u.shift(), w = b + u.shift(), C = y + u.shift(), T = w + u.shift(), P = C + u.shift(), E = T + u.shift(), Math.abs(P - _) > Math.abs(E - g) ? _ = P + u.shift() : g = E + u.shift(), e.U.P.curveTo(c, x, M, S, b, y, w), e.U.P.curveTo(c, C, T, P, E, _, g));
          else if (U == "o14") {
            if (u.length > 0 && !h && (m = u.shift() + a.nominalWidthX, h = !0), u.length == 4) {
              var Q = u.shift(), le = u.shift(), re = u.shift(), j = u.shift(), $ = e.CFF.glyphBySE(a, re), q = e.CFF.glyphBySE(a, j);
              e.U._drawCFF(a.CharStrings[$], o, a, l, c), o.x = Q, o.y = le, e.U._drawCFF(a.CharStrings[q], o, a, l, c);
            }
            p && (e.U.P.closePath(c), p = !1);
          } else if (U == "o19" || U == "o20")
            u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0, v += d + 7 >> 3;
          else if (U == "o21") u.length > 2 && !h && (m = u.shift() + l.nominalWidthX, h = !0), g += u.pop(), _ += u.pop(), p && e.U.P.closePath(c), e.U.P.moveTo(c, _, g), p = !0;
          else if (U == "o22") u.length > 1 && !h && (m = u.shift() + l.nominalWidthX, h = !0), _ += u.pop(), p && e.U.P.closePath(c), e.U.P.moveTo(c, _, g), p = !0;
          else if (U == "o25") {
            for (; u.length > 6; ) _ += u.shift(), g += u.shift(), e.U.P.lineTo(c, _, g);
            x = _ + u.shift(), M = g + u.shift(), S = x + u.shift(), b = M + u.shift(), _ = S + u.shift(), g = b + u.shift(), e.U.P.curveTo(c, x, M, S, b, _, g);
          } else if (U == "o26") for (u.length % 2 && (_ += u.shift()); u.length > 0; ) x = _, M = g + u.shift(), _ = S = x + u.shift(), g = (b = M + u.shift()) + u.shift(), e.U.P.curveTo(c, x, M, S, b, _, g);
          else if (U == "o27") for (u.length % 2 && (g += u.shift()); u.length > 0; ) M = g, S = (x = _ + u.shift()) + u.shift(), b = M + u.shift(), _ = S + u.shift(), g = b, e.U.P.curveTo(c, x, M, S, b, _, g);
          else if (U == "o10" || U == "o29") {
            var oe = U == "o10" ? l : a;
            if (u.length == 0) console.debug("error: empty stack");
            else {
              var ie = u.pop(), ce = oe.Subrs[ie + oe.Bias];
              o.x = _, o.y = g, o.nStems = d, o.haveWidth = h, o.width = m, o.open = p, e.U._drawCFF(ce, o, a, l, c), _ = o.x, g = o.y, d = o.nStems, h = o.haveWidth, m = o.width, p = o.open;
            }
          } else if (U == "o30" || U == "o31") {
            var V = u.length, Y = (ue = 0, U == "o31");
            for (ue += V - (R = -3 & V); ue < R; ) Y ? (M = g, S = (x = _ + u.shift()) + u.shift(), g = (b = M + u.shift()) + u.shift(), R - ue == 5 ? (_ = S + u.shift(), ue++) : _ = S, Y = !1) : (x = _, M = g + u.shift(), S = x + u.shift(), b = M + u.shift(), _ = S + u.shift(), R - ue == 5 ? (g = b + u.shift(), ue++) : g = b, Y = !0), e.U.P.curveTo(c, x, M, S, b, _, g), ue += 4;
          } else {
            if ((U + "").charAt(0) == "o") throw console.debug("Unknown operation: " + U, r), U;
            u.push(U);
          }
        }
      }
      o.x = _, o.y = g, o.nStems = d, o.haveWidth = h, o.width = m, o.open = p;
    };
    var n = e, i = { Typr: n };
    return s.Typr = n, s.default = i, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function xN() {
  return function(s) {
    var e = Uint8Array, n = Uint16Array, i = Uint32Array, r = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), l = function(U, R) {
      for (var O = new n(31), A = 0; A < 31; ++A) O[A] = R += 1 << U[A - 1];
      var G = new i(O[30]);
      for (A = 1; A < 30; ++A) for (var ue = O[A]; ue < O[A + 1]; ++ue) G[ue] = ue - O[A] << 5 | A;
      return [O, G];
    }, c = l(r, 2), u = c[0], d = c[1];
    u[28] = 258, d[258] = 28;
    for (var h = l(o, 0)[0], m = new n(32768), p = 0; p < 32768; ++p) {
      var v = (43690 & p) >>> 1 | (21845 & p) << 1;
      v = (61680 & (v = (52428 & v) >>> 2 | (13107 & v) << 2)) >>> 4 | (3855 & v) << 4, m[p] = ((65280 & v) >>> 8 | (255 & v) << 8) >>> 1;
    }
    var _ = function(U, R, O) {
      for (var A = U.length, G = 0, ue = new n(R); G < A; ++G) ++ue[U[G] - 1];
      var Q, le = new n(R);
      for (G = 0; G < R; ++G) le[G] = le[G - 1] + ue[G - 1] << 1;
      {
        Q = new n(1 << R);
        var re = 15 - R;
        for (G = 0; G < A; ++G) if (U[G]) for (var j = G << 4 | U[G], $ = R - U[G], q = le[U[G] - 1]++ << $, oe = q | (1 << $) - 1; q <= oe; ++q) Q[m[q] >>> re] = j;
      }
      return Q;
    }, g = new e(288);
    for (p = 0; p < 144; ++p) g[p] = 8;
    for (p = 144; p < 256; ++p) g[p] = 9;
    for (p = 256; p < 280; ++p) g[p] = 7;
    for (p = 280; p < 288; ++p) g[p] = 8;
    var x = new e(32);
    for (p = 0; p < 32; ++p) x[p] = 5;
    var M = _(g, 9), S = _(x, 5), b = function(U) {
      for (var R = U[0], O = 1; O < U.length; ++O) U[O] > R && (R = U[O]);
      return R;
    }, C = function(U, R, O) {
      var A = R / 8 | 0;
      return (U[A] | U[A + 1] << 8) >> (7 & R) & O;
    }, T = function(U, R) {
      var O = R / 8 | 0;
      return (U[O] | U[O + 1] << 8 | U[O + 2] << 16) >> (7 & R);
    }, P = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], E = function(U, R, O) {
      var A = new Error(R || P[U]);
      if (A.code = U, Error.captureStackTrace && Error.captureStackTrace(A, E), !O) throw A;
      return A;
    }, y = function(U, R, O) {
      var A = U.length;
      if (!A || O && !O.l && A < 5) return R || new e(0);
      var G = !R || O, ue = !O || O.i;
      O || (O = {}), R || (R = new e(3 * A));
      var Q, le = function(Le) {
        var nt = R.length;
        if (Le > nt) {
          var Je = new e(Math.max(2 * nt, Le));
          Je.set(R), R = Je;
        }
      }, re = O.f || 0, j = O.p || 0, $ = O.b || 0, q = O.l, oe = O.d, ie = O.m, ce = O.n, V = 8 * A;
      do {
        if (!q) {
          O.f = re = C(U, j, 1);
          var Y = C(U, j + 1, 3);
          if (j += 3, !Y) {
            var H = U[(se = ((Q = j) / 8 | 0) + (7 & Q && 1) + 4) - 4] | U[se - 3] << 8, I = se + H;
            if (I > A) {
              ue && E(0);
              break;
            }
            G && le($ + H), R.set(U.subarray(se, I), $), O.b = $ += H, O.p = j = 8 * I;
            continue;
          }
          if (Y == 1) q = M, oe = S, ie = 9, ce = 5;
          else if (Y == 2) {
            var F = C(U, j, 31) + 257, L = C(U, j + 10, 15) + 4, ee = F + C(U, j + 5, 31) + 1;
            j += 14;
            for (var Z = new e(ee), k = new e(19), ne = 0; ne < L; ++ne) k[a[ne]] = C(U, j + 3 * ne, 7);
            j += 3 * L;
            var J = b(k), B = (1 << J) - 1, X = _(k, J);
            for (ne = 0; ne < ee; ) {
              var se, z = X[C(U, j, B)];
              if (j += 15 & z, (se = z >>> 4) < 16) Z[ne++] = se;
              else {
                var N = 0, K = 0;
                for (se == 16 ? (K = 3 + C(U, j, 3), j += 2, N = Z[ne - 1]) : se == 17 ? (K = 3 + C(U, j, 7), j += 3) : se == 18 && (K = 11 + C(U, j, 127), j += 7); K--; ) Z[ne++] = N;
              }
            }
            var he = Z.subarray(0, F), me = Z.subarray(F);
            ie = b(he), ce = b(me), q = _(he, ie), oe = _(me, ce);
          } else E(1);
          if (j > V) {
            ue && E(0);
            break;
          }
        }
        G && le($ + 131072);
        for (var ge = (1 << ie) - 1, Me = (1 << ce) - 1, Ee = j; ; Ee = j) {
          var Ae = (N = q[T(U, j) & ge]) >>> 4;
          if ((j += 15 & N) > V) {
            ue && E(0);
            break;
          }
          if (N || E(2), Ae < 256) R[$++] = Ae;
          else {
            if (Ae == 256) {
              Ee = j, q = null;
              break;
            }
            var Xe = Ae - 254;
            if (Ae > 264) {
              var Oe = r[ne = Ae - 257];
              Xe = C(U, j, (1 << Oe) - 1) + u[ne], j += Oe;
            }
            var He = oe[T(U, j) & Me], Ye = He >>> 4;
            if (He || E(3), j += 15 & He, me = h[Ye], Ye > 3 && (Oe = o[Ye], me += T(U, j) & (1 << Oe) - 1, j += Oe), j > V) {
              ue && E(0);
              break;
            }
            G && le($ + 131072);
            for (var $e = $ + Xe; $ < $e; $ += 4) R[$] = R[$ - me], R[$ + 1] = R[$ + 1 - me], R[$ + 2] = R[$ + 2 - me], R[$ + 3] = R[$ + 3 - me];
            $ = $e;
          }
        }
        O.l = q, O.p = Ee, O.b = $, q && (re = 1, O.m = ie, O.d = oe, O.n = ce);
      } while (!re);
      return $ == R.length ? R : function(Le, nt, Je) {
        (Je == null || Je > Le.length) && (Je = Le.length);
        var bt = new (Le instanceof n ? n : Le instanceof i ? i : e)(Je - nt);
        return bt.set(Le.subarray(nt, Je)), bt;
      }(R, 0, $);
    }, w = new e(0), D = typeof TextDecoder < "u" && new TextDecoder();
    try {
      D.decode(w, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(U) {
      var R = new DataView(U), O = 0;
      function A() {
        var F = R.getUint16(O);
        return O += 2, F;
      }
      function G() {
        var F = R.getUint32(O);
        return O += 4, F;
      }
      function ue(F) {
        H.setUint16(I, F), I += 2;
      }
      function Q(F) {
        H.setUint32(I, F), I += 4;
      }
      for (var le = { signature: G(), flavor: G(), length: G(), numTables: A(), reserved: A(), totalSfntSize: G(), majorVersion: A(), minorVersion: A(), metaOffset: G(), metaLength: G(), metaOrigLength: G(), privOffset: G(), privLength: G() }, re = 0; Math.pow(2, re) <= le.numTables; ) re++;
      re--;
      for (var j = 16 * Math.pow(2, re), $ = 16 * le.numTables - j, q = 12, oe = [], ie = 0; ie < le.numTables; ie++) oe.push({ tag: G(), offset: G(), compLength: G(), origLength: G(), origChecksum: G() }), q += 16;
      var ce, V = new Uint8Array(12 + 16 * oe.length + oe.reduce(function(F, L) {
        return F + L.origLength + 4;
      }, 0)), Y = V.buffer, H = new DataView(Y), I = 0;
      return Q(le.flavor), ue(le.numTables), ue(j), ue(re), ue($), oe.forEach(function(F) {
        Q(F.tag), Q(F.origChecksum), Q(q), Q(F.origLength), F.outOffset = q, (q += F.origLength) % 4 != 0 && (q += 4 - q % 4);
      }), oe.forEach(function(F) {
        var L, ee = U.slice(F.offset, F.offset + F.compLength);
        if (F.compLength != F.origLength) {
          var Z = new Uint8Array(F.origLength);
          L = new Uint8Array(ee, 2), y(L, Z);
        } else Z = new Uint8Array(ee);
        V.set(Z, F.outOffset);
        var k = 0;
        (q = F.outOffset + F.origLength) % 4 != 0 && (k = 4 - q % 4), V.set(new Uint8Array(k).buffer, F.outOffset + F.origLength), ce = q + k;
      }), Y.slice(0, ce);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function _N(s, e) {
  const n = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, r = 1, o = 2, a = 4, l = 8, c = 16, u = 32;
  let d;
  function h(P) {
    if (!d) {
      const E = {
        R: o,
        L: r,
        D: a,
        C: c,
        U: u,
        T: l
      };
      d = /* @__PURE__ */ new Map();
      for (let y in i) {
        let w = 0;
        i[y].split(",").forEach((D) => {
          let [U, R] = D.split("+");
          U = parseInt(U, 36), R = R ? parseInt(R, 36) : 0, d.set(w += U, E[y]);
          for (let O = R; O--; )
            d.set(++w, E[y]);
        });
      }
    }
    return d.get(P) || u;
  }
  const m = 1, p = 2, v = 3, _ = 4, g = [null, "isol", "init", "fina", "medi"];
  function x(P) {
    const E = new Uint8Array(P.length);
    let y = u, w = m, D = -1;
    for (let U = 0; U < P.length; U++) {
      const R = P.codePointAt(U);
      let O = h(R) | 0, A = m;
      O & l || (y & (r | a | c) ? O & (o | a | c) ? (A = v, (w === m || w === v) && E[D]++) : O & (r | u) && (w === p || w === _) && E[D]-- : y & (o | u) && (w === p || w === _) && E[D]--, w = E[U] = A, y = O, D = U, R > 65535 && U++);
    }
    return E;
  }
  function M(P, E) {
    const y = [];
    for (let D = 0; D < E.length; D++) {
      const U = E.codePointAt(D);
      U > 65535 && D++, y.push(s.U.codeToGlyph(P, U));
    }
    const w = P.GSUB;
    if (w) {
      const { lookupList: D, featureList: U } = w;
      let R;
      const O = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, A = [];
      U.forEach((G) => {
        if (O.test(G.tag))
          for (let ue = 0; ue < G.tab.length; ue++) {
            if (A[G.tab[ue]]) continue;
            A[G.tab[ue]] = !0;
            const Q = D[G.tab[ue]], le = /^(isol|init|fina|medi)$/.test(G.tag);
            le && !R && (R = x(E));
            for (let re = 0; re < y.length; re++)
              (!R || !le || g[R[re]] === G.tag) && s.U._applySubs(y, re, Q, D);
          }
      });
    }
    return y;
  }
  function S(P, E) {
    const y = new Int16Array(E.length * 3);
    let w = 0;
    for (; w < E.length; w++) {
      const O = E[w];
      if (O === -1) continue;
      y[w * 3 + 2] = P.hmtx.aWidth[O];
      const A = P.GPOS;
      if (A) {
        const G = A.lookupList;
        for (let ue = 0; ue < G.length; ue++) {
          const Q = G[ue];
          for (let le = 0; le < Q.tabs.length; le++) {
            const re = Q.tabs[le];
            if (Q.ltype === 1) {
              if (s._lctf.coverageIndex(re.coverage, O) !== -1 && re.pos) {
                R(re.pos, w);
                break;
              }
            } else if (Q.ltype === 2) {
              let j = null, $ = D();
              if ($ !== -1) {
                const q = s._lctf.coverageIndex(re.coverage, E[$]);
                if (q !== -1) {
                  if (re.fmt === 1) {
                    const oe = re.pairsets[q];
                    for (let ie = 0; ie < oe.length; ie++)
                      oe[ie].gid2 === O && (j = oe[ie]);
                  } else if (re.fmt === 2) {
                    const oe = s.U._getGlyphClass(E[$], re.classDef1), ie = s.U._getGlyphClass(O, re.classDef2);
                    j = re.matrix[oe][ie];
                  }
                  if (j) {
                    j.val1 && R(j.val1, $), j.val2 && R(j.val2, w);
                    break;
                  }
                }
              }
            } else if (Q.ltype === 4) {
              const j = s._lctf.coverageIndex(re.markCoverage, O);
              if (j !== -1) {
                const $ = D(U), q = $ === -1 ? -1 : s._lctf.coverageIndex(re.baseCoverage, E[$]);
                if (q !== -1) {
                  const oe = re.markArray[j], ie = re.baseArray[q][oe.markClass];
                  y[w * 3] = ie.x - oe.x + y[$ * 3] - y[$ * 3 + 2], y[w * 3 + 1] = ie.y - oe.y + y[$ * 3 + 1];
                  break;
                }
              }
            } else if (Q.ltype === 6) {
              const j = s._lctf.coverageIndex(re.mark1Coverage, O);
              if (j !== -1) {
                const $ = D();
                if ($ !== -1) {
                  const q = E[$];
                  if (b(P, q) === 3) {
                    const oe = s._lctf.coverageIndex(re.mark2Coverage, q);
                    if (oe !== -1) {
                      const ie = re.mark1Array[j], ce = re.mark2Array[oe][ie.markClass];
                      y[w * 3] = ce.x - ie.x + y[$ * 3] - y[$ * 3 + 2], y[w * 3 + 1] = ce.y - ie.y + y[$ * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (P.kern && !P.cff) {
        const G = D();
        if (G !== -1) {
          const ue = P.kern.glyph1.indexOf(E[G]);
          if (ue !== -1) {
            const Q = P.kern.rval[ue].glyph2.indexOf(O);
            Q !== -1 && (y[G * 3 + 2] += P.kern.rval[ue].vals[Q]);
          }
        }
      }
    }
    return y;
    function D(O) {
      for (let A = w - 1; A >= 0; A--)
        if (E[A] !== -1 && (!O || O(E[A])))
          return A;
      return -1;
    }
    function U(O) {
      return b(P, O) === 1;
    }
    function R(O, A) {
      for (let G = 0; G < 3; G++)
        y[A * 3 + G] += O[G] || 0;
    }
  }
  function b(P, E) {
    const y = P.GDEF && P.GDEF.glyphClassDef;
    return y ? s.U._getGlyphClass(E, y) : 0;
  }
  function C(...P) {
    for (let E = 0; E < P.length; E++)
      if (typeof P[E] == "number")
        return P[E];
  }
  function T(P) {
    const E = /* @__PURE__ */ Object.create(null), y = P["OS/2"], w = P.hhea, D = P.head.unitsPerEm, U = C(y && y.sTypoAscender, w && w.ascender, D), R = {
      unitsPerEm: D,
      ascender: U,
      descender: C(y && y.sTypoDescender, w && w.descender, 0),
      capHeight: C(y && y.sCapHeight, U),
      xHeight: C(y && y.sxHeight, U),
      lineGap: C(y && y.sTypoLineGap, w && w.lineGap),
      supportsCodePoint(O) {
        return s.U.codeToGlyph(P, O) > 0;
      },
      forEachGlyph(O, A, G, ue) {
        let Q = 0;
        const le = 1 / R.unitsPerEm * A, re = M(P, O);
        let j = 0;
        const $ = S(P, re);
        return re.forEach((q, oe) => {
          if (q !== -1) {
            let ie = E[q];
            if (!ie) {
              const { cmds: ce, crds: V } = s.U.glyphToPath(P, q);
              let Y = "", H = 0;
              for (let Z = 0, k = ce.length; Z < k; Z++) {
                const ne = n[ce[Z]];
                Y += ce[Z];
                for (let J = 1; J <= ne; J++)
                  Y += (J > 1 ? "," : "") + V[H++];
              }
              let I, F, L, ee;
              if (V.length) {
                I = F = 1 / 0, L = ee = -1 / 0;
                for (let Z = 0, k = V.length; Z < k; Z += 2) {
                  let ne = V[Z], J = V[Z + 1];
                  ne < I && (I = ne), J < F && (F = J), ne > L && (L = ne), J > ee && (ee = J);
                }
              } else
                I = L = F = ee = 0;
              ie = E[q] = {
                index: q,
                advanceWidth: P.hmtx.aWidth[q],
                xMin: I,
                yMin: F,
                xMax: L,
                yMax: ee,
                path: Y
              };
            }
            ue.call(
              null,
              ie,
              Q + $[oe * 3] * le,
              $[oe * 3 + 1] * le,
              j
            ), Q += $[oe * 3 + 2] * le, G && (Q += G * A);
          }
          j += O.codePointAt(j) > 65535 ? 2 : 1;
        }), Q;
      }
    };
    return R;
  }
  return function(E) {
    const y = new Uint8Array(E, 0, 4), w = s._bin.readASCII(y, 0, 4);
    if (w === "wOFF")
      E = e(E);
    else if (w === "wOF2")
      throw new Error("woff2 fonts not supported");
    return T(s.parse(E)[0]);
  };
}
const bN = /* @__PURE__ */ ta({
  name: "Typr Font Parser",
  dependencies: [yN, xN, _N],
  init(s, e, n) {
    const i = s(), r = e();
    return n(i, r);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function wN() {
  return function(s) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(S) {
      var b = S >> 5;
      this.buckets.set(b, (this.buckets.get(b) || 0) | 1 << (31 & S));
    }, e.prototype.has = function(S) {
      var b = this.buckets.get(S >> 5);
      return b !== void 0 && (b & 1 << (31 & S)) != 0;
    }, e.prototype.serialize = function() {
      var S = [];
      return this.buckets.forEach(function(b, C) {
        S.push((+C).toString(36) + ":" + b.toString(36));
      }), S.join(",");
    }, e.prototype.deserialize = function(S) {
      var b = this;
      this.buckets.clear(), S.split(",").forEach(function(C) {
        var T = C.split(":");
        b.buckets.set(parseInt(T[0], 36), parseInt(T[1], 36));
      });
    };
    var n = Math.pow(2, 8), i = n - 1, r = ~i;
    function o(S) {
      var b = function(T) {
        return T & r;
      }(S).toString(16), C = function(T) {
        return (T & r) + n - 1;
      }(S).toString(16);
      return "codepoint-index/plane" + (S >> 16) + "/" + b + "-" + C + ".json";
    }
    function a(S, b) {
      var C = S & i, T = b.codePointAt(C / 6 | 0);
      return ((T = (T || 48) - 48) & 1 << C % 6) != 0;
    }
    function l(S, b) {
      var C;
      (C = S, C.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(T) {
        return T.split("-").map(function(P) {
          return parseInt(P.trim(), 16);
        });
      })).forEach(function(T) {
        var P = T[0], E = T[1];
        E === void 0 && (E = P), b(P, E);
      });
    }
    function c(S, b) {
      l(S, function(C, T) {
        for (var P = C; P <= T; P++) b(P);
      });
    }
    var u = {}, d = {}, h = /* @__PURE__ */ new WeakMap(), m = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function p(S) {
      var b = h.get(S);
      return b || (b = new e(), c(S.ranges, function(C) {
        return b.add(C);
      }), h.set(S, b)), b;
    }
    var v, _ = /* @__PURE__ */ new Map();
    function g(S, b, C) {
      return S[b] ? b : S[C] ? C : function(T) {
        for (var P in T) return P;
      }(S);
    }
    function x(S, b) {
      var C = b;
      if (!S.includes(C)) {
        C = 1 / 0;
        for (var T = 0; T < S.length; T++) Math.abs(S[T] - b) < Math.abs(C - b) && (C = S[T]);
      }
      return C;
    }
    function M(S) {
      return v || (v = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(b) {
        v.add(b);
      })), v.has(S);
    }
    return s.CodePointSet = e, s.clearCache = function() {
      u = {}, d = {};
    }, s.getFontsForString = function(S, b) {
      b === void 0 && (b = {});
      var C, T = b.lang;
      T === void 0 && (T = new RegExp("\\p{Script=Hangul}", "u").test(C = S) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(C) ? "ja" : "en");
      var P = b.category;
      P === void 0 && (P = "sans-serif");
      var E = b.style;
      E === void 0 && (E = "normal");
      var y = b.weight;
      y === void 0 && (y = 400);
      var w = (b.dataUrl || m).replace(/\/$/g, ""), D = /* @__PURE__ */ new Map(), U = new Uint8Array(S.length), R = {}, O = {}, A = new Array(S.length), G = /* @__PURE__ */ new Map(), ue = !1;
      function Q(j) {
        var $ = _.get(j);
        return $ || ($ = fetch(w + "/" + j).then(function(q) {
          if (!q.ok) throw new Error(q.statusText);
          return q.json().then(function(oe) {
            if (!Array.isArray(oe) || oe[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + oe[0]);
            return oe[1];
          });
        }).catch(function(q) {
          if (w !== m) return ue || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + w + '", trying default CDN. ' + q.message), ue = !0), w = m, _.delete(j), Q(j);
          throw q;
        }), _.set(j, $)), $;
      }
      for (var le = function(j) {
        var $ = S.codePointAt(j), q = o($);
        A[j] = q, u[q] || G.has(q) || G.set(q, Q(q).then(function(oe) {
          u[q] = oe;
        })), $ > 65535 && (j++, re = j);
      }, re = 0; re < S.length; re++) le(re);
      return Promise.all(G.values()).then(function() {
        G.clear();
        for (var j = function(q) {
          var oe = S.codePointAt(q), ie = null, ce = u[A[q]], V = void 0;
          for (var Y in ce) {
            var H = O[Y];
            if (H === void 0 && (H = O[Y] = new RegExp(Y).test(T || "en")), H) {
              for (var I in V = Y, ce[Y]) if (a(oe, ce[Y][I])) {
                ie = I;
                break;
              }
              break;
            }
          }
          if (!ie) {
            e: for (var F in ce) if (F !== V) {
              for (var L in ce[F]) if (a(oe, ce[F][L])) {
                ie = L;
                break e;
              }
            }
          }
          ie || (console.debug("No font coverage for U+" + oe.toString(16)), ie = "latin"), A[q] = ie, d[ie] || G.has(ie) || G.set(ie, Q("font-meta/" + ie + ".json").then(function(ee) {
            d[ie] = ee;
          })), oe > 65535 && (q++, $ = q);
        }, $ = 0; $ < S.length; $++) j($);
        return Promise.all(G.values());
      }).then(function() {
        for (var j, $ = null, q = 0; q < S.length; q++) {
          var oe = S.codePointAt(q);
          if ($ && (M(oe) || p($).has(oe))) U[q] = U[q - 1];
          else {
            $ = d[A[q]];
            var ie = R[$.id];
            if (!ie) {
              var ce = $.typeforms, V = g(ce, P, "sans-serif"), Y = g(ce[V], E, "normal"), H = x((j = ce[V]) === null || j === void 0 ? void 0 : j[Y], y);
              ie = R[$.id] = w + "/font-files/" + $.id + "/" + V + "." + Y + "." + H + ".woff";
            }
            var I = D.get(ie);
            I == null && (I = D.size, D.set(ie, I)), U[q] = I;
          }
          oe > 65535 && (q++, U[q] = U[q - 1]);
        }
        return { fontUrls: Array.from(D.keys()), chars: U };
      });
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({});
}
function SN(s, e) {
  const n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function r(a, l) {
    const c = (u) => {
      console.error(`Failure loading font ${a}`, u);
    };
    try {
      const u = new XMLHttpRequest();
      u.open("get", a, !0), u.responseType = "arraybuffer", u.onload = function() {
        if (u.status >= 400)
          c(new Error(u.statusText));
        else if (u.status > 0)
          try {
            const d = s(u.response);
            d.src = a, l(d);
          } catch (d) {
            c(d);
          }
      }, u.onerror = c, u.send();
    } catch (u) {
      c(u);
    }
  }
  function o(a, l) {
    let c = n[a];
    c ? l(c) : i[a] ? i[a].push(l) : (i[a] = [l], r(a, (u) => {
      u.src = a, n[a] = u, i[a].forEach((d) => d(u)), delete i[a];
    }));
  }
  return function(a, l, {
    lang: c,
    fonts: u = [],
    style: d = "normal",
    weight: h = "normal",
    unicodeFontsURL: m
  } = {}) {
    const p = new Uint8Array(a.length), v = [];
    a.length || M();
    const _ = /* @__PURE__ */ new Map(), g = [];
    if (d !== "italic" && (d = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), u && !Array.isArray(u) && (u = [u]), u = u.slice().filter((b) => !b.lang || b.lang.test(c)).reverse(), u.length) {
      let P = 0;
      (function E(y = 0) {
        for (let w = y, D = a.length; w < D; w++) {
          const U = a.codePointAt(w);
          if (P === 1 && v[p[w - 1]].supportsCodePoint(U) || w > 0 && /\s/.test(a[w]))
            p[w] = p[w - 1], P === 2 && (g[g.length - 1][1] = w);
          else
            for (let R = p[w], O = u.length; R <= O; R++)
              if (R === O) {
                const A = P === 2 ? g[g.length - 1] : g[g.length] = [w, w];
                A[1] = w, P = 2;
              } else {
                p[w] = R;
                const { src: A, unicodeRange: G } = u[R];
                if (!G || S(U, G)) {
                  const ue = n[A];
                  if (!ue) {
                    o(A, () => {
                      E(w);
                    });
                    return;
                  }
                  if (ue.supportsCodePoint(U)) {
                    let Q = _.get(ue);
                    typeof Q != "number" && (Q = v.length, v.push(ue), _.set(ue, Q)), p[w] = Q, P = 1;
                    break;
                  }
                }
              }
          U > 65535 && w + 1 < D && (p[w + 1] = p[w], w++, P === 2 && (g[g.length - 1][1] = w));
        }
        x();
      })();
    } else
      g.push([0, a.length - 1]), x();
    function x() {
      if (g.length) {
        const b = g.map((C) => a.substring(C[0], C[1] + 1)).join(`
`);
        e.getFontsForString(b, {
          lang: c || void 0,
          style: d,
          weight: h,
          dataUrl: m
        }).then(({ fontUrls: C, chars: T }) => {
          const P = v.length;
          let E = 0;
          g.forEach((w) => {
            for (let D = 0, U = w[1] - w[0]; D <= U; D++)
              p[w[0] + D] = T[E++] + P;
            E++;
          });
          let y = 0;
          C.forEach((w, D) => {
            o(w, (U) => {
              v[D + P] = U, ++y === C.length && M();
            });
          });
        });
      } else
        M();
    }
    function M() {
      l({
        chars: p,
        fonts: v
      });
    }
    function S(b, C) {
      for (let T = 0; T < C.length; T++) {
        const [P, E = P] = C[T];
        if (P <= b && b <= E)
          return !0;
      }
      return !1;
    }
  };
}
const MN = /* @__PURE__ */ ta({
  name: "FontResolver",
  dependencies: [
    SN,
    bN,
    wN
  ],
  init(s, e, n) {
    return s(e, n());
  }
});
function CN(s, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, r = "[^\\S\\u00A0]", o = new RegExp(`${r}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function a({ text: v, lang: _, fonts: g, style: x, weight: M, preResolvedFonts: S, unicodeFontsURL: b }, C) {
    const T = ({ chars: P, fonts: E }) => {
      let y, w;
      const D = [];
      for (let U = 0; U < P.length; U++)
        P[U] !== w ? (w = P[U], D.push(y = { start: U, end: U, fontObj: E[P[U]] })) : y.end = U;
      C(D);
    };
    S ? T(S) : s(
      v,
      T,
      { lang: _, fonts: g, style: x, weight: M, unicodeFontsURL: b }
    );
  }
  function l({
    text: v = "",
    font: _,
    lang: g,
    sdfGlyphSize: x = 64,
    fontSize: M = 400,
    fontWeight: S = 1,
    fontStyle: b = "normal",
    letterSpacing: C = 0,
    lineHeight: T = "normal",
    maxWidth: P = 1 / 0,
    direction: E,
    textAlign: y = "left",
    textIndent: w = 0,
    whiteSpace: D = "normal",
    overflowWrap: U = "normal",
    anchorX: R = 0,
    anchorY: O = 0,
    metricsOnly: A = !1,
    unicodeFontsURL: G,
    preResolvedFonts: ue = null,
    includeCaretPositions: Q = !1,
    chunkedBoundsSize: le = 8192,
    colorRanges: re = null
  }, j) {
    const $ = h(), q = { fontLoad: 0, typesetting: 0 };
    v.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), v = v.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), M = +M, C = +C, P = +P, T = T || "normal", w = +w, a({
      text: v,
      lang: g,
      style: b,
      weight: S,
      fonts: typeof _ == "string" ? [{ src: _ }] : _,
      unicodeFontsURL: G,
      preResolvedFonts: ue
    }, (oe) => {
      q.fontLoad = h() - $;
      const ie = isFinite(P);
      let ce = null, V = null, Y = null, H = null, I = null, F = null, L = null, ee = null, Z = 0, k = 0, ne = D !== "nowrap";
      const J = /* @__PURE__ */ new Map(), B = h();
      let X = w, se = 0, z = new m();
      const N = [z];
      oe.forEach((Me) => {
        const { fontObj: Ee } = Me, { ascender: Ae, descender: Xe, unitsPerEm: Oe, lineGap: He, capHeight: Ye, xHeight: $e } = Ee;
        let Le = J.get(Ee);
        if (!Le) {
          const Ne = M / Oe, Re = T === "normal" ? (Ae - Xe + He) * Ne : T * M, Be = (Re - (Ae - Xe) * Ne) / 2, je = Math.min(Re, (Ae - Xe) * Ne), Ge = (Ae + Xe) / 2 * Ne + je / 2;
          Le = {
            index: J.size,
            src: Ee.src,
            fontObj: Ee,
            fontSizeMult: Ne,
            unitsPerEm: Oe,
            ascender: Ae * Ne,
            descender: Xe * Ne,
            capHeight: Ye * Ne,
            xHeight: $e * Ne,
            lineHeight: Re,
            baseline: -Be - Ae * Ne,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: Ge,
            caretBottom: Ge - je
          }, J.set(Ee, Le);
        }
        const { fontSizeMult: nt } = Le, Je = v.slice(Me.start, Me.end + 1);
        let bt, Se;
        Ee.forEachGlyph(Je, M, C, (Ne, Re, Be, je) => {
          Re += se, je += Me.start, bt = Re, Se = Ne;
          const Ge = v.charAt(je), ut = Ne.advanceWidth * nt, at = z.count;
          let dt;
          if ("isEmpty" in Ne || (Ne.isWhitespace = !!Ge && new RegExp(r).test(Ge), Ne.canBreakAfter = !!Ge && o.test(Ge), Ne.isEmpty = Ne.xMin === Ne.xMax || Ne.yMin === Ne.yMax || i.test(Ge)), !Ne.isWhitespace && !Ne.isEmpty && k++, ne && ie && !Ne.isWhitespace && Re + ut + X > P && at) {
            if (z.glyphAt(at - 1).glyphObj.canBreakAfter)
              dt = new m(), X = -Re;
            else
              for (let zt = at; zt--; )
                if (zt === 0 && U === "break-word") {
                  dt = new m(), X = -Re;
                  break;
                } else if (z.glyphAt(zt).glyphObj.canBreakAfter) {
                  dt = z.splitAt(zt + 1);
                  const Kt = dt.glyphAt(0).x;
                  X -= Kt;
                  for (let rn = dt.count; rn--; )
                    dt.glyphAt(rn).x -= Kt;
                  break;
                }
            dt && (z.isSoftWrapped = !0, z = dt, N.push(z), Z = P);
          }
          let pt = z.glyphAt(z.count);
          pt.glyphObj = Ne, pt.x = Re + X, pt.y = Be, pt.width = ut, pt.charIndex = je, pt.fontData = Le, Ge === `
` && (z = new m(), N.push(z), X = -(Re + ut + C * M) + w);
        }), se = bt + Se.advanceWidth * nt + C * M;
      });
      let K = 0;
      N.forEach((Me) => {
        let Ee = !0;
        for (let Ae = Me.count; Ae--; ) {
          const Xe = Me.glyphAt(Ae);
          Ee && !Xe.glyphObj.isWhitespace && (Me.width = Xe.x + Xe.width, Me.width > Z && (Z = Me.width), Ee = !1);
          let { lineHeight: Oe, capHeight: He, xHeight: Ye, baseline: $e } = Xe.fontData;
          Oe > Me.lineHeight && (Me.lineHeight = Oe);
          const Le = $e - Me.baseline;
          Le < 0 && (Me.baseline += Le, Me.cap += Le, Me.ex += Le), Me.cap = Math.max(Me.cap, Me.baseline + He), Me.ex = Math.max(Me.ex, Me.baseline + Ye);
        }
        Me.baseline -= K, Me.cap -= K, Me.ex -= K, K += Me.lineHeight;
      });
      let he = 0, me = 0;
      if (R && (typeof R == "number" ? he = -R : typeof R == "string" && (he = -Z * (R === "left" ? 0 : R === "center" ? 0.5 : R === "right" ? 1 : u(R)))), O && (typeof O == "number" ? me = -O : typeof O == "string" && (me = O === "top" ? 0 : O === "top-baseline" ? -N[0].baseline : O === "top-cap" ? -N[0].cap : O === "top-ex" ? -N[0].ex : O === "middle" ? K / 2 : O === "bottom" ? K : O === "bottom-baseline" ? -N[N.length - 1].baseline : u(O) * K)), !A) {
        const Me = e.getEmbeddingLevels(v, E);
        ce = new Uint16Array(k), V = new Uint8Array(k), Y = new Float32Array(k * 2), H = {}, L = [1 / 0, 1 / 0, -1 / 0, -1 / 0], ee = [], Q && (F = new Float32Array(v.length * 4)), re && (I = new Uint8Array(k * 3));
        let Ee = 0, Ae = -1, Xe = -1, Oe, He;
        if (N.forEach((Ye, $e) => {
          let { count: Le, width: nt } = Ye;
          if (Le > 0) {
            let Je = 0;
            for (let je = Le; je-- && Ye.glyphAt(je).glyphObj.isWhitespace; )
              Je++;
            let bt = 0, Se = 0;
            if (y === "center")
              bt = (Z - nt) / 2;
            else if (y === "right")
              bt = Z - nt;
            else if (y === "justify" && Ye.isSoftWrapped) {
              let je = 0;
              for (let Ge = Le - Je; Ge--; )
                Ye.glyphAt(Ge).glyphObj.isWhitespace && je++;
              Se = (Z - nt) / je;
            }
            if (Se || bt) {
              let je = 0;
              for (let Ge = 0; Ge < Le; Ge++) {
                let ut = Ye.glyphAt(Ge);
                const at = ut.glyphObj;
                ut.x += bt + je, Se !== 0 && at.isWhitespace && Ge < Le - Je && (je += Se, ut.width += Se);
              }
            }
            const Ne = e.getReorderSegments(
              v,
              Me,
              Ye.glyphAt(0).charIndex,
              Ye.glyphAt(Ye.count - 1).charIndex
            );
            for (let je = 0; je < Ne.length; je++) {
              const [Ge, ut] = Ne[je];
              let at = 1 / 0, dt = -1 / 0;
              for (let pt = 0; pt < Le; pt++)
                if (Ye.glyphAt(pt).charIndex >= Ge) {
                  let zt = pt, Kt = pt;
                  for (; Kt < Le; Kt++) {
                    let rn = Ye.glyphAt(Kt);
                    if (rn.charIndex > ut)
                      break;
                    Kt < Le - Je && (at = Math.min(at, rn.x), dt = Math.max(dt, rn.x + rn.width));
                  }
                  for (let rn = zt; rn < Kt; rn++) {
                    const Bn = Ye.glyphAt(rn);
                    Bn.x = dt - (Bn.x + Bn.width - at);
                  }
                  break;
                }
            }
            let Re;
            const Be = (je) => Re = je;
            for (let je = 0; je < Le; je++) {
              const Ge = Ye.glyphAt(je);
              Re = Ge.glyphObj;
              const ut = Re.index, at = Me.levels[Ge.charIndex] & 1;
              if (at) {
                const dt = e.getMirroredCharacter(v[Ge.charIndex]);
                dt && Ge.fontData.fontObj.forEachGlyph(dt, 0, 0, Be);
              }
              if (Q) {
                const { charIndex: dt, fontData: pt } = Ge, zt = Ge.x + he, Kt = Ge.x + Ge.width + he;
                F[dt * 4] = at ? Kt : zt, F[dt * 4 + 1] = at ? zt : Kt, F[dt * 4 + 2] = Ye.baseline + pt.caretBottom + me, F[dt * 4 + 3] = Ye.baseline + pt.caretTop + me;
                const rn = dt - Ae;
                rn > 1 && d(F, Ae, rn), Ae = dt;
              }
              if (re) {
                const { charIndex: dt } = Ge;
                for (; dt > Xe; )
                  Xe++, re.hasOwnProperty(Xe) && (He = re[Xe]);
              }
              if (!Re.isWhitespace && !Re.isEmpty) {
                const dt = Ee++, { fontSizeMult: pt, src: zt, index: Kt } = Ge.fontData, rn = H[zt] || (H[zt] = {});
                rn[ut] || (rn[ut] = {
                  path: Re.path,
                  pathBounds: [Re.xMin, Re.yMin, Re.xMax, Re.yMax]
                });
                const Bn = Ge.x + he, bn = Ge.y + Ye.baseline + me;
                Y[dt * 2] = Bn, Y[dt * 2 + 1] = bn;
                const Kn = Bn + Re.xMin * pt, fi = bn + Re.yMin * pt, pi = Bn + Re.xMax * pt, Vn = bn + Re.yMax * pt;
                Kn < L[0] && (L[0] = Kn), fi < L[1] && (L[1] = fi), pi > L[2] && (L[2] = pi), Vn > L[3] && (L[3] = Vn), dt % le === 0 && (Oe = { start: dt, end: dt, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, ee.push(Oe)), Oe.end++;
                const wn = Oe.rect;
                if (Kn < wn[0] && (wn[0] = Kn), fi < wn[1] && (wn[1] = fi), pi > wn[2] && (wn[2] = pi), Vn > wn[3] && (wn[3] = Vn), ce[dt] = ut, V[dt] = Kt, re) {
                  const ri = dt * 3;
                  I[ri] = He >> 16 & 255, I[ri + 1] = He >> 8 & 255, I[ri + 2] = He & 255;
                }
              }
            }
          }
        }), F) {
          const Ye = v.length - Ae;
          Ye > 1 && d(F, Ae, Ye);
        }
      }
      const ge = [];
      J.forEach(({ index: Me, src: Ee, unitsPerEm: Ae, ascender: Xe, descender: Oe, lineHeight: He, capHeight: Ye, xHeight: $e }) => {
        ge[Me] = { src: Ee, unitsPerEm: Ae, ascender: Xe, descender: Oe, lineHeight: He, capHeight: Ye, xHeight: $e };
      }), q.typesetting = h() - B, j({
        glyphIds: ce,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: V,
        //index into fontData for each glyph
        glyphPositions: Y,
        //x,y of each glyph's origin in layout
        glyphData: H,
        //dict holding data about each glyph appearing in the text
        fontData: ge,
        //data about each font used in the text
        caretPositions: F,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: I,
        //color for each glyph, if color ranges supplied
        chunkedBounds: ee,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: M,
        //calculated em height
        topBaseline: me + N[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          he,
          me - K,
          he + Z,
          me
        ],
        visibleBounds: L,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: q
      });
    });
  }
  function c(v, _) {
    l({ ...v, metricsOnly: !0 }, (g) => {
      const [x, M, S, b] = g.blockBounds;
      _({
        width: S - x,
        height: b - M
      });
    });
  }
  function u(v) {
    let _ = v.match(/^([\d.]+)%$/), g = _ ? parseFloat(_[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function d(v, _, g) {
    const x = v[_ * 4], M = v[_ * 4 + 1], S = v[_ * 4 + 2], b = v[_ * 4 + 3], C = (M - x) / g;
    for (let T = 0; T < g; T++) {
      const P = (_ + T) * 4;
      v[P] = x + C * T, v[P + 1] = x + C * (T + 1), v[P + 2] = S, v[P + 3] = b;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function m() {
    this.data = [];
  }
  const p = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return m.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / p.length);
    },
    glyphAt(v) {
      let _ = m.flyweight;
      return _.data = this.data, _.index = v, _;
    },
    splitAt(v) {
      let _ = new m();
      return _.data = this.data.splice(v * p.length), _;
    }
  }, m.flyweight = p.reduce((v, _, g, x) => (Object.defineProperty(v, _, {
    get() {
      return this.data[this.index * p.length + g];
    },
    set(M) {
      this.data[this.index * p.length + g] = M;
    }
  }), v), { data: null, index: 0 }), {
    typeset: l,
    measure: c
  };
}
const Hr = () => (self.performance || Date).now(), Fu = /* @__PURE__ */ Uy();
let Wv;
function TN(s, e, n, i, r, o, a, l, c, u, d = !0) {
  return d ? AN(s, e, n, i, r, o, a, l, c, u).then(
    null,
    (h) => (Wv || (console.warn("WebGL SDF generation failed, falling back to JS", h), Wv = !0), jv(s, e, n, i, r, o, a, l, c, u))
  ) : jv(s, e, n, i, r, o, a, l, c, u);
}
const Hc = [], EN = 5;
let sf = 0;
function zy() {
  const s = Hr();
  for (; Hc.length && Hr() - s < EN; )
    Hc.shift()();
  sf = Hc.length ? setTimeout(zy, 0) : 0;
}
const AN = (...s) => new Promise((e, n) => {
  Hc.push(() => {
    const i = Hr();
    try {
      Fu.webgl.generateIntoCanvas(...s), e({ timing: Hr() - i });
    } catch (r) {
      n(r);
    }
  }), sf || (sf = setTimeout(zy, 0));
}), PN = 4, RN = 2e3, Xv = {};
let DN = 0;
function jv(s, e, n, i, r, o, a, l, c, u) {
  const d = "TroikaTextSDFGenerator_JS_" + DN++ % PN;
  let h = Xv[d];
  return h || (h = Xv[d] = {
    workerModule: ta({
      name: d,
      workerId: d,
      dependencies: [
        Uy,
        Hr
      ],
      init(m, p) {
        const v = m().javascript.generate;
        return function(..._) {
          const g = p();
          return {
            textureData: v(..._),
            timing: p() - g
          };
        };
      },
      getTransferables(m) {
        return [m.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(s, e, n, i, r, o).then(({ textureData: m, timing: p }) => {
    const v = Hr(), _ = new Uint8Array(m.length * 4);
    for (let g = 0; g < m.length; g++)
      _[g * 4 + u] = m[g];
    return Fu.webglUtils.renderImageData(a, _, l, c, s, e, 1 << 3 - u), p += Hr() - v, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      lN(d);
    }, RN)), { timing: p };
  });
}
function kN(s) {
  s._warm || (Fu.webgl.isSupported(s), s._warm = !0);
}
const IN = Fu.webglUtils.resizeWebGLCanvasWithoutClearing, Fa = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, LN = /* @__PURE__ */ new Mt();
function _o() {
  return (self.performance || Date).now();
}
const Yv = /* @__PURE__ */ Object.create(null);
function FN(s, e) {
  s = ON({}, s);
  const n = _o(), i = [];
  if (s.font && i.push({ label: "user", src: zN(s.font) }), s.font = i, s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || Fa.sdfGlyphSize, s.unicodeFontsURL = s.unicodeFontsURL || Fa.unicodeFontsURL, s.colorRanges != null) {
    let m = {};
    for (let p in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(p)) {
        let v = s.colorRanges[p];
        typeof v != "number" && (v = LN.set(v).getHex()), m[p] = v;
      }
    s.colorRanges = m;
  }
  Object.freeze(s);
  const { textureWidth: r, sdfExponent: o } = Fa, { sdfGlyphSize: a } = s, l = r / a * 4;
  let c = Yv[a];
  if (!c) {
    const m = document.createElement("canvas");
    m.width = r, m.height = a * 256 / l, c = Yv[a] = {
      glyphCount: 0,
      sdfGlyphSize: a,
      sdfCanvas: m,
      sdfTexture: new _n(
        m,
        void 0,
        void 0,
        void 0,
        Bt,
        Bt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, UN(c);
  }
  const { sdfTexture: u, sdfCanvas: d } = c;
  Vy(s).then((m) => {
    const { glyphIds: p, glyphFontIndices: v, fontData: _, glyphPositions: g, fontSize: x, timings: M } = m, S = [], b = new Float32Array(p.length * 4);
    let C = 0, T = 0;
    const P = _o(), E = _.map((R) => {
      let O = c.glyphsByFont.get(R.src);
      return O || c.glyphsByFont.set(R.src, O = /* @__PURE__ */ new Map()), O;
    });
    p.forEach((R, O) => {
      const A = v[O], { src: G, unitsPerEm: ue } = _[A];
      let Q = E[A].get(R);
      if (!Q) {
        const { path: q, pathBounds: oe } = m.glyphData[G][R], ie = Math.max(oe[2] - oe[0], oe[3] - oe[1]) / a * (Fa.sdfMargin * a + 0.5), ce = c.glyphCount++, V = [
          oe[0] - ie,
          oe[1] - ie,
          oe[2] + ie,
          oe[3] + ie
        ];
        E[A].set(R, Q = { path: q, atlasIndex: ce, sdfViewBox: V }), S.push(Q);
      }
      const { sdfViewBox: le } = Q, re = g[T++], j = g[T++], $ = x / ue;
      b[C++] = re + le[0] * $, b[C++] = j + le[1] * $, b[C++] = re + le[2] * $, b[C++] = j + le[3] * $, p[O] = Q.atlasIndex;
    }), M.quads = (M.quads || 0) + (_o() - P);
    const y = _o();
    M.sdf = {};
    const w = d.height, D = Math.ceil(c.glyphCount / l), U = Math.pow(2, Math.ceil(Math.log2(D * a)));
    U > w && (console.info(`Increasing SDF texture size ${w}->${U}`), IN(d, r, U), u.dispose()), Promise.all(S.map(
      (R) => Ny(R, c, s.gpuAccelerateSDF).then(({ timing: O }) => {
        M.sdf[R.atlasIndex] = O;
      })
    )).then(() => {
      S.length && !c.contextLost && (By(c), u.needsUpdate = !0), M.sdfTotal = _o() - y, M.total = _o() - n, e(Object.freeze({
        parameters: s,
        sdfTexture: u,
        sdfGlyphSize: a,
        sdfExponent: o,
        glyphBounds: b,
        glyphAtlasIndices: p,
        glyphColors: m.glyphColors,
        caretPositions: m.caretPositions,
        chunkedBounds: m.chunkedBounds,
        ascender: m.ascender,
        descender: m.descender,
        lineHeight: m.lineHeight,
        capHeight: m.capHeight,
        xHeight: m.xHeight,
        topBaseline: m.topBaseline,
        blockBounds: m.blockBounds,
        visibleBounds: m.visibleBounds,
        timings: m.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || kN(d);
  });
}
function Ny({ path: s, atlasIndex: e, sdfViewBox: n }, { sdfGlyphSize: i, sdfCanvas: r, contextLost: o }, a) {
  if (o)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: l, sdfExponent: c } = Fa, u = Math.max(n[2] - n[0], n[3] - n[1]), d = Math.floor(e / 4), h = d % (l / i) * i, m = Math.floor(d / (l / i)) * i, p = e % 4;
  return TN(i, i, s, n, u, c, r, h, m, p, a);
}
function UN(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (n) => {
    console.log("Context Lost", n), n.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (n) => {
    console.log("Context Restored", n), s.contextLost = !1;
    const i = [];
    s.glyphsByFont.forEach((r) => {
      r.forEach((o) => {
        i.push(Ny(o, s, !0));
      });
    }), Promise.all(i).then(() => {
      By(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function ON(s, e) {
  for (let n in e)
    e.hasOwnProperty(n) && (s[n] = e[n]);
  return s;
}
let bc;
function zN(s) {
  return bc || (bc = typeof document > "u" ? {} : document.createElement("a")), bc.href = s, bc.href;
}
function By(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: n } = s, { width: i, height: r } = e, o = s.sdfCanvas.getContext("webgl");
    let a = n.image.data;
    (!a || a.length !== i * r * 4) && (a = new Uint8Array(i * r * 4), n.image = { width: i, height: r, data: a }, n.flipY = !1, n.isDataTexture = !0), o.readPixels(0, 0, i, r, o.RGBA, o.UNSIGNED_BYTE, a);
  }
}
const NN = /* @__PURE__ */ ta({
  name: "Typesetter",
  dependencies: [
    CN,
    MN,
    uN
  ],
  init(s, e, n) {
    return s(e, n());
  }
}), Vy = /* @__PURE__ */ ta({
  name: "Typesetter",
  dependencies: [
    NN
  ],
  init(s) {
    return function(e) {
      return new Promise((n) => {
        s.typeset(e, n);
      });
    };
  },
  getTransferables(s) {
    const e = [];
    for (let n in s)
      s[n] && s[n].buffer && e.push(s[n].buffer);
    return e;
  }
});
Vy.onMainThread;
const qv = {};
function BN(s) {
  let e = qv[s];
  return e || (e = qv[s] = new un(1, 1, s, s).translate(0.5, 0.5, 0)), e;
}
const VN = "aTroikaGlyphBounds", Zv = "aTroikaGlyphIndex", GN = "aTroikaGlyphColor";
class HN extends My {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new Sl(), this.boundingBox = new hr();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let n = BN(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = n.attributes[i].clone();
      }), this.setIndex(n.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, n, i, r, o) {
    this.updateAttributeData(VN, e, 4), this.updateAttributeData(Zv, n, 1), this.updateAttributeData(GN, o, 3), this._blockBounds = i, this._chunkedBounds = r, this.instanceCount = n.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: n, boundingBox: i } = this;
      if (n) {
        const { PI: r, floor: o, min: a, max: l, sin: c, cos: u } = Math, d = r / 2, h = r * 2, m = Math.abs(n), p = e[0] / m, v = e[2] / m, _ = o((p + d) / h) !== o((v + d) / h) ? -m : a(c(p) * m, c(v) * m), g = o((p - d) / h) !== o((v - d) / h) ? m : l(c(p) * m, c(v) * m), x = o((p + r) / h) !== o((v + r) / h) ? m * 2 : l(m - u(p) * m, m - u(v) * m);
        i.min.set(_, e[1], n < 0 ? -x : 0), i.max.set(g, e[3], n < 0 ? 0 : x);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let n = this.getAttribute(Zv).count, i = this._chunkedBounds;
    if (i)
      for (let r = i.length; r--; ) {
        n = i[r].end;
        let o = i[r].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x)
          break;
      }
    this.instanceCount = n;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(e, n, i) {
    const r = this.getAttribute(e);
    n ? r && r.array.length === n.length ? (r.array.set(n), r.needsUpdate = !0) : (this.setAttribute(e, new Rr(n, i)), delete this._maxInstanceCount, this.dispose()) : r && this.deleteAttribute(e);
  }
}
const $N = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, WN = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, XN = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, jN = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function YN(s) {
  const e = nf(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new rt() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new jt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new jt(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new rt() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Mt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Tt() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: $N,
    vertexTransform: WN,
    fragmentDefs: XN,
    fragmentColorTransform: jN,
    customRewriter({ vertexShader: n, fragmentShader: i }) {
      let r = /\buniform\s+vec3\s+diffuse\b/;
      return r.test(i) && (i = i.replace(r, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), r.test(n) || (n = n.replace(
        Oy,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: n, fragmentShader: i };
    }
  });
  return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const ep = /* @__PURE__ */ new Tn({
  color: 16777215,
  side: vn,
  transparent: !0
}), Kv = 8421504, Jv = /* @__PURE__ */ new Zt(), wc = /* @__PURE__ */ new de(), Xd = /* @__PURE__ */ new de(), wa = [], qN = /* @__PURE__ */ new de(), jd = "+x+y";
function Qv(s) {
  return Array.isArray(s) ? s[0] : s;
}
let Gy = () => {
  const s = new Ze(
    new un(1, 1),
    ep
  );
  return Gy = () => s, s;
}, Hy = () => {
  const s = new Ze(
    new un(1, 1, 32, 1),
    ep
  );
  return Hy = () => s, s;
};
const ZN = { type: "syncstart" }, KN = { type: "synccomplete" }, $y = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], JN = $y.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class rf extends Ze {
  constructor() {
    const e = new HN();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Kv, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = jd, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(ZN), FN({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (n) => {
      this._isSyncing = !1, this._textRenderInfo = n, this.geometry.updateGlyphs(
        n.glyphBounds,
        n.glyphAtlasIndices,
        n.blockBounds,
        n.chunkedBounds,
        n.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((r) => r && r());
      })), this.dispatchEvent(KN), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, n, i, r, o, a) {
    this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o);
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(e) {
    return YN(e);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const n = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = ep.clone());
    if ((!e || !e.isDerivedFrom(n)) && (e = this._derivedMaterial = this.createDerivedMaterial(n), n.addEventListener("dispose", function i() {
      n.removeEventListener("dispose", i), e.dispose();
    })), this.hasOutline()) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function r() {
        e.removeEventListener("dispose", r), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Qv(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {
  }
  get customDistanceMaterial() {
    return Qv(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {
  }
  _prepareForRender(e) {
    const n = e.isTextOutlineMaterial, i = e.uniforms, r = this.textRenderInfo;
    if (r) {
      const { sdfTexture: l, blockBounds: c } = r;
      i.uTroikaSDFTexture.value = l, i.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height), i.uTroikaSDFGlyphSize.value = r.sdfGlyphSize, i.uTroikaSDFExponent.value = r.sdfExponent, i.uTroikaTotalBounds.value.fromArray(c), i.uTroikaUseGlyphColors.value = !n && !!r.glyphColors;
      let u = 0, d = 0, h = 0, m, p, v, _ = 0, g = 0;
      if (n) {
        let { outlineWidth: M, outlineOffsetX: S, outlineOffsetY: b, outlineBlur: C, outlineOpacity: T } = this;
        u = this._parsePercent(M) || 0, d = Math.max(0, this._parsePercent(C) || 0), m = T, _ = this._parsePercent(S) || 0, g = this._parsePercent(b) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (v = this.strokeColor, i.uTroikaStrokeColor.value.set(v ?? Kv), p = this.strokeOpacity, p == null && (p = 1)), m = this.fillOpacity;
      i.uTroikaEdgeOffset.value = u, i.uTroikaPositionOffset.value.set(_, g), i.uTroikaBlurRadius.value = d, i.uTroikaStrokeWidth.value = h, i.uTroikaStrokeOpacity.value = p, i.uTroikaFillOpacity.value = m ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let x = this.clipRect;
      if (x && Array.isArray(x) && x.length === 4)
        i.uTroikaClipRect.value.fromArray(x);
      else {
        const M = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          c[0] - M,
          c[1] - M,
          c[2] + M,
          c[3] + M
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const o = n ? this.outlineColor || 0 : this.color;
    if (o == null)
      delete e.color;
    else {
      const l = e.hasOwnProperty("color") ? e.color : e.color = new Mt();
      (o !== l._input || typeof o == "object") && l.set(l._input = o);
    }
    let a = this.orientation || jd;
    if (a !== e._orientation) {
      let l = i.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let c = a !== jd && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (c) {
        let [, u, d, h, m] = c;
        wc.set(0, 0, 0)[d] = u === "-" ? 1 : -1, Xd.set(0, 0, 0)[m] = h === "-" ? -1 : 1, Jv.lookAt(qN, wc.cross(Xd), Xd), l.setFromMatrix4(Jv);
      } else
        l.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let n = e.match(/^(-?[\d.]+)%$/), i = n ? parseFloat(n[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, n = new rt()) {
    n.copy(e);
    const i = this.curveRadius;
    return i && (n.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), n;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, n = new rt()) {
    return wc.copy(e), this.localPositionToTextCoords(this.worldToLocal(wc), n);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, n) {
    const { textRenderInfo: i, curveRadius: r } = this;
    if (i) {
      const o = i.blockBounds, a = r ? Hy() : Gy(), l = a.geometry, { position: c, uv: u } = l.attributes;
      for (let d = 0; d < u.count; d++) {
        let h = o[0] + u.getX(d) * (o[2] - o[0]);
        const m = o[1] + u.getY(d) * (o[3] - o[1]);
        let p = 0;
        r && (p = r - Math.cos(h / r) * r, h = Math.sin(h / r) * r), c.setXYZ(d, h, m, p);
      }
      l.boundingSphere = this.geometry.boundingSphere, l.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, wa.length = 0, a.raycast(e, wa);
      for (let d = 0; d < wa.length; d++)
        wa[d].object = this, n.push(wa[d]);
    }
  }
  copy(e) {
    const n = this.geometry;
    return super.copy(e), this.geometry = n, JN.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
$y.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(rf.prototype, s, {
    get() {
      return this[e];
    },
    set(n) {
      n !== this[e] && (this[e] = n, this._needsSync = !0);
    }
  });
});
new hr();
new Mt();
class eg {
  constructor(e, n = 500) {
    fe(this, "entries", []);
    fe(this, "totalLength", 0);
    this.curve = e, this.build(n);
  }
  build(e) {
    this.entries = [];
    let n = 0, i = this.curve.getPointAt(0);
    for (let r = 0; r <= e; r++) {
      const o = r / e, a = this.curve.getPointAt(o), l = this.curve.getTangentAt(o);
      r > 0 && (n += a.distanceTo(i)), this.entries.push({
        t: o,
        distance: n,
        position: a.clone(),
        tangent: l.clone().normalize()
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.entries.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.entries[l].distance < e ? n = l + 1 : i = l;
    }
    const r = this.entries[n], o = this.entries[Math.max(0, n - 1)];
    if (r.distance === o.distance)
      return r.t;
    const a = (e - o.distance) / (r.distance - o.distance);
    return o.t + a * (r.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e), i = this.curve.getPointAt(n), r = this.curve.getTangentAt(n).normalize(), o = new de(-r.y, r.x, 0).normalize();
    return {
      position: i,
      tangent: r,
      normal: o,
      t: n,
      distance: e
    };
  }
}
class QN {
  constructor() {
    fe(this, "arcLengthTable", null);
    fe(this, "curve", null);
  }
  /**
   * Set the path from control points
   */
  setPath(e, n = !1) {
    var i, r, o, a, l, c, u, d;
    if (e.length < 2) {
      this.curve = null, this.arcLengthTable = null;
      return;
    }
    this.curve = new Hf();
    for (let h = 0; h < e.length - 1; h++) {
      const m = e[h], p = e[h + 1], v = m.depth ?? 0, _ = p.depth ?? 0, g = new hl(
        new de(m.x, -m.y, v),
        new de(
          m.x + (((i = m.handleOut) == null ? void 0 : i.x) ?? 0),
          -(m.y + (((r = m.handleOut) == null ? void 0 : r.y) ?? 0)),
          v
        ),
        new de(
          p.x + (((o = p.handleIn) == null ? void 0 : o.x) ?? 0),
          -(p.y + (((a = p.handleIn) == null ? void 0 : a.y) ?? 0)),
          _
        ),
        new de(p.x, -p.y, _)
      );
      this.curve.add(g);
    }
    if (n && e.length > 2) {
      const h = e[e.length - 1], m = e[0], p = h.depth ?? 0, v = m.depth ?? 0, _ = new hl(
        new de(h.x, -h.y, p),
        new de(
          h.x + (((l = h.handleOut) == null ? void 0 : l.x) ?? 0),
          -(h.y + (((c = h.handleOut) == null ? void 0 : c.y) ?? 0)),
          p
        ),
        new de(
          m.x + (((u = m.handleIn) == null ? void 0 : u.x) ?? 0),
          -(m.y + (((d = m.handleIn) == null ? void 0 : d.y) ?? 0)),
          v
        ),
        new de(m.x, -m.y, v)
      );
      this.curve.add(_);
    }
    this.arcLengthTable = new eg(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(e) {
    this.curve = e, this.arcLengthTable = new eg(e);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    var e;
    return ((e = this.arcLengthTable) == null ? void 0 : e.totalLength) ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(e, n, i = 0, r = 72) {
    if (!this.arcLengthTable || e.length === 0)
      return [];
    const o = this.arcLengthTable.totalLength, a = [], l = i / 1e3 * r;
    let c = 0;
    for (let p = 0; p < e.length; p++)
      c += e[p], p < e.length - 1 && (c += l);
    const u = o - n.firstMargin - n.lastMargin;
    let d;
    switch (n.align) {
      case "center":
        d = n.firstMargin + (u - c) / 2;
        break;
      case "right":
        d = n.firstMargin + u - c;
        break;
      default:
        d = n.firstMargin;
    }
    const h = n.offset / 100 * u;
    d += h, n.reversed && (d = o - d - c);
    let m = d;
    for (let p = 0; p < e.length; p++) {
      const v = e[p];
      let g = m + v / 2, x = !0;
      (g < 0 || g > o) && (n.forceAlignment ? g = (g % o + o) % o : (x = g >= -v && g <= o + v, g = Math.max(0, Math.min(o, g))));
      const M = this.arcLengthTable.getPointAtDistance(g);
      let S;
      if (n.perpendicularToPath) {
        const b = Math.atan2(M.tangent.y, M.tangent.x);
        S = new Mi(0, 0, n.reversed ? b + Math.PI : b);
      } else
        S = new Mi(0, 0, 0);
      a.push({
        index: p,
        position: M.position.clone(),
        rotation: S,
        scale: 1,
        pathDistance: g,
        pathT: M.t,
        visible: x
      }), m += v + l;
    }
    return a;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(e) {
    if (!this.arcLengthTable) return null;
    const n = e / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(n);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(e) {
    if (!this.arcLengthTable || e < 2) return [];
    const n = [], i = this.arcLengthTable.totalLength / (e - 1);
    for (let r = 0; r < e; r++) {
      const o = r * i;
      n.push(this.arcLengthTable.getPointAtDistance(o));
    }
    return n;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null, this.arcLengthTable = null;
  }
}
function e8() {
  return {
    pathLayerId: null,
    reversed: !1,
    perpendicularToPath: !0,
    forceAlignment: !1,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}
class t8 extends qi {
  constructor(n, i) {
    super(n);
    fe(this, "resources");
    // Text rendering
    fe(this, "textMesh");
    fe(this, "perCharacterGroup", null);
    fe(this, "characterMeshes", []);
    // Text data from layer
    fe(this, "textData");
    // Animatable text properties (from layer.properties)
    fe(this, "fontSizeProp");
    fe(this, "trackingProp");
    fe(this, "lineSpacingProp");
    fe(this, "fillColorProp");
    fe(this, "strokeColorProp");
    fe(this, "strokeWidthProp");
    fe(this, "pathOffsetProp");
    fe(this, "firstMarginProp");
    fe(this, "lastMarginProp");
    fe(this, "characterOffsetProp");
    // Per-character animation
    fe(this, "characterTransforms");
    // Path following service
    fe(this, "textOnPath");
    fe(this, "pathConfig");
    fe(this, "pathControlPoints", []);
    fe(this, "pathClosed", !1);
    // Character width cache (recalculated when text/font changes)
    fe(this, "characterWidths", []);
    fe(this, "characterWidthsDirty", !0);
    // Additional evaluator for text-specific properties
    fe(this, "textEvaluator");
    this.resources = i, this.textEvaluator = new Cl(), this.textOnPath = new QN(), this.pathConfig = e8(), this.textData = this.extractTextData(n), this.extractAnimatableProperties(n), this.textMesh = this.createTextMesh(), this.group.add(this.textMesh), (this.textData.perCharacter3D || this.textData.pathLayerId) && this.enablePerCharacter3D(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(n) {
    const i = n.data;
    return {
      text: (i == null ? void 0 : i.text) ?? "Text",
      fontFamily: (i == null ? void 0 : i.fontFamily) ?? "Impact",
      fontSize: (i == null ? void 0 : i.fontSize) ?? 72,
      fontWeight: (i == null ? void 0 : i.fontWeight) ?? "400",
      fontStyle: (i == null ? void 0 : i.fontStyle) ?? "normal",
      fill: (i == null ? void 0 : i.fill) ?? "#ffffff",
      stroke: (i == null ? void 0 : i.stroke) ?? "",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 0,
      // Character properties
      tracking: (i == null ? void 0 : i.tracking) ?? 0,
      lineSpacing: (i == null ? void 0 : i.lineSpacing) ?? 0,
      lineAnchor: (i == null ? void 0 : i.lineAnchor) ?? 50,
      characterOffset: (i == null ? void 0 : i.characterOffset) ?? 0,
      characterValue: (i == null ? void 0 : i.characterValue) ?? 0,
      blur: (i == null ? void 0 : i.blur) ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: (i == null ? void 0 : i.letterSpacing) ?? (i == null ? void 0 : i.tracking) ?? 0,
      lineHeight: (i == null ? void 0 : i.lineHeight) ?? (i == null ? void 0 : i.lineSpacing) ?? 1.2,
      textAlign: (i == null ? void 0 : i.textAlign) ?? "left",
      // Path options (full AE parity)
      pathLayerId: (i == null ? void 0 : i.pathLayerId) ?? null,
      pathReversed: (i == null ? void 0 : i.pathReversed) ?? !1,
      pathPerpendicularToPath: (i == null ? void 0 : i.pathPerpendicularToPath) ?? !0,
      pathForceAlignment: (i == null ? void 0 : i.pathForceAlignment) ?? !1,
      pathFirstMargin: (i == null ? void 0 : i.pathFirstMargin) ?? 0,
      pathLastMargin: (i == null ? void 0 : i.pathLastMargin) ?? 0,
      pathOffset: (i == null ? void 0 : i.pathOffset) ?? 0,
      pathAlign: (i == null ? void 0 : i.pathAlign) ?? "left",
      // More Options
      anchorPointGrouping: (i == null ? void 0 : i.anchorPointGrouping) ?? "character",
      groupingAlignment: (i == null ? void 0 : i.groupingAlignment) ?? { x: 0, y: 0 },
      fillAndStroke: (i == null ? void 0 : i.fillAndStroke) ?? "fill-over-stroke",
      interCharacterBlending: (i == null ? void 0 : i.interCharacterBlending) ?? "normal",
      // 3D
      perCharacter3D: (i == null ? void 0 : i.perCharacter3D) ?? !1
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(n) {
    if (n.properties) {
      for (const i of n.properties)
        switch (i.name) {
          case "Font Size":
            this.fontSizeProp = i;
            break;
          case "Tracking":
            this.trackingProp = i;
            break;
          case "Line Spacing":
            this.lineSpacingProp = i;
            break;
          case "Fill Color":
            this.fillColorProp = i;
            break;
          case "Stroke Color":
            this.strokeColorProp = i;
            break;
          case "Stroke Width":
            this.strokeWidthProp = i;
            break;
          case "Path Offset":
            this.pathOffsetProp = i;
            break;
          case "First Margin":
            this.firstMarginProp = i;
            break;
          case "Last Margin":
            this.lastMarginProp = i;
            break;
          case "Character Offset":
            this.characterOffsetProp = i;
            break;
        }
      this.syncPathConfig();
    }
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId, this.pathConfig.reversed = this.textData.pathReversed, this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath, this.pathConfig.forceAlignment = this.textData.pathForceAlignment, this.pathConfig.firstMargin = this.textData.pathFirstMargin, this.pathConfig.lastMargin = this.textData.pathLastMargin, this.pathConfig.offset = this.textData.pathOffset, this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const n = new rf();
    return n.text = this.textData.text, n.font = this.getFontUrl(this.textData.fontFamily) ?? null, n.fontSize = this.textData.fontSize, n.color = this.textData.fill, this.textData.stroke && this.textData.strokeWidth > 0 && (n.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, n.outlineColor = this.textData.stroke), n.letterSpacing = (this.textData.tracking || 0) / 1e3, n.lineHeight = this.textData.lineHeight || 1.2, n.textAlign = this.textData.textAlign, n.anchorX = this.getAnchorX(), n.anchorY = "middle", n.depthOffset = 0, n.renderOrder = 0, n.sync(), n;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(n) {
    return [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ].includes(n) ? void 0 : {
      Roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      Lato: "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      Montserrat: "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      Oswald: "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      Poppins: "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    }[n];
  }
  /**
   * Get anchor X based on text alignment
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "left";
      case "right":
        return "right";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(n, i = !1) {
    this.pathControlPoints = n, this.pathClosed = i, n.length >= 2 ? (this.textOnPath.setPath(n, i), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout()) : (this.textOnPath.dispose(), this.resetPathLayout());
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(n) {
    this.textOnPath.setCurve(n), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null, this.pathConfig.pathLayerId = null, this.textOnPath.dispose(), this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup)
      return;
    this.ensureCharacterWidths();
    const n = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(n);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(n) {
    for (let i = 0; i < this.characterMeshes.length && i < n.length; i++) {
      const r = this.characterMeshes[i], o = n[i];
      r.position.copy(o.position), r.rotation.copy(o.rotation), r.scale.setScalar(o.scale), r.visible = o.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    this.textData.perCharacter3D ? this.createCharacterMeshes() : this.disablePerCharacter3D();
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const n = this.textData.text, i = this.textData.fontSize * 0.6;
    for (let r = 0; r < n.length; r++) {
      const o = n[r];
      `iIl1|!.,;:'"`.includes(o) ? this.characterWidths.push(i * 0.4) : "mwMW".includes(o) ? this.characterWidths.push(i * 1.3) : o === " " ? this.characterWidths.push(i * 0.5) : this.characterWidths.push(i);
    }
    this.characterWidthsDirty = !1;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    this.perCharacterGroup || (this.textMesh.visible = !1, this.perCharacterGroup = new Ai(), this.perCharacterGroup.name = `text_chars_${this.id}`, this.group.add(this.perCharacterGroup), this.createCharacterMeshes());
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    this.perCharacterGroup && (this.textMesh.visible = !0, this.disposeCharacterMeshes(), this.group.remove(this.perCharacterGroup), this.perCharacterGroup = null);
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes(), this.characterWidthsDirty = !0;
    const n = this.textData.text;
    let i = 0;
    this.ensureCharacterWidths();
    const r = this.characterWidths.reduce((a, l) => a + l, 0) + (n.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let o = 0;
    switch (this.textData.textAlign) {
      case "center":
        o = -r / 2;
        break;
      case "right":
        o = -r;
        break;
      default:
        o = 0;
    }
    i = o;
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = new rf();
      c.text = l, c.font = this.getFontUrl(this.textData.fontFamily) ?? null, c.fontSize = this.textData.fontSize, c.color = this.textData.fill, c.anchorX = "center", c.anchorY = "middle", this.textData.stroke && this.textData.strokeWidth > 0 && (c.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, c.outlineColor = this.textData.stroke);
      const u = this.characterWidths[a];
      c.position.x = i + u / 2, c.position.y = 0, c.position.z = 0, i += u + this.textData.tracking / 1e3 * this.textData.fontSize, c.sync(), this.characterMeshes.push(c), this.perCharacterGroup.add(c);
    }
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    var n;
    for (const i of this.characterMeshes)
      i.dispose(), (n = this.perCharacterGroup) == null || n.remove(i);
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(n) {
    this.textData.text = n, this.textMesh.text = n, this.textMesh.sync(), this.characterWidthsDirty = !0, this.perCharacterGroup && this.createCharacterMeshes();
  }
  setFontFamily(n) {
    this.textData.fontFamily = n;
    const i = this.getFontUrl(n) ?? null;
    this.textMesh.font = i, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const r of this.characterMeshes)
      r.font = i, r.sync();
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setFontSize(n) {
    this.textData.fontSize = n, this.textMesh.fontSize = n, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const i of this.characterMeshes)
      i.fontSize = n, i.sync();
    this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setFillColor(n) {
    this.textData.fill = n, this.textMesh.color = n;
    for (const i of this.characterMeshes)
      i.color = n;
  }
  setStroke(n, i) {
    this.textData.stroke = n, this.textData.strokeWidth = i;
    const r = i / this.textData.fontSize;
    this.textMesh.outlineWidth = r, this.textMesh.outlineColor = n;
    for (const o of this.characterMeshes)
      o.outlineWidth = r, o.outlineColor = n;
  }
  setTracking(n) {
    this.textData.tracking = n, this.textMesh.letterSpacing = n / 1e3, this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setTextAlign(n) {
    this.textData.textAlign = n, this.textMesh.textAlign = n, this.textMesh.anchorX = this.getAnchorX(), this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? (this.pathConfig.align = n, this.updatePathLayout()) : this.createCharacterMeshes());
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(n) {
    this.textData.pathOffset = n, this.pathConfig.offset = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(n) {
    this.textData.pathFirstMargin = n, this.pathConfig.firstMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(n) {
    this.textData.pathLastMargin = n, this.pathConfig.lastMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set path reversed
   */
  setPathReversed(n) {
    this.textData.pathReversed = n, this.pathConfig.reversed = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(n) {
    this.textData.pathPerpendicularToPath = n, this.pathConfig.perpendicularToPath = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set force alignment
   */
  setForceAlignment(n) {
    this.textData.pathForceAlignment = n, this.pathConfig.forceAlignment = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setAnchorPointGrouping(n) {
    this.textData.anchorPointGrouping = n;
  }
  setFillAndStroke(n) {
    this.textData.fillAndStroke = n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    var i, r, o, a, l, c, u;
    if ((i = this.fontSizeProp) != null && i.animated) {
      const d = this.textEvaluator.evaluate(this.fontSizeProp, n);
      this.setFontSize(d);
    }
    if ((r = this.trackingProp) != null && r.animated) {
      const d = this.textEvaluator.evaluate(this.trackingProp, n);
      this.setTracking(d);
    }
    if ((o = this.fillColorProp) != null && o.animated) {
      const d = this.textEvaluator.evaluate(this.fillColorProp, n);
      this.setFillColor(d);
    }
    if ((a = this.strokeColorProp) != null && a.animated && this.strokeWidthProp) {
      const d = this.textEvaluator.evaluate(this.strokeColorProp, n), h = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, n) : this.textData.strokeWidth;
      this.setStroke(d, h);
    }
    if (this.pathOffsetProp) {
      const d = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, n) : this.textData.pathOffset;
      this.setPathOffset(d);
    }
    if ((l = this.firstMarginProp) != null && l.animated) {
      const d = this.textEvaluator.evaluate(this.firstMarginProp, n);
      this.setFirstMargin(d);
    }
    if ((c = this.lastMarginProp) != null && c.animated) {
      const d = this.textEvaluator.evaluate(this.lastMarginProp, n);
      this.setLastMargin(d);
    }
    (u = this.characterTransforms) != null && u.animated && this.perCharacterGroup && this.applyCharacterTransforms(n);
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(n) {
    if (!this.characterTransforms) return;
    const i = this.textEvaluator.evaluate(this.characterTransforms, n);
    for (let r = 0; r < this.characterMeshes.length && r < i.length; r++) {
      const o = this.characterMeshes[r], a = i[r];
      o.position.x += a.position.x, o.position.y += a.position.y, o.position.z += a.position.z, o.rotation.x += mn.degToRad(a.rotation.x), o.rotation.y += mn.degToRad(a.rotation.y), o.rotation.z += mn.degToRad(a.rotation.z), o.scale.x *= a.scale.x, o.scale.y *= a.scale.y, o.material && (o.material.opacity *= a.opacity);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.text !== void 0 && this.setText(i.text), i.fontFamily !== void 0 && this.setFontFamily(i.fontFamily), i.fontSize !== void 0 && this.setFontSize(i.fontSize), i.fill !== void 0 && this.setFillColor(i.fill), (i.stroke !== void 0 || i.strokeWidth !== void 0) && this.setStroke(
      i.stroke ?? this.textData.stroke,
      i.strokeWidth ?? this.textData.strokeWidth
    ), i.tracking !== void 0 && this.setTracking(i.tracking), i.textAlign !== void 0 && this.setTextAlign(i.textAlign), i.pathLayerId !== void 0 && (this.textData.pathLayerId = i.pathLayerId, this.pathConfig.pathLayerId = i.pathLayerId), i.pathOffset !== void 0 && this.setPathOffset(i.pathOffset), i.pathFirstMargin !== void 0 && this.setFirstMargin(i.pathFirstMargin), i.pathLastMargin !== void 0 && this.setLastMargin(i.pathLastMargin), i.pathReversed !== void 0 && this.setPathReversed(i.pathReversed), i.pathPerpendicularToPath !== void 0 && this.setPerpendicularToPath(i.pathPerpendicularToPath), i.pathForceAlignment !== void 0 && this.setForceAlignment(i.pathForceAlignment), i.perCharacter3D !== void 0 && (i.perCharacter3D && !this.perCharacterGroup ? this.enablePerCharacter3D() : !i.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup && this.disablePerCharacter3D()), i.anchorPointGrouping !== void 0 && this.setAnchorPointGrouping(i.anchorPointGrouping), i.fillAndStroke !== void 0 && this.setFillAndStroke(i.fillAndStroke)), n.properties && this.extractAnimatableProperties(n);
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    var i;
    const n = (i = this.textMesh.textRenderInfo) == null ? void 0 : i.blockBounds;
    return n ? {
      width: n[2] - n[0],
      height: n[3] - n[1]
    } : { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose(), this.disposeCharacterMeshes(), this.textOnPath.dispose(), this.perCharacterGroup && this.group.remove(this.perCharacterGroup);
  }
}
class n8 extends qi {
  constructor(n) {
    super(n);
    /** The line mesh for the spline */
    fe(this, "lineMesh", null);
    /** The fill mesh (if closed path with fill) */
    fe(this, "fillMesh", null);
    /** Spline data */
    fe(this, "splineData");
    /** Cached curve for path calculations */
    fe(this, "curve", null);
    this.splineData = this.extractSplineData(n), this.buildSpline(), this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(n) {
    const i = n.data;
    return {
      controlPoints: (i == null ? void 0 : i.controlPoints) ?? [],
      closed: (i == null ? void 0 : i.closed) ?? !1,
      stroke: (i == null ? void 0 : i.stroke) ?? "#00ff00",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 2,
      fill: (i == null ? void 0 : i.fill) ?? "",
      pathData: (i == null ? void 0 : i.pathData) ?? ""
    };
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    var a, l, c, u, d, h, m, p;
    this.clearMeshes();
    const n = this.splineData.controlPoints;
    if (n.length < 2) return;
    this.curve = new Hf();
    for (let v = 0; v < n.length - 1; v++) {
      const _ = n[v], g = n[v + 1], x = _.depth ?? 0, M = g.depth ?? 0, S = new hl(
        new de(_.x, -_.y, x),
        new de(
          _.x + (((a = _.handleOut) == null ? void 0 : a.x) ?? 0),
          -(_.y + (((l = _.handleOut) == null ? void 0 : l.y) ?? 0)),
          x
        ),
        new de(
          g.x + (((c = g.handleIn) == null ? void 0 : c.x) ?? 0),
          -(g.y + (((u = g.handleIn) == null ? void 0 : u.y) ?? 0)),
          M
        ),
        new de(g.x, -g.y, M)
      );
      this.curve.add(S);
    }
    if (this.splineData.closed && n.length > 2) {
      const v = n[n.length - 1], _ = n[0], g = v.depth ?? 0, x = _.depth ?? 0, M = new hl(
        new de(v.x, -v.y, g),
        new de(
          v.x + (((d = v.handleOut) == null ? void 0 : d.x) ?? 0),
          -(v.y + (((h = v.handleOut) == null ? void 0 : h.y) ?? 0)),
          g
        ),
        new de(
          _.x + (((m = _.handleIn) == null ? void 0 : m.x) ?? 0),
          -(_.y + (((p = _.handleIn) == null ? void 0 : p.y) ?? 0)),
          x
        ),
        new de(_.x, -_.y, x)
      );
      this.curve.add(M);
    }
    const i = this.curve.getPoints(n.length * 20), r = new Vt().setFromPoints(i), o = new Yi({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: !0
    });
    this.lineMesh = new ln(r, o), this.lineMesh.name = `spline_line_${this.id}`, this.group.add(this.lineMesh), this.splineData.fill && this.splineData.closed && this.createFill(i);
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(n) {
    if (n.length < 3) return;
    const i = new xy();
    i.moveTo(n[0].x, n[0].y);
    for (let a = 1; a < n.length; a++)
      i.lineTo(n[a].x, n[a].y);
    i.closePath();
    const r = new Xf(i), o = new Tn({
      color: this.splineData.fill,
      transparent: !0,
      side: vn,
      depthWrite: !1
    });
    this.fillMesh = new Ze(r, o), this.fillMesh.name = `spline_fill_${this.id}`, this.fillMesh.position.z = -0.1, this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    this.lineMesh && (this.group.remove(this.lineMesh), this.lineMesh.geometry.dispose(), this.lineMesh.material.dispose(), this.lineMesh = null), this.fillMesh && (this.group.remove(this.fillMesh), this.fillMesh.geometry.dispose(), this.fillMesh.material.dispose(), this.fillMesh = null), this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(n) {
    return this.curve ? this.curve.getPointAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(n) {
    return this.curve ? this.curve.getTangentAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    return this.curve ? this.curve.getLength() : 0;
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(n) {
    const i = this.getPointAt(n), r = this.getTangentAt(n);
    if (!i || !r) return null;
    const o = Math.atan2(r.y, r.x) * (180 / Math.PI);
    return { position: i, rotation: o };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(n) {
    this.splineData.stroke = n, this.lineMesh && this.lineMesh.material.color.set(n);
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(n) {
    this.splineData.strokeWidth = n, this.lineMesh && (this.lineMesh.material.linewidth = n);
  }
  /**
   * Set fill color
   */
  setFill(n) {
    if (this.splineData.fill = n, this.fillMesh)
      this.fillMesh.material.color.set(n);
    else if (n && this.splineData.closed && this.curve) {
      const i = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(i);
    }
  }
  /**
   * Update control points
   */
  setControlPoints(n) {
    this.splineData.controlPoints = n, this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(n) {
    this.splineData.closed !== n && (this.splineData.closed = n, this.buildSpline());
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    const i = n.data;
    if (i) {
      let r = !1;
      i.controlPoints !== void 0 && (this.splineData.controlPoints = i.controlPoints, r = !0), i.closed !== void 0 && i.closed !== this.splineData.closed && (this.splineData.closed = i.closed, r = !0), i.stroke !== void 0 && this.setStroke(i.stroke), i.strokeWidth !== void 0 && this.setStrokeWidth(i.strokeWidth), i.fill !== void 0 && this.setFill(i.fill), r && this.buildSpline();
    }
  }
  onDispose() {
    this.clearMeshes();
  }
}
const zi = 16, Sc = 16, i8 = 50, s8 = [
  "tf_position",
  "tf_velocity",
  "tf_life",
  "tf_physical",
  "tf_rotation",
  "tf_color"
];
function tg(s) {
  return {
    id: s || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: !0,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: !1,
    beatEmissionMultiplier: 5
  };
}
function r8(s, e) {
  const n = {
    id: e || `force_${Date.now()}`,
    name: s.charAt(0).toUpperCase() + s.slice(1),
    type: s,
    enabled: !0,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (s) {
    case "gravity":
      n.direction = { x: 0, y: 1, z: 0 }, n.strength = 98;
      break;
    case "vortex":
      n.vortexAxis = { x: 0, y: 0, z: 1 }, n.inwardForce = 20;
      break;
    case "turbulence":
      n.noiseScale = 5e-3, n.noiseSpeed = 0.5, n.noiseOctaves = 3, n.noiseLacunarity = 2, n.noiseGain = 0.5;
      break;
    case "drag":
      n.linearDrag = 0.1, n.quadraticDrag = 0.01;
      break;
    case "wind":
      n.windDirection = { x: 1, y: 0, z: 0 }, n.gustStrength = 50, n.gustFrequency = 0.1;
      break;
    case "lorenz":
      n.lorenzSigma = 10, n.lorenzRho = 28, n.lorenzBeta = 2.667;
      break;
  }
  return n;
}
function Wy() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: !0,
      depthWrite: !1,
      depthTest: !0,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: !1,
        receiveShadows: !1,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: !1,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: !1,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: !1,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: !1,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: !1,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: i8,
    updateFrequency: 1,
    cullOffscreen: !0
  };
}
class ng {
  constructor(e = {}) {
    fe(this, "config");
    fe(this, "gl", null);
    fe(this, "renderer", null);
    // Double-buffered particle data
    fe(this, "particleBufferA");
    fe(this, "particleBufferB");
    fe(this, "currentBuffer", "A");
    // WebGL resources
    fe(this, "transformFeedbackProgram", null);
    fe(this, "renderProgram", null);
    fe(this, "vaoA", null);
    fe(this, "vaoB", null);
    fe(this, "particleVboA", null);
    fe(this, "particleVboB", null);
    fe(this, "transformFeedbackA", null);
    fe(this, "transformFeedbackB", null);
    // Three.js integration
    fe(this, "particleMesh", null);
    fe(this, "instancedGeometry", null);
    fe(this, "material", null);
    // Textures for modulation curves
    fe(this, "sizeOverLifetimeTexture", null);
    fe(this, "opacityOverLifetimeTexture", null);
    fe(this, "colorOverLifetimeTexture", null);
    // Emitter state
    fe(this, "emitters", /* @__PURE__ */ new Map());
    fe(this, "forceFields", /* @__PURE__ */ new Map());
    fe(this, "subEmitters", /* @__PURE__ */ new Map());
    // Runtime state
    fe(this, "state", {
      particleCount: 0,
      activeEmitters: 0,
      simulationTime: 0,
      frameCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0,
      gpuMemoryBytes: 0,
      currentAudioFeatures: /* @__PURE__ */ new Map()
    });
    // Audio reactivity
    fe(this, "audioFeatures", /* @__PURE__ */ new Map());
    // Spatial hash for neighbor queries (flocking)
    fe(this, "spatialHash", /* @__PURE__ */ new Map());
    // Event system
    fe(this, "eventHandlers", /* @__PURE__ */ new Map());
    // Pool of free particle indices
    fe(this, "freeIndices", []);
    fe(this, "nextParticleIndex", 0);
    // Random number generator with seed
    fe(this, "rng");
    // ============================================================================
    // Initialization
    // ============================================================================
    // GPU physics mode flag
    fe(this, "useGPUPhysics", !1);
    fe(this, "gpuPhysicsInitialized", !1);
    // Force field uniform buffer for GPU physics
    fe(this, "forceFieldBuffer", null);
    fe(this, "forceFieldTexture", null);
    this.config = { ...Wy(), ...e };
    const n = this.config.maxParticles * zi;
    this.particleBufferA = new Float32Array(n), this.particleBufferB = new Float32Array(n);
    for (let i = this.config.maxParticles - 1; i >= 0; i--)
      this.freeIndices.push(i);
    this.rng = this.createSeededRandom(this.config.randomSeed ?? Date.now()), this.config.emitters.forEach((i) => this.addEmitter(i)), this.config.forceFields.forEach((i) => this.addForceField(i)), this.config.subEmitters.forEach((i) => this.addSubEmitter(i));
  }
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(e) {
    if (this.renderer = e, this.gl = e.getContext(), !this.gl)
      throw new Error("WebGL2 context required for GPU particle system");
    this.createModulationTextures(), this.createParticleMesh(), this.initializeGPUPhysics(), this.state.gpuMemoryBytes = this.config.maxParticles * zi * 4 * 2;
  }
  /**
   * Initialize WebGL2 Transform Feedback for GPU-accelerated physics
   * This allows physics simulation to run entirely on the GPU for 100k+ particles
   */
  initializeGPUPhysics() {
    if (!this.gl) return;
    const e = this.gl;
    if (!e.getExtension("EXT_color_buffer_float")) {
      console.warn("EXT_color_buffer_float not available, using CPU physics fallback"), this.useGPUPhysics = !1;
      return;
    }
    try {
      if (this.transformFeedbackProgram = this.createTransformFeedbackProgram(e), !this.transformFeedbackProgram) {
        console.warn("Failed to create transform feedback program, using CPU physics"), this.useGPUPhysics = !1;
        return;
      }
      if (this.particleVboA = e.createBuffer(), this.particleVboB = e.createBuffer(), !this.particleVboA || !this.particleVboB)
        throw new Error("Failed to create particle VBOs");
      if (e.bindBuffer(e.ARRAY_BUFFER, this.particleVboA), e.bufferData(e.ARRAY_BUFFER, this.particleBufferA, e.DYNAMIC_COPY), e.bindBuffer(e.ARRAY_BUFFER, this.particleVboB), e.bufferData(e.ARRAY_BUFFER, this.particleBufferB, e.DYNAMIC_COPY), this.vaoA = e.createVertexArray(), this.vaoB = e.createVertexArray(), !this.vaoA || !this.vaoB)
        throw new Error("Failed to create VAOs");
      if (this.setupParticleVAO(e, this.vaoA, this.particleVboA), this.setupParticleVAO(e, this.vaoB, this.particleVboB), this.transformFeedbackA = e.createTransformFeedback(), this.transformFeedbackB = e.createTransformFeedback(), !this.transformFeedbackA || !this.transformFeedbackB)
        throw new Error("Failed to create transform feedback objects");
      e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, this.transformFeedbackA), e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboB), e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, this.transformFeedbackB), e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboA), e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null), this.forceFieldBuffer = new Float32Array(Sc * 16), this.forceFieldTexture = new To(
        this.forceFieldBuffer,
        Sc,
        4,
        // 4 rows of 4 floats = 16 floats per force field
        Rn,
        si
      ), this.useGPUPhysics = !0, this.gpuPhysicsInitialized = !0, console.log("GPU physics initialized with Transform Feedback");
    } catch (i) {
      console.warn("GPU physics initialization failed:", i), this.useGPUPhysics = !1, this.cleanupGPUPhysics();
    }
  }
  /**
   * Set up vertex attribute pointers for particle VAO
   */
  setupParticleVAO(e, n, i) {
    e.bindVertexArray(n), e.bindBuffer(e.ARRAY_BUFFER, i);
    const r = zi * 4;
    e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 3, e.FLOAT, !1, r, 0), e.enableVertexAttribArray(1), e.vertexAttribPointer(1, 3, e.FLOAT, !1, r, 12), e.enableVertexAttribArray(2), e.vertexAttribPointer(2, 2, e.FLOAT, !1, r, 24), e.enableVertexAttribArray(3), e.vertexAttribPointer(3, 2, e.FLOAT, !1, r, 32), e.enableVertexAttribArray(4), e.vertexAttribPointer(4, 2, e.FLOAT, !1, r, 40), e.enableVertexAttribArray(5), e.vertexAttribPointer(5, 4, e.FLOAT, !1, r, 48), e.bindVertexArray(null);
  }
  /**
   * Create the transform feedback shader program for GPU physics
   */
  createTransformFeedbackProgram(e) {
    const n = this.getTransformFeedbackVertexShader(), i = this.getTransformFeedbackFragmentShader(), r = e.createShader(e.VERTEX_SHADER), o = e.createShader(e.FRAGMENT_SHADER);
    if (!r || !o) return null;
    if (e.shaderSource(r, n), e.compileShader(r), !e.getShaderParameter(r, e.COMPILE_STATUS))
      return console.error("Transform feedback vertex shader error:", e.getShaderInfoLog(r)), e.deleteShader(r), e.deleteShader(o), null;
    if (e.shaderSource(o, i), e.compileShader(o), !e.getShaderParameter(o, e.COMPILE_STATUS))
      return console.error("Transform feedback fragment shader error:", e.getShaderInfoLog(o)), e.deleteShader(r), e.deleteShader(o), null;
    const a = e.createProgram();
    return a ? (e.attachShader(a, r), e.attachShader(a, o), e.transformFeedbackVaryings(a, s8, e.INTERLEAVED_ATTRIBS), e.linkProgram(a), e.getProgramParameter(a, e.LINK_STATUS) ? (e.deleteShader(r), e.deleteShader(o), a) : (console.error("Transform feedback program link error:", e.getProgramInfoLog(a)), e.deleteProgram(a), e.deleteShader(r), e.deleteShader(o), null)) : (e.deleteShader(r), e.deleteShader(o), null);
  }
  /**
   * Get the vertex shader for transform feedback GPU physics
   */
  getTransformFeedbackVertexShader() {
    return `#version 300 es
      precision highp float;

      // Input particle attributes
      layout(location = 0) in vec3 a_position;
      layout(location = 1) in vec3 a_velocity;
      layout(location = 2) in vec2 a_life;      // age, lifetime
      layout(location = 3) in vec2 a_physical;  // mass, size
      layout(location = 4) in vec2 a_rotation;  // rotation, angularVelocity
      layout(location = 5) in vec4 a_color;

      // Output (transform feedback)
      out vec3 tf_position;
      out vec3 tf_velocity;
      out vec2 tf_life;
      out vec2 tf_physical;
      out vec2 tf_rotation;
      out vec4 tf_color;

      // Uniforms
      uniform float u_deltaTime;
      uniform float u_time;
      uniform int u_forceFieldCount;
      uniform sampler2D u_forceFields;

      // Noise functions for turbulence
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
          i.z + vec4(0.0, i1.z, i2.z, 1.0))
          + i.y + vec4(0.0, i1.y, i2.y, 1.0))
          + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);

        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      // Calculate force from a single force field
      vec3 calculateForce(int fieldIndex, vec3 pos, vec3 vel, float mass) {
        // Read force field data from texture
        // Row 0: position.xyz, type
        // Row 1: strength, falloffStart, falloffEnd, falloffType
        // Row 2: direction/axis.xyz, extra param
        // Row 3: extra params (noise scale, speed, etc)

        vec4 row0 = texelFetch(u_forceFields, ivec2(fieldIndex, 0), 0);
        vec4 row1 = texelFetch(u_forceFields, ivec2(fieldIndex, 1), 0);
        vec4 row2 = texelFetch(u_forceFields, ivec2(fieldIndex, 2), 0);
        vec4 row3 = texelFetch(u_forceFields, ivec2(fieldIndex, 3), 0);

        vec3 fieldPos = row0.xyz;
        int fieldType = int(row0.w);
        float strength = row1.x;
        float falloffStart = row1.y;
        float falloffEnd = row1.z;
        int falloffType = int(row1.w);

        // Calculate distance and falloff
        vec3 toField = fieldPos - pos;
        float dist = length(toField);

        float falloff = 1.0;
        if (dist > falloffStart && falloffEnd > falloffStart) {
          float t = clamp((dist - falloffStart) / (falloffEnd - falloffStart), 0.0, 1.0);
          if (falloffType == 1) falloff = 1.0 - t; // Linear
          else if (falloffType == 2) falloff = 1.0 - t * t; // Quadratic
          else if (falloffType == 3) falloff = exp(-t * 3.0); // Exponential
          else if (falloffType == 4) falloff = 1.0 - (3.0 * t * t - 2.0 * t * t * t); // Smoothstep
        }

        vec3 force = vec3(0.0);
        float effectiveStrength = strength * falloff;

        // Force field types
        if (fieldType == 0) {
          // Gravity - directional
          force = row2.xyz * effectiveStrength;
        }
        else if (fieldType == 1) {
          // Point attractor
          if (dist > 0.001) {
            vec3 dir = normalize(toField);
            force = dir * effectiveStrength / max(mass, 0.1);
          }
        }
        else if (fieldType == 2) {
          // Vortex
          if (dist > 0.001) {
            vec3 axis = normalize(row2.xyz);
            vec3 tangent = normalize(cross(axis, toField));
            float inward = row2.w;
            force = tangent * effectiveStrength + normalize(toField) * inward;
          }
        }
        else if (fieldType == 3) {
          // Turbulence
          float noiseScale = row3.x;
          float noiseSpeed = row3.y;
          vec3 noisePos = pos * noiseScale + vec3(u_time * noiseSpeed);
          force.x = snoise(noisePos) * effectiveStrength;
          force.y = snoise(noisePos + vec3(100.0)) * effectiveStrength;
          force.z = snoise(noisePos + vec3(200.0)) * effectiveStrength;
        }
        else if (fieldType == 4) {
          // Drag
          float linearDrag = row3.x;
          float quadDrag = row3.y;
          float speed = length(vel);
          if (speed > 0.001) {
            float dragMag = linearDrag * speed + quadDrag * speed * speed;
            force = -normalize(vel) * dragMag * effectiveStrength;
          }
        }
        else if (fieldType == 5) {
          // Wind
          vec3 windDir = normalize(row2.xyz);
          float gustStrength = row3.x;
          float gustFreq = row3.y;
          float gust = sin(u_time * gustFreq) * gustStrength;
          force = windDir * (effectiveStrength + gust);
        }

        return force;
      }

      void main() {
        // Pass through dead particles unchanged
        if (a_life.y <= 0.0 || a_life.x >= a_life.y) {
          tf_position = a_position;
          tf_velocity = a_velocity;
          tf_life = a_life;
          tf_physical = a_physical;
          tf_rotation = a_rotation;
          tf_color = a_color;
          return;
        }

        // Read particle state
        vec3 pos = a_position;
        vec3 vel = a_velocity;
        float age = a_life.x;
        float lifetime = a_life.y;
        float mass = a_physical.x;
        float size = a_physical.y;
        float rotation = a_rotation.x;
        float angularVel = a_rotation.y;

        // Accumulate forces
        vec3 totalForce = vec3(0.0);
        for (int i = 0; i < u_forceFieldCount; i++) {
          totalForce += calculateForce(i, pos, vel, mass);
        }

        // Apply acceleration (F = ma)
        vec3 acceleration = totalForce / max(mass, 0.1);
        vel += acceleration * u_deltaTime;

        // Integrate position
        pos += vel * u_deltaTime;

        // Update rotation
        rotation += angularVel * u_deltaTime;

        // Update age
        age += u_deltaTime;

        // Life ratio for modulation
        float lifeRatio = age / lifetime;

        // Apply size over lifetime (simple linear fade for now)
        // More complex curves should be done via texture lookup
        float sizeMod = 1.0 - lifeRatio * 0.5;
        size = a_physical.y * sizeMod;

        // Apply opacity over lifetime
        float opacityMod = 1.0 - lifeRatio;

        // Output
        tf_position = pos;
        tf_velocity = vel;
        tf_life = vec2(age, lifetime);
        tf_physical = vec2(mass, size);
        tf_rotation = vec2(rotation, angularVel);
        tf_color = vec4(a_color.rgb, a_color.a * opacityMod);
      }
    `;
  }
  /**
   * Get the fragment shader for transform feedback (must exist but won't output)
   */
  getTransformFeedbackFragmentShader() {
    return `#version 300 es
      precision highp float;
      out vec4 fragColor;
      void main() {
        fragColor = vec4(0.0);
      }
    `;
  }
  /**
   * Clean up GPU physics resources
   */
  cleanupGPUPhysics() {
    var n;
    if (!this.gl) return;
    const e = this.gl;
    this.transformFeedbackProgram && (e.deleteProgram(this.transformFeedbackProgram), this.transformFeedbackProgram = null), this.particleVboA && (e.deleteBuffer(this.particleVboA), this.particleVboA = null), this.particleVboB && (e.deleteBuffer(this.particleVboB), this.particleVboB = null), this.vaoA && (e.deleteVertexArray(this.vaoA), this.vaoA = null), this.vaoB && (e.deleteVertexArray(this.vaoB), this.vaoB = null), this.transformFeedbackA && (e.deleteTransformFeedback(this.transformFeedbackA), this.transformFeedbackA = null), this.transformFeedbackB && (e.deleteTransformFeedback(this.transformFeedbackB), this.transformFeedbackB = null), (n = this.forceFieldTexture) == null || n.dispose(), this.forceFieldTexture = null;
  }
  /**
   * Enable or disable GPU physics
   */
  setGPUPhysicsEnabled(e) {
    e && !this.gpuPhysicsInitialized && this.initializeGPUPhysics(), this.useGPUPhysics = e && this.gpuPhysicsInitialized;
  }
  /**
   * Check if GPU physics is currently enabled
   */
  isGPUPhysicsEnabled() {
    return this.useGPUPhysics;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const n = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, n), this.sizeOverLifetimeTexture = new To(
      n,
      256,
      1,
      tu,
      si
    ), this.sizeOverLifetimeTexture.needsUpdate = !0;
    const i = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, i), this.opacityOverLifetimeTexture = new To(
      i,
      256,
      1,
      tu,
      si
    ), this.opacityOverLifetimeTexture.needsUpdate = !0;
    const r = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ], o = new Float32Array(256 * 4);
    for (let a = 0; a < 256; a++) {
      const l = a / 255, c = this.sampleColorGradient(r, l);
      o[a * 4] = c[0], o[a * 4 + 1] = c[1], o[a * 4 + 2] = c[2], o[a * 4 + 3] = c[3];
    }
    this.colorOverLifetimeTexture = new To(
      o,
      256,
      1,
      Rn,
      si
    ), this.colorOverLifetimeTexture.needsUpdate = !0;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(e, n) {
    const i = n.length;
    if (!e) {
      n.fill(1);
      return;
    }
    for (let r = 0; r < i; r++) {
      const o = r / (i - 1);
      n[r] = this.evaluateModulationCurve(e, o);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(e, n) {
    switch (e.type) {
      case "constant":
        return e.value;
      case "linear":
        return e.start + (e.end - e.start) * n;
      case "curve": {
        const i = e.points;
        if (i.length === 0) return 1;
        if (i.length === 1) return i[0].value;
        let r = i[0], o = i[i.length - 1];
        for (let p = 0; p < i.length - 1; p++)
          if (n >= i[p].time && n <= i[p + 1].time) {
            r = i[p], o = i[p + 1];
            break;
          }
        const a = (n - r.time) / (o.time - r.time), l = a * a, c = l * a, u = 2 * c - 3 * l + 1, d = -2 * c + 3 * l, h = c - 2 * l + a, m = c - l;
        return u * r.value + d * o.value + h * (r.outTangent ?? 0) + m * (o.inTangent ?? 0);
      }
      case "random":
        return e.min + this.rng() * (e.max - e.min);
      case "randomCurve": {
        const i = this.evaluateModulationCurve(e.minCurve, n), r = this.evaluateModulationCurve(e.maxCurve, n);
        return i + this.rng() * (r - i);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(e, n) {
    if (e.length === 0) return [1, 1, 1, 1];
    if (e.length === 1) return e[0].color;
    let i = e[0], r = e[e.length - 1];
    for (let a = 0; a < e.length - 1; a++)
      if (n >= e[a].time && n <= e[a + 1].time) {
        i = e[a], r = e[a + 1];
        break;
      }
    const o = (n - i.time) / (r.time - i.time);
    return [
      i.color[0] + (r.color[0] - i.color[0]) * o,
      i.color[1] + (r.color[1] - i.color[1]) * o,
      i.color[2] + (r.color[2] - i.color[2]) * o,
      i.color[3] + (r.color[3] - i.color[3]) * o
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const e = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]), n = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new My(), this.instancedGeometry.setAttribute("position", new Si(e, 2)), this.instancedGeometry.setAttribute("uv", new Si(n, 2));
    const i = new Rr(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), r = new Rr(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), o = new Rr(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), a = new Rr(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), l = new Rr(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), c = new Rr(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    i.setUsage(no), r.setUsage(no), o.setUsage(no), a.setUsage(no), l.setUsage(no), c.setUsage(no), this.instancedGeometry.setAttribute("i_position", i), this.instancedGeometry.setAttribute("i_velocity", r), this.instancedGeometry.setAttribute("i_life", o), this.instancedGeometry.setAttribute("i_physical", a), this.instancedGeometry.setAttribute("i_rotation", l), this.instancedGeometry.setAttribute("i_color", c), this.material = new zn({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: this.createUniforms(),
      transparent: !0,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    }), this.particleMesh = new Ze(this.instancedGeometry, this.material), this.particleMesh.frustumCulled = !1;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    this.emitters.set(e.id, {
      ...e,
      accumulator: 0,
      velocity: new de()
    }), this.state.activeEmitters = this.emitters.size;
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.state.activeEmitters = this.emitters.size;
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(e) {
    this.forceFields.set(e.id, e);
  }
  updateForceField(e, n) {
    const i = this.forceFields.get(e);
    i && Object.assign(i, n);
  }
  removeForceField(e) {
    this.forceFields.delete(e);
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(e) {
    this.subEmitters.set(e.id, e);
  }
  removeSubEmitter(e) {
    this.subEmitters.delete(e);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(e) {
    var r;
    const n = performance.now(), i = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : e * this.config.timeScale;
    this.emitParticles(i), this.useGPUPhysics && this.gl ? this.updatePhysicsGPU(i) : this.updatePhysics(i), this.processSubEmitters(), (r = this.config.flocking) != null && r.enabled && (this.updateSpatialHash(), this.applyFlocking(i)), this.applyAudioModulation(), this.updateInstanceBuffers(), this.state.simulationTime += i, this.state.frameCount++, this.state.updateTimeMs = performance.now() - n;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(e) {
    for (const n of this.emitters.values()) {
      if (!n.enabled) continue;
      let i = n.emissionRate;
      const r = this.getAudioModulation("emitter", n.id, "emissionRate");
      if (r !== void 0 && (i *= r), n.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const o = Math.floor(n.burstCount * n.beatEmissionMultiplier);
        for (let a = 0; a < o; a++)
          this.spawnParticle(n);
      }
      for (n.accumulator += i * e; n.accumulator >= 1; )
        this.spawnParticle(n), n.accumulator -= 1;
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(e) {
    if (this.freeIndices.length === 0) {
      let d = 0, h = 0;
      const m = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let p = 0; p < this.config.maxParticles; p++) {
        const v = m[p * zi + 6];
        v > h && (h = v, d = p);
      }
      this.freeIndices.push(d);
    }
    const n = this.freeIndices.pop(), i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, r = n * zi, o = this.getEmitterPosition(e), a = this.getEmissionDirection(e), l = e.initialSpeed + (this.rng() - 0.5) * 2 * e.speedVariance, c = e.velocity.clone().multiplyScalar(e.inheritEmitterVelocity);
    i[r + 0] = o.x, i[r + 1] = o.y, i[r + 2] = o.z, i[r + 3] = a.x * l + c.x, i[r + 4] = a.y * l + c.y, i[r + 5] = a.z * l + c.z, i[r + 6] = 0, i[r + 7] = e.lifetime + (this.rng() - 0.5) * 2 * e.lifetimeVariance, i[r + 8] = e.initialMass + (this.rng() - 0.5) * 2 * e.massVariance, i[r + 9] = e.initialSize + (this.rng() - 0.5) * 2 * e.sizeVariance, i[r + 10] = e.initialRotation + this.rng() * e.rotationVariance, i[r + 11] = e.initialAngularVelocity + (this.rng() - 0.5) * 2 * e.angularVelocityVariance;
    const u = this.rng() * e.colorVariance;
    return i[r + 12] = e.colorStart[0] + (e.colorEnd[0] - e.colorStart[0]) * u, i[r + 13] = e.colorStart[1] + (e.colorEnd[1] - e.colorStart[1]) * u, i[r + 14] = e.colorStart[2] + (e.colorEnd[2] - e.colorStart[2]) * u, i[r + 15] = e.colorStart[3], this.state.particleCount++, this.emit("particleBirth", { index: n, emitterId: e.id }), n;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(e) {
    const n = e.shape, i = new de(e.position.x, e.position.y, e.position.z);
    switch (n.type) {
      case "point":
        return i;
      case "circle": {
        const r = this.rng() * Math.PI * 2;
        let o = n.radius ?? 50;
        return n.emitFromEdge || (o *= Math.sqrt(this.rng())), i.add(new de(
          Math.cos(r) * o,
          Math.sin(r) * o,
          0
        ));
      }
      case "sphere": {
        const r = this.rng() * Math.PI * 2, o = Math.acos(2 * this.rng() - 1);
        let a = n.radius ?? 50;
        return n.emitFromEdge || (a *= Math.cbrt(this.rng())), i.add(new de(
          Math.sin(o) * Math.cos(r) * a,
          Math.sin(o) * Math.sin(r) * a,
          Math.cos(o) * a
        ));
      }
      case "box": {
        const r = n.boxSize ?? { x: 100, y: 100, z: 100 };
        return i.add(new de(
          (this.rng() - 0.5) * r.x,
          (this.rng() - 0.5) * r.y,
          (this.rng() - 0.5) * r.z
        ));
      }
      case "line": {
        const r = n.lineStart ?? { x: -50, y: 0, z: 0 }, o = n.lineEnd ?? { x: 50, y: 0, z: 0 }, a = this.rng();
        return i.add(new de(
          r.x + (o.x - r.x) * a,
          r.y + (o.y - r.y) * a,
          r.z + (o.z - r.z) * a
        ));
      }
      case "cone": {
        const r = this.rng() * Math.PI * 2, o = this.rng(), a = o * (n.coneRadius ?? 50), l = o * (n.coneLength ?? 100);
        return i.add(new de(
          Math.cos(r) * a,
          l,
          Math.sin(r) * a
        ));
      }
      case "image": {
        if (!n.imageData) return i;
        const { width: r, height: o, data: a } = n.imageData, l = n.emissionThreshold ?? 0.1;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * r), d = Math.floor(this.rng() * o), h = (d * r + u) * 4;
          if (a[h + 3] / 255 > l)
            return i.add(new de(
              u - r / 2,
              -(d - o / 2),
              // Flip Y for screen coords
              0
            ));
        }
        return i;
      }
      case "depthEdge": {
        if (!n.depthData || !n.imageData) return i;
        const { width: r, height: o } = n.imageData, a = n.depthData, l = n.emissionThreshold ?? 0.05;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * (r - 2)) + 1, d = Math.floor(this.rng() * (o - 2)) + 1, h = d * r + u, m = a[h], p = a[h - 1], v = a[h + 1], _ = a[h - r], g = a[h + r], x = Math.abs(v - p), M = Math.abs(g - _);
          if (Math.sqrt(x * x + M * M) > l) {
            const b = m * 500;
            return i.add(new de(
              u - r / 2,
              -(d - o / 2),
              // Flip Y for screen coords
              b
            ));
          }
        }
        return i;
      }
      default:
        return i;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(e) {
    const n = new de(
      e.emissionDirection.x,
      e.emissionDirection.y,
      e.emissionDirection.z
    ).normalize();
    if (e.emissionSpread <= 0)
      return n;
    const i = e.emissionSpread * Math.PI / 180, r = this.rng() * Math.PI * 2, o = Math.acos(1 - this.rng() * (1 - Math.cos(i))), a = Math.abs(n.y) < 0.99 ? new de(0, 1, 0) : new de(1, 0, 0), l = new de().crossVectors(a, n).normalize(), c = new de().crossVectors(n, l);
    return new de().addScaledVector(n, Math.cos(o)).addScaledVector(l, Math.sin(o) * Math.cos(r)).addScaledVector(c, Math.sin(o) * Math.sin(r)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(e) {
    const n = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const r = i * zi, o = n[r + 6], a = n[r + 7];
      if (a <= 0 || o >= a) continue;
      let l = n[r + 0], c = n[r + 1], u = n[r + 2], d = n[r + 3], h = n[r + 4], m = n[r + 5];
      const p = n[r + 8];
      let v = 0, _ = 0, g = 0;
      for (const E of this.forceFields.values()) {
        if (!E.enabled) continue;
        const y = this.calculateForceField(E, l, c, u, d, h, m, p);
        v += y.x, _ += y.y, g += y.z;
      }
      const x = v / Math.max(p, 0.1), M = _ / Math.max(p, 0.1), S = g / Math.max(p, 0.1);
      d += x * e, h += M * e, m += S * e, l += d * e, c += h * e, u += m * e;
      const b = o / a, C = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        b
      ), T = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        b
      ), P = n[r + 10] + n[r + 11] * e;
      n[r + 0] = l, n[r + 1] = c, n[r + 2] = u, n[r + 3] = d, n[r + 4] = h, n[r + 5] = m, n[r + 6] = o + e, n[r + 9] *= C, n[r + 10] = P, n[r + 15] *= T, o + e >= a && (this.freeIndices.push(i), this.state.particleCount--, this.emit("particleDeath", { index: i }));
    }
  }
  /**
   * Update particle physics using GPU Transform Feedback
   * This runs the entire physics simulation on the GPU for maximum performance
   */
  updatePhysicsGPU(e) {
    var d;
    if (!this.gl || !this.transformFeedbackProgram) return;
    const n = this.gl;
    this.updateForceFieldTexture(), n.useProgram(this.transformFeedbackProgram);
    const i = n.getUniformLocation(this.transformFeedbackProgram, "u_deltaTime"), r = n.getUniformLocation(this.transformFeedbackProgram, "u_time"), o = n.getUniformLocation(this.transformFeedbackProgram, "u_forceFieldCount"), a = n.getUniformLocation(this.transformFeedbackProgram, "u_forceFields");
    if (n.uniform1f(i, e), n.uniform1f(r, this.state.simulationTime), n.uniform1i(o, Math.min(this.forceFields.size, Sc)), this.forceFieldTexture) {
      n.activeTexture(n.TEXTURE0);
      const h = (d = this.renderer) == null ? void 0 : d.properties.get(this.forceFieldTexture).__webglTexture;
      h && (n.bindTexture(n.TEXTURE_2D, h), n.uniform1i(a, 0));
    }
    const l = this.currentBuffer === "A" ? this.vaoA : this.vaoB, c = this.currentBuffer === "A" ? this.transformFeedbackA : this.transformFeedbackB, u = this.currentBuffer === "A" ? this.particleVboB : this.particleVboA;
    n.bindVertexArray(l), n.enable(n.RASTERIZER_DISCARD), n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, c), n.beginTransformFeedback(n.POINTS), n.drawArrays(n.POINTS, 0, this.config.maxParticles), n.endTransformFeedback(), n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, null), n.disable(n.RASTERIZER_DISCARD), n.bindVertexArray(null), this.currentBuffer = this.currentBuffer === "A" ? "B" : "A", this.state.frameCount % 10 === 0 && this.readBackParticleData(u);
  }
  /**
   * Update the force field texture with current force field data
   */
  updateForceFieldTexture() {
    var n, i, r, o, a, l, c, u, d;
    if (!this.forceFieldBuffer || !this.forceFieldTexture) return;
    let e = 0;
    for (const h of this.forceFields.values()) {
      if (e >= Sc) break;
      if (!h.enabled) continue;
      const m = e * 16;
      this.forceFieldBuffer[m + 0] = h.position.x, this.forceFieldBuffer[m + 1] = h.position.y, this.forceFieldBuffer[m + 2] = h.position.z, this.forceFieldBuffer[m + 3] = this.getForceFieldTypeIndex(h.type), this.forceFieldBuffer[m + 4] = h.strength, this.forceFieldBuffer[m + 5] = h.falloffStart, this.forceFieldBuffer[m + 6] = h.falloffEnd, this.forceFieldBuffer[m + 7] = this.getFalloffTypeIndex(h.falloffType), this.forceFieldBuffer[m + 8] = ((n = h.direction) == null ? void 0 : n.x) ?? ((i = h.vortexAxis) == null ? void 0 : i.x) ?? ((r = h.windDirection) == null ? void 0 : r.x) ?? 0, this.forceFieldBuffer[m + 9] = ((o = h.direction) == null ? void 0 : o.y) ?? ((a = h.vortexAxis) == null ? void 0 : a.y) ?? ((l = h.windDirection) == null ? void 0 : l.y) ?? 0, this.forceFieldBuffer[m + 10] = ((c = h.direction) == null ? void 0 : c.z) ?? ((u = h.vortexAxis) == null ? void 0 : u.z) ?? ((d = h.windDirection) == null ? void 0 : d.z) ?? 0, this.forceFieldBuffer[m + 11] = h.inwardForce ?? 0, this.forceFieldBuffer[m + 12] = h.noiseScale ?? h.linearDrag ?? h.gustStrength ?? 0, this.forceFieldBuffer[m + 13] = h.noiseSpeed ?? h.quadraticDrag ?? h.gustFrequency ?? 0, this.forceFieldBuffer[m + 14] = 0, this.forceFieldBuffer[m + 15] = 0, e++;
    }
    this.forceFieldTexture.needsUpdate = !0;
  }
  /**
   * Get numeric index for force field type (for GPU shader)
   */
  getForceFieldTypeIndex(e) {
    switch (e) {
      case "gravity":
        return 0;
      case "point":
        return 1;
      case "vortex":
        return 2;
      case "turbulence":
        return 3;
      case "drag":
        return 4;
      case "wind":
        return 5;
      case "curl":
        return 6;
      case "magnetic":
        return 7;
      case "lorenz":
        return 8;
      default:
        return 0;
    }
  }
  /**
   * Get numeric index for falloff type (for GPU shader)
   */
  getFalloffTypeIndex(e) {
    switch (e) {
      case "none":
        return 0;
      case "linear":
        return 1;
      case "quadratic":
        return 2;
      case "exponential":
        return 3;
      case "smoothstep":
        return 4;
      default:
        return 0;
    }
  }
  /**
   * Read back particle data from GPU to CPU for death handling
   */
  readBackParticleData(e) {
    if (!this.gl || !e) return;
    const n = this.gl, i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    n.bindBuffer(n.ARRAY_BUFFER, e), n.getBufferSubData(n.ARRAY_BUFFER, 0, i), n.bindBuffer(n.ARRAY_BUFFER, null);
    let r = 0;
    for (let o = 0; o < this.config.maxParticles; o++) {
      const a = o * zi, l = i[a + 6], c = i[a + 7];
      c > 0 && l < c ? r++ : c > 0 && l >= c && (this.freeIndices.includes(o) || (this.freeIndices.push(o), this.emit("particleDeath", { index: o })));
    }
    this.state.particleCount = r;
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(e, n, i, r, o, a, l, c) {
    var g, x, M, S, b, C, T, P, E;
    const u = new de(), d = n - e.position.x, h = i - e.position.y, m = r - e.position.z, p = Math.sqrt(d * d + h * h + m * m);
    let v = 1;
    if (p > e.falloffStart) {
      const y = Math.min((p - e.falloffStart) / (e.falloffEnd - e.falloffStart), 1);
      switch (e.falloffType) {
        case "linear":
          v = 1 - y;
          break;
        case "quadratic":
          v = 1 - y * y;
          break;
        case "exponential":
          v = Math.exp(-y * 3);
          break;
        case "smoothstep":
          v = 1 - (3 * y * y - 2 * y * y * y);
          break;
      }
    }
    const _ = e.strength * v;
    switch (e.type) {
      case "gravity":
        u.set(
          (((g = e.direction) == null ? void 0 : g.x) ?? 0) * _,
          (((x = e.direction) == null ? void 0 : x.y) ?? 1) * _,
          (((M = e.direction) == null ? void 0 : M.z) ?? 0) * _
        );
        break;
      case "point":
        if (p > 1e-3) {
          const y = new de(-d, -h, -m).normalize();
          u.copy(y).multiplyScalar(_ / c);
        }
        break;
      case "vortex":
        if (p > 1e-3) {
          const y = new de(
            ((S = e.vortexAxis) == null ? void 0 : S.x) ?? 0,
            ((b = e.vortexAxis) == null ? void 0 : b.y) ?? 0,
            ((C = e.vortexAxis) == null ? void 0 : C.z) ?? 1
          ).normalize(), w = new de(d, h, m), D = new de().crossVectors(y, w).normalize(), U = w.normalize().multiplyScalar(-(e.inwardForce ?? 0));
          u.copy(D).multiplyScalar(_).add(U);
        }
        break;
      case "turbulence": {
        const y = e.noiseScale ?? 0.01, w = e.noiseSpeed ?? 0.5, D = this.state.simulationTime * w, U = Math.sin(n * y + D) * Math.cos(i * y * 1.3) * _, R = Math.sin(i * y + D * 1.1) * Math.cos(r * y * 1.2) * _, O = Math.sin(r * y + D * 0.9) * Math.cos(n * y * 1.1) * _;
        u.set(U, R, O);
        break;
      }
      case "drag": {
        const y = Math.sqrt(o * o + a * a + l * l);
        if (y > 1e-3) {
          const w = (e.linearDrag ?? 0.1) * y + (e.quadraticDrag ?? 0.01) * y * y;
          u.set(-o, -a, -l).normalize().multiplyScalar(-w * _);
        }
        break;
      }
      case "wind": {
        const y = new de(
          ((T = e.windDirection) == null ? void 0 : T.x) ?? 1,
          ((P = e.windDirection) == null ? void 0 : P.y) ?? 0,
          ((E = e.windDirection) == null ? void 0 : E.z) ?? 0
        ).normalize(), w = Math.sin(this.state.simulationTime * (e.gustFrequency ?? 0.5)) * (e.gustStrength ?? 0);
        u.copy(y).multiplyScalar(_ + w);
        break;
      }
      case "lorenz": {
        const y = e.lorenzSigma ?? 10, w = e.lorenzRho ?? 28, D = e.lorenzBeta ?? 2.667;
        u.set(
          y * (h - d),
          d * (w - m) - h,
          d * h - D * m
        ).multiplyScalar(_ * 0.01);
        break;
      }
    }
    return u;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const r = i * zi;
      if (e[r + 7] <= 0) continue;
      const a = e[r + 0], l = e[r + 1], c = e[r + 2], u = Math.floor(a / n), d = Math.floor(l / n), h = Math.floor(c / n), m = `${u},${d},${h}`;
      this.spatialHash.has(m) || this.spatialHash.set(m, []), this.spatialHash.get(m).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(e) {
    const n = this.config.flocking;
    if (!(n != null && n.enabled)) return;
    const i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, r = this.config.spatialHashCellSize;
    for (let o = 0; o < this.config.maxParticles; o++) {
      const a = o * zi;
      if (i[a + 7] <= 0) continue;
      const c = i[a + 0], u = i[a + 1], d = i[a + 2], h = Math.floor(c / r), m = Math.floor(u / r), p = Math.floor(d / r), v = new de(), _ = new de(), g = new de();
      let x = 0, M = 0, S = 0;
      for (let T = h - 1; T <= h + 1; T++)
        for (let P = m - 1; P <= m + 1; P++)
          for (let E = p - 1; E <= p + 1; E++) {
            const y = this.spatialHash.get(`${T},${P},${E}`);
            if (y)
              for (const w of y) {
                if (w === o) continue;
                const D = w * zi, U = i[D + 0], R = i[D + 1], O = i[D + 2], A = c - U, G = u - R, ue = d - O, Q = Math.sqrt(A * A + G * G + ue * ue);
                Q < n.separationRadius && Q > 0 && (v.add(new de(A, G, ue).divideScalar(Q)), x++), Q < n.alignmentRadius && (_.add(new de(
                  i[D + 3],
                  i[D + 4],
                  i[D + 5]
                )), M++), Q < n.cohesionRadius && (g.add(new de(U, R, O)), S++);
              }
          }
      x > 0 && v.divideScalar(x).normalize().multiplyScalar(n.separationWeight), M > 0 && _.divideScalar(M).normalize().multiplyScalar(n.alignmentWeight), S > 0 && (g.divideScalar(S), g.sub(new de(c, u, d)).normalize().multiplyScalar(n.cohesionWeight));
      const b = v.add(_).add(g);
      b.length() > n.maxForce && b.normalize().multiplyScalar(n.maxForce), i[a + 3] += b.x * e, i[a + 4] += b.y * e, i[a + 5] += b.z * e;
      const C = Math.sqrt(
        i[a + 3] ** 2 + i[a + 4] ** 2 + i[a + 5] ** 2
      );
      if (C > n.maxSpeed) {
        const T = n.maxSpeed / C;
        i[a + 3] *= T, i[a + 4] *= T, i[a + 5] *= T;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const e of this.config.audioBindings) {
      const r = ((this.audioFeatures.get(e.feature) ?? 0) - e.min) / (e.max - e.min);
      let o = e.outputMin + r * (e.outputMax - e.outputMin);
      if (e.curve === "exponential" ? o = e.outputMin + Math.pow(r, 2) * (e.outputMax - e.outputMin) : e.curve === "logarithmic" && (o = e.outputMin + Math.sqrt(r) * (e.outputMax - e.outputMin)), e.target === "emitter") {
        const a = this.emitters.get(e.targetId);
        a && (a[e.parameter] = o);
      } else if (e.target === "forceField") {
        const a = this.forceFields.get(e.targetId);
        a && (a[e.parameter] = o);
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(e, n, i) {
    for (const r of this.config.audioBindings)
      if (r.target === e && r.targetId === n && r.parameter === i) {
        const a = ((this.audioFeatures.get(r.feature) ?? 0) - r.min) / (r.max - r.min);
        return r.outputMin + a * (r.outputMax - r.outputMin);
      }
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.instancedGeometry.getAttribute("i_position"), i = this.instancedGeometry.getAttribute("i_velocity"), r = this.instancedGeometry.getAttribute("i_life"), o = this.instancedGeometry.getAttribute("i_physical"), a = this.instancedGeometry.getAttribute("i_rotation"), l = this.instancedGeometry.getAttribute("i_color");
    for (let c = 0; c < this.config.maxParticles; c++) {
      const u = c * zi;
      n.setXYZ(c, e[u + 0], e[u + 1], e[u + 2]), i.setXYZ(c, e[u + 3], e[u + 4], e[u + 5]), r.setXY(c, e[u + 6], e[u + 7]), o.setXY(c, e[u + 8], e[u + 9]), a.setXY(c, e[u + 10], e[u + 11]), l.setXYZW(c, e[u + 12], e[u + 13], e[u + 14], e[u + 15]);
    }
    n.needsUpdate = !0, i.needsUpdate = !0, r.needsUpdate = !0, o.needsUpdate = !0, a.needsUpdate = !0, l.needsUpdate = !0;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(e, n) {
    this.audioFeatures.set(e, n), this.state.currentAudioFeatures.set(e, n);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1), requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(e) {
    if (e) {
      const n = this.emitters.get(e);
      if (n)
        for (let i = 0; i < n.burstCount; i++)
          this.spawnParticle(n);
    } else
      for (const n of this.emitters.values())
        if (n.burstOnBeat && n.enabled)
          for (let i = 0; i < n.burstCount; i++)
            this.spawnParticle(n);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Get vertex shader code
   */
  getVertexShader() {
    return `
      precision highp float;

      attribute vec2 position;
      attribute vec2 uv;

      attribute vec3 i_position;
      attribute vec3 i_velocity;
      attribute vec2 i_life;
      attribute vec2 i_physical;
      attribute vec2 i_rotation;
      attribute vec4 i_color;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform vec3 cameraPosition;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      void main() {
        // Skip dead particles
        if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
          gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
          return;
        }

        float size = i_physical.y;
        float rotation = i_rotation.x;
        float lifeRatio = i_life.x / i_life.y;

        // Billboard facing camera
        vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
        vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

        // Apply rotation
        float cosR = cos(rotation);
        float sinR = sin(rotation);
        vec2 rotatedPos = vec2(
          position.x * cosR - position.y * sinR,
          position.x * sinR + position.y * cosR
        );

        vec3 vertexPos = i_position
          + cameraRight * rotatedPos.x * size
          + cameraUp * rotatedPos.y * size;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);

        vUv = uv;
        vColor = i_color;
        vLifeRatio = lifeRatio;
      }
    `;
  }
  /**
   * Get fragment shader code
   */
  getFragmentShader() {
    return `
      precision highp float;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      uniform sampler2D diffuseMap;
      uniform int hasDiffuseMap;
      uniform int proceduralShape;

      float proceduralAlpha(vec2 uv, int shape) {
        vec2 centered = uv * 2.0 - 1.0;
        float dist = length(centered);

        if (shape == 1) {
          return 1.0 - smoothstep(0.8, 1.0, dist);
        } else if (shape == 2) {
          return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
        }

        return 1.0;
      }

      void main() {
        vec4 texColor = vec4(1.0);

        if (hasDiffuseMap == 1) {
          texColor = texture2D(diffuseMap, vUv);
        } else if (proceduralShape > 0) {
          float alpha = proceduralAlpha(vUv, proceduralShape);
          texColor = vec4(1.0, 1.0, 1.0, alpha);
        }

        vec4 finalColor = texColor * vColor;

        if (finalColor.a < 0.01) discard;

        gl_FragColor = finalColor;
      }
    `;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return ll;
      case "multiply":
        return Fo;
      case "screen":
        return kr;
      default:
        return Hi;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var r;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (r = this.eventHandlers.get(e)) == null || r.forEach((o) => o(i));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   */
  createSeededRandom(e) {
    let n = e;
    return () => (n = n * 1103515245 + 12345 & 2147483647, n / 2147483647);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get current configuration (emitters and force fields)
   */
  getConfig() {
    return {
      emitters: Array.from(this.emitters.values()).map((n) => {
        const { accumulator: i, velocity: r, ...o } = n;
        return o;
      }),
      forceFields: Array.from(this.forceFields.values())
    };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleBufferA.fill(0), this.particleBufferB.fill(0), this.freeIndices = [];
    for (let e = this.config.maxParticles - 1; e >= 0; e--)
      this.freeIndices.push(e);
    this.state.particleCount = 0, this.state.simulationTime = 0, this.state.frameCount = 0, this.spatialHash.clear();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    var e, n, i, r, o;
    (e = this.instancedGeometry) == null || e.dispose(), (n = this.material) == null || n.dispose(), (i = this.sizeOverLifetimeTexture) == null || i.dispose(), (r = this.opacityOverLifetimeTexture) == null || r.dispose(), (o = this.colorOverLifetimeTexture) == null || o.dispose(), this.cleanupGPUPhysics(), this.emitters.clear(), this.forceFields.clear(), this.subEmitters.clear(), this.eventHandlers.clear();
  }
}
class o8 extends qi {
  constructor(n) {
    super(n);
    /** The GPU particle system instance */
    fe(this, "particleSystem");
    /** Particle system configuration */
    fe(this, "systemConfig");
    /** Whether the system has been initialized with a renderer */
    fe(this, "initialized", !1);
    /** Stored renderer reference for reinitialization */
    fe(this, "rendererRef", null);
    /** Composition FPS for time calculation */
    fe(this, "fps", 60);
    /** Performance stats */
    fe(this, "stats", {
      particleCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0
    });
    this.systemConfig = this.buildSystemConfig(n), this.particleSystem = new ng(this.systemConfig), this.initializeBlendMode();
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(n) {
    const i = n.data, r = Wy();
    if (!i)
      return r.emitters = [tg("default")], r;
    if (i.systemConfig) {
      if (r.maxParticles = i.systemConfig.maxParticles ?? 1e5, r.timeScale = 1, i.systemConfig.gravity !== 0 && r.forceFields.push({
        id: "global_gravity",
        name: "Gravity",
        type: "gravity",
        enabled: !0,
        strength: i.systemConfig.gravity * 10,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        direction: { x: 0, y: 1, z: 0 }
      }), i.systemConfig.windStrength !== 0) {
        const o = (i.systemConfig.windDirection ?? 0) * Math.PI / 180;
        r.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: !0,
          strength: i.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(o),
            y: Math.sin(o),
            z: 0
          },
          gustStrength: i.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (i.systemConfig.friction > 0 && r.forceFields.push({
        id: "global_drag",
        name: "Friction",
        type: "drag",
        enabled: !0,
        strength: 1,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        linearDrag: i.systemConfig.friction,
        quadraticDrag: i.systemConfig.friction * 0.1
      }), i.systemConfig.turbulenceFields)
        for (const o of i.systemConfig.turbulenceFields)
          o.enabled && r.forceFields.push({
            id: o.id,
            name: "Turbulence",
            type: "turbulence",
            enabled: !0,
            strength: o.strength,
            position: { x: 0, y: 0, z: 0 },
            falloffStart: 0,
            falloffEnd: 1e4,
            falloffType: "none",
            noiseScale: o.scale,
            noiseSpeed: o.evolutionSpeed,
            noiseOctaves: 3,
            noiseLacunarity: 2,
            noiseGain: 0.5
          });
    }
    if (i.emitters)
      for (const o of i.emitters) {
        if (!o.enabled) continue;
        const a = (o.direction ?? 0) * Math.PI / 180, l = {
          id: o.id,
          name: o.name,
          enabled: !0,
          position: { x: o.x, y: o.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: o.emissionRate,
          emissionRateVariance: 0,
          burstCount: o.burstCount,
          burstInterval: 0,
          initialSpeed: o.speed,
          speedVariance: o.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: o.size,
          sizeVariance: o.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: o.particleLifetime,
          lifetimeVariance: o.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            1
          ],
          colorEnd: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(a),
            y: Math.sin(a),
            z: 0
          },
          emissionSpread: o.spread,
          burstOnBeat: o.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        r.emitters.push(l);
      }
    if (i.gravityWells)
      for (const o of i.gravityWells)
        o.enabled && r.forceFields.push({
          id: o.id,
          name: o.name,
          type: "point",
          enabled: !0,
          strength: o.strength,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: o.falloff === "linear" ? "linear" : o.falloff === "quadratic" ? "quadratic" : "none"
        });
    if (i.vortices)
      for (const o of i.vortices)
        o.enabled && r.forceFields.push({
          id: o.id,
          name: o.name,
          type: "vortex",
          enabled: !0,
          strength: o.strength * o.rotationSpeed,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: o.inwardPull
        });
    if (i.modulations) {
      const o = i.modulations.filter((l) => l.property === "size");
      if (o.length > 0) {
        const l = o[0];
        r.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
      const a = i.modulations.filter((l) => l.property === "opacity");
      if (a.length > 0) {
        const l = a[0];
        r.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
    }
    return i.renderOptions && (r.render.blendMode = i.renderOptions.blendMode ?? "normal", r.render.motionBlur = i.renderOptions.motionBlur ?? !1, r.render.motionBlurStrength = i.renderOptions.motionBlurStrength ?? 0.5, r.render.motionBlurSamples = i.renderOptions.motionBlurSamples ?? 4, i.renderOptions.renderTrails && (r.render.mode = "trail", r.render.trailLength = i.renderOptions.trailLength, r.render.trailWidthEnd = 1 - (i.renderOptions.trailOpacityFalloff ?? 0.8)), r.render.texture.proceduralType = i.renderOptions.particleShape === "star" ? "star" : i.renderOptions.particleShape === "square" ? "square" : "circle"), r;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(n) {
    if (this.initialized) return;
    this.rendererRef = n, this.particleSystem.initialize(n), this.initialized = !0;
    const i = this.particleSystem.getMesh();
    i && this.group.add(i);
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(n) {
    this.rendererRef = n, this.initialized || this.initializeWithRenderer(n);
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.fps = n;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(n) {
    const i = tg();
    return n && Object.assign(i, n), this.particleSystem.addEmitter(i), i.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(n, i) {
    this.particleSystem.updateEmitter(n, i);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(n) {
    this.particleSystem.removeEmitter(n);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(n, i) {
    const r = r8(n);
    return i && Object.assign(r, i), this.particleSystem.addForceField(r), r.id;
  }
  /**
   * Update a force field
   */
  updateForceField(n, i) {
    this.particleSystem.updateForceField(n, i);
  }
  /**
   * Remove a force field
   */
  removeForceField(n) {
    this.particleSystem.removeForceField(n);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(n, i) {
    this.particleSystem.setAudioFeature(n, i);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(n) {
    this.particleSystem.triggerBurst(n);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(n) {
    if (!this.initialized) return;
    this.particleSystem.step(n);
    const i = this.particleSystem.getState();
    this.stats.particleCount = i.particleCount, this.stats.updateTimeMs = i.updateTimeMs, this.stats.renderTimeMs = i.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleSystem.reset();
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    const i = 1 / this.fps;
    this.applyAudioReactivity(), this.step(i);
  }
  /**
   * Apply audio-reactive values to particle system emitters and force fields
   */
  applyAudioReactivity() {
    const n = this.getAudioReactiveValue("particle.emissionRate"), i = this.getAudioReactiveValue("particle.speed"), r = this.getAudioReactiveValue("particle.size"), o = this.getAudioReactiveValue("particle.gravity"), a = this.getAudioReactiveValue("particle.windStrength");
    if (n !== 0 && this.particleSystem.setAudioFeature("amplitude", n), i !== 0 || r !== 0 || n !== 0) {
      const l = this.particleSystem.getConfig().emitters;
      for (const c of l)
        i !== 0 && this.particleSystem.updateEmitter(c.id, {
          initialSpeed: c.initialSpeed * (0.5 + i)
        }), r !== 0 && this.particleSystem.updateEmitter(c.id, {
          initialSize: c.initialSize * (0.5 + r)
        });
    }
    if (o !== 0 || a !== 0) {
      const l = this.particleSystem.getConfig().forceFields;
      for (const c of l)
        c.type === "gravity" && o !== 0 && this.particleSystem.updateForceField(c.id, {
          strength: c.strength * (0.5 + o)
        }), c.type === "wind" && a !== 0 && this.particleSystem.updateForceField(c.id, {
          strength: c.strength * (0.5 + a)
        });
    }
  }
  onUpdate(n) {
    if (n.data) {
      const r = this.particleSystem.getMesh();
      r && this.group.remove(r), this.systemConfig = this.buildSystemConfig({
        ...n,
        id: this.id,
        type: "particles"
      }), this.particleSystem.dispose(), this.particleSystem = new ng(this.systemConfig), this.rendererRef && (this.initialized = !1, this.initializeWithRenderer(this.rendererRef));
    }
  }
  onDispose() {
    this.particleSystem.dispose();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}
class a8 extends qi {
  constructor(n) {
    super(n);
    // Precomp data
    fe(this, "precompData");
    // Render context (provided by LayerManager)
    fe(this, "renderContext", null);
    // Display mesh
    fe(this, "mesh", null);
    fe(this, "material", null);
    // Cached render texture
    fe(this, "renderTexture", null);
    // Animation evaluator for time remap
    fe(this, "precompEvaluator");
    // Cached composition reference
    fe(this, "cachedComposition", null);
    // Parent composition FPS for frame rate conversion
    fe(this, "parentFPS", 30);
    this.precompEvaluator = new Cl(), this.precompData = this.extractPrecompData(n), this.createMesh(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract precomp data with defaults
   */
  extractPrecompData(n) {
    const i = n.data;
    return {
      compositionId: (i == null ? void 0 : i.compositionId) ?? "",
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      collapseTransformations: (i == null ? void 0 : i.collapseTransformations) ?? !1,
      overrideFrameRate: (i == null ? void 0 : i.overrideFrameRate) ?? !1,
      frameRate: i == null ? void 0 : i.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const n = new un(1, 1);
    this.material = new Tn({
      color: 4473924,
      transparent: !0,
      side: vn
    }), this.mesh = new Ze(n, this.material), this.mesh.name = `precomp_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for precomp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(n) {
    this.renderContext = n, this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(n) {
    this.parentFPS = n;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    !this.renderContext || !this.precompData.compositionId || (this.cachedComposition = this.renderContext.getComposition(
      this.precompData.compositionId
    ), this.cachedComposition && this.resizeMesh(
      this.cachedComposition.settings.width,
      this.cachedComposition.settings.height
    ));
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new un(n, i));
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(n) {
    if (!this.cachedComposition) return 0;
    if (this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      const i = this.precompData.timeRemap.animated ? this.precompEvaluator.evaluate(this.precompData.timeRemap, n) : this.precompData.timeRemap.value, r = this.precompData.overrideFrameRate && this.precompData.frameRate ? this.precompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(i * r);
    }
    if (this.precompData.overrideFrameRate && this.precompData.frameRate) {
      const i = this.parentFPS, r = this.precompData.frameRate;
      return Math.floor(n * (r / i));
    }
    return n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    if (!this.renderContext || !this.cachedComposition)
      return;
    const i = this.calculateNestedFrame(n), r = Math.max(
      0,
      Math.min(i, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.precompData.compositionId,
      r
    ), this.material && (this.renderTexture ? (this.material.map = this.renderTexture, this.material.color.setHex(16777215)) : (this.material.map = null, this.material.color.setHex(4473924)), this.material.needsUpdate = !0);
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(n) {
    this.precompData.compositionId = n, this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(n) {
    this.precompData.timeRemapEnabled = n;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(n) {
    this.precompData.timeRemap = n;
  }
  /**
   * Enable/disable collapse transformations
   */
  setCollapseTransformations(n) {
    this.precompData.collapseTransformations = n;
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(n, i) {
    this.precompData.overrideFrameRate = n, this.precompData.frameRate = i;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.compositionId !== void 0 && this.setComposition(i.compositionId), i.timeRemapEnabled !== void 0 && this.setTimeRemapEnabled(i.timeRemapEnabled), i.timeRemap !== void 0 && this.setTimeRemap(i.timeRemap), i.collapseTransformations !== void 0 && this.setCollapseTransformations(i.collapseTransformations), (i.overrideFrameRate !== void 0 || i.frameRate !== void 0) && this.setFrameRateOverride(
      i.overrideFrameRate ?? this.precompData.overrideFrameRate,
      i.frameRate ?? this.precompData.frameRate
    ));
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get precomp data
   */
  getPrecompData() {
    return { ...this.precompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.precompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh)), this.renderTexture = null, this.cachedComposition = null;
  }
}
class l8 extends qi {
  constructor(n) {
    super(n);
    // Camera data reference
    fe(this, "cameraData");
    // Callbacks to store
    fe(this, "cameraGetter");
    fe(this, "cameraAtFrameGetter");
    fe(this, "cameraUpdater");
    // Track current frame for interpolation
    fe(this, "currentFrame", 0);
    // Visual wireframe (shown in editor)
    fe(this, "wireframe", null);
    fe(this, "wireframeVisible", !0);
    // Frustum visualization
    fe(this, "frustumHelper", null);
    fe(this, "showFrustum", !0);
    // Track last camera state for frustum updates
    fe(this, "lastFrustumState", null);
    this.threeD = !0, this.cameraData = this.extractCameraData(n), this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(n) {
    const i = n.data;
    return {
      cameraId: (i == null ? void 0 : i.cameraId) ?? "",
      isActiveCamera: (i == null ? void 0 : i.isActiveCamera) ?? !1
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(n, i, r) {
    this.cameraGetter = n, this.cameraUpdater = i, this.cameraAtFrameGetter = r;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Ai(), this.wireframe.name = `camera_wireframe_${this.id}`;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200, i = 40, r = new pn(i, i * 0.6, i * 0.8), o = new Tn({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), a = new Ze(r, o);
    this.wireframe.add(a);
    const l = new $f(i * 0.3, i * 0.6, 8), c = new Tn({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.6,
      depthTest: !1
    }), u = new Ze(l, c);
    u.rotation.x = Math.PI / 2, u.position.z = i * 0.7, this.wireframe.add(u);
    const d = new un(i * 0.8, i * 0.5), h = new Tn({
      color: n,
      transparent: !0,
      opacity: 0.2,
      side: vn,
      depthTest: !1
    }), m = new Ze(d, h);
    m.position.z = -i * 0.4, this.wireframe.add(m);
    const p = [
      new de(0, i * 0.4, 0),
      new de(0, i * 0.7, 0),
      new de(-i * 0.1, i * 0.55, 0),
      new de(0, i * 0.7, 0),
      new de(i * 0.1, i * 0.55, 0)
    ], v = new Vt().setFromPoints(p), _ = new Yi({
      color: 65280,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), g = new ln(v, _);
    this.wireframe.add(g), this.group.add(this.wireframe), this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const n = this.getCamera();
    if (!n) return;
    this.frustumHelper = new Ai(), this.frustumHelper.name = `camera_frustum_${this.id}`;
    const i = this.cameraData.isActiveCamera ? 43775 : 16755200, r = n.nearClip, o = Math.min(n.farClip, 2e3), a = n.angleOfView * (Math.PI / 180), l = 16 / 9, c = 2 * Math.tan(a / 2) * r, u = c * l, d = 2 * Math.tan(a / 2) * o, h = d * l, m = new Yi({
      color: i,
      transparent: !0,
      opacity: 0.3,
      depthTest: !1
    }), p = new de(-u / 2, c / 2, r), v = new de(u / 2, c / 2, r), _ = new de(-u / 2, -c / 2, r), g = new de(u / 2, -c / 2, r), x = new de(-h / 2, d / 2, o), M = new de(h / 2, d / 2, o), S = new de(-h / 2, -d / 2, o), b = new de(h / 2, -d / 2, o), C = new Vt().setFromPoints([
      p,
      v,
      g,
      _,
      p
    ]);
    this.frustumHelper.add(new ln(C, m));
    const T = new Vt().setFromPoints([
      x,
      M,
      b,
      S,
      x
    ]);
    this.frustumHelper.add(new ln(T, m));
    const P = [
      [p, x],
      [v, M],
      [_, S],
      [g, b]
    ];
    for (const [E, y] of P) {
      const w = new Vt().setFromPoints([E, y]);
      this.frustumHelper.add(new ln(w, m));
    }
    this.group.add(this.frustumHelper), this.frustumHelper.renderOrder = 997, this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((i) => {
      if (i instanceof Ze || i instanceof ln) {
        const r = i.material;
        if (r.color.getHex() === 65280) return;
        r.color.setHex(n);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    return !this.cameraGetter || !this.cameraData.cameraId ? null : this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    return this.cameraData.cameraId ? this.cameraAtFrameGetter ? this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame) : this.getCamera() : null;
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(n) {
    this.cameraData.isActiveCamera = n, this.updateWireframeColor(), this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum(), this.createFrustum());
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(n) {
    this.wireframeVisible = n, this.wireframe && (this.wireframe.visible = n);
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(n) {
    this.showFrustum = n, this.frustumHelper && (this.frustumHelper.visible = n);
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    this.currentFrame = n;
    const i = this.getCameraAtCurrentFrame();
    if (!i) return;
    this.group.position.set(
      i.position.x,
      i.position.y,
      i.position.z
    );
    const r = Math.PI / 180;
    if (i.type === "two-node" && i.pointOfInterest) {
      const l = new de(
        i.pointOfInterest.x,
        i.pointOfInterest.y,
        i.pointOfInterest.z
      );
      this.group.lookAt(l), this.group.rotation.z += i.zRotation * r;
    } else
      this.group.rotation.set(
        (i.orientation.x + i.xRotation) * r,
        (i.orientation.y + i.yRotation) * r,
        (i.orientation.z + i.zRotation) * r,
        "YXZ"
        // Standard After Effects rotation order
      );
    const o = {
      fov: i.angleOfView,
      near: i.nearClip,
      far: i.farClip
    };
    (!this.lastFrustumState || this.lastFrustumState.fov !== o.fov || this.lastFrustumState.near !== o.near || this.lastFrustumState.far !== o.far) && (this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum(), this.lastFrustumState = o);
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.cameraId !== void 0 && (this.cameraData.cameraId = i.cameraId, this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum()), i.isActiveCamera !== void 0 && this.setActiveCamera(i.isActiveCamera));
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const n = this.getCameraAtCurrentFrame();
    return n ? {
      position: { ...n.position },
      rotation: {
        x: n.orientation.x + n.xRotation,
        y: n.orientation.y + n.yRotation,
        z: n.orientation.z + n.zRotation
      },
      fov: n.angleOfView,
      focalLength: n.focalLength,
      nearClip: n.nearClip,
      farClip: n.farClip
    } : null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    this.wireframe && (this.wireframe.traverse((n) => {
      (n instanceof Ze || n instanceof ln) && (n.geometry.dispose(), n.material.dispose());
    }), this.wireframe.clear(), this.wireframe = null);
  }
  disposeFrustum() {
    this.frustumHelper && (this.frustumHelper.traverse((n) => {
      n instanceof ln && (n.geometry.dispose(), n.material.dispose());
    }), this.frustumHelper.clear(), this.frustumHelper = null);
  }
  onDispose() {
    this.disposeWireframe(), this.disposeFrustum();
  }
}
class c8 extends qi {
  constructor(n) {
    super(n);
    fe(this, "light");
    fe(this, "helper", null);
    fe(this, "lightData");
    this.lightData = this.extractLightData(n), this.light = this.createLight(), this.group.add(this.light), this.createHelper(), this.initializeBlendMode();
  }
  /**
   * Extract light data from layer object
   */
  extractLightData(n) {
    const i = n.data;
    return {
      lightType: (i == null ? void 0 : i.lightType) ?? "point",
      color: (i == null ? void 0 : i.color) ?? "#ffffff",
      intensity: (i == null ? void 0 : i.intensity) ?? 100,
      radius: (i == null ? void 0 : i.radius) ?? 500,
      falloff: (i == null ? void 0 : i.falloff) ?? "none",
      falloffDistance: (i == null ? void 0 : i.falloffDistance) ?? 500,
      castShadows: (i == null ? void 0 : i.castShadows) ?? !1,
      shadowDarkness: (i == null ? void 0 : i.shadowDarkness) ?? 100,
      shadowDiffusion: (i == null ? void 0 : i.shadowDiffusion) ?? 0,
      coneAngle: (i == null ? void 0 : i.coneAngle) ?? 90,
      coneFeather: (i == null ? void 0 : i.coneFeather) ?? 50,
      animatedIntensity: i == null ? void 0 : i.animatedIntensity,
      animatedConeAngle: i == null ? void 0 : i.animatedConeAngle,
      animatedColor: i == null ? void 0 : i.animatedColor
    };
  }
  /**
   * Create the Three.js light based on type
   */
  createLight() {
    const n = new Mt(this.lightData.color), i = this.lightData.intensity / 100;
    switch (this.lightData.lightType) {
      case "point": {
        const r = new xa(n, i);
        return r.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, r.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, this.configureShadows(r), r;
      }
      case "spot": {
        const r = new js(n, i);
        return r.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, r.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, r.angle = mn.degToRad((this.lightData.coneAngle ?? 90) / 2), r.penumbra = (this.lightData.coneFeather ?? 50) / 100, this.configureShadows(r), r;
      }
      case "parallel": {
        const r = new Po(n, i);
        return this.configureShadows(r), r;
      }
      case "ambient":
        return new Sy(n, i);
      default:
        return Ei.warn(`LightLayer: Unknown light type: ${this.lightData.lightType}, defaulting to point`), new xa(n, i);
    }
  }
  /**
   * Configure shadow settings for shadow-capable lights
   */
  configureShadows(n) {
    n.castShadow = this.lightData.castShadows, n.castShadow && (n.shadow.mapSize.width = 1024, n.shadow.mapSize.height = 1024, n.shadow.bias = -1e-4 * (100 - this.lightData.shadowDarkness) / 100, n.shadow.radius = 1 + this.lightData.shadowDiffusion / 10, (n instanceof js || n instanceof Po) && (n.shadow.camera.near = 1, n.shadow.camera.far = this.lightData.falloffDistance * 2));
  }
  /**
   * Create helper visualization for the editor
   */
  createHelper() {
    switch (this.helper && (this.group.remove(this.helper), this.helper.dispose && this.helper.dispose()), this.lightData.lightType) {
      case "point": {
        const n = new vv(this.light, this.lightData.radius / 10);
        this.helper = n, this.group.add(n);
        break;
      }
      case "spot": {
        const n = new dc(this.light);
        this.helper = n, this.group.add(n);
        break;
      }
      case "parallel": {
        const n = new xv(this.light, 50);
        this.helper = n, this.group.add(n);
        break;
      }
    }
  }
  /**
   * Update light type (requires recreating the light)
   */
  setLightType(n) {
    n !== this.lightData.lightType && (this.lightData.lightType = n, this.group.remove(this.light), this.light.dispose && this.light.dispose(), this.light = this.createLight(), this.group.add(this.light), this.createHelper());
  }
  /**
   * Set light color
   */
  setColor(n) {
    this.lightData.color = n, this.light.color.set(n);
  }
  /**
   * Set light intensity
   */
  setIntensity(n) {
    this.lightData.intensity = n, this.light.intensity = n / 100;
  }
  /**
   * Set falloff distance
   */
  setFalloffDistance(n) {
    this.lightData.falloffDistance = n, (this.light instanceof xa || this.light instanceof js) && (this.light.distance = this.lightData.falloff === "none" ? 0 : n);
  }
  /**
   * Set cone angle (spot lights only)
   */
  setConeAngle(n) {
    this.light instanceof js && (this.lightData.coneAngle = n, this.light.angle = mn.degToRad(n / 2), this.helper instanceof dc && this.helper.update());
  }
  /**
   * Set cone feather (spot lights only)
   */
  setConeFeather(n) {
    this.light instanceof js && (this.lightData.coneFeather = n, this.light.penumbra = n / 100);
  }
  /**
   * Toggle shadow casting
   */
  setCastShadows(n) {
    this.lightData.castShadows = n, (this.light instanceof xa || this.light instanceof js || this.light instanceof Po) && (this.light.castShadow = n);
  }
  /**
   * Get the underlying Three.js light
   */
  getLight() {
    return this.light;
  }
  /**
   * Get light data
   */
  getLightData() {
    return { ...this.lightData };
  }
  /**
   * Show/hide editor helper
   */
  setHelperVisible(n) {
    this.helper && (this.helper.visible = n);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    var i, r, o;
    if ((i = this.lightData.animatedIntensity) != null && i.animated) {
      const a = this.evaluator.evaluate(this.lightData.animatedIntensity, n);
      this.light.intensity = a / 100;
    }
    if ((r = this.lightData.animatedConeAngle) != null && r.animated && this.light instanceof js) {
      const a = this.evaluator.evaluate(this.lightData.animatedConeAngle, n);
      this.light.angle = mn.degToRad(a / 2), this.helper instanceof dc && this.helper.update();
    }
    if ((o = this.lightData.animatedColor) != null && o.animated) {
      const a = this.evaluator.evaluate(this.lightData.animatedColor, n);
      this.light.color.set(a), this.helper && (this.helper instanceof vv ? this.helper.update() : this.helper instanceof dc ? this.helper.update() : this.helper instanceof xv && this.helper.update());
    }
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.lightType !== void 0 && i.lightType !== this.lightData.lightType && this.setLightType(i.lightType), i.color !== void 0 && this.setColor(i.color), i.intensity !== void 0 && this.setIntensity(i.intensity), i.falloffDistance !== void 0 && this.setFalloffDistance(i.falloffDistance), i.falloff !== void 0 && (this.lightData.falloff = i.falloff, this.setFalloffDistance(this.lightData.falloffDistance)), i.coneAngle !== void 0 && this.setConeAngle(i.coneAngle), i.coneFeather !== void 0 && this.setConeFeather(i.coneFeather), i.castShadows !== void 0 && this.setCastShadows(i.castShadows), (i.shadowDarkness !== void 0 || i.shadowDiffusion !== void 0) && (this.lightData.shadowDarkness = i.shadowDarkness ?? this.lightData.shadowDarkness, this.lightData.shadowDiffusion = i.shadowDiffusion ?? this.lightData.shadowDiffusion, (this.light instanceof xa || this.light instanceof js || this.light instanceof Po) && this.configureShadows(this.light)), i.animatedIntensity !== void 0 && (this.lightData.animatedIntensity = i.animatedIntensity), i.animatedConeAngle !== void 0 && (this.lightData.animatedConeAngle = i.animatedConeAngle), i.animatedColor !== void 0 && (this.lightData.animatedColor = i.animatedColor));
  }
  onDispose() {
    this.light.dispose && this.light.dispose(), this.helper && this.helper.dispose && this.helper.dispose();
  }
}
const u8 = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, d8 = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class h8 extends qi {
  constructor(n, i) {
    super(n);
    fe(this, "resources");
    // Textures
    fe(this, "sourceTexture", null);
    fe(this, "depthTexture", null);
    // Mesh and material
    fe(this, "mesh");
    fe(this, "geometry");
    fe(this, "material");
    // Layer data
    fe(this, "depthflowData");
    // Dimensions
    fe(this, "width", 1920);
    fe(this, "height", 1080);
    // Animation state
    fe(this, "animationTime", 0);
    this.resources = i, this.depthflowData = this.extractDepthflowData(n), this.geometry = new un(this.width, this.height), this.material = new zn({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new rt(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: u8,
      fragmentShader: d8,
      transparent: !0,
      side: vn,
      depthWrite: !1
    }), this.mesh = new Ze(this.geometry, this.material), this.mesh.name = `depthflow_${this.id}`, this.group.add(this.mesh), this.loadTextures(), this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(n) {
    var r, o, a, l, c, u, d, h, m, p, v, _, g, x;
    const i = n.data;
    return {
      sourceLayerId: (i == null ? void 0 : i.sourceLayerId) ?? "",
      depthLayerId: (i == null ? void 0 : i.depthLayerId) ?? "",
      config: {
        preset: ((r = i == null ? void 0 : i.config) == null ? void 0 : r.preset) ?? "static",
        zoom: ((o = i == null ? void 0 : i.config) == null ? void 0 : o.zoom) ?? 1,
        offsetX: ((a = i == null ? void 0 : i.config) == null ? void 0 : a.offsetX) ?? 0,
        offsetY: ((l = i == null ? void 0 : i.config) == null ? void 0 : l.offsetY) ?? 0,
        rotation: ((c = i == null ? void 0 : i.config) == null ? void 0 : c.rotation) ?? 0,
        depthScale: ((u = i == null ? void 0 : i.config) == null ? void 0 : u.depthScale) ?? 0.1,
        focusDepth: ((d = i == null ? void 0 : i.config) == null ? void 0 : d.focusDepth) ?? 0.5,
        dollyZoom: ((h = i == null ? void 0 : i.config) == null ? void 0 : h.dollyZoom) ?? 0,
        orbitRadius: ((m = i == null ? void 0 : i.config) == null ? void 0 : m.orbitRadius) ?? 0.1,
        orbitSpeed: ((p = i == null ? void 0 : i.config) == null ? void 0 : p.orbitSpeed) ?? 1,
        swingAmplitude: ((v = i == null ? void 0 : i.config) == null ? void 0 : v.swingAmplitude) ?? 0.05,
        swingFrequency: ((_ = i == null ? void 0 : i.config) == null ? void 0 : _.swingFrequency) ?? 1,
        edgeDilation: ((g = i == null ? void 0 : i.config) == null ? void 0 : g.edgeDilation) ?? 0,
        inpaintEdges: ((x = i == null ? void 0 : i.config) == null ? void 0 : x.inpaintEdges) ?? !1
      },
      animatedZoom: i == null ? void 0 : i.animatedZoom,
      animatedOffsetX: i == null ? void 0 : i.animatedOffsetX,
      animatedOffsetY: i == null ? void 0 : i.animatedOffsetY,
      animatedRotation: i == null ? void 0 : i.animatedRotation,
      animatedDepthScale: i == null ? void 0 : i.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      n && (this.sourceTexture = n, this.material.uniforms.sourceTexture.value = n, n.image && this.setDimensions(n.image.width, n.image.height));
    }
    if (this.depthflowData.depthLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      n && (this.depthTexture = n, this.material.uniforms.depthTexture.value = n);
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(n) {
    const i = this.resources.getLayerTexture(n);
    return i || (Ei.warn(`DepthflowLayer: Could not load texture for layer ${n}`), null);
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new un(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Set source layer
   */
  async setSourceLayer(n) {
    var r;
    this.depthflowData.sourceLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((r = this.sourceTexture) == null || r.dispose(), this.sourceTexture = i, this.material.uniforms.sourceTexture.value = i);
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(n) {
    var r;
    this.depthflowData.depthLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((r = this.depthTexture) == null || r.dispose(), this.depthTexture = i, this.material.uniforms.depthTexture.value = i);
  }
  /**
   * Update config values
   */
  updateConfig(n) {
    Object.assign(this.depthflowData.config, n), n.depthScale !== void 0 && (this.material.uniforms.depthScale.value = n.depthScale), n.focusDepth !== void 0 && (this.material.uniforms.focusDepth.value = n.focusDepth), n.zoom !== void 0 && (this.material.uniforms.zoom.value = n.zoom), n.rotation !== void 0 && (this.material.uniforms.rotation.value = mn.degToRad(n.rotation)), n.edgeDilation !== void 0 && (this.material.uniforms.edgeDilation.value = n.edgeDilation);
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(n, i = 30) {
    const r = this.depthflowData.config, o = this.outPoint - this.inPoint, a = o > 0 ? (n - this.inPoint) / o : 0, l = n / i;
    let c = r.zoom, u = r.offsetX, d = r.offsetY, h = r.rotation;
    switch (r.preset) {
      case "static":
        break;
      case "zoom_in":
        c = 1 + a * 0.5;
        break;
      case "zoom_out":
        c = 1.5 - a * 0.5;
        break;
      case "dolly_zoom_in":
        c = 1 + a * 0.5, this.material.uniforms.depthScale.value = r.depthScale * (1 + r.dollyZoom * a);
        break;
      case "dolly_zoom_out":
        c = 1.5 - a * 0.5, this.material.uniforms.depthScale.value = r.depthScale * (1 + r.dollyZoom * (1 - a));
        break;
      case "pan_left":
        u = a * 0.2;
        break;
      case "pan_right":
        u = -a * 0.2;
        break;
      case "pan_up":
        d = a * 0.2;
        break;
      case "pan_down":
        d = -a * 0.2;
        break;
      case "circle_cw":
        u = Math.sin(a * Math.PI * 2) * r.orbitRadius, d = Math.cos(a * Math.PI * 2) * r.orbitRadius;
        break;
      case "circle_ccw":
        u = -Math.sin(a * Math.PI * 2) * r.orbitRadius, d = Math.cos(a * Math.PI * 2) * r.orbitRadius;
        break;
      case "horizontal_swing":
        u = Math.sin(l * r.swingFrequency * Math.PI * 2) * r.swingAmplitude;
        break;
      case "vertical_swing":
        d = Math.sin(l * r.swingFrequency * Math.PI * 2) * r.swingAmplitude;
        break;
    }
    return { zoom: c, offsetX: u, offsetY: d, rotation: h };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.depthflowData.config;
    const i = this.calculatePresetValues(n);
    let r = i.zoom, o = i.offsetX, a = i.offsetY, l = i.rotation;
    this.depthflowData.animatedZoom && (r = this.evaluator.evaluate(this.depthflowData.animatedZoom, n)), this.depthflowData.animatedOffsetX && (o = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, n)), this.depthflowData.animatedOffsetY && (a = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, n)), this.depthflowData.animatedRotation && (l = this.evaluator.evaluate(this.depthflowData.animatedRotation, n)), this.depthflowData.animatedDepthScale && (this.material.uniforms.depthScale.value = this.evaluator.evaluate(
      this.depthflowData.animatedDepthScale,
      n
    )), r = this.getDrivenOrBase("depthflow.zoom", r), o = this.getDrivenOrBase("depthflow.offsetX", o), a = this.getDrivenOrBase("depthflow.offsetY", a), l = this.getDrivenOrBase("depthflow.rotation", l), this.material.uniforms.zoom.value = r, this.material.uniforms.offset.value.set(o, a), this.material.uniforms.rotation.value = mn.degToRad(l), this.material.uniforms.time.value = n / 30, this.material.needsUpdate = !0;
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.sourceLayerId !== void 0 && i.sourceLayerId !== this.depthflowData.sourceLayerId && this.setSourceLayer(i.sourceLayerId), i.depthLayerId !== void 0 && i.depthLayerId !== this.depthflowData.depthLayerId && this.setDepthLayer(i.depthLayerId), i.config && this.updateConfig(i.config), i.animatedZoom !== void 0 && (this.depthflowData.animatedZoom = i.animatedZoom), i.animatedOffsetX !== void 0 && (this.depthflowData.animatedOffsetX = i.animatedOffsetX), i.animatedOffsetY !== void 0 && (this.depthflowData.animatedOffsetY = i.animatedOffsetY), i.animatedRotation !== void 0 && (this.depthflowData.animatedRotation = i.animatedRotation), i.animatedDepthScale !== void 0 && (this.depthflowData.animatedDepthScale = i.animatedDepthScale));
  }
  onDispose() {
    var n, i;
    (n = this.sourceTexture) == null || n.dispose(), (i = this.depthTexture) == null || i.dispose(), this.geometry.dispose(), this.material.dispose();
  }
}
class f8 {
  constructor(e, n) {
    fe(this, "scene");
    fe(this, "resources");
    fe(this, "layers");
    // Callbacks
    fe(this, "onVideoMetadataLoaded");
    fe(this, "precompRenderContext", null);
    fe(this, "cameraGetter");
    fe(this, "cameraAtFrameGetter");
    fe(this, "cameraUpdater");
    // Renderer reference for particle systems
    fe(this, "rendererRef", null);
    // Composition FPS for particle timing
    fe(this, "compositionFPS", 60);
    // Camera reference for particles
    fe(this, "cameraRef", null);
    // Audio reactive callback
    fe(this, "audioReactiveGetter", null);
    this.scene = e, this.resources = n, this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(e) {
    this.onVideoMetadataLoaded = e;
  }
  /**
   * Set the precomp render context
   * This allows precomp layers to render nested compositions
   */
  setPrecompRenderContext(e) {
    this.precompRenderContext = e;
    for (const n of this.layers.values())
      n.type === "precomp" && n.setRenderContext(e);
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(e, n, i) {
    this.cameraGetter = e, this.cameraUpdater = n, this.cameraAtFrameGetter = i;
    for (const r of this.layers.values())
      r.type === "camera" && r.setCameraCallbacks(e, n, i);
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(e) {
    this.rendererRef = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setRenderer(e);
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(e) {
    this.compositionFPS = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setFPS(e), n.type === "video" && n.setFPS(e), n.type === "precomp" && n.setFPS(e);
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(e) {
    this.cameraRef = e;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(e) {
    if (this.layers.has(e.id))
      return Ei.warn(`LayerManager: Layer ${e.id} already exists, updating instead`), this.update(e.id, e), this.layers.get(e.id);
    const n = this.createLayerInstance(e);
    if (this.layers.set(e.id, n), this.setupLayerCallbacks(n, e), e.parentId) {
      const i = this.layers.get(e.parentId);
      i && n.setParent(i);
    }
    return n.hasParent() || this.scene.addToComposition(n.getObject()), n;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(e, n) {
    if (e.type === "video" && this.onVideoMetadataLoaded && e.setMetadataCallback((r) => {
      this.onVideoMetadataLoaded(n.id, r);
    }), e.type === "precomp" && this.precompRenderContext && e.setRenderContext(this.precompRenderContext), e.type === "camera" && this.cameraGetter && this.cameraUpdater && e.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter), e.type === "particles") {
      const i = e;
      this.rendererRef && i.setRenderer(this.rendererRef), i.setFPS(this.compositionFPS);
    }
    e.type === "video" && e.setFPS(this.compositionFPS), e.type === "precomp" && e.setFPS(this.compositionFPS);
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(e) {
    switch (e.type) {
      case "image":
        return new nN(e, this.resources);
      case "solid":
        return new iN(e);
      case "null":
        return new Nv(e);
      case "text":
        return new t8(e, this.resources);
      case "spline":
        return new n8(e);
      case "particles":
        return new o8(e);
      case "video":
        return new GT(e, this.resources);
      case "precomp":
        return new a8(e);
      case "camera":
        return new l8(e);
      case "light":
        return new c8(e);
      case "depthflow":
        return new h8(e, this.resources);
      default:
        return Ei.warn(`LayerManager: Unknown layer type: ${e.type}, creating NullLayer`), new Nv(e);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(e, n) {
    const i = this.layers.get(e);
    if (!i) {
      Ei.warn(`LayerManager: Layer ${e} not found for update`);
      return;
    }
    i.update(n);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(e) {
    for (const { id: n, properties: i } of e)
      this.update(n, i);
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(e) {
    const n = this.layers.get(e);
    if (!n) {
      Ei.warn(`LayerManager: Layer ${e} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(n.getObject()), n.dispose(), this.layers.delete(e);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(e) {
    for (const n of e)
      this.remove(n);
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [e, n] of this.layers)
      this.scene.removeFromComposition(n.getObject()), n.dispose();
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all layers at a given frame
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(e, n) {
    this.updateTextPathConnections();
    const i = n ?? this.audioReactiveGetter;
    for (const r of this.layers.values()) {
      if (i) {
        const o = i(r.id, e);
        o.size > 0 && r.setAudioReactiveValues(o);
      }
      r.evaluateFrame(e);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    const i = this.layers.get(e);
    i && i.setDrivenValues(n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    const n = this.layers.get(e);
    n && n.clearDrivenValues();
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const e of this.layers.values())
      e.clearDrivenValues();
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   */
  updateTextPathConnections() {
    for (const e of this.layers.values())
      if (e.type === "text") {
        const n = e, i = n.getTextData();
        if (i.pathLayerId) {
          const r = this.layers.get(i.pathLayerId);
          if (r && r.type === "spline") {
            const o = r.getCurve();
            o && n.setPathFromCurve(o);
          }
        }
      }
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(e, n) {
    const i = this.layers.get(e);
    if (!i || i.type !== "text") {
      Ei.warn(`LayerManager: Text layer ${e} not found`);
      return;
    }
    if (!n) {
      i.clearPath();
      return;
    }
    const r = this.layers.get(n);
    if (!r || r.type !== "spline") {
      Ei.warn(`LayerManager: Spline layer ${n} not found`);
      return;
    }
    const o = r.getCurve();
    o && i.setPathFromCurve(o);
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(e) {
    var n;
    return ((n = this.layers.get(e)) == null ? void 0 : n.getObject()) ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(e) {
    return this.layers.get(e) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(e) {
    return Array.from(this.layers.values()).filter(
      (n) => n.type === e
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(e) {
    return this.layers.has(e);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const e of this.layers.values())
      if (e.hasParent()) {
        const n = e.getParent();
        n && n.getObject().remove(e.getObject());
      }
    for (const e of this.layers.values()) {
      const n = e.getParentId();
      if (n) {
        const i = this.layers.get(n);
        i ? e.setParent(i) : (e.setParent(null), this.scene.addToComposition(e.getObject()));
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(e, n) {
    const i = this.layers.get(e);
    if (i) {
      if (i.hasParent()) {
        const r = i.getParent();
        r && r.getObject().remove(i.getObject());
      } else
        this.scene.removeFromComposition(i.getObject());
      if (n) {
        const r = this.layers.get(n);
        r ? i.setParent(r) : (i.setParent(null), this.scene.addToComposition(i.getObject()));
      } else
        i.setParent(null), this.scene.addToComposition(i.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(e, n) {
    const i = this.layers.get(e);
    i && (i.getObject().position.z = n, this.scene.sortByZ());
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(e, n) {
    const i = this.layers.get(e);
    i && i.setVisible(n);
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(e) {
    const n = this.layers.get(e);
    if (n) {
      const i = !n.getObject().visible;
      return n.setVisible(i), i;
    }
    return !1;
  }
  /**
   * Solo a layer (hide all others)
   */
  soloLayer(e) {
    for (const [n, i] of this.layers)
      i.setVisible(n === e);
  }
  /**
   * Unsolo all layers (show all)
   */
  unsoloAll() {
    for (const e of this.layers.values())
      e.setVisible(!0);
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(e, n, i) {
    const r = new qf(), o = new rt(e, n);
    r.setFromCamera(o, i);
    const a = this.scene.raycastComposition(r), l = /* @__PURE__ */ new Set();
    for (const c of a) {
      let u = c.object;
      for (; u; ) {
        if (u.userData.layerId) {
          l.add(u.userData.layerId);
          break;
        }
        u = u.parent;
      }
    }
    return Array.from(l).map((c) => this.layers.get(c)).filter((c) => c !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const e of this.layers.values())
      this.scene.removeFromComposition(e.getObject()), e.dispose();
    this.layers.clear();
  }
}
class p8 {
  constructor(e, n) {
    /** The main camera */
    fe(this, "camera");
    /** Keyframe evaluator for animations */
    fe(this, "evaluator");
    /** Composition dimensions */
    fe(this, "width");
    fe(this, "height");
    /** Animation properties */
    fe(this, "positionProp");
    fe(this, "targetProp");
    fe(this, "fovProp");
    /** Current target position (for lookAt) */
    fe(this, "target");
    // ============================================================================
    // VIEWPORT ZOOM/PAN
    // ============================================================================
    /** Pan offset for viewport navigation */
    fe(this, "panOffset", new rt(0, 0));
    fe(this, "zoomLevel", 1);
    this.width = e, this.height = n, this.evaluator = new Cl(), this.camera = new di(
      50,
      // Field of view
      e / n,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const i = mn.degToRad(this.camera.fov), r = n / 2 / Math.tan(i / 2);
    this.camera.position.set(e / 2, -n / 2, r), this.target = new de(e / 2, -n / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(e, n, i) {
    this.camera.position.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(e, n, i) {
    this.target.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(e, n, i) {
    this.camera.rotation.set(
      mn.degToRad(e),
      mn.degToRad(n),
      mn.degToRad(i)
    ), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(e) {
    this.camera.fov = mn.clamp(e, 1, 179), this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(e, n) {
    this.camera.near = Math.max(1e-3, e), this.camera.far = Math.max(this.camera.near + 1, n), this.camera.updateProjectionMatrix();
  }
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(e) {
    this.zoomLevel = Math.max(0.1, Math.min(10, e)), this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation
   */
  setPan(e, n) {
    this.panOffset.set(e, n), this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   */
  updateCameraForViewport() {
    const e = mn.degToRad(this.camera.fov), i = this.height / 2 / Math.tan(e / 2) / this.zoomLevel, r = this.width / 2 - this.panOffset.x / this.zoomLevel, o = this.height / 2 - this.panOffset.y / this.zoomLevel;
    this.camera.position.set(r, -o, i), this.target.set(r, -o, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(e) {
    this.positionProp = e.position, this.targetProp = e.target, this.fovProp = e.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0, this.targetProp = void 0, this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(e) {
    if (this.positionProp) {
      const n = this.evaluator.evaluate(this.positionProp, e);
      this.setPosition(n.x, n.y, n.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const n = this.evaluator.evaluate(this.targetProp, e);
      this.setTarget(n.x, n.y, n.z ?? 0);
    }
    if (this.fovProp) {
      const n = this.evaluator.evaluate(this.fovProp, e);
      this.setFOV(n);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new viewport dimensions
   */
  resize(e, n) {
    this.width = e, this.height = n, this.camera.aspect = e / n, this.camera.updateProjectionMatrix();
    const i = mn.degToRad(this.camera.fov), r = n / 2 / Math.tan(i / 2);
    this.camera.position.x = e / 2, this.camera.position.y = -n / 2, this.camera.position.z = r, this.target.set(e / 2, -n / 2, 0), this.camera.lookAt(this.target);
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(e, n, i = 0) {
    const r = e / this.width * 2 - 1, o = -(n / this.height) * 2 + 1, a = new de(r, o, 0.5);
    a.unproject(this.camera);
    const l = a.sub(this.camera.position).normalize(), c = (i - this.camera.position.z) / l.z;
    return this.camera.position.clone().add(l.multiplyScalar(c));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(e, n, i = 0) {
    const r = new de(e, -n, i);
    return r.project(this.camera), {
      x: (r.x + 1) / 2 * this.width,
      y: (-r.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(e) {
    e.position && this.setPosition(e.position.x, e.position.y, e.position.z), e.target && this.setTarget(e.target.x, e.target.y, e.target.z), e.fov !== void 0 && this.setFOV(e.fov), (e.near !== void 0 || e.far !== void 0) && this.setClipPlanes(
      e.near ?? this.camera.near,
      e.far ?? this.camera.far
    );
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const e = mn.degToRad(50), n = this.height / 2 / Math.tan(e / 2);
    this.camera.fov = 50, this.camera.position.set(this.width / 2, -this.height / 2, n), this.target.set(this.width / 2, -this.height / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const e = new Au(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    return e.position.set(0, 0, 1e3), e.lookAt(0, 0, 0), e;
  }
}
class m8 {
  constructor() {
    // Texture cache (keyed by URL or ID)
    fe(this, "textures");
    // Geometry cache (keyed by type and parameters)
    fe(this, "geometries");
    // Material cache (keyed by configuration hash)
    fe(this, "materials");
    // Texture loader
    fe(this, "textureLoader");
    // Asset getter callback (set by WeylEngine)
    fe(this, "assetGetter");
    // Statistics
    fe(this, "stats", {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    });
    this.textures = /* @__PURE__ */ new Map(), this.geometries = /* @__PURE__ */ new Map(), this.materials = /* @__PURE__ */ new Map(), this.textureLoader = new bT(), this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(e) {
    this.assetGetter = e;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(e) {
    var n;
    return (n = this.assetGetter) == null ? void 0 : n.call(this, e);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const e = new un(1, 1, 1, 1);
    this.geometries.set("plane:1:1", e);
    const n = new un(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", n);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(e, n) {
    const i = this.getTextureCacheKey(e, n), r = this.textures.get(i);
    return r ? (this.stats.texturesFromCache++, r) : new Promise((o, a) => {
      this.textureLoader.load(
        e,
        (l) => {
          this.applyTextureOptions(l, n), this.textures.set(i, l), this.stats.texturesLoaded++, o(l);
        },
        void 0,
        // Progress callback
        (l) => {
          al.error("ResourceManager: Failed to load texture:", e, l), a(l);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(e, n, i) {
    const r = this.textures.get(n);
    if (r instanceof To)
      return r.image = e, r.needsUpdate = !0, r;
    const o = new To(
      e.data,
      e.width,
      e.height,
      Rn,
      ji
    );
    return this.applyTextureOptions(o, i), o.needsUpdate = !0, this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(e, n, i) {
    const r = this.textures.get(n);
    if (r instanceof tv)
      return r.needsUpdate = !0, r;
    const o = new tv(e);
    return this.applyTextureOptions(o, i), this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Get a cached texture
   */
  getTexture(e) {
    return this.textures.get(e);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(e, n) {
    if (!n) {
      e.minFilter = Bt, e.magFilter = Bt, e.generateMipmaps = !1, e.colorSpace = dn;
      return;
    }
    n.wrapS !== void 0 && (e.wrapS = n.wrapS), n.wrapT !== void 0 && (e.wrapT = n.wrapT), n.minFilter !== void 0 && (e.minFilter = n.minFilter), n.magFilter !== void 0 && (e.magFilter = n.magFilter), n.generateMipmaps !== void 0 && (e.generateMipmaps = n.generateMipmaps), n.flipY !== void 0 && (e.flipY = n.flipY), n.colorSpace !== void 0 && (e.colorSpace = n.colorSpace);
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(e, n) {
    return n ? `${e}:${JSON.stringify(n)}` : e;
  }
  /**
   * Release a texture
   */
  releaseTexture(e) {
    const n = this.textures.get(e);
    n && (n.dispose(), this.textures.delete(e));
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(e) {
    const n = `layer:${e}`, i = this.textures.get(n);
    return i || null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(e, n) {
    const i = `layer:${e}`;
    this.textures.set(i, n);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(e = 1, n = 1) {
    const i = `plane:${e}:${n}`;
    let r = this.geometries.get(i);
    return r ? (this.stats.geometriesFromCache++, r) : (r = new un(e, n, 1, 1), this.geometries.set(i, r), this.stats.geometriesCreated++, r);
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(e = 1, n = 32) {
    const i = `circle:${e}:${n}`;
    let r = this.geometries.get(i);
    return r ? (this.stats.geometriesFromCache++, r) : (r = new Ru(e, n), this.geometries.set(i, r), this.stats.geometriesCreated++, r);
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(e = 1, n = 1, i = 1) {
    const r = `box:${e}:${n}:${i}`;
    let o = this.geometries.get(r);
    return o ? (this.stats.geometriesFromCache++, o) : (o = new pn(e, n, i), this.geometries.set(r, o), this.stats.geometriesCreated++, o);
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(e) {
    const n = `basic:${JSON.stringify(e)}`;
    let i = this.materials.get(n);
    return i || (i = new Tn({
      color: e.color ?? 16777215,
      transparent: e.transparent ?? !0,
      opacity: e.opacity ?? 1,
      map: e.map,
      side: e.side ?? vn
    }), this.materials.set(n, i), i);
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(e) {
    switch (e) {
      case "basic":
        return new Tn({
          transparent: !0,
          side: vn
        });
      case "standard":
        return new vT({
          transparent: !0,
          side: vn
        });
      case "shader":
        return new zn();
      default:
        return new Tn();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const e of this.textures.values())
      e.dispose();
    this.textures.clear();
    for (const e of this.geometries.values())
      e.dispose();
    this.geometries.clear();
    for (const e of this.materials.values())
      e.dispose();
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    al.debug("ResourceManager: Resource stats:", this.getStats());
  }
}
class v8 {
  constructor() {
    // Frame timing
    fe(this, "frameCount", 0);
    fe(this, "lastTime", 0);
    fe(this, "frameTimes", []);
    fe(this, "maxFrameTimes", 60);
    // FPS calculation
    fe(this, "fps", 0);
    fe(this, "fpsUpdateInterval", 500);
    // ms
    fe(this, "lastFpsUpdate", 0);
    fe(this, "framesInInterval", 0);
    // Frame start time (for measuring frame duration)
    fe(this, "frameStartTime", 0);
    // Last captured stats
    fe(this, "lastStats", {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(e) {
    const n = performance.now(), i = n - this.frameStartTime;
    this.frameTimes.push(i), this.frameTimes.length > this.maxFrameTimes && this.frameTimes.shift(), this.frameCount++, this.framesInInterval++;
    const r = n - this.lastFpsUpdate;
    r >= this.fpsUpdateInterval && (this.fps = Math.round(this.framesInInterval * 1e3 / r), this.framesInInterval = 0, this.lastFpsUpdate = n);
    const o = e.info, a = performance.memory, l = (a == null ? void 0 : a.usedJSHeapSize) ?? 0, c = this.frameTimes.length > 0 ? this.frameTimes.reduce((u, d) => u + d, 0) / this.frameTimes.length : 0;
    return this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(c * 100) / 100,
      drawCalls: o.render.calls,
      triangles: o.render.triangles,
      textures: o.memory.textures,
      geometries: o.memory.geometries,
      memoryUsed: l
    }, this.lastTime = n, this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    return this.frameTimes.length === 0 ? 0 : this.frameTimes.reduce((e, n) => e + n, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    return this.frameTimes.length === 0 ? { min: 0, max: 0 } : {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0, this.frameTimes = [], this.fps = 0, this.framesInInterval = 0, this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime, this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(e = 30) {
    return this.fps > 0 && this.fps < e;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const e = this.lastStats, n = this.getFrameTimeRange();
    return [
      `FPS: ${e.fps}`,
      `Frame Time: ${e.frameTime.toFixed(2)}ms (min: ${n.min.toFixed(2)}, max: ${n.max.toFixed(2)})`,
      `Draw Calls: ${e.drawCalls}`,
      `Triangles: ${e.triangles.toLocaleString()}`,
      `Textures: ${e.textures}`,
      `Geometries: ${e.geometries}`,
      `Memory: ${(e.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join(`
`);
  }
}
class g8 {
  constructor(e) {
    // Core subsystems
    fe(this, "scene");
    fe(this, "renderer");
    fe(this, "layers");
    fe(this, "camera");
    fe(this, "resources");
    fe(this, "performance");
    // State
    fe(this, "state");
    fe(this, "animationFrameId", null);
    // Background and overlay images
    fe(this, "backgroundImage", null);
    fe(this, "depthMapMesh", null);
    fe(this, "depthMapSettings", { colormap: "viridis", opacity: 0.5, visible: !1 });
    // Viewport transform for pan/zoom
    fe(this, "viewportTransform", [1, 0, 0, 1, 0, 0]);
    // Render mode
    fe(this, "renderMode", "color");
    // Audio reactivity
    fe(this, "audioReactiveGetter", null);
    // Transform controls for layer manipulation
    fe(this, "transformControls", null);
    fe(this, "selectedLayerId", null);
    fe(this, "transformMode", "translate");
    // Transform change callback
    fe(this, "onTransformChange", null);
    // Event system
    fe(this, "eventHandlers");
    // Configuration
    fe(this, "config");
    // Active camera tracking
    fe(this, "activeCameraGetter");
    fe(this, "activeCameraId", null);
    this.validateConfig(e), this.config = {
      canvas: e.canvas,
      width: e.width,
      height: e.height,
      compositionWidth: e.compositionWidth ?? e.width,
      compositionHeight: e.compositionHeight ?? e.height,
      pixelRatio: e.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      backgroundColor: e.backgroundColor ?? null,
      debug: e.debug ?? !1,
      powerPreference: e.powerPreference ?? "high-performance"
    }, this.state = {
      currentFrame: 0,
      isRendering: !1,
      isDisposed: !1,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    }, this.eventHandlers = /* @__PURE__ */ new Map(), this.resources = new m8(), this.scene = new G6(this.config.backgroundColor), this.camera = new p8(this.config.width, this.config.height), this.renderer = new tN({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera), this.layers = new f8(this.scene, this.resources), this.performance = new v8(), this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    ), this.setupContextLossHandling(), this.config.debug && ns.debug("Initialized", this.config);
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(e) {
    if (!(e.canvas instanceof HTMLCanvasElement))
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    if (e.width <= 0 || e.height <= 0)
      throw new Error("WeylEngine requires positive width and height");
    if (e.width > 8192 || e.height > 8192)
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(e) {
    this.assertNotDisposed(), this.layers.create(e), this.emit("layerAdded", { layerId: e.id }), this.config.debug && ns.debug("Layer added:", e.id, e.type);
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(e, n) {
    this.assertNotDisposed(), this.layers.update(e, n), this.emit("layerUpdated", { layerId: e, properties: n });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(e) {
    this.assertNotDisposed(), this.layers.remove(e), this.emit("layerRemoved", { layerId: e }), this.config.debug && ns.debug("Layer removed:", e);
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(e) {
    return this.layers.getObject(e);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(e) {
    this.assertNotDisposed();
    const n = new Set(this.layers.getLayerIds()), i = new Set(e.map((r) => r.id));
    for (const r of n)
      i.has(r) || this.layers.remove(r);
    for (const r of e)
      n.has(r.id) ? this.layers.update(r.id, r) : this.layers.create(r);
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(e) {
    this.resources.setAssetGetter(e);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(e) {
    this.layers.setVideoMetadataCallback(e);
  }
  /**
   * Set the precomp render context for LayerManager
   * Allows precomp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setPrecompRenderContext(e) {
    this.layers.setPrecompRenderContext(e);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(e, n, i) {
    this.layers.setCameraCallbacks(e, n, i), this.activeCameraGetter = e;
  }
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(e) {
    this.activeCameraId = e;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter)
      return;
    const e = this.layers.getLayer(this.activeCameraId);
    if (!e || e.type !== "camera")
      return;
    const n = e, i = n.getExportData();
    if (!i)
      return;
    this.camera.setPosition(i.position.x, i.position.y, i.position.z), this.camera.setRotation(i.rotation.x, i.rotation.y, i.rotation.z), this.camera.setFOV(i.fov), this.camera.setClipPlanes(i.nearClip, i.farClip);
    const r = n.getCameraAtCurrentFrame();
    r && r.depthOfField && this.setDOFFromCamera(r.depthOfField);
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(e) {
    this.layers.setCompositionFPS(e);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer()), this.layers.setCamera(this.camera.camera);
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const e = this.camera.camera;
    return {
      projectionMatrix: e.projectionMatrix.clone(),
      viewMatrix: e.matrixWorldInverse.clone(),
      projectionMatrixInverse: e.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    this.layers.setLayerDrivenValues(e, n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    this.layers.clearLayerDrivenValues(e);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Set the current frame for animation evaluation
   * @param frame - The frame number (0-indexed)
   */
  setFrame(e) {
    this.assertNotDisposed(), this.state.currentFrame = e, this.layers.evaluateFrame(e, this.audioReactiveGetter), this.syncActiveCamera(), this.activeCameraId || this.camera.evaluateFrame(e);
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e, this.layers.setAudioReactiveCallback(e);
  }
  /**
   * Get the current frame
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed(), this.performance.beginFrame(), this.emit("frameStart", { frame: this.state.currentFrame }), this.renderer.render(), this.emit("frameEnd", { frame: this.state.currentFrame }), this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    if (this.assertNotDisposed(), this.animationFrameId !== null)
      return;
    this.state.isRendering = !0;
    const e = () => {
      !this.state.isRendering || this.state.isDisposed || (this.render(), this.animationFrameId = requestAnimationFrame(e));
    };
    this.animationFrameId = requestAnimationFrame(e);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = !1, this.animationFrameId !== null && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(e, n, i, r) {
    if (this.assertNotDisposed(), e <= 0 || n <= 0) {
      ns.warn("Invalid resize dimensions:", e, n);
      return;
    }
    this.state.viewport = { width: e, height: n }, this.renderer.resize(e, n);
    const o = i ?? e, a = r ?? n;
    this.camera.resize(o, a), this.emit("resize", { width: e, height: n, compositionWidth: i, compositionHeight: r });
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Set camera position
   */
  setCameraPosition(e, n, i) {
    this.camera.setPosition(e, n, i);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(e, n, i) {
    this.camera.setTarget(e, n, i);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(e) {
    this.camera.setFOV(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(e) {
    this.renderer.setDOF({
      enabled: e.enabled,
      focusDistance: e.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: e.aperture * 1e-4,
      maxBlur: e.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(e) {
    this.renderer.setDOFEnabled(e);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(e) {
    this.renderer.setFocusDistance(e);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(e) {
    this.renderer.setAperture(e * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(e) {
    this.viewportTransform = [...e];
    const n = e[0], i = e[4], r = e[5];
    this.camera.setZoom(n), this.camera.setPan(i, r);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(e) {
    this.assertNotDisposed(), this.backgroundImage && (this.scene.removeFromComposition(this.backgroundImage), this.backgroundImage.geometry.dispose(), this.backgroundImage.material.dispose());
    const n = new _n(e);
    n.needsUpdate = !0, n.colorSpace = dn;
    const i = new un(e.width, e.height), r = new Tn({
      map: n,
      transparent: !0,
      depthWrite: !1
    });
    this.backgroundImage = new Ze(i, r), this.backgroundImage.position.set(e.width / 2, e.height / 2, -1e3), this.backgroundImage.userData.isBackground = !0, this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(e, n) {
    this.assertNotDisposed(), this.depthMapSettings = {
      colormap: n.colormap ?? this.depthMapSettings.colormap,
      opacity: n.opacity ?? this.depthMapSettings.opacity,
      visible: n.visible ?? this.depthMapSettings.visible
    }, this.depthMapMesh && (this.scene.removeFromComposition(this.depthMapMesh), this.depthMapMesh.geometry.dispose(), this.depthMapMesh.material.dispose());
    const i = new _n(e);
    i.needsUpdate = !0;
    const r = this.createColormapMaterial(i, this.depthMapSettings), o = new un(e.width, e.height);
    this.depthMapMesh = new Ze(o, r), this.depthMapMesh.position.set(e.width / 2, e.height / 2, -999), this.depthMapMesh.visible = this.depthMapSettings.visible, this.depthMapMesh.userData.isDepthOverlay = !0, this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(e, n) {
    const i = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, r = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `, o = n.colormap === "viridis" ? 0 : n.colormap === "plasma" ? 1 : 2;
    return new zn({
      uniforms: {
        depthMap: { value: e },
        opacity: { value: n.opacity },
        colormap: { value: o }
      },
      vertexShader: i,
      fragmentShader: r,
      transparent: !0,
      depthWrite: !1
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(e) {
    this.depthMapSettings.visible = e, this.depthMapMesh && (this.depthMapMesh.visible = e);
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(e) {
    if (this.depthMapSettings.colormap = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material, i = e === "viridis" ? 0 : e === "plasma" ? 1 : 2;
      n.uniforms.colormap.value = i;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(e) {
    if (this.depthMapSettings.opacity = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material;
      n.uniforms.opacity.value = e;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, this.renderer.setRenderMode(e);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(e, n) {
    const i = new qf(), r = new rt(e, n);
    i.setFromCamera(r, this.camera.getCamera());
    const o = this.scene.raycastComposition(i);
    for (const a of o) {
      let l = a.object;
      for (; l; ) {
        if (l.userData.layerId)
          return l.userData.layerId;
        if (l.userData.isBackground || l.userData.isDepthOverlay)
          break;
        l = l.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    if (this.assertNotDisposed(), this.transformControls)
      return;
    const e = this.camera.getCamera(), n = this.renderer.getDomElement();
    this.transformControls = new I6(e, n), this.transformControls.setMode(this.transformMode), this.transformControls.setSpace("world"), this.transformControls.setSize(1), this.scene.addUIElement(this.transformControls), this.transformControls.addEventListener("change", () => {
      if (!this.transformControls || !this.selectedLayerId) return;
      const i = this.transformControls.object;
      if (!i) return;
      const r = {
        position: {
          x: i.position.x,
          y: i.position.y,
          z: i.position.z
        },
        rotationX: mn.radToDeg(i.rotation.x),
        rotationY: mn.radToDeg(i.rotation.y),
        rotationZ: mn.radToDeg(i.rotation.z),
        scale: {
          x: i.scale.x * 100,
          // Convert back to percentage
          y: i.scale.y * 100,
          z: i.scale.z * 100
        }
      };
      r.rotation = r.rotationZ, this.onTransformChange && this.onTransformChange(this.selectedLayerId, r);
    }), this.transformControls.addEventListener("dragging-changed", (i) => {
      this.emit("transform-dragging", { dragging: i.value });
    }), this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(e) {
    this.onTransformChange = e;
  }
  /**
   * Select a layer and attach transform controls
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(e) {
    if (this.assertNotDisposed(), this.transformControls || this.initializeTransformControls(), this.selectedLayerId && this.transformControls && this.transformControls.detach(), this.selectedLayerId = e, !e || !this.transformControls)
      return;
    const n = this.getLayerObject(e);
    n && this.transformControls.attach(n);
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(e) {
    this.transformMode = e, this.transformControls && this.transformControls.setMode(e);
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(e) {
    this.transformControls && (this.transformControls.visible = e, this.transformControls.enabled = e);
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    var e;
    return ((e = this.transformControls) == null ? void 0 : e.dragging) ?? !1;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const e = this.renderer.captureFrame();
    return {
      imageData: e,
      width: e.width,
      height: e.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(e = "png", n = 0.95) {
    this.assertNotDisposed();
    const { imageData: i, width: r, height: o } = this.captureFrame(), a = new OffscreenCanvas(r, o);
    return a.getContext("2d").putImageData(i, 0, 0), a.convertToBlob({
      type: `image/${e}`,
      quality: n
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const e = this.renderer.captureDepth(), n = this.camera.getState();
    return {
      depthBuffer: e,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: n.near,
      far: n.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var r;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (r = this.eventHandlers.get(e)) == null || r.forEach((o) => {
      try {
        o(i);
      } catch (a) {
        ns.error(`Event handler error for ${e}:`, a);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const e = this.config.canvas;
    e.addEventListener("webglcontextlost", (n) => {
      n.preventDefault(), this.stopRenderLoop(), this.emit("contextLost", null), ns.warn("WebGL context lost");
    }), e.addEventListener("webglcontextrestored", () => {
      this.emit("contextRestored", null), ns.info("WebGL context restored");
    });
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed)
      throw new Error("WeylEngine has been disposed");
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    this.state.isDisposed || (this.stopRenderLoop(), this.layers.dispose(), this.renderer.dispose(), this.scene.dispose(), this.resources.dispose(), this.eventHandlers.clear(), this.state.isDisposed = !0, this.emit("dispose", null), this.config.debug && ns.debug("Disposed"));
  }
}
const y8 = { class: "spline-editor" }, x8 = ["viewBox"], _8 = ["x1", "y1", "x2", "y2"], b8 = ["x1", "y1", "x2", "y2"], w8 = ["cx", "cy", "onMousedown"], S8 = ["cx", "cy", "onMousedown"], M8 = ["cx", "cy", "onMousedown"], C8 = ["cx", "cy"], T8 = /* @__PURE__ */ Ot({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(s, { expose: e, emit: n }) {
    const i = s, r = n, o = sn(), a = we(null), l = we(null), c = we(null), u = Ie(() => {
      if (!i.layerId) return [];
      const M = o.layers.find((b) => b.id === i.layerId);
      return !M || M.type !== "spline" || !M.data ? [] : M.data.controlPoints || [];
    });
    function d(M, S) {
      const b = i.viewportTransform, C = (M - b[4]) / b[0], T = (S - b[5]) / b[3];
      return { x: C, y: T };
    }
    function h(M) {
      const b = M.currentTarget.getBoundingClientRect(), C = M.clientX - b.left, T = M.clientY - b.top;
      return d(C, T);
    }
    function m(M) {
      if (!i.isPenMode) return;
      const S = h(M);
      if (i.layerId) {
        const b = o.layers.find((C) => C.id === i.layerId);
        if (b && b.type === "spline") {
          const C = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: S.x,
            y: S.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          o.addSplineControlPoint(i.layerId, C), a.value = C.id, c.value = {
            type: "handleOut",
            pointId: C.id,
            startX: S.x,
            startY: S.y
          }, r("pointAdded", C), r("pathUpdated");
        }
      }
    }
    function p(M) {
      var b;
      const S = h(M);
      if (i.isPenMode && (l.value = S), c.value && i.layerId) {
        const C = o.layers.find((E) => E.id === i.layerId);
        if (!C || C.type !== "spline") return;
        const P = (b = C.data.controlPoints) == null ? void 0 : b.find((E) => E.id === c.value.pointId);
        if (!P) return;
        if (c.value.type === "point") {
          const E = S.x - P.x, y = S.y - P.y, w = { x: S.x, y: S.y };
          P.handleIn && (w.handleIn = { x: P.handleIn.x + E, y: P.handleIn.y + y }), P.handleOut && (w.handleOut = { x: P.handleOut.x + E, y: P.handleOut.y + y }), o.updateSplineControlPoint(i.layerId, P.id, w), r("pointMoved", P.id, S.x, S.y);
        } else if (c.value.type === "handleIn") {
          const E = { handleIn: { x: S.x, y: S.y } };
          if (P.type === "smooth") {
            const y = S.x - P.x, w = S.y - P.y;
            E.handleOut = { x: P.x - y, y: P.y - w };
          }
          o.updateSplineControlPoint(i.layerId, P.id, E), r("handleMoved", P.id, "in", S.x, S.y);
        } else if (c.value.type === "handleOut") {
          const E = { handleOut: { x: S.x, y: S.y } };
          if (P.type === "smooth") {
            const y = S.x - P.x, w = S.y - P.y;
            E.handleIn = { x: P.x - y, y: P.y - w };
          }
          o.updateSplineControlPoint(i.layerId, P.id, E), r("handleMoved", P.id, "out", S.x, S.y);
        }
        r("pathUpdated");
      }
    }
    function v() {
      var M;
      if (c.value && i.layerId) {
        const S = o.layers.find((b) => b.id === i.layerId);
        if (S && S.type === "spline") {
          const C = (M = S.data.controlPoints) == null ? void 0 : M.find((T) => T.id === c.value.pointId);
          if (C && C.handleOut) {
            const T = C.handleOut.x - C.x, P = C.handleOut.y - C.y;
            Math.sqrt(T * T + P * P) > 5 ? o.updateSplineControlPoint(i.layerId, C.id, {
              type: "smooth",
              handleIn: { x: C.x - T, y: C.y - P }
            }) : o.updateSplineControlPoint(i.layerId, C.id, {
              handleOut: null
            });
          }
        }
        c.value = null, r("pathUpdated");
      }
    }
    function _(M, S) {
      if (a.value = M, !i.isPenMode) {
        const b = h(S);
        c.value = {
          type: "point",
          pointId: M,
          startX: b.x,
          startY: b.y
        };
      }
    }
    function g(M, S, b) {
      const C = h(b);
      c.value = {
        type: S === "in" ? "handleIn" : "handleOut",
        pointId: M,
        startX: C.x,
        startY: C.y
      };
    }
    function x(M) {
      if ((M.key === "Delete" || M.key === "Backspace") && a.value && i.layerId) {
        const S = o.layers.find((b) => b.id === i.layerId);
        if (S && S.type === "spline") {
          const b = a.value;
          o.deleteSplineControlPoint(i.layerId, b), r("pointDeleted", b), r("pathUpdated"), a.value = null;
        }
      }
    }
    return xn(() => {
      window.addEventListener("keydown", x);
    }), Nn(() => {
      window.removeEventListener("keydown", x);
    }), e({
      selectedPointId: a,
      clearSelection: () => {
        a.value = null;
      }
    }), (M, S) => (te(), ae("div", y8, [
      (te(), ae("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${s.canvasWidth} ${s.canvasHeight}`,
        onMousedown: m,
        onMousemove: p,
        onMouseup: v,
        onMouseleave: v
      }, [
        (te(!0), ae(qe, null, ot(u.value, (b) => (te(), ae(qe, {
          key: `handles-${b.id}`
        }, [
          b.handleIn && a.value === b.id ? (te(), ae("line", {
            key: 0,
            x1: b.x,
            y1: b.y,
            x2: b.handleIn.x,
            y2: b.handleIn.y,
            class: "handle-line"
          }, null, 8, _8)) : Pe("", !0),
          b.handleOut && a.value === b.id ? (te(), ae("line", {
            key: 1,
            x1: b.x,
            y1: b.y,
            x2: b.handleOut.x,
            y2: b.handleOut.y,
            class: "handle-line"
          }, null, 8, b8)) : Pe("", !0)
        ], 64))), 128)),
        (te(!0), ae(qe, null, ot(u.value, (b) => {
          var C, T;
          return te(), ae(qe, {
            key: `handle-points-${b.id}`
          }, [
            b.handleIn && a.value === b.id ? (te(), ae("circle", {
              key: 0,
              cx: b.handleIn.x,
              cy: b.handleIn.y,
              r: "4",
              class: Fe(["handle-point", { active: ((C = c.value) == null ? void 0 : C.type) === "handleIn" && c.value.pointId === b.id }]),
              onMousedown: xt((P) => g(b.id, "in", P), ["stop"])
            }, null, 42, w8)) : Pe("", !0),
            b.handleOut && a.value === b.id ? (te(), ae("circle", {
              key: 1,
              cx: b.handleOut.x,
              cy: b.handleOut.y,
              r: "4",
              class: Fe(["handle-point", { active: ((T = c.value) == null ? void 0 : T.type) === "handleOut" && c.value.pointId === b.id }]),
              onMousedown: xt((P) => g(b.id, "out", P), ["stop"])
            }, null, 42, S8)) : Pe("", !0)
          ], 64);
        }), 128)),
        (te(!0), ae(qe, null, ot(u.value, (b) => (te(), ae("circle", {
          key: `point-${b.id}`,
          cx: b.x,
          cy: b.y,
          r: "6",
          class: Fe(["control-point", {
            selected: a.value === b.id,
            corner: b.type === "corner",
            smooth: b.type === "smooth"
          }]),
          onMousedown: xt((C) => _(b.id, C), ["stop"])
        }, null, 42, M8))), 128)),
        l.value && s.isPenMode ? (te(), ae("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, C8)) : Pe("", !0)
      ], 40, x8))
    ]));
  }
}), E8 = /* @__PURE__ */ Gt(T8, [["__scopeId", "data-v-55bdee8d"]]), A8 = {
  key: 1,
  class: "overlay-controls"
}, P8 = { class: "render-mode-controls" }, R8 = {
  key: 2,
  class: "transform-mode-controls"
}, D8 = {
  key: 3,
  class: "performance-overlay"
}, k8 = {
  key: 4,
  class: "loading-overlay"
}, I8 = /* @__PURE__ */ Ot({
  __name: "ThreeCanvas",
  setup(s, { expose: e }) {
    const n = sn(), i = we(null), r = we(null), o = we(null), a = z1(null), l = we(!1), c = we(1), u = we(800), d = we(600), h = we(!1), m = we("viridis"), p = we(50), v = we("color"), _ = we(!1), g = we({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    }), x = we([1, 0, 0, 1, 0, 0]), M = we("translate"), S = Ie(() => n.depthMap !== null), b = Ie(() => n.currentTool === "pen"), C = Ie(() => {
      const V = n.selectedLayer;
      if ((V == null ? void 0 : V.type) === "spline")
        return V.id;
      if (b.value) {
        const Y = n.layers.filter((H) => H.type === "spline");
        return Y.length > 0 ? Y[Y.length - 1].id : null;
      }
      return null;
    }), T = Ie(() => x.value);
    xn(async () => {
      if (!r.value || !i.value) return;
      const V = i.value, Y = V.getBoundingClientRect();
      u.value = Y.width, d.value = Y.height;
      const H = {
        canvas: r.value,
        width: Y.width,
        height: Y.height,
        compositionWidth: n.width || 1920,
        compositionHeight: n.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: !0,
        alpha: !0,
        powerPreference: "high-performance"
      };
      try {
        l.value = !0, a.value = new g8(H), a.value.setAssetGetter((F) => n.assets[F]), a.value.setVideoMetadataCallback((F, L) => {
          n.onVideoMetadataLoaded(F, L);
        }), a.value.setCameraCallbacks(
          (F) => n.getCamera(F),
          (F, L) => n.updateCamera(F, L),
          (F, L) => n.getCameraAtFrame(F, L)
        ), a.value.setPrecompRenderContext({
          renderComposition: (F, L) => (n.getComposition(F) && console.log("[ThreeCanvas] Precomp render requested:", F, "frame:", L), null),
          getComposition: (F) => n.getComposition(F)
        }), a.value.setAudioReactiveCallback(
          (F, L) => n.getAudioReactiveValuesForLayer(F, L)
        ), a.value.initializeTransformControls(), a.value.setTransformChangeCallback((F, L) => {
          A(F, L);
        }), a.value.initializeParticleSystems(), a.value.setCompositionFPS(n.fps || 60), a.value.start(), await Pi(), E(), n.initializePropertyDriverSystem(), a.value.setFrame(n.currentFrame), R(), new ResizeObserver(ue).observe(V), Q();
      } catch (I) {
        console.error("[ThreeCanvas] Failed to initialize engine:", I);
      } finally {
        l.value = !1;
      }
      P();
    }), Nn(() => {
      a.value && (a.value.stop(), a.value.dispose(), a.value = null);
    });
    function P() {
      Ft(
        () => n.layers,
        () => {
          E(), a.value && a.value.setFrame(n.currentFrame);
        },
        { deep: !0 }
      ), Ft(
        () => n.currentFrame,
        (V) => {
          a.value && (y(), a.value.setFrame(V));
        }
      ), Ft(
        () => [n.width, n.height],
        ([V, Y]) => {
          a.value && (a.value.resize(u.value, d.value, V, Y), Q());
        }
      ), Ft(
        () => n.sourceImage,
        async (V) => {
          a.value && V && await w(V);
        },
        { immediate: !0 }
      ), Ft(
        () => n.depthMap,
        async (V) => {
          a.value && V && await D(V);
        },
        { immediate: !0 }
      ), Ft(
        () => {
          var V;
          return (V = a.value) == null ? void 0 : V.getPerformanceStats();
        },
        (V) => {
          V && (g.value = V);
        }
      ), Ft(
        () => n.activeCameraId,
        (V) => {
          if (!a.value) return;
          if (!V) {
            a.value.setActiveCameraLayer(null);
            return;
          }
          const Y = n.layers.find(
            (H) => {
              var I;
              return H.type === "camera" && ((I = H.data) == null ? void 0 : I.cameraId) === V;
            }
          );
          Y && a.value.setActiveCameraLayer(Y.id);
        },
        { immediate: !0 }
      ), Ft(
        () => n.selectedLayerIds,
        (V) => {
          if (!a.value) return;
          const Y = V.length > 0 ? V[0] : null;
          a.value.selectLayer(Y);
        },
        { deep: !0 }
      );
    }
    function E() {
      if (!a.value) return;
      const V = new Set(a.value.getLayerIds()), Y = new Set(n.layers.map((H) => H.id));
      for (const H of V)
        Y.has(H) || a.value.removeLayer(H);
      for (const H of n.layers)
        V.has(H.id) ? a.value.updateLayer(H.id, H) : a.value.addLayer(H);
    }
    function y() {
      if (a.value) {
        a.value.clearAllDrivenValues();
        for (const V of n.layers) {
          const Y = n.getDrivenValuesForLayer(V.id);
          Y.size > 0 && a.value.setLayerDrivenValues(V.id, Y);
        }
      }
    }
    async function w(V) {
      if (a.value)
        try {
          l.value = !0;
          const Y = await U(V);
          a.value.setBackgroundImage(Y);
        } catch (Y) {
          console.error("[ThreeCanvas] Failed to load source image:", Y);
        } finally {
          l.value = !1;
        }
    }
    async function D(V) {
      if (a.value)
        try {
          const Y = await U(V);
          a.value.setDepthMap(Y, {
            colormap: m.value,
            opacity: p.value / 100,
            visible: h.value
          });
        } catch (Y) {
          console.error("[ThreeCanvas] Failed to load depth map:", Y);
        }
    }
    function U(V) {
      return new Promise((Y, H) => {
        const I = new Image();
        I.crossOrigin = "anonymous", I.onload = () => Y(I), I.onerror = H, I.src = V.startsWith("data:") ? V : `data:image/png;base64,${V}`;
      });
    }
    function R() {
      const V = i.value, Y = r.value;
      if (!V || !Y) return;
      let H = !1, I = !1, F = 0, L = 0, ee = 0, Z = 1;
      V.addEventListener("mousedown", (k) => {
        k.button === 1 && k.preventDefault();
      }), V.addEventListener("auxclick", (k) => {
        k.button === 1 && k.preventDefault();
      }), Y.addEventListener("wheel", (k) => {
        k.preventDefault();
        const ne = k.deltaY;
        let J = c.value * (ne > 0 ? 0.9 : 1.1);
        J = Math.min(Math.max(J, 0.1), 10);
        const B = Y.getBoundingClientRect(), X = k.clientX - B.left, se = k.clientY - B.top, z = J / c.value;
        x.value[4] = X - z * (X - x.value[4]), x.value[5] = se - z * (se - x.value[5]), x.value[0] = J, x.value[3] = J, c.value = J, a.value && a.value.setViewportTransform(x.value);
      }, { passive: !1 }), Y.addEventListener("mousedown", (k) => {
        var J, B;
        const ne = n.currentTool;
        if (k.button === 1 || ne === "hand" || k.button === 0 && k.altKey) {
          H = !0, F = k.clientX, L = k.clientY, Y.style.cursor = "grabbing", k.preventDefault();
          return;
        }
        if (ne === "zoom") {
          if (k.shiftKey) {
            const X = Math.max(c.value * 0.7, 0.1);
            c.value = X, x.value[0] = X, x.value[3] = X, a.value && a.value.setViewportTransform(x.value);
          } else
            I = !0, ee = k.clientY, Z = c.value;
          return;
        }
        if (ne === "text") {
          const X = Y.getBoundingClientRect(), se = O(k.clientX - X.left, k.clientY - X.top), z = n.createLayer("text");
          (J = z.transform) != null && J.position && (z.transform.position.value = { x: se.x, y: se.y, z: 0 }), n.updateLayer(z.id, {
            transform: {
              ...z.transform,
              position: {
                ...z.transform.position,
                value: { x: se.x, y: se.y, z: 0 }
              }
            }
          }), n.selectLayer(z.id), n.setTool("select");
          return;
        }
        if (ne === "select" && k.button === 0) {
          if ((B = a.value) != null && B.isTransformDragging())
            return;
          const X = Y.getBoundingClientRect(), se = (k.clientX - X.left) / X.width * 2 - 1, z = -((k.clientY - X.top) / X.height) * 2 + 1;
          if (a.value) {
            const N = a.value.raycastLayers(se, z);
            N ? (n.selectLayer(N), a.value.selectLayer(N)) : (n.clearSelection(), a.value.selectLayer(null));
          }
        }
      }), Y.addEventListener("mousemove", (k) => {
        if (H) {
          const J = k.clientX - F, B = k.clientY - L;
          x.value[4] += J, x.value[5] += B, F = k.clientX, L = k.clientY, a.value && a.value.setViewportTransform(x.value);
          return;
        }
        if (I) {
          const B = 1 + (ee - k.clientY) * 0.01, X = Math.max(0.1, Math.min(10, Z * B));
          c.value = X, x.value[0] = X, x.value[3] = X, a.value && a.value.setViewportTransform(x.value);
          return;
        }
        const ne = n.currentTool;
        ne === "hand" ? Y.style.cursor = "grab" : ne === "zoom" ? Y.style.cursor = "zoom-in" : ne === "text" ? Y.style.cursor = "text" : ne === "pen" ? Y.style.cursor = "crosshair" : Y.style.cursor = "default";
      }), Y.addEventListener("mouseup", () => {
        H && (H = !1, Y.style.cursor = n.currentTool === "hand" ? "grab" : "default"), I && (I = !1);
      }), Y.addEventListener("mouseleave", () => {
        H = !1, I = !1;
      });
    }
    function O(V, Y) {
      const H = x.value;
      return {
        x: (V - H[4]) / H[0],
        y: (Y - H[5]) / H[3]
      };
    }
    function A(V, Y) {
      var F, L, ee, Z;
      const H = n.layers.find((k) => k.id === V);
      if (!H) return;
      const I = {};
      Y.position && H.transform && (I.transform = {
        ...H.transform,
        position: {
          ...H.transform.position,
          value: {
            x: Y.position.x,
            y: Y.position.y,
            z: Y.position.z ?? ((L = (F = H.transform.position) == null ? void 0 : F.value) == null ? void 0 : L.z) ?? 0
          }
        }
      }), H.threeD ? (Y.rotationX !== void 0 || Y.rotationY !== void 0 || Y.rotationZ !== void 0) && (!I.transform && H.transform && (I.transform = { ...H.transform }), I.transform && (Y.rotationX !== void 0 && (I.transform.rotationX = { ...H.transform.rotationX, value: Y.rotationX }), Y.rotationY !== void 0 && (I.transform.rotationY = { ...H.transform.rotationY, value: Y.rotationY }), Y.rotationZ !== void 0 && (I.transform.rotationZ = { ...H.transform.rotationZ, value: Y.rotationZ }))) : Y.rotation !== void 0 && H.transform && (I.transform || (I.transform = { ...H.transform }), I.transform.rotation = { ...H.transform.rotation, value: Y.rotation }), Y.scale && H.transform && (I.transform || (I.transform = { ...H.transform }), I.transform.scale = {
        ...H.transform.scale,
        value: {
          x: Y.scale.x,
          y: Y.scale.y,
          z: Y.scale.z ?? ((Z = (ee = H.transform.scale) == null ? void 0 : ee.value) == null ? void 0 : Z.z) ?? 100
        }
      }), Object.keys(I).length > 0 && n.updateLayer(V, I);
    }
    function G(V) {
      M.value = V, a.value && a.value.setTransformMode(V);
    }
    function ue(V) {
      for (const Y of V) {
        const { width: H, height: I } = Y.contentRect;
        H > 0 && I > 0 && (u.value = H, d.value = I, a.value && a.value.resize(H, I));
      }
    }
    function Q() {
      const V = i.value;
      if (!V || !a.value) return;
      const Y = n.width || 1920, H = n.height || 1080, I = V.getBoundingClientRect(), F = 60, L = (I.width - F * 2) / Y, ee = (I.height - F * 2) / H, Z = Math.min(L, ee, 1);
      x.value = [
        Z,
        0,
        0,
        Z,
        (I.width - Y * Z) / 2,
        (I.height - H * Z) / 2
      ], c.value = Z, a.value.setViewportTransform(x.value);
    }
    function le(V) {
      v.value = V, a.value && a.value.setRenderMode(V);
    }
    function re(V) {
      if (!C.value) {
        const Y = n.createLayer("spline");
        n.selectLayer(Y.id);
      }
    }
    function j() {
      E();
    }
    function $() {
      const V = Math.min(c.value * 1.2, 10);
      c.value = V, x.value[0] = V, x.value[3] = V, a.value && a.value.setViewportTransform(x.value);
    }
    function q() {
      const V = Math.max(c.value * 0.8, 0.1);
      c.value = V, x.value[0] = V, x.value[3] = V, a.value && a.value.setViewportTransform(x.value);
    }
    function oe() {
      Q();
    }
    async function ie() {
      if (!a.value) return null;
      const V = a.value.captureFrame();
      if (!(V != null && V.imageData)) return null;
      const Y = document.createElement("canvas");
      Y.width = V.width, Y.height = V.height;
      const H = Y.getContext("2d");
      return H ? (H.putImageData(V.imageData, 0, 0), Y.toDataURL("image/png")) : null;
    }
    async function ce() {
      if (!a.value) return null;
      const V = a.value.captureDepth();
      if (!(V != null && V.depthBuffer)) return null;
      const Y = document.createElement("canvas");
      Y.width = V.width, Y.height = V.height;
      const H = Y.getContext("2d");
      if (!H) return null;
      const I = H.createImageData(V.width, V.height);
      for (let F = 0; F < V.depthBuffer.length; F++) {
        const L = Math.floor(V.depthBuffer[F] * 255), ee = F * 4;
        I.data[ee] = L, I.data[ee + 1] = L, I.data[ee + 2] = L, I.data[ee + 3] = 255;
      }
      return H.putImageData(I, 0, 0), Y.toDataURL("image/png");
    }
    return Ft(h, (V) => {
      a.value && a.value.setDepthOverlayVisible(V);
    }), Ft(m, (V) => {
      a.value && a.value.setDepthColormap(V);
    }), Ft(p, (V) => {
      a.value && a.value.setDepthOpacity(V / 100);
    }), e({
      engine: a,
      fitToView: oe,
      zoomIn: $,
      zoomOut: q,
      zoom: c,
      captureFrame: ie,
      captureDepth: ce,
      showPerformance: _,
      performanceStats: g,
      renderMode: v,
      setRenderMode: le,
      transformMode: M,
      setTransformModeTo: G
    }), (V, Y) => (te(), ae("div", {
      class: "three-canvas",
      ref_key: "containerRef",
      ref: i
    }, [
      f("canvas", {
        ref_key: "canvasRef",
        ref: r
      }, null, 512),
      C.value || b.value ? (te(), St(E8, {
        key: 0,
        layerId: C.value,
        canvasWidth: u.value,
        canvasHeight: d.value,
        zoom: c.value,
        viewportTransform: T.value,
        isPenMode: b.value,
        onPointAdded: re,
        onPathUpdated: j,
        ref_key: "splineEditorRef",
        ref: o
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : Pe("", !0),
      S.value ? (te(), ae("div", A8, [
        f("label", null, [
          st(f("input", {
            type: "checkbox",
            "onUpdate:modelValue": Y[0] || (Y[0] = (H) => h.value = H)
          }, null, 512), [
            [_i, h.value]
          ]),
          Y[9] || (Y[9] = ct(" Depth Overlay ", -1))
        ]),
        st(f("select", {
          "onUpdate:modelValue": Y[1] || (Y[1] = (H) => m.value = H),
          class: "colormap-select"
        }, [...Y[10] || (Y[10] = [
          f("option", { value: "viridis" }, "Viridis", -1),
          f("option", { value: "plasma" }, "Plasma", -1),
          f("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [Cn, m.value]
        ]),
        st(f("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": Y[2] || (Y[2] = (H) => p.value = H),
          class: "opacity-slider"
        }, null, 512), [
          [
            Ut,
            p.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : Pe("", !0),
      f("div", P8, [
        f("button", {
          class: Fe({ active: v.value === "color" }),
          onClick: Y[3] || (Y[3] = (H) => le("color")),
          title: "Color View"
        }, [...Y[11] || (Y[11] = [
          f("i", { class: "pi pi-image" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: v.value === "depth" }),
          onClick: Y[4] || (Y[4] = (H) => le("depth")),
          title: "Depth View"
        }, [...Y[12] || (Y[12] = [
          f("i", { class: "pi pi-box" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: v.value === "normal" }),
          onClick: Y[5] || (Y[5] = (H) => le("normal")),
          title: "Normal View"
        }, [...Y[13] || (Y[13] = [
          f("i", { class: "pi pi-compass" }, null, -1)
        ])], 2)
      ]),
      Ve(n).selectedLayerIds.length > 0 ? (te(), ae("div", R8, [
        f("button", {
          class: Fe({ active: M.value === "translate" }),
          onClick: Y[6] || (Y[6] = (H) => G("translate")),
          title: "Move (V)"
        }, [...Y[14] || (Y[14] = [
          f("i", { class: "pi pi-arrows-alt" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: M.value === "rotate" }),
          onClick: Y[7] || (Y[7] = (H) => G("rotate")),
          title: "Rotate (R)"
        }, [...Y[15] || (Y[15] = [
          f("i", { class: "pi pi-sync" }, null, -1)
        ])], 2),
        f("button", {
          class: Fe({ active: M.value === "scale" }),
          onClick: Y[8] || (Y[8] = (H) => G("scale")),
          title: "Scale (S)"
        }, [...Y[16] || (Y[16] = [
          f("i", { class: "pi pi-expand" }, null, -1)
        ])], 2)
      ])) : Pe("", !0),
      _.value ? (te(), ae("div", D8, [
        f("span", null, "FPS: " + _e(g.value.fps), 1),
        f("span", null, "Draw: " + _e(g.value.drawCalls), 1),
        f("span", null, "Tris: " + _e(g.value.triangles), 1)
      ])) : Pe("", !0),
      l.value ? (te(), ae("div", k8, [...Y[17] || (Y[17] = [
        f("div", { class: "loading-spinner" }, null, -1),
        f("span", null, "Loading...", -1)
      ])])) : Pe("", !0)
    ], 512));
  }
}), L8 = /* @__PURE__ */ Gt(I8, [["__scopeId", "data-v-354ad1da"]]), F8 = { class: "prop-wrapper" }, U8 = { class: "prop-content" }, O8 = { class: "prop-name" }, z8 = { class: "prop-inputs" }, N8 = {
  key: 0,
  class: "vec-item"
}, B8 = {
  key: 1,
  class: "color-input-wrapper"
}, V8 = ["value"], G8 = { class: "color-hex" }, H8 = { class: "vec-item" }, $8 = { class: "vec-item" }, W8 = ["onMousedown", "onDblclick", "onContextmenu"], X8 = /* @__PURE__ */ Ot({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(s, { emit: e }) {
    const n = s, i = sn(), r = we(/* @__PURE__ */ new Set()), o = we(null), a = we(!1), l = we(0), c = we(0), u = we({
      visible: !1,
      x: 0,
      y: 0,
      keyframe: null
    }), d = Ie(() => ({
      left: `${u.value.x}px`,
      top: `${u.value.y}px`
    })), h = Ie(() => {
      const U = Math.min(l.value, c.value), R = Math.abs(c.value - l.value);
      return {
        left: `${U}px`,
        width: `${R}px`
      };
    }), m = Ie(() => {
      var U;
      return (U = n.property.keyframes) == null ? void 0 : U.some((R) => R.frame === i.currentFrame);
    }), p = Ie(() => i.selectedPropertyPath === n.propertyPath);
    function v() {
      i.setPropertyAnimated(n.layerId, n.propertyPath, !n.property.animated);
    }
    function _() {
      i.addKeyframe(n.layerId, n.propertyPath, n.property.value);
    }
    function g(U) {
      i.setPropertyValue(n.layerId, n.propertyPath, U);
    }
    function x(U, R) {
      const O = { ...n.property.value, [U]: R };
      i.setPropertyValue(n.layerId, n.propertyPath, O);
    }
    function M() {
      i.selectProperty(n.propertyPath);
    }
    function S(U) {
      const R = U.currentTarget.getBoundingClientRect(), O = U.clientX - R.left;
      a.value = !0, l.value = O, c.value = O, U.shiftKey || r.value.clear();
      const A = (ue) => {
        const Q = ue.clientX - R.left;
        c.value = Math.max(0, Q);
        const le = Math.min(l.value, c.value) / n.pixelsPerFrame, re = Math.max(l.value, c.value) / n.pixelsPerFrame;
        ue.shiftKey || r.value.clear();
        for (const j of n.property.keyframes || [])
          j.frame >= le && j.frame <= re && r.value.add(j.id);
      }, G = (ue) => {
        if (a.value = !1, Math.abs(c.value - l.value) < 5) {
          const le = Math.round(l.value / n.pixelsPerFrame);
          i.setFrame(Math.max(0, Math.min(i.frameCount - 1, le)));
        }
        window.removeEventListener("mousemove", A), window.removeEventListener("mouseup", G);
      };
      window.addEventListener("mousemove", A), window.addEventListener("mouseup", G);
    }
    function b(U, R) {
      U.shiftKey ? r.value.has(R.id) ? r.value.delete(R.id) : r.value.add(R.id) : (r.value.clear(), r.value.add(R.id));
      const O = U.clientX, A = R.frame, G = (Q) => {
        const le = Q.clientX - O, re = Math.round(le / n.pixelsPerFrame);
        let j = Math.max(0, Math.min(i.frameCount - 1, A + re));
        if (!Q.altKey && i.snapConfig.enabled) {
          const $ = Kf(j, i.snapConfig, n.pixelsPerFrame, {
            layers: i.layers,
            selectedLayerId: n.layerId,
            currentFrame: i.currentFrame,
            audioAnalysis: i.audioAnalysis,
            peakData: i.peakData
          });
          $ && (j = $.frame);
        }
        j !== R.frame && i.moveKeyframe(n.layerId, n.propertyPath, R.id, j);
      }, ue = () => {
        window.removeEventListener("mousemove", G), window.removeEventListener("mouseup", ue);
      };
      window.addEventListener("mousemove", G), window.addEventListener("mouseup", ue);
    }
    function C(U) {
      i.removeKeyframe(n.layerId, n.propertyPath, U), r.value.delete(U);
    }
    function T(U, R) {
      var A;
      r.value.has(R.id) || (r.value.clear(), r.value.add(R.id));
      const O = (A = o.value) == null ? void 0 : A.getBoundingClientRect();
      O && (u.value = {
        visible: !0,
        x: U.clientX - O.left,
        y: U.clientY - O.top,
        keyframe: R
      });
    }
    function P() {
      u.value.visible = !1, u.value.keyframe = null;
    }
    function E(U) {
      for (const R of r.value)
        i.setKeyframeInterpolation(n.layerId, n.propertyPath, R, U);
      P();
    }
    function y() {
      u.value.keyframe && i.setFrame(u.value.keyframe.frame), P();
    }
    function w() {
      for (const U of r.value)
        i.removeKeyframe(n.layerId, n.propertyPath, U);
      r.value.clear(), P();
    }
    function D(U) {
      u.value.visible && P();
    }
    return xn(() => {
      document.addEventListener("click", D);
    }), Nn(() => {
      document.removeEventListener("click", D);
    }), (U, R) => {
      var O, A, G, ue;
      return te(), ae("div", F8, [
        s.layoutMode === "sidebar" ? (te(), ae("div", {
          key: 0,
          class: Fe(["prop-sidebar", { selected: p.value }]),
          style: yt(s.gridStyle),
          onClick: M
        }, [
          R[10] || (R[10] = f("div", { class: "indent-spacer" }, null, -1)),
          f("div", {
            class: "icon-box",
            onClick: xt(_, ["stop"])
          }, [
            f("span", {
              class: Fe(["kf-btn", { active: m.value }])
            }, "", 2)
          ]),
          f("div", {
            class: "icon-box",
            onClick: xt(v, ["stop"])
          }, [
            f("span", {
              class: Fe(["stopwatch", { active: s.property.animated }])
            }, "", 2)
          ]),
          f("div", U8, [
            f("span", O8, _e(s.name), 1),
            f("div", z8, [
              s.name === "Z Position" ? (te(), ae("div", N8, [
                R[7] || (R[7] = f("span", { class: "label z-label" }, "Z", -1)),
                ze(et, {
                  modelValue: ((O = s.property.value) == null ? void 0 : O.z) ?? 0,
                  "onUpdate:modelValue": R[0] || (R[0] = (Q) => x("z", Q))
                }, null, 8, ["modelValue"])
              ])) : s.property.type === "color" ? (te(), ae("div", B8, [
                f("input", {
                  type: "color",
                  value: s.property.value,
                  onInput: R[1] || (R[1] = (Q) => g(Q.target.value))
                }, null, 40, V8),
                f("span", G8, _e(s.property.value), 1)
              ])) : typeof s.property.value == "object" ? (te(), ae(qe, { key: 2 }, [
                f("div", H8, [
                  R[8] || (R[8] = f("span", { class: "label x-label" }, "X", -1)),
                  ze(et, {
                    modelValue: s.property.value.x,
                    "onUpdate:modelValue": R[2] || (R[2] = (Q) => x("x", Q))
                  }, null, 8, ["modelValue"])
                ]),
                f("div", $8, [
                  R[9] || (R[9] = f("span", { class: "label y-label" }, "Y", -1)),
                  ze(et, {
                    modelValue: s.property.value.y,
                    "onUpdate:modelValue": R[3] || (R[3] = (Q) => x("y", Q))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof s.property.value == "number" ? (te(), St(et, {
                key: 3,
                modelValue: s.property.value,
                "onUpdate:modelValue": g,
                precision: 1
              }, null, 8, ["modelValue"])) : Pe("", !0)
            ])
          ])
        ], 6)) : (te(), ae("div", {
          key: 1,
          class: "prop-track",
          onMousedown: S,
          ref_key: "trackRef",
          ref: o
        }, [
          a.value ? (te(), ae("div", {
            key: 0,
            class: "selection-box",
            style: yt(h.value)
          }, null, 4)) : Pe("", !0),
          (te(!0), ae(qe, null, ot(s.property.keyframes, (Q) => (te(), ae("div", {
            key: Q.id,
            class: Fe(["keyframe", { selected: r.value.has(Q.id), [Q.interpolation || "linear"]: !0 }]),
            style: yt({ left: `${Q.frame * s.pixelsPerFrame}px` }),
            onMousedown: xt((le) => b(le, Q), ["stop"]),
            onDblclick: xt((le) => C(Q.id), ["stop"]),
            onContextmenu: xt((le) => T(le, Q), ["prevent", "stop"])
          }, null, 46, W8))), 128)),
          u.value.visible ? (te(), ae("div", {
            key: 1,
            class: "keyframe-context-menu",
            style: yt(d.value)
          }, [
            R[16] || (R[16] = f("div", { class: "menu-header" }, "Interpolation", -1)),
            f("div", {
              class: Fe(["menu-item", { active: ((A = u.value.keyframe) == null ? void 0 : A.interpolation) === "linear" }]),
              onClick: R[4] || (R[4] = (Q) => E("linear"))
            }, [...R[11] || (R[11] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Linear ", -1)
            ])], 2),
            f("div", {
              class: Fe(["menu-item", { active: ((G = u.value.keyframe) == null ? void 0 : G.interpolation) === "bezier" }]),
              onClick: R[5] || (R[5] = (Q) => E("bezier"))
            }, [...R[12] || (R[12] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Bezier ", -1)
            ])], 2),
            f("div", {
              class: Fe(["menu-item", { active: ((ue = u.value.keyframe) == null ? void 0 : ue.interpolation) === "hold" }]),
              onClick: R[6] || (R[6] = (Q) => E("hold"))
            }, [...R[13] || (R[13] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Hold ", -1)
            ])], 2),
            R[17] || (R[17] = f("div", { class: "menu-divider" }, null, -1)),
            f("div", {
              class: "menu-item",
              onClick: y
            }, [...R[14] || (R[14] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Go to Frame ", -1)
            ])]),
            f("div", {
              class: "menu-item delete",
              onClick: w
            }, [...R[15] || (R[15] = [
              f("span", { class: "icon" }, "", -1),
              ct(" Delete ", -1)
            ])])
          ], 4)) : Pe("", !0)
        ], 544))
      ]);
    };
  }
}), ig = /* @__PURE__ */ Gt(X8, [["__scopeId", "data-v-32aca4cb"]]), j8 = {
  key: 0,
  class: "track-wrapper"
}, Y8 = { class: "arrow" }, q8 = { class: "layer-id" }, Z8 = { class: "type-icon" }, K8 = {
  key: 0,
  class: "name-text"
}, J8 = { class: "col-mode" }, Q8 = ["value"], eB = { class: "col-parent" }, tB = ["value"], nB = ["value"], iB = {
  key: 0,
  class: "children-container"
}, sB = ["onMousedown"], rB = { class: "arrow-col" }, oB = { class: "arrow" }, aB = { class: "group-label" }, lB = { key: 0 }, cB = {
  key: 0,
  class: "children-container"
}, uB = { key: 0 }, dB = /* @__PURE__ */ Ot({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we(!1), a = Ie(() => n.isExpandedExternal ?? o.value), l = Ie(() => r.selectedLayerIds.includes(n.layer.id)), c = we(["Transform", "Text", "More Options"]), u = we(!1), d = we(""), h = we(null), m = we(!1), p = we(0), v = we(0), _ = Ie(() => {
      var ie;
      return ((ie = n.allLayers) == null ? void 0 : ie.filter((ce) => ce.id !== n.layer.id)) || [];
    }), g = Ie(() => {
      const ie = {}, ce = n.layer.transform, V = [], Y = (H, I, F) => {
        F && V.push({ path: H, name: I, property: F });
      };
      return Y("transform.anchorPoint", "Anchor Point", ce.anchorPoint), Y("transform.position", "Position", ce.position), n.layer.threeD && V.push({
        path: "transform.position.z",
        name: "Z Position",
        property: ce.position
        // Pass full position property, PropertyTrack handles .z
      }), Y("transform.scale", "Scale", ce.scale), n.layer.threeD ? (ce.orientation && V.push({ path: "transform.orientation", name: "Orientation", property: ce.orientation }), ce.rotationX && V.push({ path: "transform.rotationX", name: "X Rotation", property: ce.rotationX }), ce.rotationY && V.push({ path: "transform.rotationY", name: "Y Rotation", property: ce.rotationY }), ce.rotationZ && V.push({ path: "transform.rotationZ", name: "Z Rotation", property: ce.rotationZ })) : ce.rotation && V.push({ path: "transform.rotation", name: "Rotation", property: ce.rotation }), n.layer.opacity && V.push({ path: "opacity", name: "Opacity", property: n.layer.opacity }), ie.Transform = V, n.layer.properties && n.layer.properties.forEach((H) => {
        const I = H.group || "Properties";
        ie[I] || (ie[I] = []), ie[I].push({ path: H.name, name: H.name, property: H });
      }), ie;
    }), x = Ie(() => {
      const ie = n.pixelsPerFrame || 10;
      return { left: `${n.layer.inPoint * ie}px`, width: `${(n.layer.outPoint - n.layer.inPoint + 1) * ie}px` };
    });
    function M() {
      i("select", n.layer.id);
    }
    function S() {
      i("toggleExpand", n.layer.id, !a.value);
    }
    function b(ie) {
      c.value.includes(ie) ? c.value = c.value.filter((ce) => ce !== ie) : c.value.push(ie);
    }
    function C(ie) {
      return { text: "T", solid: "", camera: "" }[ie] || "";
    }
    function T() {
      u.value = !0, d.value = n.layer.name, Pi(() => {
        var ie;
        return (ie = h.value) == null ? void 0 : ie.focus();
      });
    }
    function P() {
      i("updateLayer", n.layer.id, { name: d.value }), u.value = !1;
    }
    function E(ie) {
      i("updateLayer", n.layer.id, { parentId: ie.target.value || null });
    }
    function y(ie) {
      i("updateLayer", n.layer.id, { blendMode: ie.target.value });
    }
    function w() {
    }
    function D() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function U() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function R() {
    }
    function O() {
      const ie = r.getActiveComp();
      if (!ie) return;
      const ce = {
        anchorPoint: { x: ie.settings.width / 2, y: ie.settings.height / 2 },
        position: { x: ie.settings.width / 2, y: ie.settings.height / 2, z: 0 },
        scale: { x: 100, y: 100 },
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        orientation: { x: 0, y: 0, z: 0 },
        opacity: 100
      }, V = n.layer.transform;
      V.anchorPoint && (V.anchorPoint.value = { ...ce.anchorPoint }), V.position && (V.position.value = n.layer.threeD ? { ...ce.position } : { x: ce.position.x, y: ce.position.y }), V.scale && (V.scale.value = { x: ce.scale.x, y: ce.scale.y }), V.rotation && (V.rotation.value = ce.rotation), V.rotationX && (V.rotationX.value = ce.rotationX), V.rotationY && (V.rotationY.value = ce.rotationY), V.rotationZ && (V.rotationZ.value = ce.rotationZ), V.orientation && (V.orientation.value = { ...ce.orientation }), n.layer.opacity && (n.layer.opacity.value = ce.opacity), r.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[EnhancedLayerTrack] Reset transform for layer:", n.layer.name);
    }
    function A(ie) {
      p.value = ie.clientX, v.value = ie.clientY, m.value = !0, l.value || i("select", n.layer.id);
    }
    function G() {
      m.value = !1;
    }
    function ue() {
      r.duplicateLayer(n.layer.id), G();
    }
    function Q() {
      G(), Pi(() => {
        u.value = !0, d.value = n.layer.name, Pi(() => {
          var ie;
          return (ie = h.value) == null ? void 0 : ie.focus();
        });
      });
    }
    function le() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible }), G();
    }
    function re() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked }), G();
    }
    function j() {
      r.toggleLayer3D(n.layer.id), G();
    }
    function $() {
      r.selectLayer(n.layer.id), r.precomposeSelectedLayers(n.layer.name + " Precomp"), G();
    }
    function q() {
      r.deleteLayer(n.layer.id), G();
    }
    function oe(ie) {
      m.value && G();
    }
    return xn(() => {
      document.addEventListener("click", oe);
    }), Nn(() => {
      document.removeEventListener("click", oe);
    }), (ie, ce) => s.layer ? (te(), ae("div", j8, [
      s.layoutMode === "sidebar" ? (te(), ae(qe, { key: 0 }, [
        f("div", {
          class: Fe(["sidebar-row", { selected: l.value }]),
          style: yt(s.gridStyle),
          onMousedown: M,
          onContextmenu: xt(A, ["prevent"])
        }, [
          f("div", {
            class: "arrow-col",
            onMousedown: xt(S, ["stop"])
          }, [
            f("span", Y8, _e(a.value ? "" : ""), 1)
          ], 32),
          f("div", {
            class: "label-box",
            onMousedown: xt(R, ["stop"]),
            style: yt({ background: s.layer.labelColor || "#999" })
          }, null, 36),
          f("div", q8, _e(s.index), 1),
          f("div", {
            class: "icon-col",
            onMousedown: xt(D, ["stop"])
          }, _e(s.layer.visible ? "" : ""), 33),
          f("div", {
            class: "icon-col",
            onMousedown: xt(U, ["stop"])
          }, _e(s.layer.locked ? "" : ""), 33),
          f("div", {
            class: Fe(["icon-col cube-icon", { active: s.layer.threeD }]),
            onMousedown: ce[0] || (ce[0] = xt((V) => Ve(r).toggleLayer3D(s.layer.id), ["stop"]))
          }, "", 34),
          f("div", {
            class: "layer-name-col",
            onDblclick: xt(T, ["stop"])
          }, [
            f("span", Z8, _e(C(s.layer.type)), 1),
            u.value ? st((te(), ae("input", {
              key: 1,
              "onUpdate:modelValue": ce[1] || (ce[1] = (V) => d.value = V),
              onBlur: P,
              onKeydown: ol(P, ["enter"]),
              class: "rename-input",
              ref_key: "renameInput",
              ref: h
            }, null, 544)), [
              [Ut, d.value]
            ]) : (te(), ae("span", K8, _e(s.layer.name), 1))
          ], 32),
          f("div", J8, [
            f("select", {
              value: s.layer.blendMode,
              class: "mini-select",
              onChange: y,
              onMousedown: ce[2] || (ce[2] = xt(() => {
              }, ["stop"]))
            }, [...ce[5] || (ce[5] = [
              ls('<optgroup label="Normal" data-v-fb7680b0><option value="normal" data-v-fb7680b0>Normal</option><option value="dissolve" data-v-fb7680b0>Dissolve</option></optgroup><optgroup label="Darken" data-v-fb7680b0><option value="darken" data-v-fb7680b0>Darken</option><option value="multiply" data-v-fb7680b0>Multiply</option><option value="colorBurn" data-v-fb7680b0>Color Burn</option><option value="linearBurn" data-v-fb7680b0>Linear Burn</option></optgroup><optgroup label="Lighten" data-v-fb7680b0><option value="add" data-v-fb7680b0>Add</option><option value="lighten" data-v-fb7680b0>Lighten</option><option value="screen" data-v-fb7680b0>Screen</option><option value="colorDodge" data-v-fb7680b0>Color Dodge</option><option value="linearDodge" data-v-fb7680b0>Linear Dodge</option></optgroup><optgroup label="Contrast" data-v-fb7680b0><option value="overlay" data-v-fb7680b0>Overlay</option><option value="softLight" data-v-fb7680b0>Soft Light</option><option value="hardLight" data-v-fb7680b0>Hard Light</option><option value="vividLight" data-v-fb7680b0>Vivid Light</option><option value="linearLight" data-v-fb7680b0>Linear Light</option><option value="pinLight" data-v-fb7680b0>Pin Light</option><option value="hardMix" data-v-fb7680b0>Hard Mix</option></optgroup><optgroup label="Inversion" data-v-fb7680b0><option value="difference" data-v-fb7680b0>Difference</option><option value="exclusion" data-v-fb7680b0>Exclusion</option><option value="subtract" data-v-fb7680b0>Subtract</option><option value="divide" data-v-fb7680b0>Divide</option></optgroup><optgroup label="Component" data-v-fb7680b0><option value="hue" data-v-fb7680b0>Hue</option><option value="saturation" data-v-fb7680b0>Saturation</option><option value="color" data-v-fb7680b0>Color</option><option value="luminosity" data-v-fb7680b0>Luminosity</option></optgroup>', 6)
            ])], 40, Q8)
          ]),
          f("div", eB, [
            f("select", {
              value: s.layer.parentId || "",
              class: "mini-select",
              onChange: E,
              onMousedown: ce[3] || (ce[3] = xt(() => {
              }, ["stop"]))
            }, [
              ce[6] || (ce[6] = f("option", { value: "" }, "None", -1)),
              (te(!0), ae(qe, null, ot(_.value, (V) => (te(), ae("option", {
                key: V.id,
                value: V.id
              }, _e(V.index), 9, nB))), 128))
            ], 40, tB)
          ])
        ], 38),
        a.value ? (te(), ae("div", iB, [
          (te(!0), ae(qe, null, ot(g.value, (V, Y) => (te(), ae("div", {
            key: Y,
            class: "property-group"
          }, [
            f("div", {
              class: "group-header sidebar-row",
              style: yt(s.gridStyle),
              onMousedown: xt((H) => b(Y), ["stop"])
            }, [
              f("div", rB, [
                f("span", oB, _e(c.value.includes(Y) ? "" : ""), 1)
              ]),
              f("div", aB, [
                ct(_e(Y) + " ", 1),
                Y === "Transform" ? (te(), ae("span", {
                  key: 0,
                  class: "reset-link",
                  onClick: xt(O, ["stop"])
                }, "Reset")) : Pe("", !0)
              ])
            ], 44, sB),
            c.value.includes(Y) ? (te(), ae("div", lB, [
              (te(!0), ae(qe, null, ot(V, (H) => (te(), St(ig, {
                key: H.path,
                layerId: s.layer.id,
                propertyPath: H.path,
                name: H.name,
                property: H.property,
                layoutMode: "sidebar",
                gridStyle: s.gridStyle,
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : Pe("", !0)
      ], 64)) : (te(), ae(qe, { key: 1 }, [
        f("div", {
          class: "layer-row track-bg",
          onMousedown: M
        }, [
          f("div", {
            class: "duration-bar",
            style: yt(x.value),
            onMousedown: xt(w, ["stop"])
          }, [
            f("div", {
              class: "bar-fill",
              style: yt({ background: s.layer.labelColor || "#777" })
            }, null, 4)
          ], 36)
        ], 32),
        a.value ? (te(), ae("div", cB, [
          (te(!0), ae(qe, null, ot(g.value, (V, Y) => (te(), ae("div", {
            key: Y,
            class: "property-group"
          }, [
            ce[7] || (ce[7] = f("div", { class: "group-header track-bg" }, null, -1)),
            c.value.includes(Y) ? (te(), ae("div", uB, [
              (te(!0), ae(qe, null, ot(V, (H) => (te(), St(ig, {
                key: H.path,
                layerId: s.layer.id,
                propertyPath: H.path,
                name: H.name,
                property: H.property,
                layoutMode: "track",
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : Pe("", !0)
      ], 64)),
      (te(), St(zo, { to: "body" }, [
        m.value ? (te(), ae("div", {
          key: 0,
          class: "layer-context-menu",
          style: yt({ left: p.value + "px", top: v.value + "px" }),
          onClick: ce[4] || (ce[4] = xt(() => {
          }, ["stop"]))
        }, [
          f("button", { onClick: ue }, "Duplicate Layer"),
          f("button", { onClick: Q }, "Rename"),
          ce[8] || (ce[8] = f("hr", null, null, -1)),
          f("button", { onClick: le }, _e(s.layer.visible ? "Hide" : "Show") + " Layer", 1),
          f("button", { onClick: re }, _e(s.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
          f("button", { onClick: j }, _e(s.layer.threeD ? "Make 2D" : "Make 3D"), 1),
          ce[9] || (ce[9] = f("hr", null, null, -1)),
          f("button", { onClick: $ }, "Pre-compose..."),
          ce[10] || (ce[10] = f("hr", null, null, -1)),
          f("button", {
            onClick: q,
            class: "danger"
          }, "Delete Layer")
        ], 4)) : Pe("", !0)
      ]))
    ])) : Pe("", !0);
  }
}), sg = /* @__PURE__ */ Gt(dB, [["__scopeId", "data-v-fb7680b0"]]), hB = { class: "composition-tabs" }, fB = { class: "tabs-container" }, pB = ["onClick", "onDblclick", "onContextmenu"], mB = {
  key: 0,
  class: "precomp-icon",
  title: "Pre-composition"
}, vB = {
  key: 1,
  class: "tab-name"
}, gB = {
  key: 2,
  class: "tab-name"
}, yB = { class: "tab-info" }, xB = ["onClick"], _B = ["disabled"], bB = ["disabled"], wB = /* @__PURE__ */ Ot({
  __name: "CompositionTabs",
  emits: ["newComposition"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(null), o = we(""), a = we(null), l = we({
      visible: !1,
      x: 0,
      y: 0,
      comp: null
    }), c = Ie(() => i.openCompositions), u = Ie(() => i.activeCompositionId), d = Ie(() => i.project.mainCompositionId);
    function h(y) {
      i.switchComposition(y);
    }
    function m(y) {
      i.closeCompositionTab(y);
    }
    function p(y) {
      const w = y.settings;
      return `${w.width}x${w.height} ${w.fps}fps`;
    }
    function v(y) {
      r.value = y.id, o.value = y.name, Pi(() => {
        var w, D;
        (w = a.value) == null || w.focus(), (D = a.value) == null || D.select();
      });
    }
    function _() {
      r.value && o.value.trim() && i.renameComposition(r.value, o.value.trim()), r.value = null, o.value = "";
    }
    function g() {
      r.value = null, o.value = "";
    }
    function x(y, w) {
      l.value = {
        visible: !0,
        x: y.clientX,
        y: y.clientY,
        comp: w
      };
    }
    function M() {
      l.value.visible = !1, l.value.comp = null;
    }
    function S() {
      l.value.comp && v(l.value.comp), M();
    }
    function b() {
      if (l.value.comp) {
        const y = l.value.comp, w = i.createComposition(
          `${y.name} Copy`,
          y.settings,
          y.isPrecomp
        );
        console.log("[CompositionTabs] Duplicated:", w.name);
      }
      M();
    }
    function C() {
      l.value.comp && i.switchComposition(l.value.comp.id), M();
    }
    function T() {
      l.value.comp && (i.project.mainCompositionId = l.value.comp.id, console.log("[CompositionTabs] Set main composition:", l.value.comp.name)), M();
    }
    function P() {
      l.value.comp && l.value.comp.id !== d.value && i.deleteComposition(l.value.comp.id), M();
    }
    function E() {
      l.value.visible && M();
    }
    return xn(() => {
      document.addEventListener("click", E);
    }), Nn(() => {
      document.removeEventListener("click", E);
    }), (y, w) => {
      var D, U;
      return te(), ae("div", hB, [
        f("div", fB, [
          (te(!0), ae(qe, null, ot(c.value, (R) => (te(), ae("div", {
            key: R.id,
            class: Fe(["tab", {
              active: R.id === u.value,
              precomp: R.isPrecomp
            }]),
            onClick: (O) => h(R.id),
            onDblclick: (O) => v(R),
            onContextmenu: xt((O) => x(O, R), ["prevent"])
          }, [
            R.isPrecomp ? (te(), ae("span", mB, "")) : Pe("", !0),
            r.value === R.id ? (te(), ae("span", vB, [
              st(f("input", {
                ref_for: !0,
                ref_key: "renameInput",
                ref: a,
                "onUpdate:modelValue": w[0] || (w[0] = (O) => o.value = O),
                type: "text",
                class: "rename-input",
                onBlur: _,
                onKeydown: [
                  ol(_, ["enter"]),
                  ol(g, ["escape"])
                ],
                onClick: w[1] || (w[1] = xt(() => {
                }, ["stop"]))
              }, null, 544), [
                [Ut, o.value]
              ])
            ])) : (te(), ae("span", gB, _e(R.name), 1)),
            f("span", yB, _e(p(R)), 1),
            c.value.length > 1 ? (te(), ae("button", {
              key: 3,
              class: "close-btn",
              onClick: xt((O) => m(R.id), ["stop"]),
              title: "Close tab"
            }, "  ", 8, xB)) : Pe("", !0)
          ], 42, pB))), 128)),
          f("button", {
            class: "new-comp-btn",
            onClick: w[2] || (w[2] = (R) => n("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (te(), St(zo, { to: "body" }, [
          l.value.visible ? (te(), ae("div", {
            key: 0,
            class: "context-menu",
            style: yt({ left: l.value.x + "px", top: l.value.y + "px" }),
            onClick: w[3] || (w[3] = xt(() => {
            }, ["stop"]))
          }, [
            f("button", { onClick: S }, "Rename"),
            f("button", { onClick: b }, "Duplicate"),
            f("button", { onClick: C }, "Open in New Tab"),
            w[4] || (w[4] = f("hr", null, null, -1)),
            f("button", {
              onClick: T,
              disabled: ((D = l.value.comp) == null ? void 0 : D.id) === d.value
            }, " Set as Main Composition ", 8, _B),
            w[5] || (w[5] = f("hr", null, null, -1)),
            f("button", {
              onClick: P,
              disabled: ((U = l.value.comp) == null ? void 0 : U.id) === d.value,
              class: "danger"
            }, " Delete Composition ", 8, bB)
          ], 4)) : Pe("", !0)
        ]))
      ]);
    };
  }
}), SB = /* @__PURE__ */ Gt(wB, [["__scopeId", "data-v-c032dfe4"]]), MB = { class: "timeline-header" }, CB = { class: "header-left" }, TB = { class: "timecode" }, EB = { class: "frame-display" }, AB = ["value"], PB = { class: "fps-label" }, RB = { class: "header-center" }, DB = {
  key: 0,
  class: "add-layer-menu"
}, kB = { class: "tool-group" }, IB = ["disabled"], LB = { class: "header-right" }, FB = { class: "timeline-content" }, UB = /* @__PURE__ */ Ot({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(10), o = we(450), a = we({}), l = we(!1), c = we(null), u = we(null), d = we(null), h = we(null), m = we(null), p = we(null);
    let v = !1, _ = !1;
    const g = we(1e3), x = Ie(() => i.layers || []), M = Ie(() => i.currentFrame * r.value), S = Ie(() => {
      const $ = i.frameCount * r.value;
      return Math.max($, g.value) + "px";
    }), b = Ie(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function C() {
      l.value = !l.value;
    }
    function T($) {
      $ === "text" ? i.createTextLayer() : $ === "video" ? i.createLayer("video") : $ === "camera" ? i.createCameraLayer() : i.createLayer($), l.value = !1;
    }
    function P($) {
      i.selectLayer($);
    }
    function E($, q) {
      i.updateLayer($, q);
    }
    function y() {
      i.selectedLayerIds.forEach(($) => i.deleteLayer($));
    }
    function w($) {
      i.setFrame(parseInt($.target.value) || 0);
    }
    function D() {
      i.togglePlayback();
    }
    function U($, q) {
      a.value[$] = q;
    }
    function R($) {
      const q = i.fps, oe = Math.floor($ / q), ie = Math.floor($ % q), ce = oe % 60, V = Math.floor(oe / 60) % 60, Y = Math.floor(oe / 3600), H = (I, F = 2) => String(I).padStart(F, "0");
      return `${H(Y)};${H(V)};${H(ce)};${H(ie)}`;
    }
    function O() {
      const $ = d.value;
      if (!$) return;
      const q = $.getContext("2d");
      if (!q) return;
      const oe = i.frameCount * r.value, ie = Math.max(oe, g.value);
      $.width = ie, $.height = 30, q.fillStyle = "#222", q.fillRect(0, 0, $.width, $.height), q.strokeStyle = "#666", q.fillStyle = "#aaa", q.font = "11px sans-serif";
      const ce = r.value;
      let V, Y;
      ce >= 20 ? (V = 1, Y = 0) : ce >= 10 ? (V = 5, Y = 1) : ce >= 5 ? (V = 10, Y = 5) : ce >= 2 ? (V = 20, Y = 10) : ce >= 1 ? (V = 50, Y = 25) : ce >= 0.5 ? (V = 100, Y = 50) : (V = 200, Y = 0);
      for (let H = 0; H <= i.frameCount; H++) {
        const I = H * ce;
        if (H % V === 0) {
          q.strokeStyle = "#888", q.beginPath(), q.moveTo(I, 12), q.lineTo(I, 30), q.stroke();
          const F = String(H), L = q.measureText(F), ee = (H + V) * ce, Z = L.width + 20;
          (ee - I >= Z || H === 0 || H >= i.frameCount - V) && (q.fillStyle = "#ccc", q.fillText(F, I + 3, 10));
        } else Y > 0 && H % Y === 0 && (q.strokeStyle = "#555", q.beginPath(), q.moveTo(I, 22), q.lineTo(I, 30), q.stroke());
      }
      q.strokeStyle = "#444", q.beginPath(), q.moveTo(0, 29.5), q.lineTo($.width, 29.5), q.stroke();
    }
    function A($) {
      var ie, ce;
      const q = d.value.getBoundingClientRect();
      (ie = p.value) != null && ie.scrollLeft || (ce = m.value) != null && ce.scrollLeft;
      const oe = (V) => {
        var F, L;
        const Y = ((F = p.value) == null ? void 0 : F.scrollLeft) || ((L = m.value) == null ? void 0 : L.scrollLeft) || 0, H = V.clientX - q.left + Y;
        let I = Math.max(0, Math.min(i.frameCount - 1, H / r.value));
        if (!V.altKey && i.snapConfig.enabled) {
          const ee = Kf(Math.round(I), i.snapConfig, r.value, {
            layers: i.layers,
            audioAnalysis: i.audioAnalysis,
            peakData: i.peakData
          });
          ee && (I = ee.frame);
        }
        i.setFrame(Math.round(I));
      };
      oe($), window.addEventListener("mousemove", oe), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", oe), { once: !0 });
    }
    function G($) {
      const q = $.clientX, oe = o.value, ie = (ce) => {
        o.value = Math.max(300, oe + (ce.clientX - q));
      };
      window.addEventListener("mousemove", ie), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", ie), { once: !0 });
    }
    function ue($) {
      if (_) return;
      v = !0;
      const q = $.target;
      m.value && (m.value.scrollTop = q.scrollTop), requestAnimationFrame(() => {
        v = !1;
      });
    }
    function Q($) {
      const q = $.target;
      v || (_ = !0, h.value && (h.value.scrollTop = q.scrollTop), requestAnimationFrame(() => {
        _ = !1;
      })), p.value && (p.value.scrollLeft = q.scrollLeft);
    }
    function le($) {
      const q = $.target;
      m.value && (m.value.scrollLeft = q.scrollLeft);
    }
    function re($) {
      if (!($.target instanceof HTMLInputElement || $.target instanceof HTMLTextAreaElement) && ($.code === "Space" && ($.preventDefault(), D()), ($.code === "Delete" || $.code === "Backspace") && ($.preventDefault(), y()), ($.ctrlKey || $.metaKey) && $.code === "KeyC" && ($.preventDefault(), i.copySelectedLayers()), ($.ctrlKey || $.metaKey) && $.code === "KeyX" && ($.preventDefault(), i.cutSelectedLayers()), ($.ctrlKey || $.metaKey) && $.code === "KeyV" && ($.preventDefault(), i.pasteLayers()), ($.ctrlKey || $.metaKey) && $.code === "KeyA" && ($.preventDefault(), i.selectedLayerIds = i.layers.map((q) => q.id)), ($.ctrlKey || $.metaKey) && $.code === "KeyD")) {
        $.preventDefault();
        for (const q of i.selectedLayerIds)
          i.duplicateLayer(q);
      }
    }
    let j = null;
    return xn(() => {
      window.addEventListener("mousedown", (q) => {
        c.value && !c.value.contains(q.target) && (l.value = !1);
      });
      const $ = m.value || u.value;
      $ && (j = new ResizeObserver((q) => {
        for (const oe of q)
          g.value = oe.contentRect.width, O();
      }), j.observe($)), setTimeout(O, 100);
    }), Nn(() => {
      j && j.disconnect();
    }), Ft(() => [S.value, r.value, i.frameCount], () => Pi(O)), ($, q) => (te(), ae("div", {
      class: "timeline-panel",
      tabindex: "0",
      onKeydown: re
    }, [
      ze(SB, {
        onNewComposition: q[0] || (q[0] = (oe) => n("openCompositionSettings"))
      }),
      f("div", MB, [
        f("div", CB, [
          f("span", TB, _e(R(Ve(i).currentFrame)), 1),
          f("div", EB, [
            f("input", {
              type: "number",
              value: Ve(i).currentFrame,
              onChange: w,
              class: "frame-input"
            }, null, 40, AB),
            f("span", PB, _e(Ve(i).fps) + " fps", 1)
          ])
        ]),
        f("div", RB, [
          f("div", {
            class: "tool-group add-layer-wrapper",
            ref_key: "addLayerContainer",
            ref: c
          }, [
            f("button", {
              class: Fe(["add-layer-btn", { active: l.value }]),
              onMousedown: xt(C, ["stop", "prevent"])
            }, [...q[9] || (q[9] = [
              f("span", { class: "icon" }, "+", -1),
              ct(" Layer ", -1)
            ])], 34),
            l.value ? (te(), ae("div", DB, [
              f("button", {
                onMousedown: q[1] || (q[1] = (oe) => T("solid"))
              }, [...q[10] || (q[10] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Solid", -1)
              ])], 32),
              f("button", {
                onMousedown: q[2] || (q[2] = (oe) => T("text"))
              }, [...q[11] || (q[11] = [
                f("span", { class: "icon" }, "T", -1),
                ct(" Text", -1)
              ])], 32),
              f("button", {
                onMousedown: q[3] || (q[3] = (oe) => T("spline"))
              }, [...q[12] || (q[12] = [
                f("span", { class: "icon" }, "~", -1),
                ct(" Shape", -1)
              ])], 32),
              f("button", {
                onMousedown: q[4] || (q[4] = (oe) => T("null"))
              }, [...q[13] || (q[13] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Null", -1)
              ])], 32),
              f("button", {
                onMousedown: q[5] || (q[5] = (oe) => T("camera"))
              }, [...q[14] || (q[14] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Camera", -1)
              ])], 32),
              f("button", {
                onMousedown: q[6] || (q[6] = (oe) => T("light"))
              }, [...q[15] || (q[15] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Light", -1)
              ])], 32),
              f("button", {
                onMousedown: q[7] || (q[7] = (oe) => T("video"))
              }, [...q[16] || (q[16] = [
                f("span", { class: "icon" }, "", -1),
                ct(" Video", -1)
              ])], 32)
            ])) : Pe("", !0)
          ], 512),
          f("div", kB, [
            f("button", {
              class: "delete-btn",
              onClick: y,
              disabled: Ve(i).selectedLayerIds.length === 0
            }, "", 8, IB)
          ])
        ]),
        f("div", LB, [
          st(f("input", {
            type: "range",
            min: "0.1",
            max: "50",
            step: "0.1",
            "onUpdate:modelValue": q[8] || (q[8] = (oe) => r.value = oe),
            class: "zoom-slider",
            title: "Zoom Timeline"
          }, null, 512), [
            [
              Ut,
              r.value,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      f("div", FB, [
        f("div", {
          class: "timeline-sidebar",
          style: yt({ width: o.value + "px" })
        }, [
          q[17] || (q[17] = ls('<div class="sidebar-header-row" data-v-0c0bcb17><div class="col-header col-arrow" data-v-0c0bcb17></div><div class="col-header col-name" data-v-0c0bcb17>Layer Name</div><div class="col-header col-mode" data-v-0c0bcb17>Mode</div><div class="col-header col-parent" data-v-0c0bcb17>Parent</div></div>', 1)),
          f("div", {
            class: "sidebar-scroll-area",
            ref_key: "sidebarScrollRef",
            ref: h,
            onScroll: ue
          }, [
            (te(!0), ae(qe, null, ot(x.value, (oe, ie) => (te(), St(sg, {
              key: oe.id,
              layer: oe,
              index: ie + 1,
              layoutMode: "sidebar",
              isExpandedExternal: a.value[oe.id],
              allLayers: Ve(i).layers,
              gridStyle: b.value,
              onToggleExpand: U,
              onSelect: P,
              onUpdateLayer: E
            }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]))), 128))
          ], 544)
        ], 4),
        f("div", {
          class: "sidebar-resizer",
          onMousedown: G
        }, null, 32),
        f("div", {
          class: "track-viewport",
          ref_key: "trackViewportRef",
          ref: u
        }, [
          f("div", {
            class: "ruler-scroll-wrapper",
            onScroll: le,
            ref_key: "rulerScrollRef",
            ref: p
          }, [
            f("div", {
              class: "time-ruler",
              style: yt({ width: S.value }),
              onMousedown: A
            }, [
              f("canvas", {
                ref_key: "rulerCanvas",
                ref: d,
                height: "30"
              }, null, 512),
              f("div", {
                class: "playhead-head",
                style: yt({ left: M.value + "px" })
              }, null, 4),
              f("div", {
                class: "playhead-hit-area",
                style: yt({ left: M.value + "px" }),
                onMousedown: xt(A, ["stop"])
              }, null, 36)
            ], 36)
          ], 544),
          f("div", {
            class: "track-scroll-area",
            ref_key: "trackScrollRef",
            ref: m,
            onScroll: Q
          }, [
            f("div", {
              class: "layer-bars-container",
              style: yt({ width: S.value })
            }, [
              q[18] || (q[18] = f("div", { class: "grid-background" }, null, -1)),
              (te(!0), ae(qe, null, ot(x.value, (oe) => (te(), St(sg, {
                key: oe.id,
                layer: oe,
                layoutMode: "track",
                frameCount: Ve(i).frameCount,
                pixelsPerFrame: r.value,
                isExpandedExternal: a.value[oe.id],
                onSelect: P,
                onUpdateLayer: E
              }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]))), 128)),
              f("div", {
                class: "playhead-line",
                style: yt({ left: M.value + "px" })
              }, null, 4)
            ], 4)
          ], 544)
        ], 512)
      ])
    ], 32));
  }
}), rg = /* @__PURE__ */ Gt(UB, [["__scopeId", "data-v-0c0bcb17"]]), OB = { class: "graph-editor" }, zB = { class: "graph-header" }, NB = { class: "mode-toggle" }, BB = { class: "preset-buttons" }, VB = ["onClick", "title"], GB = { class: "toolbar" }, HB = { class: "graph-content" }, $B = { class: "property-list" }, WB = { class: "property-list-header" }, XB = ["title"], jB = ["onClick"], YB = ["onClick"], qB = { class: "property-name" }, ZB = {
  key: 0,
  class: "keyframe-count"
}, KB = {
  key: 0,
  class: "dimension-toggles"
}, JB = ["onClick"], QB = {
  key: 0,
  class: "no-properties"
}, eV = { class: "graph-main" }, tV = ["viewBox"], nV = ["onMousedown"], iV = ["x", "y", "fill", "transform"], sV = {
  key: 1,
  class: "bezier-handles"
}, rV = {
  key: 0,
  class: "handle out-handle"
}, oV = ["x1", "y1", "x2", "y2"], aV = ["cx", "cy", "onMousedown"], lV = {
  key: 1,
  class: "handle in-handle"
}, cV = ["x1", "y1", "x2", "y2"], uV = ["cx", "cy", "onMousedown"], dV = ["x1", "x2", "y2"], hV = {
  key: 0,
  class: "keyframe-info-panel"
}, fV = { class: "info-row" }, pV = ["value"], mV = { class: "info-row" }, vV = ["value"], gV = { class: "info-row" }, yV = ["value"], xV = ["disabled"], _V = ["disabled"], bV = ["disabled"], wV = /* @__PURE__ */ Ot({
  __name: "GraphEditor",
  emits: ["close"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = we(null), o = we(null), a = we(null), l = we(null), c = we(null), u = we(null), d = we(400), h = we(200), m = we("value"), p = $r({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), v = we([]), _ = we([]), g = we({}), x = we([]), M = we(null), S = we(null), b = we(null), C = we(null), T = we(null), P = we(!1), E = we(!0), y = { top: 10, right: 10, bottom: 10, left: 10 }, w = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, D = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], U = Ie(() => {
      const pe = i.selectedLayer;
      if (!pe) return [];
      const xe = [];
      return xe.push(pe.transform.position), xe.push(pe.transform.scale), xe.push(pe.transform.rotation), xe.push(pe.opacity), xe.push(...pe.properties), xe;
    }), R = Ie(() => U.value.filter(
      (pe) => _.value.includes(pe.id) && pe.animated
    )), O = Ie(() => U.value.every((pe) => _.value.includes(pe.id))), A = Ie(() => G(i.currentFrame));
    function G(pe) {
      const xe = d.value - y.left - y.right, Te = (pe - p.frameStart) / (p.frameEnd - p.frameStart);
      return y.left + Te * xe;
    }
    function ue(pe) {
      const xe = d.value - y.left - y.right, Te = (pe - y.left) / xe;
      return p.frameStart + Te * (p.frameEnd - p.frameStart);
    }
    function Q(pe) {
      const xe = h.value - y.top - y.bottom, Te = (pe - p.valueMin) / (p.valueMax - p.valueMin);
      return h.value - y.bottom - Te * xe;
    }
    function le(pe) {
      const xe = h.value - y.top - y.bottom, Te = (h.value - y.bottom - pe) / xe;
      return p.valueMin + Te * (p.valueMax - p.valueMin);
    }
    function re(pe) {
      return G(pe.frame);
    }
    function j(pe, xe) {
      const Te = typeof xe.value == "number" ? xe.value : typeof xe.value == "object" ? xe.value.x ?? xe.value : 0;
      return Q(Te);
    }
    function $(pe) {
      if (!pe) return 0;
      const xe = pe.keyframe.value;
      return typeof xe == "number" ? xe : typeof xe == "object" ? xe.x ?? 0 : 0;
    }
    function q(pe, xe) {
      const Te = pe.keyframes[xe];
      if (!Te || !Te.outHandle.enabled) return G(Te.frame);
      const Ue = Te.frame + Te.outHandle.frame;
      return G(Ue);
    }
    function oe(pe, xe) {
      const Te = pe.keyframes[xe];
      if (!Te || !Te.outHandle.enabled) return Q(V(Te.value));
      const Ue = V(Te.value) + Te.outHandle.value;
      return Q(Ue);
    }
    function ie(pe, xe) {
      const Te = pe.keyframes[xe];
      if (!Te || !Te.inHandle.enabled) return G(Te.frame);
      const Ue = Te.frame + Te.inHandle.frame;
      return G(Ue);
    }
    function ce(pe, xe) {
      const Te = pe.keyframes[xe];
      if (!Te || !Te.inHandle.enabled) return Q(V(Te.value));
      const Ue = V(Te.value) + Te.inHandle.value;
      return Q(Ue);
    }
    function V(pe) {
      return typeof pe == "number" ? pe : typeof pe == "object" ? pe.x ?? pe.y ?? pe.z ?? 0 : 0;
    }
    function Y(pe) {
      const xe = U.value.find((Te) => Te.id === pe);
      return xe ? w[xe.name] ?? w.default : w.default;
    }
    function H(pe) {
      return pe.frame >= p.frameStart && pe.frame <= p.frameEnd;
    }
    function I(pe, xe) {
      return x.value.some((Te) => Te.propId === pe && Te.index === xe);
    }
    function F(pe, xe) {
      if (!pe.animated || pe.keyframes.length === 0) return !1;
      const Te = pe.keyframes[0].value;
      return typeof Te == "object" && xe in Te;
    }
    function L(pe) {
      const xe = v.value.indexOf(pe);
      xe === -1 ? v.value.push(pe) : v.value.splice(xe, 1);
    }
    function ee(pe) {
      const xe = _.value.indexOf(pe);
      xe === -1 ? _.value.push(pe) : _.value.splice(xe, 1), J();
    }
    function Z() {
      O.value ? _.value = [] : _.value = U.value.map((pe) => pe.id), J();
    }
    function k(pe, xe) {
      g.value[pe] || (g.value[pe] = []);
      const Te = g.value[pe], Ue = Te.indexOf(xe);
      Ue === -1 ? Te.push(xe) : Te.splice(Ue, 1);
    }
    function ne() {
      const pe = R.value;
      if (pe.length === 0) return;
      let xe = 1 / 0, Te = -1 / 0, Ue = 1 / 0, W = -1 / 0;
      for (const Ce of pe)
        for (const be of Ce.keyframes) {
          xe = Math.min(xe, be.frame), Te = Math.max(Te, be.frame);
          const ke = V(be.value);
          Ue = Math.min(Ue, ke), W = Math.max(W, ke);
        }
      const ve = (Te - xe) * 0.1 || 10, ye = (W - Ue) * 0.1 || 10;
      p.frameStart = xe - ve, p.frameEnd = Te + ve, p.valueMin = Ue - ye, p.valueMax = W + ye;
    }
    function J() {
      ne();
    }
    function B() {
      E.value = !E.value;
    }
    function X(pe) {
      return x.value.length === 0 || !au[pe] ? !1 : pe === "linear" ? x.value.every((Te) => Te.keyframe.interpolation === "linear") : x.value.every((Te) => Te.keyframe.interpolation === "bezier");
    }
    function se(pe) {
      const xe = au[pe];
      if (!xe) return;
      const Te = i.selectedLayer;
      if (Te) {
        for (const Ue of x.value) {
          const W = U.value.find((Qe) => Qe.id === Ue.propId);
          if (!W) continue;
          const ve = Ae(W), ye = Ue.index, Ce = ye > 0 ? W.keyframes[ye - 1] : null, be = ye < W.keyframes.length - 1 ? W.keyframes[ye + 1] : null, ke = Ce ? Ue.keyframe.frame - Ce.frame : 10, De = be ? be.frame - Ue.keyframe.frame : 10;
          if (pe === "linear")
            i.setKeyframeInterpolation(Te.id, ve, Ue.keyframe.id, "linear"), Ue.keyframe.interpolation = "linear", Ue.keyframe.outHandle = { frame: De * 0.33, value: 0, enabled: !1 }, Ue.keyframe.inHandle = { frame: -ke * 0.33, value: 0, enabled: !1 };
          else {
            const Qe = {
              frame: xe.outHandle.x * De,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            }, it = {
              frame: -xe.inHandle.x * ke,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            };
            i.setKeyframeInterpolation(Te.id, ve, Ue.keyframe.id, "bezier"), i.setKeyframeHandle(Te.id, ve, Ue.keyframe.id, "out", Qe), i.setKeyframeHandle(Te.id, ve, Ue.keyframe.id, "in", it), Ue.keyframe.interpolation = "bezier", Ue.keyframe.outHandle = Qe, Ue.keyframe.inHandle = it;
          }
        }
        at();
      }
    }
    function z(pe) {
      var W;
      const xe = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!xe) return;
      const Te = pe.clientX - xe.left, Ue = pe.clientY - xe.top;
      pe.button === 1 || pe.button === 0 && pe.altKey ? S.value = { type: "pan", startX: Te, startY: Ue } : pe.button === 0 && (pe.shiftKey || (x.value = []), b.value = { x: Te, y: Ue, width: 0, height: 0 }, S.value = { type: "select", startX: Te, startY: Ue });
    }
    function N(pe) {
      var W;
      const xe = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!xe) return;
      const Te = pe.clientX - xe.left, Ue = pe.clientY - xe.top;
      if (me(Te, Ue), !!S.value)
        if (S.value.type === "pan") {
          const ve = Te - (S.value.startX ?? 0), ye = Ue - (S.value.startY ?? 0), Ce = d.value - y.left - y.right, be = h.value - y.top - y.bottom, ke = -ve / Ce * (p.frameEnd - p.frameStart), De = ye / be * (p.valueMax - p.valueMin);
          p.frameStart += ke, p.frameEnd += ke, p.valueMin += De, p.valueMax += De, S.value.startX = Te, S.value.startY = Ue, at();
        } else if (S.value.type === "select" && b.value) {
          const ve = S.value.startX ?? 0, ye = S.value.startY ?? 0;
          b.value = {
            x: Math.min(Te, ve),
            y: Math.min(Ue, ye),
            width: Math.abs(Te - ve),
            height: Math.abs(Ue - ye)
          };
        } else S.value.type === "keyframe" ? Ee(Te, Ue) : (S.value.type === "outHandle" || S.value.type === "inHandle") && He(Te, Ue);
    }
    function K() {
      var pe;
      ((pe = S.value) == null ? void 0 : pe.type) === "select" && b.value && Me(), S.value = null, b.value = null;
    }
    function he(pe) {
      var Ce;
      pe.preventDefault();
      const xe = (Ce = r.value) == null ? void 0 : Ce.getBoundingClientRect();
      if (!xe) return;
      const Te = pe.clientX - xe.left, Ue = pe.deltaY > 0 ? 1.1 : 0.9, W = ue(Te), ve = W - (W - p.frameStart) * Ue, ye = W + (p.frameEnd - W) * Ue;
      if (pe.shiftKey)
        p.frameStart = ve, p.frameEnd = ye;
      else {
        p.frameStart = ve, p.frameEnd = ye;
        const be = pe.clientY - xe.top, ke = le(be);
        p.valueMin = ke - (ke - p.valueMin) * Ue, p.valueMax = ke + (p.valueMax - ke) * Ue;
      }
      at();
    }
    function me(pe, xe) {
      M.value = null;
      for (const Te of R.value)
        for (let Ue = 0; Ue < Te.keyframes.length; Ue++) {
          const W = Te.keyframes[Ue], ve = re(W), ye = j(Te, W);
          if (Math.sqrt((pe - ve) ** 2 + (xe - ye) ** 2) < 10) {
            M.value = { propId: Te.id, index: Ue };
            return;
          }
        }
    }
    function ge(pe, xe, Te) {
      const Ue = U.value.find((ve) => ve.id === pe);
      if (!Ue) return;
      const W = Ue.keyframes[xe];
      Te.shiftKey || (x.value = []), I(pe, xe) || x.value.push({ propId: pe, index: xe, keyframe: W }), S.value = { type: "keyframe", propId: pe, index: xe };
    }
    function Me() {
      if (!b.value) return;
      const pe = b.value;
      for (const xe of R.value)
        for (let Te = 0; Te < xe.keyframes.length; Te++) {
          const Ue = xe.keyframes[Te], W = re(Ue), ve = j(xe, Ue);
          W >= pe.x && W <= pe.x + pe.width && ve >= pe.y && ve <= pe.y + pe.height && (I(xe.id, Te) || x.value.push({ propId: xe.id, index: Te, keyframe: Ue }));
        }
    }
    function Ee(pe, xe) {
      const Te = Math.round(ue(pe)), Ue = le(xe), W = i.selectedLayer;
      if (W) {
        if (x.value.length > 0) {
          const ve = x.value[0], ye = U.value.find((ke) => ke.id === ve.propId);
          if (!ye) return;
          const Ce = P.value ? Math.round(Te / 5) * 5 : Te;
          typeof ve.keyframe.value == "number" || ve.keyframe.value;
          const be = Ae(ye);
          i.updateKeyframe(W.id, be, ve.keyframe.id, {
            frame: Ce,
            value: typeof ve.keyframe.value == "number" ? Ue : void 0
          }), ve.keyframe.frame = Ce, typeof ve.keyframe.value == "number" && (ve.keyframe.value = Ue);
        }
        at();
      }
    }
    function Ae(pe) {
      const xe = pe.name.toLowerCase();
      return xe === "position" ? "transform.position" : xe === "scale" ? "transform.scale" : xe === "rotation" ? "transform.rotation" : xe === "opacity" ? "opacity" : xe === "anchor point" ? "transform.anchorPoint" : pe.id;
    }
    function Xe(pe, xe, Te, Ue) {
      S.value = { type: pe, propId: xe, index: Te }, document.addEventListener("mousemove", Oe), document.addEventListener("mouseup", $e);
    }
    function Oe(pe) {
      var W;
      const xe = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!xe || !S.value) return;
      const Te = pe.clientX - xe.left, Ue = pe.clientY - xe.top;
      He(Te, Ue);
    }
    function He(pe, xe) {
      if (!S.value || !S.value.propId) return;
      const Te = i.selectedLayer;
      if (!Te) return;
      const Ue = U.value.find((ke) => ke.id === S.value.propId);
      if (!Ue) return;
      const W = S.value.index, ve = Ue.keyframes[W];
      if (!ve) return;
      const ye = ue(pe), Ce = le(xe), be = Ae(Ue);
      if (S.value.type === "outHandle") {
        const ke = Ue.keyframes[W + 1];
        let De = ye - ve.frame;
        ke ? De = Math.max(0, Math.min(ke.frame - ve.frame, De)) : De = Math.max(0, De);
        const Qe = Ce - V(ve.value), it = {
          frame: De,
          value: Qe,
          enabled: !0
        };
        i.setKeyframeHandle(Te.id, be, ve.id, "out", it), ve.outHandle = it, ve.interpolation = "bezier", Ye(ve, "out", be);
      } else if (S.value.type === "inHandle") {
        const ke = Ue.keyframes[W - 1];
        let De = ye - ve.frame;
        ke ? De = Math.min(0, Math.max(ke.frame - ve.frame, De)) : De = Math.min(0, De);
        const Qe = Ce - V(ve.value), it = {
          frame: De,
          value: Qe,
          enabled: !0
        };
        i.setKeyframeHandle(Te.id, be, ve.id, "in", it), ve.inHandle = it, Ye(ve, "in", be);
      }
      at();
    }
    function Ye(pe, xe, Te) {
      if (!pe.controlMode || pe.controlMode === "corner")
        return;
      const Ue = i.selectedLayer;
      if (Ue && (pe.controlMode === "symmetric" && (xe === "in" ? (pe.outHandle.frame = -pe.inHandle.frame, pe.outHandle.value = -pe.inHandle.value, pe.outHandle.enabled = pe.inHandle.enabled, i.setKeyframeHandle(Ue.id, Te, pe.id, "out", { ...pe.outHandle })) : (pe.inHandle.frame = -pe.outHandle.frame, pe.inHandle.value = -pe.outHandle.value, pe.inHandle.enabled = pe.outHandle.enabled, i.setKeyframeHandle(Ue.id, Te, pe.id, "in", { ...pe.inHandle }))), pe.controlMode === "smooth")) {
        const W = xe === "in" ? pe.inHandle : pe.outHandle, ve = xe === "in" ? pe.outHandle : pe.inHandle, ye = xe === "in" ? "out" : "in";
        if (W.frame !== 0 || W.value !== 0) {
          const be = Math.atan2(W.value, W.frame) + Math.PI, ke = Math.hypot(ve.frame, ve.value);
          ve.frame = Math.cos(be) * ke, ve.value = Math.sin(be) * ke, i.setKeyframeHandle(Ue.id, Te, pe.id, ye, { ...ve });
        }
      }
    }
    function $e() {
      S.value = null, document.removeEventListener("mousemove", Oe), document.removeEventListener("mouseup", $e);
    }
    function Le(pe) {
      C.value = { x: pe.offsetX, y: pe.offsetY };
    }
    function nt() {
      if (!C.value) return;
      const pe = i.selectedLayer;
      if (!pe) return;
      const xe = Math.round(ue(C.value.x)), Te = le(C.value.y);
      if (R.value.length > 0) {
        const Ue = R.value[0], W = Ae(Ue), ve = typeof Ue.value == "number" ? Te : { x: Te, y: Te };
        i.addKeyframe(pe.id, W, ve, xe), at();
      }
      C.value = null;
    }
    function Je() {
      const pe = i.selectedLayer;
      if (pe) {
        for (const xe of x.value) {
          const Te = U.value.find((Ue) => Ue.id === xe.propId);
          if (Te) {
            const Ue = Ae(Te);
            i.removeKeyframe(pe.id, Ue, xe.keyframe.id);
          }
        }
        x.value = [], at();
      }
    }
    function bt() {
      T.value = x.value.map((pe) => ({ ...pe.keyframe }));
    }
    function Se() {
      var W, ve;
      if (!T.value || R.value.length === 0) return;
      const pe = i.selectedLayer;
      if (!pe) return;
      const xe = R.value[0], Te = Ae(xe), Ue = i.currentFrame - T.value[0].frame;
      for (const ye of T.value) {
        const Ce = ye.frame + Ue, be = i.addKeyframe(pe.id, Te, ye.value, Ce);
        be && (ye.interpolation !== "linear" && i.setKeyframeInterpolation(pe.id, Te, be.id, ye.interpolation), (W = ye.inHandle) != null && W.enabled && i.setKeyframeHandle(pe.id, Te, be.id, "in", ye.inHandle), (ve = ye.outHandle) != null && ve.enabled && i.setKeyframeHandle(pe.id, Te, be.id, "out", ye.outHandle));
      }
      at();
    }
    function Ne() {
      x.value = [];
      for (const pe of R.value)
        for (let xe = 0; xe < pe.keyframes.length; xe++)
          x.value.push({ propId: pe.id, index: xe, keyframe: pe.keyframes[xe] });
    }
    function Re() {
      const pe = [];
      for (const xe of R.value)
        for (let Te = 0; Te < xe.keyframes.length; Te++)
          I(xe.id, Te) || pe.push({ propId: xe.id, index: Te, keyframe: xe.keyframes[Te] });
      x.value = pe;
    }
    function Be(pe) {
      const xe = parseInt(pe.target.value);
      x.value.length > 0 && !isNaN(xe) && (x.value[0].keyframe.frame = xe, at());
    }
    function je(pe) {
      const xe = parseFloat(pe.target.value);
      if (x.value.length > 0 && !isNaN(xe)) {
        const Te = x.value[0].keyframe;
        typeof Te.value == "number" ? Te.value = xe : typeof Te.value == "object" && (Te.value.x = xe), at();
      }
    }
    function Ge(pe) {
      const xe = pe.target.value;
      x.value.length > 0 && (x.value[0].keyframe.interpolation = xe, at());
    }
    function ut(pe) {
      var W;
      const xe = (W = l.value) == null ? void 0 : W.getBoundingClientRect();
      if (!xe) return;
      const Te = pe.clientX - xe.left, Ue = Math.round(ue(Te));
      i.setFrame(Ue);
    }
    function at() {
      dt(), rn(), Bn();
    }
    function dt() {
      const pe = r.value;
      if (!pe) return;
      const xe = pe.getContext("2d");
      if (xe) {
        pe.width = d.value, pe.height = h.value, xe.fillStyle = "#1a1a1a", xe.fillRect(0, 0, d.value, h.value), pt(xe);
        for (const Te of R.value)
          Kt(xe, Te);
      }
    }
    function pt(pe) {
      const xe = d.value - y.left - y.right, Te = h.value - y.top - y.bottom;
      pe.strokeStyle = "#2a2a2a", pe.lineWidth = 1;
      const Ue = p.frameEnd - p.frameStart, W = zt(Ue, xe, 50), ve = p.valueMax - p.valueMin, ye = zt(ve, Te, 30), Ce = Math.ceil(p.frameStart / W) * W;
      for (let ke = Ce; ke <= p.frameEnd; ke += W) {
        const De = G(ke);
        pe.beginPath(), pe.moveTo(De, y.top), pe.lineTo(De, h.value - y.bottom), pe.stroke();
      }
      const be = Math.ceil(p.valueMin / ye) * ye;
      for (let ke = be; ke <= p.valueMax; ke += ye) {
        const De = Q(ke);
        pe.beginPath(), pe.moveTo(y.left, De), pe.lineTo(d.value - y.right, De), pe.stroke();
      }
      if (pe.strokeStyle = "#3a3a3a", pe.lineWidth = 1, p.frameStart <= 0 && p.frameEnd >= 0) {
        const ke = G(0);
        pe.beginPath(), pe.moveTo(ke, y.top), pe.lineTo(ke, h.value - y.bottom), pe.stroke();
      }
      if (p.valueMin <= 0 && p.valueMax >= 0) {
        const ke = Q(0);
        pe.beginPath(), pe.moveTo(y.left, ke), pe.lineTo(d.value - y.right, ke), pe.stroke();
      }
    }
    function zt(pe, xe, Te) {
      const Ue = pe * Te / xe, W = Math.pow(10, Math.floor(Math.log10(Ue))), ve = Ue / W;
      return ve <= 1 ? W : ve <= 2 ? 2 * W : ve <= 5 ? 5 * W : 10 * W;
    }
    function Kt(pe, xe) {
      if (xe.keyframes.length < 2) return;
      const Te = Y(xe.id);
      for (let Ue = 0; Ue < 2; Ue++) {
        Ue === 0 ? (pe.strokeStyle = "#000", pe.lineWidth = 4) : (pe.strokeStyle = Te, pe.lineWidth = 2), pe.beginPath();
        let W = !1;
        for (let ve = 0; ve < xe.keyframes.length - 1; ve++) {
          const ye = xe.keyframes[ve], Ce = xe.keyframes[ve + 1];
          if (Ce.frame < p.frameStart || ye.frame > p.frameEnd) continue;
          const be = re(ye), ke = j(xe, ye), De = re(Ce), Qe = j(xe, Ce);
          if (W || (pe.moveTo(be, ke), W = !0), ye.interpolation === "hold")
            pe.lineTo(De, ke), pe.lineTo(De, Qe);
          else if (ye.interpolation === "linear" || !ye.outHandle.enabled && !Ce.inHandle.enabled)
            pe.lineTo(De, Qe);
          else {
            const it = G(ye.frame + ye.outHandle.frame), mt = Q(V(ye.value) + ye.outHandle.value), gt = G(Ce.frame + Ce.inHandle.frame), lt = Q(V(Ce.value) + Ce.inHandle.value);
            pe.bezierCurveTo(it, mt, gt, lt, De, Qe);
          }
        }
        pe.stroke();
      }
    }
    function rn() {
      var Ce;
      const pe = l.value;
      if (!pe) return;
      const xe = (Ce = a.value) == null ? void 0 : Ce.getBoundingClientRect();
      if (!xe) return;
      pe.width = xe.width, pe.height = 24;
      const Te = pe.getContext("2d");
      if (!Te) return;
      Te.fillStyle = "#252525", Te.fillRect(0, 0, pe.width, pe.height);
      const Ue = p.frameEnd - p.frameStart, W = zt(Ue, pe.width, 60);
      Te.fillStyle = "#888", Te.font = "10px system-ui", Te.textAlign = "center";
      const ve = Math.ceil(p.frameStart / W) * W;
      for (let be = ve; be <= p.frameEnd; be += W) {
        const ke = G(be);
        Te.fillText(be.toString(), ke, 16), Te.strokeStyle = "#444", Te.beginPath(), Te.moveTo(ke, 20), Te.lineTo(ke, 24), Te.stroke();
      }
      const ye = G(i.currentFrame);
      Te.fillStyle = "#ff4444", Te.beginPath(), Te.moveTo(ye - 5, 0), Te.lineTo(ye + 5, 0), Te.lineTo(ye, 8), Te.closePath(), Te.fill();
    }
    function Bn() {
      var ye;
      const pe = u.value;
      if (!pe) return;
      const xe = (ye = c.value) == null ? void 0 : ye.getBoundingClientRect();
      if (!xe) return;
      pe.width = 40, pe.height = xe.height;
      const Te = pe.getContext("2d");
      if (!Te) return;
      Te.fillStyle = "#252525", Te.fillRect(0, 0, pe.width, pe.height);
      const Ue = p.valueMax - p.valueMin, W = zt(Ue, pe.height, 30);
      Te.fillStyle = "#888", Te.font = "10px system-ui", Te.textAlign = "right";
      const ve = Math.ceil(p.valueMin / W) * W;
      for (let Ce = ve; Ce <= p.valueMax; Ce += W) {
        const be = Q(Ce);
        Te.fillText(Ce.toFixed(0), 36, be + 4);
      }
    }
    function bn(pe = "both") {
      for (const xe of x.value) {
        const Te = U.value.find((De) => De.id === xe.propId);
        if (!Te) continue;
        const Ue = xe.keyframe, W = xe.index, ve = W > 0 ? Te.keyframes[W - 1] : null, ye = W < Te.keyframes.length - 1 ? Te.keyframes[W + 1] : null, Ce = ve ? Ue.frame - ve.frame : 10, be = ye ? ye.frame - Ue.frame : 10, ke = 0.3333;
        (pe === "both" || pe === "in") && (Ue.inHandle = {
          frame: -Ce * ke,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), (pe === "both" || pe === "out") && (Ue.outHandle = {
          frame: be * ke,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), Ue.interpolation = "bezier", Ue.controlMode = "smooth";
      }
      at();
    }
    function Kn() {
      const pe = i.currentFrame, xe = [];
      for (const Ue of R.value)
        for (const W of Ue.keyframes)
          xe.includes(W.frame) || xe.push(W.frame);
      xe.sort((Ue, W) => Ue - W);
      const Te = [...xe].reverse().find((Ue) => Ue < pe);
      Te !== void 0 && i.setFrame(Te);
    }
    function fi() {
      const pe = i.currentFrame, xe = [];
      for (const Ue of R.value)
        for (const W of Ue.keyframes)
          xe.includes(W.frame) || xe.push(W.frame);
      xe.sort((Ue, W) => Ue - W);
      const Te = xe.find((Ue) => Ue > pe);
      Te !== void 0 && i.setFrame(Te);
    }
    function pi(pe) {
      if (pe.key === "F9") {
        pe.preventDefault(), pe.ctrlKey && pe.shiftKey ? bn("out") : pe.shiftKey ? bn("in") : bn("both");
        return;
      }
      if (pe.key.toLowerCase() === "j") {
        pe.preventDefault(), Kn();
        return;
      }
      if (pe.key.toLowerCase() === "k") {
        pe.preventDefault(), fi();
        return;
      }
      if (pe.key === "Delete" || pe.key === "Backspace") {
        pe.preventDefault(), Je();
        return;
      }
      if (pe.key.toLowerCase() === "f" && !pe.ctrlKey) {
        pe.preventDefault(), pe.shiftKey ? ne() : x.value.length > 0 ? Vn() : ne();
        return;
      }
      if (pe.key === "=" || pe.key === "+") {
        pe.preventDefault(), wn();
        return;
      }
      if (pe.key === "-" || pe.key === "_") {
        pe.preventDefault(), ri();
        return;
      }
    }
    function Vn() {
      if (x.value.length === 0) {
        ne();
        return;
      }
      let pe = 1 / 0, xe = -1 / 0, Te = 1 / 0, Ue = -1 / 0;
      for (const ye of x.value) {
        pe = Math.min(pe, ye.keyframe.frame), xe = Math.max(xe, ye.keyframe.frame);
        const Ce = V(ye.keyframe.value);
        Te = Math.min(Te, Ce), Ue = Math.max(Ue, Ce);
      }
      const W = (xe - pe) * 0.1 || 10, ve = (Ue - Te) * 0.1 || 10;
      p.frameStart = pe - W, p.frameEnd = xe + W, p.valueMin = Te - ve, p.valueMax = Ue + ve, at();
    }
    function wn() {
      const pe = (p.frameStart + p.frameEnd) / 2, xe = p.frameEnd - p.frameStart;
      p.frameStart = pe - xe * 0.4, p.frameEnd = pe + xe * 0.4, at();
    }
    function ri() {
      const pe = (p.frameStart + p.frameEnd) / 2, xe = p.frameEnd - p.frameStart;
      p.frameStart = pe - xe * 0.6, p.frameEnd = pe + xe * 0.6, at();
    }
    let ki = null;
    return xn(() => {
      o.value && (ki = new ResizeObserver((pe) => {
        for (const xe of pe)
          d.value = xe.contentRect.width, h.value = xe.contentRect.height, at();
      }), ki.observe(o.value)), _.value = U.value.filter((pe) => pe.animated).map((pe) => pe.id), window.addEventListener("keydown", pi), ne(), at();
    }), Nn(() => {
      ki == null || ki.disconnect(), window.removeEventListener("keydown", pi);
    }), Ft([() => i.currentFrame, _, m], () => {
      at();
    }), Ft(U, () => {
      ne(), at();
    }, { deep: !0 }), (pe, xe) => {
      var Te, Ue;
      return te(), ae("div", OB, [
        f("div", zB, [
          xe[9] || (xe[9] = f("span", { class: "graph-title" }, "Graph Editor", -1)),
          f("div", NB, [
            f("button", {
              class: Fe({ active: m.value === "value" }),
              onClick: xe[0] || (xe[0] = (W) => m.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            f("button", {
              class: Fe({ active: m.value === "speed" }),
              onClick: xe[1] || (xe[1] = (W) => m.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          f("div", BB, [
            (te(), ae(qe, null, ot(D, (W) => f("button", {
              key: W.key,
              class: Fe(["preset-btn", { active: X(W.key) }]),
              onClick: (ve) => se(W.key),
              title: W.label
            }, _e(W.shortLabel), 11, VB)), 64))
          ]),
          f("div", GB, [
            f("button", {
              onClick: ne,
              title: "Fit to View"
            }, [...xe[5] || (xe[5] = [
              f("span", { class: "icon" }, "[ ]", -1)
            ])]),
            f("button", {
              onClick: B,
              class: Fe({ active: E.value }),
              title: "Auto-select Nearby Keyframes"
            }, [...xe[6] || (xe[6] = [
              f("span", { class: "icon" }, "A", -1)
            ])], 2),
            f("button", {
              onClick: xe[2] || (xe[2] = (W) => P.value = !P.value),
              class: Fe({ active: P.value }),
              title: "Snap to Grid"
            }, [...xe[7] || (xe[7] = [
              f("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          f("button", {
            class: "close-btn",
            onClick: xe[3] || (xe[3] = (W) => n("close"))
          }, [...xe[8] || (xe[8] = [
            f("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        f("div", HB, [
          f("div", $B, [
            f("div", WB, [
              xe[10] || (xe[10] = ct(" Properties ", -1)),
              f("button", {
                class: "toggle-all-btn",
                onClick: Z,
                title: O.value ? "Hide All" : "Show All"
              }, _e(O.value ? "Hide" : "Show"), 9, XB)
            ]),
            (te(!0), ae(qe, null, ot(U.value, (W) => (te(), ae("div", {
              key: W.id,
              class: Fe(["property-item", {
                selected: v.value.includes(W.id),
                animated: W.animated
              }])
            }, [
              f("div", {
                class: "property-row",
                onClick: (ve) => L(W.id)
              }, [
                f("span", {
                  class: Fe(["visibility-toggle", { visible: _.value.includes(W.id) }]),
                  onClick: xt((ve) => ee(W.id), ["stop"])
                }, null, 10, YB),
                f("span", {
                  class: "property-color",
                  style: yt({ background: Y(W.id) })
                }, null, 4),
                f("span", qB, _e(W.name), 1),
                W.animated ? (te(), ae("span", ZB, _e(W.keyframes.length), 1)) : Pe("", !0)
              ], 8, jB),
              W.name === "Position" || W.name === "Scale" ? (te(), ae("div", KB, [
                (te(), ae(qe, null, ot(["x", "y", "z"], (ve) => {
                  var ye;
                  return f("button", {
                    key: ve,
                    class: Fe({
                      active: (ye = g.value[W.id]) == null ? void 0 : ye.includes(ve),
                      hasValue: F(W, ve)
                    }),
                    onClick: (Ce) => k(W.id, ve)
                  }, _e(ve.toUpperCase()), 11, JB);
                }), 64))
              ])) : Pe("", !0)
            ], 2))), 128)),
            U.value.length === 0 ? (te(), ae("div", QB, " No animated properties ")) : Pe("", !0)
          ]),
          f("div", eV, [
            f("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: a
            }, [
              f("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: ut
              }, null, 512)
            ], 512),
            f("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: o
            }, [
              f("canvas", {
                ref_key: "canvasRef",
                ref: r,
                onMousedown: z,
                onMousemove: N,
                onMouseup: K,
                onMouseleave: K,
                onWheel: he,
                onContextmenu: xt(Le, ["prevent"])
              }, null, 544),
              b.value ? (te(), ae("div", {
                key: 0,
                class: "selection-box",
                style: yt({
                  left: b.value.x + "px",
                  top: b.value.y + "px",
                  width: b.value.width + "px",
                  height: b.value.height + "px"
                })
              }, null, 4)) : Pe("", !0),
              (te(), ae("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${d.value} ${h.value}`
              }, [
                (te(!0), ae(qe, null, ot(R.value, (W) => (te(), ae("g", {
                  key: W.id,
                  class: "property-handles"
                }, [
                  (te(!0), ae(qe, null, ot(W.keyframes, (ve, ye) => {
                    var Ce, be, ke, De, Qe, it, mt, gt;
                    return te(), ae(qe, { key: ye }, [
                      H(ve) ? (te(), ae("g", {
                        key: 0,
                        class: Fe(["keyframe-marker", {
                          selected: I(W.id, ye),
                          hovered: ((Ce = M.value) == null ? void 0 : Ce.propId) === W.id && ((be = M.value) == null ? void 0 : be.index) === ye
                        }]),
                        onMousedown: xt((lt) => ge(W.id, ye, lt), ["stop"])
                      }, [
                        f("rect", {
                          x: re(ve) - 5,
                          y: j(W, ve) - 5,
                          width: "10",
                          height: "10",
                          fill: Y(W.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${re(ve)}, ${j(W, ve)})`
                        }, null, 8, iV)
                      ], 42, nV)) : Pe("", !0),
                      I(W.id, ye) && ve.interpolation !== "hold" ? (te(), ae("g", sV, [
                        W.keyframes[ye + 1] && (ve.outHandle.enabled || ve.interpolation === "bezier") ? (te(), ae("g", rV, [
                          f("line", {
                            x1: re(ve),
                            y1: j(W, ve),
                            x2: q(W, ye),
                            y2: oe(W, ye),
                            class: "handle-line"
                          }, null, 8, oV),
                          f("circle", {
                            cx: q(W, ye),
                            cy: oe(W, ye),
                            r: "5",
                            class: Fe(["handle-point", { dragging: ((ke = S.value) == null ? void 0 : ke.type) === "outHandle" && ((De = S.value) == null ? void 0 : De.propId) === W.id && ((Qe = S.value) == null ? void 0 : Qe.index) === ye }]),
                            onMousedown: xt((lt) => Xe("outHandle", W.id, ye), ["stop"])
                          }, null, 42, aV)
                        ])) : Pe("", !0),
                        ye > 0 && (ve.inHandle.enabled || ve.interpolation === "bezier") ? (te(), ae("g", lV, [
                          f("line", {
                            x1: re(ve),
                            y1: j(W, ve),
                            x2: ie(W, ye),
                            y2: ce(W, ye),
                            class: "handle-line"
                          }, null, 8, cV),
                          f("circle", {
                            cx: ie(W, ye),
                            cy: ce(W, ye),
                            r: "5",
                            class: Fe(["handle-point", { dragging: ((it = S.value) == null ? void 0 : it.type) === "inHandle" && ((mt = S.value) == null ? void 0 : mt.propId) === W.id && ((gt = S.value) == null ? void 0 : gt.index) === ye }]),
                            onMousedown: xt((lt) => Xe("inHandle", W.id, ye), ["stop"])
                          }, null, 42, uV)
                        ])) : Pe("", !0)
                      ])) : Pe("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                f("line", {
                  x1: A.value,
                  y1: 0,
                  x2: A.value,
                  y2: h.value,
                  class: "current-time-line"
                }, null, 8, dV)
              ], 8, tV))
            ], 512),
            f("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: c
            }, [
              f("canvas", {
                ref_key: "valueAxisCanvas",
                ref: u
              }, null, 512)
            ], 512)
          ])
        ]),
        x.value.length > 0 ? (te(), ae("div", hV, [
          f("div", fV, [
            xe[11] || (xe[11] = f("span", { class: "info-label" }, "Frame:", -1)),
            f("input", {
              type: "number",
              value: (Te = x.value[0]) == null ? void 0 : Te.keyframe.frame,
              onChange: Be,
              class: "info-input"
            }, null, 40, pV)
          ]),
          f("div", mV, [
            xe[12] || (xe[12] = f("span", { class: "info-label" }, "Value:", -1)),
            f("input", {
              type: "number",
              value: $(x.value[0]),
              onChange: je,
              class: "info-input",
              step: "0.1"
            }, null, 40, vV)
          ]),
          f("div", gV, [
            xe[14] || (xe[14] = f("span", { class: "info-label" }, "Interpolation:", -1)),
            f("select", {
              value: (Ue = x.value[0]) == null ? void 0 : Ue.keyframe.interpolation,
              onChange: Ge,
              class: "info-select"
            }, [...xe[13] || (xe[13] = [
              f("option", { value: "linear" }, "Linear", -1),
              f("option", { value: "bezier" }, "Bezier", -1),
              f("option", { value: "hold" }, "Hold", -1)
            ])], 40, yV)
          ])
        ])) : Pe("", !0),
        C.value ? (te(), ae("div", {
          key: 1,
          class: "context-menu",
          style: yt({ left: C.value.x + "px", top: C.value.y + "px" }),
          onClick: xe[4] || (xe[4] = (W) => C.value = null)
        }, [
          f("button", { onClick: nt }, "Add Keyframe"),
          f("button", {
            onClick: Je,
            disabled: x.value.length === 0
          }, "Delete Keyframe(s)", 8, xV),
          xe[15] || (xe[15] = f("hr", null, null, -1)),
          f("button", {
            onClick: bt,
            disabled: x.value.length === 0
          }, "Copy", 8, _V),
          f("button", {
            onClick: Se,
            disabled: !T.value
          }, "Paste", 8, bV),
          xe[16] || (xe[16] = f("hr", null, null, -1)),
          f("button", { onClick: Ne }, "Select All"),
          f("button", { onClick: Re }, "Invert Selection")
        ], 4)) : Pe("", !0)
      ]);
    };
  }
}), SV = /* @__PURE__ */ Gt(wV, [["__scopeId", "data-v-70deec8d"]]), { abs: Sa, cos: xs, sin: bo, acos: MV, atan2: Ma, sqrt: qs, pow: Ti } = Math;
function Ca(s) {
  return s < 0 ? -Ti(-s, 1 / 3) : Ti(s, 1 / 3);
}
const Xy = Math.PI, Mc = 2 * Xy, Zs = Xy / 2, CV = 1e-6, Yd = Number.MAX_SAFE_INTEGER || 9007199254740991, qd = Number.MIN_SAFE_INTEGER || -9007199254740991, TV = { x: 0, y: 0, z: 0 }, Ke = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(s, e) {
    const n = e(s);
    let i = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (i += n.z * n.z), qs(i);
  },
  compute: function(s, e, n) {
    if (s === 0)
      return e[0].t = 0, e[0];
    const i = e.length - 1;
    if (s === 1)
      return e[i].t = 1, e[i];
    const r = 1 - s;
    let o = e;
    if (i === 0)
      return e[0].t = s, e[0];
    if (i === 1) {
      const l = {
        x: r * o[0].x + s * o[1].x,
        y: r * o[0].y + s * o[1].y,
        t: s
      };
      return n && (l.z = r * o[0].z + s * o[1].z), l;
    }
    if (i < 4) {
      let l = r * r, c = s * s, u, d, h, m = 0;
      i === 2 ? (o = [o[0], o[1], o[2], TV], u = l, d = r * s * 2, h = c) : i === 3 && (u = l * r, d = l * s * 3, h = r * c * 3, m = s * c);
      const p = {
        x: u * o[0].x + d * o[1].x + h * o[2].x + m * o[3].x,
        y: u * o[0].y + d * o[1].y + h * o[2].y + m * o[3].y,
        t: s
      };
      return n && (p.z = u * o[0].z + d * o[1].z + h * o[2].z + m * o[3].z), p;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * s,
          y: a[l].y + (a[l + 1].y - a[l].y) * s
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * s);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = s, a[0];
  },
  computeWithRatios: function(s, e, n, i) {
    const r = 1 - s, o = n, a = e;
    let l = o[0], c = o[1], u = o[2], d = o[3], h;
    if (l *= r, c *= s, a.length === 2)
      return h = l + c, {
        x: (l * a[0].x + c * a[1].x) / h,
        y: (l * a[0].y + c * a[1].y) / h,
        z: i ? (l * a[0].z + c * a[1].z) / h : !1,
        t: s
      };
    if (l *= r, c *= 2 * r, u *= s * s, a.length === 3)
      return h = l + c + u, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y) / h,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z) / h : !1,
        t: s
      };
    if (l *= r, c *= 1.5 * r, u *= 3 * r, d *= s * s * s, a.length === 4)
      return h = l + c + u + d, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x + d * a[3].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y + d * a[3].y) / h,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z + d * a[3].z) / h : !1,
        t: s
      };
  },
  derive: function(s, e) {
    const n = [];
    for (let i = s, r = i.length, o = r - 1; r > 1; r--, o--) {
      const a = [];
      for (let l = 0, c; l < o; l++)
        c = {
          x: o * (i[l + 1].x - i[l].x),
          y: o * (i[l + 1].y - i[l].y)
        }, e && (c.z = o * (i[l + 1].z - i[l].z)), a.push(c);
      n.push(a), i = a;
    }
    return n;
  },
  between: function(s, e, n) {
    return e <= s && s <= n || Ke.approximately(s, e) || Ke.approximately(s, n);
  },
  approximately: function(s, e, n) {
    return Sa(s - e) <= (n || CV);
  },
  length: function(s) {
    const n = Ke.Tvalues.length;
    let i = 0;
    for (let r = 0, o; r < n; r++)
      o = 0.5 * Ke.Tvalues[r] + 0.5, i += Ke.Cvalues[r] * Ke.arcfn(o, s);
    return 0.5 * i;
  },
  map: function(s, e, n, i, r) {
    const o = n - e, a = r - i, l = s - e, c = l / o;
    return i + a * c;
  },
  lerp: function(s, e, n) {
    const i = {
      x: e.x + s * (n.x - e.x),
      y: e.y + s * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (i.z = e.z + s * (n.z - e.z)), i;
  },
  pointToString: function(s) {
    let e = s.x + "/" + s.y;
    return typeof s.z < "u" && (e += "/" + s.z), e;
  },
  pointsToString: function(s) {
    return "[" + s.map(Ke.pointToString).join(", ") + "]";
  },
  copy: function(s) {
    return JSON.parse(JSON.stringify(s));
  },
  angle: function(s, e, n) {
    const i = e.x - s.x, r = e.y - s.y, o = n.x - s.x, a = n.y - s.y, l = i * a - r * o, c = i * o + r * a;
    return Ma(l, c);
  },
  // round as string, to avoid rounding errors
  round: function(s, e) {
    const n = "" + s, i = n.indexOf(".");
    return parseFloat(n.substring(0, i + 1 + e));
  },
  dist: function(s, e) {
    const n = s.x - e.x, i = s.y - e.y;
    return qs(n * n + i * i);
  },
  closest: function(s, e) {
    let n = Ti(2, 63), i, r;
    return s.forEach(function(o, a) {
      r = Ke.dist(e, o), r < n && (n = r, i = a);
    }), { mdist: n, mpos: i };
  },
  abcratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = Ti(s, e) + Ti(1 - s, e), i = n - 1;
    return Sa(i / n);
  },
  projectionratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = Ti(1 - s, e), i = Ti(s, e) + n;
    return n / i;
  },
  lli8: function(s, e, n, i, r, o, a, l) {
    const c = (s * i - e * n) * (r - a) - (s - n) * (r * l - o * a), u = (s * i - e * n) * (o - l) - (e - i) * (r * l - o * a), d = (s - n) * (o - l) - (e - i) * (r - a);
    return d == 0 ? !1 : { x: c / d, y: u / d };
  },
  lli4: function(s, e, n, i) {
    const r = s.x, o = s.y, a = e.x, l = e.y, c = n.x, u = n.y, d = i.x, h = i.y;
    return Ke.lli8(r, o, a, l, c, u, d, h);
  },
  lli: function(s, e) {
    return Ke.lli4(s, s.c, e, e.c);
  },
  makeline: function(s, e) {
    return new jy(
      s.x,
      s.y,
      (s.x + e.x) / 2,
      (s.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(s) {
    let e = Yd, n = Yd, i = qd, r = qd;
    return s.forEach(function(o) {
      const a = o.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), i < a.x.max && (i = a.x.max), r < a.y.max && (r = a.y.max);
    }), {
      x: { min: e, mid: (e + i) / 2, max: i, size: i - e },
      y: { min: n, mid: (n + r) / 2, max: r, size: r - n }
    };
  },
  shapeintersections: function(s, e, n, i, r) {
    if (!Ke.bboxoverlap(e, i)) return [];
    const o = [], a = [s.startcap, s.forward, s.back, s.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(c) {
      c.virtual || l.forEach(function(u) {
        if (u.virtual) return;
        const d = c.intersects(u, r);
        d.length > 0 && (d.c1 = c, d.c2 = u, d.s1 = s, d.s2 = n, o.push(d));
      });
    }), o;
  },
  makeshape: function(s, e, n) {
    const i = e.points.length, r = s.points.length, o = Ke.makeline(e.points[i - 1], s.points[0]), a = Ke.makeline(s.points[r - 1], e.points[0]), l = {
      startcap: o,
      forward: s,
      back: e,
      endcap: a,
      bbox: Ke.findbbox([o, s, e, a])
    };
    return l.intersections = function(c) {
      return Ke.shapeintersections(
        l,
        l.bbox,
        c,
        c.bbox,
        n
      );
    }, l;
  },
  getminmax: function(s, e, n) {
    if (!n) return { min: 0, max: 0 };
    let i = Yd, r = qd, o, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, c = n.length; l < c; l++)
      o = n[l], a = s.get(o), a[e] < i && (i = a[e]), a[e] > r && (r = a[e]);
    return { min: i, mid: (i + r) / 2, max: r, size: r - i };
  },
  align: function(s, e) {
    const n = e.p1.x, i = e.p1.y, r = -Ma(e.p2.y - i, e.p2.x - n), o = function(a) {
      return {
        x: (a.x - n) * xs(r) - (a.y - i) * bo(r),
        y: (a.x - n) * bo(r) + (a.y - i) * xs(r)
      };
    };
    return s.map(o);
  },
  roots: function(s, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = s.length - 1, i = Ke.align(s, e), r = function(P) {
      return 0 <= P && P <= 1;
    };
    if (n === 2) {
      const P = i[0].y, E = i[1].y, y = i[2].y, w = P - 2 * E + y;
      if (w !== 0) {
        const D = -qs(E * E - P * y), U = -P + E, R = -(D + U) / w, O = -(-D + U) / w;
        return [R, O].filter(r);
      } else if (E !== y && w === 0)
        return [(2 * E - y) / (2 * E - 2 * y)].filter(r);
      return [];
    }
    const o = i[0].y, a = i[1].y, l = i[2].y, c = i[3].y;
    let u = -o + 3 * a - 3 * l + c, d = 3 * o - 6 * a + 3 * l, h = -3 * o + 3 * a, m = o;
    if (Ke.approximately(u, 0)) {
      if (Ke.approximately(d, 0))
        return Ke.approximately(h, 0) ? [] : [-m / h].filter(r);
      const P = qs(h * h - 4 * d * m), E = 2 * d;
      return [(P - h) / E, (-h - P) / E].filter(r);
    }
    d /= u, h /= u, m /= u;
    const p = (3 * h - d * d) / 3, v = p / 3, _ = (2 * d * d * d - 9 * d * h + 27 * m) / 27, g = _ / 2, x = g * g + v * v * v;
    let M, S, b, C, T;
    if (x < 0) {
      const P = -p / 3, E = P * P * P, y = qs(E), w = -_ / (2 * y), D = w < -1 ? -1 : w > 1 ? 1 : w, U = MV(D), R = Ca(y), O = 2 * R;
      return b = O * xs(U / 3) - d / 3, C = O * xs((U + Mc) / 3) - d / 3, T = O * xs((U + 2 * Mc) / 3) - d / 3, [b, C, T].filter(r);
    } else {
      if (x === 0)
        return M = g < 0 ? Ca(-g) : -Ca(g), b = 2 * M - d / 3, C = -M - d / 3, [b, C].filter(r);
      {
        const P = qs(x);
        return M = Ca(-g + P), S = Ca(g + P), [M - S - d / 3].filter(r);
      }
    }
  },
  droots: function(s) {
    if (s.length === 3) {
      const e = s[0], n = s[1], i = s[2], r = e - 2 * n + i;
      if (r !== 0) {
        const o = -qs(n * n - e * i), a = -e + n, l = -(o + a) / r, c = -(-o + a) / r;
        return [l, c];
      } else if (n !== i && r === 0)
        return [(2 * n - i) / (2 * (n - i))];
      return [];
    }
    if (s.length === 2) {
      const e = s[0], n = s[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(s, e, n, i, r) {
    let o, a, l, c, u = 0, d = 0;
    const h = Ke.compute(s, e), m = Ke.compute(s, n), p = h.x * h.x + h.y * h.y;
    if (i ? (o = qs(
      Ti(h.y * m.z - m.y * h.z, 2) + Ti(h.z * m.x - m.z * h.x, 2) + Ti(h.x * m.y - m.x * h.y, 2)
    ), a = Ti(p + h.z * h.z, 3 / 2)) : (o = h.x * m.y - h.y * m.x, a = Ti(p, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (u = o / a, d = a / o, !r) {
      const v = Ke.curvature(s - 1e-3, e, n, i, !0).k, _ = Ke.curvature(s + 1e-3, e, n, i, !0).k;
      c = (_ - u + (u - v)) / 2, l = (Sa(_ - u) + Sa(u - v)) / 2;
    }
    return { k: u, r: d, dk: c, adk: l };
  },
  inflections: function(s) {
    if (s.length < 4) return [];
    const e = Ke.align(s, { p1: s[0], p2: s.slice(-1)[0] }), n = e[2].x * e[1].y, i = e[3].x * e[1].y, r = e[1].x * e[2].y, o = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * i + 3 * r - o), l = 18 * (3 * n - i - 3 * r), c = 18 * (r - n);
    if (Ke.approximately(a, 0)) {
      if (!Ke.approximately(l, 0)) {
        let m = -c / l;
        if (0 <= m && m <= 1) return [m];
      }
      return [];
    }
    const u = 2 * a;
    if (Ke.approximately(u, 0)) return [];
    const d = l * l - 4 * a * c;
    if (d < 0) return [];
    const h = Math.sqrt(d);
    return [(h - l) / u, -(l + h) / u].filter(function(m) {
      return 0 <= m && m <= 1;
    });
  },
  bboxoverlap: function(s, e) {
    const n = ["x", "y"], i = n.length;
    for (let r = 0, o, a, l, c; r < i; r++)
      if (o = n[r], a = s[o].mid, l = e[o].mid, c = (s[o].size + e[o].size) / 2, Sa(a - l) >= c) return !1;
    return !0;
  },
  expandbox: function(s, e) {
    e.x.min < s.x.min && (s.x.min = e.x.min), e.y.min < s.y.min && (s.y.min = e.y.min), e.z && e.z.min < s.z.min && (s.z.min = e.z.min), e.x.max > s.x.max && (s.x.max = e.x.max), e.y.max > s.y.max && (s.y.max = e.y.max), e.z && e.z.max > s.z.max && (s.z.max = e.z.max), s.x.mid = (s.x.min + s.x.max) / 2, s.y.mid = (s.y.min + s.y.max) / 2, s.z && (s.z.mid = (s.z.min + s.z.max) / 2), s.x.size = s.x.max - s.x.min, s.y.size = s.y.max - s.y.min, s.z && (s.z.size = s.z.max - s.z.min);
  },
  pairiteration: function(s, e, n) {
    const i = s.bbox(), r = e.bbox(), o = 1e5, a = n || 0.5;
    if (i.x.size + i.y.size < a && r.x.size + r.y.size < a)
      return [
        (o * (s._t1 + s._t2) / 2 | 0) / o + "/" + (o * (e._t1 + e._t2) / 2 | 0) / o
      ];
    let l = s.split(0.5), c = e.split(0.5), u = [
      { left: l.left, right: c.left },
      { left: l.left, right: c.right },
      { left: l.right, right: c.right },
      { left: l.right, right: c.left }
    ];
    u = u.filter(function(h) {
      return Ke.bboxoverlap(h.left.bbox(), h.right.bbox());
    });
    let d = [];
    return u.length === 0 || (u.forEach(function(h) {
      d = d.concat(
        Ke.pairiteration(h.left, h.right, a)
      );
    }), d = d.filter(function(h, m) {
      return d.indexOf(h) === m;
    })), d;
  },
  getccenter: function(s, e, n) {
    const i = e.x - s.x, r = e.y - s.y, o = n.x - e.x, a = n.y - e.y, l = i * xs(Zs) - r * bo(Zs), c = i * bo(Zs) + r * xs(Zs), u = o * xs(Zs) - a * bo(Zs), d = o * bo(Zs) + a * xs(Zs), h = (s.x + e.x) / 2, m = (s.y + e.y) / 2, p = (e.x + n.x) / 2, v = (e.y + n.y) / 2, _ = h + l, g = m + c, x = p + u, M = v + d, S = Ke.lli8(h, m, _, g, p, v, x, M), b = Ke.dist(S, s);
    let C = Ma(s.y - S.y, s.x - S.x), T = Ma(e.y - S.y, e.x - S.x), P = Ma(n.y - S.y, n.x - S.x), E;
    return C < P ? ((C > T || T > P) && (C += Mc), C > P && (E = P, P = C, C = E)) : P < T && T < C ? (E = P, P = C, C = E) : P += Mc, S.s = C, S.e = P, S.r = b, S;
  },
  numberSort: function(s, e) {
    return s - e;
  }
};
class Ja {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Ke.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), i = 1; i < e.length; i++)
      Ke.expandbox(n, e[i].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(i) {
      n.push(...i.offset(e));
    }), new Ja(n);
  }
}
const { abs: Ta, min: og, max: ag, cos: EV, sin: AV, acos: PV, sqrt: Ea } = Math, RV = Math.PI;
let jy = class fn {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), i = !1;
    if (typeof n[0] == "object") {
      i = n.length;
      const p = [];
      n.forEach(function(v) {
        ["x", "y", "z"].forEach(function(_) {
          typeof v[_] < "u" && p.push(v[_]);
        });
      }), n = p;
    }
    let r = !1;
    const o = n.length;
    if (i) {
      if (i > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        r = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !r && (o === 9 || o === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let p = 0, v = a ? 3 : 2; p < o; p += v) {
      var c = {
        x: n[p],
        y: n[p + 1]
      };
      a && (c.z = n[p + 2]), l.push(c);
    }
    const u = this.order = l.length - 1, d = this.dims = ["x", "y"];
    a && d.push("z"), this.dimlen = d.length;
    const h = Ke.align(l, { p1: l[0], p2: l[u] }), m = Ke.dist(l[0], l[u]);
    this._linear = h.reduce((p, v) => p + Ta(v.y), 0) < m / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, i, r) {
    if (typeof r > "u" && (r = 0.5), r === 0)
      return new fn(n, n, i);
    if (r === 1)
      return new fn(e, n, n);
    const o = fn.getABC(2, e, n, i, r);
    return new fn(e, o.A, i);
  }
  static cubicFromPoints(e, n, i, r, o) {
    typeof r > "u" && (r = 0.5);
    const a = fn.getABC(3, e, n, i, r);
    typeof o > "u" && (o = Ke.dist(n, a.C));
    const l = o * (1 - r) / r, c = Ke.dist(e, i), u = (i.x - e.x) / c, d = (i.y - e.y) / c, h = o * u, m = o * d, p = l * u, v = l * d, _ = { x: n.x - h, y: n.y - m }, g = { x: n.x + p, y: n.y + v }, x = a.A, M = { x: x.x + (_.x - x.x) / (1 - r), y: x.y + (_.y - x.y) / (1 - r) }, S = { x: x.x + (g.x - x.x) / r, y: x.y + (g.y - x.y) / r }, b = { x: e.x + (M.x - e.x) / r, y: e.y + (M.y - e.y) / r }, C = {
      x: i.x + (S.x - i.x) / (1 - r),
      y: i.y + (S.y - i.y) / (1 - r)
    };
    return new fn(e, b, C, i);
  }
  static getUtils() {
    return Ke;
  }
  getUtils() {
    return fn.getUtils();
  }
  static get PolyBezier() {
    return Ja;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Ke.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, i = e[0].y, r = ["M", n, i, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = e.length; o < a; o++)
      r.push(e[o].x), r.push(e[o].y);
    return r.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Ke.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = Ke.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return Ke.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, i, r, o = 0.5) {
    const a = Ke.projectionratio(o, e), l = 1 - a, c = {
      x: a * n.x + l * r.x,
      y: a * n.y + l * r.y
    }, u = Ke.abcratio(o, e);
    return { A: {
      x: i.x + (i.x - c.x) / u,
      y: i.y + (i.y - c.y) / u
    }, B: i, C: c, S: n, E: r };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let i = this.points[0], r = this.points[this.order];
    return fn.getABC(this.order, i, n, r, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, i, r; n < e; n++)
      r = n / (e - 1), i = this.compute(r), i.t = r, this._lut.push(i);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const i = this.getLUT(), r = [];
    for (let o = 0, a, l = 0; o < i.length; o++)
      a = i[o], Ke.dist(a, e) < n && (r.push(a), l += o / i.length);
    return r.length ? t /= r.length : !1;
  }
  project(e) {
    const n = this.getLUT(), i = n.length - 1, r = Ke.closest(n, e), o = r.mpos, a = (o - 1) / i, l = (o + 1) / i, c = 0.1 / i;
    let u = r.mdist, d = a, h = d, m;
    u += 1;
    for (let p; d < l + c; d += c)
      m = this.compute(d), p = Ke.dist(e, m), p < u && (u = p, h = d);
    return h = h < 0 ? 0 : h > 1 ? 1 : h, m = this.compute(h), m.t = h, m.d = u, m;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Ke.computeWithRatios(e, this.points, this.ratios, this._3d) : Ke.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], i = e.length;
    for (let r = 1, o, a; r < i; r++)
      o = e[r], a = e[r - 1], n[r] = {
        x: (i - r) / i * o.x + r / i * a.x,
        y: (i - r) / i * o.y + r / i * a.y
      };
    return n[i] = e[i - 1], new fn(n);
  }
  derivative(e) {
    return Ke.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Ke.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new fn(Ke.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Ke.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Ke.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), i = Ea(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / i, y: n.x / i };
  }
  __normal3(e) {
    const n = this.derivative(e), i = this.derivative(e + 0.01), r = Ea(n.x * n.x + n.y * n.y + n.z * n.z), o = Ea(i.x * i.x + i.y * i.y + i.z * i.z);
    n.x /= r, n.y /= r, n.z /= r, i.x /= o, i.y /= o, i.z /= o;
    const a = {
      x: i.y * n.z - i.z * n.y,
      y: i.z * n.x - i.x * n.z,
      z: i.x * n.y - i.y * n.x
    }, l = Ea(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const c = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, i = [], r = [], o = 0;
    for (r[o++] = n[0], r[o++] = n[1], r[o++] = n[2], this.order === 3 && (r[o++] = n[3]); n.length > 1; ) {
      i = [];
      for (let a = 0, l, c = n.length - 1; a < c; a++)
        l = Ke.lerp(e, n[a], n[a + 1]), r[o++] = l, i.push(l);
      n = i;
    }
    return r;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const i = this.hull(e), r = {
      left: this.order === 2 ? new fn([i[0], i[3], i[5]]) : new fn([i[0], i[4], i[7], i[9]]),
      right: this.order === 2 ? new fn([i[5], i[4], i[2]]) : new fn([i[9], i[8], i[6], i[3]]),
      span: i
    };
    return r.left._t1 = Ke.map(0, 0, 1, this._t1, this._t2), r.left._t2 = Ke.map(e, 0, 1, this._t1, this._t2), r.right._t1 = Ke.map(e, 0, 1, this._t1, this._t2), r.right._t2 = Ke.map(1, 0, 1, this._t1, this._t2), n ? (n = Ke.map(n, e, 1, 0, 1), r.right.split(n).left) : r;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(i) {
        let r = function(a) {
          return a[i];
        }, o = this.dpoints[0].map(r);
        e[i] = Ke.droots(o), this.order === 3 && (o = this.dpoints[1].map(r), e[i] = e[i].concat(Ke.droots(o))), e[i] = e[i].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[i].sort(Ke.numberSort));
      }).bind(this)
    ), e.values = n.sort(Ke.numberSort).filter(function(i, r) {
      return n.indexOf(i) === r;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(i) {
        n[i] = Ke.getminmax(this, i, e[i]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), i = e.bbox();
    return Ke.bboxoverlap(n, i);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const i = this.get(e), r = this.normal(e), o = {
        c: i,
        n: r,
        x: i.x + r.x * n,
        y: i.y + r.y * n
      };
      return this._3d && (o.z = i.z + r.z * n), o;
    }
    if (this._linear) {
      const i = this.normal(0), r = this.points.map(function(o) {
        const a = {
          x: o.x + e * i.x,
          y: o.y + e * i.y
        };
        return o.z && i.z && (a.z = o.z + e * i.z), a;
      });
      return [new fn(r)];
    }
    return this.reduce().map(function(i) {
      return i._linear ? i.offset(e)[0] : i.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const r = Ke.angle(this.points[0], this.points[3], this.points[1]), o = Ke.angle(this.points[0], this.points[3], this.points[2]);
      if (r > 0 && o < 0 || r < 0 && o > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let i = e.x * n.x + e.y * n.y;
    return this._3d && (i += e.z * n.z), Ta(PV(i)) < RV / 3;
  }
  reduce() {
    let e, n = 0, i = 0, r = 0.01, o, a = [], l = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      i = c[e], o = this.split(n, i), o._t1 = n, o._t2 = i, a.push(o), n = i;
    return a.forEach(function(u) {
      for (n = 0, i = 0; i <= 1; )
        for (i = n + r; i <= 1 + r; i += r)
          if (o = u.split(n, i), !o.simple()) {
            if (i -= r, Ta(n - i) < r)
              return [];
            o = u.split(n, i), o._t1 = Ke.map(n, 0, 1, u._t1, u._t2), o._t2 = Ke.map(i, 0, 1, u._t1, u._t2), l.push(o), n = i;
            break;
          }
      n < 1 && (o = u.split(n, 1), o._t1 = Ke.map(n, 0, 1, u._t1, u._t2), o._t2 = u._t2, l.push(o));
    }), l;
  }
  translate(e, n, i) {
    i = typeof i == "number" ? i : n;
    const r = this.order;
    let o = this.points.map((a, l) => (1 - l / r) * n + l / r * i);
    return new fn(
      this.points.map((a, l) => ({
        x: a.x + e.x * o[l],
        y: a.y + e.y * o[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let i = !1;
    if (typeof e == "function" && (i = e), i && n === 2)
      return this.raise().scale(i);
    const r = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        i ? i(0) : e,
        i ? i(1) : e
      );
    const a = i ? i(0) : e, l = i ? i(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], u = [], d = Ke.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!d)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(h) {
      const m = u[h * n] = Ke.copy(o[h * n]);
      m.x += (h ? l : a) * c[h].n.x, m.y += (h ? l : a) * c[h].n.y;
    }), i ? ([0, 1].forEach(function(h) {
      if (!(n === 2 && h)) {
        var m = o[h + 1], p = {
          x: m.x - d.x,
          y: m.y - d.y
        }, v = i ? i((h + 1) / n) : e;
        i && !r && (v = -v);
        var _ = Ea(p.x * p.x + p.y * p.y);
        p.x /= _, p.y /= _, u[h + 1] = {
          x: m.x + v * p.x,
          y: m.y + v * p.y
        };
      }
    }), new fn(u)) : ([0, 1].forEach((h) => {
      if (n === 2 && h) return;
      const m = u[h * n], p = this.derivative(h), v = { x: m.x + p.x, y: m.y + p.y };
      u[h + 1] = Ke.lli4(m, v, d, o[h + 1]);
    }), new fn(u));
  }
  outline(e, n, i, r) {
    if (n = n === void 0 ? e : n, this._linear) {
      const C = this.normal(0), T = this.points[0], P = this.points[this.points.length - 1];
      let E, y, w;
      i === void 0 && (i = e, r = n), E = { x: T.x + C.x * e, y: T.y + C.y * e }, w = { x: P.x + C.x * i, y: P.y + C.y * i }, y = { x: (E.x + w.x) / 2, y: (E.y + w.y) / 2 };
      const D = [E, y, w];
      E = { x: T.x - C.x * n, y: T.y - C.y * n }, w = { x: P.x - C.x * r, y: P.y - C.y * r }, y = { x: (E.x + w.x) / 2, y: (E.y + w.y) / 2 };
      const U = [w, y, E], R = Ke.makeline(U[2], D[0]), O = Ke.makeline(D[2], U[0]), A = [R, new fn(D), O, new fn(U)];
      return new Ja(A);
    }
    const o = this.reduce(), a = o.length, l = [];
    let c = [], u, d = 0, h = this.length();
    const m = typeof i < "u" && typeof r < "u";
    function p(C, T, P, E, y) {
      return function(w) {
        const D = E / P, U = (E + y) / P, R = T - C;
        return Ke.map(w, 0, 1, C + D * R, C + U * R);
      };
    }
    o.forEach(function(C) {
      const T = C.length();
      m ? (l.push(
        C.scale(p(e, i, h, d, T))
      ), c.push(
        C.scale(p(-n, -r, h, d, T))
      )) : (l.push(C.scale(e)), c.push(C.scale(-n))), d += T;
    }), c = c.map(function(C) {
      return u = C.points, u[3] ? C.points = [u[3], u[2], u[1], u[0]] : C.points = [u[2], u[1], u[0]], C;
    }).reverse();
    const v = l[0].points[0], _ = l[a - 1].points[l[a - 1].points.length - 1], g = c[a - 1].points[c[a - 1].points.length - 1], x = c[0].points[0], M = Ke.makeline(g, v), S = Ke.makeline(_, x), b = [M].concat(l).concat([S]).concat(c);
    return new Ja(b);
  }
  outlineshapes(e, n, i) {
    n = n || e;
    const r = this.outline(e, n).curves, o = [];
    for (let a = 1, l = r.length; a < l / 2; a++) {
      const c = Ke.makeshape(
        r[a],
        r[l - a],
        i
      );
      c.startcap.virtual = a > 1, c.endcap.virtual = a < l / 2 - 1, o.push(c);
    }
    return o;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof fn && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = og(e.p1.x, e.p2.x), i = og(e.p1.y, e.p2.y), r = ag(e.p1.x, e.p2.x), o = ag(e.p1.y, e.p2.y);
    return Ke.roots(this.points, e).filter((a) => {
      var l = this.get(a);
      return Ke.between(l.x, n, r) && Ke.between(l.y, i, o);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), i = n.length - 2, r = [];
    for (let o = 0, a, l, c; o < i; o++)
      l = n.slice(o, o + 1), c = n.slice(o + 2), a = this.curveintersects(l, c, e), r.push(...a);
    return r;
  }
  curveintersects(e, n, i) {
    const r = [];
    e.forEach(function(a) {
      n.forEach(function(l) {
        a.overlaps(l) && r.push({ left: a, right: l });
      });
    });
    let o = [];
    return r.forEach(function(a) {
      const l = Ke.pairiteration(
        a.left,
        a.right,
        i
      );
      l.length > 0 && (o = o.concat(l));
    }), o;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, i, r) {
    const o = (r - i) / 4, a = this.get(i + o), l = this.get(r - o), c = Ke.dist(e, n), u = Ke.dist(e, a), d = Ke.dist(e, l);
    return Ta(u - c) + Ta(d - c);
  }
  _iterate(e, n) {
    let i = 0, r = 1, o;
    do {
      o = 0, r = 1;
      let a = this.get(i), l, c, u, d, h = !1, m = !1, p, v = r, _ = 1;
      do
        if (m = h, d = u, v = (i + r) / 2, l = this.get(v), c = this.get(r), u = Ke.getccenter(a, l, c), u.interval = {
          start: i,
          end: r
        }, h = this._error(u, a, i, r) <= e, p = m && !h, p || (_ = r), h) {
          if (r >= 1) {
            if (u.interval.end = _ = 1, d = u, r > 1) {
              let x = {
                x: u.x + u.r * EV(u.e),
                y: u.y + u.r * AV(u.e)
              };
              u.e += Ke.angle({ x: u.x, y: u.y }, x, this.get(1));
            }
            break;
          }
          r = r + (r - i) / 2;
        } else
          r = v;
      while (!p && o++ < 100);
      if (o >= 100)
        break;
      d = d || u, n.push(d), i = _;
    } while (r < 1);
    return n;
  }
};
const DV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: jy
}, Symbol.toStringTag, { value: "Module" })), lg = DV;
class kV {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    fe(this, "curve");
    fe(this, "lut");
    fe(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, i = this.curve.get(0);
    for (let r = 0; r <= e; r++) {
      const o = r / e, a = this.curve.get(o);
      if (r > 0) {
        const l = a.x - i.x, c = a.y - i.y;
        n += Math.sqrt(l * l + c * c);
      }
      this.lut.push({
        t: o,
        length: n
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.lut.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.lut[l].length < e ? n = l + 1 : i = l;
    }
    const r = this.lut[n], o = this.lut[Math.max(0, n - 1)];
    if (r.length === o.length)
      return r.t;
    const a = (e - o.length) / (r.length - o.length);
    return o.t + a * (r.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], i = this.totalLength / (e - 1);
    for (let r = 0; r < e; r++) {
      const o = r * i;
      n.push(this.getPointAtDistance(o));
    }
    return n;
  }
}
function IV(s) {
  if (!s || s.length < 2)
    return null;
  let e = null;
  for (const n of s) {
    const [i, ...r] = n;
    if (i === "M")
      e = { x: r[0], y: r[1] };
    else {
      if (i === "C" && e)
        return new lg(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point 1
          r[2],
          r[3],
          // control point 2
          r[4],
          r[5]
          // end point
        );
      if (i === "Q" && e)
        return new lg(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point
          r[2],
          r[3]
          // end point
        );
    }
  }
  return null;
}
const Yy = /* @__PURE__ */ Math.sqrt(3), LV = 0.5 * (Yy - 1), Aa = (3 - Yy) / 6, cg = (s) => Math.floor(s) | 0, ug = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function FV(s = Math.random) {
  const e = UV(s), n = new Float64Array(e).map((r) => ug[r % 12 * 2]), i = new Float64Array(e).map((r) => ug[r % 12 * 2 + 1]);
  return function(o, a) {
    let l = 0, c = 0, u = 0;
    const d = (o + a) * LV, h = cg(o + d), m = cg(a + d), p = (h + m) * Aa, v = h - p, _ = m - p, g = o - v, x = a - _;
    let M, S;
    g > x ? (M = 1, S = 0) : (M = 0, S = 1);
    const b = g - M + Aa, C = x - S + Aa, T = g - 1 + 2 * Aa, P = x - 1 + 2 * Aa, E = h & 255, y = m & 255;
    let w = 0.5 - g * g - x * x;
    if (w >= 0) {
      const R = E + e[y], O = n[R], A = i[R];
      w *= w, l = w * w * (O * g + A * x);
    }
    let D = 0.5 - b * b - C * C;
    if (D >= 0) {
      const R = E + M + e[y + S], O = n[R], A = i[R];
      D *= D, c = D * D * (O * b + A * C);
    }
    let U = 0.5 - T * T - P * P;
    if (U >= 0) {
      const R = E + 1 + e[y + 1], O = n[R], A = i[R];
      U *= U, u = U * U * (O * T + A * P);
    }
    return 70 * (l + c + u);
  };
}
function UV(s) {
  const n = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++)
    n[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    const r = i + ~~(s() * (256 - i)), o = n[i];
    n[i] = n[r], n[r] = o;
  }
  for (let i = 256; i < 512; i++)
    n[i] = n[i - 256];
  return n;
}
function OV() {
  return {
    enabled: !1,
    particleCollision: !1,
    particleCollisionRadius: 1,
    particleCollisionResponse: "bounce",
    particleCollisionDamping: 0.8,
    layerCollision: !1,
    layerCollisionLayerId: null,
    layerCollisionThreshold: 0.5,
    floorEnabled: !1,
    floorY: 1,
    ceilingEnabled: !1,
    ceilingY: 0,
    wallsEnabled: !1,
    bounciness: 0.7,
    friction: 0.1,
    spatialHashCellSize: 50
  };
}
function zV() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function NV() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: [],
    collision: OV()
  };
}
function dg() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: zV(),
    spriteSmoothing: !0,
    spriteOpacityByAge: !0
  };
}
class tp {
  constructor(e = {}) {
    fe(this, "particles", []);
    fe(this, "emitters", /* @__PURE__ */ new Map());
    fe(this, "gravityWells", /* @__PURE__ */ new Map());
    fe(this, "vortices", /* @__PURE__ */ new Map());
    fe(this, "modulations", []);
    fe(this, "config");
    fe(this, "boundaryMask", null);
    fe(this, "frameCount", 0);
    fe(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    fe(this, "nextParticleId", 0);
    fe(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    fe(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator
    fe(this, "noise2D");
    fe(this, "noiseTime", 0);
    // Render options cache for spatial grid
    fe(this, "renderOptions", dg());
    // Sprite image cache - maps emitter ID to loaded image
    fe(this, "spriteCache", /* @__PURE__ */ new Map());
    // Collision spatial hash grid
    fe(this, "collisionGrid", /* @__PURE__ */ new Map());
    fe(this, "collisionGridCellSize", 50);
    this.config = { ...NV(), ...e }, this.noise2D = FV(), this.config.collision && (this.collisionGridCellSize = this.config.collision.spatialHashCellSize);
  }
  // ============================================================================
  // Sprite Management
  // ============================================================================
  /**
   * Load a sprite image for an emitter
   */
  async loadSprite(e, n) {
    return new Promise((i, r) => {
      const o = new Image();
      o.crossOrigin = "anonymous", o.onload = () => {
        this.spriteCache.set(e, o);
        const a = this.emitters.get(e);
        a && a.sprite && (a.sprite.imageData = o), i();
      }, o.onerror = r, o.src = n;
    });
  }
  /**
   * Set sprite image directly (for pre-loaded images)
   */
  setSpriteImage(e, n) {
    this.spriteCache.set(e, n);
    const i = this.emitters.get(e);
    i && i.sprite && (i.sprite.imageData = n);
  }
  /**
   * Get sprite image for an emitter
   */
  getSpriteImage(e) {
    return this.spriteCache.get(e) ?? null;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let i = 0; i < n; i++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const i = this.gravityWells.get(e);
    i && Object.assign(i, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const i = this.vortices.get(e);
    i && Object.assign(i, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((i) => i.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, i) {
    const r = i ? `${i}:${e}` : `*:${e}`;
    this.featureOverrides.set(r, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    var u, d, h, m;
    this.emitters.forEach((p, v) => {
      if (!p.enabled) return;
      const g = (this.getFeatureValue("emissionRate", v) ?? p.emissionRate) * e;
      let x = (this.emissionAccumulators.get(v) || 0) + g;
      for (; x >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(p), x -= 1;
      this.emissionAccumulators.set(v, x);
    });
    const n = this.config.windDirection * Math.PI / 180, i = Math.cos(n) * this.config.windStrength * 1e-3, r = Math.sin(n) * this.config.windStrength * 1e-3, o = this.getFeatureValue("gravity", "*") ?? this.config.gravity, a = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = i * (a / Math.max(1, this.config.windStrength)), c = r * (a / Math.max(1, this.config.windStrength));
    for (let p = this.particles.length - 1; p >= 0; p--) {
      const v = this.particles[p];
      if (v.prevX = v.x, v.prevY = v.y, this.trailHistory.has(v.id)) {
        const x = this.trailHistory.get(v.id);
        x.unshift({ x: v.x, y: v.y }), x.length > 20 && x.pop();
      }
      v.vy += o * 1e-3 * e, v.vx += l * e, v.vy += c * e, this.gravityWells.forEach((x) => {
        if (!x.enabled) return;
        const M = x.x - v.x, S = x.y - v.y, b = Math.sqrt(M * M + S * S);
        if (b < x.radius && b > 1e-3) {
          let C = x.strength * 1e-4;
          switch (x.falloff) {
            case "linear":
              C *= 1 - b / x.radius;
              break;
            case "quadratic":
              C *= Math.pow(1 - b / x.radius, 2);
              break;
          }
          const T = M / b, P = S / b;
          v.vx += T * C * e, v.vy += P * C * e;
        }
      }), this.vortices.forEach((x) => {
        if (!x.enabled) return;
        const M = x.x - v.x, S = x.y - v.y, b = Math.sqrt(M * M + S * S);
        if (b < x.radius && b > 1e-3) {
          const C = 1 - b / x.radius, T = x.strength * 1e-4 * C, P = M / b, E = S / b, y = -E, w = P;
          v.vx += y * T * e, v.vy += w * T * e;
          const D = x.inwardPull * 1e-4 * C;
          v.vx += P * D * e, v.vy += E * D * e;
        }
      }), this.applyTurbulence(v, e);
      const _ = 1 - this.config.friction;
      v.vx *= _, v.vy *= _, v.angularVelocity !== 0 && (v.rotation += v.angularVelocity * e);
      const g = this.emitters.get(v.emitterId);
      (u = g == null ? void 0 : g.sprite) != null && u.alignToVelocity && (v.vx !== 0 || v.vy !== 0) && (v.rotation = Math.atan2(v.vy, v.vx)), (d = g == null ? void 0 : g.sprite) != null && d.isSheet && g.sprite.totalFrames > 1 && this.updateSpriteFrame(v, g.sprite, e), v.x += v.vx * e, v.y += v.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(v), this.handleCanvasBoundary(v), this.applyModulations(v), v.age += e, v.age > v.lifetime && (v.isSubParticle || this.triggerSubEmitters(v), this.particles.splice(p, 1), this.trailHistory.delete(v.id));
    }
    (h = this.config.collision) != null && h.enabled && this.config.collision.particleCollision && this.handleParticleCollisions(), (m = this.config.collision) != null && m.enabled && this.handleEnvironmentCollisions(), this.noiseTime += e, this.frameCount++;
  }
  /**
   * Update sprite animation frame based on age and play mode
   */
  updateSpriteFrame(e, n, i) {
    const r = n.totalFrames;
    switch (e.age / e.lifetime, n.playMode) {
      case "loop": {
        const o = Math.floor(e.age * n.frameRate / 60);
        e.spriteIndex = o % r;
        break;
      }
      case "once": {
        const o = Math.floor(e.age * n.frameRate / 60);
        e.spriteIndex = Math.min(o, r - 1);
        break;
      }
      case "pingpong": {
        const o = Math.floor(e.age * n.frameRate / 60), a = Math.floor(o / (r - 1)), l = o % (r - 1);
        e.spriteIndex = a % 2 === 0 ? l : r - 1 - l;
        break;
      }
      case "random": {
        Math.random() < 0.1 && (e.spriteIndex = Math.floor(Math.random() * r));
        break;
      }
    }
  }
  /**
   * Handle particle-to-particle collisions using spatial hashing
   */
  handleParticleCollisions() {
    const e = this.config.collision;
    if (!e || !e.particleCollision) return;
    this.collisionGrid.clear();
    const n = this.collisionGridCellSize / 1e3;
    for (const r of this.particles) {
      const o = Math.floor(r.x / n), a = Math.floor(r.y / n), l = `${o},${a}`;
      this.collisionGrid.has(l) || this.collisionGrid.set(l, []), this.collisionGrid.get(l).push(r);
    }
    const i = /* @__PURE__ */ new Set();
    for (const r of this.particles) {
      const o = Math.floor(r.x / n), a = Math.floor(r.y / n);
      for (let l = -1; l <= 1; l++)
        for (let c = -1; c <= 1; c++) {
          const u = `${o + l},${a + c}`, d = this.collisionGrid.get(u);
          if (d)
            for (const h of d) {
              if (h.id <= r.id) continue;
              const m = `${Math.min(r.id, h.id)}-${Math.max(r.id, h.id)}`;
              if (i.has(m)) continue;
              i.add(m);
              const p = r.size / 1e3 * e.particleCollisionRadius, v = h.size / 1e3 * e.particleCollisionRadius, _ = p + v, g = h.x - r.x, x = h.y - r.y, M = g * g + x * x;
              if (M < _ * _ && M > 1e-6) {
                const S = Math.sqrt(M), b = g / S, C = x / S;
                switch (e.particleCollisionResponse) {
                  case "bounce": {
                    const T = r.vx - h.vx, P = r.vy - h.vy, E = T * b + P * C;
                    if (E > 0) {
                      const y = e.particleCollisionDamping;
                      r.vx -= E * b * y, r.vy -= E * C * y, h.vx += E * b * y, h.vy += E * C * y;
                      const w = _ - S;
                      r.x -= b * w * 0.5, r.y -= C * w * 0.5, h.x += b * w * 0.5, h.y += C * w * 0.5;
                    }
                    break;
                  }
                  case "absorb": {
                    r.size > h.size ? (r.size += h.size * 0.1, h.age = h.lifetime + 1) : (h.size += r.size * 0.1, r.age = r.lifetime + 1);
                    break;
                  }
                  case "explode": {
                    r.age = r.lifetime + 1, h.age = h.lifetime + 1;
                    break;
                  }
                }
                r.collisionCount++, h.collisionCount++;
              }
            }
        }
    }
  }
  /**
   * Handle floor, ceiling, and wall collisions
   */
  handleEnvironmentCollisions() {
    const e = this.config.collision;
    if (!(e != null && e.enabled)) return;
    const n = e.bounciness, i = e.friction;
    for (const r of this.particles)
      e.floorEnabled && r.y > e.floorY && (r.y = e.floorY, r.vy = -r.vy * n, r.vx *= 1 - i, r.collisionCount++), e.ceilingEnabled && r.y < e.ceilingY && (r.y = e.ceilingY, r.vy = -r.vy * n, r.vx *= 1 - i, r.collisionCount++), e.wallsEnabled && (r.x < 0 && (r.x = 0, r.vx = -r.vx * n, r.vy *= 1 - i, r.collisionCount++), r.x > 1 && (r.x = 1, r.vx = -r.vx * n, r.vy *= 1 - i, r.collisionCount++));
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = this.getEmitterSpawnPosition(e), i = e.spread * Math.PI / 180, o = e.direction * Math.PI / 180 + (Math.random() - 0.5) * i, l = (e.speed + (Math.random() - 0.5) * 2 * e.speedVariance) * 1e-3, c = Math.max(1, e.size + (Math.random() - 0.5) * 2 * e.sizeVariance), u = Math.max(1, e.particleLifetime + (Math.random() - 0.5) * 2 * e.lifetimeVariance);
    let d = 0, h = 0;
    const m = e.sprite;
    if (m && m.rotationEnabled) {
      d = Math.random() * Math.PI * 2;
      const _ = m.rotationSpeed * (Math.PI / 180), g = m.rotationSpeedVariance * (Math.PI / 180);
      h = _ + (Math.random() - 0.5) * 2 * g;
    }
    m && m.alignToVelocity && (d = o);
    let p = 0;
    m && m.isSheet && m.playMode === "random" && (p = Math.floor(Math.random() * m.totalFrames));
    const v = {
      id: this.nextParticleId++,
      x: n.x,
      y: n.y,
      prevX: n.x,
      prevY: n.y,
      vx: Math.cos(o) * l,
      vy: Math.sin(o) * l,
      age: 0,
      lifetime: u,
      size: c,
      baseSize: c,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1,
      rotation: d,
      angularVelocity: h,
      spriteIndex: p,
      collisionCount: 0
    };
    this.particles.push(v), this.trailHistory.set(v.id, [{ x: v.x, y: v.y }]);
  }
  /**
   * Calculate spawn position based on emitter shape
   */
  getEmitterSpawnPosition(e) {
    switch (e.shape || "point") {
      case "point":
        return { x: e.x, y: e.y };
      case "line": {
        const i = Math.random(), r = e.shapeWidth / 2, o = e.direction * Math.PI / 180, a = -Math.sin(o), l = Math.cos(o);
        return {
          x: e.x + a * (i - 0.5) * r * 2,
          y: e.y + l * (i - 0.5) * r * 2
        };
      }
      case "circle": {
        const i = e.shapeRadius;
        if (e.emitFromEdge) {
          const r = Math.random() * Math.PI * 2;
          return {
            x: e.x + Math.cos(r) * i,
            y: e.y + Math.sin(r) * i
          };
        } else {
          const r = Math.random() * Math.PI * 2, o = i * Math.sqrt(Math.random());
          return {
            x: e.x + Math.cos(r) * o,
            y: e.y + Math.sin(r) * o
          };
        }
      }
      case "ring": {
        const i = e.shapeInnerRadius, r = e.shapeRadius, o = Math.random() * Math.PI * 2, a = Math.sqrt(Math.random() * (r * r - i * i) + i * i);
        return {
          x: e.x + Math.cos(o) * a,
          y: e.y + Math.sin(o) * a
        };
      }
      case "box": {
        const i = e.shapeWidth / 2, r = e.shapeHeight / 2;
        if (e.emitFromEdge) {
          const o = 2 * (e.shapeWidth + e.shapeHeight), a = Math.random() * o;
          return a < e.shapeWidth ? { x: e.x - i + a, y: e.y - r } : a < e.shapeWidth + e.shapeHeight ? { x: e.x + i, y: e.y - r + (a - e.shapeWidth) } : a < 2 * e.shapeWidth + e.shapeHeight ? { x: e.x + i - (a - e.shapeWidth - e.shapeHeight), y: e.y + r } : { x: e.x - i, y: e.y + r - (a - 2 * e.shapeWidth - e.shapeHeight) };
        } else
          return {
            x: e.x + (Math.random() - 0.5) * e.shapeWidth,
            y: e.y + (Math.random() - 0.5) * e.shapeHeight
          };
      }
      case "sphere": {
        const i = e.shapeRadius;
        if (e.emitFromEdge) {
          const r = Math.random() * Math.PI * 2, o = Math.acos(2 * Math.random() - 1);
          return {
            x: e.x + Math.sin(o) * Math.cos(r) * i,
            y: e.y + Math.sin(o) * Math.sin(r) * i
            // z would be: Math.cos(phi) * radius
          };
        } else {
          let r, o, a;
          do
            r = (Math.random() - 0.5) * 2, o = (Math.random() - 0.5) * 2, a = (Math.random() - 0.5) * 2;
          while (r * r + o * o + a * a > 1);
          return {
            x: e.x + r * i,
            y: e.y + o * i
          };
        }
      }
      default:
        return { x: e.x, y: e.y };
    }
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), i = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || i < 0 || i >= this.boundaryMask.height)
      return;
    const r = (i * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[r] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = Math.random(), e.y = Math.random();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const i of this.modulations) {
      if (i.emitterId !== "*" && i.emitterId !== e.emitterId) continue;
      const r = i.easing, o = au[r] || au.linear, a = zT(n, o), l = i.startValue + (i.endValue - i.startValue) * a;
      switch (i.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const c = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (c > 1e-4) {
            const u = l / Math.max(1e-4, c * 1e3);
            e.vx *= u, e.vy *= u;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const i = this.config.turbulenceFields || [];
    for (const r of i) {
      if (!r.enabled) continue;
      const o = e.x * r.scale * 1e3, a = e.y * r.scale * 1e3, l = this.noiseTime * r.evolutionSpeed, c = this.noise2D(o + l, a + l) * Math.PI * 2, u = r.strength * 1e-5;
      e.vx += Math.cos(c) * u * n, e.vy += Math.sin(c) * u * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var r;
    const i = (r = this.config.turbulenceFields) == null ? void 0 : r.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const i of n)
      if (i.enabled && !(i.parentEmitterId !== "*" && i.parentEmitterId !== e.emitterId))
        for (let r = 0; r < i.spawnCount; r++) {
          const o = (Math.random() - 0.5) * i.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + o, c = Math.sqrt(e.vx ** 2 + e.vy ** 2) * i.inheritVelocity, u = i.speed * 1e-3 + c, d = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * u + e.vx * i.inheritVelocity,
            vy: Math.sin(l) * u + e.vy * i.inheritVelocity,
            age: 0,
            lifetime: i.lifetime * (1 + (Math.random() - 0.5) * 0.2),
            size: i.size * (1 + (Math.random() - 0.5) * i.sizeVariance / i.size),
            baseSize: i.size,
            color: [...i.color, 255],
            baseColor: [...i.color, 255],
            emitterId: i.id,
            isSubParticle: !0,
            rotation: e.rotation,
            // Inherit parent rotation
            angularVelocity: 0,
            spriteIndex: 0,
            collisionCount: 0
          };
          this.particles.push(d), this.trailHistory.set(d.id, [{ x: d.x, y: d.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var r;
    const i = (r = this.config.subEmitters) == null ? void 0 : r.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const i = this.emitters.get(e);
    if (!i || !i.enabled) return;
    const r = n ?? i.burstCount ?? 20;
    for (let o = 0; o < r; o++)
      this.spawnParticle(i);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var i;
    const e = ((i = this.renderOptions.connections) == null ? void 0 : i.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const r of this.particles) {
      const o = Math.floor(r.x * 1e3 / e), a = Math.floor(r.y * 1e3 / e), l = `${o},${a}`;
      n.has(l) || n.set(l, []), n.get(l).push(r);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const i = Math.floor(e.x * 1e3 / n.cellSize), r = Math.floor(e.y * 1e3 / n.cellSize), o = [];
    for (let a = -1; a <= 1; a++)
      for (let l = -1; l <= 1; l++) {
        const c = `${i + a},${r + l}`, u = n.cells.get(c);
        u && o.push(...u);
      }
    return o;
  }
  renderConnections(e, n, i) {
    const r = this.renderOptions.connections;
    if (!(r != null && r.enabled) || this.particles.length < 2) return;
    const o = this.buildSpatialGrid(), a = r.maxDistance / 1e3, l = a * a;
    e.lineWidth = r.lineWidth;
    for (const c of this.particles) {
      const u = this.getNeighborParticles(c, o);
      let d = 0;
      for (const h of u) {
        if (h.id <= c.id) continue;
        if (d >= r.maxConnections) break;
        const m = h.x - c.x, p = h.y - c.y, v = m * m + p * p;
        if (v < l) {
          const _ = Math.sqrt(v);
          let g = r.lineOpacity;
          r.fadeByDistance && (g *= 1 - _ / a);
          const x = Math.round((c.color[0] + h.color[0]) / 2), M = Math.round((c.color[1] + h.color[1]) / 2), S = Math.round((c.color[2] + h.color[2]) / 2);
          e.strokeStyle = `rgba(${x},${M},${S},${g})`, e.beginPath(), e.moveTo(c.x * n, c.y * i), e.lineTo(h.x * n, h.y * i), e.stroke(), d++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, i, r = dg()) {
    switch (this.renderOptions = r, e.save(), r.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, i);
    for (const o of this.particles) {
      const a = o.x * n, l = o.y * i, c = o.size;
      if (r.renderTrails) {
        const u = this.trailHistory.get(o.id);
        if (u && u.length > 1) {
          e.beginPath(), e.moveTo(a, l);
          const d = Math.min(u.length, r.trailLength);
          for (let h = 0; h < d; h++) {
            const m = u[h], p = o.color[3] * Math.pow(r.trailOpacityFalloff, h + 1);
            e.strokeStyle = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${p / 255})`, e.lineWidth = c * Math.pow(r.trailOpacityFalloff, h), e.lineTo(m.x * n, m.y * i);
          }
          e.stroke();
        }
      }
      r.glowEnabled ? (e.shadowBlur = r.glowRadius, e.shadowColor = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${r.glowIntensity})`) : e.shadowBlur = 0, r.motionBlur && (o.vx !== 0 || o.vy !== 0) ? this.renderParticleWithMotionBlur(e, o, a, l, c, n, i, r) : this.renderParticleShape(e, a, l, c, o.color, r.particleShape, o, r);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, i, r, o, a, l, c) {
    const u = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (u < 1e-4) {
      this.renderParticleShape(e, i, r, o, n.color, c.particleShape);
      return;
    }
    const d = c.motionBlurStrength * u * 500, h = Math.min(c.motionBlurSamples, 16), m = n.vx / u, p = n.vy / u, v = Math.min(d * o, o * 10);
    for (let _ = 0; _ < h; _++) {
      const g = _ / (h - 1), x = (1 - g * 0.8) / h, M = i - m * v * g, S = r - p * v * g, b = o * (1 - g * 0.3), C = n.color[3] / 255 * x * h;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, C)})`, this.renderParticleShape(e, M, S, b, null, c.particleShape, n, c);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, i, r, o, n.color, c.particleShape, n, c);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, i, r, o, a, l, c) {
    if (o && (e.fillStyle = `rgba(${o[0]}, ${o[1]}, ${o[2]}, ${o[3] / 255})`), a === "sprite" && l) {
      this.renderSprite(e, n, i, r, l, c);
      return;
    }
    if (l && l.rotation !== 0 && l)
      e.save(), e.translate(n, i), e.rotate(l.rotation), this.drawShapeAtOrigin(e, r, a), e.restore();
    else
      switch (a) {
        case "circle":
          e.beginPath(), e.arc(n, i, r / 2, 0, Math.PI * 2), e.fill();
          break;
        case "square":
          e.fillRect(n - r / 2, i - r / 2, r, r);
          break;
        case "triangle":
          e.beginPath(), e.moveTo(n, i - r / 2), e.lineTo(n - r / 2, i + r / 2), e.lineTo(n + r / 2, i + r / 2), e.closePath(), e.fill();
          break;
        case "star":
          this.drawStar(e, n, i, 5, r / 2, r / 4), e.fill();
          break;
      }
  }
  /**
   * Draw shape at origin (for rotated shapes)
   */
  drawShapeAtOrigin(e, n, i) {
    switch (i) {
      case "circle":
        e.beginPath(), e.arc(0, 0, n / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(-n / 2, -n / 2, n, n);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(0, -n / 2), e.lineTo(-n / 2, n / 2), e.lineTo(n / 2, n / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, 0, 0, 5, n / 2, n / 4), e.fill();
        break;
    }
  }
  /**
   * Render a sprite/texture particle
   */
  renderSprite(e, n, i, r, o, a) {
    var g;
    const l = this.emitters.get(o.emitterId);
    if (!((g = l == null ? void 0 : l.sprite) != null && g.enabled)) {
      e.beginPath(), e.arc(n, i, r / 2, 0, Math.PI * 2), e.fill();
      return;
    }
    const c = l.sprite, u = c.imageData || this.spriteCache.get(o.emitterId);
    if (!u) {
      e.beginPath(), e.arc(n, i, r / 2, 0, Math.PI * 2), e.fill();
      return;
    }
    e.save(), e.imageSmoothingEnabled = (a == null ? void 0 : a.spriteSmoothing) ?? !0;
    let d = o.color[3] / 255;
    if (a != null && a.spriteOpacityByAge) {
      const x = o.age / o.lifetime;
      x > 0.8 && (d *= 1 - (x - 0.8) / 0.2);
    }
    e.globalAlpha = d;
    let h = 0, m = 0, p = u.width, v = u.height;
    if (c.isSheet && c.columns > 1 || c.rows > 1) {
      const x = u.width / c.columns, M = u.height / c.rows, S = o.spriteIndex % c.columns, b = Math.floor(o.spriteIndex / c.columns) % c.rows;
      h = S * x, m = b * M, p = x, v = M;
    }
    e.translate(n, i), o.rotation !== 0 && e.rotate(o.rotation);
    const _ = r / 2;
    e.drawImage(
      u,
      h,
      m,
      p,
      v,
      // Source rectangle
      -_,
      -_,
      r,
      r
      // Destination rectangle
    ), e.restore();
  }
  drawStar(e, n, i, r, o, a) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let c = 0; c < r; c++) {
      const u = n + Math.cos(l) * o, d = i + Math.sin(l) * o;
      c === 0 ? e.moveTo(u, d) : e.lineTo(u, d), l += Math.PI / r;
      const h = n + Math.cos(l) * a, m = i + Math.sin(l) * a;
      e.lineTo(h, m), l += Math.PI / r;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const r = new OffscreenCanvas(e, n).getContext("2d");
    r.fillStyle = "#FFFFFF", r.fillRect(0, 0, e, n);
    const o = this.renderOptions.connections;
    o != null && o.enabled && this.particles.length >= 2 && (r.strokeStyle = "#000000", r.lineWidth = o.lineWidth * 2, this.renderConnections(r, e, n)), r.fillStyle = "#000000";
    for (const a of this.particles) {
      const l = a.x * e, c = a.y * n, u = a.size * 1.5;
      r.beginPath(), r.arc(l, c, u / 2, 0, Math.PI * 2), r.fill();
    }
    return r.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new tp(e.config);
    if (e.emitters)
      for (const i of e.emitters)
        n.addEmitter(i);
    if (e.gravityWells)
      for (const i of e.gravityWells)
        n.addGravityWell(i);
    if (e.vortices)
      for (const i of e.vortices)
        n.addVortex(i);
    if (e.modulations)
      for (const i of e.modulations)
        n.addModulation(i);
    return n;
  }
}
class BV {
  constructor() {
    fe(this, "offscreenCanvas", null);
    fe(this, "ctx", null);
    fe(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const i = Math.round(e / 8) * 8, r = Math.round(n / 8) * 8, o = Math.max(256, i), a = Math.max(256, r), l = e === o && n === a;
    return {
      valid: l,
      correctedWidth: o,
      correctedHeight: a,
      message: l ? void 0 : `Adjusted to ${o}x${a} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, i) {
    const { frameCount: r } = e.composition, { width: o, height: a } = n;
    this.offscreenCanvas = new OffscreenCanvas(o, a), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let c = 0; c < r; c++) {
      i && i({
        frame: c,
        total: r,
        percent: Math.round(c / r * 100)
      }), this.stepParticleSystemsToFrame(e, c);
      const u = await this.generateFrame(e, c, n);
      l.push(u);
    }
    return this.particleSystems.clear(), i && i({
      frame: r,
      total: r,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, i) {
    const r = this.ctx, { width: o, height: a } = i;
    if (r.fillStyle = "#FFFFFF", r.fillRect(0, 0, o, a), i.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    r.fillStyle = "#000000";
    const l = o / e.composition.width, c = a / e.composition.height, u = e.layers.filter(
      (h) => h.type === "text" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of u)
      await this.renderTextLayerToMatte(r, h, e, n, l, c);
    const d = e.layers.filter(
      (h) => h.type === "particles" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of d)
      this.renderParticleLayerToMatte(r, h, o, a);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, i) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== i.width || this.offscreenCanvas.height !== i.height) && (this.offscreenCanvas = new OffscreenCanvas(i.width, i.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const r = await this.generateFrame(e, n, i);
    return URL.createObjectURL(r);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, i, r, o, a) {
    const l = n.data;
    if (!l) return;
    const c = n.properties.find((h) => h.name === "fontSize"), d = (c ? an(c, r) : l.fontSize) * Math.min(o, a);
    e.font = `${l.fontWeight} ${d}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, i, r, d, o, a) : this.renderTextBlockToMatte(e, n, l, r, d, o, a);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, i, r, o, a, l, c) {
    const u = r.layers.find((S) => S.id === i.pathLayerId);
    if (!u || u.type !== "spline") return;
    const d = u.data;
    if (!(d != null && d.controlPoints) || d.controlPoints.length < 2) return;
    const h = this.buildPathCommands(d);
    if (!h || h.length < 2) return;
    const m = IV(h);
    if (!m) return;
    const p = new kV(m), v = n.properties.find((S) => S.name === "pathOffset"), _ = v ? an(v, o) : i.pathOffset, g = p.totalLength;
    let x = _ * g;
    const M = 4 * Math.min(l, c);
    for (const S of i.text) {
      if (S === " ") {
        const D = e.measureText(" ").width;
        x += D + i.letterSpacing;
        continue;
      }
      const b = e.measureText(S).width, C = Math.max(0, Math.min(x, g)), { point: T, tangent: P } = p.getPointAtDistance(C), E = Math.atan2(P.y, P.x), y = T.x * l, w = T.y * c;
      e.save(), e.translate(y, w), e.rotate(E), e.fillRect(
        -M,
        -a - M,
        b + M * 2,
        a + M * 2
      ), e.restore(), x += b + i.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const i = [];
    i.push(["M", n[0].x, n[0].y]);
    for (let r = 0; r < n.length - 1; r++) {
      const o = n[r], a = n[r + 1], l = o.handleOut || { x: o.x, y: o.y }, c = a.handleIn || { x: a.x, y: a.y };
      i.push([
        "C",
        l.x,
        l.y,
        c.x,
        c.y,
        a.x,
        a.y
      ]);
    }
    return i;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, i, r, o, a, l) {
    const c = n.transform.position, u = an(c, r), d = n.transform.rotation, h = an(d, r), m = n.transform.scale, p = an(m, r);
    e.save(), e.translate(u.x * a, u.y * l), e.rotate(h * Math.PI / 180), e.scale(p.x, p.y);
    const _ = e.measureText(i.text).width, g = o, x = 4;
    e.fillRect(
      -x,
      -g - x,
      _ + x * 2,
      g + x * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", i) {
    const r = (await Promise.resolve().then(() => gH)).default, o = new r();
    e.forEach((u, d) => {
      const h = `${n}_${String(d).padStart(4, "0")}.png`;
      o.file(h, u);
    });
    const a = await o.generateAsync(
      { type: "blob" },
      (u) => {
        i && i(Math.round(u.percent));
      }
    ), l = URL.createObjectURL(a), c = document.createElement("a");
    c.href = l, c.download = `${n}.zip`, document.body.appendChild(c), c.click(), document.body.removeChild(c), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (i) => i.type === "particles"
    );
    for (const i of n) {
      const r = i.data;
      if (!r) continue;
      const o = new tp(r.systemConfig);
      for (const l of r.emitters)
        o.addEmitter(l);
      for (const l of r.gravityWells)
        o.addGravityWell(l);
      for (const l of r.vortices)
        o.addVortex(l);
      for (const l of r.modulations)
        o.addModulation(l);
      const a = r.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < a; l++)
        o.step();
      this.particleSystems.set(i.id, o);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const i of e.layers) {
        if (i.type !== "particles") continue;
        const r = this.particleSystems.get(i.id);
        r && i.visible && n >= i.inPoint && n <= i.outPoint && r.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, i, r) {
    const o = this.particleSystems.get(n.id);
    if (!o) return;
    const a = o.renderToMask(i, r), l = new OffscreenCanvas(i, r);
    l.getContext("2d").putImageData(a, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const Tr = new BV(), VV = { class: "export-dialog" }, GV = { class: "dialog-header" }, HV = { class: "dialog-content" }, $V = { class: "form-group" }, WV = { class: "resolution-presets" }, XV = ["onClick"], jV = { class: "custom-resolution" }, YV = { class: "dimension-input" }, qV = { class: "dimension-input" }, ZV = {
  key: 0,
  class: "dimension-warning"
}, KV = { class: "form-group" }, JV = { class: "matte-mode-options" }, QV = { class: "form-group" }, e7 = { class: "preview-container" }, t7 = ["src"], n7 = {
  key: 1,
  class: "preview-placeholder"
}, i7 = {
  key: 0,
  class: "progress-section"
}, s7 = { class: "progress-bar" }, r7 = { class: "progress-text" }, o7 = { class: "dialog-footer" }, a7 = { class: "export-info" }, l7 = ["disabled"], c7 = ["disabled"], u7 = /* @__PURE__ */ Ot({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = e, i = sn(), r = Tr.getResolutionPresets(), o = we("720p (1280x720)"), a = we(1280), l = we(720), c = we(), u = we("exclude_text"), d = we(null), h = we(!1), m = we(0), p = we(""), v = Ie(() => a.value), _ = Ie(() => l.value);
    function g(b) {
      o.value = b.label, a.value = b.width, l.value = b.height, c.value = void 0;
    }
    function x() {
      const b = Tr.validateDimensions(a.value, l.value);
      if (!b.valid)
        a.value = b.correctedWidth, l.value = b.correctedHeight, c.value = b.message, o.value = "";
      else {
        c.value = void 0;
        const C = r.find(
          (T) => T.width === a.value && T.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "";
      }
    }
    async function M() {
      if (!i.hasProject) return;
      d.value && (URL.revokeObjectURL(d.value), d.value = null);
      const b = {
        width: v.value,
        height: _.value,
        matteMode: u.value
      };
      d.value = await Tr.generatePreviewFrame(
        i.project,
        0,
        b
      );
    }
    async function S() {
      if (h.value || !i.hasProject) return;
      h.value = !0, m.value = 0, p.value = "Generating frames...";
      const b = {
        width: v.value,
        height: _.value,
        matteMode: u.value
      };
      try {
        const C = await Tr.generateMatteSequence(
          i.project,
          b,
          (T) => {
            m.value = T.percent, p.value = `Generating frame ${T.frame + 1} of ${T.total}...`;
          }
        );
        p.value = "Creating ZIP archive...", await Tr.downloadAsZip(
          C,
          `matte_${Date.now()}`,
          (T) => {
            p.value = `Compressing... ${T}%`;
          }
        ), p.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (C) {
        console.error("[ExportDialog] Export failed:", C), p.value = `Export failed: ${C instanceof Error ? C.message : "Unknown error"}`;
      } finally {
        h.value = !1;
      }
    }
    return Ft(
      [v, _, u],
      () => {
        M();
      },
      { immediate: !1 }
    ), xn(() => {
      if (i.hasProject) {
        const b = Tr.validateDimensions(i.width, i.height);
        a.value = b.correctedWidth, l.value = b.correctedHeight;
        const C = r.find(
          (T) => T.width === a.value && T.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "", b.valid || (c.value = b.message);
      }
      M();
    }), Nn(() => {
      d.value && URL.revokeObjectURL(d.value), Tr.dispose();
    }), (b, C) => (te(), ae("div", {
      class: "export-dialog-overlay",
      onClick: C[6] || (C[6] = xt((T) => n("close"), ["self"]))
    }, [
      f("div", VV, [
        f("div", GV, [
          C[8] || (C[8] = f("h3", null, "Export Matte Sequence", -1)),
          f("button", {
            class: "close-btn",
            onClick: C[0] || (C[0] = (T) => n("close"))
          }, [...C[7] || (C[7] = [
            f("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        f("div", HV, [
          f("div", $V, [
            C[13] || (C[13] = f("label", null, "Resolution", -1)),
            f("div", WV, [
              (te(!0), ae(qe, null, ot(Ve(r), (T) => (te(), ae("button", {
                key: T.label,
                class: Fe(["preset-btn", { active: o.value === T.label }]),
                onClick: (P) => g(T)
              }, _e(T.label), 11, XV))), 128))
            ]),
            f("div", jV, [
              f("div", YV, [
                C[9] || (C[9] = f("label", null, "Width", -1)),
                st(f("input", {
                  "onUpdate:modelValue": C[1] || (C[1] = (T) => a.value = T),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: x
                }, null, 544), [
                  [
                    Ut,
                    a.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              C[11] || (C[11] = f("span", { class: "dimension-x" }, "", -1)),
              f("div", qV, [
                C[10] || (C[10] = f("label", null, "Height", -1)),
                st(f("input", {
                  "onUpdate:modelValue": C[2] || (C[2] = (T) => l.value = T),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: x
                }, null, 544), [
                  [
                    Ut,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            c.value ? (te(), ae("p", ZV, [
              C[12] || (C[12] = f("i", { class: "pi pi-info-circle" }, null, -1)),
              ct(" " + _e(c.value), 1)
            ])) : Pe("", !0)
          ]),
          f("div", KV, [
            C[16] || (C[16] = f("label", null, "Matte Mode", -1)),
            f("div", JV, [
              f("button", {
                class: Fe(["mode-btn", { active: u.value === "exclude_text" }]),
                onClick: C[3] || (C[3] = (T) => u.value = "exclude_text")
              }, [...C[14] || (C[14] = [
                f("i", { class: "pi pi-ban" }, null, -1),
                f("span", null, "Exclude Text", -1),
                f("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              f("button", {
                class: Fe(["mode-btn", { active: u.value === "include_all" }]),
                onClick: C[4] || (C[4] = (T) => u.value = "include_all")
              }, [...C[15] || (C[15] = [
                f("i", { class: "pi pi-check-circle" }, null, -1),
                f("span", null, "Include All", -1),
                f("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          f("div", QV, [
            C[18] || (C[18] = f("label", null, "Preview (Frame 0)", -1)),
            f("div", e7, [
              d.value ? (te(), ae("img", {
                key: 0,
                src: d.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, t7)) : (te(), ae("div", n7, [...C[17] || (C[17] = [
                f("i", { class: "pi pi-image" }, null, -1),
                f("span", null, "Generating preview...", -1)
              ])]))
            ]),
            C[19] || (C[19] = f("p", { class: "preview-info" }, [
              ct(" White = Keep original / generate content"),
              f("br"),
              ct(" Black = Exclude from generation ")
            ], -1))
          ]),
          h.value ? (te(), ae("div", i7, [
            f("div", s7, [
              f("div", {
                class: "progress-fill",
                style: yt({ width: `${m.value}%` })
              }, null, 4)
            ]),
            f("p", r7, _e(p.value), 1)
          ])) : Pe("", !0)
        ]),
        f("div", o7, [
          f("div", a7, [
            f("span", null, _e(Ve(i).frameCount) + " frames @ " + _e(v.value) + "" + _e(_.value), 1)
          ]),
          f("button", {
            class: "cancel-btn",
            onClick: C[5] || (C[5] = (T) => n("close")),
            disabled: h.value
          }, " Cancel ", 8, l7),
          f("button", {
            class: "export-btn",
            onClick: S,
            disabled: h.value || !Ve(i).hasProject
          }, [
            C[20] || (C[20] = f("i", { class: "pi pi-download" }, null, -1)),
            ct(" " + _e(h.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, c7)
        ])
      ])
    ]));
  }
}), d7 = /* @__PURE__ */ Gt(u7, [["__scopeId", "data-v-34eee532"]]), h7 = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !1,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  motionctrl: {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 3
  },
  cogvideox: {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ati: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ttm: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  }
}, f7 = {
  midas: {
    format: "midas",
    bitDepth: 8,
    invert: !0,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  zoe: {
    format: "zoe",
    bitDepth: 16,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: !1,
    normalize: !1,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  normalized: {
    format: "normalized",
    bitDepth: 8,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
}, p7 = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
], m7 = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
], hg = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  motionctrl: {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  cogvideox: {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  ati: {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  ttm: {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};
function v7(s) {
  const { width: e, height: n, nearClip: i, farClip: r, camera: o, layers: a, frame: l } = s, c = new Float32Array(e * n);
  c.fill(r);
  let u = r, d = i;
  const h = [...a].filter((m) => m.visible).sort((m, p) => {
    const v = Zd(m, l), _ = Zd(p, l);
    return v - _;
  });
  for (const m of h) {
    const p = Zd(m, l), v = g7(m, l);
    if (v < 0.01) continue;
    const _ = y7(m, l, o, e, n);
    if (!_) continue;
    const g = o.position.z, x = Math.abs(p - g), M = Math.max(i, Math.min(r, x));
    u = Math.min(u, M), d = Math.max(d, M), m.type === "depthflow" && x7(m) ? _7(c, m, _, e, n, i, r) : b7(c, _, M, v, e, n);
  }
  return {
    depthBuffer: c,
    width: e,
    height: n,
    minDepth: u,
    maxDepth: d
  };
}
function Zd(s, e) {
  var i;
  const n = (i = s.transform) == null ? void 0 : i.position;
  if (!n) return 0;
  if (n.keyframes && n.keyframes.length > 0)
    return qy(n.keyframes, e, 2) || 0;
  if (n.value) {
    const r = n.value;
    if (typeof r == "object" && "z" in r)
      return r.z ?? 0;
  }
  return 0;
}
function g7(s, e) {
  var n;
  return s.opacity && "keyframes" in s.opacity && ((n = s.opacity.keyframes) == null ? void 0 : n.length) > 0 ? (qy(s.opacity.keyframes, e) || 100) / 100 : s.opacity && "value" in s.opacity ? (s.opacity.value || 100) / 100 : 1;
}
function y7(s, e, n, i, r) {
  var E, y, w;
  let o = 0, a = 0;
  const l = (E = s.transform) == null ? void 0 : E.position;
  if (l && "value" in l) {
    const D = l.value;
    Array.isArray(D) && (o = D[0] || 0, a = D[1] || 0);
  }
  const c = s.width || i, u = s.height || r;
  let d = 1, h = 1;
  const m = (y = s.transform) == null ? void 0 : y.scale;
  if (m && "value" in m) {
    const D = m.value;
    Array.isArray(D) && (d = (D[0] || 100) / 100, h = (D[1] || 100) / 100);
  }
  const p = c * d, v = u * h;
  let _ = 0.5, g = 0.5;
  const x = (w = s.transform) == null ? void 0 : w.anchorPoint;
  if (x && "value" in x) {
    const D = x.value;
    Array.isArray(D) && (_ = (D[0] || 0) / c + 0.5, g = (D[1] || 0) / u + 0.5);
  }
  const M = o - p * _ + i / 2, S = a - v * g + r / 2, b = Math.max(0, Math.min(i, M)), C = Math.max(0, Math.min(r, S)), T = Math.max(0, Math.min(i - b, p - (b - M))), P = Math.max(0, Math.min(r - C, v - (C - S)));
  return T <= 0 || P <= 0 ? null : {
    x: b,
    y: C,
    width: T,
    height: P
  };
}
function x7(s) {
  return s.type === "depthflow" && !!s.depthMapData;
}
function _7(s, e, n, i, r, o, a) {
  const l = e.depthMapData, c = e.depthWidth || n.width, u = e.depthHeight || n.height;
  for (let d = 0; d < n.height; d++)
    for (let h = 0; h < n.width; h++) {
      const m = Math.floor(n.x + h), p = Math.floor(n.y + d);
      if (m < 0 || m >= i || p < 0 || p >= r) continue;
      const v = Math.floor(h / n.width * c), g = Math.floor(d / n.height * u) * c + v;
      let x;
      l instanceof Float32Array ? x = l[g] : x = l[g] / 255;
      const M = o + x * (a - o), S = p * i + m;
      M < s[S] && (s[S] = M);
    }
}
function b7(s, e, n, i, r, o) {
  const a = Math.floor(e.x), l = Math.floor(e.y), c = Math.min(r, Math.ceil(e.x + e.width)), u = Math.min(o, Math.ceil(e.y + e.height));
  for (let d = l; d < u; d++)
    for (let h = a; h < c; h++) {
      const m = d * r + h;
      i > 0.5 && n < s[m] && (s[m] = n);
    }
}
function qy(s, e, n) {
  if (!s || s.length === 0) return null;
  let i = s[0], r = s[s.length - 1];
  for (let c = 0; c < s.length; c++)
    if (s[c].frame <= e && (i = s[c]), s[c].frame >= e && c < s.length) {
      r = s[c];
      break;
    }
  if (i.frame === r.frame) {
    const c = i.value;
    return n !== void 0 && Array.isArray(c) ? c[n] : c;
  }
  const o = (e - i.frame) / (r.frame - i.frame), a = n !== void 0 && Array.isArray(i.value) ? i.value[n] : i.value, l = n !== void 0 && Array.isArray(r.value) ? r.value[n] : r.value;
  return a + (l - a) * o;
}
function w7(s, e) {
  const n = f7[e], { depthBuffer: i, width: r, height: o, minDepth: a, maxDepth: l } = s, c = r * o;
  if (n.bitDepth === 16) {
    const u = new Uint16Array(c);
    for (let d = 0; d < c; d++) {
      let h;
      n.normalize ? h = (i[d] - a) / (l - a) : h = i[d] / n.farClip, n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(65535, Math.round(h * 65535)));
    }
    return u;
  } else {
    const u = new Uint8Array(c);
    for (let d = 0; d < c; d++) {
      let h = (i[d] - a) / (l - a);
      n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(255, Math.round(h * 255)));
    }
    return u;
  }
}
function S7(s, e, n) {
  const i = new ImageData(e, n), r = s instanceof Uint16Array;
  for (let o = 0; o < e * n; o++) {
    const a = r ? Math.floor(s[o] / 256) : s[o], l = o * 4;
    i.data[l] = a, i.data[l + 1] = a, i.data[l + 2] = a, i.data[l + 3] = 255;
  }
  return i;
}
const Cc = Ko("ComfyUI");
class M7 {
  constructor(e) {
    fe(this, "serverAddress");
    fe(this, "clientId");
    fe(this, "ws", null);
    fe(this, "messageHandlers", /* @__PURE__ */ new Map());
    this.serverAddress = e.serverAddress.replace(/\/$/, ""), this.clientId = e.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      return (await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      })).ok;
    } catch {
      return !1;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const e = await fetch(`http://${this.serverAddress}/system_stats`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const e = await fetch(`http://${this.serverAddress}/prompt`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(e, n, i = "input", r, o = !0) {
    const a = new FormData();
    a.append("image", e, n), a.append("type", i), a.append("overwrite", o.toString()), r && a.append("subfolder", r);
    const l = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: a
    });
    if (!l.ok) {
      const c = await l.text();
      throw new Error(`Failed to upload image: ${c}`);
    }
    return l.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(e, n, i) {
    const r = new FormData();
    r.append("image", e, n), r.append("original_ref", JSON.stringify(i)), r.append("type", "input");
    const o = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: r
    });
    if (!o.ok)
      throw new Error(`Failed to upload mask: ${await o.text()}`);
    return o.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(e, n) {
    const i = {
      prompt: e,
      client_id: this.clientId,
      extra_data: n
    }, r = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(i)
    });
    if (!r.ok) {
      const o = await r.text();
      throw new Error(`Failed to queue prompt: ${o}`);
    }
    return r.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(e) {
    const n = e ? `http://${this.serverAddress}/history/${e}` : `http://${this.serverAddress}/history`, i = await fetch(n);
    if (!i.ok)
      throw new Error(`Failed to get history: ${await i.text()}`);
    return i.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(e, n = "", i = "output") {
    const r = new URLSearchParams({
      filename: e,
      subfolder: n,
      type: i
    }), o = await fetch(`http://${this.serverAddress}/view?${r}`);
    if (!o.ok)
      throw new Error(`Failed to get output: ${await o.text()}`);
    return o.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(e, n = "", i = "output") {
    const r = await this.getOutput(e, n, i);
    return new Promise((o, a) => {
      const l = new FileReader();
      l.onloadend = () => o(l.result), l.onerror = a, l.readAsDataURL(r);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const e = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!e.ok)
      throw new Error(`Failed to interrupt: ${await e.text()}`);
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const e = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: !0 })
    });
    if (!e.ok)
      throw new Error(`Failed to clear queue: ${await e.text()}`);
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(e, n) {
    const i = await fetch(`http://${this.serverAddress}/${e}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: n })
    });
    if (!i.ok)
      throw new Error(`Failed to delete from ${e}: ${await i.text()}`);
  }
  /**
   * Get available models
   */
  async getModels(e) {
    const n = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    }, i = await fetch(
      `http://${this.serverAddress}/models/${n[e]}`
    );
    return i.ok ? i.json() : [];
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((e, n) => {
      const i = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(i), this.ws.onopen = () => {
        Cc.debug("WebSocket connected"), e();
      }, this.ws.onerror = (r) => {
        Cc.error("WebSocket error:", r), n(new Error("WebSocket connection failed"));
      }, this.ws.onclose = () => {
        Cc.debug("WebSocket disconnected"), this.ws = null;
      }, this.ws.onmessage = (r) => {
        try {
          const o = JSON.parse(r.data);
          this.handleWebSocketMessage(o);
        } catch (o) {
          Cc.error("Failed to parse WebSocket message:", o);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    this.ws && (this.ws.close(), this.ws = null), this.messageHandlers.clear();
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(e, n) {
    this.messageHandlers.set(e, n);
  }
  /**
   * Remove a message handler
   */
  offMessage(e) {
    this.messageHandlers.delete(e);
  }
  handleWebSocketMessage(e) {
    const { type: n } = e, i = this.messageHandlers.get(n);
    i && i(e);
    const r = this.messageHandlers.get("all");
    r && r(e);
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(e, n, i) {
    const r = new OffscreenCanvas(e.width, e.height);
    r.getContext("2d").putImageData(e, 0, 0);
    const a = await r.convertToBlob({ type: "image/png" });
    return this.uploadImage(a, n, "input", i);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(e, n, i) {
    let r;
    return e instanceof OffscreenCanvas ? r = await e.convertToBlob({ type: "image/png" }) : r = await new Promise((o, a) => {
      e.toBlob((l) => {
        l ? o(l) : a(new Error("Failed to convert canvas to blob"));
      }, "image/png");
    }), this.uploadImage(r, n, "input", i);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(e, n, i = 3e5) {
    const r = Date.now();
    return this.isWebSocketConnected() || await this.connectWebSocket(), new Promise((o, a) => {
      let l = !1;
      const c = () => {
        this.offMessage("progress"), this.offMessage("executing"), this.offMessage("executed"), this.offMessage("execution_error");
      }, u = () => {
        Date.now() - r > i && (c(), a(new Error("Prompt execution timed out")));
      };
      this.onMessage("progress", (d) => {
        u(), n == null || n({
          status: "executing",
          currentStep: d.data.value,
          totalSteps: d.data.max,
          percentage: d.data.value / d.data.max * 100
        });
      }), this.onMessage("executing", (d) => {
        u(), d.data.prompt_id === e && (n == null || n({
          status: "executing",
          currentNode: d.data.node,
          percentage: 10
          // Approximate
        }));
      }), this.onMessage("executed", async (d) => {
        if (d.data.prompt_id === e && !l) {
          l = !0, c(), n == null || n({
            status: "completed",
            percentage: 100
          });
          const h = await this.getHistory(e);
          o(h[e]);
        }
      }), this.onMessage("execution_error", (d) => {
        d.data.prompt_id === e && (c(), n == null || n({
          status: "error",
          percentage: 0
        }), a(new Error(d.data.exception_message || "Execution failed")));
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(e, n) {
    const { prompt_id: i } = await this.queuePrompt(e);
    n == null || n({
      status: "queued",
      percentage: 0
    });
    const r = await this.waitForPrompt(i, n), o = [];
    for (const a of Object.values(r.outputs))
      a.images && o.push(...a.images), a.gifs && o.push(...a.gifs);
    return {
      promptId: i,
      history: r,
      outputs: o
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let Tc = null;
function Mo(s) {
  return (!Tc || s && s !== Tc.server) && (Tc = new M7({
    serverAddress: s || "127.0.0.1:8188"
  })), Tc;
}
let Zy = 1;
function Us() {
  Zy = 1;
}
function vt() {
  return String(Zy++);
}
function ft(s, e, n) {
  const i = {
    class_type: s,
    inputs: e
  };
  return n && (i._meta = { title: n }), i;
}
function We(s, e = 0) {
  return [s, e];
}
function np(s, e) {
  const n = vt();
  return s[n] = ft("CheckpointLoaderSimple", {
    ckpt_name: e
  }, "Load Checkpoint"), n;
}
function qo(s, e, n, i) {
  const r = vt();
  return s[r] = ft("CLIPTextEncode", {
    clip: e,
    text: n
  }, i), r;
}
function lr(s, e, n) {
  const i = vt();
  return s[i] = ft("LoadImage", {
    image: e
  }, n || "Load Image"), i;
}
function cr(s, e, n, i) {
  const r = vt();
  return s[r] = ft("ImageResize", {
    image: e,
    width: n,
    height: i,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image"), r;
}
function C7(s, e, n) {
  const i = vt();
  return s[i] = ft("VAEEncode", {
    pixels: e,
    vae: n
  }, "VAE Encode"), i;
}
function El(s, e, n) {
  const i = vt();
  return s[i] = ft("VAEDecode", {
    samples: e,
    vae: n
  }, "VAE Decode"), i;
}
function Al(s, e, n, i, r, o) {
  const a = vt();
  return s[a] = ft("KSampler", {
    model: e,
    positive: n,
    negative: i,
    latent_image: r,
    seed: o.seed ?? Math.floor(Math.random() * 2147483647),
    steps: o.steps ?? 20,
    cfg: o.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: o.denoise ?? 1
  }, "KSampler"), a;
}
function Os(s, e, n) {
  const i = vt();
  return s[i] = ft("VHS_VideoCombine", {
    images: e,
    frame_rate: n.fps,
    loop_count: 0,
    filename_prefix: n.filename || "weyl_output",
    format: n.format || "video/h264-mp4",
    pingpong: !1,
    save_output: !0,
    audio: null,
    meta_batch: null
  }, "Video Output"), i;
}
function fg(s) {
  Us();
  const e = {}, n = s.width > 640 || s.height > 640, i = s.wanModel || (n ? "i2v_720p" : "i2v_480p"), r = vt();
  e[r] = ft("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${i}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const o = vt();
  e[o] = ft("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const a = vt();
  e[a] = ft("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const l = lr(e, s.referenceImage || "input.png", "Reference Image"), c = cr(e, We(l), s.width, s.height), u = vt();
  e[u] = ft("WanTextEncode", {
    text_encoder: We(a),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = vt();
  e[d] = ft("WanImageToVideo", {
    wan_model: We(r),
    positive: We(u),
    image: We(c),
    vae: We(o),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: s.denoise || 1
  }, "I2V Generation");
  const h = vt();
  return e[h] = ft("WanVAEDecode", {
    vae: We(o),
    samples: We(d),
    enable_vae_tiling: !0,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode"), Os(e, We(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_i2v"
  }), e;
}
function T7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const i = vt();
  e[i] = ft("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const r = vt();
  e[r] = ft("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = lr(e, s.referenceImage || "input.png", "Reference Image"), a = cr(e, We(o), s.width, s.height), l = vt();
  e[l] = ft("WanTextEncode", {
    text_encoder: We(r),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const c = vt();
  e[c] = ft("WanFunCameraMotion", {
    motion_type: s.cameraMotion || "Static",
    length: s.frameCount
  }, "Camera Motion");
  const u = vt();
  e[u] = ft("WanFunCameraI2V", {
    wan_model: We(n),
    positive: We(l),
    image: We(a),
    camera_motion: We(c),
    vae: We(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const d = vt();
  return e[d] = ft("WanVAEDecode", {
    vae: We(i),
    samples: We(u),
    enable_vae_tiling: !0
  }, "VAE Decode"), Os(e, We(d), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_fun_camera"
  }), e;
}
function E7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const i = vt();
  e[i] = ft("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const r = vt();
  e[r] = ft("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = lr(e, s.referenceImage || "first.png", "First Frame"), a = lr(e, s.lastFrameImage || "last.png", "Last Frame"), l = cr(e, We(o), s.width, s.height), c = cr(e, We(a), s.width, s.height), u = vt();
  e[u] = ft("WanTextEncode", {
    text_encoder: We(r),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = vt();
  e[d] = ft("WanFirstLastFrameToVideo", {
    wan_model: We(n),
    positive: We(u),
    first_frame: We(l),
    last_frame: We(c),
    vae: We(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const h = vt();
  return e[h] = ft("WanVAEDecode", {
    vae: We(i),
    samples: We(d),
    enable_vae_tiling: !0
  }, "VAE Decode"), Os(e, We(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_flf"
  }), e;
}
function A7(s) {
  var h;
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const i = vt();
  e[i] = ft("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const r = lr(e, s.referenceImage || "input.png", "Reference Image"), o = cr(e, We(r), s.width, s.height), a = vt();
  s.trajType === "custom" && ((h = s.cameraData) != null && h.trajectory) ? e[a] = ft("Uni3CCustomTrajectory", {
    trajectory_data: JSON.stringify(s.cameraData.trajectory),
    length: s.frameCount
  }, "Custom Trajectory") : e[a] = ft("Uni3CPresetTrajectory", {
    traj_type: s.trajType || "orbit",
    length: s.frameCount
  }, "Preset Trajectory");
  const l = vt();
  e[l] = ft("ApplyUni3CCameraControl", {
    model: We(i),
    uni3c: We(n),
    trajectory: We(a),
    image: We(o),
    control_strength: 1
  }, "Apply Camera Control");
  const c = vt();
  e[c] = ft("SVDEncode", {
    model: We(l),
    image: We(o),
    vae: We(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = Al(
    e,
    We(l),
    We(c, 1),
    We(c, 2),
    We(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5, denoise: 1 }
  ), d = El(e, We(u), We(i, 2));
  return Os(e, We(d), {
    fps: s.fps,
    filename: s.outputFilename || "uni3c_output"
  }), e;
}
function P7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const i = vt();
  e[i] = ft("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const r = lr(e, s.referenceImage || "input.png", "Reference Image"), o = cr(e, We(r), s.width, s.height), a = vt();
  s.cameraPoses ? e[a] = ft("MotionCtrlCameraPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[a] = ft("MotionCtrlPresetPoses", {
    preset: s.motionPreset || "static",
    length: s.frameCount
  }, "Preset Poses");
  const l = vt();
  e[l] = ft("ApplyMotionCtrl", {
    model: We(i),
    motion_ctrl: We(n),
    camera_poses: We(a),
    control_strength: 1
  }, "Apply MotionCtrl");
  const c = vt();
  e[c] = ft("SVDEncode", {
    model: We(l),
    image: We(o),
    vae: We(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = Al(
    e,
    We(l),
    We(c, 1),
    We(c, 2),
    We(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5 }
  ), d = El(e, We(u), We(i, 2));
  return Os(e, We(d), {
    fps: s.fps,
    filename: s.outputFilename || "motionctrl_output"
  }), e;
}
function R7(s) {
  Us();
  const e = {}, n = np(e, s.checkpoint || "sd_xl_base_1.0.safetensors"), i = vt();
  e[i] = ft("ControlNetLoader", {
    control_net_name: s.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const r = vt();
  e[r] = ft("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const o = lr(e, s.referenceImage || "reference.png", "Reference Image"), a = cr(e, We(o), s.width, s.height), l = qo(e, We(n, 1), s.prompt, "Positive"), c = qo(e, We(n, 1), s.negativePrompt, "Negative"), u = vt();
  e[u] = ft("ControlNetApply", {
    conditioning: We(l),
    control_net: We(i),
    image: We(r),
    strength: 1
  }, "Apply ControlNet");
  const d = C7(e, We(a), We(n, 2)), h = Al(
    e,
    We(n),
    We(u),
    We(c),
    We(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7, denoise: s.denoise || 0.75 }
  ), m = El(e, We(h), We(n, 2));
  return Os(e, We(m), {
    fps: s.fps,
    filename: s.outputFilename || "controlnet_depth"
  }), e;
}
function D7(s) {
  Us();
  const e = {}, n = np(e, s.checkpoint || "dreamshaper_8.safetensors"), i = vt();
  e[i] = ft("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const r = vt();
  e[r] = ft("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const o = vt();
  s.cameraPoses ? e[o] = ft("ADE_CameraCtrlPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[o] = ft("ADE_CameraCtrlPreset", {
    motion_type: s.cameraMotion || "Static",
    speed: 1,
    frame_length: s.frameCount
  }, "Camera Preset");
  const a = vt();
  e[a] = ft("ADE_ApplyAnimateDiffModel", {
    model: We(n),
    motion_model: We(i)
  }, "Apply AnimateDiff");
  const l = vt();
  e[l] = ft("ADE_ApplyCameraCtrl", {
    model: We(a),
    cameractrl: We(r),
    poses: We(o)
  }, "Apply CameraCtrl");
  const c = qo(e, We(n, 1), s.prompt, "Positive"), u = qo(e, We(n, 1), s.negativePrompt, "Negative"), d = vt();
  e[d] = ft("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = Al(
    e,
    We(l),
    We(c),
    We(u),
    We(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), m = El(e, We(h), We(n, 2));
  return Os(e, We(m), {
    fps: s.fps,
    filename: s.outputFilename || "animatediff_cameractrl"
  }), e;
}
function k7(s) {
  Us();
  const e = {}, n = vt();
  e[n] = ft("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const i = vt();
  e[i] = ft("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const r = vt();
  e[r] = ft("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const o = lr(e, s.referenceImage || "input.png", "Reference Image"), a = cr(e, We(o), s.width, s.height), l = vt();
  e[l] = ft("CogVideoTextEncode", {
    text_encoder: We(i),
    prompt: s.prompt,
    force_offload: !0
  }, "Encode Prompt");
  const c = vt();
  e[c] = ft("CogVideoImageToVideo", {
    model: We(n),
    positive: We(l),
    image: We(a),
    vae: We(r),
    width: s.width,
    height: s.height,
    num_frames: s.frameCount,
    steps: s.steps || 50,
    cfg: s.cfgScale || 6,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const u = vt();
  return e[u] = ft("CogVideoDecode", {
    vae: We(r),
    samples: We(c),
    enable_vae_tiling: !0
  }, "Decode Video"), Os(e, We(u), {
    fps: s.fps,
    filename: s.outputFilename || "cogvideox_output"
  }), e;
}
function pg(s, e) {
  Us();
  const n = {}, i = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  }, r = np(n, s.checkpoint || "v1-5-pruned-emaonly.safetensors"), o = vt();
  n[o] = ft("ControlNetLoader", {
    control_net_name: s.controlnetModel || i[e]
  }, `Load ControlNet ${e}`);
  const a = vt();
  n[a] = ft("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const l = qo(n, We(r, 1), s.prompt, "Positive"), c = qo(n, We(r, 1), s.negativePrompt, "Negative"), u = vt();
  n[u] = ft("ControlNetApply", {
    conditioning: We(l),
    control_net: We(o),
    image: We(a),
    strength: 1
  }, "Apply ControlNet");
  const d = vt();
  n[d] = ft("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = Al(
    n,
    We(r),
    We(u),
    We(c),
    We(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), m = El(n, We(h), We(r, 2));
  return Os(n, We(m), {
    fps: s.fps,
    filename: s.outputFilename || `controlnet_${e}`
  }), n;
}
function I7(s, e) {
  switch (s) {
    case "wan22-i2v":
      return fg(e);
    case "wan22-t2v":
      return fg({ ...e, referenceImage: void 0 });
    case "wan22-fun-camera":
      return T7(e);
    case "wan22-first-last":
      return E7(e);
    case "uni3c-camera":
    case "uni3c-motion":
      return A7(e);
    case "motionctrl":
    case "motionctrl-svd":
      return P7(e);
    case "cogvideox":
      return k7(e);
    case "controlnet-depth":
      return R7(e);
    case "controlnet-canny":
      return pg(e, "canny");
    case "controlnet-lineart":
      return pg(e, "lineart");
    case "animatediff-cameractrl":
      return D7(e);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${s}`);
  }
}
function L7(s) {
  const e = [], n = [], i = Object.keys(s);
  for (const [o, a] of Object.entries(s)) {
    a.class_type || e.push(`Node ${o}: missing class_type`);
    for (const [l, c] of Object.entries(a.inputs))
      if (Array.isArray(c) && c.length === 2) {
        const [u] = c;
        typeof u == "string" && !i.includes(u) && e.push(`Node ${o}.${l}: references non-existent node ${u}`);
      }
  }
  return Object.values(s).some(
    (o) => o.class_type.includes("Save") || o.class_type.includes("Output") || o.class_type.includes("Preview")
  ) || n.push("Workflow has no output/save nodes"), {
    valid: e.length === 0,
    errors: e,
    warnings: n
  };
}
class F7 {
  constructor(e) {
    fe(this, "layers");
    fe(this, "cameraKeyframes");
    fe(this, "config");
    fe(this, "onProgress");
    fe(this, "abortSignal");
    fe(this, "aborted", !1);
    this.layers = e.layers, this.cameraKeyframes = e.cameraKeyframes, this.config = e.config, this.onProgress = e.onProgress || (() => {
    }), this.abortSignal = e.abortSignal, this.abortSignal && this.abortSignal.addEventListener("abort", () => {
      this.aborted = !0;
    });
  }
  checkAborted() {
    if (this.aborted)
      throw new Error("Export aborted");
  }
  updateProgress(e) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...e
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const e = Date.now(), n = {
      success: !1,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const i = this.validateConfig();
      if (i.length > 0)
        return n.errors = i, n;
      this.config.exportReferenceFrame && (this.checkAborted(), await this.renderReferenceFrame(n)), this.config.exportLastFrame && (this.checkAborted(), await this.renderLastFrame(n)), this.config.exportDepthMap && (this.checkAborted(), await this.renderDepthSequence(n)), this.config.exportControlImages && (this.checkAborted(), await this.renderControlSequence(n)), this.config.exportCameraData && (this.checkAborted(), await this.exportCameraData(n)), this.checkAborted(), await this.generateWorkflow(n), this.config.autoQueueWorkflow && this.config.comfyuiServer && (this.checkAborted(), await this.queueWorkflow(n)), n.success = n.errors.length === 0;
    } catch (i) {
      i instanceof Error && i.message === "Export aborted" ? n.errors.push("Export was cancelled") : n.errors.push(i instanceof Error ? i.message : "Unknown error");
    }
    return n.duration = Date.now() - e, n;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const e = [];
    return (this.config.width < 64 || this.config.width > 4096) && e.push("Width must be between 64 and 4096"), (this.config.height < 64 || this.config.height > 4096) && e.push("Height must be between 64 and 4096"), (this.config.frameCount < 1 || this.config.frameCount > 1e3) && e.push("Frame count must be between 1 and 1000"), (this.config.fps < 1 || this.config.fps > 120) && e.push("FPS must be between 1 and 120"), (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) && e.push("Invalid start frame"), (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) && e.push("Invalid end frame"), !this.config.prompt && this.needsPrompt() && e.push("Prompt is required for this export target"), e;
  }
  needsPrompt() {
    return !["controlnet-depth", "controlnet-canny", "controlnet-lineart"].includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.startFrame);
    const r = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const l = await Mo(this.config.comfyuiServer).uploadImage(r, o);
      e.outputFiles.referenceImage = l.name;
    } else
      e.outputFiles.referenceImage = await this.saveBlobLocally(r, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.endFrame - 1);
    const r = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const l = await Mo(this.config.comfyuiServer).uploadImage(r, o);
      e.outputFiles.lastImage = l.name;
    } else
      e.outputFiles.lastImage = await this.saveBlobLocally(r, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(e, n) {
    e.clearRect(0, 0, e.canvas.width, e.canvas.height);
    const i = [...this.layers].filter((r) => r.visible).sort((r, o) => {
      var c, u, d, h, m, p;
      const a = ((d = (u = (c = r.transform) == null ? void 0 : c.position) == null ? void 0 : u.value) == null ? void 0 : d.z) ?? 0, l = ((p = (m = (h = o.transform) == null ? void 0 : h.position) == null ? void 0 : m.value) == null ? void 0 : p.z) ?? 0;
      return a - l;
    });
    for (const r of i)
      await this.renderLayerToCanvas(e, r, n);
  }
  async renderLayerToCanvas(e, n, i) {
    var u, d, h, m, p, v, _;
    const r = ((d = (u = n.transform) == null ? void 0 : u.position) == null ? void 0 : d.value) ?? { x: 0, y: 0 }, o = ((m = (h = n.transform) == null ? void 0 : h.scale) == null ? void 0 : m.value) ?? { x: 100, y: 100 }, a = ((v = (p = n.transform) == null ? void 0 : p.rotation) == null ? void 0 : v.value) ?? 0, l = typeof ((_ = n.opacity) == null ? void 0 : _.value) == "number" ? n.opacity.value : 100;
    e.save(), e.globalAlpha = l / 100, e.translate(r.x, r.y), e.rotate(a * Math.PI / 180), e.scale(o.x / 100, o.y / 100);
    const c = n.data;
    if (n.type === "image" && (c != null && c.src)) {
      const g = await this.loadImage(c.src);
      e.drawImage(g, -g.width / 2, -g.height / 2);
    } else if (n.type === "solid" && (c != null && c.color)) {
      e.fillStyle = c.color || "#000000";
      const g = c.width ?? 100, x = c.height ?? 100;
      e.fillRect(-g / 2, -x / 2, g, x);
    }
    e.restore();
  }
  loadImage(e) {
    return new Promise((n, i) => {
      const r = new Image();
      r.onload = () => n(r), r.onerror = i, r.src = e;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let r = 0; r < n; r++) {
      this.checkAborted();
      const o = this.config.startFrame + r, a = r / n * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: a,
        overallProgress: 15 + a * 0.25,
        currentFrame: r + 1,
        totalFrames: n,
        message: `Rendering depth frame ${r + 1}/${n}`
      });
      const l = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: !1,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      }, c = v7({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: l,
        layers: this.layers,
        frame: o
      }), u = w7(
        c,
        this.config.depthFormat
      ), d = S7(
        u,
        this.config.width,
        this.config.height
      ), h = new OffscreenCanvas(this.config.width, this.config.height);
      h.getContext("2d").putImageData(d, 0, 0);
      const p = await h.convertToBlob({ type: "image/png" }), v = `${this.config.filenamePrefix}_depth_${String(r).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const g = await Mo(this.config.comfyuiServer).uploadImage(p, v, "input", "depth_sequence");
        i.push(g.name);
      } else
        i.push(await this.saveBlobLocally(p, v));
    }
    e.outputFiles.depthSequence = i, this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let r = 0; r < n; r++) {
      this.checkAborted();
      const o = this.config.startFrame + r, a = r / n * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: a,
        overallProgress: 40 + a * 0.2,
        currentFrame: r + 1,
        totalFrames: n,
        message: `Rendering control frame ${r + 1}/${n}`
      });
      const l = new OffscreenCanvas(this.config.width, this.config.height), c = l.getContext("2d");
      await this.renderFrameToCanvas(c, o);
      const d = await (await this.applyControlPreprocessing(l, this.config.controlType || "depth")).convertToBlob({ type: "image/png" }), h = `${this.config.filenamePrefix}_control_${String(r).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const p = await Mo(this.config.comfyuiServer).uploadImage(d, h, "input", "control_sequence");
        i.push(p.name);
      } else
        i.push(await this.saveBlobLocally(d, h));
    }
    e.outputFiles.controlSequence = i, this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(e, n) {
    const i = new OffscreenCanvas(e.width, e.height), r = i.getContext("2d"), a = e.getContext("2d").getImageData(0, 0, e.width, e.height), l = a.data;
    switch (n) {
      case "canny":
        this.applyEdgeDetection(l, e.width, e.height);
        break;
      case "lineart":
        this.applyLineart(l);
        break;
      case "softedge":
        this.applySoftEdge(l, e.width, e.height);
        break;
    }
    return r.putImageData(a, 0, 0), i;
  }
  applyEdgeDetection(e, n, i) {
    const r = new Float32Array(n * i);
    for (let a = 0; a < n * i; a++) {
      const l = a * 4;
      r[a] = (e[l] * 0.299 + e[l + 1] * 0.587 + e[l + 2] * 0.114) / 255;
    }
    const o = new Float32Array(n * i);
    for (let a = 1; a < i - 1; a++)
      for (let l = 1; l < n - 1; l++) {
        const c = a * n + l, u = -r[c - n - 1] + r[c - n + 1] + -2 * r[c - 1] + 2 * r[c + 1] + -r[c + n - 1] + r[c + n + 1], d = -r[c - n - 1] - 2 * r[c - n] - r[c - n + 1] + r[c + n - 1] + 2 * r[c + n] + r[c + n + 1];
        o[c] = Math.min(1, Math.sqrt(u * u + d * d) * 2);
      }
    for (let a = 0; a < n * i; a++) {
      const l = a * 4, c = Math.floor(o[a] * 255);
      e[l] = c, e[l + 1] = c, e[l + 2] = c;
    }
  }
  applyLineart(e) {
    for (let n = 0; n < e.length; n += 4) {
      const r = e[n] * 0.299 + e[n + 1] * 0.587 + e[n + 2] * 0.114 > 128 ? 255 : 0;
      e[n] = r, e[n + 1] = r, e[n + 2] = r;
    }
  }
  applySoftEdge(e, n, i) {
    this.applyEdgeDetection(e, n, i);
    const r = new Uint8ClampedArray(e), o = 2;
    for (let a = o; a < i - o; a++)
      for (let l = o; l < n - o; l++) {
        let c = 0, u = 0;
        for (let m = -o; m <= o; m++)
          for (let p = -o; p <= o; p++) {
            const v = ((a + m) * n + (l + p)) * 4;
            c += r[v], u++;
          }
        const d = (a * n + l) * 4, h = Math.floor(c / u);
        e[d] = h, e[d + 1] = h, e[d + 2] = h;
      }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(e) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const n = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: !1,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: !1
      }
    }, i = aE(
      this.config.target,
      n,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    ), r = `${this.config.filenamePrefix}_camera.json`, o = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    this.config.comfyuiServer ? e.outputFiles.cameraData = r : e.outputFiles.cameraData = await this.saveBlobLocally(o, r), this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(e) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const n = {
      referenceImage: e.outputFiles.referenceImage,
      lastFrameImage: e.outputFiles.lastImage,
      depthSequence: e.outputFiles.depthSequence,
      controlImages: e.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    e.outputFiles.cameraData && (n.cameraData = e.outputFiles.cameraData);
    const i = I7(this.config.target, n), r = L7(i);
    r.valid || e.errors.push(...r.errors), e.warnings.push(...r.warnings);
    const o = `${this.config.filenamePrefix}_workflow.json`, a = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    e.outputFiles.workflowJson = await this.saveBlobLocally(a, o), this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(e) {
    if (!this.config.comfyuiServer || !e.outputFiles.workflowJson)
      return;
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const n = Mo(this.config.comfyuiServer);
    if (!await n.checkConnection()) {
      e.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const o = await (await fetch(e.outputFiles.workflowJson)).json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const a = await n.queuePrompt(o);
    if (e.outputFiles.promptId = a.prompt_id, a.node_errors && Object.keys(a.node_errors).length > 0) {
      e.errors.push("Workflow has node errors: " + JSON.stringify(a.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await n.waitForPrompt(a.prompt_id, (l) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: l.percentage,
          overallProgress: 80 + l.percentage * 0.15,
          message: `Generating: ${l.percentage.toFixed(0)}%`,
          preview: l.preview
        });
      }), this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (l) {
      e.errors.push(l instanceof Error ? l.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(e, n) {
    const i = URL.createObjectURL(e), r = document.createElement("a");
    return r.href = i, r.download = n, document.body.appendChild(r), r.click(), document.body.removeChild(r), i;
  }
}
async function U7(s, e, n, i) {
  return new F7({
    layers: s,
    cameraKeyframes: e,
    config: n,
    onProgress: i
  }).execute();
}
const O7 = { class: "export-dialog" }, z7 = { class: "dialog-tabs" }, N7 = { class: "dialog-content" }, B7 = {
  key: 0,
  class: "tab-content"
}, V7 = { class: "target-grid" }, G7 = { class: "target-buttons" }, H7 = ["onClick"], $7 = {
  key: 0,
  class: "target-info"
}, W7 = { class: "info-row" }, X7 = { class: "info-row" }, j7 = { class: "info-row" }, Y7 = {
  key: 1,
  class: "tab-content"
}, q7 = { class: "settings-section" }, Z7 = { class: "preset-buttons" }, K7 = ["onClick"], J7 = { class: "input-row" }, Q7 = { class: "settings-section" }, e9 = { class: "preset-buttons" }, t9 = ["onClick"], n9 = { class: "input-row" }, i9 = { class: "input-row" }, s9 = { class: "settings-section" }, r9 = { class: "checkbox-grid" }, o9 = {
  key: 0,
  class: "settings-section"
}, a9 = ["value"], l9 = {
  key: 1,
  class: "settings-section"
}, c9 = ["value"], u9 = {
  key: 2,
  class: "tab-content"
}, d9 = { class: "settings-section" }, h9 = { class: "settings-section" }, f9 = { class: "settings-section" }, p9 = { class: "input-row" }, m9 = { class: "input-row seed-row" }, v9 = {
  key: 3,
  class: "tab-content"
}, g9 = { class: "settings-section" }, y9 = { class: "server-row" }, x9 = { key: 0 }, _9 = { key: 1 }, b9 = { key: 2 }, w9 = { key: 3 }, S9 = { class: "settings-section" }, M9 = { class: "checkbox-large" }, C9 = {
  key: 0,
  class: "export-progress"
}, T9 = { class: "progress-header" }, E9 = { class: "progress-bar" }, A9 = {
  key: 0,
  class: "progress-details"
}, P9 = {
  key: 1,
  class: "export-error"
}, R9 = { class: "dialog-footer" }, D9 = ["disabled"], k9 = /* @__PURE__ */ Ot({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = we("target"), o = we("wan22-i2v"), a = we(832), l = we(480), c = we(81), u = we(24), d = we(0), h = we(81), m = we(!0), p = we(!1), v = we(!0), _ = we(!0), g = we(!1), x = we("midas"), M = we("depth"), S = we(""), b = we("blurry, low quality, distorted"), C = we(void 0), T = we(30), P = we(5), E = we("127.0.0.1:8188"), y = we(!1), w = we("disconnected"), D = we(!1), U = we(null), R = we(null), O = we(null), A = Ie(() => hg[o.value]), G = Ie(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      Uni3C: ["uni3c-camera", "uni3c-motion"],
      MotionCtrl: ["motionctrl", "motionctrl-svd"],
      Camera: ["animatediff-cameractrl", "camera-comfyui", "ati"],
      Advanced: ["light-x", "ttm", "cogvideox"],
      ControlNet: ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      Custom: ["custom-workflow"]
    })), ue = Ie(() => ({
      "wan22-i2v": "Image to Video",
      "wan22-t2v": "Text to Video",
      "wan22-fun-camera": "Fun Camera",
      "wan22-first-last": "First + Last Frame",
      "wan-move": "Point Trajectories",
      "uni3c-camera": "Camera Control",
      "uni3c-motion": "Motion + Camera",
      motionctrl: "MotionCtrl",
      "motionctrl-svd": "MotionCtrl SVD",
      cogvideox: "CogVideoX I2V",
      "animatediff-cameractrl": "CameraCtrl",
      "camera-comfyui": "4x4 Matrices",
      ati: "Any Trajectory",
      "light-x": "Relighting",
      ttm: "Cut & Drag",
      "controlnet-depth": "Depth",
      "controlnet-canny": "Canny Edge",
      "controlnet-lineart": "Line Art",
      "custom-workflow": "Custom Workflow"
    })), Q = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ], le = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function re(Y) {
      o.value = Y;
      const H = h7[Y];
      H && (a.value = H.width ?? 832, l.value = H.height ?? 480, c.value = H.frameCount ?? 81, u.value = H.fps ?? 24, h.value = c.value);
      const I = hg[Y];
      I && (m.value = I.requiredInputs.includes("depth_sequence") || I.requiredInputs.includes("depth_map"), v.value = I.requiredInputs.includes("camera_data") || I.requiredInputs.includes("camera_trajectory") || I.requiredInputs.includes("camera_poses"), _.value = I.requiredInputs.includes("reference_image") || I.requiredInputs.includes("first_frame"), g.value = I.requiredInputs.includes("last_frame"), p.value = Y.startsWith("controlnet-"));
    }
    async function j() {
      w.value = "connecting";
      try {
        const H = await Mo(E.value).checkConnection();
        w.value = H ? "connected" : "error";
      } catch {
        w.value = "error";
      }
    }
    function $(Y) {
      a.value = Y.width, l.value = Y.height;
    }
    function q(Y) {
      c.value = Y, h.value = Math.min(h.value, Y);
    }
    function oe() {
      C.value = Math.floor(Math.random() * 2147483647);
    }
    async function ie() {
      D.value = !0, R.value = null, O.value = new AbortController();
      const Y = {
        target: o.value,
        width: a.value,
        height: l.value,
        frameCount: c.value,
        fps: u.value,
        startFrame: d.value,
        endFrame: h.value,
        outputDir: "",
        filenamePrefix: `weyl_${o.value}_${Date.now()}`,
        exportDepthMap: m.value,
        exportControlImages: p.value,
        exportCameraData: v.value,
        exportReferenceFrame: _.value,
        exportLastFrame: g.value,
        depthFormat: x.value,
        controlType: M.value,
        prompt: S.value,
        negativePrompt: b.value,
        seed: C.value,
        steps: T.value,
        cfgScale: P.value,
        comfyuiServer: E.value,
        autoQueueWorkflow: y.value
      };
      try {
        const H = await U7(
          n.layers,
          n.cameraKeyframes,
          Y,
          (I) => {
            U.value = I;
          }
        );
        H.success ? i("exported", H) : R.value = H.errors.join(`
`);
      } catch (H) {
        R.value = H instanceof Error ? H.message : "Export failed";
      } finally {
        D.value = !1, O.value = null;
      }
    }
    function ce() {
      O.value && O.value.abort();
    }
    function V() {
      D.value && ce(), i("close");
    }
    return xn(() => {
      h.value = Math.min(c.value, n.totalFrames), j();
    }), Ft(o, () => {
      re(o.value);
    }), (Y, H) => {
      var I, F, L;
      return te(), ae("div", {
        class: "export-dialog-overlay",
        onClick: xt(V, ["self"])
      }, [
        f("div", O7, [
          f("header", { class: "dialog-header" }, [
            H[24] || (H[24] = f("h2", null, "Export to ComfyUI", -1)),
            f("button", {
              class: "close-btn",
              onClick: V
            }, "")
          ]),
          f("nav", z7, [
            f("button", {
              class: Fe({ active: r.value === "target" }),
              onClick: H[0] || (H[0] = (ee) => r.value = "target")
            }, " Target ", 2),
            f("button", {
              class: Fe({ active: r.value === "output" }),
              onClick: H[1] || (H[1] = (ee) => r.value = "output")
            }, " Output ", 2),
            f("button", {
              class: Fe({ active: r.value === "generation" }),
              onClick: H[2] || (H[2] = (ee) => r.value = "generation")
            }, " Generation ", 2),
            f("button", {
              class: Fe({ active: r.value === "comfyui" }),
              onClick: H[3] || (H[3] = (ee) => r.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          f("div", N7, [
            r.value === "target" ? (te(), ae("div", B7, [
              f("div", V7, [
                (te(!0), ae(qe, null, ot(G.value, (ee, Z) => (te(), ae("div", {
                  key: Z,
                  class: "target-category"
                }, [
                  f("h3", null, _e(Z), 1),
                  f("div", G7, [
                    (te(!0), ae(qe, null, ot(ee, (k) => (te(), ae("button", {
                      key: k,
                      class: Fe({ selected: o.value === k }),
                      onClick: (ne) => re(k)
                    }, _e(ue.value[k]), 11, H7))), 128))
                  ])
                ]))), 128))
              ]),
              A.value ? (te(), ae("div", $7, [
                f("h4", null, _e(ue.value[o.value]), 1),
                f("div", W7, [
                  H[25] || (H[25] = f("span", { class: "label" }, "Required:", -1)),
                  f("span", null, _e(A.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                f("div", X7, [
                  H[26] || (H[26] = f("span", { class: "label" }, "Optional:", -1)),
                  f("span", null, _e(A.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                f("div", j7, [
                  H[27] || (H[27] = f("span", { class: "label" }, "Outputs:", -1)),
                  f("span", null, _e(A.value.outputTypes.join(", ")), 1)
                ])
              ])) : Pe("", !0)
            ])) : Pe("", !0),
            r.value === "output" ? (te(), ae("div", Y7, [
              f("div", q7, [
                H[28] || (H[28] = f("h3", null, "Resolution", -1)),
                f("div", Z7, [
                  (te(!0), ae(qe, null, ot(Ve(p7), (ee) => (te(), ae("button", {
                    key: ee.name,
                    onClick: (Z) => $(ee)
                  }, _e(ee.name), 9, K7))), 128))
                ]),
                f("div", J7, [
                  ze(et, {
                    modelValue: a.value,
                    "onUpdate:modelValue": H[4] || (H[4] = (ee) => a.value = ee),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  ze(et, {
                    modelValue: l.value,
                    "onUpdate:modelValue": H[5] || (H[5] = (ee) => l.value = ee),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              f("div", Q7, [
                H[29] || (H[29] = f("h3", null, "Frames", -1)),
                f("div", e9, [
                  (te(!0), ae(qe, null, ot(Ve(m7), (ee) => (te(), ae("button", {
                    key: ee.name,
                    onClick: (Z) => q(ee.frameCount)
                  }, _e(ee.name), 9, t9))), 128))
                ]),
                f("div", n9, [
                  ze(et, {
                    modelValue: c.value,
                    "onUpdate:modelValue": H[6] || (H[6] = (ee) => c.value = ee),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  ze(et, {
                    modelValue: u.value,
                    "onUpdate:modelValue": H[7] || (H[7] = (ee) => u.value = ee),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                f("div", i9, [
                  ze(et, {
                    modelValue: d.value,
                    "onUpdate:modelValue": H[8] || (H[8] = (ee) => d.value = ee),
                    label: "Start",
                    min: 0,
                    max: h.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  ze(et, {
                    modelValue: h.value,
                    "onUpdate:modelValue": H[9] || (H[9] = (ee) => h.value = ee),
                    label: "End",
                    min: d.value + 1,
                    max: c.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              f("div", s9, [
                H[35] || (H[35] = f("h3", null, "Export Options", -1)),
                f("div", r9, [
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[10] || (H[10] = (ee) => _.value = ee)
                    }, null, 512), [
                      [_i, _.value]
                    ]),
                    H[30] || (H[30] = ct(" Reference Frame ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[11] || (H[11] = (ee) => g.value = ee)
                    }, null, 512), [
                      [_i, g.value]
                    ]),
                    H[31] || (H[31] = ct(" Last Frame ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[12] || (H[12] = (ee) => m.value = ee)
                    }, null, 512), [
                      [_i, m.value]
                    ]),
                    H[32] || (H[32] = ct(" Depth Maps ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[13] || (H[13] = (ee) => p.value = ee)
                    }, null, 512), [
                      [_i, p.value]
                    ]),
                    H[33] || (H[33] = ct(" Control Images ", -1))
                  ]),
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": H[14] || (H[14] = (ee) => v.value = ee)
                    }, null, 512), [
                      [_i, v.value]
                    ]),
                    H[34] || (H[34] = ct(" Camera Data ", -1))
                  ])
                ])
              ]),
              m.value ? (te(), ae("div", o9, [
                H[36] || (H[36] = f("h3", null, "Depth Format", -1)),
                st(f("select", {
                  "onUpdate:modelValue": H[15] || (H[15] = (ee) => x.value = ee)
                }, [
                  (te(), ae(qe, null, ot(Q, (ee) => f("option", {
                    key: ee.value,
                    value: ee.value
                  }, _e(ee.label), 9, a9)), 64))
                ], 512), [
                  [Cn, x.value]
                ])
              ])) : Pe("", !0),
              p.value ? (te(), ae("div", l9, [
                H[37] || (H[37] = f("h3", null, "Control Type", -1)),
                st(f("select", {
                  "onUpdate:modelValue": H[16] || (H[16] = (ee) => M.value = ee)
                }, [
                  (te(), ae(qe, null, ot(le, (ee) => f("option", {
                    key: ee.value,
                    value: ee.value
                  }, _e(ee.label), 9, c9)), 64))
                ], 512), [
                  [Cn, M.value]
                ])
              ])) : Pe("", !0)
            ])) : Pe("", !0),
            r.value === "generation" ? (te(), ae("div", u9, [
              f("div", d9, [
                H[38] || (H[38] = f("h3", null, "Prompt", -1)),
                st(f("textarea", {
                  "onUpdate:modelValue": H[17] || (H[17] = (ee) => S.value = ee),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [Ut, S.value]
                ])
              ]),
              f("div", h9, [
                H[39] || (H[39] = f("h3", null, "Negative Prompt", -1)),
                st(f("textarea", {
                  "onUpdate:modelValue": H[18] || (H[18] = (ee) => b.value = ee),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [Ut, b.value]
                ])
              ]),
              f("div", f9, [
                H[40] || (H[40] = f("h3", null, "Parameters", -1)),
                f("div", p9, [
                  ze(et, {
                    modelValue: T.value,
                    "onUpdate:modelValue": H[19] || (H[19] = (ee) => T.value = ee),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  ze(et, {
                    modelValue: P.value,
                    "onUpdate:modelValue": H[20] || (H[20] = (ee) => P.value = ee),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                f("div", m9, [
                  ze(et, {
                    modelValue: C.value ?? 0,
                    "onUpdate:modelValue": H[21] || (H[21] = (ee) => C.value = ee),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  f("button", {
                    class: "randomize-btn",
                    onClick: oe
                  }, "Random")
                ])
              ])
            ])) : Pe("", !0),
            r.value === "comfyui" ? (te(), ae("div", v9, [
              f("div", g9, [
                H[41] || (H[41] = f("h3", null, "Server", -1)),
                f("div", y9, [
                  st(f("input", {
                    type: "text",
                    "onUpdate:modelValue": H[22] || (H[22] = (ee) => E.value = ee),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [Ut, E.value]
                  ]),
                  f("button", { onClick: j }, _e(w.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                f("div", {
                  class: Fe(["connection-status", w.value])
                }, [
                  w.value === "connected" ? (te(), ae("span", x9, "Connected")) : w.value === "error" ? (te(), ae("span", _9, "Connection failed")) : w.value === "connecting" ? (te(), ae("span", b9, "Connecting...")) : (te(), ae("span", w9, "Not connected"))
                ], 2)
              ]),
              f("div", S9, [
                H[43] || (H[43] = f("h3", null, "Workflow", -1)),
                f("label", M9, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": H[23] || (H[23] = (ee) => y.value = ee)
                  }, null, 512), [
                    [_i, y.value]
                  ]),
                  H[42] || (H[42] = f("span", null, [
                    f("strong", null, "Auto-queue workflow"),
                    f("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : Pe("", !0)
          ]),
          D.value ? (te(), ae("div", C9, [
            f("div", T9, [
              f("span", null, _e(((I = U.value) == null ? void 0 : I.message) || "Exporting..."), 1),
              f("button", { onClick: ce }, "Cancel")
            ]),
            f("div", E9, [
              f("div", {
                class: "progress-fill",
                style: yt({ width: `${((F = U.value) == null ? void 0 : F.overallProgress) || 0}%` })
              }, null, 4)
            ]),
            (L = U.value) != null && L.currentFrame ? (te(), ae("div", A9, " Frame " + _e(U.value.currentFrame) + " / " + _e(U.value.totalFrames), 1)) : Pe("", !0)
          ])) : Pe("", !0),
          R.value ? (te(), ae("div", P9, _e(R.value), 1)) : Pe("", !0),
          f("footer", R9, [
            f("button", {
              class: "secondary",
              onClick: V
            }, "Cancel"),
            f("button", {
              class: "primary",
              disabled: D.value,
              onClick: ie
            }, _e(D.value ? "Exporting..." : "Export"), 9, D9)
          ])
        ])
      ]);
    };
  }
}), I9 = /* @__PURE__ */ Gt(k9, [["__scopeId", "data-v-784836ff"]]), L9 = { class: "dialog-container" }, F9 = { class: "dialog-content" }, U9 = { class: "form-row" }, O9 = { class: "tabs" }, z9 = {
  key: 0,
  class: "tab-content"
}, N9 = { class: "form-row" }, B9 = { class: "form-row dimensions-row" }, V9 = { class: "dimension-group" }, G9 = { class: "dimension-group" }, H9 = { class: "form-row" }, $9 = { class: "aspect-info" }, W9 = { class: "form-row" }, X9 = { class: "form-row" }, j9 = { class: "resolution-info" }, Y9 = { class: "form-row" }, q9 = { class: "duration-inputs" }, Z9 = { class: "duration-helper" }, K9 = { class: "form-row" }, J9 = { class: "color-picker-row" }, Q9 = { class: "color-label" }, eG = {
  key: 1,
  class: "tab-content"
}, tG = { class: "form-row" }, nG = { class: "form-row" }, iG = { class: "form-row" }, sG = { class: "motion-blur-settings" }, rG = {
  key: 0,
  class: "motion-blur-params"
}, oG = { class: "param-row" }, aG = { class: "param-row" }, lG = { class: "dialog-footer" }, cG = { class: "preview-toggle" }, uG = /* @__PURE__ */ Ot({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = sn(), o = we("basic"), a = we("custom"), l = we(!1), c = we(16 / 9), u = we(!1), d = we({
      name: "Main Comp",
      width: 1920,
      height: 1080,
      pixelAspectRatio: 1,
      fps: 30,
      frameCount: 300,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: !0,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: !1,
      shutterAngle: 180,
      shutterPhase: -90
    }), h = Ie(() => {
      const y = d.value.width / d.value.height * d.value.pixelAspectRatio;
      return Math.abs(y - 16 / 9) < 0.01 ? "16:9 (1.78)" : Math.abs(y - 4 / 3) < 0.01 ? "4:3 (1.33)" : Math.abs(y - 1) < 0.01 ? "1:1 (1.0)" : Math.abs(y - 9 / 16) < 0.01 ? "9:16 (0.56)" : Math.abs(y - 21 / 9) < 0.01 ? "21:9 (2.33)" : `${y.toFixed(2)}`;
    }), m = Ie(() => d.value.frameCount / d.value.fps), p = we("00:00:10:00"), v = Ie(() => {
      const w = { full: 1, half: 2, third: 3, quarter: 4 }[d.value.resolution], D = Math.floor(d.value.width / w), U = Math.floor(d.value.height / w), R = (D * U * 4 / (1024 * 1024)).toFixed(1);
      return `${D} x ${U}, ${R} MB per 8bpc frame`;
    }), _ = {
      "1080p30": { width: 1920, height: 1080, fps: 30 },
      "1080p60": { width: 1920, height: 1080, fps: 60 },
      "720p30": { width: 1280, height: 720, fps: 30 },
      "4k30": { width: 3840, height: 2160, fps: 30 },
      instagram_square: { width: 1080, height: 1080, fps: 30 },
      instagram_story: { width: 1080, height: 1920, fps: 30 },
      tiktok: { width: 1080, height: 1920, fps: 30 },
      youtube_short: { width: 1080, height: 1920, fps: 60 },
      sd15_512: { width: 512, height: 512, fps: 8 },
      sd15_768: { width: 768, height: 512, fps: 8 },
      sdxl_1024: { width: 1024, height: 1024, fps: 8 },
      wan_480p: { width: 832, height: 480, fps: 16 },
      wan_720p: { width: 1280, height: 720, fps: 16 }
    };
    function g() {
      const y = _[a.value];
      y && (y.width && (d.value.width = y.width), y.height && (d.value.height = y.height), y.fps && (d.value.fps = y.fps), c.value = d.value.width / d.value.height, S());
    }
    function x(y) {
      d.value.width = Math.round(d.value.width / 8) * 8, d.value.height = Math.round(d.value.height / 8) * 8, l.value ? y === "width" ? d.value.height = Math.round(d.value.width / c.value / 8) * 8 : d.value.width = Math.round(d.value.height * c.value / 8) * 8 : c.value = d.value.width / d.value.height, a.value = "custom";
    }
    function M() {
      const y = p.value.split(":").map((w) => parseInt(w) || 0);
      if (y.length === 4) {
        const [w, D, U, R] = y, O = w * 3600 + D * 60 + U;
        d.value.frameCount = Math.round(O * d.value.fps) + R;
      } else y.length === 1 && (d.value.frameCount = y[0]);
    }
    function S() {
      const y = d.value.frameCount, w = d.value.fps, D = Math.floor(y / w), U = y % Math.round(w), R = Math.floor(D / 3600), O = Math.floor(D % 3600 / 60), A = D % 60;
      p.value = `${b(R)}:${b(O)}:${b(A)}:${b(U)}`;
    }
    function b(y) {
      return y.toString().padStart(2, "0");
    }
    function C() {
      var y, w, D, U, R, O;
      d.value = {
        name: ((w = (y = r.project) == null ? void 0 : y.meta) == null ? void 0 : w.name) || "Main Comp",
        width: r.width,
        height: r.height,
        pixelAspectRatio: 1,
        fps: r.fps,
        frameCount: r.frameCount,
        resolution: "full",
        backgroundColor: ((U = (D = r.project) == null ? void 0 : D.composition) == null ? void 0 : U.backgroundColor) || "#000000",
        autoResizeToContent: ((O = (R = r.project) == null ? void 0 : R.composition) == null ? void 0 : O.autoResizeToContent) ?? !0,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: !1,
        shutterAngle: 180,
        shutterPhase: -90
      }, c.value = d.value.width / d.value.height, S();
    }
    function T() {
      i("close");
    }
    function P() {
      i("confirm", { ...d.value }), i("close");
    }
    function E(y) {
      y.key === "Escape" ? T() : y.key === "Enter" && !y.shiftKey && P();
    }
    return Ft(() => n.visible, (y) => {
      y && C();
    }), Ft(d, () => {
      u.value && n.visible && r.resizeComposition(d.value.width, d.value.height, d.value.frameCount);
    }, { deep: !0 }), xn(() => {
      window.addEventListener("keydown", E);
    }), Nn(() => {
      window.removeEventListener("keydown", E);
    }), (y, w) => (te(), St(zo, { to: "body" }, [
      s.visible ? (te(), ae("div", {
        key: 0,
        class: "dialog-overlay",
        onClick: xt(T, ["self"])
      }, [
        f("div", L9, [
          f("div", { class: "dialog-header" }, [
            w[20] || (w[20] = f("span", { class: "dialog-title" }, "Composition Settings", -1)),
            f("button", {
              class: "close-btn",
              onClick: T
            }, "")
          ]),
          f("div", F9, [
            f("div", U9, [
              w[21] || (w[21] = f("label", null, "Composition Name:", -1)),
              st(f("input", {
                type: "text",
                "onUpdate:modelValue": w[0] || (w[0] = (D) => d.value.name = D),
                class: "text-input full-width"
              }, null, 512), [
                [Ut, d.value.name]
              ])
            ]),
            f("div", O9, [
              f("button", {
                class: Fe({ active: o.value === "basic" }),
                onClick: w[1] || (w[1] = (D) => o.value = "basic")
              }, "Basic", 2),
              f("button", {
                class: Fe({ active: o.value === "advanced" }),
                onClick: w[2] || (w[2] = (D) => o.value = "advanced")
              }, "Advanced", 2)
            ]),
            o.value === "basic" ? (te(), ae("div", z9, [
              f("div", N9, [
                w[23] || (w[23] = f("label", null, "Preset:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[3] || (w[3] = (D) => a.value = D),
                  onChange: g,
                  class: "select-input"
                }, [...w[22] || (w[22] = [
                  f("option", { value: "custom" }, "Custom", -1),
                  f("optgroup", { label: "Video" }, [
                    f("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                    f("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                    f("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                    f("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                  ], -1),
                  f("optgroup", { label: "Social Media" }, [
                    f("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                    f("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                    f("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                    f("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                  ], -1),
                  f("optgroup", { label: "AI Video (ComfyUI)" }, [
                    f("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                    f("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                    f("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                    f("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                    f("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)")
                  ], -1)
                ])], 544), [
                  [Cn, a.value]
                ])
              ]),
              f("div", B9, [
                f("div", V9, [
                  w[24] || (w[24] = f("label", null, "Width:", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": w[4] || (w[4] = (D) => d.value.width = D),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: w[5] || (w[5] = (D) => x("width"))
                  }, null, 544), [
                    [
                      Ut,
                      d.value.width,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  w[25] || (w[25] = f("span", { class: "unit" }, "px", -1))
                ]),
                f("button", {
                  class: Fe(["lock-btn", { locked: l.value }]),
                  onClick: w[6] || (w[6] = (D) => l.value = !l.value),
                  title: "Lock Aspect Ratio"
                }, _e(l.value ? "" : ""), 3),
                f("div", G9, [
                  w[26] || (w[26] = f("label", null, "Height:", -1)),
                  st(f("input", {
                    type: "number",
                    "onUpdate:modelValue": w[7] || (w[7] = (D) => d.value.height = D),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: w[8] || (w[8] = (D) => x("height"))
                  }, null, 544), [
                    [
                      Ut,
                      d.value.height,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  w[27] || (w[27] = f("span", { class: "unit" }, "px", -1))
                ])
              ]),
              f("div", H9, [
                w[29] || (w[29] = f("label", null, "Pixel Aspect Ratio:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[9] || (w[9] = (D) => d.value.pixelAspectRatio = D),
                  class: "select-input"
                }, [...w[28] || (w[28] = [
                  f("option", { value: "1" }, "Square Pixels (1.0)", -1),
                  f("option", { value: "1.067" }, "D1/DV NTSC (0.9)", -1),
                  f("option", { value: "1.422" }, "D1/DV PAL (1.067)", -1),
                  f("option", { value: "1.333" }, "Anamorphic 2:1 (2.0)", -1)
                ])], 512), [
                  [Cn, d.value.pixelAspectRatio]
                ]),
                f("span", $9, "Frame Aspect Ratio: " + _e(h.value), 1)
              ]),
              f("div", W9, [
                w[31] || (w[31] = f("label", null, "Frame Rate:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[10] || (w[10] = (D) => d.value.fps = D),
                  class: "select-input short"
                }, [...w[30] || (w[30] = [
                  f("option", { value: 8 }, "8", -1),
                  f("option", { value: 12 }, "12", -1),
                  f("option", { value: 15 }, "15", -1),
                  f("option", { value: 16 }, "16", -1),
                  f("option", { value: 23.976 }, "23.976", -1),
                  f("option", { value: 24 }, "24", -1),
                  f("option", { value: 25 }, "25", -1),
                  f("option", { value: 29.97 }, "29.97", -1),
                  f("option", { value: 30 }, "30", -1),
                  f("option", { value: 50 }, "50", -1),
                  f("option", { value: 59.94 }, "59.94", -1),
                  f("option", { value: 60 }, "60", -1)
                ])], 512), [
                  [
                    Cn,
                    d.value.fps,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                w[32] || (w[32] = f("span", { class: "unit" }, "frames per second", -1))
              ]),
              f("div", X9, [
                w[34] || (w[34] = f("label", null, "Resolution:", -1)),
                st(f("select", {
                  "onUpdate:modelValue": w[11] || (w[11] = (D) => d.value.resolution = D),
                  class: "select-input short"
                }, [...w[33] || (w[33] = [
                  f("option", { value: "full" }, "Full", -1),
                  f("option", { value: "half" }, "Half", -1),
                  f("option", { value: "third" }, "Third", -1),
                  f("option", { value: "quarter" }, "Quarter", -1)
                ])], 512), [
                  [Cn, d.value.resolution]
                ]),
                f("span", j9, _e(v.value), 1)
              ]),
              f("div", Y9, [
                w[35] || (w[35] = f("label", null, "Duration:", -1)),
                f("div", q9, [
                  st(f("input", {
                    type: "text",
                    "onUpdate:modelValue": w[12] || (w[12] = (D) => p.value = D),
                    class: "timecode-input",
                    placeholder: "00:00:00:00",
                    onBlur: M
                  }, null, 544), [
                    [Ut, p.value]
                  ]),
                  f("span", Z9, _e(d.value.frameCount) + " frames = " + _e(m.value.toFixed(2)) + "s ", 1)
                ])
              ]),
              f("div", K9, [
                w[36] || (w[36] = f("label", null, "Background Color:", -1)),
                f("div", J9, [
                  st(f("input", {
                    type: "color",
                    "onUpdate:modelValue": w[13] || (w[13] = (D) => d.value.backgroundColor = D),
                    class: "color-input"
                  }, null, 512), [
                    [Ut, d.value.backgroundColor]
                  ]),
                  f("span", Q9, _e(d.value.backgroundColor), 1)
                ])
              ])
            ])) : Pe("", !0),
            o.value === "advanced" ? (te(), ae("div", eG, [
              f("div", tG, [
                f("label", null, [
                  st(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": w[14] || (w[14] = (D) => d.value.autoResizeToContent = D)
                  }, null, 512), [
                    [_i, d.value.autoResizeToContent]
                  ]),
                  w[37] || (w[37] = ct(" Auto-resize composition when importing video ", -1))
                ])
              ]),
              f("div", nG, [
                w[38] || (w[38] = f("label", null, "Start Timecode:", -1)),
                st(f("input", {
                  type: "text",
                  "onUpdate:modelValue": w[15] || (w[15] = (D) => d.value.startTimecode = D),
                  class: "timecode-input",
                  placeholder: "00:00:00:00"
                }, null, 512), [
                  [Ut, d.value.startTimecode]
                ])
              ]),
              f("div", iG, [
                w[44] || (w[44] = f("label", null, "Motion Blur:", -1)),
                f("div", sG, [
                  f("label", null, [
                    st(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": w[16] || (w[16] = (D) => d.value.motionBlurEnabled = D)
                    }, null, 512), [
                      [_i, d.value.motionBlurEnabled]
                    ]),
                    w[39] || (w[39] = ct(" Enable Motion Blur ", -1))
                  ]),
                  d.value.motionBlurEnabled ? (te(), ae("div", rG, [
                    f("div", oG, [
                      w[40] || (w[40] = f("label", null, "Shutter Angle:", -1)),
                      st(f("input", {
                        type: "number",
                        "onUpdate:modelValue": w[17] || (w[17] = (D) => d.value.shutterAngle = D),
                        min: "0",
                        max: "720",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          Ut,
                          d.value.shutterAngle,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      w[41] || (w[41] = f("span", { class: "unit" }, "", -1))
                    ]),
                    f("div", aG, [
                      w[42] || (w[42] = f("label", null, "Shutter Phase:", -1)),
                      st(f("input", {
                        type: "number",
                        "onUpdate:modelValue": w[18] || (w[18] = (D) => d.value.shutterPhase = D),
                        min: "-360",
                        max: "360",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          Ut,
                          d.value.shutterPhase,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      w[43] || (w[43] = f("span", { class: "unit" }, "", -1))
                    ])
                  ])) : Pe("", !0)
                ])
              ])
            ])) : Pe("", !0)
          ]),
          f("div", lG, [
            f("div", cG, [
              f("label", null, [
                st(f("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": w[19] || (w[19] = (D) => u.value = D)
                }, null, 512), [
                  [_i, u.value]
                ]),
                w[45] || (w[45] = ct(" Preview ", -1))
              ])
            ]),
            f("div", { class: "dialog-actions" }, [
              f("button", {
                class: "btn btn-secondary",
                onClick: T
              }, "Cancel"),
              f("button", {
                class: "btn btn-primary",
                onClick: P
              }, "OK")
            ])
          ])
        ])
      ])) : Pe("", !0)
    ]));
  }
}), dG = /* @__PURE__ */ Gt(uG, [["__scopeId", "data-v-76356b13"]]), hG = { class: "workspace-layout" }, fG = { class: "toolbar" }, pG = { class: "tool-group" }, mG = { class: "tool-group" }, vG = ["title"], gG = { class: "icon" }, yG = { class: "timecode-display" }, xG = { class: "tool-group" }, _G = { class: "tool-group" }, bG = ["disabled"], wG = ["disabled"], SG = { class: "workspace-content" }, MG = { class: "panel left-panel" }, CG = { class: "panel-tabs" }, TG = { class: "panel-content" }, EG = { class: "panel viewport-panel" }, AG = { class: "viewport-header" }, PG = { class: "viewport-tabs" }, RG = { class: "viewport-controls" }, DG = { class: "viewport-content" }, kG = { class: "panel timeline-panel" }, IG = { class: "panel graph-editor-panel" }, LG = {
  key: 1,
  class: "panel timeline-panel"
}, FG = { class: "panel right-panel" }, UG = { class: "panel-tabs" }, OG = { class: "panel-content" }, zG = { class: "status-bar" }, NG = { class: "status-left" }, BG = { class: "status-item" }, VG = { class: "status-item" }, GG = { class: "status-center" }, HG = {
  key: 0,
  class: "render-progress"
}, $G = { class: "status-right" }, WG = { class: "status-item" }, XG = { class: "status-item" }, jG = /* @__PURE__ */ Ot({
  __name: "WorkspaceLayout",
  setup(s) {
    const e = sn(), n = Ie({
      get: () => e.currentTool,
      set: (I) => e.setTool(I)
    }), i = we("standard"), r = we("project"), o = we("properties"), a = we("composition"), l = we("fit"), c = we(!1), u = we(!0), d = we(!1), h = we(!1), m = we(!1), p = we(!1), v = we(!1), _ = we("cpu"), g = we(null), x = Ie(() => {
      const I = e.getActiveCameraAtFrame();
      return I || Ty("default", b.value, C.value);
    }), M = we(Ey()), S = we({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), b = Ie(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.composition) == null ? void 0 : F.width) || 1920;
    }), C = Ie(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.composition) == null ? void 0 : F.height) || 1080;
    }), T = we(60), P = we("0 MB"), E = we(0), y = Ie(() => {
      var ne, J;
      const I = e.currentFrame, F = ((J = (ne = e.project) == null ? void 0 : ne.composition) == null ? void 0 : J.fps) || 30, L = I / F, ee = Math.floor(L / 60), Z = Math.floor(L % 60), k = I % F;
      return `${String(ee).padStart(2, "0")}:${String(Z).padStart(2, "0")}:${String(k).padStart(2, "0")}`;
    }), w = Ie(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.meta) == null ? void 0 : F.name) || "Untitled Project";
    }), D = Ie(() => {
      var F;
      const I = (F = e.project) == null ? void 0 : F.composition;
      return I ? `${I.width}${I.height} @ ${I.fps}fps` : "No Composition";
    }), U = Ie(() => e.canUndo), R = Ie(() => e.canRedo);
    function O() {
      v.value = !v.value, v.value ? e.play() : e.pause();
    }
    function A() {
      e.goToStart();
    }
    function G() {
      e.goToEnd();
    }
    function ue() {
      e.setFrame(e.currentFrame + 1);
    }
    function Q() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function le() {
      e.undo();
    }
    function re() {
      e.redo();
    }
    function j(I) {
      e.activeCameraId && e.updateCamera(I.id, I);
    }
    function $() {
      console.log("[Weyl] Matte export completed");
    }
    function q(I) {
      console.log("[Weyl] ComfyUI export completed", I), m.value = !1;
    }
    function oe(I) {
      console.log("[Weyl] Composition settings updated:", I), e.updateCompositionSettings(e.activeCompositionId, {
        width: I.width,
        height: I.height,
        fps: I.fps,
        frameCount: I.frameCount,
        backgroundColor: I.backgroundColor,
        autoResizeToContent: I.autoResizeToContent
      }), e.renameComposition(e.activeCompositionId, I.name), p.value = !1;
    }
    const ie = Ie(() => {
      const I = e.getActiveCameraAtFrame();
      return I ? e.getCameraKeyframes(I.id) : [];
    });
    function ce() {
      console.log("[WorkspaceLayout] Zoom changed to:", l.value);
    }
    function V(I) {
      var F, L;
      if (!(((F = document.activeElement) == null ? void 0 : F.tagName) === "INPUT" || ((L = document.activeElement) == null ? void 0 : L.tagName) === "TEXTAREA"))
        switch (I.key.toLowerCase()) {
          case " ":
            I.preventDefault(), O();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            I.ctrlKey || I.metaKey ? (I.preventDefault(), I.shiftKey ? re() : le()) : n.value = "zoom";
            break;
          case "home":
            I.preventDefault(), A();
            break;
          case "end":
            I.preventDefault(), G();
            break;
          case "arrowleft":
            I.preventDefault(), Q();
            break;
          case "arrowright":
            I.preventDefault(), ue();
            break;
          case "g":
            I.shiftKey && (d.value = !d.value);
            break;
          case "k":
            (I.ctrlKey || I.metaKey) && (I.preventDefault(), p.value = !0);
            break;
        }
    }
    let Y;
    function H() {
      if ("memory" in performance) {
        const I = performance.memory, F = Math.round(I.usedJSHeapSize / 1024 / 1024);
        P.value = `${F} MB`;
      }
    }
    return xn(async () => {
      const I = await DE();
      _.value = I.tier, window.addEventListener("keydown", V), Y = window.setInterval(H, 1e3);
    }), Nn(() => {
      window.removeEventListener("keydown", V), clearInterval(Y);
    }), (I, F) => (te(), ae("div", hG, [
      f("div", fG, [
        f("div", pG, [
          f("button", {
            class: Fe({ active: n.value === "select" }),
            onClick: F[0] || (F[0] = (L) => n.value = "select"),
            title: "Select (V)"
          }, [...F[27] || (F[27] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "pen" }),
            onClick: F[1] || (F[1] = (L) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...F[28] || (F[28] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "text" }),
            onClick: F[2] || (F[2] = (L) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...F[29] || (F[29] = [
            f("span", { class: "icon" }, "T", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "hand" }),
            onClick: F[3] || (F[3] = (L) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...F[30] || (F[30] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Fe({ active: n.value === "zoom" }),
            onClick: F[4] || (F[4] = (L) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...F[31] || (F[31] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        F[41] || (F[41] = f("div", { class: "divider" }, null, -1)),
        f("div", mG, [
          f("button", {
            onClick: A,
            title: "Go to Start (Home)"
          }, [...F[32] || (F[32] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: Q,
            title: "Step Backward"
          }, [...F[33] || (F[33] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: O,
            title: v.value ? "Pause (Space)" : "Play (Space)"
          }, [
            f("span", gG, _e(v.value ? "" : ""), 1)
          ], 8, vG),
          f("button", {
            onClick: ue,
            title: "Step Forward"
          }, [...F[34] || (F[34] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: G,
            title: "Go to End (End)"
          }, [...F[35] || (F[35] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ]),
        f("div", yG, _e(y.value), 1),
        F[42] || (F[42] = f("div", { class: "divider" }, null, -1)),
        f("div", xG, [
          st(f("select", {
            "onUpdate:modelValue": F[5] || (F[5] = (L) => i.value = L),
            class: "workspace-selector"
          }, [...F[36] || (F[36] = [
            f("option", { value: "standard" }, "Standard", -1),
            f("option", { value: "animation" }, "Animation", -1),
            f("option", { value: "effects" }, "Effects", -1),
            f("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [Cn, i.value]
          ])
        ]),
        F[43] || (F[43] = f("div", { class: "spacer" }, null, -1)),
        f("div", _G, [
          f("span", {
            class: Fe(["gpu-badge", _.value])
          }, _e(_.value.toUpperCase()), 3),
          f("button", {
            onClick: le,
            disabled: !U.value,
            title: "Undo (Ctrl+Z)"
          }, [...F[37] || (F[37] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, bG),
          f("button", {
            onClick: re,
            disabled: !R.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...F[38] || (F[38] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, wG),
          f("button", {
            onClick: F[6] || (F[6] = (L) => h.value = !0),
            title: "Export Matte"
          }, [...F[39] || (F[39] = [
            f("span", { class: "icon" }, "", -1),
            ct(" Matte ", -1)
          ])]),
          f("button", {
            onClick: F[7] || (F[7] = (L) => m.value = !0),
            title: "Export to ComfyUI"
          }, [...F[40] || (F[40] = [
            f("span", { class: "icon" }, "", -1),
            ct(" ComfyUI ", -1)
          ])])
        ])
      ]),
      f("div", SG, [
        ze(Ve(nd), { class: "default-theme horizontal-split" }, {
          default: Ni(() => [
            ze(Ve(vr), {
              size: 12,
              "min-size": 8,
              "max-size": 20
            }, {
              default: Ni(() => [
                f("div", MG, [
                  f("div", CG, [
                    f("button", {
                      class: Fe({ active: r.value === "project" }),
                      onClick: F[8] || (F[8] = (L) => r.value = "project")
                    }, " Project ", 2),
                    f("button", {
                      class: Fe({ active: r.value === "effects" }),
                      onClick: F[9] || (F[9] = (L) => r.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  f("div", TG, [
                    r.value === "project" ? (te(), St(rA, {
                      key: 0,
                      onOpenCompositionSettings: F[10] || (F[10] = (L) => p.value = !0)
                    })) : r.value === "effects" ? (te(), St(zA, { key: 1 })) : Pe("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            ze(Ve(vr), {
              size: 70,
              "min-size": 40
            }, {
              default: Ni(() => [
                ze(Ve(nd), {
                  horizontal: "",
                  class: "default-theme"
                }, {
                  default: Ni(() => [
                    ze(Ve(vr), {
                      size: 65,
                      "min-size": 20
                    }, {
                      default: Ni(() => [
                        f("div", EG, [
                          f("div", AG, [
                            f("div", PG, [
                              f("button", {
                                class: Fe({ active: a.value === "composition" }),
                                onClick: F[11] || (F[11] = (L) => a.value = "composition")
                              }, " Composition ", 2),
                              f("button", {
                                class: Fe({ active: a.value === "layer" }),
                                onClick: F[12] || (F[12] = (L) => a.value = "layer")
                              }, " Layer ", 2),
                              f("button", {
                                class: Fe({ active: a.value === "footage" }),
                                onClick: F[13] || (F[13] = (L) => a.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            f("div", RG, [
                              st(f("select", {
                                "onUpdate:modelValue": F[14] || (F[14] = (L) => l.value = L),
                                onChange: ce,
                                class: "zoom-select"
                              }, [...F[44] || (F[44] = [
                                f("option", { value: "fit" }, "Fit", -1),
                                f("option", { value: "25" }, "25%", -1),
                                f("option", { value: "50" }, "50%", -1),
                                f("option", { value: "75" }, "75%", -1),
                                f("option", { value: "100" }, "100%", -1),
                                f("option", { value: "150" }, "150%", -1),
                                f("option", { value: "200" }, "200%", -1)
                              ])], 544), [
                                [Cn, l.value]
                              ]),
                              f("button", {
                                class: Fe({ active: c.value }),
                                onClick: F[15] || (F[15] = (L) => c.value = !c.value),
                                title: "Toggle Guides"
                              }, [...F[45] || (F[45] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2),
                              f("button", {
                                class: Fe({ active: u.value }),
                                onClick: F[16] || (F[16] = (L) => u.value = !u.value),
                                title: "Toggle Grid"
                              }, [...F[46] || (F[46] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2)
                            ])
                          ]),
                          f("div", DG, [
                            a.value === "composition" ? (te(), St(L8, {
                              key: 0,
                              ref_key: "threeCanvasRef",
                              ref: g
                            }, null, 512)) : (te(), St(k6, {
                              key: 1,
                              camera: x.value,
                              viewportState: M.value,
                              viewOptions: S.value,
                              compWidth: b.value,
                              compHeight: C.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    ze(Ve(vr), {
                      size: 35,
                      "min-size": 15
                    }, {
                      default: Ni(() => [
                        d.value ? (te(), St(Ve(nd), {
                          key: 0,
                          horizontal: "",
                          class: "default-theme"
                        }, {
                          default: Ni(() => [
                            ze(Ve(vr), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: Ni(() => [
                                f("div", kG, [
                                  ze(rg, {
                                    onOpenCompositionSettings: F[17] || (F[17] = (L) => p.value = !0)
                                  })
                                ])
                              ]),
                              _: 1
                            }),
                            ze(Ve(vr), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: Ni(() => [
                                f("div", IG, [
                                  ze(SV, {
                                    onClose: F[18] || (F[18] = (L) => d.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : (te(), ae("div", LG, [
                          ze(rg, {
                            onOpenCompositionSettings: F[19] || (F[19] = (L) => p.value = !0)
                          })
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            ze(Ve(vr), {
              size: 18,
              "min-size": 12,
              "max-size": 25
            }, {
              default: Ni(() => [
                f("div", FG, [
                  f("div", UG, [
                    f("button", {
                      class: Fe({ active: o.value === "effects" }),
                      onClick: F[20] || (F[20] = (L) => o.value = "effects")
                    }, " Effects ", 2),
                    f("button", {
                      class: Fe({ active: o.value === "properties" }),
                      onClick: F[21] || (F[21] = (L) => o.value = "properties")
                    }, " Props ", 2),
                    f("button", {
                      class: Fe({ active: o.value === "camera" }),
                      onClick: F[22] || (F[22] = (L) => o.value = "camera")
                    }, " Cam ", 2),
                    f("button", {
                      class: Fe({ active: o.value === "audio" }),
                      onClick: F[23] || (F[23] = (L) => o.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  f("div", OG, [
                    o.value === "effects" ? (te(), St(aP, { key: 0 })) : o.value === "properties" ? (te(), St(aU, { key: 1 })) : o.value === "camera" ? (te(), St(NO, {
                      key: 2,
                      camera: x.value,
                      "onUpdate:camera": j
                    }, null, 8, ["camera"])) : o.value === "audio" ? (te(), St(u6, { key: 3 })) : Pe("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", zG, [
        f("div", NG, [
          f("span", BG, _e(w.value), 1),
          F[47] || (F[47] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", VG, _e(D.value), 1)
        ]),
        f("div", GG, [
          E.value > 0 ? (te(), ae("span", HG, " Rendering: " + _e(Math.round(E.value * 100)) + "% ", 1)) : Pe("", !0)
        ]),
        f("div", $G, [
          f("span", WG, _e(P.value), 1),
          F[48] || (F[48] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", XG, _e(T.value) + " fps", 1)
        ])
      ]),
      h.value ? (te(), St(d7, {
        key: 0,
        onClose: F[24] || (F[24] = (L) => h.value = !1),
        onExported: $
      })) : Pe("", !0),
      m.value ? (te(), St(I9, {
        key: 1,
        layers: Ve(e).layers,
        "camera-keyframes": ie.value,
        "current-frame": Ve(e).currentFrame,
        "total-frames": Ve(e).frameCount,
        onClose: F[25] || (F[25] = (L) => m.value = !1),
        onExported: q
      }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : Pe("", !0),
      ze(dG, {
        visible: p.value,
        onClose: F[26] || (F[26] = (L) => p.value = !1),
        onConfirm: oe
      }, null, 8, ["visible"])
    ]));
  }
}), YG = /* @__PURE__ */ Gt(jG, [["__scopeId", "data-v-7dd8f679"]]), qG = /* @__PURE__ */ Ot({
  __name: "App",
  setup(s) {
    return (e, n) => (te(), St(YG));
  }
}), Ky = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
], Jy = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function Qy(s) {
  const e = { r: 0, g: 0, b: 0, a: 0, next: null };
  let n = e;
  for (let i = 1; i < s; i++)
    n.next = { r: 0, g: 0, b: 0, a: 0, next: null }, n = n.next;
  return n.next = e, e;
}
function ZG(s, e, n) {
  const i = s.data, r = s.width, o = s.height;
  e = Math.max(0, Math.min(255, Math.round(e))), n = Math.max(0, Math.min(255, Math.round(n))), !(e === 0 && n === 0) && (e > 0 && KG(i, r, o, e), n > 0 && JG(i, r, o, n));
}
function KG(s, e, n, i) {
  const r = i + i + 1, o = e - 1, a = Ky[i], l = Jy[i], c = Qy(r);
  for (let u = 0; u < n; u++) {
    let d = 0, h = 0, m = 0, p = 0, v = 0, _ = 0, g = 0, x = 0, M = 0, S = 0, b = 0, C = 0;
    const T = u * e;
    let P = c, E = c;
    const y = s[T * 4], w = s[T * 4 + 1], D = s[T * 4 + 2], U = s[T * 4 + 3];
    for (let O = 0; O <= i; O++) {
      P.r = y, P.g = w, P.b = D, P.a = U;
      const A = i + 1 - O;
      M += y * A, S += w * A, b += D * A, C += U * A, O > 0 ? (d += y, h += w, m += D, p += U) : (v += y, _ += w, g += D, x += U), P = P.next;
    }
    for (let O = 1; O <= i; O++) {
      const A = Math.min(O, o), G = (T + A) * 4, ue = s[G], Q = s[G + 1], le = s[G + 2], re = s[G + 3];
      P.r = ue, P.g = Q, P.b = le, P.a = re;
      const j = i + 1 - O;
      M += ue * j, S += Q * j, b += le * j, C += re * j, d += ue, h += Q, m += le, p += re, P = P.next;
    }
    let R = c;
    for (let O = 0; O < i; O++)
      R = R.next;
    E = R.next;
    for (let O = 0; O < e; O++) {
      const A = (T + O) * 4;
      s[A] = M * a >>> l, s[A + 1] = S * a >>> l, s[A + 2] = b * a >>> l, s[A + 3] = C * a >>> l, M -= v, S -= _, b -= g, C -= x, v -= R.r, _ -= R.g, g -= R.b, x -= R.a;
      const G = Math.min(O + i + 1, o), ue = (T + G) * 4;
      R.r = s[ue], R.g = s[ue + 1], R.b = s[ue + 2], R.a = s[ue + 3], d += R.r, h += R.g, m += R.b, p += R.a, M += d, S += h, b += m, C += p, R = R.next, v += E.r, _ += E.g, g += E.b, x += E.a, d -= E.r, h -= E.g, m -= E.b, p -= E.a, E = E.next;
    }
  }
}
function JG(s, e, n, i) {
  const r = i + i + 1, o = n - 1, a = Ky[i], l = Jy[i], c = Qy(r);
  for (let u = 0; u < e; u++) {
    let d = 0, h = 0, m = 0, p = 0, v = 0, _ = 0, g = 0, x = 0, M = 0, S = 0, b = 0, C = 0, T = c, P = c;
    const E = s[u * 4], y = s[u * 4 + 1], w = s[u * 4 + 2], D = s[u * 4 + 3];
    for (let R = 0; R <= i; R++) {
      T.r = E, T.g = y, T.b = w, T.a = D;
      const O = i + 1 - R;
      M += E * O, S += y * O, b += w * O, C += D * O, R > 0 ? (d += E, h += y, m += w, p += D) : (v += E, _ += y, g += w, x += D), T = T.next;
    }
    for (let R = 1; R <= i; R++) {
      const A = (Math.min(R, o) * e + u) * 4, G = s[A], ue = s[A + 1], Q = s[A + 2], le = s[A + 3];
      T.r = G, T.g = ue, T.b = Q, T.a = le;
      const re = i + 1 - R;
      M += G * re, S += ue * re, b += Q * re, C += le * re, d += G, h += ue, m += Q, p += le, T = T.next;
    }
    let U = c;
    for (let R = 0; R < i; R++)
      U = U.next;
    P = U.next;
    for (let R = 0; R < n; R++) {
      const O = (R * e + u) * 4;
      s[O] = M * a >>> l, s[O + 1] = S * a >>> l, s[O + 2] = b * a >>> l, s[O + 3] = C * a >>> l, M -= v, S -= _, b -= g, C -= x, v -= U.r, _ -= U.g, g -= U.b, x -= U.a;
      const G = (Math.min(R + i + 1, o) * e + u) * 4;
      U.r = s[G], U.g = s[G + 1], U.b = s[G + 2], U.a = s[G + 3], d += U.r, h += U.g, m += U.b, p += U.a, M += d, S += h, b += m, C += p, U = U.next, v += P.r, _ += P.g, g += P.b, x += P.a, d -= P.r, h -= P.g, m -= P.b, p -= P.a, P = P.next;
    }
  }
}
function QG(s, e) {
  const n = e.blurriness ?? 10, i = e.blur_dimensions ?? "both";
  if (n <= 0)
    return s;
  const r = fr(s.canvas), o = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height);
  let a = 0, l = 0;
  switch (i) {
    case "horizontal":
      a = n;
      break;
    case "vertical":
      l = n;
      break;
    case "both":
    default:
      a = n, l = n;
      break;
  }
  return ZG(o, a, l), r.ctx.putImageData(o, 0, 0), r;
}
function eH() {
  Qs("gaussian-blur", QG);
}
function tH(s, e) {
  const n = (e.brightness ?? 0) / 100, i = (e.contrast ?? 0) / 100, r = e.use_legacy ?? !1;
  if (n === 0 && i === 0)
    return s;
  const o = fr(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = a.data, c = r ? 1 + i : 259 * (i * 255 + 255) / (255 * (259 - i * 255));
  for (let u = 0; u < l.length; u += 4) {
    let d = l[u], h = l[u + 1], m = l[u + 2];
    d += n * 255, h += n * 255, m += n * 255, d = c * (d - 128) + 128, h = c * (h - 128) + 128, m = c * (m - 128) + 128, l[u] = Math.max(0, Math.min(255, d)), l[u + 1] = Math.max(0, Math.min(255, h)), l[u + 2] = Math.max(0, Math.min(255, m));
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function nH(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = (i + r) / 2;
  let a = 0, l = 0;
  if (i !== r) {
    const c = i - r;
    switch (l = o > 0.5 ? c / (2 - i - r) : c / (i + r), i) {
      case s:
        a = ((e - n) / c + (e < n ? 6 : 0)) / 6;
        break;
      case e:
        a = ((n - s) / c + 2) / 6;
        break;
      case n:
        a = ((s - e) / c + 4) / 6;
        break;
    }
  }
  return [a, l, o];
}
function iH(s, e, n) {
  let i, r, o;
  if (e === 0)
    i = r = o = n;
  else {
    const a = (u, d, h) => (h < 0 && (h += 1), h > 1 && (h -= 1), h < 0.16666666666666666 ? u + (d - u) * 6 * h : h < 0.5 ? d : h < 0.6666666666666666 ? u + (d - u) * (0.6666666666666666 - h) * 6 : u), l = n < 0.5 ? n * (1 + e) : n + e - n * e, c = 2 * n - l;
    i = a(c, l, s + 1 / 3), r = a(c, l, s), o = a(c, l, s - 1 / 3);
  }
  return [Math.round(i * 255), Math.round(r * 255), Math.round(o * 255)];
}
function sH(s, e) {
  const n = (e.master_hue ?? 0) / 360, i = (e.master_saturation ?? 0) / 100, r = (e.master_lightness ?? 0) / 100, o = e.colorize ?? !1;
  if (n === 0 && i === 0 && r === 0 && !o)
    return s;
  const a = fr(s.canvas), l = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), c = l.data;
  for (let u = 0; u < c.length; u += 4) {
    const d = c[u], h = c[u + 1], m = c[u + 2];
    let [p, v, _] = nH(d, h, m);
    o ? (p = n, v = Math.abs(i) + 0.25) : (p = (p + n) % 1, p < 0 && (p += 1), v = v + v * i), _ = _ + _ * r, v = Math.max(0, Math.min(1, v)), _ = Math.max(0, Math.min(1, _));
    const [g, x, M] = iH(p, v, _);
    c[u] = g, c[u + 1] = x, c[u + 2] = M;
  }
  return a.ctx.putImageData(l, 0, 0), a;
}
function rH(s, e) {
  const n = e.input_black ?? 0, i = e.input_white ?? 255, r = e.gamma ?? 1, o = e.output_black ?? 0, a = e.output_white ?? 255;
  if (n === 0 && i === 255 && r === 1 && o === 0 && a === 255)
    return s;
  const l = fr(s.canvas), c = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), u = c.data, d = new Uint8Array(256), h = i - n, m = a - o;
  for (let p = 0; p < 256; p++) {
    let v = (p - n) / h;
    v = Math.max(0, Math.min(1, v)), v = Math.pow(v, 1 / r), v = o + v * m, v = Math.max(0, Math.min(255, v)), d[p] = Math.round(v);
  }
  for (let p = 0; p < u.length; p += 4)
    u[p] = d[u[p]], u[p + 1] = d[u[p + 1]], u[p + 2] = d[u[p + 2]];
  return l.ctx.putImageData(c, 0, 0), l;
}
function oH(s, e) {
  const n = e.map_black_to ?? { r: 0, g: 0, b: 0 }, i = e.map_white_to ?? { r: 255, g: 255, b: 255 }, r = (e.amount_to_tint ?? 100) / 100;
  if (r === 0)
    return s;
  const o = fr(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = a.data;
  for (let c = 0; c < l.length; c += 4) {
    const u = l[c], d = l[c + 1], h = l[c + 2], m = (u * 0.299 + d * 0.587 + h * 0.114) / 255, p = n.r + (i.r - n.r) * m, v = n.g + (i.g - n.g) * m, _ = n.b + (i.b - n.b) * m;
    l[c] = Math.round(u + (p - u) * r), l[c + 1] = Math.round(d + (v - d) * r), l[c + 2] = Math.round(h + (_ - h) * r);
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function aH(s, e, n, i, r) {
  const o = r * r, a = o * r, l = 1 - r, c = l * l;
  return c * l * s + 3 * c * r * e + 3 * l * o * n + a * i;
}
function Pa(s) {
  const e = new Uint8Array(256);
  if (!s || s.length === 0) {
    for (let i = 0; i < 256; i++)
      e[i] = i;
    return e;
  }
  if (s.length === 1) {
    for (let i = 0; i < 256; i++)
      e[i] = Math.max(0, Math.min(255, Math.round(s[0].y)));
    return e;
  }
  const n = [...s].sort((i, r) => i.x - r.x);
  n[0].x > 0 && n.unshift({ x: 0, y: n[0].y }), n[n.length - 1].x < 255 && n.push({ x: 255, y: n[n.length - 1].y });
  for (let i = 0; i < 256; i++) {
    let r = 0;
    for (let p = 0; p < n.length - 1; p++)
      if (i >= n[p].x && i <= n[p + 1].x) {
        r = p;
        break;
      }
    const o = n[r], a = n[r + 1], l = (i - o.x) / (a.x - o.x || 1);
    let c = 0, u = 0;
    if (r > 0) {
      const p = n[r - 1];
      c = (a.y - p.y) / (a.x - p.x || 1) * (a.x - o.x);
    }
    if (r < n.length - 2) {
      const p = n[r + 2];
      u = (p.y - o.y) / (p.x - o.x || 1) * (a.x - o.x);
    }
    const d = o.y + c / 3, h = a.y - u / 3, m = aH(o.y, d, h, a.y, l);
    e[i] = Math.max(0, Math.min(255, Math.round(m)));
  }
  return e;
}
function lH(s, e) {
  const n = e.master_curve, i = e.red_curve, r = e.green_curve, o = e.blue_curve, a = e.alpha_curve, l = (e.blend_with_original ?? 100) / 100;
  if (!(n || i || r || o || a) || l === 0)
    return s;
  const u = Pa(n ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), d = Pa(i ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), h = Pa(r ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), m = Pa(o ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), p = a ? Pa(a) : null, v = fr(s.canvas), _ = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), g = _.data;
  for (let x = 0; x < g.length; x += 4) {
    const M = g[x], S = g[x + 1], b = g[x + 2], C = g[x + 3];
    let T = u[M], P = u[S], E = u[b];
    T = d[T], P = h[P], E = m[E];
    const y = p ? p[C] : C;
    l < 1 && (T = Math.round(M + (T - M) * l), P = Math.round(S + (P - S) * l), E = Math.round(b + (E - b) * l)), g[x] = T, g[x + 1] = P, g[x + 2] = E, g[x + 3] = y;
  }
  return v.ctx.putImageData(_, 0, 0), v;
}
function cH(s, e) {
  const n = e.glow_threshold ?? 128, i = e.glow_radius ?? 20, r = (e.glow_intensity ?? 100) / 100, o = e.glow_operation ?? "add";
  if (r === 0 || i === 0)
    return s;
  const { width: a, height: l } = s.canvas, c = fr(s.canvas), u = document.createElement("canvas");
  u.width = a, u.height = l;
  const d = u.getContext("2d"), h = s.ctx.getImageData(0, 0, a, l), m = d.createImageData(a, l);
  for (let _ = 0; _ < h.data.length; _ += 4) {
    const g = h.data[_], x = h.data[_ + 1], M = h.data[_ + 2], S = h.data[_ + 3], b = g * 0.299 + x * 0.587 + M * 0.114;
    if (b > n) {
      const C = (b - n) / (255 - n) * r;
      m.data[_] = Math.min(255, g * C), m.data[_ + 1] = Math.min(255, x * C), m.data[_ + 2] = Math.min(255, M * C), m.data[_ + 3] = S;
    } else
      m.data[_] = 0, m.data[_ + 1] = 0, m.data[_ + 2] = 0, m.data[_ + 3] = 0;
  }
  d.putImageData(m, 0, 0);
  const p = document.createElement("canvas");
  p.width = a, p.height = l;
  const v = p.getContext("2d");
  switch (v.filter = `blur(${i}px)`, v.drawImage(u, 0, 0), c.ctx.drawImage(s.canvas, 0, 0), o) {
    case "screen":
      c.ctx.globalCompositeOperation = "screen";
      break;
    case "lighten":
      c.ctx.globalCompositeOperation = "lighten";
      break;
    case "add":
    default:
      c.ctx.globalCompositeOperation = "lighter";
      break;
  }
  return c.ctx.drawImage(p, 0, 0), c.ctx.globalCompositeOperation = "source-over", c;
}
function uH(s, e) {
  const n = e.shadow_color ?? { r: 0, g: 0, b: 0 }, i = (e.opacity ?? 50) / 100, r = (e.direction ?? 135) * Math.PI / 180, o = e.distance ?? 5, a = e.softness ?? 5, l = e.shadow_only ?? !1, c = fr(s.canvas), { width: u, height: d } = s.canvas, h = Math.cos(r) * o, m = Math.sin(r) * o;
  return c.ctx.shadowColor = `rgba(${n.r}, ${n.g}, ${n.b}, ${i})`, c.ctx.shadowBlur = a, c.ctx.shadowOffsetX = h, c.ctx.shadowOffsetY = m, c.ctx.drawImage(s.canvas, 0, 0), c.ctx.shadowColor = "transparent", c.ctx.shadowBlur = 0, c.ctx.shadowOffsetX = 0, c.ctx.shadowOffsetY = 0, l || c.ctx.drawImage(s.canvas, 0, 0), c;
}
function dH() {
  Qs("brightness-contrast", tH), Qs("hue-saturation", sH), Qs("levels", rH), Qs("tint", oH), Qs("curves", lH), Qs("glow", cH), Qs("drop-shadow", uH);
}
function hH() {
  eH(), dH();
}
let e1 = null;
function mg(s) {
  let e = null;
  if (typeof s == "string" ? e = document.getElementById(s) || document.querySelector(s) : s instanceof HTMLElement ? e = s : e = document.getElementById("weyl-compositor-root") || document.getElementById("app"), !e) return null;
  hH();
  const n = P_(qG);
  return n.use(k_()), n.mount(e), e1 = n, fH(), n;
}
function fH() {
  window.addEventListener("weyl:inputs-ready", (s) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: s.detail }));
  });
}
async function xH(s, e) {
  var n, i;
  return ((i = (n = window.WeylCompositor) == null ? void 0 : n.sendOutput) == null ? void 0 : i.call(n, s, e)) ?? !1;
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => mg()) : setTimeout(() => {
  e1 || mg();
}, 0);
var Ec = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function pH(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function Ac(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var t1 = { exports: {} };
(function(s, e) {
  var n = { env: {} };
  /*!
  
  	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  	<http://stuartk.com/jszip>
  
  	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  	JSZip uses the library pako released under the MIT license :
  	https://github.com/nodeca/pako/blob/main/LICENSE
  	*/
  (function(i) {
    s.exports = i();
  })(function() {
    return function i(r, o, a) {
      function l(d, h) {
        if (!o[d]) {
          if (!r[d]) {
            var m = typeof Ac == "function" && Ac;
            if (!h && m) return m(d, !0);
            if (c) return c(d, !0);
            var p = new Error("Cannot find module '" + d + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var v = o[d] = { exports: {} };
          r[d][0].call(v.exports, function(_) {
            var g = r[d][1][_];
            return l(g || _);
          }, v, v.exports, i, r, o, a);
        }
        return o[d].exports;
      }
      for (var c = typeof Ac == "function" && Ac, u = 0; u < a.length; u++) l(a[u]);
      return l;
    }({ 1: [function(i, r, o) {
      var a = i("./utils"), l = i("./support"), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      o.encode = function(u) {
        for (var d, h, m, p, v, _, g, x = [], M = 0, S = u.length, b = S, C = a.getTypeOf(u) !== "string"; M < u.length; ) b = S - M, m = C ? (d = u[M++], h = M < S ? u[M++] : 0, M < S ? u[M++] : 0) : (d = u.charCodeAt(M++), h = M < S ? u.charCodeAt(M++) : 0, M < S ? u.charCodeAt(M++) : 0), p = d >> 2, v = (3 & d) << 4 | h >> 4, _ = 1 < b ? (15 & h) << 2 | m >> 6 : 64, g = 2 < b ? 63 & m : 64, x.push(c.charAt(p) + c.charAt(v) + c.charAt(_) + c.charAt(g));
        return x.join("");
      }, o.decode = function(u) {
        var d, h, m, p, v, _, g = 0, x = 0, M = "data:";
        if (u.substr(0, M.length) === M) throw new Error("Invalid base64 input, it looks like a data url.");
        var S, b = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (u.charAt(u.length - 1) === c.charAt(64) && b--, u.charAt(u.length - 2) === c.charAt(64) && b--, b % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (S = l.uint8array ? new Uint8Array(0 | b) : new Array(0 | b); g < u.length; ) d = c.indexOf(u.charAt(g++)) << 2 | (p = c.indexOf(u.charAt(g++))) >> 4, h = (15 & p) << 4 | (v = c.indexOf(u.charAt(g++))) >> 2, m = (3 & v) << 6 | (_ = c.indexOf(u.charAt(g++))), S[x++] = d, v !== 64 && (S[x++] = h), _ !== 64 && (S[x++] = m);
        return S;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(i, r, o) {
      var a = i("./external"), l = i("./stream/DataWorker"), c = i("./stream/Crc32Probe"), u = i("./stream/DataLengthProbe");
      function d(h, m, p, v, _) {
        this.compressedSize = h, this.uncompressedSize = m, this.crc32 = p, this.compression = v, this.compressedContent = _;
      }
      d.prototype = { getContentWorker: function() {
        var h = new l(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), m = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== m.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new l(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, d.createWorkerFrom = function(h, m, p) {
        return h.pipe(new c()).pipe(new u("uncompressedSize")).pipe(m.compressWorker(p)).pipe(new u("compressedSize")).withStreamInfo("compression", m);
      }, r.exports = d;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(i, r, o) {
      var a = i("./stream/GenericWorker");
      o.STORE = { magic: "\0\0", compressWorker: function() {
        return new a("STORE compression");
      }, uncompressWorker: function() {
        return new a("STORE decompression");
      } }, o.DEFLATE = i("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(i, r, o) {
      var a = i("./utils"), l = function() {
        for (var c, u = [], d = 0; d < 256; d++) {
          c = d;
          for (var h = 0; h < 8; h++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
          u[d] = c;
        }
        return u;
      }();
      r.exports = function(c, u) {
        return c !== void 0 && c.length ? a.getTypeOf(c) !== "string" ? function(d, h, m, p) {
          var v = l, _ = p + m;
          d ^= -1;
          for (var g = p; g < _; g++) d = d >>> 8 ^ v[255 & (d ^ h[g])];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : function(d, h, m, p) {
          var v = l, _ = p + m;
          d ^= -1;
          for (var g = p; g < _; g++) d = d >>> 8 ^ v[255 & (d ^ h.charCodeAt(g))];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(i, r, o) {
      o.base64 = !1, o.binary = !1, o.dir = !1, o.createFolders = !0, o.date = null, o.compression = null, o.compressionOptions = null, o.comment = null, o.unixPermissions = null, o.dosPermissions = null;
    }, {}], 6: [function(i, r, o) {
      var a = null;
      a = typeof Promise < "u" ? Promise : i("lie"), r.exports = { Promise: a };
    }, { lie: 37 }], 7: [function(i, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", l = i("pako"), c = i("./utils"), u = i("./stream/GenericWorker"), d = a ? "uint8array" : "array";
      function h(m, p) {
        u.call(this, "FlateWorker/" + m), this._pako = null, this._pakoAction = m, this._pakoOptions = p, this.meta = {};
      }
      o.magic = "\b\0", c.inherits(h, u), h.prototype.processChunk = function(m) {
        this.meta = m.meta, this._pako === null && this._createPako(), this._pako.push(c.transformTo(d, m.data), !1);
      }, h.prototype.flush = function() {
        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        u.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new l[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var m = this;
        this._pako.onData = function(p) {
          m.push({ data: p, meta: m.meta });
        };
      }, o.compressWorker = function(m) {
        return new h("Deflate", m);
      }, o.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(i, r, o) {
      function a(v, _) {
        var g, x = "";
        for (g = 0; g < _; g++) x += String.fromCharCode(255 & v), v >>>= 8;
        return x;
      }
      function l(v, _, g, x, M, S) {
        var b, C, T = v.file, P = v.compression, E = S !== d.utf8encode, y = c.transformTo("string", S(T.name)), w = c.transformTo("string", d.utf8encode(T.name)), D = T.comment, U = c.transformTo("string", S(D)), R = c.transformTo("string", d.utf8encode(D)), O = w.length !== T.name.length, A = R.length !== D.length, G = "", ue = "", Q = "", le = T.dir, re = T.date, j = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        _ && !g || (j.crc32 = v.crc32, j.compressedSize = v.compressedSize, j.uncompressedSize = v.uncompressedSize);
        var $ = 0;
        _ && ($ |= 8), E || !O && !A || ($ |= 2048);
        var q = 0, oe = 0;
        le && (q |= 16), M === "UNIX" ? (oe = 798, q |= function(ce, V) {
          var Y = ce;
          return ce || (Y = V ? 16893 : 33204), (65535 & Y) << 16;
        }(T.unixPermissions, le)) : (oe = 20, q |= function(ce) {
          return 63 & (ce || 0);
        }(T.dosPermissions)), b = re.getUTCHours(), b <<= 6, b |= re.getUTCMinutes(), b <<= 5, b |= re.getUTCSeconds() / 2, C = re.getUTCFullYear() - 1980, C <<= 4, C |= re.getUTCMonth() + 1, C <<= 5, C |= re.getUTCDate(), O && (ue = a(1, 1) + a(h(y), 4) + w, G += "up" + a(ue.length, 2) + ue), A && (Q = a(1, 1) + a(h(U), 4) + R, G += "uc" + a(Q.length, 2) + Q);
        var ie = "";
        return ie += `
\0`, ie += a($, 2), ie += P.magic, ie += a(b, 2), ie += a(C, 2), ie += a(j.crc32, 4), ie += a(j.compressedSize, 4), ie += a(j.uncompressedSize, 4), ie += a(y.length, 2), ie += a(G.length, 2), { fileRecord: m.LOCAL_FILE_HEADER + ie + y + G, dirRecord: m.CENTRAL_FILE_HEADER + a(oe, 2) + ie + a(U.length, 2) + "\0\0\0\0" + a(q, 4) + a(x, 4) + y + G + U };
      }
      var c = i("../utils"), u = i("../stream/GenericWorker"), d = i("../utf8"), h = i("../crc32"), m = i("../signature");
      function p(v, _, g, x) {
        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = _, this.zipPlatform = g, this.encodeFileName = x, this.streamFiles = v, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      c.inherits(p, u), p.prototype.push = function(v) {
        var _ = v.meta.percent || 0, g = this.entriesCount, x = this._sources.length;
        this.accumulate ? this.contentBuffer.push(v) : (this.bytesWritten += v.data.length, u.prototype.push.call(this, { data: v.data, meta: { currentFile: this.currentFile, percent: g ? (_ + 100 * (g - x - 1)) / g : 100 } }));
      }, p.prototype.openedSource = function(v) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = v.file.name;
        var _ = this.streamFiles && !v.file.dir;
        if (_) {
          var g = l(v, _, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: g.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(v) {
        this.accumulate = !1;
        var _ = this.streamFiles && !v.file.dir, g = l(v, _, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), _) this.push({ data: function(x) {
          return m.DATA_DESCRIPTOR + a(x.crc32, 4) + a(x.compressedSize, 4) + a(x.uncompressedSize, 4);
        }(v), meta: { percent: 100 } });
        else for (this.push({ data: g.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var v = this.bytesWritten, _ = 0; _ < this.dirRecords.length; _++) this.push({ data: this.dirRecords[_], meta: { percent: 100 } });
        var g = this.bytesWritten - v, x = function(M, S, b, C, T) {
          var P = c.transformTo("string", T(C));
          return m.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(M, 2) + a(M, 2) + a(S, 4) + a(b, 4) + a(P.length, 2) + P;
        }(this.dirRecords.length, g, v, this.zipComment, this.encodeFileName);
        this.push({ data: x, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(v) {
        this._sources.push(v);
        var _ = this;
        return v.on("data", function(g) {
          _.processChunk(g);
        }), v.on("end", function() {
          _.closedSource(_.previous.streamInfo), _._sources.length ? _.prepareNextSource() : _.end();
        }), v.on("error", function(g) {
          _.error(g);
        }), this;
      }, p.prototype.resume = function() {
        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(v) {
        var _ = this._sources;
        if (!u.prototype.error.call(this, v)) return !1;
        for (var g = 0; g < _.length; g++) try {
          _[g].error(v);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        u.prototype.lock.call(this);
        for (var v = this._sources, _ = 0; _ < v.length; _++) v[_].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(i, r, o) {
      var a = i("../compressions"), l = i("./ZipFileWorker");
      o.generateWorker = function(c, u, d) {
        var h = new l(u.streamFiles, d, u.platform, u.encodeFileName), m = 0;
        try {
          c.forEach(function(p, v) {
            m++;
            var _ = function(S, b) {
              var C = S || b, T = a[C];
              if (!T) throw new Error(C + " is not a valid compression method !");
              return T;
            }(v.options.compression, u.compression), g = v.options.compressionOptions || u.compressionOptions || {}, x = v.dir, M = v.date;
            v._compressWorker(_, g).withStreamInfo("file", { name: p, dir: x, date: M, comment: v.comment || "", unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions }).pipe(h);
          }), h.entriesCount = m;
        } catch (p) {
          h.error(p);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(i, r, o) {
      function a() {
        if (!(this instanceof a)) return new a();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var l = new a();
          for (var c in this) typeof this[c] != "function" && (l[c] = this[c]);
          return l;
        };
      }
      (a.prototype = i("./object")).loadAsync = i("./load"), a.support = i("./support"), a.defaults = i("./defaults"), a.version = "3.10.1", a.loadAsync = function(l, c) {
        return new a().loadAsync(l, c);
      }, a.external = i("./external"), r.exports = a;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(i, r, o) {
      var a = i("./utils"), l = i("./external"), c = i("./utf8"), u = i("./zipEntries"), d = i("./stream/Crc32Probe"), h = i("./nodejsUtils");
      function m(p) {
        return new l.Promise(function(v, _) {
          var g = p.decompressed.getContentWorker().pipe(new d());
          g.on("error", function(x) {
            _(x);
          }).on("end", function() {
            g.streamInfo.crc32 !== p.decompressed.crc32 ? _(new Error("Corrupted zip : CRC32 mismatch")) : v();
          }).resume();
        });
      }
      r.exports = function(p, v) {
        var _ = this;
        return v = a.extend(v || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: c.utf8decode }), h.isNode && h.isStream(p) ? l.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", p, !0, v.optimizedBinaryString, v.base64).then(function(g) {
          var x = new u(v);
          return x.load(g), x;
        }).then(function(g) {
          var x = [l.Promise.resolve(g)], M = g.files;
          if (v.checkCRC32) for (var S = 0; S < M.length; S++) x.push(m(M[S]));
          return l.Promise.all(x);
        }).then(function(g) {
          for (var x = g.shift(), M = x.files, S = 0; S < M.length; S++) {
            var b = M[S], C = b.fileNameStr, T = a.resolve(b.fileNameStr);
            _.file(T, b.decompressed, { binary: !0, optimizedBinaryString: !0, date: b.date, dir: b.dir, comment: b.fileCommentStr.length ? b.fileCommentStr : null, unixPermissions: b.unixPermissions, dosPermissions: b.dosPermissions, createFolders: v.createFolders }), b.dir || (_.file(T).unsafeOriginalName = C);
          }
          return x.zipComment.length && (_.comment = x.zipComment), _;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(i, r, o) {
      var a = i("../utils"), l = i("../stream/GenericWorker");
      function c(u, d) {
        l.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(d);
      }
      a.inherits(c, l), c.prototype._bindStream = function(u) {
        var d = this;
        (this._stream = u).pause(), u.on("data", function(h) {
          d.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          d.isPaused ? this.generatedError = h : d.error(h);
        }).on("end", function() {
          d.isPaused ? d._upstreamEnded = !0 : d.end();
        });
      }, c.prototype.pause = function() {
        return !!l.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = c;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(i, r, o) {
      var a = i("readable-stream").Readable;
      function l(c, u, d) {
        a.call(this, u), this._helper = c;
        var h = this;
        c.on("data", function(m, p) {
          h.push(m) || h._helper.pause(), d && d(p);
        }).on("error", function(m) {
          h.emit("error", m);
        }).on("end", function() {
          h.push(null);
        });
      }
      i("../utils").inherits(l, a), l.prototype._read = function() {
        this._helper.resume();
      }, r.exports = l;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(i, r, o) {
      r.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, l) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, l);
        if (typeof a == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(a, l);
      }, allocBuffer: function(a) {
        if (Buffer.alloc) return Buffer.alloc(a);
        var l = new Buffer(a);
        return l.fill(0), l;
      }, isBuffer: function(a) {
        return Buffer.isBuffer(a);
      }, isStream: function(a) {
        return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
      } };
    }, {}], 15: [function(i, r, o) {
      function a(T, P, E) {
        var y, w = c.getTypeOf(P), D = c.extend(E || {}, h);
        D.date = D.date || /* @__PURE__ */ new Date(), D.compression !== null && (D.compression = D.compression.toUpperCase()), typeof D.unixPermissions == "string" && (D.unixPermissions = parseInt(D.unixPermissions, 8)), D.unixPermissions && 16384 & D.unixPermissions && (D.dir = !0), D.dosPermissions && 16 & D.dosPermissions && (D.dir = !0), D.dir && (T = M(T)), D.createFolders && (y = x(T)) && S.call(this, y, !0);
        var U = w === "string" && D.binary === !1 && D.base64 === !1;
        E && E.binary !== void 0 || (D.binary = !U), (P instanceof m && P.uncompressedSize === 0 || D.dir || !P || P.length === 0) && (D.base64 = !1, D.binary = !0, P = "", D.compression = "STORE", w = "string");
        var R = null;
        R = P instanceof m || P instanceof u ? P : _.isNode && _.isStream(P) ? new g(T, P) : c.prepareContent(T, P, D.binary, D.optimizedBinaryString, D.base64);
        var O = new p(T, R, D);
        this.files[T] = O;
      }
      var l = i("./utf8"), c = i("./utils"), u = i("./stream/GenericWorker"), d = i("./stream/StreamHelper"), h = i("./defaults"), m = i("./compressedObject"), p = i("./zipObject"), v = i("./generate"), _ = i("./nodejsUtils"), g = i("./nodejs/NodejsStreamInputAdapter"), x = function(T) {
        T.slice(-1) === "/" && (T = T.substring(0, T.length - 1));
        var P = T.lastIndexOf("/");
        return 0 < P ? T.substring(0, P) : "";
      }, M = function(T) {
        return T.slice(-1) !== "/" && (T += "/"), T;
      }, S = function(T, P) {
        return P = P !== void 0 ? P : h.createFolders, T = M(T), this.files[T] || a.call(this, T, null, { dir: !0, createFolders: P }), this.files[T];
      };
      function b(T) {
        return Object.prototype.toString.call(T) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(T) {
        var P, E, y;
        for (P in this.files) y = this.files[P], (E = P.slice(this.root.length, P.length)) && P.slice(0, this.root.length) === this.root && T(E, y);
      }, filter: function(T) {
        var P = [];
        return this.forEach(function(E, y) {
          T(E, y) && P.push(y);
        }), P;
      }, file: function(T, P, E) {
        if (arguments.length !== 1) return T = this.root + T, a.call(this, T, P, E), this;
        if (b(T)) {
          var y = T;
          return this.filter(function(D, U) {
            return !U.dir && y.test(D);
          });
        }
        var w = this.files[this.root + T];
        return w && !w.dir ? w : null;
      }, folder: function(T) {
        if (!T) return this;
        if (b(T)) return this.filter(function(w, D) {
          return D.dir && T.test(w);
        });
        var P = this.root + T, E = S.call(this, P), y = this.clone();
        return y.root = E.name, y;
      }, remove: function(T) {
        T = this.root + T;
        var P = this.files[T];
        if (P || (T.slice(-1) !== "/" && (T += "/"), P = this.files[T]), P && !P.dir) delete this.files[T];
        else for (var E = this.filter(function(w, D) {
          return D.name.slice(0, T.length) === T;
        }), y = 0; y < E.length; y++) delete this.files[E[y].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(T) {
        var P, E = {};
        try {
          if ((E = c.extend(T || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: l.utf8encode })).type = E.type.toLowerCase(), E.compression = E.compression.toUpperCase(), E.type === "binarystring" && (E.type = "string"), !E.type) throw new Error("No output type specified.");
          c.checkSupport(E.type), E.platform !== "darwin" && E.platform !== "freebsd" && E.platform !== "linux" && E.platform !== "sunos" || (E.platform = "UNIX"), E.platform === "win32" && (E.platform = "DOS");
          var y = E.comment || this.comment || "";
          P = v.generateWorker(this, E, y);
        } catch (w) {
          (P = new u("error")).error(w);
        }
        return new d(P, E.type || "string", E.mimeType);
      }, generateAsync: function(T, P) {
        return this.generateInternalStream(T).accumulate(P);
      }, generateNodeStream: function(T, P) {
        return (T = T || {}).type || (T.type = "nodebuffer"), this.generateInternalStream(T).toNodejsStream(P);
      } };
      r.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(i, r, o) {
      r.exports = i("stream");
    }, { stream: void 0 }], 17: [function(i, r, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
        for (var u = 0; u < this.data.length; u++) c[u] = 255 & c[u];
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data[this.zero + c];
      }, l.prototype.lastIndexOfSignature = function(c) {
        for (var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), m = c.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === u && this.data[p + 1] === d && this.data[p + 2] === h && this.data[p + 3] === m) return p - this.zero;
        return -1;
      }, l.prototype.readAndCheckSignature = function(c) {
        var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), m = c.charCodeAt(3), p = this.readData(4);
        return u === p[0] && d === p[1] && h === p[2] && m === p[3];
      }, l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(i, r, o) {
      var a = i("../utils");
      function l(c) {
        this.data = c, this.length = c.length, this.index = 0, this.zero = 0;
      }
      l.prototype = { checkOffset: function(c) {
        this.checkIndex(this.index + c);
      }, checkIndex: function(c) {
        if (this.length < this.zero + c || c < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + c + "). Corrupted zip ?");
      }, setIndex: function(c) {
        this.checkIndex(c), this.index = c;
      }, skip: function(c) {
        this.setIndex(this.index + c);
      }, byteAt: function() {
      }, readInt: function(c) {
        var u, d = 0;
        for (this.checkOffset(c), u = this.index + c - 1; u >= this.index; u--) d = (d << 8) + this.byteAt(u);
        return this.index += c, d;
      }, readString: function(c) {
        return a.transformTo("string", this.readData(c));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var c = this.readInt(4);
        return new Date(Date.UTC(1980 + (c >> 25 & 127), (c >> 21 & 15) - 1, c >> 16 & 31, c >> 11 & 31, c >> 5 & 63, (31 & c) << 1));
      } }, r.exports = l;
    }, { "../utils": 32 }], 19: [function(i, r, o) {
      var a = i("./Uint8ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(i, r, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data.charCodeAt(this.zero + c);
      }, l.prototype.lastIndexOfSignature = function(c) {
        return this.data.lastIndexOf(c) - this.zero;
      }, l.prototype.readAndCheckSignature = function(c) {
        return c === this.readData(4);
      }, l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(i, r, o) {
      var a = i("./ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(i, r, o) {
      var a = i("../utils"), l = i("../support"), c = i("./ArrayReader"), u = i("./StringReader"), d = i("./NodeBufferReader"), h = i("./Uint8ArrayReader");
      r.exports = function(m) {
        var p = a.getTypeOf(m);
        return a.checkSupport(p), p !== "string" || l.uint8array ? p === "nodebuffer" ? new d(m) : l.uint8array ? new h(a.transformTo("uint8array", m)) : new c(a.transformTo("array", m)) : new u(m);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(i, r, o) {
      o.LOCAL_FILE_HEADER = "PK", o.CENTRAL_FILE_HEADER = "PK", o.CENTRAL_DIRECTORY_END = "PK", o.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", o.ZIP64_CENTRAL_DIRECTORY_END = "PK", o.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(i, r, o) {
      var a = i("./GenericWorker"), l = i("../utils");
      function c(u) {
        a.call(this, "ConvertWorker to " + u), this.destType = u;
      }
      l.inherits(c, a), c.prototype.processChunk = function(u) {
        this.push({ data: l.transformTo(this.destType, u.data), meta: u.meta });
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(i, r, o) {
      var a = i("./GenericWorker"), l = i("../crc32");
      function c() {
        a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      i("../utils").inherits(c, a), c.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = l(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, r.exports = c;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(i, r, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
      }
      a.inherits(c, l), c.prototype.processChunk = function(u) {
        if (u) {
          var d = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = d + u.data.length;
        }
        l.prototype.processChunk.call(this, u);
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(i, r, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataWorker");
        var d = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(h) {
          d.dataIsReady = !0, d.data = h, d.max = h && h.length || 0, d.type = a.getTypeOf(h), d.isPaused || d._tickAndRepeat();
        }, function(h) {
          d.error(h);
        });
      }
      a.inherits(c, l), c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this.data = null;
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
      }, c.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, c.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var u = null, d = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            u = this.data.substring(this.index, d);
            break;
          case "uint8array":
            u = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            u = this.data.slice(this.index, d);
        }
        return this.index = d, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(i, r, o) {
      function a(l) {
        this.name = l || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      a.prototype = { push: function(l) {
        this.emit("data", l);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (l) {
          this.emit("error", l);
        }
        return !0;
      }, error: function(l) {
        return !this.isFinished && (this.isPaused ? this.generatedError = l : (this.isFinished = !0, this.emit("error", l), this.previous && this.previous.error(l), this.cleanUp()), !0);
      }, on: function(l, c) {
        return this._listeners[l].push(c), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(l, c) {
        if (this._listeners[l]) for (var u = 0; u < this._listeners[l].length; u++) this._listeners[l][u].call(this, c);
      }, pipe: function(l) {
        return l.registerPrevious(this);
      }, registerPrevious: function(l) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = l.streamInfo, this.mergeStreamInfo(), this.previous = l;
        var c = this;
        return l.on("data", function(u) {
          c.processChunk(u);
        }), l.on("end", function() {
          c.end();
        }), l.on("error", function(u) {
          c.error(u);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var l = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), l = !0), this.previous && this.previous.resume(), !l;
      }, flush: function() {
      }, processChunk: function(l) {
        this.push(l);
      }, withStreamInfo: function(l, c) {
        return this.extraStreamInfo[l] = c, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var l in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, l) && (this.streamInfo[l] = this.extraStreamInfo[l]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var l = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + l : l;
      } }, r.exports = a;
    }, {}], 29: [function(i, r, o) {
      var a = i("../utils"), l = i("./ConvertWorker"), c = i("./GenericWorker"), u = i("../base64"), d = i("../support"), h = i("../external"), m = null;
      if (d.nodestream) try {
        m = i("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(_, g) {
        return new h.Promise(function(x, M) {
          var S = [], b = _._internalType, C = _._outputType, T = _._mimeType;
          _.on("data", function(P, E) {
            S.push(P), g && g(E);
          }).on("error", function(P) {
            S = [], M(P);
          }).on("end", function() {
            try {
              var P = function(E, y, w) {
                switch (E) {
                  case "blob":
                    return a.newBlob(a.transformTo("arraybuffer", y), w);
                  case "base64":
                    return u.encode(y);
                  default:
                    return a.transformTo(E, y);
                }
              }(C, function(E, y) {
                var w, D = 0, U = null, R = 0;
                for (w = 0; w < y.length; w++) R += y[w].length;
                switch (E) {
                  case "string":
                    return y.join("");
                  case "array":
                    return Array.prototype.concat.apply([], y);
                  case "uint8array":
                    for (U = new Uint8Array(R), w = 0; w < y.length; w++) U.set(y[w], D), D += y[w].length;
                    return U;
                  case "nodebuffer":
                    return Buffer.concat(y);
                  default:
                    throw new Error("concat : unsupported type '" + E + "'");
                }
              }(b, S), T);
              x(P);
            } catch (E) {
              M(E);
            }
            S = [];
          }).resume();
        });
      }
      function v(_, g, x) {
        var M = g;
        switch (g) {
          case "blob":
          case "arraybuffer":
            M = "uint8array";
            break;
          case "base64":
            M = "string";
        }
        try {
          this._internalType = M, this._outputType = g, this._mimeType = x, a.checkSupport(M), this._worker = _.pipe(new l(M)), _.lock();
        } catch (S) {
          this._worker = new c("error"), this._worker.error(S);
        }
      }
      v.prototype = { accumulate: function(_) {
        return p(this, _);
      }, on: function(_, g) {
        var x = this;
        return _ === "data" ? this._worker.on(_, function(M) {
          g.call(x, M.data, M.meta);
        }) : this._worker.on(_, function() {
          a.delay(g, arguments, x);
        }), this;
      }, resume: function() {
        return a.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(_) {
        if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new m(this, { objectMode: this._outputType !== "nodebuffer" }, _);
      } }, r.exports = v;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(i, r, o) {
      if (o.base64 = !0, o.array = !0, o.string = !0, o.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", o.nodebuffer = typeof Buffer < "u", o.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") o.blob = !1;
      else {
        var a = new ArrayBuffer(0);
        try {
          o.blob = new Blob([a], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            l.append(a), o.blob = l.getBlob("application/zip").size === 0;
          } catch {
            o.blob = !1;
          }
        }
      }
      try {
        o.nodestream = !!i("readable-stream").Readable;
      } catch {
        o.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(i, r, o) {
      for (var a = i("./utils"), l = i("./support"), c = i("./nodejsUtils"), u = i("./stream/GenericWorker"), d = new Array(256), h = 0; h < 256; h++) d[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      d[254] = d[254] = 1;
      function m() {
        u.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        u.call(this, "utf-8 encode");
      }
      o.utf8encode = function(v) {
        return l.nodebuffer ? c.newBufferFrom(v, "utf-8") : function(_) {
          var g, x, M, S, b, C = _.length, T = 0;
          for (S = 0; S < C; S++) (64512 & (x = _.charCodeAt(S))) == 55296 && S + 1 < C && (64512 & (M = _.charCodeAt(S + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (M - 56320), S++), T += x < 128 ? 1 : x < 2048 ? 2 : x < 65536 ? 3 : 4;
          for (g = l.uint8array ? new Uint8Array(T) : new Array(T), S = b = 0; b < T; S++) (64512 & (x = _.charCodeAt(S))) == 55296 && S + 1 < C && (64512 & (M = _.charCodeAt(S + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (M - 56320), S++), x < 128 ? g[b++] = x : (x < 2048 ? g[b++] = 192 | x >>> 6 : (x < 65536 ? g[b++] = 224 | x >>> 12 : (g[b++] = 240 | x >>> 18, g[b++] = 128 | x >>> 12 & 63), g[b++] = 128 | x >>> 6 & 63), g[b++] = 128 | 63 & x);
          return g;
        }(v);
      }, o.utf8decode = function(v) {
        return l.nodebuffer ? a.transformTo("nodebuffer", v).toString("utf-8") : function(_) {
          var g, x, M, S, b = _.length, C = new Array(2 * b);
          for (g = x = 0; g < b; ) if ((M = _[g++]) < 128) C[x++] = M;
          else if (4 < (S = d[M])) C[x++] = 65533, g += S - 1;
          else {
            for (M &= S === 2 ? 31 : S === 3 ? 15 : 7; 1 < S && g < b; ) M = M << 6 | 63 & _[g++], S--;
            1 < S ? C[x++] = 65533 : M < 65536 ? C[x++] = M : (M -= 65536, C[x++] = 55296 | M >> 10 & 1023, C[x++] = 56320 | 1023 & M);
          }
          return C.length !== x && (C.subarray ? C = C.subarray(0, x) : C.length = x), a.applyFromCharCode(C);
        }(v = a.transformTo(l.uint8array ? "uint8array" : "array", v));
      }, a.inherits(m, u), m.prototype.processChunk = function(v) {
        var _ = a.transformTo(l.uint8array ? "uint8array" : "array", v.data);
        if (this.leftOver && this.leftOver.length) {
          if (l.uint8array) {
            var g = _;
            (_ = new Uint8Array(g.length + this.leftOver.length)).set(this.leftOver, 0), _.set(g, this.leftOver.length);
          } else _ = this.leftOver.concat(_);
          this.leftOver = null;
        }
        var x = function(S, b) {
          var C;
          for ((b = b || S.length) > S.length && (b = S.length), C = b - 1; 0 <= C && (192 & S[C]) == 128; ) C--;
          return C < 0 || C === 0 ? b : C + d[S[C]] > b ? C : b;
        }(_), M = _;
        x !== _.length && (l.uint8array ? (M = _.subarray(0, x), this.leftOver = _.subarray(x, _.length)) : (M = _.slice(0, x), this.leftOver = _.slice(x, _.length))), this.push({ data: o.utf8decode(M), meta: v.meta });
      }, m.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: o.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, o.Utf8DecodeWorker = m, a.inherits(p, u), p.prototype.processChunk = function(v) {
        this.push({ data: o.utf8encode(v.data), meta: v.meta });
      }, o.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(i, r, o) {
      var a = i("./support"), l = i("./base64"), c = i("./nodejsUtils"), u = i("./external");
      function d(g) {
        return g;
      }
      function h(g, x) {
        for (var M = 0; M < g.length; ++M) x[M] = 255 & g.charCodeAt(M);
        return x;
      }
      i("setimmediate"), o.newBlob = function(g, x) {
        o.checkSupport("blob");
        try {
          return new Blob([g], { type: x });
        } catch {
          try {
            var M = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return M.append(g), M.getBlob(x);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var m = { stringifyByChunk: function(g, x, M) {
        var S = [], b = 0, C = g.length;
        if (C <= M) return String.fromCharCode.apply(null, g);
        for (; b < C; ) x === "array" || x === "nodebuffer" ? S.push(String.fromCharCode.apply(null, g.slice(b, Math.min(b + M, C)))) : S.push(String.fromCharCode.apply(null, g.subarray(b, Math.min(b + M, C)))), b += M;
        return S.join("");
      }, stringifyByChar: function(g) {
        for (var x = "", M = 0; M < g.length; M++) x += String.fromCharCode(g[M]);
        return x;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return a.nodebuffer && String.fromCharCode.apply(null, c.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(g) {
        var x = 65536, M = o.getTypeOf(g), S = !0;
        if (M === "uint8array" ? S = m.applyCanBeUsed.uint8array : M === "nodebuffer" && (S = m.applyCanBeUsed.nodebuffer), S) for (; 1 < x; ) try {
          return m.stringifyByChunk(g, M, x);
        } catch {
          x = Math.floor(x / 2);
        }
        return m.stringifyByChar(g);
      }
      function v(g, x) {
        for (var M = 0; M < g.length; M++) x[M] = g[M];
        return x;
      }
      o.applyFromCharCode = p;
      var _ = {};
      _.string = { string: d, array: function(g) {
        return h(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return _.string.uint8array(g).buffer;
      }, uint8array: function(g) {
        return h(g, new Uint8Array(g.length));
      }, nodebuffer: function(g) {
        return h(g, c.allocBuffer(g.length));
      } }, _.array = { string: p, array: d, arraybuffer: function(g) {
        return new Uint8Array(g).buffer;
      }, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, _.arraybuffer = { string: function(g) {
        return p(new Uint8Array(g));
      }, array: function(g) {
        return v(new Uint8Array(g), new Array(g.byteLength));
      }, arraybuffer: d, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(new Uint8Array(g));
      } }, _.uint8array = { string: p, array: function(g) {
        return v(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return g.buffer;
      }, uint8array: d, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, _.nodebuffer = { string: p, array: function(g) {
        return v(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return _.nodebuffer.uint8array(g).buffer;
      }, uint8array: function(g) {
        return v(g, new Uint8Array(g.length));
      }, nodebuffer: d }, o.transformTo = function(g, x) {
        if (x = x || "", !g) return x;
        o.checkSupport(g);
        var M = o.getTypeOf(x);
        return _[M][g](x);
      }, o.resolve = function(g) {
        for (var x = g.split("/"), M = [], S = 0; S < x.length; S++) {
          var b = x[S];
          b === "." || b === "" && S !== 0 && S !== x.length - 1 || (b === ".." ? M.pop() : M.push(b));
        }
        return M.join("/");
      }, o.getTypeOf = function(g) {
        return typeof g == "string" ? "string" : Object.prototype.toString.call(g) === "[object Array]" ? "array" : a.nodebuffer && c.isBuffer(g) ? "nodebuffer" : a.uint8array && g instanceof Uint8Array ? "uint8array" : a.arraybuffer && g instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, o.checkSupport = function(g) {
        if (!a[g.toLowerCase()]) throw new Error(g + " is not supported by this platform");
      }, o.MAX_VALUE_16BITS = 65535, o.MAX_VALUE_32BITS = -1, o.pretty = function(g) {
        var x, M, S = "";
        for (M = 0; M < (g || "").length; M++) S += "\\x" + ((x = g.charCodeAt(M)) < 16 ? "0" : "") + x.toString(16).toUpperCase();
        return S;
      }, o.delay = function(g, x, M) {
        setImmediate(function() {
          g.apply(M || null, x || []);
        });
      }, o.inherits = function(g, x) {
        function M() {
        }
        M.prototype = x.prototype, g.prototype = new M();
      }, o.extend = function() {
        var g, x, M = {};
        for (g = 0; g < arguments.length; g++) for (x in arguments[g]) Object.prototype.hasOwnProperty.call(arguments[g], x) && M[x] === void 0 && (M[x] = arguments[g][x]);
        return M;
      }, o.prepareContent = function(g, x, M, S, b) {
        return u.Promise.resolve(x).then(function(C) {
          return a.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(T, P) {
            var E = new FileReader();
            E.onload = function(y) {
              T(y.target.result);
            }, E.onerror = function(y) {
              P(y.target.error);
            }, E.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var T = o.getTypeOf(C);
          return T ? (T === "arraybuffer" ? C = o.transformTo("uint8array", C) : T === "string" && (b ? C = l.decode(C) : M && S !== !0 && (C = function(P) {
            return h(P, a.uint8array ? new Uint8Array(P.length) : new Array(P.length));
          }(C))), C) : u.Promise.reject(new Error("Can't read the data of '" + g + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(i, r, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./signature"), u = i("./zipEntry"), d = i("./support");
      function h(m) {
        this.files = [], this.loadOptions = m;
      }
      h.prototype = { checkSignature: function(m) {
        if (!this.reader.readAndCheckSignature(m)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + l.pretty(p) + ", expected " + l.pretty(m) + ")");
        }
      }, isSignature: function(m, p) {
        var v = this.reader.index;
        this.reader.setIndex(m);
        var _ = this.reader.readString(4) === p;
        return this.reader.setIndex(v), _;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var m = this.reader.readData(this.zipCommentLength), p = d.uint8array ? "uint8array" : "array", v = l.transformTo(p, m);
        this.zipComment = this.loadOptions.decodeFileName(v);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var m, p, v, _ = this.zip64EndOfCentralSize - 44; 0 < _; ) m = this.reader.readInt(2), p = this.reader.readInt(4), v = this.reader.readData(p), this.zip64ExtensibleData[m] = { id: m, length: p, value: v };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var m, p;
        for (m = 0; m < this.files.length; m++) p = this.files[m], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(c.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var m;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(c.CENTRAL_FILE_HEADER); ) (m = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(m);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var m = this.reader.lastIndexOfSignature(c.CENTRAL_DIRECTORY_END);
        if (m < 0) throw this.isSignature(0, c.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(m);
        var p = m;
        if (this.checkSignature(c.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === l.MAX_VALUE_16BITS || this.diskWithCentralDirStart === l.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === l.MAX_VALUE_16BITS || this.centralDirRecords === l.MAX_VALUE_16BITS || this.centralDirSize === l.MAX_VALUE_32BITS || this.centralDirOffset === l.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (m = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(m), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, c.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var v = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (v += 20, v += 12 + this.zip64EndOfCentralSize);
        var _ = p - v;
        if (0 < _) this.isSignature(p, c.CENTRAL_FILE_HEADER) || (this.reader.zero = _);
        else if (_ < 0) throw new Error("Corrupted zip: missing " + Math.abs(_) + " bytes.");
      }, prepareReader: function(m) {
        this.reader = a(m);
      }, load: function(m) {
        this.prepareReader(m), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(i, r, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./compressedObject"), u = i("./crc32"), d = i("./utf8"), h = i("./compressions"), m = i("./support");
      function p(v, _) {
        this.options = v, this.loadOptions = _;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(v) {
        var _, g;
        if (v.skip(22), this.fileNameLength = v.readInt(2), g = v.readInt(2), this.fileName = v.readData(this.fileNameLength), v.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((_ = function(x) {
          for (var M in h) if (Object.prototype.hasOwnProperty.call(h, M) && h[M].magic === x) return h[M];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + l.pretty(this.compressionMethod) + " unknown (inner file : " + l.transformTo("string", this.fileName) + ")");
        this.decompressed = new c(this.compressedSize, this.uncompressedSize, this.crc32, _, v.readData(this.compressedSize));
      }, readCentralPart: function(v) {
        this.versionMadeBy = v.readInt(2), v.skip(2), this.bitFlag = v.readInt(2), this.compressionMethod = v.readString(2), this.date = v.readDate(), this.crc32 = v.readInt(4), this.compressedSize = v.readInt(4), this.uncompressedSize = v.readInt(4);
        var _ = v.readInt(2);
        if (this.extraFieldsLength = v.readInt(2), this.fileCommentLength = v.readInt(2), this.diskNumberStart = v.readInt(2), this.internalFileAttributes = v.readInt(2), this.externalFileAttributes = v.readInt(4), this.localHeaderOffset = v.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        v.skip(_), this.readExtraFields(v), this.parseZIP64ExtraField(v), this.fileComment = v.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var v = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), v == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), v == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var v = a(this.extraFields[1].value);
          this.uncompressedSize === l.MAX_VALUE_32BITS && (this.uncompressedSize = v.readInt(8)), this.compressedSize === l.MAX_VALUE_32BITS && (this.compressedSize = v.readInt(8)), this.localHeaderOffset === l.MAX_VALUE_32BITS && (this.localHeaderOffset = v.readInt(8)), this.diskNumberStart === l.MAX_VALUE_32BITS && (this.diskNumberStart = v.readInt(4));
        }
      }, readExtraFields: function(v) {
        var _, g, x, M = v.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); v.index + 4 < M; ) _ = v.readInt(2), g = v.readInt(2), x = v.readData(g), this.extraFields[_] = { id: _, length: g, value: x };
        v.setIndex(M);
      }, handleUTF8: function() {
        var v = m.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = d.utf8decode(this.fileName), this.fileCommentStr = d.utf8decode(this.fileComment);
        else {
          var _ = this.findExtraFieldUnicodePath();
          if (_ !== null) this.fileNameStr = _;
          else {
            var g = l.transformTo(v, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(g);
          }
          var x = this.findExtraFieldUnicodeComment();
          if (x !== null) this.fileCommentStr = x;
          else {
            var M = l.transformTo(v, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(M);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var v = this.extraFields[28789];
        if (v) {
          var _ = a(v.value);
          return _.readInt(1) !== 1 || u(this.fileName) !== _.readInt(4) ? null : d.utf8decode(_.readData(v.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var v = this.extraFields[25461];
        if (v) {
          var _ = a(v.value);
          return _.readInt(1) !== 1 || u(this.fileComment) !== _.readInt(4) ? null : d.utf8decode(_.readData(v.length - 5));
        }
        return null;
      } }, r.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(i, r, o) {
      function a(_, g, x) {
        this.name = _, this.dir = x.dir, this.date = x.date, this.comment = x.comment, this.unixPermissions = x.unixPermissions, this.dosPermissions = x.dosPermissions, this._data = g, this._dataBinary = x.binary, this.options = { compression: x.compression, compressionOptions: x.compressionOptions };
      }
      var l = i("./stream/StreamHelper"), c = i("./stream/DataWorker"), u = i("./utf8"), d = i("./compressedObject"), h = i("./stream/GenericWorker");
      a.prototype = { internalStream: function(_) {
        var g = null, x = "string";
        try {
          if (!_) throw new Error("No output type specified.");
          var M = (x = _.toLowerCase()) === "string" || x === "text";
          x !== "binarystring" && x !== "text" || (x = "string"), g = this._decompressWorker();
          var S = !this._dataBinary;
          S && !M && (g = g.pipe(new u.Utf8EncodeWorker())), !S && M && (g = g.pipe(new u.Utf8DecodeWorker()));
        } catch (b) {
          (g = new h("error")).error(b);
        }
        return new l(g, x, "");
      }, async: function(_, g) {
        return this.internalStream(_).accumulate(g);
      }, nodeStream: function(_, g) {
        return this.internalStream(_ || "nodebuffer").toNodejsStream(g);
      }, _compressWorker: function(_, g) {
        if (this._data instanceof d && this._data.compression.magic === _.magic) return this._data.getCompressedWorker();
        var x = this._decompressWorker();
        return this._dataBinary || (x = x.pipe(new u.Utf8EncodeWorker())), d.createWorkerFrom(x, _, g);
      }, _decompressWorker: function() {
        return this._data instanceof d ? this._data.getContentWorker() : this._data instanceof h ? this._data : new c(this._data);
      } };
      for (var m = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, v = 0; v < m.length; v++) a.prototype[m[v]] = p;
      r.exports = a;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(i, r, o) {
      (function(a) {
        var l, c, u = a.MutationObserver || a.WebKitMutationObserver;
        if (u) {
          var d = 0, h = new u(_), m = a.document.createTextNode("");
          h.observe(m, { characterData: !0 }), l = function() {
            m.data = d = ++d % 2;
          };
        } else if (a.setImmediate || a.MessageChannel === void 0) l = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
          var g = a.document.createElement("script");
          g.onreadystatechange = function() {
            _(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
          }, a.document.documentElement.appendChild(g);
        } : function() {
          setTimeout(_, 0);
        };
        else {
          var p = new a.MessageChannel();
          p.port1.onmessage = _, l = function() {
            p.port2.postMessage(0);
          };
        }
        var v = [];
        function _() {
          var g, x;
          c = !0;
          for (var M = v.length; M; ) {
            for (x = v, v = [], g = -1; ++g < M; ) x[g]();
            M = v.length;
          }
          c = !1;
        }
        r.exports = function(g) {
          v.push(g) !== 1 || c || l();
        };
      }).call(this, typeof Ec < "u" ? Ec : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(i, r, o) {
      var a = i("immediate");
      function l() {
      }
      var c = {}, u = ["REJECTED"], d = ["FULFILLED"], h = ["PENDING"];
      function m(M) {
        if (typeof M != "function") throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, M !== l && g(this, M);
      }
      function p(M, S, b) {
        this.promise = M, typeof S == "function" && (this.onFulfilled = S, this.callFulfilled = this.otherCallFulfilled), typeof b == "function" && (this.onRejected = b, this.callRejected = this.otherCallRejected);
      }
      function v(M, S, b) {
        a(function() {
          var C;
          try {
            C = S(b);
          } catch (T) {
            return c.reject(M, T);
          }
          C === M ? c.reject(M, new TypeError("Cannot resolve promise with itself")) : c.resolve(M, C);
        });
      }
      function _(M) {
        var S = M && M.then;
        if (M && (typeof M == "object" || typeof M == "function") && typeof S == "function") return function() {
          S.apply(M, arguments);
        };
      }
      function g(M, S) {
        var b = !1;
        function C(E) {
          b || (b = !0, c.reject(M, E));
        }
        function T(E) {
          b || (b = !0, c.resolve(M, E));
        }
        var P = x(function() {
          S(T, C);
        });
        P.status === "error" && C(P.value);
      }
      function x(M, S) {
        var b = {};
        try {
          b.value = M(S), b.status = "success";
        } catch (C) {
          b.status = "error", b.value = C;
        }
        return b;
      }
      (r.exports = m).prototype.finally = function(M) {
        if (typeof M != "function") return this;
        var S = this.constructor;
        return this.then(function(b) {
          return S.resolve(M()).then(function() {
            return b;
          });
        }, function(b) {
          return S.resolve(M()).then(function() {
            throw b;
          });
        });
      }, m.prototype.catch = function(M) {
        return this.then(null, M);
      }, m.prototype.then = function(M, S) {
        if (typeof M != "function" && this.state === d || typeof S != "function" && this.state === u) return this;
        var b = new this.constructor(l);
        return this.state !== h ? v(b, this.state === d ? M : S, this.outcome) : this.queue.push(new p(b, M, S)), b;
      }, p.prototype.callFulfilled = function(M) {
        c.resolve(this.promise, M);
      }, p.prototype.otherCallFulfilled = function(M) {
        v(this.promise, this.onFulfilled, M);
      }, p.prototype.callRejected = function(M) {
        c.reject(this.promise, M);
      }, p.prototype.otherCallRejected = function(M) {
        v(this.promise, this.onRejected, M);
      }, c.resolve = function(M, S) {
        var b = x(_, S);
        if (b.status === "error") return c.reject(M, b.value);
        var C = b.value;
        if (C) g(M, C);
        else {
          M.state = d, M.outcome = S;
          for (var T = -1, P = M.queue.length; ++T < P; ) M.queue[T].callFulfilled(S);
        }
        return M;
      }, c.reject = function(M, S) {
        M.state = u, M.outcome = S;
        for (var b = -1, C = M.queue.length; ++b < C; ) M.queue[b].callRejected(S);
        return M;
      }, m.resolve = function(M) {
        return M instanceof this ? M : c.resolve(new this(l), M);
      }, m.reject = function(M) {
        var S = new this(l);
        return c.reject(S, M);
      }, m.all = function(M) {
        var S = this;
        if (Object.prototype.toString.call(M) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var b = M.length, C = !1;
        if (!b) return this.resolve([]);
        for (var T = new Array(b), P = 0, E = -1, y = new this(l); ++E < b; ) w(M[E], E);
        return y;
        function w(D, U) {
          S.resolve(D).then(function(R) {
            T[U] = R, ++P !== b || C || (C = !0, c.resolve(y, T));
          }, function(R) {
            C || (C = !0, c.reject(y, R));
          });
        }
      }, m.race = function(M) {
        var S = this;
        if (Object.prototype.toString.call(M) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var b = M.length, C = !1;
        if (!b) return this.resolve([]);
        for (var T = -1, P = new this(l); ++T < b; ) E = M[T], S.resolve(E).then(function(y) {
          C || (C = !0, c.resolve(P, y));
        }, function(y) {
          C || (C = !0, c.reject(P, y));
        });
        var E;
        return P;
      };
    }, { immediate: 36 }], 38: [function(i, r, o) {
      var a = {};
      (0, i("./lib/utils/common").assign)(a, i("./lib/deflate"), i("./lib/inflate"), i("./lib/zlib/constants")), r.exports = a;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(i, r, o) {
      var a = i("./zlib/deflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/messages"), d = i("./zlib/zstream"), h = Object.prototype.toString, m = 0, p = -1, v = 0, _ = 8;
      function g(M) {
        if (!(this instanceof g)) return new g(M);
        this.options = l.assign({ level: p, method: _, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: v, to: "" }, M || {});
        var S = this.options;
        S.raw && 0 < S.windowBits ? S.windowBits = -S.windowBits : S.gzip && 0 < S.windowBits && S.windowBits < 16 && (S.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var b = a.deflateInit2(this.strm, S.level, S.method, S.windowBits, S.memLevel, S.strategy);
        if (b !== m) throw new Error(u[b]);
        if (S.header && a.deflateSetHeader(this.strm, S.header), S.dictionary) {
          var C;
          if (C = typeof S.dictionary == "string" ? c.string2buf(S.dictionary) : h.call(S.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(S.dictionary) : S.dictionary, (b = a.deflateSetDictionary(this.strm, C)) !== m) throw new Error(u[b]);
          this._dict_set = !0;
        }
      }
      function x(M, S) {
        var b = new g(S);
        if (b.push(M, !0), b.err) throw b.msg || u[b.err];
        return b.result;
      }
      g.prototype.push = function(M, S) {
        var b, C, T = this.strm, P = this.options.chunkSize;
        if (this.ended) return !1;
        C = S === ~~S ? S : S === !0 ? 4 : 0, typeof M == "string" ? T.input = c.string2buf(M) : h.call(M) === "[object ArrayBuffer]" ? T.input = new Uint8Array(M) : T.input = M, T.next_in = 0, T.avail_in = T.input.length;
        do {
          if (T.avail_out === 0 && (T.output = new l.Buf8(P), T.next_out = 0, T.avail_out = P), (b = a.deflate(T, C)) !== 1 && b !== m) return this.onEnd(b), !(this.ended = !0);
          T.avail_out !== 0 && (T.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(c.buf2binstring(l.shrinkBuf(T.output, T.next_out))) : this.onData(l.shrinkBuf(T.output, T.next_out)));
        } while ((0 < T.avail_in || T.avail_out === 0) && b !== 1);
        return C === 4 ? (b = a.deflateEnd(this.strm), this.onEnd(b), this.ended = !0, b === m) : C !== 2 || (this.onEnd(m), !(T.avail_out = 0));
      }, g.prototype.onData = function(M) {
        this.chunks.push(M);
      }, g.prototype.onEnd = function(M) {
        M === m && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = M, this.msg = this.strm.msg;
      }, o.Deflate = g, o.deflate = x, o.deflateRaw = function(M, S) {
        return (S = S || {}).raw = !0, x(M, S);
      }, o.gzip = function(M, S) {
        return (S = S || {}).gzip = !0, x(M, S);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(i, r, o) {
      var a = i("./zlib/inflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/constants"), d = i("./zlib/messages"), h = i("./zlib/zstream"), m = i("./zlib/gzheader"), p = Object.prototype.toString;
      function v(g) {
        if (!(this instanceof v)) return new v(g);
        this.options = l.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
        var x = this.options;
        x.raw && 0 <= x.windowBits && x.windowBits < 16 && (x.windowBits = -x.windowBits, x.windowBits === 0 && (x.windowBits = -15)), !(0 <= x.windowBits && x.windowBits < 16) || g && g.windowBits || (x.windowBits += 32), 15 < x.windowBits && x.windowBits < 48 && !(15 & x.windowBits) && (x.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var M = a.inflateInit2(this.strm, x.windowBits);
        if (M !== u.Z_OK) throw new Error(d[M]);
        this.header = new m(), a.inflateGetHeader(this.strm, this.header);
      }
      function _(g, x) {
        var M = new v(x);
        if (M.push(g, !0), M.err) throw M.msg || d[M.err];
        return M.result;
      }
      v.prototype.push = function(g, x) {
        var M, S, b, C, T, P, E = this.strm, y = this.options.chunkSize, w = this.options.dictionary, D = !1;
        if (this.ended) return !1;
        S = x === ~~x ? x : x === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof g == "string" ? E.input = c.binstring2buf(g) : p.call(g) === "[object ArrayBuffer]" ? E.input = new Uint8Array(g) : E.input = g, E.next_in = 0, E.avail_in = E.input.length;
        do {
          if (E.avail_out === 0 && (E.output = new l.Buf8(y), E.next_out = 0, E.avail_out = y), (M = a.inflate(E, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && w && (P = typeof w == "string" ? c.string2buf(w) : p.call(w) === "[object ArrayBuffer]" ? new Uint8Array(w) : w, M = a.inflateSetDictionary(this.strm, P)), M === u.Z_BUF_ERROR && D === !0 && (M = u.Z_OK, D = !1), M !== u.Z_STREAM_END && M !== u.Z_OK) return this.onEnd(M), !(this.ended = !0);
          E.next_out && (E.avail_out !== 0 && M !== u.Z_STREAM_END && (E.avail_in !== 0 || S !== u.Z_FINISH && S !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (b = c.utf8border(E.output, E.next_out), C = E.next_out - b, T = c.buf2string(E.output, b), E.next_out = C, E.avail_out = y - C, C && l.arraySet(E.output, E.output, b, C, 0), this.onData(T)) : this.onData(l.shrinkBuf(E.output, E.next_out)))), E.avail_in === 0 && E.avail_out === 0 && (D = !0);
        } while ((0 < E.avail_in || E.avail_out === 0) && M !== u.Z_STREAM_END);
        return M === u.Z_STREAM_END && (S = u.Z_FINISH), S === u.Z_FINISH ? (M = a.inflateEnd(this.strm), this.onEnd(M), this.ended = !0, M === u.Z_OK) : S !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(E.avail_out = 0));
      }, v.prototype.onData = function(g) {
        this.chunks.push(g);
      }, v.prototype.onEnd = function(g) {
        g === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, o.Inflate = v, o.inflate = _, o.inflateRaw = function(g, x) {
        return (x = x || {}).raw = !0, _(g, x);
      }, o.ungzip = _;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(i, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      o.assign = function(u) {
        for (var d = Array.prototype.slice.call(arguments, 1); d.length; ) {
          var h = d.shift();
          if (h) {
            if (typeof h != "object") throw new TypeError(h + "must be non-object");
            for (var m in h) h.hasOwnProperty(m) && (u[m] = h[m]);
          }
        }
        return u;
      }, o.shrinkBuf = function(u, d) {
        return u.length === d ? u : u.subarray ? u.subarray(0, d) : (u.length = d, u);
      };
      var l = { arraySet: function(u, d, h, m, p) {
        if (d.subarray && u.subarray) u.set(d.subarray(h, h + m), p);
        else for (var v = 0; v < m; v++) u[p + v] = d[h + v];
      }, flattenChunks: function(u) {
        var d, h, m, p, v, _;
        for (d = m = 0, h = u.length; d < h; d++) m += u[d].length;
        for (_ = new Uint8Array(m), d = p = 0, h = u.length; d < h; d++) v = u[d], _.set(v, p), p += v.length;
        return _;
      } }, c = { arraySet: function(u, d, h, m, p) {
        for (var v = 0; v < m; v++) u[p + v] = d[h + v];
      }, flattenChunks: function(u) {
        return [].concat.apply([], u);
      } };
      o.setTyped = function(u) {
        u ? (o.Buf8 = Uint8Array, o.Buf16 = Uint16Array, o.Buf32 = Int32Array, o.assign(o, l)) : (o.Buf8 = Array, o.Buf16 = Array, o.Buf32 = Array, o.assign(o, c));
      }, o.setTyped(a);
    }, {}], 42: [function(i, r, o) {
      var a = i("./common"), l = !0, c = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        l = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        c = !1;
      }
      for (var u = new a.Buf8(256), d = 0; d < 256; d++) u[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      function h(m, p) {
        if (p < 65537 && (m.subarray && c || !m.subarray && l)) return String.fromCharCode.apply(null, a.shrinkBuf(m, p));
        for (var v = "", _ = 0; _ < p; _++) v += String.fromCharCode(m[_]);
        return v;
      }
      u[254] = u[254] = 1, o.string2buf = function(m) {
        var p, v, _, g, x, M = m.length, S = 0;
        for (g = 0; g < M; g++) (64512 & (v = m.charCodeAt(g))) == 55296 && g + 1 < M && (64512 & (_ = m.charCodeAt(g + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (_ - 56320), g++), S += v < 128 ? 1 : v < 2048 ? 2 : v < 65536 ? 3 : 4;
        for (p = new a.Buf8(S), g = x = 0; x < S; g++) (64512 & (v = m.charCodeAt(g))) == 55296 && g + 1 < M && (64512 & (_ = m.charCodeAt(g + 1))) == 56320 && (v = 65536 + (v - 55296 << 10) + (_ - 56320), g++), v < 128 ? p[x++] = v : (v < 2048 ? p[x++] = 192 | v >>> 6 : (v < 65536 ? p[x++] = 224 | v >>> 12 : (p[x++] = 240 | v >>> 18, p[x++] = 128 | v >>> 12 & 63), p[x++] = 128 | v >>> 6 & 63), p[x++] = 128 | 63 & v);
        return p;
      }, o.buf2binstring = function(m) {
        return h(m, m.length);
      }, o.binstring2buf = function(m) {
        for (var p = new a.Buf8(m.length), v = 0, _ = p.length; v < _; v++) p[v] = m.charCodeAt(v);
        return p;
      }, o.buf2string = function(m, p) {
        var v, _, g, x, M = p || m.length, S = new Array(2 * M);
        for (v = _ = 0; v < M; ) if ((g = m[v++]) < 128) S[_++] = g;
        else if (4 < (x = u[g])) S[_++] = 65533, v += x - 1;
        else {
          for (g &= x === 2 ? 31 : x === 3 ? 15 : 7; 1 < x && v < M; ) g = g << 6 | 63 & m[v++], x--;
          1 < x ? S[_++] = 65533 : g < 65536 ? S[_++] = g : (g -= 65536, S[_++] = 55296 | g >> 10 & 1023, S[_++] = 56320 | 1023 & g);
        }
        return h(S, _);
      }, o.utf8border = function(m, p) {
        var v;
        for ((p = p || m.length) > m.length && (p = m.length), v = p - 1; 0 <= v && (192 & m[v]) == 128; ) v--;
        return v < 0 || v === 0 ? p : v + u[m[v]] > p ? v : p;
      };
    }, { "./common": 41 }], 43: [function(i, r, o) {
      r.exports = function(a, l, c, u) {
        for (var d = 65535 & a | 0, h = a >>> 16 & 65535 | 0, m = 0; c !== 0; ) {
          for (c -= m = 2e3 < c ? 2e3 : c; h = h + (d = d + l[u++] | 0) | 0, --m; ) ;
          d %= 65521, h %= 65521;
        }
        return d | h << 16 | 0;
      };
    }, {}], 44: [function(i, r, o) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(i, r, o) {
      var a = function() {
        for (var l, c = [], u = 0; u < 256; u++) {
          l = u;
          for (var d = 0; d < 8; d++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          c[u] = l;
        }
        return c;
      }();
      r.exports = function(l, c, u, d) {
        var h = a, m = d + u;
        l ^= -1;
        for (var p = d; p < m; p++) l = l >>> 8 ^ h[255 & (l ^ c[p])];
        return -1 ^ l;
      };
    }, {}], 46: [function(i, r, o) {
      var a, l = i("../utils/common"), c = i("./trees"), u = i("./adler32"), d = i("./crc32"), h = i("./messages"), m = 0, p = 4, v = 0, _ = -2, g = -1, x = 4, M = 2, S = 8, b = 9, C = 286, T = 30, P = 19, E = 2 * C + 1, y = 15, w = 3, D = 258, U = D + w + 1, R = 42, O = 113, A = 1, G = 2, ue = 3, Q = 4;
      function le(k, ne) {
        return k.msg = h[ne], ne;
      }
      function re(k) {
        return (k << 1) - (4 < k ? 9 : 0);
      }
      function j(k) {
        for (var ne = k.length; 0 <= --ne; ) k[ne] = 0;
      }
      function $(k) {
        var ne = k.state, J = ne.pending;
        J > k.avail_out && (J = k.avail_out), J !== 0 && (l.arraySet(k.output, ne.pending_buf, ne.pending_out, J, k.next_out), k.next_out += J, ne.pending_out += J, k.total_out += J, k.avail_out -= J, ne.pending -= J, ne.pending === 0 && (ne.pending_out = 0));
      }
      function q(k, ne) {
        c._tr_flush_block(k, 0 <= k.block_start ? k.block_start : -1, k.strstart - k.block_start, ne), k.block_start = k.strstart, $(k.strm);
      }
      function oe(k, ne) {
        k.pending_buf[k.pending++] = ne;
      }
      function ie(k, ne) {
        k.pending_buf[k.pending++] = ne >>> 8 & 255, k.pending_buf[k.pending++] = 255 & ne;
      }
      function ce(k, ne) {
        var J, B, X = k.max_chain_length, se = k.strstart, z = k.prev_length, N = k.nice_match, K = k.strstart > k.w_size - U ? k.strstart - (k.w_size - U) : 0, he = k.window, me = k.w_mask, ge = k.prev, Me = k.strstart + D, Ee = he[se + z - 1], Ae = he[se + z];
        k.prev_length >= k.good_match && (X >>= 2), N > k.lookahead && (N = k.lookahead);
        do
          if (he[(J = ne) + z] === Ae && he[J + z - 1] === Ee && he[J] === he[se] && he[++J] === he[se + 1]) {
            se += 2, J++;
            do
              ;
            while (he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && he[++se] === he[++J] && se < Me);
            if (B = D - (Me - se), se = Me - D, z < B) {
              if (k.match_start = ne, N <= (z = B)) break;
              Ee = he[se + z - 1], Ae = he[se + z];
            }
          }
        while ((ne = ge[ne & me]) > K && --X != 0);
        return z <= k.lookahead ? z : k.lookahead;
      }
      function V(k) {
        var ne, J, B, X, se, z, N, K, he, me, ge = k.w_size;
        do {
          if (X = k.window_size - k.lookahead - k.strstart, k.strstart >= ge + (ge - U)) {
            for (l.arraySet(k.window, k.window, ge, ge, 0), k.match_start -= ge, k.strstart -= ge, k.block_start -= ge, ne = J = k.hash_size; B = k.head[--ne], k.head[ne] = ge <= B ? B - ge : 0, --J; ) ;
            for (ne = J = ge; B = k.prev[--ne], k.prev[ne] = ge <= B ? B - ge : 0, --J; ) ;
            X += ge;
          }
          if (k.strm.avail_in === 0) break;
          if (z = k.strm, N = k.window, K = k.strstart + k.lookahead, he = X, me = void 0, me = z.avail_in, he < me && (me = he), J = me === 0 ? 0 : (z.avail_in -= me, l.arraySet(N, z.input, z.next_in, me, K), z.state.wrap === 1 ? z.adler = u(z.adler, N, me, K) : z.state.wrap === 2 && (z.adler = d(z.adler, N, me, K)), z.next_in += me, z.total_in += me, me), k.lookahead += J, k.lookahead + k.insert >= w) for (se = k.strstart - k.insert, k.ins_h = k.window[se], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[se + 1]) & k.hash_mask; k.insert && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[se + w - 1]) & k.hash_mask, k.prev[se & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = se, se++, k.insert--, !(k.lookahead + k.insert < w)); ) ;
        } while (k.lookahead < U && k.strm.avail_in !== 0);
      }
      function Y(k, ne) {
        for (var J, B; ; ) {
          if (k.lookahead < U) {
            if (V(k), k.lookahead < U && ne === m) return A;
            if (k.lookahead === 0) break;
          }
          if (J = 0, k.lookahead >= w && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), J !== 0 && k.strstart - J <= k.w_size - U && (k.match_length = ce(k, J)), k.match_length >= w) if (B = c._tr_tally(k, k.strstart - k.match_start, k.match_length - w), k.lookahead -= k.match_length, k.match_length <= k.max_lazy_match && k.lookahead >= w) {
            for (k.match_length--; k.strstart++, k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart, --k.match_length != 0; ) ;
            k.strstart++;
          } else k.strstart += k.match_length, k.match_length = 0, k.ins_h = k.window[k.strstart], k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + 1]) & k.hash_mask;
          else B = c._tr_tally(k, 0, k.window[k.strstart]), k.lookahead--, k.strstart++;
          if (B && (q(k, !1), k.strm.avail_out === 0)) return A;
        }
        return k.insert = k.strstart < w - 1 ? k.strstart : w - 1, ne === p ? (q(k, !0), k.strm.avail_out === 0 ? ue : Q) : k.last_lit && (q(k, !1), k.strm.avail_out === 0) ? A : G;
      }
      function H(k, ne) {
        for (var J, B, X; ; ) {
          if (k.lookahead < U) {
            if (V(k), k.lookahead < U && ne === m) return A;
            if (k.lookahead === 0) break;
          }
          if (J = 0, k.lookahead >= w && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), k.prev_length = k.match_length, k.prev_match = k.match_start, k.match_length = w - 1, J !== 0 && k.prev_length < k.max_lazy_match && k.strstart - J <= k.w_size - U && (k.match_length = ce(k, J), k.match_length <= 5 && (k.strategy === 1 || k.match_length === w && 4096 < k.strstart - k.match_start) && (k.match_length = w - 1)), k.prev_length >= w && k.match_length <= k.prev_length) {
            for (X = k.strstart + k.lookahead - w, B = c._tr_tally(k, k.strstart - 1 - k.prev_match, k.prev_length - w), k.lookahead -= k.prev_length - 1, k.prev_length -= 2; ++k.strstart <= X && (k.ins_h = (k.ins_h << k.hash_shift ^ k.window[k.strstart + w - 1]) & k.hash_mask, J = k.prev[k.strstart & k.w_mask] = k.head[k.ins_h], k.head[k.ins_h] = k.strstart), --k.prev_length != 0; ) ;
            if (k.match_available = 0, k.match_length = w - 1, k.strstart++, B && (q(k, !1), k.strm.avail_out === 0)) return A;
          } else if (k.match_available) {
            if ((B = c._tr_tally(k, 0, k.window[k.strstart - 1])) && q(k, !1), k.strstart++, k.lookahead--, k.strm.avail_out === 0) return A;
          } else k.match_available = 1, k.strstart++, k.lookahead--;
        }
        return k.match_available && (B = c._tr_tally(k, 0, k.window[k.strstart - 1]), k.match_available = 0), k.insert = k.strstart < w - 1 ? k.strstart : w - 1, ne === p ? (q(k, !0), k.strm.avail_out === 0 ? ue : Q) : k.last_lit && (q(k, !1), k.strm.avail_out === 0) ? A : G;
      }
      function I(k, ne, J, B, X) {
        this.good_length = k, this.max_lazy = ne, this.nice_length = J, this.max_chain = B, this.func = X;
      }
      function F() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = S, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new l.Buf16(2 * E), this.dyn_dtree = new l.Buf16(2 * (2 * T + 1)), this.bl_tree = new l.Buf16(2 * (2 * P + 1)), j(this.dyn_ltree), j(this.dyn_dtree), j(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new l.Buf16(y + 1), this.heap = new l.Buf16(2 * C + 1), j(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new l.Buf16(2 * C + 1), j(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function L(k) {
        var ne;
        return k && k.state ? (k.total_in = k.total_out = 0, k.data_type = M, (ne = k.state).pending = 0, ne.pending_out = 0, ne.wrap < 0 && (ne.wrap = -ne.wrap), ne.status = ne.wrap ? R : O, k.adler = ne.wrap === 2 ? 0 : 1, ne.last_flush = m, c._tr_init(ne), v) : le(k, _);
      }
      function ee(k) {
        var ne = L(k);
        return ne === v && function(J) {
          J.window_size = 2 * J.w_size, j(J.head), J.max_lazy_match = a[J.level].max_lazy, J.good_match = a[J.level].good_length, J.nice_match = a[J.level].nice_length, J.max_chain_length = a[J.level].max_chain, J.strstart = 0, J.block_start = 0, J.lookahead = 0, J.insert = 0, J.match_length = J.prev_length = w - 1, J.match_available = 0, J.ins_h = 0;
        }(k.state), ne;
      }
      function Z(k, ne, J, B, X, se) {
        if (!k) return _;
        var z = 1;
        if (ne === g && (ne = 6), B < 0 ? (z = 0, B = -B) : 15 < B && (z = 2, B -= 16), X < 1 || b < X || J !== S || B < 8 || 15 < B || ne < 0 || 9 < ne || se < 0 || x < se) return le(k, _);
        B === 8 && (B = 9);
        var N = new F();
        return (k.state = N).strm = k, N.wrap = z, N.gzhead = null, N.w_bits = B, N.w_size = 1 << N.w_bits, N.w_mask = N.w_size - 1, N.hash_bits = X + 7, N.hash_size = 1 << N.hash_bits, N.hash_mask = N.hash_size - 1, N.hash_shift = ~~((N.hash_bits + w - 1) / w), N.window = new l.Buf8(2 * N.w_size), N.head = new l.Buf16(N.hash_size), N.prev = new l.Buf16(N.w_size), N.lit_bufsize = 1 << X + 6, N.pending_buf_size = 4 * N.lit_bufsize, N.pending_buf = new l.Buf8(N.pending_buf_size), N.d_buf = 1 * N.lit_bufsize, N.l_buf = 3 * N.lit_bufsize, N.level = ne, N.strategy = se, N.method = J, ee(k);
      }
      a = [new I(0, 0, 0, 0, function(k, ne) {
        var J = 65535;
        for (J > k.pending_buf_size - 5 && (J = k.pending_buf_size - 5); ; ) {
          if (k.lookahead <= 1) {
            if (V(k), k.lookahead === 0 && ne === m) return A;
            if (k.lookahead === 0) break;
          }
          k.strstart += k.lookahead, k.lookahead = 0;
          var B = k.block_start + J;
          if ((k.strstart === 0 || k.strstart >= B) && (k.lookahead = k.strstart - B, k.strstart = B, q(k, !1), k.strm.avail_out === 0) || k.strstart - k.block_start >= k.w_size - U && (q(k, !1), k.strm.avail_out === 0)) return A;
        }
        return k.insert = 0, ne === p ? (q(k, !0), k.strm.avail_out === 0 ? ue : Q) : (k.strstart > k.block_start && (q(k, !1), k.strm.avail_out), A);
      }), new I(4, 4, 8, 4, Y), new I(4, 5, 16, 8, Y), new I(4, 6, 32, 32, Y), new I(4, 4, 16, 16, H), new I(8, 16, 32, 32, H), new I(8, 16, 128, 128, H), new I(8, 32, 128, 256, H), new I(32, 128, 258, 1024, H), new I(32, 258, 258, 4096, H)], o.deflateInit = function(k, ne) {
        return Z(k, ne, S, 15, 8, 0);
      }, o.deflateInit2 = Z, o.deflateReset = ee, o.deflateResetKeep = L, o.deflateSetHeader = function(k, ne) {
        return k && k.state ? k.state.wrap !== 2 ? _ : (k.state.gzhead = ne, v) : _;
      }, o.deflate = function(k, ne) {
        var J, B, X, se;
        if (!k || !k.state || 5 < ne || ne < 0) return k ? le(k, _) : _;
        if (B = k.state, !k.output || !k.input && k.avail_in !== 0 || B.status === 666 && ne !== p) return le(k, k.avail_out === 0 ? -5 : _);
        if (B.strm = k, J = B.last_flush, B.last_flush = ne, B.status === R) if (B.wrap === 2) k.adler = 0, oe(B, 31), oe(B, 139), oe(B, 8), B.gzhead ? (oe(B, (B.gzhead.text ? 1 : 0) + (B.gzhead.hcrc ? 2 : 0) + (B.gzhead.extra ? 4 : 0) + (B.gzhead.name ? 8 : 0) + (B.gzhead.comment ? 16 : 0)), oe(B, 255 & B.gzhead.time), oe(B, B.gzhead.time >> 8 & 255), oe(B, B.gzhead.time >> 16 & 255), oe(B, B.gzhead.time >> 24 & 255), oe(B, B.level === 9 ? 2 : 2 <= B.strategy || B.level < 2 ? 4 : 0), oe(B, 255 & B.gzhead.os), B.gzhead.extra && B.gzhead.extra.length && (oe(B, 255 & B.gzhead.extra.length), oe(B, B.gzhead.extra.length >> 8 & 255)), B.gzhead.hcrc && (k.adler = d(k.adler, B.pending_buf, B.pending, 0)), B.gzindex = 0, B.status = 69) : (oe(B, 0), oe(B, 0), oe(B, 0), oe(B, 0), oe(B, 0), oe(B, B.level === 9 ? 2 : 2 <= B.strategy || B.level < 2 ? 4 : 0), oe(B, 3), B.status = O);
        else {
          var z = S + (B.w_bits - 8 << 4) << 8;
          z |= (2 <= B.strategy || B.level < 2 ? 0 : B.level < 6 ? 1 : B.level === 6 ? 2 : 3) << 6, B.strstart !== 0 && (z |= 32), z += 31 - z % 31, B.status = O, ie(B, z), B.strstart !== 0 && (ie(B, k.adler >>> 16), ie(B, 65535 & k.adler)), k.adler = 1;
        }
        if (B.status === 69) if (B.gzhead.extra) {
          for (X = B.pending; B.gzindex < (65535 & B.gzhead.extra.length) && (B.pending !== B.pending_buf_size || (B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), $(k), X = B.pending, B.pending !== B.pending_buf_size)); ) oe(B, 255 & B.gzhead.extra[B.gzindex]), B.gzindex++;
          B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), B.gzindex === B.gzhead.extra.length && (B.gzindex = 0, B.status = 73);
        } else B.status = 73;
        if (B.status === 73) if (B.gzhead.name) {
          X = B.pending;
          do {
            if (B.pending === B.pending_buf_size && (B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), $(k), X = B.pending, B.pending === B.pending_buf_size)) {
              se = 1;
              break;
            }
            se = B.gzindex < B.gzhead.name.length ? 255 & B.gzhead.name.charCodeAt(B.gzindex++) : 0, oe(B, se);
          } while (se !== 0);
          B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), se === 0 && (B.gzindex = 0, B.status = 91);
        } else B.status = 91;
        if (B.status === 91) if (B.gzhead.comment) {
          X = B.pending;
          do {
            if (B.pending === B.pending_buf_size && (B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), $(k), X = B.pending, B.pending === B.pending_buf_size)) {
              se = 1;
              break;
            }
            se = B.gzindex < B.gzhead.comment.length ? 255 & B.gzhead.comment.charCodeAt(B.gzindex++) : 0, oe(B, se);
          } while (se !== 0);
          B.gzhead.hcrc && B.pending > X && (k.adler = d(k.adler, B.pending_buf, B.pending - X, X)), se === 0 && (B.status = 103);
        } else B.status = 103;
        if (B.status === 103 && (B.gzhead.hcrc ? (B.pending + 2 > B.pending_buf_size && $(k), B.pending + 2 <= B.pending_buf_size && (oe(B, 255 & k.adler), oe(B, k.adler >> 8 & 255), k.adler = 0, B.status = O)) : B.status = O), B.pending !== 0) {
          if ($(k), k.avail_out === 0) return B.last_flush = -1, v;
        } else if (k.avail_in === 0 && re(ne) <= re(J) && ne !== p) return le(k, -5);
        if (B.status === 666 && k.avail_in !== 0) return le(k, -5);
        if (k.avail_in !== 0 || B.lookahead !== 0 || ne !== m && B.status !== 666) {
          var N = B.strategy === 2 ? function(K, he) {
            for (var me; ; ) {
              if (K.lookahead === 0 && (V(K), K.lookahead === 0)) {
                if (he === m) return A;
                break;
              }
              if (K.match_length = 0, me = c._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++, me && (q(K, !1), K.strm.avail_out === 0)) return A;
            }
            return K.insert = 0, he === p ? (q(K, !0), K.strm.avail_out === 0 ? ue : Q) : K.last_lit && (q(K, !1), K.strm.avail_out === 0) ? A : G;
          }(B, ne) : B.strategy === 3 ? function(K, he) {
            for (var me, ge, Me, Ee, Ae = K.window; ; ) {
              if (K.lookahead <= D) {
                if (V(K), K.lookahead <= D && he === m) return A;
                if (K.lookahead === 0) break;
              }
              if (K.match_length = 0, K.lookahead >= w && 0 < K.strstart && (ge = Ae[Me = K.strstart - 1]) === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me]) {
                Ee = K.strstart + D;
                do
                  ;
                while (ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && Me < Ee);
                K.match_length = D - (Ee - Me), K.match_length > K.lookahead && (K.match_length = K.lookahead);
              }
              if (K.match_length >= w ? (me = c._tr_tally(K, 1, K.match_length - w), K.lookahead -= K.match_length, K.strstart += K.match_length, K.match_length = 0) : (me = c._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++), me && (q(K, !1), K.strm.avail_out === 0)) return A;
            }
            return K.insert = 0, he === p ? (q(K, !0), K.strm.avail_out === 0 ? ue : Q) : K.last_lit && (q(K, !1), K.strm.avail_out === 0) ? A : G;
          }(B, ne) : a[B.level].func(B, ne);
          if (N !== ue && N !== Q || (B.status = 666), N === A || N === ue) return k.avail_out === 0 && (B.last_flush = -1), v;
          if (N === G && (ne === 1 ? c._tr_align(B) : ne !== 5 && (c._tr_stored_block(B, 0, 0, !1), ne === 3 && (j(B.head), B.lookahead === 0 && (B.strstart = 0, B.block_start = 0, B.insert = 0))), $(k), k.avail_out === 0)) return B.last_flush = -1, v;
        }
        return ne !== p ? v : B.wrap <= 0 ? 1 : (B.wrap === 2 ? (oe(B, 255 & k.adler), oe(B, k.adler >> 8 & 255), oe(B, k.adler >> 16 & 255), oe(B, k.adler >> 24 & 255), oe(B, 255 & k.total_in), oe(B, k.total_in >> 8 & 255), oe(B, k.total_in >> 16 & 255), oe(B, k.total_in >> 24 & 255)) : (ie(B, k.adler >>> 16), ie(B, 65535 & k.adler)), $(k), 0 < B.wrap && (B.wrap = -B.wrap), B.pending !== 0 ? v : 1);
      }, o.deflateEnd = function(k) {
        var ne;
        return k && k.state ? (ne = k.state.status) !== R && ne !== 69 && ne !== 73 && ne !== 91 && ne !== 103 && ne !== O && ne !== 666 ? le(k, _) : (k.state = null, ne === O ? le(k, -3) : v) : _;
      }, o.deflateSetDictionary = function(k, ne) {
        var J, B, X, se, z, N, K, he, me = ne.length;
        if (!k || !k.state || (se = (J = k.state).wrap) === 2 || se === 1 && J.status !== R || J.lookahead) return _;
        for (se === 1 && (k.adler = u(k.adler, ne, me, 0)), J.wrap = 0, me >= J.w_size && (se === 0 && (j(J.head), J.strstart = 0, J.block_start = 0, J.insert = 0), he = new l.Buf8(J.w_size), l.arraySet(he, ne, me - J.w_size, J.w_size, 0), ne = he, me = J.w_size), z = k.avail_in, N = k.next_in, K = k.input, k.avail_in = me, k.next_in = 0, k.input = ne, V(J); J.lookahead >= w; ) {
          for (B = J.strstart, X = J.lookahead - (w - 1); J.ins_h = (J.ins_h << J.hash_shift ^ J.window[B + w - 1]) & J.hash_mask, J.prev[B & J.w_mask] = J.head[J.ins_h], J.head[J.ins_h] = B, B++, --X; ) ;
          J.strstart = B, J.lookahead = w - 1, V(J);
        }
        return J.strstart += J.lookahead, J.block_start = J.strstart, J.insert = J.lookahead, J.lookahead = 0, J.match_length = J.prev_length = w - 1, J.match_available = 0, k.next_in = N, k.input = K, k.avail_in = z, J.wrap = se, v;
      }, o.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(i, r, o) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(i, r, o) {
      r.exports = function(a, l) {
        var c, u, d, h, m, p, v, _, g, x, M, S, b, C, T, P, E, y, w, D, U, R, O, A, G;
        c = a.state, u = a.next_in, A = a.input, d = u + (a.avail_in - 5), h = a.next_out, G = a.output, m = h - (l - a.avail_out), p = h + (a.avail_out - 257), v = c.dmax, _ = c.wsize, g = c.whave, x = c.wnext, M = c.window, S = c.hold, b = c.bits, C = c.lencode, T = c.distcode, P = (1 << c.lenbits) - 1, E = (1 << c.distbits) - 1;
        e: do {
          b < 15 && (S += A[u++] << b, b += 8, S += A[u++] << b, b += 8), y = C[S & P];
          t: for (; ; ) {
            if (S >>>= w = y >>> 24, b -= w, (w = y >>> 16 & 255) === 0) G[h++] = 65535 & y;
            else {
              if (!(16 & w)) {
                if (!(64 & w)) {
                  y = C[(65535 & y) + (S & (1 << w) - 1)];
                  continue t;
                }
                if (32 & w) {
                  c.mode = 12;
                  break e;
                }
                a.msg = "invalid literal/length code", c.mode = 30;
                break e;
              }
              D = 65535 & y, (w &= 15) && (b < w && (S += A[u++] << b, b += 8), D += S & (1 << w) - 1, S >>>= w, b -= w), b < 15 && (S += A[u++] << b, b += 8, S += A[u++] << b, b += 8), y = T[S & E];
              n: for (; ; ) {
                if (S >>>= w = y >>> 24, b -= w, !(16 & (w = y >>> 16 & 255))) {
                  if (!(64 & w)) {
                    y = T[(65535 & y) + (S & (1 << w) - 1)];
                    continue n;
                  }
                  a.msg = "invalid distance code", c.mode = 30;
                  break e;
                }
                if (U = 65535 & y, b < (w &= 15) && (S += A[u++] << b, (b += 8) < w && (S += A[u++] << b, b += 8)), v < (U += S & (1 << w) - 1)) {
                  a.msg = "invalid distance too far back", c.mode = 30;
                  break e;
                }
                if (S >>>= w, b -= w, (w = h - m) < U) {
                  if (g < (w = U - w) && c.sane) {
                    a.msg = "invalid distance too far back", c.mode = 30;
                    break e;
                  }
                  if (O = M, (R = 0) === x) {
                    if (R += _ - w, w < D) {
                      for (D -= w; G[h++] = M[R++], --w; ) ;
                      R = h - U, O = G;
                    }
                  } else if (x < w) {
                    if (R += _ + x - w, (w -= x) < D) {
                      for (D -= w; G[h++] = M[R++], --w; ) ;
                      if (R = 0, x < D) {
                        for (D -= w = x; G[h++] = M[R++], --w; ) ;
                        R = h - U, O = G;
                      }
                    }
                  } else if (R += x - w, w < D) {
                    for (D -= w; G[h++] = M[R++], --w; ) ;
                    R = h - U, O = G;
                  }
                  for (; 2 < D; ) G[h++] = O[R++], G[h++] = O[R++], G[h++] = O[R++], D -= 3;
                  D && (G[h++] = O[R++], 1 < D && (G[h++] = O[R++]));
                } else {
                  for (R = h - U; G[h++] = G[R++], G[h++] = G[R++], G[h++] = G[R++], 2 < (D -= 3); ) ;
                  D && (G[h++] = G[R++], 1 < D && (G[h++] = G[R++]));
                }
                break;
              }
            }
            break;
          }
        } while (u < d && h < p);
        u -= D = b >> 3, S &= (1 << (b -= D << 3)) - 1, a.next_in = u, a.next_out = h, a.avail_in = u < d ? d - u + 5 : 5 - (u - d), a.avail_out = h < p ? p - h + 257 : 257 - (h - p), c.hold = S, c.bits = b;
      };
    }, {}], 49: [function(i, r, o) {
      var a = i("../utils/common"), l = i("./adler32"), c = i("./crc32"), u = i("./inffast"), d = i("./inftrees"), h = 1, m = 2, p = 0, v = -2, _ = 1, g = 852, x = 592;
      function M(R) {
        return (R >>> 24 & 255) + (R >>> 8 & 65280) + ((65280 & R) << 8) + ((255 & R) << 24);
      }
      function S() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function b(R) {
        var O;
        return R && R.state ? (O = R.state, R.total_in = R.total_out = O.total = 0, R.msg = "", O.wrap && (R.adler = 1 & O.wrap), O.mode = _, O.last = 0, O.havedict = 0, O.dmax = 32768, O.head = null, O.hold = 0, O.bits = 0, O.lencode = O.lendyn = new a.Buf32(g), O.distcode = O.distdyn = new a.Buf32(x), O.sane = 1, O.back = -1, p) : v;
      }
      function C(R) {
        var O;
        return R && R.state ? ((O = R.state).wsize = 0, O.whave = 0, O.wnext = 0, b(R)) : v;
      }
      function T(R, O) {
        var A, G;
        return R && R.state ? (G = R.state, O < 0 ? (A = 0, O = -O) : (A = 1 + (O >> 4), O < 48 && (O &= 15)), O && (O < 8 || 15 < O) ? v : (G.window !== null && G.wbits !== O && (G.window = null), G.wrap = A, G.wbits = O, C(R))) : v;
      }
      function P(R, O) {
        var A, G;
        return R ? (G = new S(), (R.state = G).window = null, (A = T(R, O)) !== p && (R.state = null), A) : v;
      }
      var E, y, w = !0;
      function D(R) {
        if (w) {
          var O;
          for (E = new a.Buf32(512), y = new a.Buf32(32), O = 0; O < 144; ) R.lens[O++] = 8;
          for (; O < 256; ) R.lens[O++] = 9;
          for (; O < 280; ) R.lens[O++] = 7;
          for (; O < 288; ) R.lens[O++] = 8;
          for (d(h, R.lens, 0, 288, E, 0, R.work, { bits: 9 }), O = 0; O < 32; ) R.lens[O++] = 5;
          d(m, R.lens, 0, 32, y, 0, R.work, { bits: 5 }), w = !1;
        }
        R.lencode = E, R.lenbits = 9, R.distcode = y, R.distbits = 5;
      }
      function U(R, O, A, G) {
        var ue, Q = R.state;
        return Q.window === null && (Q.wsize = 1 << Q.wbits, Q.wnext = 0, Q.whave = 0, Q.window = new a.Buf8(Q.wsize)), G >= Q.wsize ? (a.arraySet(Q.window, O, A - Q.wsize, Q.wsize, 0), Q.wnext = 0, Q.whave = Q.wsize) : (G < (ue = Q.wsize - Q.wnext) && (ue = G), a.arraySet(Q.window, O, A - G, ue, Q.wnext), (G -= ue) ? (a.arraySet(Q.window, O, A - G, G, 0), Q.wnext = G, Q.whave = Q.wsize) : (Q.wnext += ue, Q.wnext === Q.wsize && (Q.wnext = 0), Q.whave < Q.wsize && (Q.whave += ue))), 0;
      }
      o.inflateReset = C, o.inflateReset2 = T, o.inflateResetKeep = b, o.inflateInit = function(R) {
        return P(R, 15);
      }, o.inflateInit2 = P, o.inflate = function(R, O) {
        var A, G, ue, Q, le, re, j, $, q, oe, ie, ce, V, Y, H, I, F, L, ee, Z, k, ne, J, B, X = 0, se = new a.Buf8(4), z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!R || !R.state || !R.output || !R.input && R.avail_in !== 0) return v;
        (A = R.state).mode === 12 && (A.mode = 13), le = R.next_out, ue = R.output, j = R.avail_out, Q = R.next_in, G = R.input, re = R.avail_in, $ = A.hold, q = A.bits, oe = re, ie = j, ne = p;
        e: for (; ; ) switch (A.mode) {
          case _:
            if (A.wrap === 0) {
              A.mode = 13;
              break;
            }
            for (; q < 16; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (2 & A.wrap && $ === 35615) {
              se[A.check = 0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0), q = $ = 0, A.mode = 2;
              break;
            }
            if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & $) << 8) + ($ >> 8)) % 31) {
              R.msg = "incorrect header check", A.mode = 30;
              break;
            }
            if ((15 & $) != 8) {
              R.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (q -= 4, k = 8 + (15 & ($ >>>= 4)), A.wbits === 0) A.wbits = k;
            else if (k > A.wbits) {
              R.msg = "invalid window size", A.mode = 30;
              break;
            }
            A.dmax = 1 << k, R.adler = A.check = 1, A.mode = 512 & $ ? 10 : 12, q = $ = 0;
            break;
          case 2:
            for (; q < 16; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (A.flags = $, (255 & A.flags) != 8) {
              R.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (57344 & A.flags) {
              R.msg = "unknown header flags set", A.mode = 30;
              break;
            }
            A.head && (A.head.text = $ >> 8 & 1), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = $ = 0, A.mode = 3;
          case 3:
            for (; q < 32; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            A.head && (A.head.time = $), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, se[2] = $ >>> 16 & 255, se[3] = $ >>> 24 & 255, A.check = c(A.check, se, 4, 0)), q = $ = 0, A.mode = 4;
          case 4:
            for (; q < 16; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            A.head && (A.head.xflags = 255 & $, A.head.os = $ >> 8), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = $ = 0, A.mode = 5;
          case 5:
            if (1024 & A.flags) {
              for (; q < 16; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.length = $, A.head && (A.head.extra_len = $), 512 & A.flags && (se[0] = 255 & $, se[1] = $ >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = $ = 0;
            } else A.head && (A.head.extra = null);
            A.mode = 6;
          case 6:
            if (1024 & A.flags && (re < (ce = A.length) && (ce = re), ce && (A.head && (k = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), a.arraySet(A.head.extra, G, Q, ce, k)), 512 & A.flags && (A.check = c(A.check, G, ce, Q)), re -= ce, Q += ce, A.length -= ce), A.length)) break e;
            A.length = 0, A.mode = 7;
          case 7:
            if (2048 & A.flags) {
              if (re === 0) break e;
              for (ce = 0; k = G[Q + ce++], A.head && k && A.length < 65536 && (A.head.name += String.fromCharCode(k)), k && ce < re; ) ;
              if (512 & A.flags && (A.check = c(A.check, G, ce, Q)), re -= ce, Q += ce, k) break e;
            } else A.head && (A.head.name = null);
            A.length = 0, A.mode = 8;
          case 8:
            if (4096 & A.flags) {
              if (re === 0) break e;
              for (ce = 0; k = G[Q + ce++], A.head && k && A.length < 65536 && (A.head.comment += String.fromCharCode(k)), k && ce < re; ) ;
              if (512 & A.flags && (A.check = c(A.check, G, ce, Q)), re -= ce, Q += ce, k) break e;
            } else A.head && (A.head.comment = null);
            A.mode = 9;
          case 9:
            if (512 & A.flags) {
              for (; q < 16; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              if ($ !== (65535 & A.check)) {
                R.msg = "header crc mismatch", A.mode = 30;
                break;
              }
              q = $ = 0;
            }
            A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), R.adler = A.check = 0, A.mode = 12;
            break;
          case 10:
            for (; q < 32; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            R.adler = A.check = M($), q = $ = 0, A.mode = 11;
          case 11:
            if (A.havedict === 0) return R.next_out = le, R.avail_out = j, R.next_in = Q, R.avail_in = re, A.hold = $, A.bits = q, 2;
            R.adler = A.check = 1, A.mode = 12;
          case 12:
            if (O === 5 || O === 6) break e;
          case 13:
            if (A.last) {
              $ >>>= 7 & q, q -= 7 & q, A.mode = 27;
              break;
            }
            for (; q < 3; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            switch (A.last = 1 & $, q -= 1, 3 & ($ >>>= 1)) {
              case 0:
                A.mode = 14;
                break;
              case 1:
                if (D(A), A.mode = 20, O !== 6) break;
                $ >>>= 2, q -= 2;
                break e;
              case 2:
                A.mode = 17;
                break;
              case 3:
                R.msg = "invalid block type", A.mode = 30;
            }
            $ >>>= 2, q -= 2;
            break;
          case 14:
            for ($ >>>= 7 & q, q -= 7 & q; q < 32; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if ((65535 & $) != ($ >>> 16 ^ 65535)) {
              R.msg = "invalid stored block lengths", A.mode = 30;
              break;
            }
            if (A.length = 65535 & $, q = $ = 0, A.mode = 15, O === 6) break e;
          case 15:
            A.mode = 16;
          case 16:
            if (ce = A.length) {
              if (re < ce && (ce = re), j < ce && (ce = j), ce === 0) break e;
              a.arraySet(ue, G, Q, ce, le), re -= ce, Q += ce, j -= ce, le += ce, A.length -= ce;
              break;
            }
            A.mode = 12;
            break;
          case 17:
            for (; q < 14; ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (A.nlen = 257 + (31 & $), $ >>>= 5, q -= 5, A.ndist = 1 + (31 & $), $ >>>= 5, q -= 5, A.ncode = 4 + (15 & $), $ >>>= 4, q -= 4, 286 < A.nlen || 30 < A.ndist) {
              R.msg = "too many length or distance symbols", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 18;
          case 18:
            for (; A.have < A.ncode; ) {
              for (; q < 3; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.lens[z[A.have++]] = 7 & $, $ >>>= 3, q -= 3;
            }
            for (; A.have < 19; ) A.lens[z[A.have++]] = 0;
            if (A.lencode = A.lendyn, A.lenbits = 7, J = { bits: A.lenbits }, ne = d(0, A.lens, 0, 19, A.lencode, 0, A.work, J), A.lenbits = J.bits, ne) {
              R.msg = "invalid code lengths set", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 19;
          case 19:
            for (; A.have < A.nlen + A.ndist; ) {
              for (; I = (X = A.lencode[$ & (1 << A.lenbits) - 1]) >>> 16 & 255, F = 65535 & X, !((H = X >>> 24) <= q); ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              if (F < 16) $ >>>= H, q -= H, A.lens[A.have++] = F;
              else {
                if (F === 16) {
                  for (B = H + 2; q < B; ) {
                    if (re === 0) break e;
                    re--, $ += G[Q++] << q, q += 8;
                  }
                  if ($ >>>= H, q -= H, A.have === 0) {
                    R.msg = "invalid bit length repeat", A.mode = 30;
                    break;
                  }
                  k = A.lens[A.have - 1], ce = 3 + (3 & $), $ >>>= 2, q -= 2;
                } else if (F === 17) {
                  for (B = H + 3; q < B; ) {
                    if (re === 0) break e;
                    re--, $ += G[Q++] << q, q += 8;
                  }
                  q -= H, k = 0, ce = 3 + (7 & ($ >>>= H)), $ >>>= 3, q -= 3;
                } else {
                  for (B = H + 7; q < B; ) {
                    if (re === 0) break e;
                    re--, $ += G[Q++] << q, q += 8;
                  }
                  q -= H, k = 0, ce = 11 + (127 & ($ >>>= H)), $ >>>= 7, q -= 7;
                }
                if (A.have + ce > A.nlen + A.ndist) {
                  R.msg = "invalid bit length repeat", A.mode = 30;
                  break;
                }
                for (; ce--; ) A.lens[A.have++] = k;
              }
            }
            if (A.mode === 30) break;
            if (A.lens[256] === 0) {
              R.msg = "invalid code -- missing end-of-block", A.mode = 30;
              break;
            }
            if (A.lenbits = 9, J = { bits: A.lenbits }, ne = d(h, A.lens, 0, A.nlen, A.lencode, 0, A.work, J), A.lenbits = J.bits, ne) {
              R.msg = "invalid literal/lengths set", A.mode = 30;
              break;
            }
            if (A.distbits = 6, A.distcode = A.distdyn, J = { bits: A.distbits }, ne = d(m, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, J), A.distbits = J.bits, ne) {
              R.msg = "invalid distances set", A.mode = 30;
              break;
            }
            if (A.mode = 20, O === 6) break e;
          case 20:
            A.mode = 21;
          case 21:
            if (6 <= re && 258 <= j) {
              R.next_out = le, R.avail_out = j, R.next_in = Q, R.avail_in = re, A.hold = $, A.bits = q, u(R, ie), le = R.next_out, ue = R.output, j = R.avail_out, Q = R.next_in, G = R.input, re = R.avail_in, $ = A.hold, q = A.bits, A.mode === 12 && (A.back = -1);
              break;
            }
            for (A.back = 0; I = (X = A.lencode[$ & (1 << A.lenbits) - 1]) >>> 16 & 255, F = 65535 & X, !((H = X >>> 24) <= q); ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (I && !(240 & I)) {
              for (L = H, ee = I, Z = F; I = (X = A.lencode[Z + (($ & (1 << L + ee) - 1) >> L)]) >>> 16 & 255, F = 65535 & X, !(L + (H = X >>> 24) <= q); ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              $ >>>= L, q -= L, A.back += L;
            }
            if ($ >>>= H, q -= H, A.back += H, A.length = F, I === 0) {
              A.mode = 26;
              break;
            }
            if (32 & I) {
              A.back = -1, A.mode = 12;
              break;
            }
            if (64 & I) {
              R.msg = "invalid literal/length code", A.mode = 30;
              break;
            }
            A.extra = 15 & I, A.mode = 22;
          case 22:
            if (A.extra) {
              for (B = A.extra; q < B; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.length += $ & (1 << A.extra) - 1, $ >>>= A.extra, q -= A.extra, A.back += A.extra;
            }
            A.was = A.length, A.mode = 23;
          case 23:
            for (; I = (X = A.distcode[$ & (1 << A.distbits) - 1]) >>> 16 & 255, F = 65535 & X, !((H = X >>> 24) <= q); ) {
              if (re === 0) break e;
              re--, $ += G[Q++] << q, q += 8;
            }
            if (!(240 & I)) {
              for (L = H, ee = I, Z = F; I = (X = A.distcode[Z + (($ & (1 << L + ee) - 1) >> L)]) >>> 16 & 255, F = 65535 & X, !(L + (H = X >>> 24) <= q); ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              $ >>>= L, q -= L, A.back += L;
            }
            if ($ >>>= H, q -= H, A.back += H, 64 & I) {
              R.msg = "invalid distance code", A.mode = 30;
              break;
            }
            A.offset = F, A.extra = 15 & I, A.mode = 24;
          case 24:
            if (A.extra) {
              for (B = A.extra; q < B; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              A.offset += $ & (1 << A.extra) - 1, $ >>>= A.extra, q -= A.extra, A.back += A.extra;
            }
            if (A.offset > A.dmax) {
              R.msg = "invalid distance too far back", A.mode = 30;
              break;
            }
            A.mode = 25;
          case 25:
            if (j === 0) break e;
            if (ce = ie - j, A.offset > ce) {
              if ((ce = A.offset - ce) > A.whave && A.sane) {
                R.msg = "invalid distance too far back", A.mode = 30;
                break;
              }
              V = ce > A.wnext ? (ce -= A.wnext, A.wsize - ce) : A.wnext - ce, ce > A.length && (ce = A.length), Y = A.window;
            } else Y = ue, V = le - A.offset, ce = A.length;
            for (j < ce && (ce = j), j -= ce, A.length -= ce; ue[le++] = Y[V++], --ce; ) ;
            A.length === 0 && (A.mode = 21);
            break;
          case 26:
            if (j === 0) break e;
            ue[le++] = A.length, j--, A.mode = 21;
            break;
          case 27:
            if (A.wrap) {
              for (; q < 32; ) {
                if (re === 0) break e;
                re--, $ |= G[Q++] << q, q += 8;
              }
              if (ie -= j, R.total_out += ie, A.total += ie, ie && (R.adler = A.check = A.flags ? c(A.check, ue, ie, le - ie) : l(A.check, ue, ie, le - ie)), ie = j, (A.flags ? $ : M($)) !== A.check) {
                R.msg = "incorrect data check", A.mode = 30;
                break;
              }
              q = $ = 0;
            }
            A.mode = 28;
          case 28:
            if (A.wrap && A.flags) {
              for (; q < 32; ) {
                if (re === 0) break e;
                re--, $ += G[Q++] << q, q += 8;
              }
              if ($ !== (4294967295 & A.total)) {
                R.msg = "incorrect length check", A.mode = 30;
                break;
              }
              q = $ = 0;
            }
            A.mode = 29;
          case 29:
            ne = 1;
            break e;
          case 30:
            ne = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return v;
        }
        return R.next_out = le, R.avail_out = j, R.next_in = Q, R.avail_in = re, A.hold = $, A.bits = q, (A.wsize || ie !== R.avail_out && A.mode < 30 && (A.mode < 27 || O !== 4)) && U(R, R.output, R.next_out, ie - R.avail_out) ? (A.mode = 31, -4) : (oe -= R.avail_in, ie -= R.avail_out, R.total_in += oe, R.total_out += ie, A.total += ie, A.wrap && ie && (R.adler = A.check = A.flags ? c(A.check, ue, ie, R.next_out - ie) : l(A.check, ue, ie, R.next_out - ie)), R.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (oe == 0 && ie === 0 || O === 4) && ne === p && (ne = -5), ne);
      }, o.inflateEnd = function(R) {
        if (!R || !R.state) return v;
        var O = R.state;
        return O.window && (O.window = null), R.state = null, p;
      }, o.inflateGetHeader = function(R, O) {
        var A;
        return R && R.state && 2 & (A = R.state).wrap ? ((A.head = O).done = !1, p) : v;
      }, o.inflateSetDictionary = function(R, O) {
        var A, G = O.length;
        return R && R.state ? (A = R.state).wrap !== 0 && A.mode !== 11 ? v : A.mode === 11 && l(1, O, G, 0) !== A.check ? -3 : U(R, O, G, G) ? (A.mode = 31, -4) : (A.havedict = 1, p) : v;
      }, o.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(i, r, o) {
      var a = i("../utils/common"), l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(h, m, p, v, _, g, x, M) {
        var S, b, C, T, P, E, y, w, D, U = M.bits, R = 0, O = 0, A = 0, G = 0, ue = 0, Q = 0, le = 0, re = 0, j = 0, $ = 0, q = null, oe = 0, ie = new a.Buf16(16), ce = new a.Buf16(16), V = null, Y = 0;
        for (R = 0; R <= 15; R++) ie[R] = 0;
        for (O = 0; O < v; O++) ie[m[p + O]]++;
        for (ue = U, G = 15; 1 <= G && ie[G] === 0; G--) ;
        if (G < ue && (ue = G), G === 0) return _[g++] = 20971520, _[g++] = 20971520, M.bits = 1, 0;
        for (A = 1; A < G && ie[A] === 0; A++) ;
        for (ue < A && (ue = A), R = re = 1; R <= 15; R++) if (re <<= 1, (re -= ie[R]) < 0) return -1;
        if (0 < re && (h === 0 || G !== 1)) return -1;
        for (ce[1] = 0, R = 1; R < 15; R++) ce[R + 1] = ce[R] + ie[R];
        for (O = 0; O < v; O++) m[p + O] !== 0 && (x[ce[m[p + O]]++] = O);
        if (E = h === 0 ? (q = V = x, 19) : h === 1 ? (q = l, oe -= 257, V = c, Y -= 257, 256) : (q = u, V = d, -1), R = A, P = g, le = O = $ = 0, C = -1, T = (j = 1 << (Q = ue)) - 1, h === 1 && 852 < j || h === 2 && 592 < j) return 1;
        for (; ; ) {
          for (y = R - le, D = x[O] < E ? (w = 0, x[O]) : x[O] > E ? (w = V[Y + x[O]], q[oe + x[O]]) : (w = 96, 0), S = 1 << R - le, A = b = 1 << Q; _[P + ($ >> le) + (b -= S)] = y << 24 | w << 16 | D | 0, b !== 0; ) ;
          for (S = 1 << R - 1; $ & S; ) S >>= 1;
          if (S !== 0 ? ($ &= S - 1, $ += S) : $ = 0, O++, --ie[R] == 0) {
            if (R === G) break;
            R = m[p + x[O]];
          }
          if (ue < R && ($ & T) !== C) {
            for (le === 0 && (le = ue), P += A, re = 1 << (Q = R - le); Q + le < G && !((re -= ie[Q + le]) <= 0); ) Q++, re <<= 1;
            if (j += 1 << Q, h === 1 && 852 < j || h === 2 && 592 < j) return 1;
            _[C = $ & T] = ue << 24 | Q << 16 | P - g | 0;
          }
        }
        return $ !== 0 && (_[P + $] = R - le << 24 | 64 << 16 | 0), M.bits = ue, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(i, r, o) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(i, r, o) {
      var a = i("../utils/common"), l = 0, c = 1;
      function u(X) {
        for (var se = X.length; 0 <= --se; ) X[se] = 0;
      }
      var d = 0, h = 29, m = 256, p = m + 1 + h, v = 30, _ = 19, g = 2 * p + 1, x = 15, M = 16, S = 7, b = 256, C = 16, T = 17, P = 18, E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], U = new Array(2 * (p + 2));
      u(U);
      var R = new Array(2 * v);
      u(R);
      var O = new Array(512);
      u(O);
      var A = new Array(256);
      u(A);
      var G = new Array(h);
      u(G);
      var ue, Q, le, re = new Array(v);
      function j(X, se, z, N, K) {
        this.static_tree = X, this.extra_bits = se, this.extra_base = z, this.elems = N, this.max_length = K, this.has_stree = X && X.length;
      }
      function $(X, se) {
        this.dyn_tree = X, this.max_code = 0, this.stat_desc = se;
      }
      function q(X) {
        return X < 256 ? O[X] : O[256 + (X >>> 7)];
      }
      function oe(X, se) {
        X.pending_buf[X.pending++] = 255 & se, X.pending_buf[X.pending++] = se >>> 8 & 255;
      }
      function ie(X, se, z) {
        X.bi_valid > M - z ? (X.bi_buf |= se << X.bi_valid & 65535, oe(X, X.bi_buf), X.bi_buf = se >> M - X.bi_valid, X.bi_valid += z - M) : (X.bi_buf |= se << X.bi_valid & 65535, X.bi_valid += z);
      }
      function ce(X, se, z) {
        ie(X, z[2 * se], z[2 * se + 1]);
      }
      function V(X, se) {
        for (var z = 0; z |= 1 & X, X >>>= 1, z <<= 1, 0 < --se; ) ;
        return z >>> 1;
      }
      function Y(X, se, z) {
        var N, K, he = new Array(x + 1), me = 0;
        for (N = 1; N <= x; N++) he[N] = me = me + z[N - 1] << 1;
        for (K = 0; K <= se; K++) {
          var ge = X[2 * K + 1];
          ge !== 0 && (X[2 * K] = V(he[ge]++, ge));
        }
      }
      function H(X) {
        var se;
        for (se = 0; se < p; se++) X.dyn_ltree[2 * se] = 0;
        for (se = 0; se < v; se++) X.dyn_dtree[2 * se] = 0;
        for (se = 0; se < _; se++) X.bl_tree[2 * se] = 0;
        X.dyn_ltree[2 * b] = 1, X.opt_len = X.static_len = 0, X.last_lit = X.matches = 0;
      }
      function I(X) {
        8 < X.bi_valid ? oe(X, X.bi_buf) : 0 < X.bi_valid && (X.pending_buf[X.pending++] = X.bi_buf), X.bi_buf = 0, X.bi_valid = 0;
      }
      function F(X, se, z, N) {
        var K = 2 * se, he = 2 * z;
        return X[K] < X[he] || X[K] === X[he] && N[se] <= N[z];
      }
      function L(X, se, z) {
        for (var N = X.heap[z], K = z << 1; K <= X.heap_len && (K < X.heap_len && F(se, X.heap[K + 1], X.heap[K], X.depth) && K++, !F(se, N, X.heap[K], X.depth)); ) X.heap[z] = X.heap[K], z = K, K <<= 1;
        X.heap[z] = N;
      }
      function ee(X, se, z) {
        var N, K, he, me, ge = 0;
        if (X.last_lit !== 0) for (; N = X.pending_buf[X.d_buf + 2 * ge] << 8 | X.pending_buf[X.d_buf + 2 * ge + 1], K = X.pending_buf[X.l_buf + ge], ge++, N === 0 ? ce(X, K, se) : (ce(X, (he = A[K]) + m + 1, se), (me = E[he]) !== 0 && ie(X, K -= G[he], me), ce(X, he = q(--N), z), (me = y[he]) !== 0 && ie(X, N -= re[he], me)), ge < X.last_lit; ) ;
        ce(X, b, se);
      }
      function Z(X, se) {
        var z, N, K, he = se.dyn_tree, me = se.stat_desc.static_tree, ge = se.stat_desc.has_stree, Me = se.stat_desc.elems, Ee = -1;
        for (X.heap_len = 0, X.heap_max = g, z = 0; z < Me; z++) he[2 * z] !== 0 ? (X.heap[++X.heap_len] = Ee = z, X.depth[z] = 0) : he[2 * z + 1] = 0;
        for (; X.heap_len < 2; ) he[2 * (K = X.heap[++X.heap_len] = Ee < 2 ? ++Ee : 0)] = 1, X.depth[K] = 0, X.opt_len--, ge && (X.static_len -= me[2 * K + 1]);
        for (se.max_code = Ee, z = X.heap_len >> 1; 1 <= z; z--) L(X, he, z);
        for (K = Me; z = X.heap[1], X.heap[1] = X.heap[X.heap_len--], L(X, he, 1), N = X.heap[1], X.heap[--X.heap_max] = z, X.heap[--X.heap_max] = N, he[2 * K] = he[2 * z] + he[2 * N], X.depth[K] = (X.depth[z] >= X.depth[N] ? X.depth[z] : X.depth[N]) + 1, he[2 * z + 1] = he[2 * N + 1] = K, X.heap[1] = K++, L(X, he, 1), 2 <= X.heap_len; ) ;
        X.heap[--X.heap_max] = X.heap[1], function(Ae, Xe) {
          var Oe, He, Ye, $e, Le, nt, Je = Xe.dyn_tree, bt = Xe.max_code, Se = Xe.stat_desc.static_tree, Ne = Xe.stat_desc.has_stree, Re = Xe.stat_desc.extra_bits, Be = Xe.stat_desc.extra_base, je = Xe.stat_desc.max_length, Ge = 0;
          for ($e = 0; $e <= x; $e++) Ae.bl_count[$e] = 0;
          for (Je[2 * Ae.heap[Ae.heap_max] + 1] = 0, Oe = Ae.heap_max + 1; Oe < g; Oe++) je < ($e = Je[2 * Je[2 * (He = Ae.heap[Oe]) + 1] + 1] + 1) && ($e = je, Ge++), Je[2 * He + 1] = $e, bt < He || (Ae.bl_count[$e]++, Le = 0, Be <= He && (Le = Re[He - Be]), nt = Je[2 * He], Ae.opt_len += nt * ($e + Le), Ne && (Ae.static_len += nt * (Se[2 * He + 1] + Le)));
          if (Ge !== 0) {
            do {
              for ($e = je - 1; Ae.bl_count[$e] === 0; ) $e--;
              Ae.bl_count[$e]--, Ae.bl_count[$e + 1] += 2, Ae.bl_count[je]--, Ge -= 2;
            } while (0 < Ge);
            for ($e = je; $e !== 0; $e--) for (He = Ae.bl_count[$e]; He !== 0; ) bt < (Ye = Ae.heap[--Oe]) || (Je[2 * Ye + 1] !== $e && (Ae.opt_len += ($e - Je[2 * Ye + 1]) * Je[2 * Ye], Je[2 * Ye + 1] = $e), He--);
          }
        }(X, se), Y(he, Ee, X.bl_count);
      }
      function k(X, se, z) {
        var N, K, he = -1, me = se[1], ge = 0, Me = 7, Ee = 4;
        for (me === 0 && (Me = 138, Ee = 3), se[2 * (z + 1) + 1] = 65535, N = 0; N <= z; N++) K = me, me = se[2 * (N + 1) + 1], ++ge < Me && K === me || (ge < Ee ? X.bl_tree[2 * K] += ge : K !== 0 ? (K !== he && X.bl_tree[2 * K]++, X.bl_tree[2 * C]++) : ge <= 10 ? X.bl_tree[2 * T]++ : X.bl_tree[2 * P]++, he = K, Ee = (ge = 0) === me ? (Me = 138, 3) : K === me ? (Me = 6, 3) : (Me = 7, 4));
      }
      function ne(X, se, z) {
        var N, K, he = -1, me = se[1], ge = 0, Me = 7, Ee = 4;
        for (me === 0 && (Me = 138, Ee = 3), N = 0; N <= z; N++) if (K = me, me = se[2 * (N + 1) + 1], !(++ge < Me && K === me)) {
          if (ge < Ee) for (; ce(X, K, X.bl_tree), --ge != 0; ) ;
          else K !== 0 ? (K !== he && (ce(X, K, X.bl_tree), ge--), ce(X, C, X.bl_tree), ie(X, ge - 3, 2)) : ge <= 10 ? (ce(X, T, X.bl_tree), ie(X, ge - 3, 3)) : (ce(X, P, X.bl_tree), ie(X, ge - 11, 7));
          he = K, Ee = (ge = 0) === me ? (Me = 138, 3) : K === me ? (Me = 6, 3) : (Me = 7, 4);
        }
      }
      u(re);
      var J = !1;
      function B(X, se, z, N) {
        ie(X, (d << 1) + (N ? 1 : 0), 3), function(K, he, me, ge) {
          I(K), oe(K, me), oe(K, ~me), a.arraySet(K.pending_buf, K.window, he, me, K.pending), K.pending += me;
        }(X, se, z);
      }
      o._tr_init = function(X) {
        J || (function() {
          var se, z, N, K, he, me = new Array(x + 1);
          for (K = N = 0; K < h - 1; K++) for (G[K] = N, se = 0; se < 1 << E[K]; se++) A[N++] = K;
          for (A[N - 1] = K, K = he = 0; K < 16; K++) for (re[K] = he, se = 0; se < 1 << y[K]; se++) O[he++] = K;
          for (he >>= 7; K < v; K++) for (re[K] = he << 7, se = 0; se < 1 << y[K] - 7; se++) O[256 + he++] = K;
          for (z = 0; z <= x; z++) me[z] = 0;
          for (se = 0; se <= 143; ) U[2 * se + 1] = 8, se++, me[8]++;
          for (; se <= 255; ) U[2 * se + 1] = 9, se++, me[9]++;
          for (; se <= 279; ) U[2 * se + 1] = 7, se++, me[7]++;
          for (; se <= 287; ) U[2 * se + 1] = 8, se++, me[8]++;
          for (Y(U, p + 1, me), se = 0; se < v; se++) R[2 * se + 1] = 5, R[2 * se] = V(se, 5);
          ue = new j(U, E, m + 1, p, x), Q = new j(R, y, 0, v, x), le = new j(new Array(0), w, 0, _, S);
        }(), J = !0), X.l_desc = new $(X.dyn_ltree, ue), X.d_desc = new $(X.dyn_dtree, Q), X.bl_desc = new $(X.bl_tree, le), X.bi_buf = 0, X.bi_valid = 0, H(X);
      }, o._tr_stored_block = B, o._tr_flush_block = function(X, se, z, N) {
        var K, he, me = 0;
        0 < X.level ? (X.strm.data_type === 2 && (X.strm.data_type = function(ge) {
          var Me, Ee = 4093624447;
          for (Me = 0; Me <= 31; Me++, Ee >>>= 1) if (1 & Ee && ge.dyn_ltree[2 * Me] !== 0) return l;
          if (ge.dyn_ltree[18] !== 0 || ge.dyn_ltree[20] !== 0 || ge.dyn_ltree[26] !== 0) return c;
          for (Me = 32; Me < m; Me++) if (ge.dyn_ltree[2 * Me] !== 0) return c;
          return l;
        }(X)), Z(X, X.l_desc), Z(X, X.d_desc), me = function(ge) {
          var Me;
          for (k(ge, ge.dyn_ltree, ge.l_desc.max_code), k(ge, ge.dyn_dtree, ge.d_desc.max_code), Z(ge, ge.bl_desc), Me = _ - 1; 3 <= Me && ge.bl_tree[2 * D[Me] + 1] === 0; Me--) ;
          return ge.opt_len += 3 * (Me + 1) + 5 + 5 + 4, Me;
        }(X), K = X.opt_len + 3 + 7 >>> 3, (he = X.static_len + 3 + 7 >>> 3) <= K && (K = he)) : K = he = z + 5, z + 4 <= K && se !== -1 ? B(X, se, z, N) : X.strategy === 4 || he === K ? (ie(X, 2 + (N ? 1 : 0), 3), ee(X, U, R)) : (ie(X, 4 + (N ? 1 : 0), 3), function(ge, Me, Ee, Ae) {
          var Xe;
          for (ie(ge, Me - 257, 5), ie(ge, Ee - 1, 5), ie(ge, Ae - 4, 4), Xe = 0; Xe < Ae; Xe++) ie(ge, ge.bl_tree[2 * D[Xe] + 1], 3);
          ne(ge, ge.dyn_ltree, Me - 1), ne(ge, ge.dyn_dtree, Ee - 1);
        }(X, X.l_desc.max_code + 1, X.d_desc.max_code + 1, me + 1), ee(X, X.dyn_ltree, X.dyn_dtree)), H(X), N && I(X);
      }, o._tr_tally = function(X, se, z) {
        return X.pending_buf[X.d_buf + 2 * X.last_lit] = se >>> 8 & 255, X.pending_buf[X.d_buf + 2 * X.last_lit + 1] = 255 & se, X.pending_buf[X.l_buf + X.last_lit] = 255 & z, X.last_lit++, se === 0 ? X.dyn_ltree[2 * z]++ : (X.matches++, se--, X.dyn_ltree[2 * (A[z] + m + 1)]++, X.dyn_dtree[2 * q(se)]++), X.last_lit === X.lit_bufsize - 1;
      }, o._tr_align = function(X) {
        ie(X, 2, 3), ce(X, b, U), function(se) {
          se.bi_valid === 16 ? (oe(se, se.bi_buf), se.bi_buf = 0, se.bi_valid = 0) : 8 <= se.bi_valid && (se.pending_buf[se.pending++] = 255 & se.bi_buf, se.bi_buf >>= 8, se.bi_valid -= 8);
        }(X);
      };
    }, { "../utils/common": 41 }], 53: [function(i, r, o) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(i, r, o) {
      (function(a) {
        (function(l, c) {
          if (!l.setImmediate) {
            var u, d, h, m, p = 1, v = {}, _ = !1, g = l.document, x = Object.getPrototypeOf && Object.getPrototypeOf(l);
            x = x && x.setTimeout ? x : l, u = {}.toString.call(l.process) === "[object process]" ? function(C) {
              n.nextTick(function() {
                S(C);
              });
            } : function() {
              if (l.postMessage && !l.importScripts) {
                var C = !0, T = l.onmessage;
                return l.onmessage = function() {
                  C = !1;
                }, l.postMessage("", "*"), l.onmessage = T, C;
              }
            }() ? (m = "setImmediate$" + Math.random() + "$", l.addEventListener ? l.addEventListener("message", b, !1) : l.attachEvent("onmessage", b), function(C) {
              l.postMessage(m + C, "*");
            }) : l.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(C) {
              S(C.data);
            }, function(C) {
              h.port2.postMessage(C);
            }) : g && "onreadystatechange" in g.createElement("script") ? (d = g.documentElement, function(C) {
              var T = g.createElement("script");
              T.onreadystatechange = function() {
                S(C), T.onreadystatechange = null, d.removeChild(T), T = null;
              }, d.appendChild(T);
            }) : function(C) {
              setTimeout(S, 0, C);
            }, x.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var T = new Array(arguments.length - 1), P = 0; P < T.length; P++) T[P] = arguments[P + 1];
              var E = { callback: C, args: T };
              return v[p] = E, u(p), p++;
            }, x.clearImmediate = M;
          }
          function M(C) {
            delete v[C];
          }
          function S(C) {
            if (_) setTimeout(S, 0, C);
            else {
              var T = v[C];
              if (T) {
                _ = !0;
                try {
                  (function(P) {
                    var E = P.callback, y = P.args;
                    switch (y.length) {
                      case 0:
                        E();
                        break;
                      case 1:
                        E(y[0]);
                        break;
                      case 2:
                        E(y[0], y[1]);
                        break;
                      case 3:
                        E(y[0], y[1], y[2]);
                        break;
                      default:
                        E.apply(c, y);
                    }
                  })(T);
                } finally {
                  M(C), _ = !1;
                }
              }
            }
          }
          function b(C) {
            C.source === l && typeof C.data == "string" && C.data.indexOf(m) === 0 && S(+C.data.slice(m.length));
          }
        })(typeof self > "u" ? a === void 0 ? this : a : self);
      }).call(this, typeof Ec < "u" ? Ec : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(t1);
var mH = t1.exports;
const vH = /* @__PURE__ */ pH(mH), gH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: vH
}, Symbol.toStringTag, { value: "Module" }));
export {
  mg as mountApp,
  xH as sendToComfyUI
};
