var H5 = Object.defineProperty;
var G5 = (s, e, n) => e in s ? H5(s, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : s[e] = n;
var le = (s, e, n) => G5(s, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function th(s) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of s.split(",")) e[n] = 1;
  return (n) => n in e;
}
const on = {}, na = [], Cs = () => {
}, y9 = () => !1, jc = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // uppercase letter
(s.charCodeAt(2) > 122 || s.charCodeAt(2) < 97), nh = (s) => s.startsWith("onUpdate:"), ri = Object.assign, ih = (s, e) => {
  const n = s.indexOf(e);
  n > -1 && s.splice(n, 1);
}, $5 = Object.prototype.hasOwnProperty, qt = (s, e) => $5.call(s, e), St = Array.isArray, ia = (s) => jr(s) === "[object Map]", Ma = (s) => jr(s) === "[object Set]", hf = (s) => jr(s) === "[object Date]", Et = (s) => typeof s == "function", Tn = (s) => typeof s == "string", ds = (s) => typeof s == "symbol", an = (s) => s !== null && typeof s == "object", x9 = (s) => (an(s) || Et(s)) && Et(s.then) && Et(s.catch), b9 = Object.prototype.toString, jr = (s) => b9.call(s), W5 = (s) => jr(s).slice(8, -1), _9 = (s) => jr(s) === "[object Object]", Xc = (s) => Tn(s) && s !== "NaN" && s[0] !== "-" && "" + parseInt(s, 10) === s, ur = /* @__PURE__ */ th(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Yc = (s) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = s(n));
}, j5 = /-\w/g, qi = Yc(
  (s) => s.replace(j5, (e) => e.slice(1).toUpperCase())
), X5 = /\B([A-Z])/g, F0 = Yc(
  (s) => s.replace(X5, "-$1").toLowerCase()
), qc = Yc((s) => s.charAt(0).toUpperCase() + s.slice(1)), Fu = Yc(
  (s) => s ? `on${qc(s)}` : ""
), P0 = (s, e) => !Object.is(s, e), rc = (s, ...e) => {
  for (let n = 0; n < s.length; n++)
    s[n](...e);
}, w9 = (s, e, n, i = !1) => {
  Object.defineProperty(s, e, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: n
  });
}, Zc = (s) => {
  const e = parseFloat(s);
  return isNaN(e) ? s : e;
};
let ff;
const Kc = () => ff || (ff = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function xt(s) {
  if (St(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++) {
      const i = s[n], o = Tn(i) ? K5(i) : xt(i);
      if (o)
        for (const a in o)
          e[a] = o[a];
    }
    return e;
  } else if (Tn(s) || an(s))
    return s;
}
const Y5 = /;(?![^(]*\))/g, q5 = /:([^]+)/, Z5 = /\/\*[^]*?\*\//g;
function K5(s) {
  const e = {};
  return s.replace(Z5, "").split(Y5).forEach((n) => {
    if (n) {
      const i = n.split(q5);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Le(s) {
  let e = "";
  if (Tn(s))
    e = s;
  else if (St(s))
    for (let n = 0; n < s.length; n++) {
      const i = Le(s[n]);
      i && (e += i + " ");
    }
  else if (an(s))
    for (const n in s)
      s[n] && (e += n + " ");
  return e.trim();
}
const J5 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Q5 = /* @__PURE__ */ th(J5);
function M9(s) {
  return !!s || s === "";
}
function e4(s, e) {
  if (s.length !== e.length) return !1;
  let n = !0;
  for (let i = 0; n && i < s.length; i++)
    n = Xr(s[i], e[i]);
  return n;
}
function Xr(s, e) {
  if (s === e) return !0;
  let n = hf(s), i = hf(e);
  if (n || i)
    return n && i ? s.getTime() === e.getTime() : !1;
  if (n = ds(s), i = ds(e), n || i)
    return s === e;
  if (n = St(s), i = St(e), n || i)
    return n && i ? e4(s, e) : !1;
  if (n = an(s), i = an(e), n || i) {
    if (!n || !i)
      return !1;
    const o = Object.keys(s).length, a = Object.keys(e).length;
    if (o !== a)
      return !1;
    for (const r in s) {
      const l = s.hasOwnProperty(r), c = e.hasOwnProperty(r);
      if (l && !c || !l && c || !Xr(s[r], e[r]))
        return !1;
    }
  }
  return String(s) === String(e);
}
function sh(s, e) {
  return s.findIndex((n) => Xr(n, e));
}
const S9 = (s) => !!(s && s.__v_isRef === !0), ye = (s) => Tn(s) ? s : s == null ? "" : St(s) || an(s) && (s.toString === b9 || !Et(s.toString)) ? S9(s) ? ye(s.value) : JSON.stringify(s, C9, 2) : String(s), C9 = (s, e) => S9(e) ? C9(s, e.value) : ia(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [i, o], a) => (n[Ou(i, a) + " =>"] = o, n),
    {}
  )
} : Ma(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => Ou(n))
} : ds(e) ? Ou(e) : an(e) && !St(e) && !_9(e) ? String(e) : e, Ou = (s, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    ds(s) ? `Symbol(${(n = s.description) != null ? n : e})` : s
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let ei;
class T9 {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = ei, !e && ei && (this.index = (ei.scopes || (ei.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = ei;
      try {
        return ei = this, e();
      } finally {
        ei = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = ei, ei = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (ei = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, i;
      for (n = 0, i = this.effects.length; n < i; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, i = this.cleanups.length; n < i; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, i = this.scopes.length; n < i; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const o = this.parent.scopes.pop();
        o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function E9(s) {
  return new T9(s);
}
function A9() {
  return ei;
}
function t4(s, e = !1) {
  ei && ei.cleanups.push(s);
}
let rn;
const Uu = /* @__PURE__ */ new WeakSet();
class P9 {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, ei && ei.active && ei.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Uu.has(this) && (Uu.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || D9(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, pf(this), I9(this);
    const e = rn, n = us;
    rn = this, us = !0;
    try {
      return this.fn();
    } finally {
      R9(this), rn = e, us = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        rh(e);
      this.deps = this.depsTail = void 0, pf(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Uu.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    G1(this) && this.run();
  }
  get dirty() {
    return G1(this);
  }
}
let k9 = 0, dr, hr;
function D9(s, e = !1) {
  if (s.flags |= 8, e) {
    s.next = hr, hr = s;
    return;
  }
  s.next = dr, dr = s;
}
function oh() {
  k9++;
}
function ah() {
  if (--k9 > 0)
    return;
  if (hr) {
    let e = hr;
    for (hr = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let s;
  for (; dr; ) {
    let e = dr;
    for (dr = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (i) {
          s || (s = i);
        }
      e = n;
    }
  }
  if (s) throw s;
}
function I9(s) {
  for (let e = s.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function R9(s) {
  let e, n = s.depsTail, i = n;
  for (; i; ) {
    const o = i.prevDep;
    i.version === -1 ? (i === n && (n = o), rh(i), n4(i)) : e = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = o;
  }
  s.deps = e, s.depsTail = n;
}
function G1(s) {
  for (let e = s.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (L9(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!s._dirty;
}
function L9(s) {
  if (s.flags & 4 && !(s.flags & 16) || (s.flags &= -17, s.globalVersion === Er) || (s.globalVersion = Er, !s.isSSR && s.flags & 128 && (!s.deps && !s._dirty || !G1(s))))
    return;
  s.flags |= 2;
  const e = s.dep, n = rn, i = us;
  rn = s, us = !0;
  try {
    I9(s);
    const o = s.fn(s._value);
    (e.version === 0 || P0(o, s._value)) && (s.flags |= 128, s._value = o, e.version++);
  } catch (o) {
    throw e.version++, o;
  } finally {
    rn = n, us = i, R9(s), s.flags &= -3;
  }
}
function rh(s, e = !1) {
  const { dep: n, prevSub: i, nextSub: o } = s;
  if (i && (i.nextSub = o, s.prevSub = void 0), o && (o.prevSub = i, s.nextSub = void 0), n.subs === s && (n.subs = i, !i && n.computed)) {
    n.computed.flags &= -5;
    for (let a = n.computed.deps; a; a = a.nextDep)
      rh(a, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function n4(s) {
  const { prevDep: e, nextDep: n } = s;
  e && (e.nextDep = n, s.prevDep = void 0), n && (n.prevDep = e, s.nextDep = void 0);
}
let us = !0;
const F9 = [];
function e0() {
  F9.push(us), us = !1;
}
function t0() {
  const s = F9.pop();
  us = s === void 0 ? !0 : s;
}
function pf(s) {
  const { cleanup: e } = s;
  if (s.cleanup = void 0, e) {
    const n = rn;
    rn = void 0;
    try {
      e();
    } finally {
      rn = n;
    }
  }
}
let Er = 0;
class i4 {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class lh {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!rn || !us || rn === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== rn)
      n = this.activeLink = new i4(rn, this), rn.deps ? (n.prevDep = rn.depsTail, rn.depsTail.nextDep = n, rn.depsTail = n) : rn.deps = rn.depsTail = n, O9(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const i = n.nextDep;
      i.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = i), n.prevDep = rn.depsTail, n.nextDep = void 0, rn.depsTail.nextDep = n, rn.depsTail = n, rn.deps === n && (rn.deps = i);
    }
    return n;
  }
  trigger(e) {
    this.version++, Er++, this.notify(e);
  }
  notify(e) {
    oh();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      ah();
    }
  }
}
function O9(s) {
  if (s.dep.sc++, s.sub.flags & 4) {
    const e = s.dep.computed;
    if (e && !s.dep.subs) {
      e.flags |= 20;
      for (let i = e.deps; i; i = i.nextDep)
        O9(i);
    }
    const n = s.dep.subs;
    n !== s && (s.prevSub = n, n && (n.nextSub = s)), s.dep.subs = s;
  }
}
const wc = /* @__PURE__ */ new WeakMap(), co = Symbol(
  ""
), $1 = Symbol(
  ""
), Ar = Symbol(
  ""
);
function ii(s, e, n) {
  if (us && rn) {
    let i = wc.get(s);
    i || wc.set(s, i = /* @__PURE__ */ new Map());
    let o = i.get(n);
    o || (i.set(n, o = new lh()), o.map = i, o.key = n), o.track();
  }
}
function js(s, e, n, i, o, a) {
  const r = wc.get(s);
  if (!r) {
    Er++;
    return;
  }
  const l = (c) => {
    c && c.trigger();
  };
  if (oh(), e === "clear")
    r.forEach(l);
  else {
    const c = St(s), u = c && Xc(n);
    if (c && n === "length") {
      const d = Number(i);
      r.forEach((h, p) => {
        (p === "length" || p === Ar || !ds(p) && p >= d) && l(h);
      });
    } else
      switch ((n !== void 0 || r.has(void 0)) && l(r.get(n)), u && l(r.get(Ar)), e) {
        case "add":
          c ? u && l(r.get("length")) : (l(r.get(co)), ia(s) && l(r.get($1)));
          break;
        case "delete":
          c || (l(r.get(co)), ia(s) && l(r.get($1)));
          break;
        case "set":
          ia(s) && l(r.get(co));
          break;
      }
  }
  ah();
}
function s4(s, e) {
  const n = wc.get(s);
  return n && n.get(e);
}
function So(s) {
  const e = $t(s);
  return e === s ? e : (ii(e, "iterate", Ar), Ni(s) ? e : e.map(hs));
}
function Jc(s) {
  return ii(s = $t(s), "iterate", Ar), s;
}
function M0(s, e) {
  return n0(s) ? Zs(s) ? ca(hs(e)) : ca(e) : hs(e);
}
const o4 = {
  __proto__: null,
  [Symbol.iterator]() {
    return zu(this, Symbol.iterator, (s) => M0(this, s));
  },
  concat(...s) {
    return So(this).concat(
      ...s.map((e) => St(e) ? So(e) : e)
    );
  },
  entries() {
    return zu(this, "entries", (s) => (s[1] = M0(this, s[1]), s));
  },
  every(s, e) {
    return Ds(this, "every", s, e, void 0, arguments);
  },
  filter(s, e) {
    return Ds(
      this,
      "filter",
      s,
      e,
      (n) => n.map((i) => M0(this, i)),
      arguments
    );
  },
  find(s, e) {
    return Ds(
      this,
      "find",
      s,
      e,
      (n) => M0(this, n),
      arguments
    );
  },
  findIndex(s, e) {
    return Ds(this, "findIndex", s, e, void 0, arguments);
  },
  findLast(s, e) {
    return Ds(
      this,
      "findLast",
      s,
      e,
      (n) => M0(this, n),
      arguments
    );
  },
  findLastIndex(s, e) {
    return Ds(this, "findLastIndex", s, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(s, e) {
    return Ds(this, "forEach", s, e, void 0, arguments);
  },
  includes(...s) {
    return Bu(this, "includes", s);
  },
  indexOf(...s) {
    return Bu(this, "indexOf", s);
  },
  join(s) {
    return So(this).join(s);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...s) {
    return Bu(this, "lastIndexOf", s);
  },
  map(s, e) {
    return Ds(this, "map", s, e, void 0, arguments);
  },
  pop() {
    return za(this, "pop");
  },
  push(...s) {
    return za(this, "push", s);
  },
  reduce(s, ...e) {
    return mf(this, "reduce", s, e);
  },
  reduceRight(s, ...e) {
    return mf(this, "reduceRight", s, e);
  },
  shift() {
    return za(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(s, e) {
    return Ds(this, "some", s, e, void 0, arguments);
  },
  splice(...s) {
    return za(this, "splice", s);
  },
  toReversed() {
    return So(this).toReversed();
  },
  toSorted(s) {
    return So(this).toSorted(s);
  },
  toSpliced(...s) {
    return So(this).toSpliced(...s);
  },
  unshift(...s) {
    return za(this, "unshift", s);
  },
  values() {
    return zu(this, "values", (s) => M0(this, s));
  }
};
function zu(s, e, n) {
  const i = Jc(s), o = i[e]();
  return i !== s && !Ni(s) && (o._next = o.next, o.next = () => {
    const a = o._next();
    return a.done || (a.value = n(a.value)), a;
  }), o;
}
const a4 = Array.prototype;
function Ds(s, e, n, i, o, a) {
  const r = Jc(s), l = r !== s && !Ni(s), c = r[e];
  if (c !== a4[e]) {
    const h = c.apply(s, a);
    return l ? hs(h) : h;
  }
  let u = n;
  r !== s && (l ? u = function(h, p) {
    return n.call(this, M0(s, h), p, s);
  } : n.length > 2 && (u = function(h, p) {
    return n.call(this, h, p, s);
  }));
  const d = c.call(r, u, i);
  return l && o ? o(d) : d;
}
function mf(s, e, n, i) {
  const o = Jc(s);
  let a = n;
  return o !== s && (Ni(s) ? n.length > 3 && (a = function(r, l, c) {
    return n.call(this, r, l, c, s);
  }) : a = function(r, l, c) {
    return n.call(this, r, M0(s, l), c, s);
  }), o[e](a, ...i);
}
function Bu(s, e, n) {
  const i = $t(s);
  ii(i, "iterate", Ar);
  const o = i[e](...n);
  return (o === -1 || o === !1) && Qc(n[0]) ? (n[0] = $t(n[0]), i[e](...n)) : o;
}
function za(s, e, n = []) {
  e0(), oh();
  const i = $t(s)[e].apply(s, n);
  return ah(), t0(), i;
}
const r4 = /* @__PURE__ */ th("__proto__,__v_isRef,__isVue"), U9 = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((s) => s !== "arguments" && s !== "caller").map((s) => Symbol[s]).filter(ds)
);
function l4(s) {
  ds(s) || (s = String(s));
  const e = $t(this);
  return ii(e, "has", s), e.hasOwnProperty(s);
}
class z9 {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, i) {
    if (n === "__v_skip") return e.__v_skip;
    const o = this._isReadonly, a = this._isShallow;
    if (n === "__v_isReactive")
      return !o;
    if (n === "__v_isReadonly")
      return o;
    if (n === "__v_isShallow")
      return a;
    if (n === "__v_raw")
      return i === (o ? a ? y4 : H9 : a ? V9 : N9).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
    const r = St(e);
    if (!o) {
      let c;
      if (r && (c = o4[n]))
        return c;
      if (n === "hasOwnProperty")
        return l4;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Cn(e) ? e : i
    );
    if ((ds(n) ? U9.has(n) : r4(n)) || (o || ii(e, "get", n), a))
      return l;
    if (Cn(l)) {
      const c = r && Xc(n) ? l : l.value;
      return o && an(c) ? j1(c) : c;
    }
    return an(l) ? o ? j1(l) : po(l) : l;
  }
}
class B9 extends z9 {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, i, o) {
    let a = e[n];
    const r = St(e) && Xc(n);
    if (!this._isShallow) {
      const u = n0(a);
      if (!Ni(i) && !n0(i) && (a = $t(a), i = $t(i)), !r && Cn(a) && !Cn(i))
        return u || (a.value = i), !0;
    }
    const l = r ? Number(n) < e.length : qt(e, n), c = Reflect.set(
      e,
      n,
      i,
      Cn(e) ? e : o
    );
    return e === $t(o) && (l ? P0(i, a) && js(e, "set", n, i) : js(e, "add", n, i)), c;
  }
  deleteProperty(e, n) {
    const i = qt(e, n);
    e[n];
    const o = Reflect.deleteProperty(e, n);
    return o && i && js(e, "delete", n, void 0), o;
  }
  has(e, n) {
    const i = Reflect.has(e, n);
    return (!ds(n) || !U9.has(n)) && ii(e, "has", n), i;
  }
  ownKeys(e) {
    return ii(
      e,
      "iterate",
      St(e) ? "length" : co
    ), Reflect.ownKeys(e);
  }
}
class c4 extends z9 {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return !0;
  }
  deleteProperty(e, n) {
    return !0;
  }
}
const u4 = /* @__PURE__ */ new B9(), d4 = /* @__PURE__ */ new c4(), h4 = /* @__PURE__ */ new B9(!0);
const W1 = (s) => s, al = (s) => Reflect.getPrototypeOf(s);
function f4(s, e, n) {
  return function(...i) {
    const o = this.__v_raw, a = $t(o), r = ia(a), l = s === "entries" || s === Symbol.iterator && r, c = s === "keys" && r, u = o[s](...i), d = n ? W1 : e ? ca : hs;
    return !e && ii(
      a,
      "iterate",
      c ? $1 : co
    ), {
      // iterator protocol
      next() {
        const { value: h, done: p } = u.next();
        return p ? { value: h, done: p } : {
          value: l ? [d(h[0]), d(h[1])] : d(h),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function rl(s) {
  return function(...e) {
    return s === "delete" ? !1 : s === "clear" ? void 0 : this;
  };
}
function p4(s, e) {
  const n = {
    get(o) {
      const a = this.__v_raw, r = $t(a), l = $t(o);
      s || (P0(o, l) && ii(r, "get", o), ii(r, "get", l));
      const { has: c } = al(r), u = e ? W1 : s ? ca : hs;
      if (c.call(r, o))
        return u(a.get(o));
      if (c.call(r, l))
        return u(a.get(l));
      a !== r && a.get(o);
    },
    get size() {
      const o = this.__v_raw;
      return !s && ii($t(o), "iterate", co), o.size;
    },
    has(o) {
      const a = this.__v_raw, r = $t(a), l = $t(o);
      return s || (P0(o, l) && ii(r, "has", o), ii(r, "has", l)), o === l ? a.has(o) : a.has(o) || a.has(l);
    },
    forEach(o, a) {
      const r = this, l = r.__v_raw, c = $t(l), u = e ? W1 : s ? ca : hs;
      return !s && ii(c, "iterate", co), l.forEach((d, h) => o.call(a, u(d), u(h), r));
    }
  };
  return ri(
    n,
    s ? {
      add: rl("add"),
      set: rl("set"),
      delete: rl("delete"),
      clear: rl("clear")
    } : {
      add(o) {
        !e && !Ni(o) && !n0(o) && (o = $t(o));
        const a = $t(this);
        return al(a).has.call(a, o) || (a.add(o), js(a, "add", o, o)), this;
      },
      set(o, a) {
        !e && !Ni(a) && !n0(a) && (a = $t(a));
        const r = $t(this), { has: l, get: c } = al(r);
        let u = l.call(r, o);
        u || (o = $t(o), u = l.call(r, o));
        const d = c.call(r, o);
        return r.set(o, a), u ? P0(a, d) && js(r, "set", o, a) : js(r, "add", o, a), this;
      },
      delete(o) {
        const a = $t(this), { has: r, get: l } = al(a);
        let c = r.call(a, o);
        c || (o = $t(o), c = r.call(a, o)), l && l.call(a, o);
        const u = a.delete(o);
        return c && js(a, "delete", o, void 0), u;
      },
      clear() {
        const o = $t(this), a = o.size !== 0, r = o.clear();
        return a && js(
          o,
          "clear",
          void 0,
          void 0
        ), r;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((o) => {
    n[o] = f4(o, s, e);
  }), n;
}
function ch(s, e) {
  const n = p4(s, e);
  return (i, o, a) => o === "__v_isReactive" ? !s : o === "__v_isReadonly" ? s : o === "__v_raw" ? i : Reflect.get(
    qt(n, o) && o in i ? n : i,
    o,
    a
  );
}
const m4 = {
  get: /* @__PURE__ */ ch(!1, !1)
}, v4 = {
  get: /* @__PURE__ */ ch(!1, !0)
}, g4 = {
  get: /* @__PURE__ */ ch(!0, !1)
};
const N9 = /* @__PURE__ */ new WeakMap(), V9 = /* @__PURE__ */ new WeakMap(), H9 = /* @__PURE__ */ new WeakMap(), y4 = /* @__PURE__ */ new WeakMap();
function x4(s) {
  switch (s) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function b4(s) {
  return s.__v_skip || !Object.isExtensible(s) ? 0 : x4(W5(s));
}
function po(s) {
  return n0(s) ? s : uh(
    s,
    !1,
    u4,
    m4,
    N9
  );
}
function _4(s) {
  return uh(
    s,
    !1,
    h4,
    v4,
    V9
  );
}
function j1(s) {
  return uh(
    s,
    !0,
    d4,
    g4,
    H9
  );
}
function uh(s, e, n, i, o) {
  if (!an(s) || s.__v_raw && !(e && s.__v_isReactive))
    return s;
  const a = b4(s);
  if (a === 0)
    return s;
  const r = o.get(s);
  if (r)
    return r;
  const l = new Proxy(
    s,
    a === 2 ? i : n
  );
  return o.set(s, l), l;
}
function Zs(s) {
  return n0(s) ? Zs(s.__v_raw) : !!(s && s.__v_isReactive);
}
function n0(s) {
  return !!(s && s.__v_isReadonly);
}
function Ni(s) {
  return !!(s && s.__v_isShallow);
}
function Qc(s) {
  return s ? !!s.__v_raw : !1;
}
function $t(s) {
  const e = s && s.__v_raw;
  return e ? $t(e) : s;
}
function $s(s) {
  return !qt(s, "__v_skip") && Object.isExtensible(s) && w9(s, "__v_skip", !0), s;
}
const hs = (s) => an(s) ? po(s) : s, ca = (s) => an(s) ? j1(s) : s;
function Cn(s) {
  return s ? s.__v_isRef === !0 : !1;
}
function xe(s) {
  return G9(s, !1);
}
function w4(s) {
  return G9(s, !0);
}
function G9(s, e) {
  return Cn(s) ? s : new M4(s, e);
}
class M4 {
  constructor(e, n) {
    this.dep = new lh(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : $t(e), this._value = n ? e : hs(e), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, i = this.__v_isShallow || Ni(e) || n0(e);
    e = i ? e : $t(e), P0(e, n) && (this._rawValue = e, this._value = i ? e : hs(e), this.dep.trigger());
  }
}
function He(s) {
  return Cn(s) ? s.value : s;
}
const S4 = {
  get: (s, e, n) => e === "__v_raw" ? s : He(Reflect.get(s, e, n)),
  set: (s, e, n, i) => {
    const o = s[e];
    return Cn(o) && !Cn(n) ? (o.value = n, !0) : Reflect.set(s, e, n, i);
  }
};
function $9(s) {
  return Zs(s) ? s : new Proxy(s, S4);
}
function C4(s) {
  const e = St(s) ? new Array(s.length) : {};
  for (const n in s)
    e[n] = E4(s, n);
  return e;
}
class T4 {
  constructor(e, n, i) {
    this._object = e, this._key = n, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0, this._raw = $t(e);
    let o = !0, a = e;
    if (!St(e) || !Xc(String(n)))
      do
        o = !Qc(a) || Ni(a);
      while (o && (a = a.__v_raw));
    this._shallow = o;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = He(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && Cn(this._raw[this._key])) {
      const n = this._object[this._key];
      if (Cn(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return s4(this._raw, this._key);
  }
}
function E4(s, e, n) {
  return new T4(s, e, n);
}
class A4 {
  constructor(e, n, i) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new lh(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Er - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    rn !== this)
      return D9(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return L9(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function P4(s, e, n = !1) {
  let i, o;
  return Et(s) ? i = s : (i = s.get, o = s.set), new A4(i, o, n);
}
const ll = {}, Mc = /* @__PURE__ */ new WeakMap();
let K0;
function k4(s, e = !1, n = K0) {
  if (n) {
    let i = Mc.get(n);
    i || Mc.set(n, i = []), i.push(s);
  }
}
function D4(s, e, n = on) {
  const { immediate: i, deep: o, once: a, scheduler: r, augmentJob: l, call: c } = n, u = (_) => o ? _ : Ni(_) || o === !1 || o === 0 ? Xs(_, 1) : Xs(_);
  let d, h, p, f, m = !1, y = !1;
  if (Cn(s) ? (h = () => s.value, m = Ni(s)) : Zs(s) ? (h = () => u(s), m = !0) : St(s) ? (y = !0, m = s.some((_) => Zs(_) || Ni(_)), h = () => s.map((_) => {
    if (Cn(_))
      return _.value;
    if (Zs(_))
      return u(_);
    if (Et(_))
      return c ? c(_, 2) : _();
  })) : Et(s) ? e ? h = c ? () => c(s, 2) : s : h = () => {
    if (p) {
      e0();
      try {
        p();
      } finally {
        t0();
      }
    }
    const _ = K0;
    K0 = d;
    try {
      return c ? c(s, 3, [f]) : s(f);
    } finally {
      K0 = _;
    }
  } : h = Cs, e && o) {
    const _ = h, C = o === !0 ? 1 / 0 : o;
    h = () => Xs(_(), C);
  }
  const g = A9(), x = () => {
    d.stop(), g && g.active && ih(g.effects, d);
  };
  if (a && e) {
    const _ = e;
    e = (...C) => {
      _(...C), x();
    };
  }
  let w = y ? new Array(s.length).fill(ll) : ll;
  const M = (_) => {
    if (!(!(d.flags & 1) || !d.dirty && !_))
      if (e) {
        const C = d.run();
        if (o || m || (y ? C.some((T, P) => P0(T, w[P])) : P0(C, w))) {
          p && p();
          const T = K0;
          K0 = d;
          try {
            const P = [
              C,
              // pass undefined as the old value when it's changed for the first time
              w === ll ? void 0 : y && w[0] === ll ? [] : w,
              f
            ];
            w = C, c ? c(e, 3, P) : (
              // @ts-expect-error
              e(...P)
            );
          } finally {
            K0 = T;
          }
        }
      } else
        d.run();
  };
  return l && l(M), d = new P9(h), d.scheduler = r ? () => r(M, !1) : M, f = (_) => k4(_, !1, d), p = d.onStop = () => {
    const _ = Mc.get(d);
    if (_) {
      if (c)
        c(_, 4);
      else
        for (const C of _) C();
      Mc.delete(d);
    }
  }, e ? i ? M(!0) : w = d.run() : r ? r(M.bind(null, !0), !0) : d.run(), x.pause = d.pause.bind(d), x.resume = d.resume.bind(d), x.stop = x, x;
}
function Xs(s, e = 1 / 0, n) {
  if (e <= 0 || !an(s) || s.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(s) || 0) >= e))
    return s;
  if (n.set(s, e), e--, Cn(s))
    Xs(s.value, e, n);
  else if (St(s))
    for (let i = 0; i < s.length; i++)
      Xs(s[i], e, n);
  else if (Ma(s) || ia(s))
    s.forEach((i) => {
      Xs(i, e, n);
    });
  else if (_9(s)) {
    for (const i in s)
      Xs(s[i], e, n);
    for (const i of Object.getOwnPropertySymbols(s))
      Object.prototype.propertyIsEnumerable.call(s, i) && Xs(s[i], e, n);
  }
  return s;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Yr(s, e, n, i) {
  try {
    return i ? s(...i) : s();
  } catch (o) {
    eu(o, e, n);
  }
}
function Es(s, e, n, i) {
  if (Et(s)) {
    const o = Yr(s, e, n, i);
    return o && x9(o) && o.catch((a) => {
      eu(a, e, n);
    }), o;
  }
  if (St(s)) {
    const o = [];
    for (let a = 0; a < s.length; a++)
      o.push(Es(s[a], e, n, i));
    return o;
  }
}
function eu(s, e, n, i = !0) {
  const o = e ? e.vnode : null, { errorHandler: a, throwUnhandledErrorInProduction: r } = e && e.appContext.config || on;
  if (e) {
    let l = e.parent;
    const c = e.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const d = l.ec;
      if (d) {
        for (let h = 0; h < d.length; h++)
          if (d[h](s, c, u) === !1)
            return;
      }
      l = l.parent;
    }
    if (a) {
      e0(), Yr(a, null, 10, [
        s,
        c,
        u
      ]), t0();
      return;
    }
  }
  I4(s, n, o, i, r);
}
function I4(s, e, n, i = !0, o = !1) {
  if (o)
    throw s;
  console.error(s);
}
const mi = [];
let bs = -1;
const sa = [];
let S0 = null, Xo = 0;
const W9 = /* @__PURE__ */ Promise.resolve();
let Sc = null;
function Xi(s) {
  const e = Sc || W9;
  return s ? e.then(this ? s.bind(this) : s) : e;
}
function R4(s) {
  let e = bs + 1, n = mi.length;
  for (; e < n; ) {
    const i = e + n >>> 1, o = mi[i], a = Pr(o);
    a < s || a === s && o.flags & 2 ? e = i + 1 : n = i;
  }
  return e;
}
function dh(s) {
  if (!(s.flags & 1)) {
    const e = Pr(s), n = mi[mi.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(s.flags & 2) && e >= Pr(n) ? mi.push(s) : mi.splice(R4(e), 0, s), s.flags |= 1, j9();
  }
}
function j9() {
  Sc || (Sc = W9.then(Y9));
}
function L4(s) {
  St(s) ? sa.push(...s) : S0 && s.id === -1 ? S0.splice(Xo + 1, 0, s) : s.flags & 1 || (sa.push(s), s.flags |= 1), j9();
}
function vf(s, e, n = bs + 1) {
  for (; n < mi.length; n++) {
    const i = mi[n];
    if (i && i.flags & 2) {
      if (s && i.id !== s.uid)
        continue;
      mi.splice(n, 1), n--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function X9(s) {
  if (sa.length) {
    const e = [...new Set(sa)].sort(
      (n, i) => Pr(n) - Pr(i)
    );
    if (sa.length = 0, S0) {
      S0.push(...e);
      return;
    }
    for (S0 = e, Xo = 0; Xo < S0.length; Xo++) {
      const n = S0[Xo];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    S0 = null, Xo = 0;
  }
}
const Pr = (s) => s.id == null ? s.flags & 2 ? -1 : 1 / 0 : s.id;
function Y9(s) {
  try {
    for (bs = 0; bs < mi.length; bs++) {
      const e = mi[bs];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), Yr(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; bs < mi.length; bs++) {
      const e = mi[bs];
      e && (e.flags &= -2);
    }
    bs = -1, mi.length = 0, X9(), Sc = null, (mi.length || sa.length) && Y9();
  }
}
let jn = null, q9 = null;
function Cc(s) {
  const e = jn;
  return jn = s, q9 = s && s.type.__scopeId || null, e;
}
function ss(s, e = jn, n) {
  if (!e || s._n)
    return s;
  const i = (...o) => {
    i._d && Ac(-1);
    const a = Cc(e);
    let r;
    try {
      r = s(...o);
    } finally {
      Cc(a), i._d && Ac(1);
    }
    return r;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function st(s, e) {
  if (jn === null)
    return s;
  const n = ou(jn), i = s.dirs || (s.dirs = []);
  for (let o = 0; o < e.length; o++) {
    let [a, r, l, c = on] = e[o];
    a && (Et(a) && (a = {
      mounted: a,
      updated: a
    }), a.deep && Xs(r), i.push({
      dir: a,
      instance: n,
      value: r,
      oldValue: void 0,
      arg: l,
      modifiers: c
    }));
  }
  return s;
}
function z0(s, e, n, i) {
  const o = s.dirs, a = e && e.dirs;
  for (let r = 0; r < o.length; r++) {
    const l = o[r];
    a && (l.oldValue = a[r].value);
    let c = l.dir[i];
    c && (e0(), Es(c, n, 8, [
      s.el,
      l,
      s,
      e
    ]), t0());
  }
}
const Z9 = Symbol("_vte"), F4 = (s) => s.__isTeleport, fr = (s) => s && (s.disabled || s.disabled === ""), gf = (s) => s && (s.defer || s.defer === ""), yf = (s) => typeof SVGElement < "u" && s instanceof SVGElement, xf = (s) => typeof MathMLElement == "function" && s instanceof MathMLElement, X1 = (s, e) => {
  const n = s && s.to;
  return Tn(n) ? e ? e(n) : null : n;
}, K9 = {
  name: "Teleport",
  __isTeleport: !0,
  process(s, e, n, i, o, a, r, l, c, u) {
    const {
      mc: d,
      pc: h,
      pbc: p,
      o: { insert: f, querySelector: m, createText: y, createComment: g }
    } = u, x = fr(e.props);
    let { shapeFlag: w, children: M, dynamicChildren: _ } = e;
    if (s == null) {
      const C = e.el = y(""), T = e.anchor = y("");
      f(C, n, i), f(T, n, i);
      const P = (b, S) => {
        w & 16 && d(
          M,
          b,
          S,
          o,
          a,
          r,
          l,
          c
        );
      }, E = () => {
        const b = e.target = X1(e.props, m), S = J9(b, e, y, f);
        b && (r !== "svg" && yf(b) ? r = "svg" : r !== "mathml" && xf(b) && (r = "mathml"), o && o.isCE && (o.ce._teleportTargets || (o.ce._teleportTargets = /* @__PURE__ */ new Set())).add(b), x || (P(b, S), lc(e, !1)));
      };
      x && (P(n, T), lc(e, !0)), gf(e.props) ? (e.el.__isMounted = !1, hi(() => {
        E(), delete e.el.__isMounted;
      }, a)) : E();
    } else {
      if (gf(e.props) && s.el.__isMounted === !1) {
        hi(() => {
          K9.process(
            s,
            e,
            n,
            i,
            o,
            a,
            r,
            l,
            c,
            u
          );
        }, a);
        return;
      }
      e.el = s.el, e.targetStart = s.targetStart;
      const C = e.anchor = s.anchor, T = e.target = s.target, P = e.targetAnchor = s.targetAnchor, E = fr(s.props), b = E ? n : T, S = E ? C : P;
      if (r === "svg" || yf(T) ? r = "svg" : (r === "mathml" || xf(T)) && (r = "mathml"), _ ? (p(
        s.dynamicChildren,
        _,
        b,
        o,
        a,
        r,
        l
      ), vh(s, e, !0)) : c || h(
        s,
        e,
        b,
        S,
        o,
        a,
        r,
        l,
        !1
      ), x)
        E ? e.props && s.props && e.props.to !== s.props.to && (e.props.to = s.props.to) : cl(
          e,
          n,
          C,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (s.props && s.props.to)) {
        const A = e.target = X1(
          e.props,
          m
        );
        A && cl(
          e,
          A,
          null,
          u,
          0
        );
      } else E && cl(
        e,
        T,
        P,
        u,
        1
      );
      lc(e, x);
    }
  },
  remove(s, e, n, { um: i, o: { remove: o } }, a) {
    const {
      shapeFlag: r,
      children: l,
      anchor: c,
      targetStart: u,
      targetAnchor: d,
      target: h,
      props: p
    } = s;
    if (h && (o(u), o(d)), a && o(c), r & 16) {
      const f = a || !fr(p);
      for (let m = 0; m < l.length; m++) {
        const y = l[m];
        i(
          y,
          e,
          n,
          f,
          !!y.dynamicChildren
        );
      }
    }
  },
  move: cl,
  hydrate: O4
};
function cl(s, e, n, { o: { insert: i }, m: o }, a = 2) {
  a === 0 && i(s.targetAnchor, e, n);
  const { el: r, anchor: l, shapeFlag: c, children: u, props: d } = s, h = a === 2;
  if (h && i(r, e, n), (!h || fr(d)) && c & 16)
    for (let p = 0; p < u.length; p++)
      o(
        u[p],
        e,
        n,
        2
      );
  h && i(l, e, n);
}
function O4(s, e, n, i, o, a, {
  o: { nextSibling: r, parentNode: l, querySelector: c, insert: u, createText: d }
}, h) {
  function p(y, g, x, w) {
    g.anchor = h(
      r(y),
      g,
      l(y),
      n,
      i,
      o,
      a
    ), g.targetStart = x, g.targetAnchor = w;
  }
  const f = e.target = X1(
    e.props,
    c
  ), m = fr(e.props);
  if (f) {
    const y = f._lpa || f.firstChild;
    if (e.shapeFlag & 16)
      if (m)
        p(
          s,
          e,
          y,
          y && r(y)
        );
      else {
        e.anchor = r(s);
        let g = y;
        for (; g; ) {
          if (g && g.nodeType === 8) {
            if (g.data === "teleport start anchor")
              e.targetStart = g;
            else if (g.data === "teleport anchor") {
              e.targetAnchor = g, f._lpa = e.targetAnchor && r(e.targetAnchor);
              break;
            }
          }
          g = r(g);
        }
        e.targetAnchor || J9(f, e, d, u), h(
          y && r(y),
          e,
          f,
          n,
          i,
          o,
          a
        );
      }
    lc(e, m);
  } else m && e.shapeFlag & 16 && p(s, e, s, r(s));
  return e.anchor && r(e.anchor);
}
const R0 = K9;
function lc(s, e) {
  const n = s.ctx;
  if (n && n.ut) {
    let i, o;
    for (e ? (i = s.el, o = s.anchor) : (i = s.targetStart, o = s.targetAnchor); i && i !== o; )
      i.nodeType === 1 && i.setAttribute("data-v-owner", n.uid), i = i.nextSibling;
    n.ut();
  }
}
function J9(s, e, n, i) {
  const o = e.targetStart = n(""), a = e.targetAnchor = n("");
  return o[Z9] = a, s && (i(o, s), i(a, s)), a;
}
const U4 = Symbol("_leaveCb");
function hh(s, e) {
  s.shapeFlag & 6 && s.component ? (s.transition = e, hh(s.component.subTree, e)) : s.shapeFlag & 128 ? (s.ssContent.transition = e.clone(s.ssContent), s.ssFallback.transition = e.clone(s.ssFallback)) : s.transition = e;
}
// @__NO_SIDE_EFFECTS__
function Bt(s, e) {
  return Et(s) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    ri({ name: s.name }, e, { setup: s })
  ) : s;
}
function Q9(s) {
  s.ids = [s.ids[0] + s.ids[2]++ + "-", 0, 0];
}
const Tc = /* @__PURE__ */ new WeakMap();
function pr(s, e, n, i, o = !1) {
  if (St(s)) {
    s.forEach(
      (m, y) => pr(
        m,
        e && (St(e) ? e[y] : e),
        n,
        i,
        o
      )
    );
    return;
  }
  if (oa(i) && !o) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && pr(s, e, n, i.component.subTree);
    return;
  }
  const a = i.shapeFlag & 4 ? ou(i.component) : i.el, r = o ? null : a, { i: l, r: c } = s, u = e && e.r, d = l.refs === on ? l.refs = {} : l.refs, h = l.setupState, p = $t(h), f = h === on ? y9 : (m) => qt(p, m);
  if (u != null && u !== c) {
    if (bf(e), Tn(u))
      d[u] = null, f(u) && (h[u] = null);
    else if (Cn(u)) {
      u.value = null;
      const m = e;
      m.k && (d[m.k] = null);
    }
  }
  if (Et(c))
    Yr(c, l, 12, [r, d]);
  else {
    const m = Tn(c), y = Cn(c);
    if (m || y) {
      const g = () => {
        if (s.f) {
          const x = m ? f(c) ? h[c] : d[c] : c.value;
          if (o)
            St(x) && ih(x, a);
          else if (St(x))
            x.includes(a) || x.push(a);
          else if (m)
            d[c] = [a], f(c) && (h[c] = d[c]);
          else {
            const w = [a];
            c.value = w, s.k && (d[s.k] = w);
          }
        } else m ? (d[c] = r, f(c) && (h[c] = r)) : y && (c.value = r, s.k && (d[s.k] = r));
      };
      if (r) {
        const x = () => {
          g(), Tc.delete(s);
        };
        x.id = -1, Tc.set(s, x), hi(x, n);
      } else
        bf(s), g();
    }
  }
}
function bf(s) {
  const e = Tc.get(s);
  e && (e.flags |= 8, Tc.delete(s));
}
Kc().requestIdleCallback;
Kc().cancelIdleCallback;
const oa = (s) => !!s.type.__asyncLoader, e3 = (s) => s.type.__isKeepAlive;
function z4(s, e) {
  t3(s, "a", e);
}
function B4(s, e) {
  t3(s, "da", e);
}
function t3(s, e, n = oi) {
  const i = s.__wdc || (s.__wdc = () => {
    let o = n;
    for (; o; ) {
      if (o.isDeactivated)
        return;
      o = o.parent;
    }
    return s();
  });
  if (tu(e, i, n), n) {
    let o = n.parent;
    for (; o && o.parent; )
      e3(o.parent.vnode) && N4(i, e, n, o), o = o.parent;
  }
}
function N4(s, e, n, i) {
  const o = tu(
    e,
    s,
    i,
    !0
    /* prepend */
  );
  Un(() => {
    ih(i[e], o);
  }, n);
}
function tu(s, e, n = oi, i = !1) {
  if (n) {
    const o = n[s] || (n[s] = []), a = e.__weh || (e.__weh = (...r) => {
      e0();
      const l = qr(n), c = Es(e, n, s, r);
      return l(), t0(), c;
    });
    return i ? o.unshift(a) : o.push(a), a;
  }
}
const a0 = (s) => (e, n = oi) => {
  (!Ir || s === "sp") && tu(s, (...i) => e(...i), n);
}, V4 = a0("bm"), gn = a0("m"), H4 = a0(
  "bu"
), G4 = a0("u"), fh = a0(
  "bum"
), Un = a0("um"), $4 = a0(
  "sp"
), W4 = a0("rtg"), j4 = a0("rtc");
function X4(s, e = oi) {
  tu("ec", s, e);
}
const Y4 = "components", n3 = Symbol.for("v-ndc");
function i3(s) {
  return Tn(s) ? q4(Y4, s, !1) || s : s || n3;
}
function q4(s, e, n = !0, i = !1) {
  const o = jn || oi;
  if (o) {
    const a = o.type;
    {
      const l = B8(
        a,
        !1
      );
      if (l && (l === e || l === qi(e) || l === qc(qi(e))))
        return a;
    }
    const r = (
      // local registration
      // check instance[type] first which is resolved for options API
      _f(o[s] || a[s], e) || // global registration
      _f(o.appContext[s], e)
    );
    return !r && i ? a : r;
  }
}
function _f(s, e) {
  return s && (s[e] || s[qi(e)] || s[qc(qi(e))]);
}
function at(s, e, n, i) {
  let o;
  const a = n, r = St(s);
  if (r || Tn(s)) {
    const l = r && Zs(s);
    let c = !1, u = !1;
    l && (c = !Ni(s), u = n0(s), s = Jc(s)), o = new Array(s.length);
    for (let d = 0, h = s.length; d < h; d++)
      o[d] = e(
        c ? u ? ca(hs(s[d])) : hs(s[d]) : s[d],
        d,
        void 0,
        a
      );
  } else if (typeof s == "number") {
    o = new Array(s);
    for (let l = 0; l < s; l++)
      o[l] = e(l + 1, l, void 0, a);
  } else if (an(s))
    if (s[Symbol.iterator])
      o = Array.from(
        s,
        (l, c) => e(l, c, void 0, a)
      );
    else {
      const l = Object.keys(s);
      o = new Array(l.length);
      for (let c = 0, u = l.length; c < u; c++) {
        const d = l[c];
        o[c] = e(s[d], d, c, a);
      }
    }
  else
    o = [];
  return o;
}
function Z4(s, e, n = {}, i, o) {
  if (jn.ce || jn.parent && oa(jn.parent) && jn.parent.ce) {
    const u = Object.keys(n).length > 0;
    return se(), Tt(
      Xe,
      null,
      [Ne("slot", n, i)],
      u ? -2 : 64
    );
  }
  let a = s[e];
  a && a._c && (a._d = !1), se();
  const r = a && s3(a(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  r && r.key, c = Tt(
    Xe,
    {
      key: (l && !ds(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!r && i ? "_fb" : "")
    },
    r || [],
    r && s._ === 1 ? 64 : -2
  );
  return c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), a && a._c && (a._d = !0), c;
}
function s3(s) {
  return s.some((e) => Dr(e) ? !(e.type === i0 || e.type === Xe && !s3(e.children)) : !0) ? s : null;
}
const Y1 = (s) => s ? M3(s) ? ou(s) : Y1(s.parent) : null, mr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ ri(/* @__PURE__ */ Object.create(null), {
    $: (s) => s,
    $el: (s) => s.vnode.el,
    $data: (s) => s.data,
    $props: (s) => s.props,
    $attrs: (s) => s.attrs,
    $slots: (s) => s.slots,
    $refs: (s) => s.refs,
    $parent: (s) => Y1(s.parent),
    $root: (s) => Y1(s.root),
    $host: (s) => s.ce,
    $emit: (s) => s.emit,
    $options: (s) => a3(s),
    $forceUpdate: (s) => s.f || (s.f = () => {
      dh(s.update);
    }),
    $nextTick: (s) => s.n || (s.n = Xi.bind(s.proxy)),
    $watch: (s) => u8.bind(s)
  })
), Nu = (s, e) => s !== on && !s.__isScriptSetup && qt(s, e), K4 = {
  get({ _: s }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: i, data: o, props: a, accessCache: r, type: l, appContext: c } = s;
    if (e[0] !== "$") {
      const p = r[e];
      if (p !== void 0)
        switch (p) {
          case 1:
            return i[e];
          case 2:
            return o[e];
          case 4:
            return n[e];
          case 3:
            return a[e];
        }
      else {
        if (Nu(i, e))
          return r[e] = 1, i[e];
        if (o !== on && qt(o, e))
          return r[e] = 2, o[e];
        if (qt(a, e))
          return r[e] = 3, a[e];
        if (n !== on && qt(n, e))
          return r[e] = 4, n[e];
        q1 && (r[e] = 0);
      }
    }
    const u = mr[e];
    let d, h;
    if (u)
      return e === "$attrs" && ii(s.attrs, "get", ""), u(s);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[e])
    )
      return d;
    if (n !== on && qt(n, e))
      return r[e] = 4, n[e];
    if (
      // global properties
      h = c.config.globalProperties, qt(h, e)
    )
      return h[e];
  },
  set({ _: s }, e, n) {
    const { data: i, setupState: o, ctx: a } = s;
    return Nu(o, e) ? (o[e] = n, !0) : i !== on && qt(i, e) ? (i[e] = n, !0) : qt(s.props, e) || e[0] === "$" && e.slice(1) in s ? !1 : (a[e] = n, !0);
  },
  has({
    _: { data: s, setupState: e, accessCache: n, ctx: i, appContext: o, props: a, type: r }
  }, l) {
    let c;
    return !!(n[l] || s !== on && l[0] !== "$" && qt(s, l) || Nu(e, l) || qt(a, l) || qt(i, l) || qt(mr, l) || qt(o.config.globalProperties, l) || (c = r.__cssModules) && c[l]);
  },
  defineProperty(s, e, n) {
    return n.get != null ? s._.accessCache[e] = 0 : qt(n, "value") && this.set(s, e, n.value, null), Reflect.defineProperty(s, e, n);
  }
};
function J4() {
  return Q4().slots;
}
function Q4(s) {
  const e = su();
  return e.setupContext || (e.setupContext = C3(e));
}
function wf(s) {
  return St(s) ? s.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : s;
}
let q1 = !0;
function e8(s) {
  const e = a3(s), n = s.proxy, i = s.ctx;
  q1 = !1, e.beforeCreate && Mf(e.beforeCreate, s, "bc");
  const {
    // state
    data: o,
    computed: a,
    methods: r,
    watch: l,
    provide: c,
    inject: u,
    // lifecycle
    created: d,
    beforeMount: h,
    mounted: p,
    beforeUpdate: f,
    updated: m,
    activated: y,
    deactivated: g,
    beforeDestroy: x,
    beforeUnmount: w,
    destroyed: M,
    unmounted: _,
    render: C,
    renderTracked: T,
    renderTriggered: P,
    errorCaptured: E,
    serverPrefetch: b,
    // public API
    expose: S,
    inheritAttrs: A,
    // assets
    components: R,
    directives: k,
    filters: U
  } = e;
  if (u && t8(u, i, null), r)
    for (const fe in r) {
      const q = r[fe];
      Et(q) && (i[fe] = q.bind(n));
    }
  if (o) {
    const fe = o.call(n, n);
    an(fe) && (s.data = po(fe));
  }
  if (q1 = !0, a)
    for (const fe in a) {
      const q = a[fe], G = Et(q) ? q.bind(n, n) : Et(q.get) ? q.get.bind(n, n) : Cs, Q = !Et(q) && Et(q.set) ? q.set.bind(n) : Cs, K = Re({
        get: G,
        set: Q
      });
      Object.defineProperty(i, fe, {
        enumerable: !0,
        configurable: !0,
        get: () => K.value,
        set: (Y) => K.value = Y
      });
    }
  if (l)
    for (const fe in l)
      o3(l[fe], i, n, fe);
  if (c) {
    const fe = Et(c) ? c.call(n) : c;
    Reflect.ownKeys(fe).forEach((q) => {
      _0(q, fe[q]);
    });
  }
  d && Mf(d, s, "c");
  function W(fe, q) {
    St(q) ? q.forEach((G) => fe(G.bind(n))) : q && fe(q.bind(n));
  }
  if (W(V4, h), W(gn, p), W(H4, f), W(G4, m), W(z4, y), W(B4, g), W(X4, E), W(j4, T), W(W4, P), W(fh, w), W(Un, _), W($4, b), St(S))
    if (S.length) {
      const fe = s.exposed || (s.exposed = {});
      S.forEach((q) => {
        Object.defineProperty(fe, q, {
          get: () => n[q],
          set: (G) => n[q] = G,
          enumerable: !0
        });
      });
    } else s.exposed || (s.exposed = {});
  C && s.render === Cs && (s.render = C), A != null && (s.inheritAttrs = A), R && (s.components = R), k && (s.directives = k), b && Q9(s);
}
function t8(s, e, n = Cs) {
  St(s) && (s = Z1(s));
  for (const i in s) {
    const o = s[i];
    let a;
    an(o) ? "default" in o ? a = os(
      o.from || i,
      o.default,
      !0
    ) : a = os(o.from || i) : a = os(o), Cn(a) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => a.value,
      set: (r) => a.value = r
    }) : e[i] = a;
  }
}
function Mf(s, e, n) {
  Es(
    St(s) ? s.map((i) => i.bind(e.proxy)) : s.bind(e.proxy),
    e,
    n
  );
}
function o3(s, e, n, i) {
  let o = i.includes(".") ? c3(n, i) : () => n[i];
  if (Tn(s)) {
    const a = e[s];
    Et(a) && Ft(o, a);
  } else if (Et(s))
    Ft(o, s.bind(n));
  else if (an(s))
    if (St(s))
      s.forEach((a) => o3(a, e, n, i));
    else {
      const a = Et(s.handler) ? s.handler.bind(n) : e[s.handler];
      Et(a) && Ft(o, a, s);
    }
}
function a3(s) {
  const e = s.type, { mixins: n, extends: i } = e, {
    mixins: o,
    optionsCache: a,
    config: { optionMergeStrategies: r }
  } = s.appContext, l = a.get(e);
  let c;
  return l ? c = l : !o.length && !n && !i ? c = e : (c = {}, o.length && o.forEach(
    (u) => Ec(c, u, r, !0)
  ), Ec(c, e, r)), an(e) && a.set(e, c), c;
}
function Ec(s, e, n, i = !1) {
  const { mixins: o, extends: a } = e;
  a && Ec(s, a, n, !0), o && o.forEach(
    (r) => Ec(s, r, n, !0)
  );
  for (const r in e)
    if (!(i && r === "expose")) {
      const l = n8[r] || n && n[r];
      s[r] = l ? l(s[r], e[r]) : e[r];
    }
  return s;
}
const n8 = {
  data: Sf,
  props: Cf,
  emits: Cf,
  // objects
  methods: sr,
  computed: sr,
  // lifecycle
  beforeCreate: ci,
  created: ci,
  beforeMount: ci,
  mounted: ci,
  beforeUpdate: ci,
  updated: ci,
  beforeDestroy: ci,
  beforeUnmount: ci,
  destroyed: ci,
  unmounted: ci,
  activated: ci,
  deactivated: ci,
  errorCaptured: ci,
  serverPrefetch: ci,
  // assets
  components: sr,
  directives: sr,
  // watch
  watch: s8,
  // provide / inject
  provide: Sf,
  inject: i8
};
function Sf(s, e) {
  return e ? s ? function() {
    return ri(
      Et(s) ? s.call(this, this) : s,
      Et(e) ? e.call(this, this) : e
    );
  } : e : s;
}
function i8(s, e) {
  return sr(Z1(s), Z1(e));
}
function Z1(s) {
  if (St(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++)
      e[s[n]] = s[n];
    return e;
  }
  return s;
}
function ci(s, e) {
  return s ? [...new Set([].concat(s, e))] : e;
}
function sr(s, e) {
  return s ? ri(/* @__PURE__ */ Object.create(null), s, e) : e;
}
function Cf(s, e) {
  return s ? St(s) && St(e) ? [.../* @__PURE__ */ new Set([...s, ...e])] : ri(
    /* @__PURE__ */ Object.create(null),
    wf(s),
    wf(e ?? {})
  ) : e;
}
function s8(s, e) {
  if (!s) return e;
  if (!e) return s;
  const n = ri(/* @__PURE__ */ Object.create(null), s);
  for (const i in e)
    n[i] = ci(s[i], e[i]);
  return n;
}
function r3() {
  return {
    app: null,
    config: {
      isNativeTag: y9,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let o8 = 0;
function a8(s, e) {
  return function(i, o = null) {
    Et(i) || (i = ri({}, i)), o != null && !an(o) && (o = null);
    const a = r3(), r = /* @__PURE__ */ new WeakSet(), l = [];
    let c = !1;
    const u = a.app = {
      _uid: o8++,
      _component: i,
      _props: o,
      _container: null,
      _context: a,
      _instance: null,
      version: H8,
      get config() {
        return a.config;
      },
      set config(d) {
      },
      use(d, ...h) {
        return r.has(d) || (d && Et(d.install) ? (r.add(d), d.install(u, ...h)) : Et(d) && (r.add(d), d(u, ...h))), u;
      },
      mixin(d) {
        return a.mixins.includes(d) || a.mixins.push(d), u;
      },
      component(d, h) {
        return h ? (a.components[d] = h, u) : a.components[d];
      },
      directive(d, h) {
        return h ? (a.directives[d] = h, u) : a.directives[d];
      },
      mount(d, h, p) {
        if (!c) {
          const f = u._ceVNode || Ne(i, o);
          return f.appContext = a, p === !0 ? p = "svg" : p === !1 && (p = void 0), s(f, d, p), c = !0, u._container = d, d.__vue_app__ = u, ou(f.component);
        }
      },
      onUnmount(d) {
        l.push(d);
      },
      unmount() {
        c && (Es(
          l,
          u._instance,
          16
        ), s(null, u._container), delete u._container.__vue_app__);
      },
      provide(d, h) {
        return a.provides[d] = h, u;
      },
      runWithContext(d) {
        const h = uo;
        uo = u;
        try {
          return d();
        } finally {
          uo = h;
        }
      }
    };
    return u;
  };
}
let uo = null;
function _0(s, e) {
  if (oi) {
    let n = oi.provides;
    const i = oi.parent && oi.parent.provides;
    i === n && (n = oi.provides = Object.create(i)), n[s] = e;
  }
}
function os(s, e, n = !1) {
  const i = su();
  if (i || uo) {
    let o = uo ? uo._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (o && s in o)
      return o[s];
    if (arguments.length > 1)
      return n && Et(e) ? e.call(i && i.proxy) : e;
  }
}
function r8() {
  return !!(su() || uo);
}
const l8 = Symbol.for("v-scx"), c8 = () => os(l8);
function Ft(s, e, n) {
  return l3(s, e, n);
}
function l3(s, e, n = on) {
  const { immediate: i, deep: o, flush: a, once: r } = n, l = ri({}, n), c = e && i || !e && a !== "post";
  let u;
  if (Ir) {
    if (a === "sync") {
      const f = c8();
      u = f.__watcherHandles || (f.__watcherHandles = []);
    } else if (!c) {
      const f = () => {
      };
      return f.stop = Cs, f.resume = Cs, f.pause = Cs, f;
    }
  }
  const d = oi;
  l.call = (f, m, y) => Es(f, d, m, y);
  let h = !1;
  a === "post" ? l.scheduler = (f) => {
    hi(f, d && d.suspense);
  } : a !== "sync" && (h = !0, l.scheduler = (f, m) => {
    m ? f() : dh(f);
  }), l.augmentJob = (f) => {
    e && (f.flags |= 4), h && (f.flags |= 2, d && (f.id = d.uid, f.i = d));
  };
  const p = D4(s, e, l);
  return Ir && (u ? u.push(p) : c && p()), p;
}
function u8(s, e, n) {
  const i = this.proxy, o = Tn(s) ? s.includes(".") ? c3(i, s) : () => i[s] : s.bind(i, i);
  let a;
  Et(e) ? a = e : (a = e.handler, n = e);
  const r = qr(this), l = l3(o, a.bind(i), n);
  return r(), l;
}
function c3(s, e) {
  const n = e.split(".");
  return () => {
    let i = s;
    for (let o = 0; o < n.length && i; o++)
      i = i[n[o]];
    return i;
  };
}
const d8 = (s, e) => e === "modelValue" || e === "model-value" ? s.modelModifiers : s[`${e}Modifiers`] || s[`${qi(e)}Modifiers`] || s[`${F0(e)}Modifiers`];
function h8(s, e, ...n) {
  if (s.isUnmounted) return;
  const i = s.vnode.props || on;
  let o = n;
  const a = e.startsWith("update:"), r = a && d8(i, e.slice(7));
  r && (r.trim && (o = n.map((d) => Tn(d) ? d.trim() : d)), r.number && (o = n.map(Zc)));
  let l, c = i[l = Fu(e)] || // also try camelCase event handler (#2249)
  i[l = Fu(qi(e))];
  !c && a && (c = i[l = Fu(F0(e))]), c && Es(
    c,
    s,
    6,
    o
  );
  const u = i[l + "Once"];
  if (u) {
    if (!s.emitted)
      s.emitted = {};
    else if (s.emitted[l])
      return;
    s.emitted[l] = !0, Es(
      u,
      s,
      6,
      o
    );
  }
}
const f8 = /* @__PURE__ */ new WeakMap();
function u3(s, e, n = !1) {
  const i = n ? f8 : e.emitsCache, o = i.get(s);
  if (o !== void 0)
    return o;
  const a = s.emits;
  let r = {}, l = !1;
  if (!Et(s)) {
    const c = (u) => {
      const d = u3(u, e, !0);
      d && (l = !0, ri(r, d));
    };
    !n && e.mixins.length && e.mixins.forEach(c), s.extends && c(s.extends), s.mixins && s.mixins.forEach(c);
  }
  return !a && !l ? (an(s) && i.set(s, null), null) : (St(a) ? a.forEach((c) => r[c] = null) : ri(r, a), an(s) && i.set(s, r), r);
}
function nu(s, e) {
  return !s || !jc(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), qt(s, e[0].toLowerCase() + e.slice(1)) || qt(s, F0(e)) || qt(s, e));
}
function Tf(s) {
  const {
    type: e,
    vnode: n,
    proxy: i,
    withProxy: o,
    propsOptions: [a],
    slots: r,
    attrs: l,
    emit: c,
    render: u,
    renderCache: d,
    props: h,
    data: p,
    setupState: f,
    ctx: m,
    inheritAttrs: y
  } = s, g = Cc(s);
  let x, w;
  try {
    if (n.shapeFlag & 4) {
      const _ = o || i, C = _;
      x = Ms(
        u.call(
          C,
          _,
          d,
          h,
          f,
          p,
          m
        )
      ), w = l;
    } else {
      const _ = e;
      x = Ms(
        _.length > 1 ? _(
          h,
          { attrs: l, slots: r, emit: c }
        ) : _(
          h,
          null
        )
      ), w = e.props ? l : p8(l);
    }
  } catch (_) {
    vr.length = 0, eu(_, s, 1), x = Ne(i0);
  }
  let M = x;
  if (w && y !== !1) {
    const _ = Object.keys(w), { shapeFlag: C } = M;
    _.length && C & 7 && (a && _.some(nh) && (w = m8(
      w,
      a
    )), M = ua(M, w, !1, !0));
  }
  return n.dirs && (M = ua(M, null, !1, !0), M.dirs = M.dirs ? M.dirs.concat(n.dirs) : n.dirs), n.transition && hh(M, n.transition), x = M, Cc(g), x;
}
const p8 = (s) => {
  let e;
  for (const n in s)
    (n === "class" || n === "style" || jc(n)) && ((e || (e = {}))[n] = s[n]);
  return e;
}, m8 = (s, e) => {
  const n = {};
  for (const i in s)
    (!nh(i) || !(i.slice(9) in e)) && (n[i] = s[i]);
  return n;
};
function v8(s, e, n) {
  const { props: i, children: o, component: a } = s, { props: r, children: l, patchFlag: c } = e, u = a.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && c >= 0) {
    if (c & 1024)
      return !0;
    if (c & 16)
      return i ? Ef(i, r, u) : !!r;
    if (c & 8) {
      const d = e.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        const p = d[h];
        if (r[p] !== i[p] && !nu(u, p))
          return !0;
      }
    }
  } else
    return (o || l) && (!l || !l.$stable) ? !0 : i === r ? !1 : i ? r ? Ef(i, r, u) : !0 : !!r;
  return !1;
}
function Ef(s, e, n) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(s).length)
    return !0;
  for (let o = 0; o < i.length; o++) {
    const a = i[o];
    if (e[a] !== s[a] && !nu(n, a))
      return !0;
  }
  return !1;
}
function g8({ vnode: s, parent: e }, n) {
  for (; e; ) {
    const i = e.subTree;
    if (i.suspense && i.suspense.activeBranch === s && (i.el = s.el), i === s)
      (s = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const d3 = {}, h3 = () => Object.create(d3), f3 = (s) => Object.getPrototypeOf(s) === d3;
function y8(s, e, n, i = !1) {
  const o = {}, a = h3();
  s.propsDefaults = /* @__PURE__ */ Object.create(null), p3(s, e, o, a);
  for (const r in s.propsOptions[0])
    r in o || (o[r] = void 0);
  n ? s.props = i ? o : _4(o) : s.type.props ? s.props = o : s.props = a, s.attrs = a;
}
function x8(s, e, n, i) {
  const {
    props: o,
    attrs: a,
    vnode: { patchFlag: r }
  } = s, l = $t(o), [c] = s.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || r > 0) && !(r & 16)
  ) {
    if (r & 8) {
      const d = s.vnode.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        let p = d[h];
        if (nu(s.emitsOptions, p))
          continue;
        const f = e[p];
        if (c)
          if (qt(a, p))
            f !== a[p] && (a[p] = f, u = !0);
          else {
            const m = qi(p);
            o[m] = K1(
              c,
              l,
              m,
              f,
              s,
              !1
            );
          }
        else
          f !== a[p] && (a[p] = f, u = !0);
      }
    }
  } else {
    p3(s, e, o, a) && (u = !0);
    let d;
    for (const h in l)
      (!e || // for camelCase
      !qt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = F0(h)) === h || !qt(e, d))) && (c ? n && // for camelCase
      (n[h] !== void 0 || // for kebab-case
      n[d] !== void 0) && (o[h] = K1(
        c,
        l,
        h,
        void 0,
        s,
        !0
      )) : delete o[h]);
    if (a !== l)
      for (const h in a)
        (!e || !qt(e, h)) && (delete a[h], u = !0);
  }
  u && js(s.attrs, "set", "");
}
function p3(s, e, n, i) {
  const [o, a] = s.propsOptions;
  let r = !1, l;
  if (e)
    for (let c in e) {
      if (ur(c))
        continue;
      const u = e[c];
      let d;
      o && qt(o, d = qi(c)) ? !a || !a.includes(d) ? n[d] = u : (l || (l = {}))[d] = u : nu(s.emitsOptions, c) || (!(c in i) || u !== i[c]) && (i[c] = u, r = !0);
    }
  if (a) {
    const c = $t(n), u = l || on;
    for (let d = 0; d < a.length; d++) {
      const h = a[d];
      n[h] = K1(
        o,
        c,
        h,
        u[h],
        s,
        !qt(u, h)
      );
    }
  }
  return r;
}
function K1(s, e, n, i, o, a) {
  const r = s[n];
  if (r != null) {
    const l = qt(r, "default");
    if (l && i === void 0) {
      const c = r.default;
      if (r.type !== Function && !r.skipFactory && Et(c)) {
        const { propsDefaults: u } = o;
        if (n in u)
          i = u[n];
        else {
          const d = qr(o);
          i = u[n] = c.call(
            null,
            e
          ), d();
        }
      } else
        i = c;
      o.ce && o.ce._setProp(n, i);
    }
    r[
      0
      /* shouldCast */
    ] && (a && !l ? i = !1 : r[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === F0(n)) && (i = !0));
  }
  return i;
}
const b8 = /* @__PURE__ */ new WeakMap();
function m3(s, e, n = !1) {
  const i = n ? b8 : e.propsCache, o = i.get(s);
  if (o)
    return o;
  const a = s.props, r = {}, l = [];
  let c = !1;
  if (!Et(s)) {
    const d = (h) => {
      c = !0;
      const [p, f] = m3(h, e, !0);
      ri(r, p), f && l.push(...f);
    };
    !n && e.mixins.length && e.mixins.forEach(d), s.extends && d(s.extends), s.mixins && s.mixins.forEach(d);
  }
  if (!a && !c)
    return an(s) && i.set(s, na), na;
  if (St(a))
    for (let d = 0; d < a.length; d++) {
      const h = qi(a[d]);
      Af(h) && (r[h] = on);
    }
  else if (a)
    for (const d in a) {
      const h = qi(d);
      if (Af(h)) {
        const p = a[d], f = r[h] = St(p) || Et(p) ? { type: p } : ri({}, p), m = f.type;
        let y = !1, g = !0;
        if (St(m))
          for (let x = 0; x < m.length; ++x) {
            const w = m[x], M = Et(w) && w.name;
            if (M === "Boolean") {
              y = !0;
              break;
            } else M === "String" && (g = !1);
          }
        else
          y = Et(m) && m.name === "Boolean";
        f[
          0
          /* shouldCast */
        ] = y, f[
          1
          /* shouldCastTrue */
        ] = g, (y || qt(f, "default")) && l.push(h);
      }
    }
  const u = [r, l];
  return an(s) && i.set(s, u), u;
}
function Af(s) {
  return s[0] !== "$" && !ur(s);
}
const ph = (s) => s === "_" || s === "_ctx" || s === "$stable", mh = (s) => St(s) ? s.map(Ms) : [Ms(s)], _8 = (s, e, n) => {
  if (e._n)
    return e;
  const i = ss((...o) => mh(e(...o)), n);
  return i._c = !1, i;
}, v3 = (s, e, n) => {
  const i = s._ctx;
  for (const o in s) {
    if (ph(o)) continue;
    const a = s[o];
    if (Et(a))
      e[o] = _8(o, a, i);
    else if (a != null) {
      const r = mh(a);
      e[o] = () => r;
    }
  }
}, g3 = (s, e) => {
  const n = mh(e);
  s.slots.default = () => n;
}, y3 = (s, e, n) => {
  for (const i in e)
    (n || !ph(i)) && (s[i] = e[i]);
}, w8 = (s, e, n) => {
  const i = s.slots = h3();
  if (s.vnode.shapeFlag & 32) {
    const o = e._;
    o ? (y3(i, e, n), n && w9(i, "_", o, !0)) : v3(e, i);
  } else e && g3(s, e);
}, M8 = (s, e, n) => {
  const { vnode: i, slots: o } = s;
  let a = !0, r = on;
  if (i.shapeFlag & 32) {
    const l = e._;
    l ? n && l === 1 ? a = !1 : y3(o, e, n) : (a = !e.$stable, v3(e, o)), r = e;
  } else e && (g3(s, e), r = { default: 1 });
  if (a)
    for (const l in o)
      !ph(l) && r[l] == null && delete o[l];
}, hi = A8;
function S8(s) {
  return C8(s);
}
function C8(s, e) {
  const n = Kc();
  n.__VUE__ = !0;
  const {
    insert: i,
    remove: o,
    patchProp: a,
    createElement: r,
    createText: l,
    createComment: c,
    setText: u,
    setElementText: d,
    parentNode: h,
    nextSibling: p,
    setScopeId: f = Cs,
    insertStaticContent: m
  } = s, y = (F, B, L, D = null, j = null, Z = null, z = void 0, $ = null, oe = !!B.dynamicChildren) => {
    if (F === B)
      return;
    F && !Ba(F, B) && (D = ie(F), Y(F, j, Z, !0), F = null), B.patchFlag === -2 && (oe = !1, B.dynamicChildren = null);
    const { type: O, ref: V, shapeFlag: H } = B;
    switch (O) {
      case iu:
        g(F, B, L, D);
        break;
      case i0:
        x(F, B, L, D);
        break;
      case cc:
        F == null && w(B, L, D, z);
        break;
      case Xe:
        R(
          F,
          B,
          L,
          D,
          j,
          Z,
          z,
          $,
          oe
        );
        break;
      default:
        H & 1 ? C(
          F,
          B,
          L,
          D,
          j,
          Z,
          z,
          $,
          oe
        ) : H & 6 ? k(
          F,
          B,
          L,
          D,
          j,
          Z,
          z,
          $,
          oe
        ) : (H & 64 || H & 128) && O.process(
          F,
          B,
          L,
          D,
          j,
          Z,
          z,
          $,
          oe,
          N
        );
    }
    V != null && j ? pr(V, F && F.ref, Z, B || F, !B) : V == null && F && F.ref != null && pr(F.ref, null, Z, F, !0);
  }, g = (F, B, L, D) => {
    if (F == null)
      i(
        B.el = l(B.children),
        L,
        D
      );
    else {
      const j = B.el = F.el;
      B.children !== F.children && u(j, B.children);
    }
  }, x = (F, B, L, D) => {
    F == null ? i(
      B.el = c(B.children || ""),
      L,
      D
    ) : B.el = F.el;
  }, w = (F, B, L, D) => {
    [F.el, F.anchor] = m(
      F.children,
      B,
      L,
      D,
      F.el,
      F.anchor
    );
  }, M = ({ el: F, anchor: B }, L, D) => {
    let j;
    for (; F && F !== B; )
      j = p(F), i(F, L, D), F = j;
    i(B, L, D);
  }, _ = ({ el: F, anchor: B }) => {
    let L;
    for (; F && F !== B; )
      L = p(F), o(F), F = L;
    o(B);
  }, C = (F, B, L, D, j, Z, z, $, oe) => {
    if (B.type === "svg" ? z = "svg" : B.type === "math" && (z = "mathml"), F == null)
      T(
        B,
        L,
        D,
        j,
        Z,
        z,
        $,
        oe
      );
    else {
      const O = F.el && F.el._isVueCE ? F.el : null;
      try {
        O && O._beginPatch(), b(
          F,
          B,
          j,
          Z,
          z,
          $,
          oe
        );
      } finally {
        O && O._endPatch();
      }
    }
  }, T = (F, B, L, D, j, Z, z, $) => {
    let oe, O;
    const { props: V, shapeFlag: H, transition: X, dirs: ue } = F;
    if (oe = F.el = r(
      F.type,
      Z,
      V && V.is,
      V
    ), H & 8 ? d(oe, F.children) : H & 16 && E(
      F.children,
      oe,
      null,
      D,
      j,
      Vu(F, Z),
      z,
      $
    ), ue && z0(F, null, D, "created"), P(oe, F, F.scopeId, z, D), V) {
      for (const _e in V)
        _e !== "value" && !ur(_e) && a(oe, _e, null, V[_e], Z, D);
      "value" in V && a(oe, "value", null, V.value, Z), (O = V.onVnodeBeforeMount) && vs(O, D, F);
    }
    ue && z0(F, null, D, "beforeMount");
    const me = T8(j, X);
    me && X.beforeEnter(oe), i(oe, B, L), ((O = V && V.onVnodeMounted) || me || ue) && hi(() => {
      O && vs(O, D, F), me && X.enter(oe), ue && z0(F, null, D, "mounted");
    }, j);
  }, P = (F, B, L, D, j) => {
    if (L && f(F, L), D)
      for (let Z = 0; Z < D.length; Z++)
        f(F, D[Z]);
    if (j) {
      let Z = j.subTree;
      if (B === Z || b3(Z.type) && (Z.ssContent === B || Z.ssFallback === B)) {
        const z = j.vnode;
        P(
          F,
          z,
          z.scopeId,
          z.slotScopeIds,
          j.parent
        );
      }
    }
  }, E = (F, B, L, D, j, Z, z, $, oe = 0) => {
    for (let O = oe; O < F.length; O++) {
      const V = F[O] = $ ? C0(F[O]) : Ms(F[O]);
      y(
        null,
        V,
        B,
        L,
        D,
        j,
        Z,
        z,
        $
      );
    }
  }, b = (F, B, L, D, j, Z, z) => {
    const $ = B.el = F.el;
    let { patchFlag: oe, dynamicChildren: O, dirs: V } = B;
    oe |= F.patchFlag & 16;
    const H = F.props || on, X = B.props || on;
    let ue;
    if (L && B0(L, !1), (ue = X.onVnodeBeforeUpdate) && vs(ue, L, B, F), V && z0(B, F, L, "beforeUpdate"), L && B0(L, !0), (H.innerHTML && X.innerHTML == null || H.textContent && X.textContent == null) && d($, ""), O ? S(
      F.dynamicChildren,
      O,
      $,
      L,
      D,
      Vu(B, j),
      Z
    ) : z || q(
      F,
      B,
      $,
      null,
      L,
      D,
      Vu(B, j),
      Z,
      !1
    ), oe > 0) {
      if (oe & 16)
        A($, H, X, L, j);
      else if (oe & 2 && H.class !== X.class && a($, "class", null, X.class, j), oe & 4 && a($, "style", H.style, X.style, j), oe & 8) {
        const me = B.dynamicProps;
        for (let _e = 0; _e < me.length; _e++) {
          const we = me[_e], Ae = H[we], Ve = X[we];
          (Ve !== Ae || we === "value") && a($, we, Ae, Ve, j, L);
        }
      }
      oe & 1 && F.children !== B.children && d($, B.children);
    } else !z && O == null && A($, H, X, L, j);
    ((ue = X.onVnodeUpdated) || V) && hi(() => {
      ue && vs(ue, L, B, F), V && z0(B, F, L, "updated");
    }, D);
  }, S = (F, B, L, D, j, Z, z) => {
    for (let $ = 0; $ < B.length; $++) {
      const oe = F[$], O = B[$], V = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oe.type === Xe || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Ba(oe, O) || // - In the case of a component, it could contain anything.
        oe.shapeFlag & 198) ? h(oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          L
        )
      );
      y(
        oe,
        O,
        V,
        null,
        D,
        j,
        Z,
        z,
        !0
      );
    }
  }, A = (F, B, L, D, j) => {
    if (B !== L) {
      if (B !== on)
        for (const Z in B)
          !ur(Z) && !(Z in L) && a(
            F,
            Z,
            B[Z],
            null,
            j,
            D
          );
      for (const Z in L) {
        if (ur(Z)) continue;
        const z = L[Z], $ = B[Z];
        z !== $ && Z !== "value" && a(F, Z, $, z, j, D);
      }
      "value" in L && a(F, "value", B.value, L.value, j);
    }
  }, R = (F, B, L, D, j, Z, z, $, oe) => {
    const O = B.el = F ? F.el : l(""), V = B.anchor = F ? F.anchor : l("");
    let { patchFlag: H, dynamicChildren: X, slotScopeIds: ue } = B;
    ue && ($ = $ ? $.concat(ue) : ue), F == null ? (i(O, L, D), i(V, L, D), E(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      B.children || [],
      L,
      V,
      j,
      Z,
      z,
      $,
      oe
    )) : H > 0 && H & 64 && X && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    F.dynamicChildren ? (S(
      F.dynamicChildren,
      X,
      L,
      j,
      Z,
      z,
      $
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (B.key != null || j && B === j.subTree) && vh(
      F,
      B,
      !0
      /* shallow */
    )) : q(
      F,
      B,
      L,
      V,
      j,
      Z,
      z,
      $,
      oe
    );
  }, k = (F, B, L, D, j, Z, z, $, oe) => {
    B.slotScopeIds = $, F == null ? B.shapeFlag & 512 ? j.ctx.activate(
      B,
      L,
      D,
      z,
      oe
    ) : U(
      B,
      L,
      D,
      j,
      Z,
      z,
      oe
    ) : I(F, B, oe);
  }, U = (F, B, L, D, j, Z, z) => {
    const $ = F.component = F8(
      F,
      D,
      j
    );
    if (e3(F) && ($.ctx.renderer = N), O8($, !1, z), $.asyncDep) {
      if (j && j.registerDep($, W, z), !F.el) {
        const oe = $.subTree = Ne(i0);
        x(null, oe, B, L), F.placeholder = oe.el;
      }
    } else
      W(
        $,
        F,
        B,
        L,
        j,
        Z,
        z
      );
  }, I = (F, B, L) => {
    const D = B.component = F.component;
    if (v8(F, B, L))
      if (D.asyncDep && !D.asyncResolved) {
        fe(D, B, L);
        return;
      } else
        D.next = B, D.update();
    else
      B.el = F.el, D.vnode = B;
  }, W = (F, B, L, D, j, Z, z) => {
    const $ = () => {
      if (F.isMounted) {
        let { next: H, bu: X, u: ue, parent: me, vnode: _e } = F;
        {
          const $e = x3(F);
          if ($e) {
            H && (H.el = _e.el, fe(F, H, z)), $e.asyncDep.then(() => {
              F.isUnmounted || $();
            });
            return;
          }
        }
        let we = H, Ae;
        B0(F, !1), H ? (H.el = _e.el, fe(F, H, z)) : H = _e, X && rc(X), (Ae = H.props && H.props.onVnodeBeforeUpdate) && vs(Ae, me, H, _e), B0(F, !0);
        const Ve = Tf(F), Fe = F.subTree;
        F.subTree = Ve, y(
          Fe,
          Ve,
          // parent may have changed if it's in a teleport
          h(Fe.el),
          // anchor may have changed if it's in a fragment
          ie(Fe),
          F,
          j,
          Z
        ), H.el = Ve.el, we === null && g8(F, Ve.el), ue && hi(ue, j), (Ae = H.props && H.props.onVnodeUpdated) && hi(
          () => vs(Ae, me, H, _e),
          j
        );
      } else {
        let H;
        const { el: X, props: ue } = B, { bm: me, m: _e, parent: we, root: Ae, type: Ve } = F, Fe = oa(B);
        B0(F, !1), me && rc(me), !Fe && (H = ue && ue.onVnodeBeforeMount) && vs(H, we, B), B0(F, !0);
        {
          Ae.ce && // @ts-expect-error _def is private
          Ae.ce._def.shadowRoot !== !1 && Ae.ce._injectChildStyle(Ve);
          const $e = F.subTree = Tf(F);
          y(
            null,
            $e,
            L,
            D,
            F,
            j,
            Z
          ), B.el = $e.el;
        }
        if (_e && hi(_e, j), !Fe && (H = ue && ue.onVnodeMounted)) {
          const $e = B;
          hi(
            () => vs(H, we, $e),
            j
          );
        }
        (B.shapeFlag & 256 || we && oa(we.vnode) && we.vnode.shapeFlag & 256) && F.a && hi(F.a, j), F.isMounted = !0, B = L = D = null;
      }
    };
    F.scope.on();
    const oe = F.effect = new P9($);
    F.scope.off();
    const O = F.update = oe.run.bind(oe), V = F.job = oe.runIfDirty.bind(oe);
    V.i = F, V.id = F.uid, oe.scheduler = () => dh(V), B0(F, !0), O();
  }, fe = (F, B, L) => {
    B.component = F;
    const D = F.vnode.props;
    F.vnode = B, F.next = null, x8(F, B.props, D, L), M8(F, B.children, L), e0(), vf(F), t0();
  }, q = (F, B, L, D, j, Z, z, $, oe = !1) => {
    const O = F && F.children, V = F ? F.shapeFlag : 0, H = B.children, { patchFlag: X, shapeFlag: ue } = B;
    if (X > 0) {
      if (X & 128) {
        Q(
          O,
          H,
          L,
          D,
          j,
          Z,
          z,
          $,
          oe
        );
        return;
      } else if (X & 256) {
        G(
          O,
          H,
          L,
          D,
          j,
          Z,
          z,
          $,
          oe
        );
        return;
      }
    }
    ue & 8 ? (V & 16 && de(O, j, Z), H !== O && d(L, H)) : V & 16 ? ue & 16 ? Q(
      O,
      H,
      L,
      D,
      j,
      Z,
      z,
      $,
      oe
    ) : de(O, j, Z, !0) : (V & 8 && d(L, ""), ue & 16 && E(
      H,
      L,
      D,
      j,
      Z,
      z,
      $,
      oe
    ));
  }, G = (F, B, L, D, j, Z, z, $, oe) => {
    F = F || na, B = B || na;
    const O = F.length, V = B.length, H = Math.min(O, V);
    let X;
    for (X = 0; X < H; X++) {
      const ue = B[X] = oe ? C0(B[X]) : Ms(B[X]);
      y(
        F[X],
        ue,
        L,
        null,
        j,
        Z,
        z,
        $,
        oe
      );
    }
    O > V ? de(
      F,
      j,
      Z,
      !0,
      !1,
      H
    ) : E(
      B,
      L,
      D,
      j,
      Z,
      z,
      $,
      oe,
      H
    );
  }, Q = (F, B, L, D, j, Z, z, $, oe) => {
    let O = 0;
    const V = B.length;
    let H = F.length - 1, X = V - 1;
    for (; O <= H && O <= X; ) {
      const ue = F[O], me = B[O] = oe ? C0(B[O]) : Ms(B[O]);
      if (Ba(ue, me))
        y(
          ue,
          me,
          L,
          null,
          j,
          Z,
          z,
          $,
          oe
        );
      else
        break;
      O++;
    }
    for (; O <= H && O <= X; ) {
      const ue = F[H], me = B[X] = oe ? C0(B[X]) : Ms(B[X]);
      if (Ba(ue, me))
        y(
          ue,
          me,
          L,
          null,
          j,
          Z,
          z,
          $,
          oe
        );
      else
        break;
      H--, X--;
    }
    if (O > H) {
      if (O <= X) {
        const ue = X + 1, me = ue < V ? B[ue].el : D;
        for (; O <= X; )
          y(
            null,
            B[O] = oe ? C0(B[O]) : Ms(B[O]),
            L,
            me,
            j,
            Z,
            z,
            $,
            oe
          ), O++;
      }
    } else if (O > X)
      for (; O <= H; )
        Y(F[O], j, Z, !0), O++;
    else {
      const ue = O, me = O, _e = /* @__PURE__ */ new Map();
      for (O = me; O <= X; O++) {
        const Ue = B[O] = oe ? C0(B[O]) : Ms(B[O]);
        Ue.key != null && _e.set(Ue.key, O);
      }
      let we, Ae = 0;
      const Ve = X - me + 1;
      let Fe = !1, $e = 0;
      const Ze = new Array(Ve);
      for (O = 0; O < Ve; O++) Ze[O] = 0;
      for (O = ue; O <= H; O++) {
        const Ue = F[O];
        if (Ae >= Ve) {
          Y(Ue, j, Z, !0);
          continue;
        }
        let rt;
        if (Ue.key != null)
          rt = _e.get(Ue.key);
        else
          for (we = me; we <= X; we++)
            if (Ze[we - me] === 0 && Ba(Ue, B[we])) {
              rt = we;
              break;
            }
        rt === void 0 ? Y(Ue, j, Z, !0) : (Ze[rt - me] = O + 1, rt >= $e ? $e = rt : Fe = !0, y(
          Ue,
          B[rt],
          L,
          null,
          j,
          Z,
          z,
          $,
          oe
        ), Ae++);
      }
      const je = Fe ? E8(Ze) : na;
      for (we = je.length - 1, O = Ve - 1; O >= 0; O--) {
        const Ue = me + O, rt = B[Ue], Qe = B[Ue + 1], yt = Ue + 1 < V ? (
          // #13559, fallback to el placeholder for unresolved async component
          Qe.el || Qe.placeholder
        ) : D;
        Ze[O] === 0 ? y(
          null,
          rt,
          L,
          yt,
          j,
          Z,
          z,
          $,
          oe
        ) : Fe && (we < 0 || O !== je[we] ? K(rt, L, yt, 2) : we--);
      }
    }
  }, K = (F, B, L, D, j = null) => {
    const { el: Z, type: z, transition: $, children: oe, shapeFlag: O } = F;
    if (O & 6) {
      K(F.component.subTree, B, L, D);
      return;
    }
    if (O & 128) {
      F.suspense.move(B, L, D);
      return;
    }
    if (O & 64) {
      z.move(F, B, L, N);
      return;
    }
    if (z === Xe) {
      i(Z, B, L);
      for (let H = 0; H < oe.length; H++)
        K(oe[H], B, L, D);
      i(F.anchor, B, L);
      return;
    }
    if (z === cc) {
      M(F, B, L);
      return;
    }
    if (D !== 2 && O & 1 && $)
      if (D === 0)
        $.beforeEnter(Z), i(Z, B, L), hi(() => $.enter(Z), j);
      else {
        const { leave: H, delayLeave: X, afterLeave: ue } = $, me = () => {
          F.ctx.isUnmounted ? o(Z) : i(Z, B, L);
        }, _e = () => {
          Z._isLeaving && Z[U4](
            !0
            /* cancelled */
          ), H(Z, () => {
            me(), ue && ue();
          });
        };
        X ? X(Z, me, _e) : _e();
      }
    else
      i(Z, B, L);
  }, Y = (F, B, L, D = !1, j = !1) => {
    const {
      type: Z,
      props: z,
      ref: $,
      children: oe,
      dynamicChildren: O,
      shapeFlag: V,
      patchFlag: H,
      dirs: X,
      cacheIndex: ue
    } = F;
    if (H === -2 && (j = !1), $ != null && (e0(), pr($, null, L, F, !0), t0()), ue != null && (B.renderCache[ue] = void 0), V & 256) {
      B.ctx.deactivate(F);
      return;
    }
    const me = V & 1 && X, _e = !oa(F);
    let we;
    if (_e && (we = z && z.onVnodeBeforeUnmount) && vs(we, B, F), V & 6)
      ae(F.component, L, D);
    else {
      if (V & 128) {
        F.suspense.unmount(L, D);
        return;
      }
      me && z0(F, null, B, "beforeUnmount"), V & 64 ? F.type.remove(
        F,
        B,
        L,
        N,
        D
      ) : O && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !O.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (Z !== Xe || H > 0 && H & 64) ? de(
        O,
        B,
        L,
        !1,
        !0
      ) : (Z === Xe && H & 384 || !j && V & 16) && de(oe, B, L), D && ee(F);
    }
    (_e && (we = z && z.onVnodeUnmounted) || me) && hi(() => {
      we && vs(we, B, F), me && z0(F, null, B, "unmounted");
    }, L);
  }, ee = (F) => {
    const { type: B, el: L, anchor: D, transition: j } = F;
    if (B === Xe) {
      ce(L, D);
      return;
    }
    if (B === cc) {
      _(F);
      return;
    }
    const Z = () => {
      o(L), j && !j.persisted && j.afterLeave && j.afterLeave();
    };
    if (F.shapeFlag & 1 && j && !j.persisted) {
      const { leave: z, delayLeave: $ } = j, oe = () => z(L, Z);
      $ ? $(F.el, Z, oe) : oe();
    } else
      Z();
  }, ce = (F, B) => {
    let L;
    for (; F !== B; )
      L = p(F), o(F), F = L;
    o(B);
  }, ae = (F, B, L) => {
    const { bum: D, scope: j, job: Z, subTree: z, um: $, m: oe, a: O } = F;
    Pf(oe), Pf(O), D && rc(D), j.stop(), Z && (Z.flags |= 8, Y(z, F, B, L)), $ && hi($, B), hi(() => {
      F.isUnmounted = !0;
    }, B);
  }, de = (F, B, L, D = !1, j = !1, Z = 0) => {
    for (let z = Z; z < F.length; z++)
      Y(F[z], B, L, D, j);
  }, ie = (F) => {
    if (F.shapeFlag & 6)
      return ie(F.component.subTree);
    if (F.shapeFlag & 128)
      return F.suspense.next();
    const B = p(F.anchor || F.el), L = B && B[Z9];
    return L ? p(L) : B;
  };
  let he = !1;
  const ne = (F, B, L) => {
    F == null ? B._vnode && Y(B._vnode, null, null, !0) : y(
      B._vnode || null,
      F,
      B,
      null,
      null,
      null,
      L
    ), B._vnode = F, he || (he = !0, vf(), X9(), he = !1);
  }, N = {
    p: y,
    um: Y,
    m: K,
    r: ee,
    mt: U,
    mc: E,
    pc: q,
    pbc: S,
    n: ie,
    o: s
  };
  return {
    render: ne,
    hydrate: void 0,
    createApp: a8(ne)
  };
}
function Vu({ type: s, props: e }, n) {
  return n === "svg" && s === "foreignObject" || n === "mathml" && s === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function B0({ effect: s, job: e }, n) {
  n ? (s.flags |= 32, e.flags |= 4) : (s.flags &= -33, e.flags &= -5);
}
function T8(s, e) {
  return (!s || s && !s.pendingBranch) && e && !e.persisted;
}
function vh(s, e, n = !1) {
  const i = s.children, o = e.children;
  if (St(i) && St(o))
    for (let a = 0; a < i.length; a++) {
      const r = i[a];
      let l = o[a];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = o[a] = C0(o[a]), l.el = r.el), !n && l.patchFlag !== -2 && vh(r, l)), l.type === iu && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = r.el), l.type === i0 && !l.el && (l.el = r.el);
    }
}
function E8(s) {
  const e = s.slice(), n = [0];
  let i, o, a, r, l;
  const c = s.length;
  for (i = 0; i < c; i++) {
    const u = s[i];
    if (u !== 0) {
      if (o = n[n.length - 1], s[o] < u) {
        e[i] = o, n.push(i);
        continue;
      }
      for (a = 0, r = n.length - 1; a < r; )
        l = a + r >> 1, s[n[l]] < u ? a = l + 1 : r = l;
      u < s[n[a]] && (a > 0 && (e[i] = n[a - 1]), n[a] = i);
    }
  }
  for (a = n.length, r = n[a - 1]; a-- > 0; )
    n[a] = r, r = e[r];
  return n;
}
function x3(s) {
  const e = s.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : x3(e);
}
function Pf(s) {
  if (s)
    for (let e = 0; e < s.length; e++)
      s[e].flags |= 8;
}
const b3 = (s) => s.__isSuspense;
function A8(s, e) {
  e && e.pendingBranch ? St(s) ? e.effects.push(...s) : e.effects.push(s) : L4(s);
}
const Xe = Symbol.for("v-fgt"), iu = Symbol.for("v-txt"), i0 = Symbol.for("v-cmt"), cc = Symbol.for("v-stc"), vr = [];
let zi = null;
function se(s = !1) {
  vr.push(zi = s ? null : []);
}
function P8() {
  vr.pop(), zi = vr[vr.length - 1] || null;
}
let kr = 1;
function Ac(s, e = !1) {
  kr += s, s < 0 && zi && e && (zi.hasOnce = !0);
}
function _3(s) {
  return s.dynamicChildren = kr > 0 ? zi || na : null, P8(), kr > 0 && zi && zi.push(s), s;
}
function re(s, e, n, i, o, a) {
  return _3(
    v(
      s,
      e,
      n,
      i,
      o,
      a,
      !0
    )
  );
}
function Tt(s, e, n, i, o) {
  return _3(
    Ne(
      s,
      e,
      n,
      i,
      o,
      !0
    )
  );
}
function Dr(s) {
  return s ? s.__v_isVNode === !0 : !1;
}
function Ba(s, e) {
  return s.type === e.type && s.key === e.key;
}
const w3 = ({ key: s }) => s ?? null, uc = ({
  ref: s,
  ref_key: e,
  ref_for: n
}) => (typeof s == "number" && (s = "" + s), s != null ? Tn(s) || Cn(s) || Et(s) ? { i: jn, r: s, k: e, f: !!n } : s : null);
function v(s, e = null, n = null, i = 0, o = null, a = s === Xe ? 0 : 1, r = !1, l = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s,
    props: e,
    key: e && w3(e),
    ref: e && uc(e),
    scopeId: q9,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a,
    patchFlag: i,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: jn
  };
  return l ? (gh(c, n), a & 128 && s.normalize(c)) : n && (c.shapeFlag |= Tn(n) ? 8 : 16), kr > 0 && // avoid a block node from tracking itself
  !r && // has current parent block
  zi && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (c.patchFlag > 0 || a & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  c.patchFlag !== 32 && zi.push(c), c;
}
const Ne = k8;
function k8(s, e = null, n = null, i = 0, o = null, a = !1) {
  if ((!s || s === n3) && (s = i0), Dr(s)) {
    const l = ua(
      s,
      e,
      !0
      /* mergeRef: true */
    );
    return n && gh(l, n), kr > 0 && !a && zi && (l.shapeFlag & 6 ? zi[zi.indexOf(s)] = l : zi.push(l)), l.patchFlag = -2, l;
  }
  if (N8(s) && (s = s.__vccOpts), e) {
    e = D8(e);
    let { class: l, style: c } = e;
    l && !Tn(l) && (e.class = Le(l)), an(c) && (Qc(c) && !St(c) && (c = ri({}, c)), e.style = xt(c));
  }
  const r = Tn(s) ? 1 : b3(s) ? 128 : F4(s) ? 64 : an(s) ? 4 : Et(s) ? 2 : 0;
  return v(
    s,
    e,
    n,
    i,
    o,
    r,
    a,
    !0
  );
}
function D8(s) {
  return s ? Qc(s) || f3(s) ? ri({}, s) : s : null;
}
function ua(s, e, n = !1, i = !1) {
  const { props: o, ref: a, patchFlag: r, children: l, transition: c } = s, u = e ? I8(o || {}, e) : o, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s.type,
    props: u,
    key: u && w3(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && a ? St(a) ? a.concat(uc(e)) : [a, uc(e)] : uc(e)
    ) : a,
    scopeId: s.scopeId,
    slotScopeIds: s.slotScopeIds,
    children: l,
    target: s.target,
    targetStart: s.targetStart,
    targetAnchor: s.targetAnchor,
    staticCount: s.staticCount,
    shapeFlag: s.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && s.type !== Xe ? r === -1 ? 16 : r | 16 : r,
    dynamicProps: s.dynamicProps,
    dynamicChildren: s.dynamicChildren,
    appContext: s.appContext,
    dirs: s.dirs,
    transition: c,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: s.component,
    suspense: s.suspense,
    ssContent: s.ssContent && ua(s.ssContent),
    ssFallback: s.ssFallback && ua(s.ssFallback),
    placeholder: s.placeholder,
    el: s.el,
    anchor: s.anchor,
    ctx: s.ctx,
    ce: s.ce
  };
  return c && i && hh(
    d,
    c.clone(d)
  ), d;
}
function ct(s = " ", e = 0) {
  return Ne(iu, null, s, e);
}
function fs(s, e) {
  const n = Ne(cc, null, s);
  return n.staticCount = e, n;
}
function Te(s = "", e = !1) {
  return e ? (se(), Tt(i0, null, s)) : Ne(i0, null, s);
}
function Ms(s) {
  return s == null || typeof s == "boolean" ? Ne(i0) : St(s) ? Ne(
    Xe,
    null,
    // #3666, avoid reference pollution when reusing vnode
    s.slice()
  ) : Dr(s) ? C0(s) : Ne(iu, null, String(s));
}
function C0(s) {
  return s.el === null && s.patchFlag !== -1 || s.memo ? s : ua(s);
}
function gh(s, e) {
  let n = 0;
  const { shapeFlag: i } = s;
  if (e == null)
    e = null;
  else if (St(e))
    n = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const o = e.default;
      o && (o._c && (o._d = !1), gh(s, o()), o._c && (o._d = !0));
      return;
    } else {
      n = 32;
      const o = e._;
      !o && !f3(e) ? e._ctx = jn : o === 3 && jn && (jn.slots._ === 1 ? e._ = 1 : (e._ = 2, s.patchFlag |= 1024));
    }
  else Et(e) ? (e = { default: e, _ctx: jn }, n = 32) : (e = String(e), i & 64 ? (n = 16, e = [ct(e)]) : n = 8);
  s.children = e, s.shapeFlag |= n;
}
function I8(...s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = s[n];
    for (const o in i)
      if (o === "class")
        e.class !== i.class && (e.class = Le([e.class, i.class]));
      else if (o === "style")
        e.style = xt([e.style, i.style]);
      else if (jc(o)) {
        const a = e[o], r = i[o];
        r && a !== r && !(St(a) && a.includes(r)) && (e[o] = a ? [].concat(a, r) : r);
      } else o !== "" && (e[o] = i[o]);
  }
  return e;
}
function vs(s, e, n, i = null) {
  Es(s, e, 7, [
    n,
    i
  ]);
}
const R8 = r3();
let L8 = 0;
function F8(s, e, n) {
  const i = s.type, o = (e ? e.appContext : s.appContext) || R8, a = {
    uid: L8++,
    vnode: s,
    type: i,
    parent: e,
    appContext: o,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new T9(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(o.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: m3(i, o),
    emitsOptions: u3(i, o),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: on,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: on,
    data: on,
    props: on,
    attrs: on,
    slots: on,
    refs: on,
    setupState: on,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return a.ctx = { _: a }, a.root = e ? e.root : a, a.emit = h8.bind(null, a), s.ce && s.ce(a), a;
}
let oi = null;
const su = () => oi || jn;
let Pc, J1;
{
  const s = Kc(), e = (n, i) => {
    let o;
    return (o = s[n]) || (o = s[n] = []), o.push(i), (a) => {
      o.length > 1 ? o.forEach((r) => r(a)) : o[0](a);
    };
  };
  Pc = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => oi = n
  ), J1 = e(
    "__VUE_SSR_SETTERS__",
    (n) => Ir = n
  );
}
const qr = (s) => {
  const e = oi;
  return Pc(s), s.scope.on(), () => {
    s.scope.off(), Pc(e);
  };
}, kf = () => {
  oi && oi.scope.off(), Pc(null);
};
function M3(s) {
  return s.vnode.shapeFlag & 4;
}
let Ir = !1;
function O8(s, e = !1, n = !1) {
  e && J1(e);
  const { props: i, children: o } = s.vnode, a = M3(s);
  y8(s, i, a, e), w8(s, o, n || e);
  const r = a ? U8(s, e) : void 0;
  return e && J1(!1), r;
}
function U8(s, e) {
  const n = s.type;
  s.accessCache = /* @__PURE__ */ Object.create(null), s.proxy = new Proxy(s.ctx, K4);
  const { setup: i } = n;
  if (i) {
    e0();
    const o = s.setupContext = i.length > 1 ? C3(s) : null, a = qr(s), r = Yr(
      i,
      s,
      0,
      [
        s.props,
        o
      ]
    ), l = x9(r);
    if (t0(), a(), (l || s.sp) && !oa(s) && Q9(s), l) {
      if (r.then(kf, kf), e)
        return r.then((c) => {
          Df(s, c);
        }).catch((c) => {
          eu(c, s, 0);
        });
      s.asyncDep = r;
    } else
      Df(s, r);
  } else
    S3(s);
}
function Df(s, e, n) {
  Et(e) ? s.type.__ssrInlineRender ? s.ssrRender = e : s.render = e : an(e) && (s.setupState = $9(e)), S3(s);
}
function S3(s, e, n) {
  const i = s.type;
  s.render || (s.render = i.render || Cs);
  {
    const o = qr(s);
    e0();
    try {
      e8(s);
    } finally {
      t0(), o();
    }
  }
}
const z8 = {
  get(s, e) {
    return ii(s, "get", ""), s[e];
  }
};
function C3(s) {
  const e = (n) => {
    s.exposed = n || {};
  };
  return {
    attrs: new Proxy(s.attrs, z8),
    slots: s.slots,
    emit: s.emit,
    expose: e
  };
}
function ou(s) {
  return s.exposed ? s.exposeProxy || (s.exposeProxy = new Proxy($9($s(s.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in mr)
        return mr[n](s);
    },
    has(e, n) {
      return n in e || n in mr;
    }
  })) : s.proxy;
}
function B8(s, e = !0) {
  return Et(s) ? s.displayName || s.name : s.name || e && s.__name;
}
function N8(s) {
  return Et(s) && "__vccOpts" in s;
}
const Re = (s, e) => P4(s, e, Ir);
function V8(s, e, n) {
  try {
    Ac(-1);
    const i = arguments.length;
    return i === 2 ? an(e) && !St(e) ? Dr(e) ? Ne(s, null, [e]) : Ne(s, e) : Ne(s, null, e) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && Dr(n) && (n = [n]), Ne(s, e, n));
  } finally {
    Ac(1);
  }
}
const H8 = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Q1;
const If = typeof window < "u" && window.trustedTypes;
if (If)
  try {
    Q1 = /* @__PURE__ */ If.createPolicy("vue", {
      createHTML: (s) => s
    });
  } catch {
  }
const T3 = Q1 ? (s) => Q1.createHTML(s) : (s) => s, G8 = "http://www.w3.org/2000/svg", $8 = "http://www.w3.org/1998/Math/MathML", Gs = typeof document < "u" ? document : null, Rf = Gs && /* @__PURE__ */ Gs.createElement("template"), W8 = {
  insert: (s, e, n) => {
    e.insertBefore(s, n || null);
  },
  remove: (s) => {
    const e = s.parentNode;
    e && e.removeChild(s);
  },
  createElement: (s, e, n, i) => {
    const o = e === "svg" ? Gs.createElementNS(G8, s) : e === "mathml" ? Gs.createElementNS($8, s) : n ? Gs.createElement(s, { is: n }) : Gs.createElement(s);
    return s === "select" && i && i.multiple != null && o.setAttribute("multiple", i.multiple), o;
  },
  createText: (s) => Gs.createTextNode(s),
  createComment: (s) => Gs.createComment(s),
  setText: (s, e) => {
    s.nodeValue = e;
  },
  setElementText: (s, e) => {
    s.textContent = e;
  },
  parentNode: (s) => s.parentNode,
  nextSibling: (s) => s.nextSibling,
  querySelector: (s) => Gs.querySelector(s),
  setScopeId(s, e) {
    s.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(s, e, n, i, o, a) {
    const r = n ? n.previousSibling : e.lastChild;
    if (o && (o === a || o.nextSibling))
      for (; e.insertBefore(o.cloneNode(!0), n), !(o === a || !(o = o.nextSibling)); )
        ;
    else {
      Rf.innerHTML = T3(
        i === "svg" ? `<svg>${s}</svg>` : i === "mathml" ? `<math>${s}</math>` : s
      );
      const l = Rf.content;
      if (i === "svg" || i === "mathml") {
        const c = l.firstChild;
        for (; c.firstChild; )
          l.appendChild(c.firstChild);
        l.removeChild(c);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      r ? r.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, j8 = Symbol("_vtc");
function X8(s, e, n) {
  const i = s[j8];
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? s.removeAttribute("class") : n ? s.setAttribute("class", e) : s.className = e;
}
const kc = Symbol("_vod"), E3 = Symbol("_vsh"), u0 = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(s, { value: e }, { transition: n }) {
    s[kc] = s.style.display === "none" ? "" : s.style.display, n && e ? n.beforeEnter(s) : Na(s, e);
  },
  mounted(s, { value: e }, { transition: n }) {
    n && e && n.enter(s);
  },
  updated(s, { value: e, oldValue: n }, { transition: i }) {
    !e != !n && (i ? e ? (i.beforeEnter(s), Na(s, !0), i.enter(s)) : i.leave(s, () => {
      Na(s, !1);
    }) : Na(s, e));
  },
  beforeUnmount(s, { value: e }) {
    Na(s, e);
  }
};
function Na(s, e) {
  s.style.display = e ? s[kc] : "none", s[E3] = !e;
}
const Y8 = Symbol(""), q8 = /(?:^|;)\s*display\s*:/;
function Z8(s, e, n) {
  const i = s.style, o = Tn(n);
  let a = !1;
  if (n && !o) {
    if (e)
      if (Tn(e))
        for (const r of e.split(";")) {
          const l = r.slice(0, r.indexOf(":")).trim();
          n[l] == null && dc(i, l, "");
        }
      else
        for (const r in e)
          n[r] == null && dc(i, r, "");
    for (const r in n)
      r === "display" && (a = !0), dc(i, r, n[r]);
  } else if (o) {
    if (e !== n) {
      const r = i[Y8];
      r && (n += ";" + r), i.cssText = n, a = q8.test(n);
    }
  } else e && s.removeAttribute("style");
  kc in s && (s[kc] = a ? i.display : "", s[E3] && (i.display = "none"));
}
const Lf = /\s*!important$/;
function dc(s, e, n) {
  if (St(n))
    n.forEach((i) => dc(s, e, i));
  else if (n == null && (n = ""), e.startsWith("--"))
    s.setProperty(e, n);
  else {
    const i = K8(s, e);
    Lf.test(n) ? s.setProperty(
      F0(i),
      n.replace(Lf, ""),
      "important"
    ) : s[i] = n;
  }
}
const Ff = ["Webkit", "Moz", "ms"], Hu = {};
function K8(s, e) {
  const n = Hu[e];
  if (n)
    return n;
  let i = qi(e);
  if (i !== "filter" && i in s)
    return Hu[e] = i;
  i = qc(i);
  for (let o = 0; o < Ff.length; o++) {
    const a = Ff[o] + i;
    if (a in s)
      return Hu[e] = a;
  }
  return e;
}
const Of = "http://www.w3.org/1999/xlink";
function Uf(s, e, n, i, o, a = Q5(e)) {
  i && e.startsWith("xlink:") ? n == null ? s.removeAttributeNS(Of, e.slice(6, e.length)) : s.setAttributeNS(Of, e, n) : n == null || a && !M9(n) ? s.removeAttribute(e) : s.setAttribute(
    e,
    a ? "" : ds(n) ? String(n) : n
  );
}
function zf(s, e, n, i, o) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (s[e] = e === "innerHTML" ? T3(n) : n);
    return;
  }
  const a = s.tagName;
  if (e === "value" && a !== "PROGRESS" && // custom elements may use _value internally
  !a.includes("-")) {
    const l = a === "OPTION" ? s.getAttribute("value") || "" : s.value, c = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      s.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== c || !("_value" in s)) && (s.value = c), n == null && s.removeAttribute(e), s._value = n;
    return;
  }
  let r = !1;
  if (n === "" || n == null) {
    const l = typeof s[e];
    l === "boolean" ? n = M9(n) : n == null && l === "string" ? (n = "", r = !0) : l === "number" && (n = 0, r = !0);
  }
  try {
    s[e] = n;
  } catch {
  }
  r && s.removeAttribute(o || e);
}
function T0(s, e, n, i) {
  s.addEventListener(e, n, i);
}
function J8(s, e, n, i) {
  s.removeEventListener(e, n, i);
}
const Bf = Symbol("_vei");
function Q8(s, e, n, i, o = null) {
  const a = s[Bf] || (s[Bf] = {}), r = a[e];
  if (i && r)
    r.value = i;
  else {
    const [l, c] = e6(e);
    if (i) {
      const u = a[e] = i6(
        i,
        o
      );
      T0(s, l, u, c);
    } else r && (J8(s, l, r, c), a[e] = void 0);
  }
}
const Nf = /(?:Once|Passive|Capture)$/;
function e6(s) {
  let e;
  if (Nf.test(s)) {
    e = {};
    let i;
    for (; i = s.match(Nf); )
      s = s.slice(0, s.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [s[2] === ":" ? s.slice(3) : F0(s.slice(2)), e];
}
let Gu = 0;
const t6 = /* @__PURE__ */ Promise.resolve(), n6 = () => Gu || (t6.then(() => Gu = 0), Gu = Date.now());
function i6(s, e) {
  const n = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= n.attached)
      return;
    Es(
      s6(i, n.value),
      e,
      5,
      [i]
    );
  };
  return n.value = s, n.attached = n6(), n;
}
function s6(s, e) {
  if (St(e)) {
    const n = s.stopImmediatePropagation;
    return s.stopImmediatePropagation = () => {
      n.call(s), s._stopped = !0;
    }, e.map(
      (i) => (o) => !o._stopped && i && i(o)
    );
  } else
    return e;
}
const Vf = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // lowercase letter
s.charCodeAt(2) > 96 && s.charCodeAt(2) < 123, o6 = (s, e, n, i, o, a) => {
  const r = o === "svg";
  e === "class" ? X8(s, i, r) : e === "style" ? Z8(s, n, i) : jc(e) ? nh(e) || Q8(s, e, n, i, a) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : a6(s, e, i, r)) ? (zf(s, e, i), !s.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Uf(s, e, i, r, a, e !== "value")) : /* #11081 force set props for possible async custom element */ s._isVueCE && (/[A-Z]/.test(e) || !Tn(i)) ? zf(s, qi(e), i, a, e) : (e === "true-value" ? s._trueValue = i : e === "false-value" && (s._falseValue = i), Uf(s, e, i, r));
};
function a6(s, e, n, i) {
  if (i)
    return !!(e === "innerHTML" || e === "textContent" || e in s && Vf(e) && Et(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && s.tagName === "IFRAME" || e === "form" || e === "list" && s.tagName === "INPUT" || e === "type" && s.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const o = s.tagName;
    if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE")
      return !1;
  }
  return Vf(e) && Tn(n) ? !1 : e in s;
}
const da = (s) => {
  const e = s.props["onUpdate:modelValue"] || !1;
  return St(e) ? (n) => rc(e, n) : e;
};
function r6(s) {
  s.target.composing = !0;
}
function Hf(s) {
  const e = s.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const Ks = Symbol("_assign");
function Gf(s, e, n) {
  return e && (s = s.trim()), n && (s = Zc(s)), s;
}
const Ot = {
  created(s, { modifiers: { lazy: e, trim: n, number: i } }, o) {
    s[Ks] = da(o);
    const a = i || o.props && o.props.type === "number";
    T0(s, e ? "change" : "input", (r) => {
      r.target.composing || s[Ks](Gf(s.value, n, a));
    }), (n || a) && T0(s, "change", () => {
      s.value = Gf(s.value, n, a);
    }), e || (T0(s, "compositionstart", r6), T0(s, "compositionend", Hf), T0(s, "change", Hf));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(s, { value: e }) {
    s.value = e ?? "";
  },
  beforeUpdate(s, { value: e, oldValue: n, modifiers: { lazy: i, trim: o, number: a } }, r) {
    if (s[Ks] = da(r), s.composing) return;
    const l = (a || s.type === "number") && !/^0\d/.test(s.value) ? Zc(s.value) : s.value, c = e ?? "";
    l !== c && (document.activeElement === s && s.type !== "range" && (i && e === n || o && s.value.trim() === c) || (s.value = c));
  }
}, Ci = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(s, e, n) {
    s[Ks] = da(n), T0(s, "change", () => {
      const i = s._modelValue, o = Rr(s), a = s.checked, r = s[Ks];
      if (St(i)) {
        const l = sh(i, o), c = l !== -1;
        if (a && !c)
          r(i.concat(o));
        else if (!a && c) {
          const u = [...i];
          u.splice(l, 1), r(u);
        }
      } else if (Ma(i)) {
        const l = new Set(i);
        a ? l.add(o) : l.delete(o), r(l);
      } else
        r(A3(s, a));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: $f,
  beforeUpdate(s, e, n) {
    s[Ks] = da(n), $f(s, e, n);
  }
};
function $f(s, { value: e, oldValue: n }, i) {
  s._modelValue = e;
  let o;
  if (St(e))
    o = sh(e, i.props.value) > -1;
  else if (Ma(e))
    o = e.has(i.props.value);
  else {
    if (e === n) return;
    o = Xr(e, A3(s, !0));
  }
  s.checked !== o && (s.checked = o);
}
const En = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(s, { value: e, modifiers: { number: n } }, i) {
    const o = Ma(e);
    T0(s, "change", () => {
      const a = Array.prototype.filter.call(s.options, (r) => r.selected).map(
        (r) => n ? Zc(Rr(r)) : Rr(r)
      );
      s[Ks](
        s.multiple ? o ? new Set(a) : a : a[0]
      ), s._assigning = !0, Xi(() => {
        s._assigning = !1;
      });
    }), s[Ks] = da(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(s, { value: e }) {
    Wf(s, e);
  },
  beforeUpdate(s, e, n) {
    s[Ks] = da(n);
  },
  updated(s, { value: e }) {
    s._assigning || Wf(s, e);
  }
};
function Wf(s, e) {
  const n = s.multiple, i = St(e);
  if (!(n && !i && !Ma(e))) {
    for (let o = 0, a = s.options.length; o < a; o++) {
      const r = s.options[o], l = Rr(r);
      if (n)
        if (i) {
          const c = typeof l;
          c === "string" || c === "number" ? r.selected = e.some((u) => String(u) === String(l)) : r.selected = sh(e, l) > -1;
        } else
          r.selected = e.has(l);
      else if (Xr(Rr(r), e)) {
        s.selectedIndex !== o && (s.selectedIndex = o);
        return;
      }
    }
    !n && s.selectedIndex !== -1 && (s.selectedIndex = -1);
  }
}
function Rr(s) {
  return "_value" in s ? s._value : s.value;
}
function A3(s, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in s ? s[n] : e;
}
const l6 = ["ctrl", "shift", "alt", "meta"], c6 = {
  stop: (s) => s.stopPropagation(),
  prevent: (s) => s.preventDefault(),
  self: (s) => s.target !== s.currentTarget,
  ctrl: (s) => !s.ctrlKey,
  shift: (s) => !s.shiftKey,
  alt: (s) => !s.altKey,
  meta: (s) => !s.metaKey,
  left: (s) => "button" in s && s.button !== 0,
  middle: (s) => "button" in s && s.button !== 1,
  right: (s) => "button" in s && s.button !== 2,
  exact: (s, e) => l6.some((n) => s[`${n}Key`] && !e.includes(n))
}, _t = (s, e) => {
  const n = s._withMods || (s._withMods = {}), i = e.join(".");
  return n[i] || (n[i] = (o, ...a) => {
    for (let r = 0; r < e.length; r++) {
      const l = c6[e[r]];
      if (l && l(o, e)) return;
    }
    return s(o, ...a);
  });
}, u6 = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Lr = (s, e) => {
  const n = s._withKeys || (s._withKeys = {}), i = e.join(".");
  return n[i] || (n[i] = (o) => {
    if (!("key" in o))
      return;
    const a = F0(o.key);
    if (e.some(
      (r) => r === a || u6[r] === a
    ))
      return s(o);
  });
}, d6 = /* @__PURE__ */ ri({ patchProp: o6 }, W8);
let jf;
function h6() {
  return jf || (jf = S8(d6));
}
const f6 = (...s) => {
  const e = h6().createApp(...s), { mount: n } = e;
  return e.mount = (i) => {
    const o = m6(i);
    if (!o) return;
    const a = e._component;
    !Et(a) && !a.render && !a.template && (a.template = o.innerHTML), o.nodeType === 1 && (o.textContent = "");
    const r = n(o, !1, p6(o));
    return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), r;
  }, e;
};
function p6(s) {
  if (s instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && s instanceof MathMLElement)
    return "mathml";
}
function m6(s) {
  return Tn(s) ? document.querySelector(s) : s;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let P3;
const au = (s) => P3 = s, k3 = (
  /* istanbul ignore next */
  Symbol()
);
function ed(s) {
  return s && typeof s == "object" && Object.prototype.toString.call(s) === "[object Object]" && typeof s.toJSON != "function";
}
var gr;
(function(s) {
  s.direct = "direct", s.patchObject = "patch object", s.patchFunction = "patch function";
})(gr || (gr = {}));
function v6() {
  const s = E9(!0), e = s.run(() => xe({}));
  let n = [], i = [];
  const o = $s({
    install(a) {
      au(o), o._a = a, a.provide(k3, o), a.config.globalProperties.$pinia = o, i.forEach((r) => n.push(r)), i = [];
    },
    use(a) {
      return this._a ? n.push(a) : i.push(a), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: s,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return o;
}
const D3 = () => {
};
function Xf(s, e, n, i = D3) {
  s.push(e);
  const o = () => {
    const a = s.indexOf(e);
    a > -1 && (s.splice(a, 1), i());
  };
  return !n && A9() && t4(o), o;
}
function Co(s, ...e) {
  s.slice().forEach((n) => {
    n(...e);
  });
}
const g6 = (s) => s(), Yf = Symbol(), $u = Symbol();
function td(s, e) {
  s instanceof Map && e instanceof Map ? e.forEach((n, i) => s.set(i, n)) : s instanceof Set && e instanceof Set && e.forEach(s.add, s);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const i = e[n], o = s[n];
    ed(o) && ed(i) && s.hasOwnProperty(n) && !Cn(i) && !Zs(i) ? s[n] = td(o, i) : s[n] = i;
  }
  return s;
}
const y6 = (
  /* istanbul ignore next */
  Symbol()
);
function x6(s) {
  return !ed(s) || !s.hasOwnProperty(y6);
}
const { assign: w0 } = Object;
function b6(s) {
  return !!(Cn(s) && s.effect);
}
function _6(s, e, n, i) {
  const { state: o, actions: a, getters: r } = e, l = n.state.value[s];
  let c;
  function u() {
    l || (n.state.value[s] = o ? o() : {});
    const d = C4(n.state.value[s]);
    return w0(d, a, Object.keys(r || {}).reduce((h, p) => (h[p] = $s(Re(() => {
      au(n);
      const f = n._s.get(s);
      return r[p].call(f, f);
    })), h), {}));
  }
  return c = I3(s, u, e, n, i, !0), c;
}
function I3(s, e, n = {}, i, o, a) {
  let r;
  const l = w0({ actions: {} }, n), c = { deep: !0 };
  let u, d, h = [], p = [], f;
  const m = i.state.value[s];
  !a && !m && (i.state.value[s] = {}), xe({});
  let y;
  function g(E) {
    let b;
    u = d = !1, typeof E == "function" ? (E(i.state.value[s]), b = {
      type: gr.patchFunction,
      storeId: s,
      events: f
    }) : (td(i.state.value[s], E), b = {
      type: gr.patchObject,
      payload: E,
      storeId: s,
      events: f
    });
    const S = y = Symbol();
    Xi().then(() => {
      y === S && (u = !0);
    }), d = !0, Co(h, b, i.state.value[s]);
  }
  const x = a ? function() {
    const { state: b } = n, S = b ? b() : {};
    this.$patch((A) => {
      w0(A, S);
    });
  } : (
    /* istanbul ignore next */
    D3
  );
  function w() {
    r.stop(), h = [], p = [], i._s.delete(s);
  }
  const M = (E, b = "") => {
    if (Yf in E)
      return E[$u] = b, E;
    const S = function() {
      au(i);
      const A = Array.from(arguments), R = [], k = [];
      function U(fe) {
        R.push(fe);
      }
      function I(fe) {
        k.push(fe);
      }
      Co(p, {
        args: A,
        name: S[$u],
        store: C,
        after: U,
        onError: I
      });
      let W;
      try {
        W = E.apply(this && this.$id === s ? this : C, A);
      } catch (fe) {
        throw Co(k, fe), fe;
      }
      return W instanceof Promise ? W.then((fe) => (Co(R, fe), fe)).catch((fe) => (Co(k, fe), Promise.reject(fe))) : (Co(R, W), W);
    };
    return S[Yf] = !0, S[$u] = b, S;
  }, _ = {
    _p: i,
    // _s: scope,
    $id: s,
    $onAction: Xf.bind(null, p),
    $patch: g,
    $reset: x,
    $subscribe(E, b = {}) {
      const S = Xf(h, E, b.detached, () => A()), A = r.run(() => Ft(() => i.state.value[s], (R) => {
        (b.flush === "sync" ? d : u) && E({
          storeId: s,
          type: gr.direct,
          events: f
        }, R);
      }, w0({}, c, b)));
      return S;
    },
    $dispose: w
  }, C = po(_);
  i._s.set(s, C);
  const P = (i._a && i._a.runWithContext || g6)(() => i._e.run(() => (r = E9()).run(() => e({ action: M }))));
  for (const E in P) {
    const b = P[E];
    if (Cn(b) && !b6(b) || Zs(b))
      a || (m && x6(b) && (Cn(b) ? b.value = m[E] : td(b, m[E])), i.state.value[s][E] = b);
    else if (typeof b == "function") {
      const S = M(b, E);
      P[E] = S, l.actions[E] = b;
    }
  }
  return w0(C, P), w0($t(C), P), Object.defineProperty(C, "$state", {
    get: () => i.state.value[s],
    set: (E) => {
      g((b) => {
        w0(b, E);
      });
    }
  }), i._p.forEach((E) => {
    w0(C, r.run(() => E({
      store: C,
      app: i._a,
      pinia: i,
      options: l
    })));
  }), m && a && n.hydrate && n.hydrate(C.$state, m), u = !0, d = !0, C;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function w6(s, e, n) {
  let i, o;
  const a = typeof e == "function";
  i = s, o = a ? n : e;
  function r(l, c) {
    const u = r8();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (u ? os(k3, null) : null), l && au(l), l = P3, l._s.has(i) || (a ? I3(i, e, o, l) : _6(i, o, l)), l._s.get(i);
  }
  return r.$id = i, r;
}
const Wu = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: !1 },
    pushOtherPanes: { type: Boolean, default: !0 },
    maximizePanes: { type: Boolean, default: !0 },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: !1 }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(s, { emit: e }) {
    const n = e, i = s, o = J4(), a = xe([]), r = Re(() => a.value.reduce((ie, he) => (ie[~~he.id] = he) && ie, {})), l = Re(() => a.value.length), c = xe(null), u = xe(!1), d = xe({
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), h = xe({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), p = Re(() => ({
      [`splitpanes splitpanes--${i.horizontal ? "horizontal" : "vertical"}`]: !0,
      "splitpanes--dragging": d.value.dragging
    })), f = () => {
      document.addEventListener("mousemove", g, { passive: !1 }), document.addEventListener("mouseup", x), "ontouchstart" in window && (document.addEventListener("touchmove", g, { passive: !1 }), document.addEventListener("touchend", x));
    }, m = () => {
      document.removeEventListener("mousemove", g, { passive: !1 }), document.removeEventListener("mouseup", x), "ontouchstart" in window && (document.removeEventListener("touchmove", g, { passive: !1 }), document.removeEventListener("touchend", x));
    }, y = (ie, he) => {
      const ne = ie.target.closest(".splitpanes__splitter");
      if (ne) {
        const { left: N, top: te } = ne.getBoundingClientRect(), { clientX: F, clientY: B } = "ontouchstart" in window && ie.touches ? ie.touches[0] : ie;
        d.value.cursorOffset = i.horizontal ? B - te : F - N;
      }
      f(), d.value.mouseDown = !0, d.value.activeSplitter = he;
    }, g = (ie) => {
      d.value.mouseDown && (ie.preventDefault(), d.value.dragging = !0, requestAnimationFrame(() => {
        P(C(ie)), ae("resize", { event: ie }, !0);
      }));
    }, x = (ie) => {
      d.value.dragging && (window.getSelection().removeAllRanges(), ae("resized", { event: ie }, !0)), d.value.mouseDown = !1, d.value.activeSplitter = null, setTimeout(() => {
        d.value.dragging = !1, m();
      }, 100);
    }, w = (ie, he) => {
      "ontouchstart" in window && (ie.preventDefault(), h.value.splitter === he ? (clearTimeout(h.value.timeoutId), h.value.timeoutId = null, M(ie, he), h.value.splitter = null) : (h.value.splitter = he, h.value.timeoutId = setTimeout(() => h.value.splitter = null, 500))), d.value.dragging || ae("splitter-click", { event: ie, index: he }, !0);
    }, M = (ie, he) => {
      if (ae("splitter-dblclick", { event: ie, index: he }, !0), i.maximizePanes) {
        let ne = 0;
        a.value = a.value.map((N, te) => (N.size = te === he ? N.max : N.min, te !== he && (ne += N.min), N)), a.value[he].size -= ne, ae("pane-maximize", { event: ie, index: he, pane: a.value[he] }), ae("resized", { event: ie, index: he }, !0);
      }
    }, _ = (ie, he) => {
      ae("pane-click", {
        event: ie,
        index: r.value[he].index,
        pane: r.value[he]
      });
    }, C = (ie) => {
      const he = c.value.getBoundingClientRect(), { clientX: ne, clientY: N } = "ontouchstart" in window && ie.touches ? ie.touches[0] : ie;
      return {
        x: ne - (i.horizontal ? 0 : d.value.cursorOffset) - he.left,
        y: N - (i.horizontal ? d.value.cursorOffset : 0) - he.top
      };
    }, T = (ie) => {
      ie = ie[i.horizontal ? "y" : "x"];
      const he = c.value[i.horizontal ? "clientHeight" : "clientWidth"];
      return i.rtl && !i.horizontal && (ie = he - ie), ie * 100 / he;
    }, P = (ie) => {
      const he = d.value.activeSplitter;
      let ne = {
        prevPanesSize: b(he),
        nextPanesSize: S(he),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const N = 0 + (i.pushOtherPanes ? 0 : ne.prevPanesSize), te = 100 - (i.pushOtherPanes ? 0 : ne.nextPanesSize), F = Math.max(Math.min(T(ie), te), N);
      let B = [he, he + 1], L = a.value[B[0]] || null, D = a.value[B[1]] || null;
      const j = L.max < 100 && F >= L.max + ne.prevPanesSize, Z = D.max < 100 && F <= 100 - (D.max + S(he + 1));
      if (j || Z) {
        j ? (L.size = L.max, D.size = Math.max(100 - L.max - ne.prevPanesSize - ne.nextPanesSize, 0)) : (L.size = Math.max(100 - D.max - ne.prevPanesSize - S(he + 1), 0), D.size = D.max);
        return;
      }
      if (i.pushOtherPanes) {
        const z = E(ne, F);
        if (!z) return;
        ({ sums: ne, panesToResize: B } = z), L = a.value[B[0]] || null, D = a.value[B[1]] || null;
      }
      L !== null && (L.size = Math.min(Math.max(F - ne.prevPanesSize - ne.prevReachedMinPanes, L.min), L.max)), D !== null && (D.size = Math.min(Math.max(100 - F - ne.nextPanesSize - ne.nextReachedMinPanes, D.min), D.max));
    }, E = (ie, he) => {
      const ne = d.value.activeSplitter, N = [ne, ne + 1];
      return he < ie.prevPanesSize + a.value[N[0]].min && (N[0] = A(ne).index, ie.prevReachedMinPanes = 0, N[0] < ne && a.value.forEach((te, F) => {
        F > N[0] && F <= ne && (te.size = te.min, ie.prevReachedMinPanes += te.min);
      }), ie.prevPanesSize = b(N[0]), N[0] === void 0) ? (ie.prevReachedMinPanes = 0, a.value[0].size = a.value[0].min, a.value.forEach((te, F) => {
        F > 0 && F <= ne && (te.size = te.min, ie.prevReachedMinPanes += te.min);
      }), a.value[N[1]].size = 100 - ie.prevReachedMinPanes - a.value[0].min - ie.prevPanesSize - ie.nextPanesSize, null) : he > 100 - ie.nextPanesSize - a.value[N[1]].min && (N[1] = R(ne).index, ie.nextReachedMinPanes = 0, N[1] > ne + 1 && a.value.forEach((te, F) => {
        F > ne && F < N[1] && (te.size = te.min, ie.nextReachedMinPanes += te.min);
      }), ie.nextPanesSize = S(N[1] - 1), N[1] === void 0) ? (ie.nextReachedMinPanes = 0, a.value.forEach((te, F) => {
        F < l.value - 1 && F >= ne + 1 && (te.size = te.min, ie.nextReachedMinPanes += te.min);
      }), a.value[N[0]].size = 100 - ie.prevPanesSize - S(N[0] - 1), null) : { sums: ie, panesToResize: N };
    }, b = (ie) => a.value.reduce((he, ne, N) => he + (N < ie ? ne.size : 0), 0), S = (ie) => a.value.reduce((he, ne, N) => he + (N > ie + 1 ? ne.size : 0), 0), A = (ie) => [...a.value].reverse().find((he) => he.index < ie && he.size > he.min) || {}, R = (ie) => a.value.find((he) => he.index > ie + 1 && he.size > he.min) || {}, k = () => {
      var ie;
      const he = Array.from(((ie = c.value) == null ? void 0 : ie.children) || []);
      for (const ne of he) {
        const N = ne.classList.contains("splitpanes__pane"), te = ne.classList.contains("splitpanes__splitter");
        !N && !te && (ne.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, U = (ie, he, ne = !1) => {
      const N = ie - 1, te = document.createElement("div");
      te.classList.add("splitpanes__splitter"), ne || (te.onmousedown = (F) => y(F, N), typeof window < "u" && "ontouchstart" in window && (te.ontouchstart = (F) => y(F, N)), te.onclick = (F) => w(F, N + 1)), te.ondblclick = (F) => M(F, N + 1), he.parentNode.insertBefore(te, he);
    }, I = (ie) => {
      ie.onmousedown = void 0, ie.onclick = void 0, ie.ondblclick = void 0, ie.remove();
    }, W = () => {
      var ie;
      const he = Array.from(((ie = c.value) == null ? void 0 : ie.children) || []);
      for (const N of he)
        N.className.includes("splitpanes__splitter") && I(N);
      let ne = 0;
      for (const N of he)
        N.className.includes("splitpanes__pane") && (!ne && i.firstSplitter ? U(ne, N, !0) : ne && U(ne, N), ne++);
    }, fe = ({ uid: ie, ...he }) => {
      const ne = r.value[ie];
      for (const [N, te] of Object.entries(he)) ne[N] = te;
    }, q = (ie) => {
      var he;
      let ne = -1;
      Array.from(((he = c.value) == null ? void 0 : he.children) || []).some((N) => (N.className.includes("splitpanes__pane") && ne++, N.isSameNode(ie.el))), a.value.splice(ne, 0, { ...ie, index: ne }), a.value.forEach((N, te) => N.index = te), u.value && Xi(() => {
        W(), Q({ addedPane: a.value[ne] }), ae("pane-add", { pane: a.value[ne] });
      });
    }, G = (ie) => {
      const he = a.value.findIndex((N) => N.id === ie);
      a.value[he].el = null;
      const ne = a.value.splice(he, 1)[0];
      a.value.forEach((N, te) => N.index = te), Xi(() => {
        W(), ae("pane-remove", { pane: ne }), Q({ removedPane: { ...ne } });
      });
    }, Q = (ie = {}) => {
      !ie.addedPane && !ie.removedPane ? Y() : a.value.some((he) => he.givenSize !== null || he.min || he.max < 100) ? ee(ie) : K(), u.value && ae("resized");
    }, K = () => {
      const ie = 100 / l.value;
      let he = 0;
      const ne = [], N = [];
      for (const te of a.value)
        te.size = Math.max(Math.min(ie, te.max), te.min), he -= te.size, te.size >= te.max && ne.push(te.id), te.size <= te.min && N.push(te.id);
      he > 0.1 && ce(he, ne, N);
    }, Y = () => {
      let ie = 100;
      const he = [], ne = [];
      let N = 0;
      for (const F of a.value)
        ie -= F.size, F.givenSize !== null && N++, F.size >= F.max && he.push(F.id), F.size <= F.min && ne.push(F.id);
      let te = 100;
      if (ie > 0.1) {
        for (const F of a.value)
          F.givenSize === null && (F.size = Math.max(Math.min(ie / (l.value - N), F.max), F.min)), te -= F.size;
        te > 0.1 && ce(te, he, ne);
      }
    }, ee = ({ addedPane: ie, removedPane: he } = {}) => {
      let ne = 100 / l.value, N = 0;
      const te = [], F = [];
      ((ie == null ? void 0 : ie.givenSize) ?? null) !== null && (ne = (100 - ie.givenSize) / (l.value - 1));
      for (const B of a.value)
        N -= B.size, B.size >= B.max && te.push(B.id), B.size <= B.min && F.push(B.id);
      if (!(Math.abs(N) < 0.1)) {
        for (const B of a.value)
          (ie == null ? void 0 : ie.givenSize) !== null && (ie == null ? void 0 : ie.id) === B.id || (B.size = Math.max(Math.min(ne, B.max), B.min)), N -= B.size, B.size >= B.max && te.push(B.id), B.size <= B.min && F.push(B.id);
        N > 0.1 && ce(N, te, F);
      }
    }, ce = (ie, he, ne) => {
      let N;
      ie > 0 ? N = ie / (l.value - he.length) : N = ie / (l.value - ne.length), a.value.forEach((te, F) => {
        if (ie > 0 && !he.includes(te.id)) {
          const B = Math.max(Math.min(te.size + N, te.max), te.min), L = B - te.size;
          ie -= L, te.size = B;
        } else if (!ne.includes(te.id)) {
          const B = Math.max(Math.min(te.size + N, te.max), te.min), L = B - te.size;
          ie -= L, te.size = B;
        }
      }), Math.abs(ie) > 0.1 && Xi(() => {
        u.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, ae = (ie, he = void 0, ne = !1) => {
      const N = (he == null ? void 0 : he.index) ?? d.value.activeSplitter ?? null;
      n(ie, {
        ...he,
        ...N !== null && { index: N },
        ...ne && N !== null && {
          prevPane: a.value[N - (i.firstSplitter ? 1 : 0)],
          nextPane: a.value[N + (i.firstSplitter ? 0 : 1)]
        },
        panes: a.value.map((te) => ({ min: te.min, max: te.max, size: te.size }))
      });
    };
    Ft(() => i.firstSplitter, () => W()), gn(() => {
      k(), W(), Q(), ae("ready"), u.value = !0;
    }), fh(() => u.value = !1);
    const de = () => {
      var ie;
      return V8(
        "div",
        { ref: c, class: p.value },
        (ie = o.default) == null ? void 0 : ie.call(o)
      );
    };
    return _0("panes", a), _0("indexedPanes", r), _0("horizontal", Re(() => i.horizontal)), _0("requestUpdate", fe), _0("onPaneAdd", q), _0("onPaneRemove", G), _0("onPaneClick", _), (ie, he) => (se(), Tt(i3(de)));
  }
}, N0 = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(s) {
    var e;
    const n = s, i = os("requestUpdate"), o = os("onPaneAdd"), a = os("horizontal"), r = os("onPaneRemove"), l = os("onPaneClick"), c = (e = su()) == null ? void 0 : e.uid, u = os("indexedPanes"), d = Re(() => u.value[c]), h = xe(null), p = Re(() => {
      const g = isNaN(n.size) || n.size === void 0 ? 0 : parseFloat(n.size);
      return Math.max(Math.min(g, m.value), f.value);
    }), f = Re(() => {
      const g = parseFloat(n.minSize);
      return isNaN(g) ? 0 : g;
    }), m = Re(() => {
      const g = parseFloat(n.maxSize);
      return isNaN(g) ? 100 : g;
    }), y = Re(() => {
      var g;
      return `${a.value ? "height" : "width"}: ${(g = d.value) == null ? void 0 : g.size}%`;
    });
    return Ft(() => p.value, (g) => i({ uid: c, size: g })), Ft(() => f.value, (g) => i({ uid: c, min: g })), Ft(() => m.value, (g) => i({ uid: c, max: g })), gn(() => {
      o({
        id: c,
        el: h.value,
        min: f.value,
        max: m.value,
        // The given size (useful to know the user intention).
        givenSize: n.size === void 0 ? null : p.value,
        size: p.value
        // The computed current size at any time.
      });
    }), fh(() => r(c)), (g, x) => (se(), re("div", {
      ref_key: "paneEl",
      ref: h,
      class: "splitpanes__pane",
      onClick: x[0] || (x[0] = (w) => He(l)(w, g._.uid)),
      style: xt(y.value)
    }, [
      Z4(g.$slots, "default")
    ], 4));
  }
}, yr = Math.PI, Dc = 1.70158, ul = Dc * 1.525, qf = Dc + 1, Zf = 2 * yr / 3, Kf = 2 * yr / 4.5, k0 = {
  // Linear - no easing
  linear: (s) => s,
  // Sine easing
  easeInSine: (s) => 1 - Math.cos(s * yr / 2),
  easeOutSine: (s) => Math.sin(s * yr / 2),
  easeInOutSine: (s) => -(Math.cos(yr * s) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // Circ (circular)
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (s) => qf * s * s * s - Dc * s * s,
  easeOutBack: (s) => 1 + qf * Math.pow(s - 1, 3) + Dc * Math.pow(s - 1, 2),
  easeInOutBack: (s) => s < 0.5 ? Math.pow(2 * s, 2) * ((ul + 1) * 2 * s - ul) / 2 : (Math.pow(2 * s - 2, 2) * ((ul + 1) * (s * 2 - 2) + ul) + 2) / 2,
  // Elastic
  easeInElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * Zf),
  easeOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * Zf) + 1,
  easeInOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * Kf)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * Kf) / 2 + 1,
  // Bounce
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInBounce: (s) => 1 - k0.easeOutBounce(1 - s),
  easeInOutBounce: (s) => s < 0.5 ? (1 - k0.easeOutBounce(1 - 2 * s)) / 2 : (1 + k0.easeOutBounce(2 * s - 1)) / 2
};
function R3(s) {
  return s in k0 ? k0[s] : k0.linear;
}
const Jf = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
  none: 4
}, Ic = {
  level: "warn",
  prefix: "[Weyl]"
};
function Is(s) {
  return Jf[s] >= Jf[Ic.level];
}
function To(s, e, n) {
  const i = [];
  return i.push(Ic.prefix), e && i.push(`[${e}]`), i.push(n), i.join(" ");
}
function r0(s) {
  return {
    debug(e, ...n) {
      Is("debug") && console.log(To("DEBUG", s, e), ...n);
    },
    info(e, ...n) {
      Is("info") && console.info(To("INFO", s, e), ...n);
    },
    warn(e, ...n) {
      Is("warn") && console.warn(To("WARN", s, e), ...n);
    },
    error(e, ...n) {
      Is("error") && console.error(To("ERROR", s, e), ...n);
    },
    /**
     * Log with a specific level
     */
    log(e, n, ...i) {
      switch (e) {
        case "debug":
          this.debug(n, ...i);
          break;
        case "info":
          this.info(n, ...i);
          break;
        case "warn":
          this.warn(n, ...i);
          break;
        case "error":
          this.error(n, ...i);
          break;
      }
    },
    /**
     * Group related logs (collapsible in console)
     */
    group(e) {
      Is("debug") && console.group(To("", s, e));
    },
    groupEnd() {
      Is("debug") && console.groupEnd();
    },
    /**
     * Log a table (useful for arrays/objects)
     */
    table(e) {
      Is("debug") && (console.log(To("", s, "Table:")), console.table(e));
    },
    /**
     * Measure time for an operation
     */
    time(e) {
      Is("debug") && console.time(`${Ic.prefix} [${s}] ${e}`);
    },
    timeEnd(e) {
      Is("debug") && console.timeEnd(`${Ic.prefix} [${s}] ${e}`);
    }
  };
}
const bt = r0("Store"), _s = r0("Engine"), fi = r0("Layer"), Fr = r0("Render"), M6 = (s) => 1 - Math.cos(s * Math.PI / 2), S6 = (s) => Math.sin(s * Math.PI / 2), C6 = (s) => -(Math.cos(Math.PI * s) - 1) / 2, T6 = (s) => s * s, E6 = (s) => 1 - (1 - s) * (1 - s), A6 = (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2, P6 = (s) => s * s * s, k6 = (s) => 1 - Math.pow(1 - s, 3), D6 = (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2, I6 = (s) => s * s * s * s, R6 = (s) => 1 - Math.pow(1 - s, 4), L6 = (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2, F6 = (s) => s * s * s * s * s, O6 = (s) => 1 - Math.pow(1 - s, 5), U6 = (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2, z6 = (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10), B6 = (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s), N6 = (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2, V6 = (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)), H6 = (s) => Math.sqrt(1 - Math.pow(s - 1, 2)), G6 = (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2, ru = 1.70158, dl = ru * 1.525, L3 = ru + 1, $6 = (s) => L3 * s * s * s - ru * s * s, W6 = (s) => 1 + L3 * Math.pow(s - 1, 3) + ru * Math.pow(s - 1, 2), j6 = (s) => s < 0.5 ? Math.pow(2 * s, 2) * ((dl + 1) * 2 * s - dl) / 2 : (Math.pow(2 * s - 2, 2) * ((dl + 1) * (s * 2 - 2) + dl) + 2) / 2, F3 = 2 * Math.PI / 3, Qf = 2 * Math.PI / 4.5, X6 = (s) => s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * F3), Y6 = (s) => s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * F3) + 1, q6 = (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * Qf)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * Qf) / 2 + 1, Rc = (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375, Z6 = (s) => 1 - Rc(1 - s), K6 = (s) => s < 0.5 ? (1 - Rc(1 - 2 * s)) / 2 : (1 + Rc(2 * s - 1)) / 2, J6 = (s) => s, Q6 = (s) => s === 0 ? 0 : 1, e7 = (s) => s === 1 ? 1 : 0, t7 = {
  // Linear
  linear: J6,
  // Sine
  easeInSine: M6,
  easeOutSine: S6,
  easeInOutSine: C6,
  // Quad
  easeInQuad: T6,
  easeOutQuad: E6,
  easeInOutQuad: A6,
  // Cubic
  easeInCubic: P6,
  easeOutCubic: k6,
  easeInOutCubic: D6,
  // Quart
  easeInQuart: I6,
  easeOutQuart: R6,
  easeInOutQuart: L6,
  // Quint
  easeInQuint: F6,
  easeOutQuint: O6,
  easeInOutQuint: U6,
  // Expo
  easeInExpo: z6,
  easeOutExpo: B6,
  easeInOutExpo: N6,
  // Circ
  easeInCirc: V6,
  easeOutCirc: H6,
  easeInOutCirc: G6,
  // Back
  easeInBack: $6,
  easeOutBack: W6,
  easeInOutBack: j6,
  // Elastic
  easeInElastic: X6,
  easeOutElastic: Y6,
  easeInOutElastic: q6,
  // Bounce
  easeInBounce: Z6,
  easeOutBounce: Rc,
  easeInOutBounce: K6,
  // Step
  stepStart: Q6,
  stepEnd: e7
};
function n7(s, e = 0.1, n = 2, i = 2) {
  const { time: o, keyframes: a, value: r, velocity: l } = s;
  if (a.length === 0) return r;
  const c = s.fps || 30, u = o * c;
  let d = null;
  for (let g = a.length - 1; g >= 0; g--)
    if (a[g].frame <= u) {
      d = a[g];
      break;
    }
  if (!d) return r;
  const h = d.frame / c, p = o - h;
  if (p <= 0) return r;
  const f = typeof l == "number" ? l : l[0], m = typeof r == "number" ? r : r[0], y = f * e * Math.sin(n * p * 2 * Math.PI) / Math.exp(i * p);
  return typeof r == "number" ? m + y : r.map((g, x) => {
    const w = l[x] || 0;
    return g + w * e * Math.sin(n * p * 2 * Math.PI) / Math.exp(i * p);
  });
}
function i7(s, e = 0.7, n = 4e3) {
  const { time: i, keyframes: o, value: a } = s;
  if (o.length === 0) return a;
  const r = s.fps || 30, l = i * r;
  let c = null;
  for (let w = o.length - 1; w >= 0; w--)
    if (o[w].frame <= l) {
      c = o[w];
      break;
    }
  if (!c) return a;
  const u = c.frame / r, d = i - u;
  if (d <= 0) return a;
  let h = d, p = 1, f = 0;
  const m = 10;
  for (; h > 0 && f < m; ) {
    const w = Math.sqrt(2 * p / n);
    if (h < w * 2)
      break;
    h -= w * 2, p *= e * e, f++;
  }
  const y = Math.sqrt(2 * p / n), g = h / (y * 2), x = p * 4 * g * (1 - g);
  return typeof a == "number" ? a - x * (1 - e) : a.map((w) => w - x * (1 - e));
}
function s7(s, e = 1, n = 0.3) {
  const { time: i, keyframes: o, value: a } = s;
  if (o.length === 0) return a;
  const r = s.fps || 30, l = i * r;
  let c = null;
  for (let m = o.length - 1; m >= 0; m--)
    if (o[m].frame <= l) {
      c = o[m];
      break;
    }
  if (!c) return a;
  const u = c.frame / r, d = i - u;
  if (d <= 0) return a;
  const h = n / 4, f = Math.pow(2, -10 * d) * Math.sin((d - h) * (2 * Math.PI) / n);
  return typeof a == "number" ? a + e * f : a.map((m) => m + e * f);
}
function o7(s, e = "cycle", n = 0) {
  const { time: i, keyframes: o, fps: a } = s;
  if (o.length < 2) return s.value;
  const r = n > 0 ? Math.max(0, o.length - n) : 0, l = o[r], c = o[o.length - 1], u = l.frame / a, d = c.frame / a, h = d - u;
  if (h <= 0 || i <= d) return s.value;
  const p = i - d;
  switch (e) {
    case "cycle": {
      const f = u + p % h;
      return aa(o, f, a);
    }
    case "pingpong": {
      const f = Math.floor(p / h), m = p % h / h, g = f % 2 === 1 ? 1 - m : m, x = u + g * h;
      return aa(o, x, a);
    }
    case "offset": {
      const f = Math.floor(p / h), m = u + p % h, y = aa(o, m, a), g = O3(c.value, l.value);
      return U3(y, z3(g, f + 1));
    }
    case "continue": {
      const f = s.velocity;
      return typeof f == "number" ? s.value + f * p : s.value.map((m, y) => m + f[y] * p);
    }
  }
}
function a7(s, e = "cycle", n = 0) {
  const { time: i, keyframes: o, fps: a } = s;
  if (o.length < 2) return s.value;
  const r = n > 0 ? Math.min(o.length - 1, n - 1) : o.length - 1, l = o[0], c = o[r], u = l.frame / a, d = c.frame / a, h = d - u;
  if (h <= 0 || i >= u) return s.value;
  const p = u - i;
  switch (e) {
    case "cycle": {
      const f = d - p % h;
      return aa(o, f, a);
    }
    case "pingpong": {
      const f = Math.floor(p / h), m = p % h / h, g = f % 2 === 1 ? m : 1 - m, x = u + g * h;
      return aa(o, x, a);
    }
    case "offset": {
      const f = Math.floor(p / h), m = d - p % h, y = aa(o, m, a), g = O3(l.value, c.value);
      return U3(y, z3(g, f + 1));
    }
    case "continue": {
      const f = s.velocity;
      return typeof f == "number" ? s.value - f * p : s.value.map((m, y) => m - f[y] * p);
    }
  }
}
function r7(s, e = 5, n = 50, i = 1, o = 0.5, a) {
  const r = s.time, { value: l } = s, c = (u, d) => {
    let h = 0, p = 1, f = 1;
    for (let m = 0; m < i; m++)
      h += p * Math.sin(d * e * f * Math.PI * 2 + u * 1e3), h += p * 0.5 * Math.sin(d * e * f * Math.PI * 2 * 1.5 + u * 500), p *= o, f *= 2;
    return h / (1 + (i - 1) * o);
  };
  return typeof l == "number" ? l + c(0, r) * n : l.map((u, d) => u + c(d, r) * n);
}
const ep = {
  /**
   * Linear time ramp
   */
  timeRamp(s, e, n, i, o) {
    if (o <= s) return n;
    if (o >= e) return i;
    const a = (o - s) / (e - s);
    return n + (i - n) * a;
  },
  /**
   * Periodic function (loops every period seconds)
   */
  periodic(s, e) {
    return s % e / e;
  },
  /**
   * Sawtooth wave
   */
  sawtooth(s, e, n = 1) {
    const i = s * e;
    return n * 2 * (i - Math.floor(i + 0.5));
  },
  /**
   * Triangle wave
   */
  triangle(s, e, n = 1) {
    const i = s * e;
    return n * (2 * Math.abs(2 * (i - Math.floor(i + 0.5))) - 1);
  },
  /**
   * Square wave
   */
  square(s, e, n = 1) {
    const i = s * e;
    return n * (i - Math.floor(i) < 0.5 ? 1 : -1);
  },
  /**
   * Sine wave
   */
  sine(s, e, n = 1, i = 0) {
    return n * Math.sin(2 * Math.PI * e * s + i);
  },
  /**
   * Pulse (duty cycle controlled square)
   */
  pulse(s, e, n = 0.5, i = 1) {
    const o = s * e % 1;
    return i * (o < n ? 1 : 0);
  }
}, Lc = {
  /**
   * Linear interpolation
   */
  lerp(s, e, n) {
    return s + (e - s) * n;
  },
  /**
   * Clamp value between min and max
   */
  clamp(s, e, n) {
    return Math.min(n, Math.max(e, s));
  },
  /**
   * Map value from one range to another
   */
  map(s, e, n, i, o) {
    return i + (o - i) * ((s - e) / (n - e));
  },
  /**
   * Normalized value (0-1) based on range
   */
  normalize(s, e, n) {
    return (s - e) / (n - e);
  },
  /**
   * Smooth step (Hermite interpolation)
   */
  smoothstep(s, e, n) {
    const i = Lc.clamp((n - s) / (e - s), 0, 1);
    return i * i * (3 - 2 * i);
  },
  /**
   * Smoother step (Ken Perlin's improved version)
   */
  smootherstep(s, e, n) {
    const i = Lc.clamp((n - s) / (e - s), 0, 1);
    return i * i * i * (i * (i * 6 - 15) + 10);
  },
  /**
   * Modulo with support for negative numbers
   */
  mod(s, e) {
    return (s % e + e) % e;
  },
  /**
   * Distance between two 2D points
   */
  distance(s, e, n, i) {
    const o = n - s, a = i - e;
    return Math.sqrt(o * o + a * a);
  },
  /**
   * Angle between two 2D points (in radians)
   */
  angleBetween(s, e, n, i) {
    return Math.atan2(i - e, n - s);
  },
  /**
   * Convert degrees to radians
   */
  degreesToRadians(s) {
    return s * Math.PI / 180;
  },
  /**
   * Convert radians to degrees
   */
  radiansToDegrees(s) {
    return s * 180 / Math.PI;
  },
  /**
   * Random number with seed (deterministic)
   */
  seedRandom(s, e = 0, n = 1) {
    const i = Math.sin(s * 12.9898) * 43758.5453, o = i - Math.floor(i);
    return e + o * (n - e);
  },
  /**
   * Gaussian random (normal distribution)
   */
  gaussRandom(s = 0, e = 1) {
    const n = Math.random(), i = Math.random(), o = Math.sqrt(-2 * Math.log(n)) * Math.cos(2 * Math.PI * i);
    return s + o * e;
  }
};
function aa(s, e, n) {
  const i = e * n;
  let o = null, a = null;
  for (const c of s)
    if (c.frame <= i)
      o = c;
    else if (!a) {
      a = c;
      break;
    }
  if (!o) return s[0].value;
  if (!a) return o.value;
  const r = (i - o.frame) / (a.frame - o.frame), l = l7(r, o.interpolation);
  return c7(o.value, a.value, l);
}
function l7(s, e) {
  const n = t7[e];
  return n ? n(s) : s;
}
function c7(s, e, n) {
  return typeof s == "number" && typeof e == "number" ? s + (e - s) * n : Array.isArray(s) && Array.isArray(e) ? s.map((i, o) => i + (e[o] - i) * n) : s;
}
function O3(s, e) {
  return typeof s == "number" && typeof e == "number" ? s - e : Array.isArray(s) && Array.isArray(e) ? s.map((n, i) => n - e[i]) : 0;
}
function U3(s, e) {
  return typeof s == "number" && typeof e == "number" ? s + e : Array.isArray(s) && Array.isArray(e) ? s.map((n, i) => n + e[i]) : s;
}
function z3(s, e) {
  return typeof s == "number" ? s * e : Array.isArray(s) ? s.map((n) => n * e) : 0;
}
function u7(s, e) {
  if (!s.enabled) return e.value;
  switch (s.type) {
    case "preset":
      return d7(s.name, e, s.params);
    case "function":
      return h7(s.name, e, s.params);
    default:
      return e.value;
  }
}
function d7(s, e, n) {
  switch (s) {
    case "inertia":
      return n7(e, n.amplitude, n.frequency, n.decay);
    case "bounce":
      return i7(e, n.elasticity, n.gravity);
    case "elastic":
      return s7(e, n.amplitude, n.period);
    case "wiggle":
      return r7(e, n.frequency, n.amplitude, n.octaves);
    case "loopOut":
      return o7(e, n.type, n.numKeyframes);
    case "loopIn":
      return a7(e, n.type, n.numKeyframes);
    default:
      return e.value;
  }
}
function h7(s, e, n) {
  if (s in ep) {
    const i = ep[s];
    return i(e.time, ...Object.values(n));
  }
  if (s in Lc) {
    const i = Lc[s], o = typeof e.value == "number" ? e.value : e.value[0];
    return i(o, ...Object.values(n));
  }
  return e.value;
}
function B3(s, e) {
  let n = 0, i = s.length - 2;
  for (; n <= i; ) {
    const o = n + i >>> 1, a = s[o].frame, r = s[o + 1].frame;
    if (e >= a && e <= r)
      return o;
    e < a ? i = o - 1 : n = o + 1;
  }
  return Math.max(0, Math.min(n, s.length - 2));
}
function N3(s, e) {
  if (typeof s == "number" && typeof e == "number")
    return e - s;
  if (typeof s == "object" && s !== null && "x" in s && "y" in s && typeof e == "object" && e !== null && "x" in e && "y" in e) {
    const n = e.x - s.x, i = e.y - s.y;
    return Math.sqrt(n * n + i * i) || 1;
  }
  return 1;
}
function mt(s, e, n = 30, i = "") {
  var a;
  let o;
  if (!s.animated || s.keyframes.length === 0)
    o = s.value;
  else {
    const r = s.keyframes;
    if (e <= r[0].frame)
      o = r[0].value;
    else if (e >= r[r.length - 1].frame)
      o = r[r.length - 1].value;
    else {
      const l = B3(r, e), c = r[l], u = r[l + 1], d = u.frame - c.frame, h = e - c.frame;
      let p = d > 0 ? h / d : 0;
      const f = c.interpolation || "linear";
      if (f === "hold")
        o = c.value;
      else {
        if (f === "bezier") {
          const m = N3(c.value, u.value);
          p = V3(p, c.outHandle, u.inHandle, d, m);
        } else f !== "linear" && f in k0 ? p = R3(f)(p) : f !== "linear" && Fr.warn(`Unknown interpolation type: ${f}, using linear`);
        o = H3(c.value, u.value, p);
      }
    }
  }
  return (a = s.expression) != null && a.enabled && (o = f7(s, o, e, n)), o;
}
function f7(s, e, n, i, o) {
  const a = s.expression;
  if (!a || !a.enabled) return e;
  const r = n / i, l = p7(s, n, i), c = {
    time: r,
    fps: i,
    propertyName: s.name,
    value: e,
    velocity: l,
    numKeys: s.keyframes.length,
    keyframes: s.keyframes
  }, u = {
    type: a.type,
    name: a.name,
    params: a.params,
    enabled: a.enabled
  };
  return u7(u, c);
}
function p7(s, e, n) {
  const o = tp(s, e - 0.5), a = tp(s, e + 0.5);
  if (typeof o == "number" && typeof a == "number")
    return (a - o) * n;
  if (typeof o == "object" && typeof a == "object") {
    const r = o, l = a;
    if ("x" in r && "y" in r) {
      const c = [(l.x - r.x) * n, (l.y - r.y) * n];
      return "z" in r && "z" in l && c.push((l.z - r.z) * n), c;
    }
  }
  return 0;
}
function tp(s, e) {
  if (!s.animated || s.keyframes.length === 0)
    return s.value;
  const n = s.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  const i = B3(n, e), o = n[i], a = n[i + 1], r = a.frame - o.frame, l = e - o.frame;
  let c = r > 0 ? l / r : 0;
  const u = o.interpolation || "linear";
  if (u === "hold")
    return o.value;
  if (u === "bezier") {
    const d = N3(o.value, a.value);
    c = V3(c, o.outHandle, a.inHandle, r, d);
  } else u !== "linear" && u in k0 && (c = R3(u)(c));
  return H3(o.value, a.value, c);
}
function V3(s, e, n, i = 1, o = 1) {
  if (!e.enabled && !n.enabled)
    return s;
  const a = i > 0 ? Math.abs(e.frame) / i : 0.33, r = o !== 0 ? e.value / o : 0.33, l = i > 0 ? 1 - Math.abs(n.frame) / i : 0.67, c = o !== 0 ? 1 - n.value / o : 0.67;
  let u = s;
  const d = 1e-6, h = 8;
  for (let p = 0; p < h; p++) {
    const m = Fc(u, 0, a, l, 1) - s;
    if (Math.abs(m) < d) break;
    const y = m7(u, 0, a, l, 1);
    if (Math.abs(y) < d) break;
    u -= m / y, u = Math.max(0, Math.min(1, u));
  }
  return Fc(u, 0, r, c, 1);
}
function Fc(s, e, n, i, o) {
  const a = 1 - s;
  return a * a * a * e + 3 * a * a * s * n + 3 * a * s * s * i + s * s * s * o;
}
function m7(s, e, n, i, o) {
  const a = 1 - s;
  return 3 * a * a * (n - e) + 6 * a * s * (i - n) + 3 * s * s * (o - i);
}
function H3(s, e, n) {
  if (typeof s == "number" && typeof e == "number")
    return s + (e - s) * n;
  if (typeof s == "object" && s !== null && typeof e == "object" && e !== null && "x" in s && "y" in s && "x" in e && "y" in e) {
    const i = s, o = e, a = {
      x: i.x + (o.x - i.x) * n,
      y: i.y + (o.y - i.y) * n
    };
    return "z" in i && "z" in o ? a.z = i.z + (o.z - i.z) * n : "z" in i ? a.z = i.z * (1 - n) : "z" in o && (a.z = o.z * n), a;
  }
  return typeof s == "string" && typeof e == "string" && s.startsWith("#") && e.startsWith("#") ? v7(s, e, n) : n < 0.5 ? s : e;
}
function v7(s, e, n) {
  const i = parseInt(s.slice(1, 3), 16), o = parseInt(s.slice(3, 5), 16), a = parseInt(s.slice(5, 7), 16), r = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), c = parseInt(e.slice(5, 7), 16), u = Math.round(i + (r - i) * n), d = Math.round(o + (l - o) * n), h = Math.round(a + (c - a) * n);
  return `#${u.toString(16).padStart(2, "0")}${d.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}`;
}
const g7 = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
}, Oc = g7;
function y7(s, e, n) {
  const i = e.x, o = e.y, a = 1 - n.x, r = 1 - n.y;
  return {
    x: Fc(s, 0, i, a, 1),
    y: Fc(s, 0, o, r, 1)
  };
}
function x7(s, e) {
  const n = Math.max(0, Math.min(1, s));
  return y7(n, e.outHandle, e.inHandle).y;
}
function Li(s, e, n) {
  var o, a, r, l, c, u, d, h, p, f, m, y, g, x, w, M, _, C, T, P, E, b, S, A, R, k, U, I, W;
  const i = Math.max(0, Math.min(n, s.frameCount - 1));
  switch (e) {
    case "amplitude":
      return s.amplitudeEnvelope[i] ?? 0;
    case "rms":
      return s.rmsEnergy[i] ?? 0;
    case "spectralCentroid":
      return s.spectralCentroid[i] ?? 0;
    case "sub":
      return s.frequencyBands.sub[i] ?? 0;
    case "bass":
      return s.frequencyBands.bass[i] ?? 0;
    case "lowMid":
      return s.frequencyBands.lowMid[i] ?? 0;
    case "mid":
      return s.frequencyBands.mid[i] ?? 0;
    case "highMid":
      return s.frequencyBands.highMid[i] ?? 0;
    case "high":
      return s.frequencyBands.high[i] ?? 0;
    case "onsets":
      return s.onsets.includes(i) ? 1 : 0;
    case "spectralFlux":
      return ((o = s.spectralFlux) == null ? void 0 : o[i]) ?? 0;
    case "zeroCrossingRate":
    case "zcr":
      return ((a = s.zeroCrossingRate) == null ? void 0 : a[i]) ?? 0;
    case "spectralRolloff":
    case "rolloff":
      return ((r = s.spectralRolloff) == null ? void 0 : r[i]) ?? 0;
    case "spectralFlatness":
    case "flatness":
      return ((l = s.spectralFlatness) == null ? void 0 : l[i]) ?? 0;
    case "chromaEnergy":
      return ((c = s.chromaFeatures) == null ? void 0 : c.chromaEnergy[i]) ?? 0;
    case "chromaC":
      return ((d = (u = s.chromaFeatures) == null ? void 0 : u.chroma[i]) == null ? void 0 : d[0]) ?? 0;
    case "chromaCs":
    case "chromaDb":
      return ((p = (h = s.chromaFeatures) == null ? void 0 : h.chroma[i]) == null ? void 0 : p[1]) ?? 0;
    case "chromaD":
      return ((m = (f = s.chromaFeatures) == null ? void 0 : f.chroma[i]) == null ? void 0 : m[2]) ?? 0;
    case "chromaDs":
    case "chromaEb":
      return ((g = (y = s.chromaFeatures) == null ? void 0 : y.chroma[i]) == null ? void 0 : g[3]) ?? 0;
    case "chromaE":
      return ((w = (x = s.chromaFeatures) == null ? void 0 : x.chroma[i]) == null ? void 0 : w[4]) ?? 0;
    case "chromaF":
      return ((_ = (M = s.chromaFeatures) == null ? void 0 : M.chroma[i]) == null ? void 0 : _[5]) ?? 0;
    case "chromaFs":
    case "chromaGb":
      return ((T = (C = s.chromaFeatures) == null ? void 0 : C.chroma[i]) == null ? void 0 : T[6]) ?? 0;
    case "chromaG":
      return ((E = (P = s.chromaFeatures) == null ? void 0 : P.chroma[i]) == null ? void 0 : E[7]) ?? 0;
    case "chromaGs":
    case "chromaAb":
      return ((S = (b = s.chromaFeatures) == null ? void 0 : b.chroma[i]) == null ? void 0 : S[8]) ?? 0;
    case "chromaA":
      return ((R = (A = s.chromaFeatures) == null ? void 0 : A.chroma[i]) == null ? void 0 : R[9]) ?? 0;
    case "chromaAs":
    case "chromaBb":
      return ((U = (k = s.chromaFeatures) == null ? void 0 : k.chroma[i]) == null ? void 0 : U[10]) ?? 0;
    case "chromaB":
      return ((W = (I = s.chromaFeatures) == null ? void 0 : I.chroma[i]) == null ? void 0 : W[11]) ?? 0;
    default:
      return 0;
  }
}
function G3(s, e) {
  const { threshold: n, minPeaksDistance: i, multiply: o } = e, a = s.map((d) => Math.min(1, d * o)), r = [];
  for (let d = 1; d < a.length - 1; d++) {
    const h = a[d - 1], p = a[d], f = a[d + 1];
    p > h && p > f && p >= n && r.push({ index: d, value: p });
  }
  const l = [];
  for (const d of r) {
    const h = l.findIndex(
      (p) => Math.abs(p.index - d.index) < i
    );
    h === -1 ? l.push(d) : d.value > l[h].value && (l[h] = d);
  }
  l.sort((d, h) => d.index - h.index);
  const c = new Array(s.length).fill(0);
  let u = 0;
  for (let d = 0; d < s.length; d++)
    l.some((p) => p.index === d) && (u = 1 - u), c[d] = u;
  return {
    indices: l.map((d) => d.index),
    values: l.map((d) => d.value),
    count: l.length,
    alternating: c
  };
}
function np(s, e) {
  return s.onsets.includes(e);
}
function b7(s, e) {
  return s.indices.includes(e);
}
const $3 = /* @__PURE__ */ Math.sqrt(3), _7 = 0.5 * ($3 - 1), Va = (3 - $3) / 6, ip = (s) => Math.floor(s) | 0, sp = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function op(s = Math.random) {
  const e = w7(s), n = new Float64Array(e).map((o) => sp[o % 12 * 2]), i = new Float64Array(e).map((o) => sp[o % 12 * 2 + 1]);
  return function(a, r) {
    let l = 0, c = 0, u = 0;
    const d = (a + r) * _7, h = ip(a + d), p = ip(r + d), f = (h + p) * Va, m = h - f, y = p - f, g = a - m, x = r - y;
    let w, M;
    g > x ? (w = 1, M = 0) : (w = 0, M = 1);
    const _ = g - w + Va, C = x - M + Va, T = g - 1 + 2 * Va, P = x - 1 + 2 * Va, E = h & 255, b = p & 255;
    let S = 0.5 - g * g - x * x;
    if (S >= 0) {
      const k = E + e[b], U = n[k], I = i[k];
      S *= S, l = S * S * (U * g + I * x);
    }
    let A = 0.5 - _ * _ - C * C;
    if (A >= 0) {
      const k = E + w + e[b + M], U = n[k], I = i[k];
      A *= A, c = A * A * (U * _ + I * C);
    }
    let R = 0.5 - T * T - P * P;
    if (R >= 0) {
      const k = E + 1 + e[b + 1], U = n[k], I = i[k];
      R *= R, u = R * R * (U * T + I * P);
    }
    return 70 * (l + c + u);
  };
}
function w7(s) {
  const n = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++)
    n[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    const o = i + ~~(s() * (256 - i)), a = n[i];
    n[i] = n[o], n[o] = a;
  }
  for (let i = 256; i < 512; i++)
    n[i] = n[i - 256];
  return n;
}
class W3 {
  constructor(e = 12345) {
    le(this, "state");
    le(this, "initialSeed");
    this.initialSeed = e, this.state = e;
  }
  /** Reset to initial seed */
  reset() {
    this.state = this.initialSeed;
  }
  /** Reset to a new seed */
  setSeed(e) {
    this.initialSeed = e, this.state = e;
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(e) {
    this.state = e;
  }
  /** Get initial seed */
  getSeed() {
    return this.initialSeed;
  }
  /**
   * Get next random number in [0, 1)
   * Uses mulberry32 algorithm
   */
  next() {
    let e = this.state += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(e, n) {
    return e + this.next() * (n - e);
  }
  /** Get random integer in range [min, max] inclusive */
  int(e, n) {
    return Math.floor(this.range(e, n + 1));
  }
  /** Get random value with variance: base + random(-variance, +variance) */
  variance(e, n) {
    return e + (this.next() - 0.5) * 2 * n;
  }
  /** Get random boolean with given probability of true */
  bool(e = 0.5) {
    return this.next() < e;
  }
  /** Get random angle in radians [0, 2) */
  angle() {
    return this.next() * Math.PI * 2;
  }
  /** Get random point in unit circle */
  inCircle() {
    const e = this.angle(), n = Math.sqrt(this.next());
    return { x: n * Math.cos(e), y: n * Math.sin(e) };
  }
  /** Get random point on unit sphere */
  onSphere() {
    const e = this.angle(), n = Math.acos(2 * this.next() - 1);
    return {
      x: Math.sin(n) * Math.cos(e),
      y: Math.sin(n) * Math.sin(e),
      z: Math.cos(n)
    };
  }
}
function M7() {
  return {
    enabled: !1,
    particleCollision: !1,
    particleCollisionRadius: 1,
    particleCollisionResponse: "bounce",
    particleCollisionDamping: 0.8,
    layerCollision: !1,
    layerCollisionLayerId: null,
    layerCollisionThreshold: 0.5,
    floorEnabled: !1,
    floorY: 1,
    ceilingEnabled: !1,
    ceilingY: 0,
    wallsEnabled: !1,
    bounciness: 0.7,
    friction: 0.1,
    spatialHashCellSize: 50
  };
}
function S7() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function C7() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: [],
    collision: M7()
  };
}
function ap() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: S7(),
    spriteSmoothing: !0,
    spriteOpacityByAge: !0,
    emissiveEnabled: !1,
    emissiveIntensity: 2,
    emissiveColor: null
  };
}
class lu {
  constructor(e = {}, n = 12345) {
    le(this, "particles", []);
    le(this, "emitters", /* @__PURE__ */ new Map());
    le(this, "gravityWells", /* @__PURE__ */ new Map());
    le(this, "vortices", /* @__PURE__ */ new Map());
    le(this, "modulations", []);
    le(this, "config");
    le(this, "boundaryMask", null);
    le(this, "frameCount", 0);
    le(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    le(this, "nextParticleId", 0);
    le(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    le(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator (seeded for determinism)
    le(this, "noise2D");
    le(this, "noiseTime", 0);
    // Render options cache for spatial grid
    le(this, "renderOptions", ap());
    // Sprite image cache - maps emitter ID to loaded image
    le(this, "spriteCache", /* @__PURE__ */ new Map());
    // Collision spatial hash grid
    le(this, "collisionGrid", /* @__PURE__ */ new Map());
    le(this, "collisionGridCellSize", 50);
    // SEEDED RNG - For deterministic simulation
    // Same seed + same config + same frame = identical particle state
    le(this, "rng");
    // Spline path provider for emitters with shape='spline'
    // Set by the engine integration (e.g., WeylEngine) to resolve spline paths
    le(this, "splineProvider", null);
    // Current frame for spline queries
    le(this, "currentFrame", 0);
    // Sequential emit state per emitter (for 'sequential' emit mode)
    le(this, "sequentialEmitT", /* @__PURE__ */ new Map());
    this.config = { ...C7(), ...e }, this.rng = new W3(n), this.noise2D = op(() => this.rng.next()), this.config.collision && (this.collisionGridCellSize = this.config.collision.spatialHashCellSize);
  }
  /**
   * Get the RNG instance (for external access/checkpointing)
   */
  getRng() {
    return this.rng;
  }
  /**
   * Set new seed and reset RNG
   */
  setSeed(e) {
    this.rng.setSeed(e), this.noise2D = op(() => this.rng.next());
  }
  /**
   * Set the spline path provider callback
   * This allows emitters with shape='spline' to query spline positions
   */
  setSplineProvider(e) {
    this.splineProvider = e;
  }
  /**
   * Get the current spline provider
   */
  getSplineProvider() {
    return this.splineProvider;
  }
  /**
   * Set the current frame for spline queries
   * Called by the engine before stepping the simulation
   */
  setCurrentFrame(e) {
    this.currentFrame = e;
  }
  // ============================================================================
  // Sprite Management
  // ============================================================================
  /**
   * Load a sprite image for an emitter
   */
  async loadSprite(e, n) {
    return new Promise((i, o) => {
      const a = new Image();
      a.crossOrigin = "anonymous", a.onload = () => {
        this.spriteCache.set(e, a);
        const r = this.emitters.get(e);
        r && r.sprite && (r.sprite.imageData = a), i();
      }, a.onerror = o, a.src = n;
    });
  }
  /**
   * Set sprite image directly (for pre-loaded images)
   */
  setSpriteImage(e, n) {
    this.spriteCache.set(e, n);
    const i = this.emitters.get(e);
    i && i.sprite && (i.sprite.imageData = n);
  }
  /**
   * Get sprite image for an emitter
   */
  getSpriteImage(e) {
    return this.spriteCache.get(e) ?? null;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let i = 0; i < n; i++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const i = this.gravityWells.get(e);
    i && Object.assign(i, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const i = this.vortices.get(e);
    i && Object.assign(i, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((i) => i.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, i) {
    const o = i ? `${i}:${e}` : `*:${e}`;
    this.featureOverrides.set(o, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    var u, d, h, p;
    this.emitters.forEach((f, m) => {
      if (!f.enabled) return;
      const g = (this.getFeatureValue("emissionRate", m) ?? f.emissionRate) * e;
      let x = (this.emissionAccumulators.get(m) || 0) + g;
      for (; x >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(f), x -= 1;
      this.emissionAccumulators.set(m, x);
    });
    const n = this.config.windDirection * Math.PI / 180, i = Math.cos(n) * this.config.windStrength * 1e-3, o = Math.sin(n) * this.config.windStrength * 1e-3, a = this.getFeatureValue("gravity", "*") ?? this.config.gravity, r = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = i * (r / Math.max(1, this.config.windStrength)), c = o * (r / Math.max(1, this.config.windStrength));
    for (let f = this.particles.length - 1; f >= 0; f--) {
      const m = this.particles[f];
      if (m.prevX = m.x, m.prevY = m.y, this.trailHistory.has(m.id)) {
        const x = this.trailHistory.get(m.id);
        x.unshift({ x: m.x, y: m.y }), x.length > 20 && x.pop();
      }
      m.vy += a * 1e-3 * e, m.vx += l * e, m.vy += c * e, this.gravityWells.forEach((x) => {
        if (!x.enabled) return;
        const w = x.x - m.x, M = x.y - m.y, _ = Math.sqrt(w * w + M * M);
        if (_ < x.radius && _ > 1e-3) {
          let C = x.strength * 1e-4;
          switch (x.falloff) {
            case "linear":
              C *= 1 - _ / x.radius;
              break;
            case "quadratic":
              C *= Math.pow(1 - _ / x.radius, 2);
              break;
          }
          const T = w / _, P = M / _;
          m.vx += T * C * e, m.vy += P * C * e;
        }
      }), this.vortices.forEach((x) => {
        if (!x.enabled) return;
        const w = x.x - m.x, M = x.y - m.y, _ = Math.sqrt(w * w + M * M);
        if (_ < x.radius && _ > 1e-3) {
          const C = 1 - _ / x.radius, T = x.strength * 1e-4 * C, P = w / _, E = M / _, b = -E, S = P;
          m.vx += b * T * e, m.vy += S * T * e;
          const A = x.inwardPull * 1e-4 * C;
          m.vx += P * A * e, m.vy += E * A * e;
        }
      }), this.applyTurbulence(m, e);
      const y = 1 - this.config.friction;
      m.vx *= y, m.vy *= y, m.angularVelocity !== 0 && (m.rotation += m.angularVelocity * e);
      const g = this.emitters.get(m.emitterId);
      (u = g == null ? void 0 : g.sprite) != null && u.alignToVelocity && (m.vx !== 0 || m.vy !== 0) && (m.rotation = Math.atan2(m.vy, m.vx)), (d = g == null ? void 0 : g.sprite) != null && d.isSheet && g.sprite.totalFrames > 1 && this.updateSpriteFrame(m, g.sprite, e), m.x += m.vx * e, m.y += m.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(m), this.handleCanvasBoundary(m), this.applyModulations(m), m.age += e, m.age > m.lifetime && (m.isSubParticle || this.triggerSubEmitters(m), this.particles.splice(f, 1), this.trailHistory.delete(m.id));
    }
    (h = this.config.collision) != null && h.enabled && this.config.collision.particleCollision && this.handleParticleCollisions(), (p = this.config.collision) != null && p.enabled && this.handleEnvironmentCollisions(), this.noiseTime += e, this.frameCount++;
  }
  /**
   * Update sprite animation frame based on age and play mode
   */
  updateSpriteFrame(e, n, i) {
    const o = n.totalFrames;
    switch (e.age / e.lifetime, n.playMode) {
      case "loop": {
        const a = Math.floor(e.age * n.frameRate / 60);
        e.spriteIndex = a % o;
        break;
      }
      case "once": {
        const a = Math.floor(e.age * n.frameRate / 60);
        e.spriteIndex = Math.min(a, o - 1);
        break;
      }
      case "pingpong": {
        const a = Math.floor(e.age * n.frameRate / 60), r = Math.floor(a / (o - 1)), l = a % (o - 1);
        e.spriteIndex = r % 2 === 0 ? l : o - 1 - l;
        break;
      }
      case "random": {
        this.rng.bool(0.1) && (e.spriteIndex = this.rng.int(0, o - 1));
        break;
      }
    }
  }
  /**
   * Handle particle-to-particle collisions using spatial hashing
   */
  handleParticleCollisions() {
    const e = this.config.collision;
    if (!e || !e.particleCollision) return;
    this.collisionGrid.clear();
    const n = this.collisionGridCellSize / 1e3;
    for (const o of this.particles) {
      const a = Math.floor(o.x / n), r = Math.floor(o.y / n), l = `${a},${r}`;
      this.collisionGrid.has(l) || this.collisionGrid.set(l, []), this.collisionGrid.get(l).push(o);
    }
    const i = /* @__PURE__ */ new Set();
    for (const o of this.particles) {
      const a = Math.floor(o.x / n), r = Math.floor(o.y / n);
      for (let l = -1; l <= 1; l++)
        for (let c = -1; c <= 1; c++) {
          const u = `${a + l},${r + c}`, d = this.collisionGrid.get(u);
          if (d)
            for (const h of d) {
              if (h.id <= o.id) continue;
              const p = `${Math.min(o.id, h.id)}-${Math.max(o.id, h.id)}`;
              if (i.has(p)) continue;
              i.add(p);
              const f = o.size / 1e3 * e.particleCollisionRadius, m = h.size / 1e3 * e.particleCollisionRadius, y = f + m, g = h.x - o.x, x = h.y - o.y, w = g * g + x * x;
              if (w < y * y && w > 1e-6) {
                const M = Math.sqrt(w), _ = g / M, C = x / M;
                switch (e.particleCollisionResponse) {
                  case "bounce": {
                    const T = o.vx - h.vx, P = o.vy - h.vy, E = T * _ + P * C;
                    if (E > 0) {
                      const b = e.particleCollisionDamping;
                      o.vx -= E * _ * b, o.vy -= E * C * b, h.vx += E * _ * b, h.vy += E * C * b;
                      const S = y - M;
                      o.x -= _ * S * 0.5, o.y -= C * S * 0.5, h.x += _ * S * 0.5, h.y += C * S * 0.5;
                    }
                    break;
                  }
                  case "absorb": {
                    o.size > h.size ? (o.size += h.size * 0.1, h.age = h.lifetime + 1) : (h.size += o.size * 0.1, o.age = o.lifetime + 1);
                    break;
                  }
                  case "explode": {
                    o.age = o.lifetime + 1, h.age = h.lifetime + 1;
                    break;
                  }
                }
                o.collisionCount++, h.collisionCount++;
              }
            }
        }
    }
  }
  /**
   * Handle floor, ceiling, and wall collisions
   */
  handleEnvironmentCollisions() {
    const e = this.config.collision;
    if (!(e != null && e.enabled)) return;
    const n = e.bounciness, i = e.friction;
    for (const o of this.particles)
      e.floorEnabled && o.y > e.floorY && (o.y = e.floorY, o.vy = -o.vy * n, o.vx *= 1 - i, o.collisionCount++), e.ceilingEnabled && o.y < e.ceilingY && (o.y = e.ceilingY, o.vy = -o.vy * n, o.vx *= 1 - i, o.collisionCount++), e.wallsEnabled && (o.x < 0 && (o.x = 0, o.vx = -o.vx * n, o.vy *= 1 - i, o.collisionCount++), o.x > 1 && (o.x = 1, o.vx = -o.vx * n, o.vy *= 1 - i, o.collisionCount++));
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = this.getEmitterSpawnPosition(e), i = n.direction !== void 0 ? n.direction : e.direction, o = e.spread * Math.PI / 180, r = i * Math.PI / 180 + (this.rng.next() - 0.5) * o, c = this.rng.variance(e.speed, e.speedVariance) * 1e-3, u = Math.max(1, this.rng.variance(e.size, e.sizeVariance)), d = Math.max(1, this.rng.variance(e.particleLifetime, e.lifetimeVariance));
    let h = 0, p = 0;
    const f = e.sprite;
    if (f && f.rotationEnabled) {
      h = this.rng.angle();
      const g = f.rotationSpeed * (Math.PI / 180), x = f.rotationSpeedVariance * (Math.PI / 180);
      p = this.rng.variance(g, x);
    }
    f && f.alignToVelocity && (h = r);
    let m = 0;
    f && f.isSheet && f.playMode === "random" && (m = this.rng.int(0, f.totalFrames - 1));
    const y = {
      id: this.nextParticleId++,
      x: n.x,
      y: n.y,
      prevX: n.x,
      prevY: n.y,
      vx: Math.cos(r) * c,
      vy: Math.sin(r) * c,
      age: 0,
      lifetime: d,
      size: u,
      baseSize: u,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1,
      rotation: h,
      angularVelocity: p,
      spriteIndex: m,
      collisionCount: 0
    };
    this.particles.push(y), this.trailHistory.set(y.id, [{ x: y.x, y: y.y }]);
  }
  /**
   * Calculate spawn position based on emitter shape
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   * Returns position and optionally a direction override for spline emission
   */
  getEmitterSpawnPosition(e) {
    switch (e.shape || "point") {
      case "point":
        return { x: e.x, y: e.y };
      case "line": {
        const i = this.rng.next(), o = e.shapeWidth / 2, a = e.direction * Math.PI / 180, r = -Math.sin(a), l = Math.cos(a);
        return {
          x: e.x + r * (i - 0.5) * o * 2,
          y: e.y + l * (i - 0.5) * o * 2
        };
      }
      case "circle": {
        const i = e.shapeRadius;
        if (e.emitFromEdge) {
          const o = this.rng.angle();
          return {
            x: e.x + Math.cos(o) * i,
            y: e.y + Math.sin(o) * i
          };
        } else {
          const o = this.rng.angle(), a = i * Math.sqrt(this.rng.next());
          return {
            x: e.x + Math.cos(o) * a,
            y: e.y + Math.sin(o) * a
          };
        }
      }
      case "ring": {
        const i = e.shapeInnerRadius, o = e.shapeRadius, a = this.rng.angle(), r = Math.sqrt(this.rng.next() * (o * o - i * i) + i * i);
        return {
          x: e.x + Math.cos(a) * r,
          y: e.y + Math.sin(a) * r
        };
      }
      case "box": {
        const i = e.shapeWidth / 2, o = e.shapeHeight / 2;
        if (e.emitFromEdge) {
          const a = 2 * (e.shapeWidth + e.shapeHeight), r = this.rng.next() * a;
          return r < e.shapeWidth ? { x: e.x - i + r, y: e.y - o } : r < e.shapeWidth + e.shapeHeight ? { x: e.x + i, y: e.y - o + (r - e.shapeWidth) } : r < 2 * e.shapeWidth + e.shapeHeight ? { x: e.x + i - (r - e.shapeWidth - e.shapeHeight), y: e.y + o } : { x: e.x - i, y: e.y + o - (r - 2 * e.shapeWidth - e.shapeHeight) };
        } else
          return {
            x: e.x + (this.rng.next() - 0.5) * e.shapeWidth,
            y: e.y + (this.rng.next() - 0.5) * e.shapeHeight
          };
      }
      case "sphere": {
        const i = e.shapeRadius;
        if (e.emitFromEdge) {
          const o = this.rng.angle(), a = Math.acos(2 * this.rng.next() - 1);
          return {
            x: e.x + Math.sin(a) * Math.cos(o) * i,
            y: e.y + Math.sin(a) * Math.sin(o) * i
            // z would be: Math.cos(phi) * radius
          };
        } else {
          let o, a, r;
          do
            o = (this.rng.next() - 0.5) * 2, a = (this.rng.next() - 0.5) * 2, r = (this.rng.next() - 0.5) * 2;
          while (o * o + a * a + r * r > 1);
          return {
            x: e.x + o * i,
            y: e.y + a * i
          };
        }
      }
      case "spline":
        return this.getSplineEmitPosition(e);
      default:
        return { x: e.x, y: e.y };
    }
  }
  /**
   * Get emission position along a spline path
   * Returns position and optionally modifies emission direction
   * DETERMINISM: Uses seeded RNG (this.rng) for random positions
   */
  getSplineEmitPosition(e) {
    const n = e.splinePath;
    if (!n || !this.splineProvider)
      return { x: e.x, y: e.y };
    let i;
    switch (n.emitMode) {
      case "start":
        i = n.parameter * this.rng.next() * 0.1;
        break;
      case "end":
        i = 1 - n.parameter * this.rng.next() * 0.1;
        break;
      case "random":
        i = this.rng.next();
        break;
      case "uniform":
        const c = Math.max(0.01, n.parameter), u = Math.ceil(1 / c);
        i = this.rng.int(0, u - 1) * c;
        break;
      case "sequential":
        const h = this.sequentialEmitT.get(e.id) ?? 0;
        i = h;
        const p = Math.max(1e-3, n.parameter);
        let f = h + p;
        f > 1 && (f = f - 1), this.sequentialEmitT.set(e.id, f);
        break;
      default:
        i = this.rng.next();
    }
    i = Math.max(0, Math.min(1, i));
    const o = this.splineProvider(n.layerId, i, this.currentFrame);
    if (!o)
      return { x: e.x, y: e.y };
    let a = o.point.x, r = o.point.y;
    if (n.offset !== 0) {
      const c = Math.sqrt(o.tangent.x ** 2 + o.tangent.y ** 2);
      if (c > 1e-4) {
        const u = -o.tangent.y / c, d = o.tangent.x / c;
        a += u * n.offset, r += d * n.offset;
      }
    }
    let l;
    if (n.alignToPath) {
      const c = Math.atan2(o.tangent.y, o.tangent.x) * (180 / Math.PI);
      n.bidirectional && this.rng.bool(0.5) ? l = c + 180 : l = c, l += 90;
    }
    return { x: a, y: r, direction: l };
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), i = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || i < 0 || i >= this.boundaryMask.height)
      return;
    const o = (i * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[o] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = this.rng.next(), e.y = this.rng.next();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const i of this.modulations) {
      if (i.emitterId !== "*" && i.emitterId !== e.emitterId) continue;
      const o = i.easing, a = Oc[o] || Oc.linear, r = x7(n, a), l = i.startValue + (i.endValue - i.startValue) * r;
      switch (i.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const c = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (c > 1e-4) {
            const u = l / Math.max(1e-4, c * 1e3);
            e.vx *= u, e.vy *= u;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const i = this.config.turbulenceFields || [];
    for (const o of i) {
      if (!o.enabled) continue;
      const a = e.x * o.scale * 1e3, r = e.y * o.scale * 1e3, l = this.noiseTime * o.evolutionSpeed, c = this.noise2D(a + l, r + l) * Math.PI * 2, u = o.strength * 1e-5;
      e.vx += Math.cos(c) * u * n, e.vy += Math.sin(c) * u * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var o;
    const i = (o = this.config.turbulenceFields) == null ? void 0 : o.find((a) => a.id === e);
    i && Object.assign(i, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  /**
   * Trigger sub-emitters when a particle dies
   * DETERMINISM: Uses seeded RNG (this.rng) for all randomness
   */
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const i of n)
      if (i.enabled && !(i.parentEmitterId !== "*" && i.parentEmitterId !== e.emitterId))
        for (let o = 0; o < i.spawnCount; o++) {
          const a = (this.rng.next() - 0.5) * i.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + a, c = Math.sqrt(e.vx ** 2 + e.vy ** 2) * i.inheritVelocity, u = i.speed * 1e-3 + c, d = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * u + e.vx * i.inheritVelocity,
            vy: Math.sin(l) * u + e.vy * i.inheritVelocity,
            age: 0,
            lifetime: i.lifetime * (1 + (this.rng.next() - 0.5) * 0.2),
            size: i.size * (1 + (this.rng.next() - 0.5) * i.sizeVariance / i.size),
            baseSize: i.size,
            color: [...i.color, 255],
            baseColor: [...i.color, 255],
            emitterId: i.id,
            isSubParticle: !0,
            rotation: e.rotation,
            // Inherit parent rotation
            angularVelocity: 0,
            spriteIndex: 0,
            collisionCount: 0
          };
          this.particles.push(d), this.trailHistory.set(d.id, [{ x: d.x, y: d.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var o;
    const i = (o = this.config.subEmitters) == null ? void 0 : o.find((a) => a.id === e);
    i && Object.assign(i, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const i = this.emitters.get(e);
    if (!i || !i.enabled) return;
    const o = n ?? i.burstCount ?? 20;
    for (let a = 0; a < o; a++)
      this.spawnParticle(i);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var i;
    const e = ((i = this.renderOptions.connections) == null ? void 0 : i.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const o of this.particles) {
      const a = Math.floor(o.x * 1e3 / e), r = Math.floor(o.y * 1e3 / e), l = `${a},${r}`;
      n.has(l) || n.set(l, []), n.get(l).push(o);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const i = Math.floor(e.x * 1e3 / n.cellSize), o = Math.floor(e.y * 1e3 / n.cellSize), a = [];
    for (let r = -1; r <= 1; r++)
      for (let l = -1; l <= 1; l++) {
        const c = `${i + r},${o + l}`, u = n.cells.get(c);
        u && a.push(...u);
      }
    return a;
  }
  renderConnections(e, n, i) {
    const o = this.renderOptions.connections;
    if (!(o != null && o.enabled) || this.particles.length < 2) return;
    const a = this.buildSpatialGrid(), r = o.maxDistance / 1e3, l = r * r;
    e.lineWidth = o.lineWidth;
    for (const c of this.particles) {
      const u = this.getNeighborParticles(c, a);
      let d = 0;
      for (const h of u) {
        if (h.id <= c.id) continue;
        if (d >= o.maxConnections) break;
        const p = h.x - c.x, f = h.y - c.y, m = p * p + f * f;
        if (m < l) {
          const y = Math.sqrt(m);
          let g = o.lineOpacity;
          o.fadeByDistance && (g *= 1 - y / r);
          const x = Math.round((c.color[0] + h.color[0]) / 2), w = Math.round((c.color[1] + h.color[1]) / 2), M = Math.round((c.color[2] + h.color[2]) / 2);
          e.strokeStyle = `rgba(${x},${w},${M},${g})`, e.beginPath(), e.moveTo(c.x * n, c.y * i), e.lineTo(h.x * n, h.y * i), e.stroke(), d++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0, this.sequentialEmitT.clear(), this.currentFrame = 0;
  }
  /**
   * Restore particles from serialized state (for checkpoint restoration)
   * DETERMINISM: Restores exact particle positions for scrub-safe simulation
   *
   * @param particleStates - Array of serialized particle states from a checkpoint
   * @param frameCount - The frame number being restored to
   */
  restoreParticles(e, n) {
    this.particles = [], this.trailHistory.clear();
    let i = 0;
    for (const o of e) {
      const a = {
        id: o.id,
        x: o.x,
        y: o.y,
        prevX: o.x,
        // Previous position set to current (no trail initially)
        prevY: o.y,
        vx: o.vx,
        vy: o.vy,
        age: o.age,
        lifetime: o.lifetime,
        size: o.size,
        baseSize: o.size,
        // Base size set to current
        color: [...o.color],
        baseColor: [...o.color],
        emitterId: o.emitterId,
        isSubParticle: !1,
        rotation: o.rotation,
        angularVelocity: 0,
        // Default angular velocity
        spriteIndex: 0,
        collisionCount: 0
        // Reset collision count on restore
      };
      this.particles.push(a), i = Math.max(i, o.id);
    }
    this.nextParticleId = i + 1, this.frameCount = n;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, i, o = ap()) {
    switch (this.renderOptions = o, e.save(), o.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, i);
    for (const a of this.particles) {
      const r = a.x * n, l = a.y * i, c = a.size;
      if (o.renderTrails) {
        const u = this.trailHistory.get(a.id);
        if (u && u.length > 1) {
          e.beginPath(), e.moveTo(r, l);
          const d = Math.min(u.length, o.trailLength);
          for (let h = 0; h < d; h++) {
            const p = u[h], f = a.color[3] * Math.pow(o.trailOpacityFalloff, h + 1);
            e.strokeStyle = `rgba(${a.color[0]}, ${a.color[1]}, ${a.color[2]}, ${f / 255})`, e.lineWidth = c * Math.pow(o.trailOpacityFalloff, h), e.lineTo(p.x * n, p.y * i);
          }
          e.stroke();
        }
      }
      o.glowEnabled ? (e.shadowBlur = o.glowRadius, e.shadowColor = `rgba(${a.color[0]}, ${a.color[1]}, ${a.color[2]}, ${o.glowIntensity})`) : e.shadowBlur = 0, o.motionBlur && (a.vx !== 0 || a.vy !== 0) ? this.renderParticleWithMotionBlur(e, a, r, l, c, n, i, o) : this.renderParticleShape(e, r, l, c, a.color, o.particleShape, a, o);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, i, o, a, r, l, c) {
    const u = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (u < 1e-4) {
      this.renderParticleShape(e, i, o, a, n.color, c.particleShape);
      return;
    }
    const d = c.motionBlurStrength * u * 500, h = Math.min(c.motionBlurSamples, 16), p = n.vx / u, f = n.vy / u, m = Math.min(d * a, a * 10);
    for (let y = 0; y < h; y++) {
      const g = y / (h - 1), x = (1 - g * 0.8) / h, w = i - p * m * g, M = o - f * m * g, _ = a * (1 - g * 0.3), C = n.color[3] / 255 * x * h;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, C)})`, this.renderParticleShape(e, w, M, _, null, c.particleShape, n, c);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, i, o, a, n.color, c.particleShape, n, c);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, i, o, a, r, l, c) {
    if (a && (e.fillStyle = `rgba(${a[0]}, ${a[1]}, ${a[2]}, ${a[3] / 255})`), r === "sprite" && l) {
      this.renderSprite(e, n, i, o, l, c);
      return;
    }
    if (l && l.rotation !== 0 && l)
      e.save(), e.translate(n, i), e.rotate(l.rotation), this.drawShapeAtOrigin(e, o, r), e.restore();
    else
      switch (r) {
        case "circle":
          e.beginPath(), e.arc(n, i, o / 2, 0, Math.PI * 2), e.fill();
          break;
        case "square":
          e.fillRect(n - o / 2, i - o / 2, o, o);
          break;
        case "triangle":
          e.beginPath(), e.moveTo(n, i - o / 2), e.lineTo(n - o / 2, i + o / 2), e.lineTo(n + o / 2, i + o / 2), e.closePath(), e.fill();
          break;
        case "star":
          this.drawStar(e, n, i, 5, o / 2, o / 4), e.fill();
          break;
      }
  }
  /**
   * Draw shape at origin (for rotated shapes)
   */
  drawShapeAtOrigin(e, n, i) {
    switch (i) {
      case "circle":
        e.beginPath(), e.arc(0, 0, n / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(-n / 2, -n / 2, n, n);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(0, -n / 2), e.lineTo(-n / 2, n / 2), e.lineTo(n / 2, n / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, 0, 0, 5, n / 2, n / 4), e.fill();
        break;
    }
  }
  /**
   * Render a sprite/texture particle
   */
  renderSprite(e, n, i, o, a, r) {
    var g;
    const l = this.emitters.get(a.emitterId);
    if (!((g = l == null ? void 0 : l.sprite) != null && g.enabled)) {
      e.beginPath(), e.arc(n, i, o / 2, 0, Math.PI * 2), e.fill();
      return;
    }
    const c = l.sprite, u = c.imageData || this.spriteCache.get(a.emitterId);
    if (!u) {
      e.beginPath(), e.arc(n, i, o / 2, 0, Math.PI * 2), e.fill();
      return;
    }
    e.save(), e.imageSmoothingEnabled = (r == null ? void 0 : r.spriteSmoothing) ?? !0;
    let d = a.color[3] / 255;
    if (r != null && r.spriteOpacityByAge) {
      const x = a.age / a.lifetime;
      x > 0.8 && (d *= 1 - (x - 0.8) / 0.2);
    }
    e.globalAlpha = d;
    let h = 0, p = 0, f = u.width, m = u.height;
    if (c.isSheet && c.columns > 1 || c.rows > 1) {
      const x = u.width / c.columns, w = u.height / c.rows, M = a.spriteIndex % c.columns, _ = Math.floor(a.spriteIndex / c.columns) % c.rows;
      h = M * x, p = _ * w, f = x, m = w;
    }
    e.translate(n, i), a.rotation !== 0 && e.rotate(a.rotation);
    const y = o / 2;
    e.drawImage(
      u,
      h,
      p,
      f,
      m,
      // Source rectangle
      -y,
      -y,
      o,
      o
      // Destination rectangle
    ), e.restore();
  }
  drawStar(e, n, i, o, a, r) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let c = 0; c < o; c++) {
      const u = n + Math.cos(l) * a, d = i + Math.sin(l) * a;
      c === 0 ? e.moveTo(u, d) : e.lineTo(u, d), l += Math.PI / o;
      const h = n + Math.cos(l) * r, p = i + Math.sin(l) * r;
      e.lineTo(h, p), l += Math.PI / o;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const o = new OffscreenCanvas(e, n).getContext("2d");
    o.fillStyle = "#FFFFFF", o.fillRect(0, 0, e, n);
    const a = this.renderOptions.connections;
    a != null && a.enabled && this.particles.length >= 2 && (o.strokeStyle = "#000000", o.lineWidth = a.lineWidth * 2, this.renderConnections(o, e, n)), o.fillStyle = "#000000";
    for (const r of this.particles) {
      const l = r.x * e, c = r.y * n, u = r.size * 1.5;
      o.beginPath(), o.arc(l, c, u / 2, 0, Math.PI * 2), o.fill();
    }
    return o.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new lu(e.config);
    if (e.emitters)
      for (const i of e.emitters)
        n.addEmitter(i);
    if (e.gravityWells)
      for (const i of e.gravityWells)
        n.addGravityWell(i);
    if (e.vortices)
      for (const i of e.vortices)
        n.addVortex(i);
    if (e.modulations)
      for (const i of e.modulations)
        n.addModulation(i);
    return n;
  }
}
class T7 {
  constructor(e) {
    le(this, "state");
    this.state = e;
  }
  /** Reset to initial seed */
  reset(e) {
    this.state = e;
  }
  /** Get next random number in [0, 1) */
  next() {
    let e = this.state += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
  }
  /** Get random in range [min, max] */
  range(e, n) {
    return e + this.next() * (n - e);
  }
  /** Get current state for checkpointing */
  getState() {
    return this.state;
  }
  /** Restore state from checkpoint */
  setState(e) {
    this.state = e;
  }
}
class E7 {
  constructor(e, n = 12345, i = 30) {
    /** The underlying particle system (used for simulation) */
    le(this, "system");
    /** Configuration (immutable after construction) */
    le(this, "config");
    /** Master seed for deterministic simulation */
    le(this, "seed");
    /** Seeded RNG instance */
    le(this, "rng");
    /** Checkpoint interval (frames between cached states) */
    le(this, "checkpointInterval");
    /** Cached checkpoints: frame  checkpoint */
    le(this, "checkpoints");
    /** Last evaluated frame (for optimization) */
    le(this, "lastEvaluatedFrame", -1);
    /** Last snapshot (cached for repeated access) */
    le(this, "lastSnapshot", null);
    this.config = { ...e }, this.seed = n, this.rng = new T7(n), this.checkpointInterval = i, this.checkpoints = /* @__PURE__ */ new Map(), this.system = new lu(e, n), this.createCheckpoint(0);
  }
  /**
   * Evaluate particle state at a specific frame
   *
   * PURE (relative to frame number): Same frame always produces same result.
   *
   * @param frame - Target frame number
   * @returns Immutable ParticleSnapshot
   */
  evaluateAtFrame(e) {
    if (e === this.lastEvaluatedFrame && this.lastSnapshot)
      return this.lastSnapshot;
    const n = this.findNearestCheckpoint(e);
    this.restoreCheckpoint(n);
    const i = e - n;
    for (let a = 0; a < i; a++) {
      this.deterministicStep();
      const r = n + a + 1;
      r % this.checkpointInterval === 0 && !this.checkpoints.has(r) && this.createCheckpoint(r);
    }
    const o = this.createSnapshot(e);
    return this.lastEvaluatedFrame = e, this.lastSnapshot = o, o;
  }
  /**
   * Get the underlying particles for rendering
   * NOTE: This is a convenience method; prefer evaluateAtFrame() for determinism
   */
  getParticles() {
    return this.system.getParticles();
  }
  /**
   * Reset controller and clear all checkpoints
   */
  reset() {
    this.system.reset(), this.rng.reset(this.seed), this.checkpoints.clear(), this.lastEvaluatedFrame = -1, this.lastSnapshot = null, this.createCheckpoint(0);
  }
  /**
   * Update configuration (clears all checkpoints)
   */
  updateConfig(e) {
    Object.assign(this.config, e), this.system.setConfig(e), this.reset();
  }
  /**
   * Get current seed
   */
  getSeed() {
    return this.seed;
  }
  // ============================================================================
  // PRIVATE METHODS
  // ============================================================================
  /**
   * Find the frame number of the nearest checkpoint at or before target
   */
  findNearestCheckpoint(e) {
    let n = 0;
    for (const i of this.checkpoints.keys())
      i <= e && i > n && (n = i);
    return n;
  }
  /**
   * Create a checkpoint at the current state
   * DETERMINISM: Captures RNG state for exact restoration
   */
  createCheckpoint(e) {
    const n = this.system.getParticles().map((o) => this.serializeParticle(o)), i = {
      frame: e,
      particles: n,
      emissionAccumulators: /* @__PURE__ */ new Map(),
      // Would need access to system internals
      nextParticleId: n.length > 0 ? Math.max(...n.map((o) => o.id)) + 1 : 0,
      noiseTime: 0,
      // Would need access to system internals
      frameCount: e,
      // Capture RNG state from the particle system for deterministic restoration
      rngState: this.system.getRng().getState()
    };
    this.checkpoints.set(e, i);
  }
  /**
   * Restore state from a checkpoint
   * DETERMINISM: Restores exact RNG state for reproducible continuation
   */
  restoreCheckpoint(e) {
    const n = this.checkpoints.get(e);
    if (!n)
      throw new Error(`No checkpoint at frame ${e}`);
    this.system.getRng().setState(n.rngState), this.rng.setState(n.rngState), this.system.restoreParticles(n.particles, n.frame);
  }
  /**
   * Perform one deterministic simulation step
   * DETERMINISM: ParticleSystem now uses seeded RNG (mulberry32) for all randomness
   */
  deterministicStep() {
    this.system.step(1);
  }
  /**
   * Serialize a particle to immutable state
   */
  serializeParticle(e) {
    return Object.freeze({
      id: e.id,
      x: e.x,
      y: e.y,
      vx: e.vx,
      vy: e.vy,
      age: e.age,
      lifetime: e.lifetime,
      size: e.size,
      color: Object.freeze([...e.color]),
      rotation: e.rotation,
      emitterId: e.emitterId
    });
  }
  /**
   * Create an immutable snapshot of current state
   * DETERMINISM: No timestamps - only deterministic values
   */
  createSnapshot(e) {
    const n = this.system.getParticles().map((i) => this.serializeParticle(i));
    return Object.freeze({
      frame: e,
      particles: Object.freeze(n),
      count: n.length,
      seed: this.seed,
      rngState: this.system.getRng().getState()
    });
  }
}
class A7 {
  constructor() {
    le(this, "controllers", /* @__PURE__ */ new Map());
  }
  /**
   * Get or create a controller for a layer
   */
  getController(e, n, i) {
    let o = this.controllers.get(e);
    return o || (o = new E7(n, i ?? this.generateSeed(e)), this.controllers.set(e, o)), o;
  }
  /**
   * Evaluate particles for a layer at a frame
   */
  evaluateLayer(e, n, i, o) {
    return this.getController(e, i, o).evaluateAtFrame(n);
  }
  /**
   * Reset a specific layer's controller
   */
  resetLayer(e) {
    const n = this.controllers.get(e);
    n && n.reset();
  }
  /**
   * Clear all controllers
   */
  clear() {
    this.controllers.clear();
  }
  /**
   * Generate deterministic seed from layer ID
   */
  generateSeed(e) {
    let n = 0;
    for (let i = 0; i < e.length; i++) {
      const o = e.charCodeAt(i);
      n = (n << 5) - n + o, n = n & n;
    }
    return Math.abs(n);
  }
}
const nd = new A7();
class P7 {
  /**
   * Internal state: NONE
   * This class is intentionally stateless between evaluate() calls
   */
  /**
   * Evaluate complete frame state
   *
   * PURE FUNCTION: Same inputs always produce same outputs
   * NO SIDE EFFECTS: Does not mutate project, layers, or any external state
   *
   * @param frame - Absolute frame number (0-indexed)
   * @param project - The project data (read-only)
   * @param audioAnalysis - Pre-computed audio analysis (optional)
   * @param activeCameraId - ID of active camera layer (optional)
   * @returns Immutable FrameState snapshot
   */
  evaluate(e, n, i, o) {
    const a = n.compositions[n.mainCompositionId];
    if (!a)
      return this.createEmptyFrameState(e, n.composition);
    const r = this.evaluateLayers(e, a.layers), l = this.evaluateCamera(
      e,
      a.layers,
      o ?? null
    ), c = this.evaluateAudio(e, i ?? null), u = this.evaluateParticleLayers(e, a.layers);
    return Object.freeze({
      frame: e,
      composition: a.settings,
      layers: Object.freeze(r),
      camera: l,
      audio: c,
      particleSnapshots: Object.freeze(u)
    });
  }
  /**
   * Evaluate a single property at a given frame
   * Utility method for UI components that need individual values
   */
  evaluateProperty(e, n) {
    return mt(e, n);
  }
  /**
   * Check if a layer is visible at a given frame
   */
  isLayerVisibleAtFrame(e, n) {
    return e.visible && n >= e.inPoint && n <= e.outPoint;
  }
  // ============================================================================
  // PRIVATE EVALUATION METHODS
  // ============================================================================
  evaluateLayers(e, n) {
    const i = [];
    for (const o of n) {
      const a = e >= o.inPoint && e <= o.outPoint, r = o.visible && a, l = this.evaluateTransform(e, o.transform, o.threeD), c = mt(o.opacity, e), u = this.evaluateEffects(e, o.effects), d = this.evaluateLayerProperties(e, o);
      i.push(Object.freeze({
        id: o.id,
        type: o.type,
        name: o.name,
        visible: r,
        inRange: a,
        opacity: c,
        transform: Object.freeze(l),
        effects: Object.freeze(u),
        properties: Object.freeze(d),
        parentId: o.parentId,
        blendMode: o.blendMode,
        threeD: o.threeD,
        layerRef: o
        // Reference for static data only - NOT for evaluation
      }));
    }
    return i;
  }
  evaluateTransform(e, n, i) {
    const o = mt(n.position, e), a = mt(n.anchorPoint, e), r = mt(n.scale, e), l = mt(n.rotation, e), c = {
      position: { ...o },
      anchorPoint: { ...a },
      scale: { ...r },
      rotation: l
    };
    return i ? {
      ...c,
      rotationX: n.rotationX ? mt(n.rotationX, e) : 0,
      rotationY: n.rotationY ? mt(n.rotationY, e) : 0,
      rotationZ: n.rotationZ ? mt(n.rotationZ, e) : l
    } : c;
  }
  evaluateEffects(e, n) {
    return n.map((i) => {
      const o = {};
      for (const [a, r] of Object.entries(i.parameters))
        this.isAnimatableProperty(r) ? o[a] = mt(r, e) : o[a] = r;
      return Object.freeze({
        id: i.id,
        type: i.effectKey,
        // Use effectKey as the effect type identifier
        enabled: i.enabled,
        parameters: Object.freeze(o)
      });
    });
  }
  evaluateLayerProperties(e, n) {
    const i = {};
    for (const o of n.properties)
      i[o.name] = mt(o, e);
    switch (n.type) {
      case "text":
        n.data && "fontSize" in n.data;
        break;
      case "solid":
        break;
      case "depthflow":
        if (n.data && "animatedZoom" in n.data) {
          const o = n.data;
          o.animatedZoom && (i.zoom = mt(o.animatedZoom, e)), o.animatedOffsetX && (i.offsetX = mt(o.animatedOffsetX, e)), o.animatedOffsetY && (i.offsetY = mt(o.animatedOffsetY, e)), o.animatedRotation && (i.rotation = mt(o.animatedRotation, e));
        }
        break;
      case "particles":
        i._requiresSimulation = !0;
        break;
    }
    return i;
  }
  evaluateCamera(e, n, i) {
    var m, y, g, x;
    let o;
    if (i && (o = n.find(
      (w) => w.id === i && w.type === "camera"
    )), o || (o = n.find(
      (w) => w.type === "camera" && w.visible && e >= w.inPoint && e <= w.outPoint
    )), !o || !o.data)
      return null;
    const a = o.data, r = this.evaluateTransform(e, o.transform, !0);
    let l = { x: r.position.x, y: r.position.y, z: 0 }, c = { x: 0, y: 0, z: 0 }, u = 50, d = 50;
    if (a.animatedPosition) {
      const w = mt(a.animatedPosition, e);
      l = { x: w.x, y: w.y, z: w.z ?? 0 };
    }
    if (a.animatedTarget) {
      const w = mt(a.animatedTarget, e);
      c = { x: w.x, y: w.y, z: w.z ?? 0 };
    }
    a.animatedFov && (u = mt(a.animatedFov, e)), a.animatedFocalLength && (d = mt(a.animatedFocalLength, e));
    let h = ((m = a.depthOfField) == null ? void 0 : m.focusDistance) ?? 1e3, p = ((y = a.depthOfField) == null ? void 0 : y.aperture) ?? 2.8, f = ((g = a.depthOfField) == null ? void 0 : g.blurLevel) ?? 50;
    return a.animatedFocusDistance && (h = mt(a.animatedFocusDistance, e)), a.animatedAperture && (p = mt(a.animatedAperture, e)), a.animatedBlurLevel && (f = mt(a.animatedBlurLevel, e)), Object.freeze({
      id: o.id,
      name: o.name,
      position: Object.freeze(l),
      target: Object.freeze(c),
      fov: u,
      focalLength: d,
      depthOfField: Object.freeze({
        enabled: ((x = a.depthOfField) == null ? void 0 : x.enabled) ?? !1,
        focusDistance: h,
        aperture: p,
        blurLevel: f
      })
    });
  }
  evaluateAudio(e, n) {
    return Object.freeze(n ? {
      hasAudio: !0,
      amplitude: Li(n, "amplitude", e),
      rms: Li(n, "rms", e),
      bass: Li(n, "bass", e),
      mid: Li(n, "mid", e),
      high: Li(n, "high", e),
      spectralCentroid: Li(n, "spectralCentroid", e),
      isBeat: Li(n, "onsets", e) > 0.5,
      isOnset: Li(n, "onsets", e) > 0,
      bpm: n.bpm
    } : {
      hasAudio: !1,
      amplitude: 0,
      rms: 0,
      bass: 0,
      mid: 0,
      high: 0,
      spectralCentroid: 0,
      isBeat: !1,
      isOnset: !1,
      bpm: 0
    });
  }
  /**
   * Evaluate particle layers through deterministic simulation
   * DETERMINISM: Uses ParticleSimulationRegistry which guarantees same frame = same result
   */
  evaluateParticleLayers(e, n) {
    const i = {};
    for (const o of n) {
      if (o.type !== "particles" || !o.visible || e < o.inPoint || e > o.outPoint) continue;
      const a = o.data;
      if (!(a != null && a.systemConfig)) continue;
      const r = this.convertToParticleSystemConfig(a), l = e - o.inPoint, c = nd.evaluateLayer(
        o.id,
        l,
        r
      );
      i[o.id] = c;
    }
    return i;
  }
  /**
   * Convert ParticleLayerData to ParticleSystemConfig
   * Maps the project-level configuration to the simulation config
   */
  convertToParticleSystemConfig(e) {
    const n = e.systemConfig;
    return {
      maxParticles: n.maxParticles,
      gravity: n.gravity,
      windStrength: n.windStrength,
      windDirection: n.windDirection,
      warmupPeriod: n.warmupPeriod,
      respectMaskBoundary: n.respectMaskBoundary,
      boundaryBehavior: n.boundaryBehavior,
      friction: n.friction,
      turbulenceFields: n.turbulenceFields ?? [],
      subEmitters: n.subEmitters ?? [],
      collision: {
        enabled: !1,
        particleCollision: !1,
        particleCollisionRadius: 1,
        particleCollisionResponse: "bounce",
        particleCollisionDamping: 0.5,
        layerCollision: !1,
        layerCollisionLayerId: null,
        layerCollisionThreshold: 0.5,
        floorEnabled: !1,
        floorY: 1,
        ceilingEnabled: !1,
        ceilingY: 0,
        wallsEnabled: !1,
        bounciness: 0.8,
        friction: 0.1,
        spatialHashCellSize: 32
      }
    };
  }
  /**
   * Create empty frame state for missing compositions
   * DETERMINISM: No timestamps or non-deterministic values
   */
  createEmptyFrameState(e, n) {
    return Object.freeze({
      frame: e,
      composition: n,
      layers: Object.freeze([]),
      camera: null,
      audio: Object.freeze({
        hasAudio: !1,
        amplitude: 0,
        rms: 0,
        bass: 0,
        mid: 0,
        high: 0,
        spectralCentroid: 0,
        isBeat: !1,
        isOnset: !1,
        bpm: 0
      }),
      particleSnapshots: Object.freeze({})
    });
  }
  /**
   * Type guard to check if a value is an AnimatableProperty
   */
  isAnimatableProperty(e) {
    return typeof e == "object" && e !== null && "value" in e && "keyframes" in e && Array.isArray(e.keyframes);
  }
}
const k7 = new P7();
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const yh = "170", D7 = 0, rp = 1, I7 = 2, j3 = 1, X3 = 2, Vs = 3, L0 = 0, vi = 1, mn = 2, si = 0, rs = 1, ha = 2, id = 3, ra = 4, E0 = 5, Oi = 100, Y3 = 101, R7 = 102, q3 = 103, Z3 = 104, sd = 200, Hs = 201, L7 = 202, od = 203, Uc = 204, Or = 205, K3 = 206, F7 = 207, J3 = 208, Q3 = 209, O7 = 210, U7 = 211, z7 = 212, B7 = 213, N7 = 214, ad = 0, rd = 1, ld = 2, fa = 3, cd = 4, ud = 5, dd = 6, hd = 7, em = 0, V7 = 1, H7 = 2, D0 = 0, tm = 1, nm = 2, im = 3, xh = 4, G7 = 5, sm = 6, om = 7, Zo = 300, pa = 301, ma = 302, fd = 303, pd = 304, cu = 306, Ur = 1e3, pi = 1001, md = 1002, xn = 1003, $7 = 1004, hl = 1005, Dt = 1006, ju = 1007, ao = 1008, ps = 1009, am = 1010, rm = 1011, zr = 1012, bh = 1013, mo = 1014, Vn = 1015, gi = 1016, _h = 1017, wh = 1018, vo = 1020, lm = 35902, cm = 1021, um = 1022, Sn = 1023, dm = 1024, hm = 1025, ho = 1026, go = 1027, Br = 1028, Mh = 1029, fm = 1030, Sh = 1031, Ch = 1033, hc = 33776, fc = 33777, pc = 33778, mc = 33779, vd = 35840, gd = 35841, yd = 35842, xd = 35843, bd = 36196, _d = 37492, wd = 37496, Md = 37808, Sd = 37809, Cd = 37810, Td = 37811, Ed = 37812, Ad = 37813, Pd = 37814, kd = 37815, Dd = 37816, Id = 37817, Rd = 37818, Ld = 37819, Fd = 37820, Od = 37821, vc = 36492, Ud = 36494, zd = 36495, pm = 36283, Bd = 36284, Nd = 36285, Vd = 36286, W7 = 3200, Th = 3201, Eh = 0, j7 = 1, A0 = "", pn = "srgb", Sa = "srgb-linear", uu = "linear", Qt = "srgb", Eo = 7680, lp = 519, X7 = 512, Y7 = 513, q7 = 514, mm = 515, Z7 = 516, K7 = 517, J7 = 518, Q7 = 519, cp = 35044, Ao = 35048, up = "300 es", qs = 2e3, zc = 2001;
class xo {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const o = this._listeners[e];
    if (o !== void 0) {
      const a = o.indexOf(n);
      a !== -1 && o.splice(a, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const o = i.slice(0);
      for (let a = 0, r = o.length; a < r; a++)
        o[a].call(this, e);
      e.target = null;
    }
  }
}
const Kn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let dp = 1234567;
const xr = Math.PI / 180, va = 180 / Math.PI;
function bo() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Kn[s & 255] + Kn[s >> 8 & 255] + Kn[s >> 16 & 255] + Kn[s >> 24 & 255] + "-" + Kn[e & 255] + Kn[e >> 8 & 255] + "-" + Kn[e >> 16 & 15 | 64] + Kn[e >> 24 & 255] + "-" + Kn[n & 63 | 128] + Kn[n >> 8 & 255] + "-" + Kn[n >> 16 & 255] + Kn[n >> 24 & 255] + Kn[i & 255] + Kn[i >> 8 & 255] + Kn[i >> 16 & 255] + Kn[i >> 24 & 255]).toLowerCase();
}
function Nn(s, e, n) {
  return Math.max(e, Math.min(n, s));
}
function Ah(s, e) {
  return (s % e + e) % e;
}
function ev(s, e, n, i, o) {
  return i + (s - e) * (o - i) / (n - e);
}
function tv(s, e, n) {
  return s !== e ? (n - s) / (e - s) : 0;
}
function br(s, e, n) {
  return (1 - n) * s + n * e;
}
function nv(s, e, n, i) {
  return br(s, e, 1 - Math.exp(-n * i));
}
function iv(s, e = 1) {
  return e - Math.abs(Ah(s, e * 2) - e);
}
function sv(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * (3 - 2 * s));
}
function ov(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function av(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function rv(s, e) {
  return s + Math.random() * (e - s);
}
function lv(s) {
  return s * (0.5 - Math.random());
}
function cv(s) {
  s !== void 0 && (dp = s);
  let e = dp += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function uv(s) {
  return s * xr;
}
function dv(s) {
  return s * va;
}
function hv(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function fv(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function pv(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function mv(s, e, n, i, o) {
  const a = Math.cos, r = Math.sin, l = a(n / 2), c = r(n / 2), u = a((e + i) / 2), d = r((e + i) / 2), h = a((e - i) / 2), p = r((e - i) / 2), f = a((i - e) / 2), m = r((i - e) / 2);
  switch (o) {
    case "XYX":
      s.set(l * d, c * h, c * p, l * u);
      break;
    case "YZY":
      s.set(c * p, l * d, c * h, l * u);
      break;
    case "ZXZ":
      s.set(c * h, c * p, l * d, l * u);
      break;
    case "XZX":
      s.set(l * d, c * m, c * f, l * u);
      break;
    case "YXY":
      s.set(c * f, l * d, c * m, l * u);
      break;
    case "ZYZ":
      s.set(c * m, c * f, l * d, l * u);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + o);
  }
}
function Yo(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ui(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const ln = {
  DEG2RAD: xr,
  RAD2DEG: va,
  generateUUID: bo,
  clamp: Nn,
  euclideanModulo: Ah,
  mapLinear: ev,
  inverseLerp: tv,
  lerp: br,
  damp: nv,
  pingpong: iv,
  smoothstep: sv,
  smootherstep: ov,
  randInt: av,
  randFloat: rv,
  randFloatSpread: lv,
  seededRandom: cv,
  degToRad: uv,
  radToDeg: dv,
  isPowerOfTwo: hv,
  ceilPowerOfTwo: fv,
  floorPowerOfTwo: pv,
  setQuaternionFromProperEuler: mv,
  normalize: ui,
  denormalize: Yo
};
class qe {
  constructor(e = 0, n = 0) {
    qe.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, o = e.elements;
    return this.x = o[0] * n + o[3] * i + o[6], this.y = o[1] * n + o[4] * i + o[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Nn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n), o = Math.sin(n), a = this.x - e.x, r = this.y - e.y;
    return this.x = a * i - r * o + e.x, this.y = a * o + r * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class At {
  constructor(e, n, i, o, a, r, l, c, u) {
    At.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, o, a, r, l, c, u);
  }
  set(e, n, i, o, a, r, l, c, u) {
    const d = this.elements;
    return d[0] = e, d[1] = o, d[2] = l, d[3] = n, d[4] = a, d[5] = c, d[6] = i, d[7] = r, d[8] = u, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, o = n.elements, a = this.elements, r = i[0], l = i[3], c = i[6], u = i[1], d = i[4], h = i[7], p = i[2], f = i[5], m = i[8], y = o[0], g = o[3], x = o[6], w = o[1], M = o[4], _ = o[7], C = o[2], T = o[5], P = o[8];
    return a[0] = r * y + l * w + c * C, a[3] = r * g + l * M + c * T, a[6] = r * x + l * _ + c * P, a[1] = u * y + d * w + h * C, a[4] = u * g + d * M + h * T, a[7] = u * x + d * _ + h * P, a[2] = p * y + f * w + m * C, a[5] = p * g + f * M + m * T, a[8] = p * x + f * _ + m * P, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[1], o = e[2], a = e[3], r = e[4], l = e[5], c = e[6], u = e[7], d = e[8];
    return n * r * d - n * l * u - i * a * d + i * l * c + o * a * u - o * r * c;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], o = e[2], a = e[3], r = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = d * r - l * u, p = l * c - d * a, f = u * a - r * c, m = n * h + i * p + o * f;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / m;
    return e[0] = h * y, e[1] = (o * u - d * i) * y, e[2] = (l * i - o * r) * y, e[3] = p * y, e[4] = (d * n - o * c) * y, e[5] = (o * a - l * n) * y, e[6] = f * y, e[7] = (i * c - u * n) * y, e[8] = (r * n - i * a) * y, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, i, o, a, r, l) {
    const c = Math.cos(a), u = Math.sin(a);
    return this.set(
      i * c,
      i * u,
      -i * (c * r + u * l) + r + e,
      -o * u,
      o * c,
      -o * (-u * r + c * l) + l + n,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, n) {
    return this.premultiply(Xu.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(Xu.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(Xu.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      i,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let o = 0; o < 9; o++)
      if (n[o] !== i[o]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Xu = /* @__PURE__ */ new At();
function vm(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
function Nr(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function vv() {
  const s = Nr("canvas");
  return s.style.display = "block", s;
}
const hp = {};
function or(s) {
  s in hp || (hp[s] = !0, console.warn(s));
}
function gv(s, e, n) {
  return new Promise(function(i, o) {
    function a() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          o();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(a, n);
          break;
        default:
          i();
      }
    }
    setTimeout(a, n);
  });
}
function yv(s) {
  const e = s.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function xv(s) {
  const e = s.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const Nt = {
  enabled: !0,
  workingColorSpace: Sa,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(s, e, n) {
    return this.enabled === !1 || e === n || !e || !n || (this.spaces[e].transfer === Qt && (s.r = Js(s.r), s.g = Js(s.g), s.b = Js(s.b)), this.spaces[e].primaries !== this.spaces[n].primaries && (s.applyMatrix3(this.spaces[e].toXYZ), s.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === Qt && (s.r = la(s.r), s.g = la(s.g), s.b = la(s.b))), s;
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this.workingColorSpace);
  },
  getPrimaries: function(s) {
    return this.spaces[s].primaries;
  },
  getTransfer: function(s) {
    return s === A0 ? uu : this.spaces[s].transfer;
  },
  getLuminanceCoefficients: function(s, e = this.workingColorSpace) {
    return s.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(s) {
    Object.assign(this.spaces, s);
  },
  // Internal APIs
  _getMatrix: function(s, e, n) {
    return s.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(s) {
    return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(s = this.workingColorSpace) {
    return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
  }
};
function Js(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function la(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
const fp = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], pp = [0.2126, 0.7152, 0.0722], mp = [0.3127, 0.329], vp = /* @__PURE__ */ new At().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), gp = /* @__PURE__ */ new At().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
Nt.define({
  [Sa]: {
    primaries: fp,
    whitePoint: mp,
    transfer: uu,
    toXYZ: vp,
    fromXYZ: gp,
    luminanceCoefficients: pp,
    workingColorSpaceConfig: { unpackColorSpace: pn },
    outputColorSpaceConfig: { drawingBufferColorSpace: pn }
  },
  [pn]: {
    primaries: fp,
    whitePoint: mp,
    transfer: Qt,
    toXYZ: vp,
    fromXYZ: gp,
    luminanceCoefficients: pp,
    outputColorSpaceConfig: { drawingBufferColorSpace: pn }
  }
});
let Po;
class bv {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      Po === void 0 && (Po = Nr("canvas")), Po.width = e.width, Po.height = e.height;
      const i = Po.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = Po;
    }
    return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = Nr("canvas");
      n.width = e.width, n.height = e.height;
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const o = i.getImageData(0, 0, e.width, e.height), a = o.data;
      for (let r = 0; r < a.length; r++)
        a[r] = Js(a[r] / 255) * 255;
      return i.putImageData(o, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(Js(n[i] / 255) * 255) : n[i] = Js(n[i]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let _v = 0;
class gm {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: _v++ }), this.uuid = bo(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, o = this.data;
    if (o !== null) {
      let a;
      if (Array.isArray(o)) {
        a = [];
        for (let r = 0, l = o.length; r < l; r++)
          o[r].isDataTexture ? a.push(Yu(o[r].image)) : a.push(Yu(o[r]));
      } else
        a = Yu(o);
      i.url = a;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function Yu(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? bv.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let wv = 0;
class An extends xo {
  constructor(e = An.DEFAULT_IMAGE, n = An.DEFAULT_MAPPING, i = pi, o = pi, a = Dt, r = ao, l = Sn, c = ps, u = An.DEFAULT_ANISOTROPY, d = A0) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: wv++ }), this.uuid = bo(), this.name = "", this.source = new gm(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = i, this.wrapT = o, this.magFilter = a, this.minFilter = r, this.anisotropy = u, this.format = l, this.internalFormat = null, this.type = c, this.offset = new qe(0, 0), this.repeat = new qe(1, 1), this.center = new qe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new At(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), n || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Zo) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Ur:
          e.x = e.x - Math.floor(e.x);
          break;
        case pi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case md:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Ur:
          e.y = e.y - Math.floor(e.y);
          break;
        case pi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case md:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
An.DEFAULT_IMAGE = null;
An.DEFAULT_MAPPING = Zo;
An.DEFAULT_ANISOTROPY = 1;
class Kt {
  constructor(e = 0, n = 0, i = 0, o = 1) {
    Kt.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = i, this.w = o;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, o) {
    return this.x = e, this.y = n, this.z = i, this.w = o, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, o = this.z, a = this.w, r = e.elements;
    return this.x = r[0] * n + r[4] * i + r[8] * o + r[12] * a, this.y = r[1] * n + r[5] * i + r[9] * o + r[13] * a, this.z = r[2] * n + r[6] * i + r[10] * o + r[14] * a, this.w = r[3] * n + r[7] * i + r[11] * o + r[15] * a, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, o, a;
    const c = e.elements, u = c[0], d = c[4], h = c[8], p = c[1], f = c[5], m = c[9], y = c[2], g = c[6], x = c[10];
    if (Math.abs(d - p) < 0.01 && Math.abs(h - y) < 0.01 && Math.abs(m - g) < 0.01) {
      if (Math.abs(d + p) < 0.1 && Math.abs(h + y) < 0.1 && Math.abs(m + g) < 0.1 && Math.abs(u + f + x - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const M = (u + 1) / 2, _ = (f + 1) / 2, C = (x + 1) / 2, T = (d + p) / 4, P = (h + y) / 4, E = (m + g) / 4;
      return M > _ && M > C ? M < 0.01 ? (i = 0, o = 0.707106781, a = 0.707106781) : (i = Math.sqrt(M), o = T / i, a = P / i) : _ > C ? _ < 0.01 ? (i = 0.707106781, o = 0, a = 0.707106781) : (o = Math.sqrt(_), i = T / o, a = E / o) : C < 0.01 ? (i = 0.707106781, o = 0.707106781, a = 0) : (a = Math.sqrt(C), i = P / a, o = E / a), this.set(i, o, a, n), this;
    }
    let w = Math.sqrt((g - m) * (g - m) + (h - y) * (h - y) + (p - d) * (p - d));
    return Math.abs(w) < 1e-3 && (w = 1), this.x = (g - m) / w, this.y = (h - y) / w, this.z = (p - d) / w, this.w = Math.acos((u + f + x - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this.w = e.w + (n.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Mv extends xo {
  constructor(e = 1, n = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new Kt(0, 0, e, n), this.scissorTest = !1, this.viewport = new Kt(0, 0, e, n);
    const o = { width: e, height: n, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Dt,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const a = new An(o, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    a.flipY = !1, a.generateMipmaps = i.generateMipmaps, a.internalFormat = i.internalFormat, this.textures = [];
    const r = i.count;
    for (let l = 0; l < r; l++)
      this.textures[l] = a.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      this.width = e, this.height = n, this.depth = i;
      for (let o = 0, a = this.textures.length; o < a; o++)
        this.textures[o].image.width = e, this.textures[o].image.height = n, this.textures[o].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let i = 0, o = e.textures.length; i < o; i++)
      this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const n = Object.assign({}, e.texture.image);
    return this.texture.source = new gm(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Xn extends Mv {
  constructor(e = 1, n = 1, i = {}) {
    super(e, n, i), this.isWebGLRenderTarget = !0;
  }
}
class ym extends An {
  constructor(e = null, n = 1, i = 1, o = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: i, depth: o }, this.magFilter = xn, this.minFilter = xn, this.wrapR = pi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Sv extends An {
  constructor(e = null, n = 1, i = 1, o = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: i, depth: o }, this.magFilter = xn, this.minFilter = xn, this.wrapR = pi, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class ni {
  constructor(e = 0, n = 0, i = 0, o = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = i, this._w = o;
  }
  static slerpFlat(e, n, i, o, a, r, l) {
    let c = i[o + 0], u = i[o + 1], d = i[o + 2], h = i[o + 3];
    const p = a[r + 0], f = a[r + 1], m = a[r + 2], y = a[r + 3];
    if (l === 0) {
      e[n + 0] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
      return;
    }
    if (l === 1) {
      e[n + 0] = p, e[n + 1] = f, e[n + 2] = m, e[n + 3] = y;
      return;
    }
    if (h !== y || c !== p || u !== f || d !== m) {
      let g = 1 - l;
      const x = c * p + u * f + d * m + h * y, w = x >= 0 ? 1 : -1, M = 1 - x * x;
      if (M > Number.EPSILON) {
        const C = Math.sqrt(M), T = Math.atan2(C, x * w);
        g = Math.sin(g * T) / C, l = Math.sin(l * T) / C;
      }
      const _ = l * w;
      if (c = c * g + p * _, u = u * g + f * _, d = d * g + m * _, h = h * g + y * _, g === 1 - l) {
        const C = 1 / Math.sqrt(c * c + u * u + d * d + h * h);
        c *= C, u *= C, d *= C, h *= C;
      }
    }
    e[n] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
  }
  static multiplyQuaternionsFlat(e, n, i, o, a, r) {
    const l = i[o], c = i[o + 1], u = i[o + 2], d = i[o + 3], h = a[r], p = a[r + 1], f = a[r + 2], m = a[r + 3];
    return e[n] = l * m + d * h + c * f - u * p, e[n + 1] = c * m + d * p + u * h - l * f, e[n + 2] = u * m + d * f + l * p - c * h, e[n + 3] = d * m - l * h - c * p - u * f, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, i, o) {
    return this._x = e, this._y = n, this._z = i, this._w = o, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n = !0) {
    const i = e._x, o = e._y, a = e._z, r = e._order, l = Math.cos, c = Math.sin, u = l(i / 2), d = l(o / 2), h = l(a / 2), p = c(i / 2), f = c(o / 2), m = c(a / 2);
    switch (r) {
      case "XYZ":
        this._x = p * d * h + u * f * m, this._y = u * f * h - p * d * m, this._z = u * d * m + p * f * h, this._w = u * d * h - p * f * m;
        break;
      case "YXZ":
        this._x = p * d * h + u * f * m, this._y = u * f * h - p * d * m, this._z = u * d * m - p * f * h, this._w = u * d * h + p * f * m;
        break;
      case "ZXY":
        this._x = p * d * h - u * f * m, this._y = u * f * h + p * d * m, this._z = u * d * m + p * f * h, this._w = u * d * h - p * f * m;
        break;
      case "ZYX":
        this._x = p * d * h - u * f * m, this._y = u * f * h + p * d * m, this._z = u * d * m - p * f * h, this._w = u * d * h + p * f * m;
        break;
      case "YZX":
        this._x = p * d * h + u * f * m, this._y = u * f * h + p * d * m, this._z = u * d * m - p * f * h, this._w = u * d * h - p * f * m;
        break;
      case "XZY":
        this._x = p * d * h - u * f * m, this._y = u * f * h - p * d * m, this._z = u * d * m + p * f * h, this._w = u * d * h + p * f * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2, o = Math.sin(i);
    return this._x = e.x * o, this._y = e.y * o, this._z = e.z * o, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, i = n[0], o = n[4], a = n[8], r = n[1], l = n[5], c = n[9], u = n[2], d = n[6], h = n[10], p = i + l + h;
    if (p > 0) {
      const f = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / f, this._x = (d - c) * f, this._y = (a - u) * f, this._z = (r - o) * f;
    } else if (i > l && i > h) {
      const f = 2 * Math.sqrt(1 + i - l - h);
      this._w = (d - c) / f, this._x = 0.25 * f, this._y = (o + r) / f, this._z = (a + u) / f;
    } else if (l > h) {
      const f = 2 * Math.sqrt(1 + l - i - h);
      this._w = (a - u) / f, this._x = (o + r) / f, this._y = 0.25 * f, this._z = (c + d) / f;
    } else {
      const f = 2 * Math.sqrt(1 + h - i - l);
      this._w = (r - o) / f, this._x = (a + u) / f, this._y = (c + d) / f, this._z = 0.25 * f;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Nn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const o = Math.min(1, n / i);
    return this.slerp(e, o), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x, o = e._y, a = e._z, r = e._w, l = n._x, c = n._y, u = n._z, d = n._w;
    return this._x = i * d + r * l + o * u - a * c, this._y = o * d + r * c + a * l - i * u, this._z = a * d + r * u + i * c - o * l, this._w = r * d - i * l - o * c - a * u, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x, o = this._y, a = this._z, r = this._w;
    let l = r * e._w + i * e._x + o * e._y + a * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = r, this._x = i, this._y = o, this._z = a, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const f = 1 - n;
      return this._w = f * r + n * this._w, this._x = f * i + n * this._x, this._y = f * o + n * this._y, this._z = f * a + n * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(c), d = Math.atan2(u, l), h = Math.sin((1 - n) * d) / u, p = Math.sin(n * d) / u;
    return this._w = r * h + this._w * p, this._x = i * h + this._x * p, this._y = o * h + this._y * p, this._z = a * h + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), i = Math.random(), o = Math.sqrt(1 - i), a = Math.sqrt(i);
    return this.set(
      o * Math.sin(e),
      o * Math.cos(e),
      a * Math.sin(n),
      a * Math.cos(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class pe {
  constructor(e = 0, n = 0, i = 0) {
    pe.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = i;
  }
  set(e, n, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = n, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(yp.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(yp.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, o = this.z, a = e.elements;
    return this.x = a[0] * n + a[3] * i + a[6] * o, this.y = a[1] * n + a[4] * i + a[7] * o, this.z = a[2] * n + a[5] * i + a[8] * o, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, o = this.z, a = e.elements, r = 1 / (a[3] * n + a[7] * i + a[11] * o + a[15]);
    return this.x = (a[0] * n + a[4] * i + a[8] * o + a[12]) * r, this.y = (a[1] * n + a[5] * i + a[9] * o + a[13]) * r, this.z = (a[2] * n + a[6] * i + a[10] * o + a[14]) * r, this;
  }
  applyQuaternion(e) {
    const n = this.x, i = this.y, o = this.z, a = e.x, r = e.y, l = e.z, c = e.w, u = 2 * (r * o - l * i), d = 2 * (l * n - a * o), h = 2 * (a * i - r * n);
    return this.x = n + c * u + r * h - l * d, this.y = i + c * d + l * u - a * h, this.z = o + c * h + a * d - r * u, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, i = this.y, o = this.z, a = e.elements;
    return this.x = a[0] * n + a[4] * i + a[8] * o, this.y = a[1] * n + a[5] * i + a[9] * o, this.z = a[2] * n + a[6] * i + a[10] * o, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x, o = e.y, a = e.z, r = n.x, l = n.y, c = n.z;
    return this.x = o * c - a * l, this.y = a * r - i * c, this.z = i * l - o * r, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return qu.copy(this).projectOnVector(e), this.sub(qu);
  }
  reflect(e) {
    return this.sub(qu.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Nn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y, o = this.z - e.z;
    return n * n + i * i + o * o;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const o = Math.sin(n) * e;
    return this.x = o * Math.sin(i), this.y = Math.cos(n) * e, this.z = o * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return this.x = e * Math.sin(n), this.y = i, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), o = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = i, this.z = o, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, i = Math.sqrt(1 - n * n);
    return this.x = i * Math.cos(e), this.y = n, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const qu = /* @__PURE__ */ new pe(), yp = /* @__PURE__ */ new ni();
class O0 {
  constructor(e = new pe(1 / 0, 1 / 0, 1 / 0), n = new pe(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(es.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(es.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = es.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const a = i.getAttribute("position");
      if (n === !0 && a !== void 0 && e.isInstancedMesh !== !0)
        for (let r = 0, l = a.count; r < l; r++)
          e.isMesh === !0 ? e.getVertexPosition(r, es) : es.fromBufferAttribute(a, r), es.applyMatrix4(e.matrixWorld), this.expandByPoint(es);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), fl.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), fl.copy(i.boundingBox)), fl.applyMatrix4(e.matrixWorld), this.union(fl);
    }
    const o = e.children;
    for (let a = 0, r = o.length; a < r; a++)
      this.expandByObject(o[a], n);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, es), es.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, i;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, i += e.normal.z * this.min.z), n <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Ha), pl.subVectors(this.max, Ha), ko.subVectors(e.a, Ha), Do.subVectors(e.b, Ha), Io.subVectors(e.c, Ha), d0.subVectors(Do, ko), h0.subVectors(Io, Do), V0.subVectors(ko, Io);
    let n = [
      0,
      -d0.z,
      d0.y,
      0,
      -h0.z,
      h0.y,
      0,
      -V0.z,
      V0.y,
      d0.z,
      0,
      -d0.x,
      h0.z,
      0,
      -h0.x,
      V0.z,
      0,
      -V0.x,
      -d0.y,
      d0.x,
      0,
      -h0.y,
      h0.x,
      0,
      -V0.y,
      V0.x,
      0
    ];
    return !Zu(n, ko, Do, Io, pl) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Zu(n, ko, Do, Io, pl)) ? !1 : (ml.crossVectors(d0, h0), n = [ml.x, ml.y, ml.z], Zu(n, ko, Do, Io, pl));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, es).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(es).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Rs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Rs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Rs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Rs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Rs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Rs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Rs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Rs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Rs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Rs = [
  /* @__PURE__ */ new pe(),
  /* @__PURE__ */ new pe(),
  /* @__PURE__ */ new pe(),
  /* @__PURE__ */ new pe(),
  /* @__PURE__ */ new pe(),
  /* @__PURE__ */ new pe(),
  /* @__PURE__ */ new pe(),
  /* @__PURE__ */ new pe()
], es = /* @__PURE__ */ new pe(), fl = /* @__PURE__ */ new O0(), ko = /* @__PURE__ */ new pe(), Do = /* @__PURE__ */ new pe(), Io = /* @__PURE__ */ new pe(), d0 = /* @__PURE__ */ new pe(), h0 = /* @__PURE__ */ new pe(), V0 = /* @__PURE__ */ new pe(), Ha = /* @__PURE__ */ new pe(), pl = /* @__PURE__ */ new pe(), ml = /* @__PURE__ */ new pe(), H0 = /* @__PURE__ */ new pe();
function Zu(s, e, n, i, o) {
  for (let a = 0, r = s.length - 3; a <= r; a += 3) {
    H0.fromArray(s, a);
    const l = o.x * Math.abs(H0.x) + o.y * Math.abs(H0.y) + o.z * Math.abs(H0.z), c = e.dot(H0), u = n.dot(H0), d = i.dot(H0);
    if (Math.max(-Math.max(c, u, d), Math.min(c, u, d)) > l)
      return !1;
  }
  return !0;
}
const Cv = /* @__PURE__ */ new O0(), Ga = /* @__PURE__ */ new pe(), Ku = /* @__PURE__ */ new pe();
class Zr {
  constructor(e = new pe(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : Cv.setFromPoints(e).getCenter(i);
    let o = 0;
    for (let a = 0, r = e.length; a < r; a++)
      o = Math.max(o, i.distanceToSquared(e[a]));
    return this.radius = Math.sqrt(o), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Ga.subVectors(e, this.center);
    const n = Ga.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n), o = (i - this.radius) * 0.5;
      this.center.addScaledVector(Ga, o / i), this.radius += o;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Ku.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Ga.copy(e.center).add(Ku)), this.expandByPoint(Ga.copy(e.center).sub(Ku))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ls = /* @__PURE__ */ new pe(), Ju = /* @__PURE__ */ new pe(), vl = /* @__PURE__ */ new pe(), f0 = /* @__PURE__ */ new pe(), Qu = /* @__PURE__ */ new pe(), gl = /* @__PURE__ */ new pe(), e1 = /* @__PURE__ */ new pe();
class Ph {
  constructor(e = new pe(), n = new pe(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ls)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = Ls.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (Ls.copy(this.origin).addScaledVector(this.direction, n), Ls.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, o) {
    Ju.copy(e).add(n).multiplyScalar(0.5), vl.copy(n).sub(e).normalize(), f0.copy(this.origin).sub(Ju);
    const a = e.distanceTo(n) * 0.5, r = -this.direction.dot(vl), l = f0.dot(this.direction), c = -f0.dot(vl), u = f0.lengthSq(), d = Math.abs(1 - r * r);
    let h, p, f, m;
    if (d > 0)
      if (h = r * c - l, p = r * l - c, m = a * d, h >= 0)
        if (p >= -m)
          if (p <= m) {
            const y = 1 / d;
            h *= y, p *= y, f = h * (h + r * p + 2 * l) + p * (r * h + p + 2 * c) + u;
          } else
            p = a, h = Math.max(0, -(r * p + l)), f = -h * h + p * (p + 2 * c) + u;
        else
          p = -a, h = Math.max(0, -(r * p + l)), f = -h * h + p * (p + 2 * c) + u;
      else
        p <= -m ? (h = Math.max(0, -(-r * a + l)), p = h > 0 ? -a : Math.min(Math.max(-a, -c), a), f = -h * h + p * (p + 2 * c) + u) : p <= m ? (h = 0, p = Math.min(Math.max(-a, -c), a), f = p * (p + 2 * c) + u) : (h = Math.max(0, -(r * a + l)), p = h > 0 ? a : Math.min(Math.max(-a, -c), a), f = -h * h + p * (p + 2 * c) + u);
    else
      p = r > 0 ? -a : a, h = Math.max(0, -(r * p + l)), f = -h * h + p * (p + 2 * c) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), o && o.copy(Ju).addScaledVector(vl, p), f;
  }
  intersectSphere(e, n) {
    Ls.subVectors(e.center, this.origin);
    const i = Ls.dot(this.direction), o = Ls.dot(Ls) - i * i, a = e.radius * e.radius;
    if (o > a) return null;
    const r = Math.sqrt(a - o), l = i - r, c = i + r;
    return c < 0 ? null : l < 0 ? this.at(c, n) : this.at(l, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, o, a, r, l, c;
    const u = 1 / this.direction.x, d = 1 / this.direction.y, h = 1 / this.direction.z, p = this.origin;
    return u >= 0 ? (i = (e.min.x - p.x) * u, o = (e.max.x - p.x) * u) : (i = (e.max.x - p.x) * u, o = (e.min.x - p.x) * u), d >= 0 ? (a = (e.min.y - p.y) * d, r = (e.max.y - p.y) * d) : (a = (e.max.y - p.y) * d, r = (e.min.y - p.y) * d), i > r || a > o || ((a > i || isNaN(i)) && (i = a), (r < o || isNaN(o)) && (o = r), h >= 0 ? (l = (e.min.z - p.z) * h, c = (e.max.z - p.z) * h) : (l = (e.max.z - p.z) * h, c = (e.min.z - p.z) * h), i > c || l > o) || ((l > i || i !== i) && (i = l), (c < o || o !== o) && (o = c), o < 0) ? null : this.at(i >= 0 ? i : o, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ls) !== null;
  }
  intersectTriangle(e, n, i, o, a) {
    Qu.subVectors(n, e), gl.subVectors(i, e), e1.crossVectors(Qu, gl);
    let r = this.direction.dot(e1), l;
    if (r > 0) {
      if (o) return null;
      l = 1;
    } else if (r < 0)
      l = -1, r = -r;
    else
      return null;
    f0.subVectors(this.origin, e);
    const c = l * this.direction.dot(gl.crossVectors(f0, gl));
    if (c < 0)
      return null;
    const u = l * this.direction.dot(Qu.cross(f0));
    if (u < 0 || c + u > r)
      return null;
    const d = -l * f0.dot(e1);
    return d < 0 ? null : this.at(d / r, a);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class jt {
  constructor(e, n, i, o, a, r, l, c, u, d, h, p, f, m, y, g) {
    jt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, o, a, r, l, c, u, d, h, p, f, m, y, g);
  }
  set(e, n, i, o, a, r, l, c, u, d, h, p, f, m, y, g) {
    const x = this.elements;
    return x[0] = e, x[4] = n, x[8] = i, x[12] = o, x[1] = a, x[5] = r, x[9] = l, x[13] = c, x[2] = u, x[6] = d, x[10] = h, x[14] = p, x[3] = f, x[7] = m, x[11] = y, x[15] = g, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new jt().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
  }
  copyPosition(e) {
    const n = this.elements, i = e.elements;
    return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, i) {
    return this.set(
      e.x,
      n.x,
      i.x,
      0,
      e.y,
      n.y,
      i.y,
      0,
      e.z,
      n.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, i = e.elements, o = 1 / Ro.setFromMatrixColumn(e, 0).length(), a = 1 / Ro.setFromMatrixColumn(e, 1).length(), r = 1 / Ro.setFromMatrixColumn(e, 2).length();
    return n[0] = i[0] * o, n[1] = i[1] * o, n[2] = i[2] * o, n[3] = 0, n[4] = i[4] * a, n[5] = i[5] * a, n[6] = i[6] * a, n[7] = 0, n[8] = i[8] * r, n[9] = i[9] * r, n[10] = i[10] * r, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const n = this.elements, i = e.x, o = e.y, a = e.z, r = Math.cos(i), l = Math.sin(i), c = Math.cos(o), u = Math.sin(o), d = Math.cos(a), h = Math.sin(a);
    if (e.order === "XYZ") {
      const p = r * d, f = r * h, m = l * d, y = l * h;
      n[0] = c * d, n[4] = -c * h, n[8] = u, n[1] = f + m * u, n[5] = p - y * u, n[9] = -l * c, n[2] = y - p * u, n[6] = m + f * u, n[10] = r * c;
    } else if (e.order === "YXZ") {
      const p = c * d, f = c * h, m = u * d, y = u * h;
      n[0] = p + y * l, n[4] = m * l - f, n[8] = r * u, n[1] = r * h, n[5] = r * d, n[9] = -l, n[2] = f * l - m, n[6] = y + p * l, n[10] = r * c;
    } else if (e.order === "ZXY") {
      const p = c * d, f = c * h, m = u * d, y = u * h;
      n[0] = p - y * l, n[4] = -r * h, n[8] = m + f * l, n[1] = f + m * l, n[5] = r * d, n[9] = y - p * l, n[2] = -r * u, n[6] = l, n[10] = r * c;
    } else if (e.order === "ZYX") {
      const p = r * d, f = r * h, m = l * d, y = l * h;
      n[0] = c * d, n[4] = m * u - f, n[8] = p * u + y, n[1] = c * h, n[5] = y * u + p, n[9] = f * u - m, n[2] = -u, n[6] = l * c, n[10] = r * c;
    } else if (e.order === "YZX") {
      const p = r * c, f = r * u, m = l * c, y = l * u;
      n[0] = c * d, n[4] = y - p * h, n[8] = m * h + f, n[1] = h, n[5] = r * d, n[9] = -l * d, n[2] = -u * d, n[6] = f * h + m, n[10] = p - y * h;
    } else if (e.order === "XZY") {
      const p = r * c, f = r * u, m = l * c, y = l * u;
      n[0] = c * d, n[4] = -h, n[8] = u * d, n[1] = p * h + y, n[5] = r * d, n[9] = f * h - m, n[2] = m * h - f, n[6] = l * d, n[10] = y * h + p;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Tv, e, Ev);
  }
  lookAt(e, n, i) {
    const o = this.elements;
    return Ii.subVectors(e, n), Ii.lengthSq() === 0 && (Ii.z = 1), Ii.normalize(), p0.crossVectors(i, Ii), p0.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Ii.x += 1e-4 : Ii.z += 1e-4, Ii.normalize(), p0.crossVectors(i, Ii)), p0.normalize(), yl.crossVectors(Ii, p0), o[0] = p0.x, o[4] = yl.x, o[8] = Ii.x, o[1] = p0.y, o[5] = yl.y, o[9] = Ii.y, o[2] = p0.z, o[6] = yl.z, o[10] = Ii.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, o = n.elements, a = this.elements, r = i[0], l = i[4], c = i[8], u = i[12], d = i[1], h = i[5], p = i[9], f = i[13], m = i[2], y = i[6], g = i[10], x = i[14], w = i[3], M = i[7], _ = i[11], C = i[15], T = o[0], P = o[4], E = o[8], b = o[12], S = o[1], A = o[5], R = o[9], k = o[13], U = o[2], I = o[6], W = o[10], fe = o[14], q = o[3], G = o[7], Q = o[11], K = o[15];
    return a[0] = r * T + l * S + c * U + u * q, a[4] = r * P + l * A + c * I + u * G, a[8] = r * E + l * R + c * W + u * Q, a[12] = r * b + l * k + c * fe + u * K, a[1] = d * T + h * S + p * U + f * q, a[5] = d * P + h * A + p * I + f * G, a[9] = d * E + h * R + p * W + f * Q, a[13] = d * b + h * k + p * fe + f * K, a[2] = m * T + y * S + g * U + x * q, a[6] = m * P + y * A + g * I + x * G, a[10] = m * E + y * R + g * W + x * Q, a[14] = m * b + y * k + g * fe + x * K, a[3] = w * T + M * S + _ * U + C * q, a[7] = w * P + M * A + _ * I + C * G, a[11] = w * E + M * R + _ * W + C * Q, a[15] = w * b + M * k + _ * fe + C * K, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[4], o = e[8], a = e[12], r = e[1], l = e[5], c = e[9], u = e[13], d = e[2], h = e[6], p = e[10], f = e[14], m = e[3], y = e[7], g = e[11], x = e[15];
    return m * (+a * c * h - o * u * h - a * l * p + i * u * p + o * l * f - i * c * f) + y * (+n * c * f - n * u * p + a * r * p - o * r * f + o * u * d - a * c * d) + g * (+n * u * h - n * l * f - a * r * h + i * r * f + a * l * d - i * u * d) + x * (-o * l * d - n * c * h + n * l * p + o * r * h - i * r * p + i * c * d);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, i) {
    const o = this.elements;
    return e.isVector3 ? (o[12] = e.x, o[13] = e.y, o[14] = e.z) : (o[12] = e, o[13] = n, o[14] = i), this;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], o = e[2], a = e[3], r = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = e[9], p = e[10], f = e[11], m = e[12], y = e[13], g = e[14], x = e[15], w = h * g * u - y * p * u + y * c * f - l * g * f - h * c * x + l * p * x, M = m * p * u - d * g * u - m * c * f + r * g * f + d * c * x - r * p * x, _ = d * y * u - m * h * u + m * l * f - r * y * f - d * l * x + r * h * x, C = m * h * c - d * y * c - m * l * p + r * y * p + d * l * g - r * h * g, T = n * w + i * M + o * _ + a * C;
    if (T === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / T;
    return e[0] = w * P, e[1] = (y * p * a - h * g * a - y * o * f + i * g * f + h * o * x - i * p * x) * P, e[2] = (l * g * a - y * c * a + y * o * u - i * g * u - l * o * x + i * c * x) * P, e[3] = (h * c * a - l * p * a - h * o * u + i * p * u + l * o * f - i * c * f) * P, e[4] = M * P, e[5] = (d * g * a - m * p * a + m * o * f - n * g * f - d * o * x + n * p * x) * P, e[6] = (m * c * a - r * g * a - m * o * u + n * g * u + r * o * x - n * c * x) * P, e[7] = (r * p * a - d * c * a + d * o * u - n * p * u - r * o * f + n * c * f) * P, e[8] = _ * P, e[9] = (m * h * a - d * y * a - m * i * f + n * y * f + d * i * x - n * h * x) * P, e[10] = (r * y * a - m * l * a + m * i * u - n * y * u - r * i * x + n * l * x) * P, e[11] = (d * l * a - r * h * a - d * i * u + n * h * u + r * i * f - n * l * f) * P, e[12] = C * P, e[13] = (d * y * o - m * h * o + m * i * p - n * y * p - d * i * g + n * h * g) * P, e[14] = (m * l * o - r * y * o - m * i * c + n * y * c + r * i * g - n * l * g) * P, e[15] = (r * h * o - d * l * o + d * i * c - n * h * c - r * i * p + n * l * p) * P, this;
  }
  scale(e) {
    const n = this.elements, i = e.x, o = e.y, a = e.z;
    return n[0] *= i, n[4] *= o, n[8] *= a, n[1] *= i, n[5] *= o, n[9] *= a, n[2] *= i, n[6] *= o, n[10] *= a, n[3] *= i, n[7] *= o, n[11] *= a, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], o = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, o));
  }
  makeTranslation(e, n, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n), o = Math.sin(n), a = 1 - i, r = e.x, l = e.y, c = e.z, u = a * r, d = a * l;
    return this.set(
      u * r + i,
      u * l - o * c,
      u * c + o * l,
      0,
      u * l + o * c,
      d * l + i,
      d * c - o * r,
      0,
      u * c - o * l,
      d * c + o * r,
      a * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, i, o, a, r) {
    return this.set(
      1,
      i,
      a,
      0,
      e,
      1,
      r,
      0,
      n,
      o,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, i) {
    const o = this.elements, a = n._x, r = n._y, l = n._z, c = n._w, u = a + a, d = r + r, h = l + l, p = a * u, f = a * d, m = a * h, y = r * d, g = r * h, x = l * h, w = c * u, M = c * d, _ = c * h, C = i.x, T = i.y, P = i.z;
    return o[0] = (1 - (y + x)) * C, o[1] = (f + _) * C, o[2] = (m - M) * C, o[3] = 0, o[4] = (f - _) * T, o[5] = (1 - (p + x)) * T, o[6] = (g + w) * T, o[7] = 0, o[8] = (m + M) * P, o[9] = (g - w) * P, o[10] = (1 - (p + y)) * P, o[11] = 0, o[12] = e.x, o[13] = e.y, o[14] = e.z, o[15] = 1, this;
  }
  decompose(e, n, i) {
    const o = this.elements;
    let a = Ro.set(o[0], o[1], o[2]).length();
    const r = Ro.set(o[4], o[5], o[6]).length(), l = Ro.set(o[8], o[9], o[10]).length();
    this.determinant() < 0 && (a = -a), e.x = o[12], e.y = o[13], e.z = o[14], ts.copy(this);
    const u = 1 / a, d = 1 / r, h = 1 / l;
    return ts.elements[0] *= u, ts.elements[1] *= u, ts.elements[2] *= u, ts.elements[4] *= d, ts.elements[5] *= d, ts.elements[6] *= d, ts.elements[8] *= h, ts.elements[9] *= h, ts.elements[10] *= h, n.setFromRotationMatrix(ts), i.x = a, i.y = r, i.z = l, this;
  }
  makePerspective(e, n, i, o, a, r, l = qs) {
    const c = this.elements, u = 2 * a / (n - e), d = 2 * a / (i - o), h = (n + e) / (n - e), p = (i + o) / (i - o);
    let f, m;
    if (l === qs)
      f = -(r + a) / (r - a), m = -2 * r * a / (r - a);
    else if (l === zc)
      f = -r / (r - a), m = -r * a / (r - a);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return c[0] = u, c[4] = 0, c[8] = h, c[12] = 0, c[1] = 0, c[5] = d, c[9] = p, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = m, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, n, i, o, a, r, l = qs) {
    const c = this.elements, u = 1 / (n - e), d = 1 / (i - o), h = 1 / (r - a), p = (n + e) * u, f = (i + o) * d;
    let m, y;
    if (l === qs)
      m = (r + a) * h, y = -2 * h;
    else if (l === zc)
      m = a * h, y = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return c[0] = 2 * u, c[4] = 0, c[8] = 0, c[12] = -p, c[1] = 0, c[5] = 2 * d, c[9] = 0, c[13] = -f, c[2] = 0, c[6] = 0, c[10] = y, c[14] = -m, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let o = 0; o < 16; o++)
      if (n[o] !== i[o]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e[n + 9] = i[9], e[n + 10] = i[10], e[n + 11] = i[11], e[n + 12] = i[12], e[n + 13] = i[13], e[n + 14] = i[14], e[n + 15] = i[15], e;
  }
}
const Ro = /* @__PURE__ */ new pe(), ts = /* @__PURE__ */ new jt(), Tv = /* @__PURE__ */ new pe(0, 0, 0), Ev = /* @__PURE__ */ new pe(1, 1, 1), p0 = /* @__PURE__ */ new pe(), yl = /* @__PURE__ */ new pe(), Ii = /* @__PURE__ */ new pe(), xp = /* @__PURE__ */ new jt(), bp = /* @__PURE__ */ new ni();
class Hi {
  constructor(e = 0, n = 0, i = 0, o = Hi.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = i, this._order = o;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, i, o = this._order) {
    return this._x = e, this._y = n, this._z = i, this._order = o, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const o = e.elements, a = o[0], r = o[4], l = o[8], c = o[1], u = o[5], d = o[9], h = o[2], p = o[6], f = o[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(Nn(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, f), this._z = Math.atan2(-r, a)) : (this._x = Math.atan2(p, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Nn(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, a), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Nn(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-r, u)) : (this._y = 0, this._z = Math.atan2(c, a));
        break;
      case "ZYX":
        this._y = Math.asin(-Nn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-r, u));
        break;
      case "YZX":
        this._z = Math.asin(Nn(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-d, u), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(l, f));
        break;
      case "XZY":
        this._z = Math.asin(-Nn(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._x = Math.atan2(p, u), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-d, f), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return xp.makeRotationFromQuaternion(e), this.setFromRotationMatrix(xp, n, i);
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return bp.setFromEuler(this), this.setFromQuaternion(bp, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Hi.DEFAULT_ORDER = "XYZ";
class kh {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let Av = 0;
const _p = /* @__PURE__ */ new pe(), Lo = /* @__PURE__ */ new ni(), Fs = /* @__PURE__ */ new jt(), xl = /* @__PURE__ */ new pe(), $a = /* @__PURE__ */ new pe(), Pv = /* @__PURE__ */ new pe(), kv = /* @__PURE__ */ new ni(), wp = /* @__PURE__ */ new pe(1, 0, 0), Mp = /* @__PURE__ */ new pe(0, 1, 0), Sp = /* @__PURE__ */ new pe(0, 0, 1), Cp = { type: "added" }, Dv = { type: "removed" }, Fo = { type: "childadded", child: null }, t1 = { type: "childremoved", child: null };
class vn extends xo {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: Av++ }), this.uuid = bo(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vn.DEFAULT_UP.clone();
    const e = new pe(), n = new Hi(), i = new ni(), o = new pe(1, 1, 1);
    function a() {
      i.setFromEuler(n, !1);
    }
    function r() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(a), i._onChange(r), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: o
      },
      modelViewMatrix: {
        value: new jt()
      },
      normalMatrix: {
        value: new At()
      }
    }), this.matrix = new jt(), this.matrixWorld = new jt(), this.matrixAutoUpdate = vn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new kh(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return Lo.setFromAxisAngle(e, n), this.quaternion.multiply(Lo), this;
  }
  rotateOnWorldAxis(e, n) {
    return Lo.setFromAxisAngle(e, n), this.quaternion.premultiply(Lo), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(wp, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Mp, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Sp, e);
  }
  translateOnAxis(e, n) {
    return _p.copy(e).applyQuaternion(this.quaternion), this.position.add(_p.multiplyScalar(n)), this;
  }
  translateX(e) {
    return this.translateOnAxis(wp, e);
  }
  translateY(e) {
    return this.translateOnAxis(Mp, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Sp, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Fs.copy(this.matrixWorld).invert());
  }
  lookAt(e, n, i) {
    e.isVector3 ? xl.copy(e) : xl.set(e, n, i);
    const o = this.parent;
    this.updateWorldMatrix(!0, !1), $a.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Fs.lookAt($a, xl, this.up) : Fs.lookAt(xl, $a, this.up), this.quaternion.setFromRotationMatrix(Fs), o && (Fs.extractRotation(o.matrixWorld), Lo.setFromRotationMatrix(Fs), this.quaternion.premultiply(Lo.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Cp), Fo.child = e, this.dispatchEvent(Fo), Fo.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Dv), t1.child = e, this.dispatchEvent(t1), t1.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Fs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Fs.multiply(e.parent.matrixWorld)), e.applyMatrix4(Fs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Cp), Fo.child = e, this.dispatchEvent(Fo), Fo.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, o = this.children.length; i < o; i++) {
      const r = this.children[i].getObjectByProperty(e, n);
      if (r !== void 0)
        return r;
    }
  }
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const o = this.children;
    for (let a = 0, r = o.length; a < r; a++)
      o[a].getObjectsByProperty(e, n, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($a, e, Pv), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose($a, kv, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, o = n.length; i < o; i++)
      n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, o = n.length; i < o; i++)
      n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let i = 0, o = n.length; i < o; i++)
      n[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) {
      const o = this.children;
      for (let a = 0, r = o.length; a < r; a++)
        o[a].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", i = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const o = {};
    o.uuid = this.uuid, o.type = this.type, this.name !== "" && (o.name = this.name), this.castShadow === !0 && (o.castShadow = !0), this.receiveShadow === !0 && (o.receiveShadow = !0), this.visible === !1 && (o.visible = !1), this.frustumCulled === !1 && (o.frustumCulled = !1), this.renderOrder !== 0 && (o.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (o.userData = this.userData), o.layers = this.layers.mask, o.matrix = this.matrix.toArray(), o.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (o.matrixAutoUpdate = !1), this.isInstancedMesh && (o.type = "InstancedMesh", o.count = this.count, o.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (o.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (o.type = "BatchedMesh", o.perObjectFrustumCulled = this.perObjectFrustumCulled, o.sortObjects = this.sortObjects, o.drawRanges = this._drawRanges, o.reservedRanges = this._reservedRanges, o.visibility = this._visibility, o.active = this._active, o.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), o.maxInstanceCount = this._maxInstanceCount, o.maxVertexCount = this._maxVertexCount, o.maxIndexCount = this._maxIndexCount, o.geometryInitialized = this._geometryInitialized, o.geometryCount = this._geometryCount, o.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (o.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (o.boundingSphere = {
      center: o.boundingSphere.center.toArray(),
      radius: o.boundingSphere.radius
    }), this.boundingBox !== null && (o.boundingBox = {
      min: o.boundingBox.min.toArray(),
      max: o.boundingBox.max.toArray()
    }));
    function a(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? o.background = this.background.toJSON() : this.background.isTexture && (o.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (o.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      o.geometry = a(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let u = 0, d = c.length; u < d; u++) {
            const h = c[u];
            a(e.shapes, h);
          }
        else
          a(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (o.bindMode = this.bindMode, o.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (a(e.skeletons, this.skeleton), o.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, u = this.material.length; c < u; c++)
          l.push(a(e.materials, this.material[c]));
        o.material = l;
      } else
        o.material = a(e.materials, this.material);
    if (this.children.length > 0) {
      o.children = [];
      for (let l = 0; l < this.children.length; l++)
        o.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      o.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        o.animations.push(a(e.animations, c));
      }
    }
    if (n) {
      const l = r(e.geometries), c = r(e.materials), u = r(e.textures), d = r(e.images), h = r(e.shapes), p = r(e.skeletons), f = r(e.animations), m = r(e.nodes);
      l.length > 0 && (i.geometries = l), c.length > 0 && (i.materials = c), u.length > 0 && (i.textures = u), d.length > 0 && (i.images = d), h.length > 0 && (i.shapes = h), p.length > 0 && (i.skeletons = p), f.length > 0 && (i.animations = f), m.length > 0 && (i.nodes = m);
    }
    return i.object = o, i;
    function r(l) {
      const c = [];
      for (const u in l) {
        const d = l[u];
        delete d.metadata, c.push(d);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let i = 0; i < e.children.length; i++) {
        const o = e.children[i];
        this.add(o.clone());
      }
    return this;
  }
}
vn.DEFAULT_UP = /* @__PURE__ */ new pe(0, 1, 0);
vn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ns = /* @__PURE__ */ new pe(), Os = /* @__PURE__ */ new pe(), n1 = /* @__PURE__ */ new pe(), Us = /* @__PURE__ */ new pe(), Oo = /* @__PURE__ */ new pe(), Uo = /* @__PURE__ */ new pe(), Tp = /* @__PURE__ */ new pe(), i1 = /* @__PURE__ */ new pe(), s1 = /* @__PURE__ */ new pe(), o1 = /* @__PURE__ */ new pe(), a1 = /* @__PURE__ */ new Kt(), r1 = /* @__PURE__ */ new Kt(), l1 = /* @__PURE__ */ new Kt();
class as {
  constructor(e = new pe(), n = new pe(), i = new pe()) {
    this.a = e, this.b = n, this.c = i;
  }
  static getNormal(e, n, i, o) {
    o.subVectors(i, n), ns.subVectors(e, n), o.cross(ns);
    const a = o.lengthSq();
    return a > 0 ? o.multiplyScalar(1 / Math.sqrt(a)) : o.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, i, o, a) {
    ns.subVectors(o, n), Os.subVectors(i, n), n1.subVectors(e, n);
    const r = ns.dot(ns), l = ns.dot(Os), c = ns.dot(n1), u = Os.dot(Os), d = Os.dot(n1), h = r * u - l * l;
    if (h === 0)
      return a.set(0, 0, 0), null;
    const p = 1 / h, f = (u * c - l * d) * p, m = (r * d - l * c) * p;
    return a.set(1 - f - m, m, f);
  }
  static containsPoint(e, n, i, o) {
    return this.getBarycoord(e, n, i, o, Us) === null ? !1 : Us.x >= 0 && Us.y >= 0 && Us.x + Us.y <= 1;
  }
  static getInterpolation(e, n, i, o, a, r, l, c) {
    return this.getBarycoord(e, n, i, o, Us) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(a, Us.x), c.addScaledVector(r, Us.y), c.addScaledVector(l, Us.z), c);
  }
  static getInterpolatedAttribute(e, n, i, o, a, r) {
    return a1.setScalar(0), r1.setScalar(0), l1.setScalar(0), a1.fromBufferAttribute(e, n), r1.fromBufferAttribute(e, i), l1.fromBufferAttribute(e, o), r.setScalar(0), r.addScaledVector(a1, a.x), r.addScaledVector(r1, a.y), r.addScaledVector(l1, a.z), r;
  }
  static isFrontFacing(e, n, i, o) {
    return ns.subVectors(i, n), Os.subVectors(e, n), ns.cross(Os).dot(o) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, o) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[o]), this;
  }
  setFromAttributeAndIndices(e, n, i, o) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, o), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return ns.subVectors(this.c, this.b), Os.subVectors(this.a, this.b), ns.cross(Os).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return as.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return as.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, i, o, a) {
    return as.getInterpolation(e, this.a, this.b, this.c, n, i, o, a);
  }
  containsPoint(e) {
    return as.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return as.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a, o = this.b, a = this.c;
    let r, l;
    Oo.subVectors(o, i), Uo.subVectors(a, i), i1.subVectors(e, i);
    const c = Oo.dot(i1), u = Uo.dot(i1);
    if (c <= 0 && u <= 0)
      return n.copy(i);
    s1.subVectors(e, o);
    const d = Oo.dot(s1), h = Uo.dot(s1);
    if (d >= 0 && h <= d)
      return n.copy(o);
    const p = c * h - d * u;
    if (p <= 0 && c >= 0 && d <= 0)
      return r = c / (c - d), n.copy(i).addScaledVector(Oo, r);
    o1.subVectors(e, a);
    const f = Oo.dot(o1), m = Uo.dot(o1);
    if (m >= 0 && f <= m)
      return n.copy(a);
    const y = f * u - c * m;
    if (y <= 0 && u >= 0 && m <= 0)
      return l = u / (u - m), n.copy(i).addScaledVector(Uo, l);
    const g = d * m - f * h;
    if (g <= 0 && h - d >= 0 && f - m >= 0)
      return Tp.subVectors(a, o), l = (h - d) / (h - d + (f - m)), n.copy(o).addScaledVector(Tp, l);
    const x = 1 / (g + y + p);
    return r = y * x, l = p * x, n.copy(i).addScaledVector(Oo, r).addScaledVector(Uo, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const xm = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, m0 = { h: 0, s: 0, l: 0 }, bl = { h: 0, s: 0, l: 0 };
function c1(s, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? s + (e - s) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - n) : s;
}
class Mt {
  constructor(e, n, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, i);
  }
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const o = e;
      o && o.isColor ? this.copy(o) : typeof o == "number" ? this.setHex(o) : typeof o == "string" && this.setStyle(o);
    } else
      this.setRGB(e, n, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, n = pn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Nt.toWorkingColorSpace(this, n), this;
  }
  setRGB(e, n, i, o = Nt.workingColorSpace) {
    return this.r = e, this.g = n, this.b = i, Nt.toWorkingColorSpace(this, o), this;
  }
  setHSL(e, n, i, o = Nt.workingColorSpace) {
    if (e = Ah(e, 1), n = Nn(n, 0, 1), i = Nn(i, 0, 1), n === 0)
      this.r = this.g = this.b = i;
    else {
      const a = i <= 0.5 ? i * (1 + n) : i + n - i * n, r = 2 * i - a;
      this.r = c1(r, a, e + 1 / 3), this.g = c1(r, a, e), this.b = c1(r, a, e - 1 / 3);
    }
    return Nt.toWorkingColorSpace(this, o), this;
  }
  setStyle(e, n = pn) {
    function i(a) {
      a !== void 0 && parseFloat(a) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let o;
    if (o = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let a;
      const r = o[1], l = o[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (a = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(a[4]), this.setRGB(
              Math.min(255, parseInt(a[1], 10)) / 255,
              Math.min(255, parseInt(a[2], 10)) / 255,
              Math.min(255, parseInt(a[3], 10)) / 255,
              n
            );
          if (a = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(a[4]), this.setRGB(
              Math.min(100, parseInt(a[1], 10)) / 100,
              Math.min(100, parseInt(a[2], 10)) / 100,
              Math.min(100, parseInt(a[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (a = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(a[4]), this.setHSL(
              parseFloat(a[1]) / 360,
              parseFloat(a[2]) / 100,
              parseFloat(a[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (o = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const a = o[1], r = a.length;
      if (r === 3)
        return this.setRGB(
          parseInt(a.charAt(0), 16) / 15,
          parseInt(a.charAt(1), 16) / 15,
          parseInt(a.charAt(2), 16) / 15,
          n
        );
      if (r === 6)
        return this.setHex(parseInt(a, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = pn) {
    const i = xm[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Js(e.r), this.g = Js(e.g), this.b = Js(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = la(e.r), this.g = la(e.g), this.b = la(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = pn) {
    return Nt.fromWorkingColorSpace(Jn.copy(this), e), Math.round(Nn(Jn.r * 255, 0, 255)) * 65536 + Math.round(Nn(Jn.g * 255, 0, 255)) * 256 + Math.round(Nn(Jn.b * 255, 0, 255));
  }
  getHexString(e = pn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = Nt.workingColorSpace) {
    Nt.fromWorkingColorSpace(Jn.copy(this), n);
    const i = Jn.r, o = Jn.g, a = Jn.b, r = Math.max(i, o, a), l = Math.min(i, o, a);
    let c, u;
    const d = (l + r) / 2;
    if (l === r)
      c = 0, u = 0;
    else {
      const h = r - l;
      switch (u = d <= 0.5 ? h / (r + l) : h / (2 - r - l), r) {
        case i:
          c = (o - a) / h + (o < a ? 6 : 0);
          break;
        case o:
          c = (a - i) / h + 2;
          break;
        case a:
          c = (i - o) / h + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = u, e.l = d, e;
  }
  getRGB(e, n = Nt.workingColorSpace) {
    return Nt.fromWorkingColorSpace(Jn.copy(this), n), e.r = Jn.r, e.g = Jn.g, e.b = Jn.b, e;
  }
  getStyle(e = pn) {
    Nt.fromWorkingColorSpace(Jn.copy(this), e);
    const n = Jn.r, i = Jn.g, o = Jn.b;
    return e !== pn ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${o.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(o * 255)})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(m0), this.setHSL(m0.h + e, m0.s + n, m0.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpColors(e, n, i) {
    return this.r = e.r + (n.r - e.r) * i, this.g = e.g + (n.g - e.g) * i, this.b = e.b + (n.b - e.b) * i, this;
  }
  lerpHSL(e, n) {
    this.getHSL(m0), e.getHSL(bl);
    const i = br(m0.h, bl.h, n), o = br(m0.s, bl.s, n), a = br(m0.l, bl.l, n);
    return this.setHSL(i, o, a), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const n = this.r, i = this.g, o = this.b, a = e.elements;
    return this.r = a[0] * n + a[3] * i + a[6] * o, this.g = a[1] * n + a[4] * i + a[7] * o, this.b = a[2] * n + a[5] * i + a[8] * o, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Jn = /* @__PURE__ */ new Mt();
Mt.NAMES = xm;
let Iv = 0;
class _o extends xo {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Iv++ }), this.uuid = bo(), this.name = "", this.blending = rs, this.side = L0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Uc, this.blendDst = Or, this.blendEquation = Oi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Mt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = fa, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = lp, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Eo, this.stencilZFail = Eo, this.stencilZPass = Eo, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const i = e[n];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
          continue;
        }
        const o = this[n];
        if (o === void 0) {
          console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
          continue;
        }
        o && o.isColor ? o.set(i) : o && o.isVector3 && i && i.isVector3 ? o.copy(i) : this[n] = i;
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== rs && (i.blending = this.blending), this.side !== L0 && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== Uc && (i.blendSrc = this.blendSrc), this.blendDst !== Or && (i.blendDst = this.blendDst), this.blendEquation !== Oi && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== fa && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== lp && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Eo && (i.stencilFail = this.stencilFail), this.stencilZFail !== Eo && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Eo && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function o(a) {
      const r = [];
      for (const l in a) {
        const c = a[l];
        delete c.metadata, r.push(c);
      }
      return r;
    }
    if (n) {
      const a = o(e.textures), r = o(e.images);
      a.length > 0 && (i.textures = a), r.length > 0 && (i.images = r);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const o = n.length;
      i = new Array(o);
      for (let a = 0; a !== o; ++a)
        i[a] = n[a].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class _n extends _o {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Hi(), this.combine = em, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Ys = /* @__PURE__ */ Rv();
function Rv() {
  const s = new ArrayBuffer(4), e = new Float32Array(s), n = new Uint32Array(s), i = new Uint32Array(512), o = new Uint32Array(512);
  for (let c = 0; c < 256; ++c) {
    const u = c - 127;
    u < -27 ? (i[c] = 0, i[c | 256] = 32768, o[c] = 24, o[c | 256] = 24) : u < -14 ? (i[c] = 1024 >> -u - 14, i[c | 256] = 1024 >> -u - 14 | 32768, o[c] = -u - 1, o[c | 256] = -u - 1) : u <= 15 ? (i[c] = u + 15 << 10, i[c | 256] = u + 15 << 10 | 32768, o[c] = 13, o[c | 256] = 13) : u < 128 ? (i[c] = 31744, i[c | 256] = 64512, o[c] = 24, o[c | 256] = 24) : (i[c] = 31744, i[c | 256] = 64512, o[c] = 13, o[c | 256] = 13);
  }
  const a = new Uint32Array(2048), r = new Uint32Array(64), l = new Uint32Array(64);
  for (let c = 1; c < 1024; ++c) {
    let u = c << 13, d = 0;
    for (; !(u & 8388608); )
      u <<= 1, d -= 8388608;
    u &= -8388609, d += 947912704, a[c] = u | d;
  }
  for (let c = 1024; c < 2048; ++c)
    a[c] = 939524096 + (c - 1024 << 13);
  for (let c = 1; c < 31; ++c)
    r[c] = c << 23;
  r[31] = 1199570944, r[32] = 2147483648;
  for (let c = 33; c < 63; ++c)
    r[c] = 2147483648 + (c - 32 << 23);
  r[63] = 3347054592;
  for (let c = 1; c < 64; ++c)
    c !== 32 && (l[c] = 1024);
  return {
    floatView: e,
    uint32View: n,
    baseTable: i,
    shiftTable: o,
    mantissaTable: a,
    exponentTable: r,
    offsetTable: l
  };
}
function Lv(s) {
  Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = Nn(s, -65504, 65504), Ys.floatView[0] = s;
  const e = Ys.uint32View[0], n = e >> 23 & 511;
  return Ys.baseTable[n] + ((e & 8388607) >> Ys.shiftTable[n]);
}
function Fv(s) {
  const e = s >> 10;
  return Ys.uint32View[0] = Ys.mantissaTable[Ys.offsetTable[e] + (s & 1023)] + Ys.exponentTable[e], Ys.floatView[0];
}
const Ep = {
  toHalfFloat: Lv,
  fromHalfFloat: Fv
}, In = /* @__PURE__ */ new pe(), _l = /* @__PURE__ */ new qe();
class Vi {
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = i, this.usage = cp, this.updateRanges = [], this.gpuType = Vn, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, n, i) {
    e *= this.itemSize, i *= n.itemSize;
    for (let o = 0, a = this.itemSize; o < a; o++)
      this.array[e + o] = n.array[i + o];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        _l.fromBufferAttribute(this, n), _l.applyMatrix3(e), this.setXY(n, _l.x, _l.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        In.fromBufferAttribute(this, n), In.applyMatrix3(e), this.setXYZ(n, In.x, In.y, In.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      In.fromBufferAttribute(this, n), In.applyMatrix4(e), this.setXYZ(n, In.x, In.y, In.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      In.fromBufferAttribute(this, n), In.applyNormalMatrix(e), this.setXYZ(n, In.x, In.y, In.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      In.fromBufferAttribute(this, n), In.transformDirection(e), this.setXYZ(n, In.x, In.y, In.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = Yo(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return this.normalized && (i = ui(i, this.array)), this.array[e * this.itemSize + n] = i, this;
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = ui(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = ui(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = ui(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = ui(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  setXY(e, n, i) {
    return e *= this.itemSize, this.normalized && (n = ui(n, this.array), i = ui(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this;
  }
  setXYZ(e, n, i, o) {
    return e *= this.itemSize, this.normalized && (n = ui(n, this.array), i = ui(i, this.array), o = ui(o, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = o, this;
  }
  setXYZW(e, n, i, o, a) {
    return e *= this.itemSize, this.normalized && (n = ui(n, this.array), i = ui(i, this.array), o = ui(o, this.array), a = ui(a, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = o, this.array[e + 3] = a, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== cp && (e.usage = this.usage), e;
  }
}
class bm extends Vi {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class _m extends Vi {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class Pt extends Vi {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let Ov = 0;
const Wi = /* @__PURE__ */ new jt(), u1 = /* @__PURE__ */ new vn(), zo = /* @__PURE__ */ new pe(), Ri = /* @__PURE__ */ new O0(), Wa = /* @__PURE__ */ new O0(), zn = /* @__PURE__ */ new pe();
class Ut extends xo {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Ov++ }), this.uuid = bo(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (vm(e) ? _m : bm)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const a = new At().getNormalMatrix(e);
      i.applyNormalMatrix(a), i.needsUpdate = !0;
    }
    const o = this.attributes.tangent;
    return o !== void 0 && (o.transformDirection(e), o.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Wi.makeRotationFromQuaternion(e), this.applyMatrix4(Wi), this;
  }
  rotateX(e) {
    return Wi.makeRotationX(e), this.applyMatrix4(Wi), this;
  }
  rotateY(e) {
    return Wi.makeRotationY(e), this.applyMatrix4(Wi), this;
  }
  rotateZ(e) {
    return Wi.makeRotationZ(e), this.applyMatrix4(Wi), this;
  }
  translate(e, n, i) {
    return Wi.makeTranslation(e, n, i), this.applyMatrix4(Wi), this;
  }
  scale(e, n, i) {
    return Wi.makeScale(e, n, i), this.applyMatrix4(Wi), this;
  }
  lookAt(e) {
    return u1.lookAt(e), u1.updateMatrix(), this.applyMatrix4(u1.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(zo).negate(), this.translate(zo.x, zo.y, zo.z), this;
  }
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const i = [];
      for (let o = 0, a = e.length; o < a; o++) {
        const r = e[o];
        i.push(r.x, r.y, r.z || 0);
      }
      this.setAttribute("position", new Pt(i, 3));
    } else {
      for (let i = 0, o = n.count; i < o; i++) {
        const a = e[i];
        n.setXYZ(i, a.x, a.y, a.z || 0);
      }
      e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new O0());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new pe(-1 / 0, -1 / 0, -1 / 0),
        new pe(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let i = 0, o = n.length; i < o; i++) {
          const a = n[i];
          Ri.setFromBufferAttribute(a), this.morphTargetsRelative ? (zn.addVectors(this.boundingBox.min, Ri.min), this.boundingBox.expandByPoint(zn), zn.addVectors(this.boundingBox.max, Ri.max), this.boundingBox.expandByPoint(zn)) : (this.boundingBox.expandByPoint(Ri.min), this.boundingBox.expandByPoint(Ri.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Zr());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new pe(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (Ri.setFromBufferAttribute(e), n)
        for (let a = 0, r = n.length; a < r; a++) {
          const l = n[a];
          Wa.setFromBufferAttribute(l), this.morphTargetsRelative ? (zn.addVectors(Ri.min, Wa.min), Ri.expandByPoint(zn), zn.addVectors(Ri.max, Wa.max), Ri.expandByPoint(zn)) : (Ri.expandByPoint(Wa.min), Ri.expandByPoint(Wa.max));
        }
      Ri.getCenter(i);
      let o = 0;
      for (let a = 0, r = e.count; a < r; a++)
        zn.fromBufferAttribute(e, a), o = Math.max(o, i.distanceToSquared(zn));
      if (n)
        for (let a = 0, r = n.length; a < r; a++) {
          const l = n[a], c = this.morphTargetsRelative;
          for (let u = 0, d = l.count; u < d; u++)
            zn.fromBufferAttribute(l, u), c && (zo.fromBufferAttribute(e, u), zn.add(zo)), o = Math.max(o, i.distanceToSquared(zn));
        }
      this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = n.position, o = n.normal, a = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Vi(new Float32Array(4 * i.count), 4));
    const r = this.getAttribute("tangent"), l = [], c = [];
    for (let E = 0; E < i.count; E++)
      l[E] = new pe(), c[E] = new pe();
    const u = new pe(), d = new pe(), h = new pe(), p = new qe(), f = new qe(), m = new qe(), y = new pe(), g = new pe();
    function x(E, b, S) {
      u.fromBufferAttribute(i, E), d.fromBufferAttribute(i, b), h.fromBufferAttribute(i, S), p.fromBufferAttribute(a, E), f.fromBufferAttribute(a, b), m.fromBufferAttribute(a, S), d.sub(u), h.sub(u), f.sub(p), m.sub(p);
      const A = 1 / (f.x * m.y - m.x * f.y);
      isFinite(A) && (y.copy(d).multiplyScalar(m.y).addScaledVector(h, -f.y).multiplyScalar(A), g.copy(h).multiplyScalar(f.x).addScaledVector(d, -m.x).multiplyScalar(A), l[E].add(y), l[b].add(y), l[S].add(y), c[E].add(g), c[b].add(g), c[S].add(g));
    }
    let w = this.groups;
    w.length === 0 && (w = [{
      start: 0,
      count: e.count
    }]);
    for (let E = 0, b = w.length; E < b; ++E) {
      const S = w[E], A = S.start, R = S.count;
      for (let k = A, U = A + R; k < U; k += 3)
        x(
          e.getX(k + 0),
          e.getX(k + 1),
          e.getX(k + 2)
        );
    }
    const M = new pe(), _ = new pe(), C = new pe(), T = new pe();
    function P(E) {
      C.fromBufferAttribute(o, E), T.copy(C);
      const b = l[E];
      M.copy(b), M.sub(C.multiplyScalar(C.dot(b))).normalize(), _.crossVectors(T, b);
      const A = _.dot(c[E]) < 0 ? -1 : 1;
      r.setXYZW(E, M.x, M.y, M.z, A);
    }
    for (let E = 0, b = w.length; E < b; ++E) {
      const S = w[E], A = S.start, R = S.count;
      for (let k = A, U = A + R; k < U; k += 3)
        P(e.getX(k + 0)), P(e.getX(k + 1)), P(e.getX(k + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new Vi(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let p = 0, f = i.count; p < f; p++)
          i.setXYZ(p, 0, 0, 0);
      const o = new pe(), a = new pe(), r = new pe(), l = new pe(), c = new pe(), u = new pe(), d = new pe(), h = new pe();
      if (e)
        for (let p = 0, f = e.count; p < f; p += 3) {
          const m = e.getX(p + 0), y = e.getX(p + 1), g = e.getX(p + 2);
          o.fromBufferAttribute(n, m), a.fromBufferAttribute(n, y), r.fromBufferAttribute(n, g), d.subVectors(r, a), h.subVectors(o, a), d.cross(h), l.fromBufferAttribute(i, m), c.fromBufferAttribute(i, y), u.fromBufferAttribute(i, g), l.add(d), c.add(d), u.add(d), i.setXYZ(m, l.x, l.y, l.z), i.setXYZ(y, c.x, c.y, c.z), i.setXYZ(g, u.x, u.y, u.z);
        }
      else
        for (let p = 0, f = n.count; p < f; p += 3)
          o.fromBufferAttribute(n, p + 0), a.fromBufferAttribute(n, p + 1), r.fromBufferAttribute(n, p + 2), d.subVectors(r, a), h.subVectors(o, a), d.cross(h), i.setXYZ(p + 0, d.x, d.y, d.z), i.setXYZ(p + 1, d.x, d.y, d.z), i.setXYZ(p + 2, d.x, d.y, d.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      zn.fromBufferAttribute(e, n), zn.normalize(), e.setXYZ(n, zn.x, zn.y, zn.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const u = l.array, d = l.itemSize, h = l.normalized, p = new u.constructor(c.length * d);
      let f = 0, m = 0;
      for (let y = 0, g = c.length; y < g; y++) {
        l.isInterleavedBufferAttribute ? f = c[y] * l.data.stride + l.offset : f = c[y] * d;
        for (let x = 0; x < d; x++)
          p[m++] = u[f++];
      }
      return new Vi(p, d, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new Ut(), i = this.index.array, o = this.attributes;
    for (const l in o) {
      const c = o[l], u = e(c, i);
      n.setAttribute(l, u);
    }
    const a = this.morphAttributes;
    for (const l in a) {
      const c = [], u = a[l];
      for (let d = 0, h = u.length; d < h; d++) {
        const p = u[d], f = e(p, i);
        c.push(f);
      }
      n.morphAttributes[l] = c;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const r = this.groups;
    for (let l = 0, c = r.length; l < c; l++) {
      const u = r[l];
      n.addGroup(u.start, u.count, u.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const u in c)
        c[u] !== void 0 && (e[u] = c[u]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const u = i[c];
      e.data.attributes[c] = u.toJSON(e.data);
    }
    const o = {};
    let a = !1;
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c], d = [];
      for (let h = 0, p = u.length; h < p; h++) {
        const f = u[h];
        d.push(f.toJSON(e.data));
      }
      d.length > 0 && (o[c] = d, a = !0);
    }
    a && (e.data.morphAttributes = o, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const r = this.groups;
    r.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(r)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const o = e.attributes;
    for (const u in o) {
      const d = o[u];
      this.setAttribute(u, d.clone(n));
    }
    const a = e.morphAttributes;
    for (const u in a) {
      const d = [], h = a[u];
      for (let p = 0, f = h.length; p < f; p++)
        d.push(h[p].clone(n));
      this.morphAttributes[u] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const r = e.groups;
    for (let u = 0, d = r.length; u < d; u++) {
      const h = r[u];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Ap = /* @__PURE__ */ new jt(), G0 = /* @__PURE__ */ new Ph(), wl = /* @__PURE__ */ new Zr(), Pp = /* @__PURE__ */ new pe(), Ml = /* @__PURE__ */ new pe(), Sl = /* @__PURE__ */ new pe(), Cl = /* @__PURE__ */ new pe(), d1 = /* @__PURE__ */ new pe(), Tl = /* @__PURE__ */ new pe(), kp = /* @__PURE__ */ new pe(), El = /* @__PURE__ */ new pe();
class Ke extends vn {
  constructor(e = new Ut(), n = new _n()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const o = n[i[0]];
      if (o !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, r = o.length; a < r; a++) {
          const l = o[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = a;
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const i = this.geometry, o = i.attributes.position, a = i.morphAttributes.position, r = i.morphTargetsRelative;
    n.fromBufferAttribute(o, e);
    const l = this.morphTargetInfluences;
    if (a && l) {
      Tl.set(0, 0, 0);
      for (let c = 0, u = a.length; c < u; c++) {
        const d = l[c], h = a[c];
        d !== 0 && (d1.fromBufferAttribute(h, e), r ? Tl.addScaledVector(d1, d) : Tl.addScaledVector(d1.sub(n), d));
      }
      n.add(Tl);
    }
    return n;
  }
  raycast(e, n) {
    const i = this.geometry, o = this.material, a = this.matrixWorld;
    o !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), wl.copy(i.boundingSphere), wl.applyMatrix4(a), G0.copy(e.ray).recast(e.near), !(wl.containsPoint(G0.origin) === !1 && (G0.intersectSphere(wl, Pp) === null || G0.origin.distanceToSquared(Pp) > (e.far - e.near) ** 2)) && (Ap.copy(a).invert(), G0.copy(e.ray).applyMatrix4(Ap), !(i.boundingBox !== null && G0.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, n, G0)));
  }
  _computeIntersections(e, n, i) {
    let o;
    const a = this.geometry, r = this.material, l = a.index, c = a.attributes.position, u = a.attributes.uv, d = a.attributes.uv1, h = a.attributes.normal, p = a.groups, f = a.drawRange;
    if (l !== null)
      if (Array.isArray(r))
        for (let m = 0, y = p.length; m < y; m++) {
          const g = p[m], x = r[g.materialIndex], w = Math.max(g.start, f.start), M = Math.min(l.count, Math.min(g.start + g.count, f.start + f.count));
          for (let _ = w, C = M; _ < C; _ += 3) {
            const T = l.getX(_), P = l.getX(_ + 1), E = l.getX(_ + 2);
            o = Al(this, x, e, i, u, d, h, T, P, E), o && (o.faceIndex = Math.floor(_ / 3), o.face.materialIndex = g.materialIndex, n.push(o));
          }
        }
      else {
        const m = Math.max(0, f.start), y = Math.min(l.count, f.start + f.count);
        for (let g = m, x = y; g < x; g += 3) {
          const w = l.getX(g), M = l.getX(g + 1), _ = l.getX(g + 2);
          o = Al(this, r, e, i, u, d, h, w, M, _), o && (o.faceIndex = Math.floor(g / 3), n.push(o));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(r))
        for (let m = 0, y = p.length; m < y; m++) {
          const g = p[m], x = r[g.materialIndex], w = Math.max(g.start, f.start), M = Math.min(c.count, Math.min(g.start + g.count, f.start + f.count));
          for (let _ = w, C = M; _ < C; _ += 3) {
            const T = _, P = _ + 1, E = _ + 2;
            o = Al(this, x, e, i, u, d, h, T, P, E), o && (o.faceIndex = Math.floor(_ / 3), o.face.materialIndex = g.materialIndex, n.push(o));
          }
        }
      else {
        const m = Math.max(0, f.start), y = Math.min(c.count, f.start + f.count);
        for (let g = m, x = y; g < x; g += 3) {
          const w = g, M = g + 1, _ = g + 2;
          o = Al(this, r, e, i, u, d, h, w, M, _), o && (o.faceIndex = Math.floor(g / 3), n.push(o));
        }
      }
  }
}
function Uv(s, e, n, i, o, a, r, l) {
  let c;
  if (e.side === vi ? c = i.intersectTriangle(r, a, o, !0, l) : c = i.intersectTriangle(o, a, r, e.side === L0, l), c === null) return null;
  El.copy(l), El.applyMatrix4(s.matrixWorld);
  const u = n.ray.origin.distanceTo(El);
  return u < n.near || u > n.far ? null : {
    distance: u,
    point: El.clone(),
    object: s
  };
}
function Al(s, e, n, i, o, a, r, l, c, u) {
  s.getVertexPosition(l, Ml), s.getVertexPosition(c, Sl), s.getVertexPosition(u, Cl);
  const d = Uv(s, e, n, i, Ml, Sl, Cl, kp);
  if (d) {
    const h = new pe();
    as.getBarycoord(kp, Ml, Sl, Cl, h), o && (d.uv = as.getInterpolatedAttribute(o, l, c, u, h, new qe())), a && (d.uv1 = as.getInterpolatedAttribute(a, l, c, u, h, new qe())), r && (d.normal = as.getInterpolatedAttribute(r, l, c, u, h, new pe()), d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
    const p = {
      a: l,
      b: c,
      c: u,
      normal: new pe(),
      materialIndex: 0
    };
    as.getNormal(Ml, Sl, Cl, p.normal), d.face = p, d.barycoord = h;
  }
  return d;
}
class Mn extends Ut {
  constructor(e = 1, n = 1, i = 1, o = 1, a = 1, r = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: i,
      widthSegments: o,
      heightSegments: a,
      depthSegments: r
    };
    const l = this;
    o = Math.floor(o), a = Math.floor(a), r = Math.floor(r);
    const c = [], u = [], d = [], h = [];
    let p = 0, f = 0;
    m("z", "y", "x", -1, -1, i, n, e, r, a, 0), m("z", "y", "x", 1, -1, i, n, -e, r, a, 1), m("x", "z", "y", 1, 1, e, i, n, o, r, 2), m("x", "z", "y", 1, -1, e, i, -n, o, r, 3), m("x", "y", "z", 1, -1, e, n, i, o, a, 4), m("x", "y", "z", -1, -1, e, n, -i, o, a, 5), this.setIndex(c), this.setAttribute("position", new Pt(u, 3)), this.setAttribute("normal", new Pt(d, 3)), this.setAttribute("uv", new Pt(h, 2));
    function m(y, g, x, w, M, _, C, T, P, E, b) {
      const S = _ / P, A = C / E, R = _ / 2, k = C / 2, U = T / 2, I = P + 1, W = E + 1;
      let fe = 0, q = 0;
      const G = new pe();
      for (let Q = 0; Q < W; Q++) {
        const K = Q * A - k;
        for (let Y = 0; Y < I; Y++) {
          const ee = Y * S - R;
          G[y] = ee * w, G[g] = K * M, G[x] = U, u.push(G.x, G.y, G.z), G[y] = 0, G[g] = 0, G[x] = T > 0 ? 1 : -1, d.push(G.x, G.y, G.z), h.push(Y / P), h.push(1 - Q / E), fe += 1;
        }
      }
      for (let Q = 0; Q < E; Q++)
        for (let K = 0; K < P; K++) {
          const Y = p + K + I * Q, ee = p + K + I * (Q + 1), ce = p + (K + 1) + I * (Q + 1), ae = p + (K + 1) + I * Q;
          c.push(Y, ee, ae), c.push(ee, ce, ae), q += 6;
        }
      l.addGroup(f, q, b), f += q, p += fe;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Mn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function ga(s) {
  const e = {};
  for (const n in s) {
    e[n] = {};
    for (const i in s[n]) {
      const o = s[n][i];
      o && (o.isColor || o.isMatrix3 || o.isMatrix4 || o.isVector2 || o.isVector3 || o.isVector4 || o.isTexture || o.isQuaternion) ? o.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = o.clone() : Array.isArray(o) ? e[n][i] = o.slice() : e[n][i] = o;
    }
  }
  return e;
}
function di(s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = ga(s[n]);
    for (const o in i)
      e[o] = i[o];
  }
  return e;
}
function zv(s) {
  const e = [];
  for (let n = 0; n < s.length; n++)
    e.push(s[n].clone());
  return e;
}
function wm(s) {
  const e = s.getRenderTarget();
  return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Nt.workingColorSpace;
}
const ls = { clone: ga, merge: di };
var Bv = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Nv = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class dn extends _o {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Bv, this.fragmentShader = Nv, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ga(e.uniforms), this.uniformsGroups = zv(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    n.glslVersion = this.glslVersion, n.uniforms = {};
    for (const o in this.uniforms) {
      const r = this.uniforms[o].value;
      r && r.isTexture ? n.uniforms[o] = {
        type: "t",
        value: r.toJSON(e).uuid
      } : r && r.isColor ? n.uniforms[o] = {
        type: "c",
        value: r.getHex()
      } : r && r.isVector2 ? n.uniforms[o] = {
        type: "v2",
        value: r.toArray()
      } : r && r.isVector3 ? n.uniforms[o] = {
        type: "v3",
        value: r.toArray()
      } : r && r.isVector4 ? n.uniforms[o] = {
        type: "v4",
        value: r.toArray()
      } : r && r.isMatrix3 ? n.uniforms[o] = {
        type: "m3",
        value: r.toArray()
      } : r && r.isMatrix4 ? n.uniforms[o] = {
        type: "m4",
        value: r.toArray()
      } : n.uniforms[o] = {
        value: r
      };
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
    const i = {};
    for (const o in this.extensions)
      this.extensions[o] === !0 && (i[o] = !0);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class Mm extends vn {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new jt(), this.projectionMatrix = new jt(), this.projectionMatrixInverse = new jt(), this.coordinateSystem = qs;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const v0 = /* @__PURE__ */ new pe(), Dp = /* @__PURE__ */ new qe(), Ip = /* @__PURE__ */ new qe();
class Ti extends Mm {
  constructor(e = 50, n = 1, i = 0.1, o = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = o, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = va * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(xr * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return va * 2 * Math.atan(
      Math.tan(xr * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, n, i) {
    v0.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(v0.x, v0.y).multiplyScalar(-e / v0.z), v0.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(v0.x, v0.y).multiplyScalar(-e / v0.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, Dp, Ip), n.subVectors(Ip, Dp);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, n, i, o, a, r) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = o, this.view.width = a, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(xr * 0.5 * this.fov) / this.zoom, i = 2 * n, o = this.aspect * i, a = -0.5 * o;
    const r = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = r.fullWidth, u = r.fullHeight;
      a += r.offsetX * o / c, n -= r.offsetY * i / u, o *= r.width / c, i *= r.height / u;
    }
    const l = this.filmOffset;
    l !== 0 && (a += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(a, a + o, n, n - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
const Bo = -90, No = 1;
class Vv extends vn {
  constructor(e, n, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const o = new Ti(Bo, No, e, n);
    o.layers = this.layers, this.add(o);
    const a = new Ti(Bo, No, e, n);
    a.layers = this.layers, this.add(a);
    const r = new Ti(Bo, No, e, n);
    r.layers = this.layers, this.add(r);
    const l = new Ti(Bo, No, e, n);
    l.layers = this.layers, this.add(l);
    const c = new Ti(Bo, No, e, n);
    c.layers = this.layers, this.add(c);
    const u = new Ti(Bo, No, e, n);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [i, o, a, r, l, c] = n;
    for (const u of n) this.remove(u);
    if (e === qs)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), o.up.set(0, 1, 0), o.lookAt(-1, 0, 0), a.up.set(0, 0, -1), a.lookAt(0, 1, 0), r.up.set(0, 0, 1), r.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === zc)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), o.up.set(0, -1, 0), o.lookAt(1, 0, 0), a.up.set(0, 0, 1), a.lookAt(0, 1, 0), r.up.set(0, 0, -1), r.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const u of n)
      this.add(u), u.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: o } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [a, r, l, c, u, d] = this.children, h = e.getRenderTarget(), p = e.getActiveCubeFace(), f = e.getActiveMipmapLevel(), m = e.xr.enabled;
    e.xr.enabled = !1;
    const y = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, o), e.render(n, a), e.setRenderTarget(i, 1, o), e.render(n, r), e.setRenderTarget(i, 2, o), e.render(n, l), e.setRenderTarget(i, 3, o), e.render(n, c), e.setRenderTarget(i, 4, o), e.render(n, u), i.texture.generateMipmaps = y, e.setRenderTarget(i, 5, o), e.render(n, d), e.setRenderTarget(h, p, f), e.xr.enabled = m, i.texture.needsPMREMUpdate = !0;
  }
}
class Sm extends An {
  constructor(e, n, i, o, a, r, l, c, u, d) {
    e = e !== void 0 ? e : [], n = n !== void 0 ? n : pa, super(e, n, i, o, a, r, l, c, u, d), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Hv extends Xn {
  constructor(e = 1, n = {}) {
    super(e, e, n), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, o = [i, i, i, i, i, i];
    this.texture = new Sm(o, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Dt;
  }
  fromEquirectangularTexture(e, n) {
    this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, o = new Mn(5, 5, 5), a = new dn({
      name: "CubemapFromEquirect",
      uniforms: ga(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: vi,
      blending: si
    });
    a.uniforms.tEquirect.value = n;
    const r = new Ke(o, a), l = n.minFilter;
    return n.minFilter === ao && (n.minFilter = Dt), new Vv(1, 10, this).update(e, r), n.minFilter = l, r.geometry.dispose(), r.material.dispose(), this;
  }
  clear(e, n, i, o) {
    const a = e.getRenderTarget();
    for (let r = 0; r < 6; r++)
      e.setRenderTarget(this, r), e.clear(n, i, o);
    e.setRenderTarget(a);
  }
}
const h1 = /* @__PURE__ */ new pe(), Gv = /* @__PURE__ */ new pe(), $v = /* @__PURE__ */ new At();
class J0 {
  constructor(e = new pe(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, i, o) {
    return this.normal.set(e, n, i), this.constant = o, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const o = h1.subVectors(i, n).cross(Gv.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(o, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const i = e.delta(h1), o = this.normal.dot(i);
    if (o === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const a = -(e.start.dot(this.normal) + this.constant) / o;
    return a < 0 || a > 1 ? null : n.copy(e.start).addScaledVector(i, a);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return n < 0 && i > 0 || i < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || $v.getNormalMatrix(e), o = this.coplanarPoint(h1).applyMatrix4(e), a = this.normal.applyMatrix3(i).normalize();
    return this.constant = -o.dot(a), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $0 = /* @__PURE__ */ new Zr(), Pl = /* @__PURE__ */ new pe();
class Dh {
  constructor(e = new J0(), n = new J0(), i = new J0(), o = new J0(), a = new J0(), r = new J0()) {
    this.planes = [e, n, i, o, a, r];
  }
  set(e, n, i, o, a, r) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(n), l[2].copy(i), l[3].copy(o), l[4].copy(a), l[5].copy(r), this;
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, n = qs) {
    const i = this.planes, o = e.elements, a = o[0], r = o[1], l = o[2], c = o[3], u = o[4], d = o[5], h = o[6], p = o[7], f = o[8], m = o[9], y = o[10], g = o[11], x = o[12], w = o[13], M = o[14], _ = o[15];
    if (i[0].setComponents(c - a, p - u, g - f, _ - x).normalize(), i[1].setComponents(c + a, p + u, g + f, _ + x).normalize(), i[2].setComponents(c + r, p + d, g + m, _ + w).normalize(), i[3].setComponents(c - r, p - d, g - m, _ - w).normalize(), i[4].setComponents(c - l, p - h, g - y, _ - M).normalize(), n === qs)
      i[5].setComponents(c + l, p + h, g + y, _ + M).normalize();
    else if (n === zc)
      i[5].setComponents(l, h, y, M).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), $0.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), $0.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere($0);
  }
  intersectsSprite(e) {
    return $0.center.set(0, 0, 0), $0.radius = 0.7071067811865476, $0.applyMatrix4(e.matrixWorld), this.intersectsSphere($0);
  }
  intersectsSphere(e) {
    const n = this.planes, i = e.center, o = -e.radius;
    for (let a = 0; a < 6; a++)
      if (n[a].distanceToPoint(i) < o)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const o = n[i];
      if (Pl.x = o.normal.x > 0 ? e.max.x : e.min.x, Pl.y = o.normal.y > 0 ? e.max.y : e.min.y, Pl.z = o.normal.z > 0 ? e.max.z : e.min.z, o.distanceToPoint(Pl) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      if (n[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Cm() {
  let s = null, e = !1, n = null, i = null;
  function o(a, r) {
    n(a, r), i = s.requestAnimationFrame(o);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (i = s.requestAnimationFrame(o), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(a) {
      n = a;
    },
    setContext: function(a) {
      s = a;
    }
  };
}
function Wv(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function n(l, c) {
    const u = l.array, d = l.usage, h = u.byteLength, p = s.createBuffer();
    s.bindBuffer(c, p), s.bufferData(c, u, d), l.onUploadCallback();
    let f;
    if (u instanceof Float32Array)
      f = s.FLOAT;
    else if (u instanceof Uint16Array)
      l.isFloat16BufferAttribute ? f = s.HALF_FLOAT : f = s.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      f = s.SHORT;
    else if (u instanceof Uint32Array)
      f = s.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      f = s.INT;
    else if (u instanceof Int8Array)
      f = s.BYTE;
    else if (u instanceof Uint8Array)
      f = s.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      f = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: p,
      type: f,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: l.version,
      size: h
    };
  }
  function i(l, c, u) {
    const d = c.array, h = c.updateRanges;
    if (s.bindBuffer(u, l), h.length === 0)
      s.bufferSubData(u, 0, d);
    else {
      h.sort((f, m) => f.start - m.start);
      let p = 0;
      for (let f = 1; f < h.length; f++) {
        const m = h[p], y = h[f];
        y.start <= m.start + m.count + 1 ? m.count = Math.max(
          m.count,
          y.start + y.count - m.start
        ) : (++p, h[p] = y);
      }
      h.length = p + 1;
      for (let f = 0, m = h.length; f < m; f++) {
        const y = h[f];
        s.bufferSubData(
          u,
          y.start * d.BYTES_PER_ELEMENT,
          d,
          y.start,
          y.count
        );
      }
      c.clearUpdateRanges();
    }
    c.onUploadCallback();
  }
  function o(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function a(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const c = e.get(l);
    c && (s.deleteBuffer(c.buffer), e.delete(l));
  }
  function r(l, c) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const d = e.get(l);
      (!d || d.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const u = e.get(l);
    if (u === void 0)
      e.set(l, n(l, c));
    else if (u.version < l.version) {
      if (u.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      i(u.buffer, l, c), u.version = l.version;
    }
  }
  return {
    get: o,
    remove: a,
    update: r
  };
}
class nn extends Ut {
  constructor(e = 1, n = 1, i = 1, o = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: i,
      heightSegments: o
    };
    const a = e / 2, r = n / 2, l = Math.floor(i), c = Math.floor(o), u = l + 1, d = c + 1, h = e / l, p = n / c, f = [], m = [], y = [], g = [];
    for (let x = 0; x < d; x++) {
      const w = x * p - r;
      for (let M = 0; M < u; M++) {
        const _ = M * h - a;
        m.push(_, -w, 0), y.push(0, 0, 1), g.push(M / l), g.push(1 - x / c);
      }
    }
    for (let x = 0; x < c; x++)
      for (let w = 0; w < l; w++) {
        const M = w + u * x, _ = w + u * (x + 1), C = w + 1 + u * (x + 1), T = w + 1 + u * x;
        f.push(M, _, T), f.push(_, C, T);
      }
    this.setIndex(f), this.setAttribute("position", new Pt(m, 3)), this.setAttribute("normal", new Pt(y, 3)), this.setAttribute("uv", new Pt(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new nn(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var jv = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Xv = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, Yv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, qv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Zv = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, Kv = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Jv = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Qv = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, eg = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, tg = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, ng = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, ig = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, sg = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, og = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, ag = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, rg = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, lg = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, cg = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, ug = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, dg = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, hg = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, fg = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, pg = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, mg = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, vg = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, gg = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, yg = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, xg = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, bg = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, _g = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, wg = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Mg = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Sg = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Cg = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Tg = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Eg = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Ag = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Pg = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, kg = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Dg = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Ig = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Rg = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Lg = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Fg = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Og = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Ug = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, zg = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Bg = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Ng = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Vg = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Hg = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Gg = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, $g = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Wg = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, jg = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Xg = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Yg = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, qg = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Zg = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Kg = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Jg = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Qg = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, ey = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, ty = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, ny = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, iy = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, sy = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, oy = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, ay = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, ry = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, ly = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, cy = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, uy = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, dy = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, hy = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, fy = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, py = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, my = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, vy = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, gy = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, yy = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, xy = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, by = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, _y = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, wy = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, My = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Sy = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Cy = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Ty = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Ey = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Ay = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Py = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, ky = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Dy = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Iy = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Ry = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Ly = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Fy = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Oy = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Uy = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, zy = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, By = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Ny = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Vy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Hy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Gy = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, $y = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Wy = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, jy = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Xy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Yy = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, qy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, Zy = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, Ky = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, Jy = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, Qy = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, ex = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, tx = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, nx = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ix = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, sx = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, ox = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, ax = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, rx = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, lx = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, cx = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, ux = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, dx = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, hx = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, fx = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, px = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, mx = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, vx = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gx = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, yx = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xx = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, bx = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, _x = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, wx = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Mx = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Sx = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, kt = {
  alphahash_fragment: jv,
  alphahash_pars_fragment: Xv,
  alphamap_fragment: Yv,
  alphamap_pars_fragment: qv,
  alphatest_fragment: Zv,
  alphatest_pars_fragment: Kv,
  aomap_fragment: Jv,
  aomap_pars_fragment: Qv,
  batching_pars_vertex: eg,
  batching_vertex: tg,
  begin_vertex: ng,
  beginnormal_vertex: ig,
  bsdfs: sg,
  iridescence_fragment: og,
  bumpmap_pars_fragment: ag,
  clipping_planes_fragment: rg,
  clipping_planes_pars_fragment: lg,
  clipping_planes_pars_vertex: cg,
  clipping_planes_vertex: ug,
  color_fragment: dg,
  color_pars_fragment: hg,
  color_pars_vertex: fg,
  color_vertex: pg,
  common: mg,
  cube_uv_reflection_fragment: vg,
  defaultnormal_vertex: gg,
  displacementmap_pars_vertex: yg,
  displacementmap_vertex: xg,
  emissivemap_fragment: bg,
  emissivemap_pars_fragment: _g,
  colorspace_fragment: wg,
  colorspace_pars_fragment: Mg,
  envmap_fragment: Sg,
  envmap_common_pars_fragment: Cg,
  envmap_pars_fragment: Tg,
  envmap_pars_vertex: Eg,
  envmap_physical_pars_fragment: zg,
  envmap_vertex: Ag,
  fog_vertex: Pg,
  fog_pars_vertex: kg,
  fog_fragment: Dg,
  fog_pars_fragment: Ig,
  gradientmap_pars_fragment: Rg,
  lightmap_pars_fragment: Lg,
  lights_lambert_fragment: Fg,
  lights_lambert_pars_fragment: Og,
  lights_pars_begin: Ug,
  lights_toon_fragment: Bg,
  lights_toon_pars_fragment: Ng,
  lights_phong_fragment: Vg,
  lights_phong_pars_fragment: Hg,
  lights_physical_fragment: Gg,
  lights_physical_pars_fragment: $g,
  lights_fragment_begin: Wg,
  lights_fragment_maps: jg,
  lights_fragment_end: Xg,
  logdepthbuf_fragment: Yg,
  logdepthbuf_pars_fragment: qg,
  logdepthbuf_pars_vertex: Zg,
  logdepthbuf_vertex: Kg,
  map_fragment: Jg,
  map_pars_fragment: Qg,
  map_particle_fragment: ey,
  map_particle_pars_fragment: ty,
  metalnessmap_fragment: ny,
  metalnessmap_pars_fragment: iy,
  morphinstance_vertex: sy,
  morphcolor_vertex: oy,
  morphnormal_vertex: ay,
  morphtarget_pars_vertex: ry,
  morphtarget_vertex: ly,
  normal_fragment_begin: cy,
  normal_fragment_maps: uy,
  normal_pars_fragment: dy,
  normal_pars_vertex: hy,
  normal_vertex: fy,
  normalmap_pars_fragment: py,
  clearcoat_normal_fragment_begin: my,
  clearcoat_normal_fragment_maps: vy,
  clearcoat_pars_fragment: gy,
  iridescence_pars_fragment: yy,
  opaque_fragment: xy,
  packing: by,
  premultiplied_alpha_fragment: _y,
  project_vertex: wy,
  dithering_fragment: My,
  dithering_pars_fragment: Sy,
  roughnessmap_fragment: Cy,
  roughnessmap_pars_fragment: Ty,
  shadowmap_pars_fragment: Ey,
  shadowmap_pars_vertex: Ay,
  shadowmap_vertex: Py,
  shadowmask_pars_fragment: ky,
  skinbase_vertex: Dy,
  skinning_pars_vertex: Iy,
  skinning_vertex: Ry,
  skinnormal_vertex: Ly,
  specularmap_fragment: Fy,
  specularmap_pars_fragment: Oy,
  tonemapping_fragment: Uy,
  tonemapping_pars_fragment: zy,
  transmission_fragment: By,
  transmission_pars_fragment: Ny,
  uv_pars_fragment: Vy,
  uv_pars_vertex: Hy,
  uv_vertex: Gy,
  worldpos_vertex: $y,
  background_vert: Wy,
  background_frag: jy,
  backgroundCube_vert: Xy,
  backgroundCube_frag: Yy,
  cube_vert: qy,
  cube_frag: Zy,
  depth_vert: Ky,
  depth_frag: Jy,
  distanceRGBA_vert: Qy,
  distanceRGBA_frag: ex,
  equirect_vert: tx,
  equirect_frag: nx,
  linedashed_vert: ix,
  linedashed_frag: sx,
  meshbasic_vert: ox,
  meshbasic_frag: ax,
  meshlambert_vert: rx,
  meshlambert_frag: lx,
  meshmatcap_vert: cx,
  meshmatcap_frag: ux,
  meshnormal_vert: dx,
  meshnormal_frag: hx,
  meshphong_vert: fx,
  meshphong_frag: px,
  meshphysical_vert: mx,
  meshphysical_frag: vx,
  meshtoon_vert: gx,
  meshtoon_frag: yx,
  points_vert: xx,
  points_frag: bx,
  shadow_vert: _x,
  shadow_frag: wx,
  sprite_vert: Mx,
  sprite_frag: Sx
}, nt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new At() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new At() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new At() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new At() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new At() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new At() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new At() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new At() },
    normalScale: { value: /* @__PURE__ */ new qe(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new At() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new At() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new At() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new At() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Mt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new At() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new At() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new qe(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new At() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new At() },
    alphaTest: { value: 0 }
  }
}, Ss = {
  basic: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.specularmap,
      nt.envmap,
      nt.aomap,
      nt.lightmap,
      nt.fog
    ]),
    vertexShader: kt.meshbasic_vert,
    fragmentShader: kt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.specularmap,
      nt.envmap,
      nt.aomap,
      nt.lightmap,
      nt.emissivemap,
      nt.bumpmap,
      nt.normalmap,
      nt.displacementmap,
      nt.fog,
      nt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: kt.meshlambert_vert,
    fragmentShader: kt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.specularmap,
      nt.envmap,
      nt.aomap,
      nt.lightmap,
      nt.emissivemap,
      nt.bumpmap,
      nt.normalmap,
      nt.displacementmap,
      nt.fog,
      nt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        specular: { value: /* @__PURE__ */ new Mt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: kt.meshphong_vert,
    fragmentShader: kt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.envmap,
      nt.aomap,
      nt.lightmap,
      nt.emissivemap,
      nt.bumpmap,
      nt.normalmap,
      nt.displacementmap,
      nt.roughnessmap,
      nt.metalnessmap,
      nt.fog,
      nt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: kt.meshphysical_vert,
    fragmentShader: kt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.aomap,
      nt.lightmap,
      nt.emissivemap,
      nt.bumpmap,
      nt.normalmap,
      nt.displacementmap,
      nt.gradientmap,
      nt.fog,
      nt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: kt.meshtoon_vert,
    fragmentShader: kt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.bumpmap,
      nt.normalmap,
      nt.displacementmap,
      nt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: kt.meshmatcap_vert,
    fragmentShader: kt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ di([
      nt.points,
      nt.fog
    ]),
    vertexShader: kt.points_vert,
    fragmentShader: kt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: kt.linedashed_vert,
    fragmentShader: kt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.displacementmap
    ]),
    vertexShader: kt.depth_vert,
    fragmentShader: kt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.bumpmap,
      nt.normalmap,
      nt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: kt.meshnormal_vert,
    fragmentShader: kt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ di([
      nt.sprite,
      nt.fog
    ]),
    vertexShader: kt.sprite_vert,
    fragmentShader: kt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new At() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: kt.background_vert,
    fragmentShader: kt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new At() }
    },
    vertexShader: kt.backgroundCube_vert,
    fragmentShader: kt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: kt.cube_vert,
    fragmentShader: kt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: kt.equirect_vert,
    fragmentShader: kt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ di([
      nt.common,
      nt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new pe() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: kt.distanceRGBA_vert,
    fragmentShader: kt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ di([
      nt.lights,
      nt.fog,
      {
        color: { value: /* @__PURE__ */ new Mt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: kt.shadow_vert,
    fragmentShader: kt.shadow_frag
  }
};
Ss.physical = {
  uniforms: /* @__PURE__ */ di([
    Ss.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new At() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new At() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new qe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new At() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new At() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new At() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Mt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new At() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new At() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new At() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new qe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new At() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Mt(0) },
      specularColor: { value: /* @__PURE__ */ new Mt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new At() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new At() },
      anisotropyVector: { value: /* @__PURE__ */ new qe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new At() }
    }
  ]),
  vertexShader: kt.meshphysical_vert,
  fragmentShader: kt.meshphysical_frag
};
const kl = { r: 0, b: 0, g: 0 }, W0 = /* @__PURE__ */ new Hi(), Cx = /* @__PURE__ */ new jt();
function Tx(s, e, n, i, o, a, r) {
  const l = new Mt(0);
  let c = a === !0 ? 0 : 1, u, d, h = null, p = 0, f = null;
  function m(w) {
    let M = w.isScene === !0 ? w.background : null;
    return M && M.isTexture && (M = (w.backgroundBlurriness > 0 ? n : e).get(M)), M;
  }
  function y(w) {
    let M = !1;
    const _ = m(w);
    _ === null ? x(l, c) : _ && _.isColor && (x(_, 1), M = !0);
    const C = s.xr.getEnvironmentBlendMode();
    C === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, r) : C === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, r), (s.autoClear || M) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function g(w, M) {
    const _ = m(M);
    _ && (_.isCubeTexture || _.mapping === cu) ? (d === void 0 && (d = new Ke(
      new Mn(1, 1, 1),
      new dn({
        name: "BackgroundCubeMaterial",
        uniforms: ga(Ss.backgroundCube.uniforms),
        vertexShader: Ss.backgroundCube.vertexShader,
        fragmentShader: Ss.backgroundCube.fragmentShader,
        side: vi,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function(C, T, P) {
      this.matrixWorld.copyPosition(P.matrixWorld);
    }, Object.defineProperty(d.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), o.update(d)), W0.copy(M.backgroundRotation), W0.x *= -1, W0.y *= -1, W0.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (W0.y *= -1, W0.z *= -1), d.material.uniforms.envMap.value = _, d.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = M.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, d.material.uniforms.backgroundRotation.value.setFromMatrix4(Cx.makeRotationFromEuler(W0)), d.material.toneMapped = Nt.getTransfer(_.colorSpace) !== Qt, (h !== _ || p !== _.version || f !== s.toneMapping) && (d.material.needsUpdate = !0, h = _, p = _.version, f = s.toneMapping), d.layers.enableAll(), w.unshift(d, d.geometry, d.material, 0, 0, null)) : _ && _.isTexture && (u === void 0 && (u = new Ke(
      new nn(2, 2),
      new dn({
        name: "BackgroundMaterial",
        uniforms: ga(Ss.background.uniforms),
        vertexShader: Ss.background.vertexShader,
        fragmentShader: Ss.background.fragmentShader,
        side: L0,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), o.update(u)), u.material.uniforms.t2D.value = _, u.material.uniforms.backgroundIntensity.value = M.backgroundIntensity, u.material.toneMapped = Nt.getTransfer(_.colorSpace) !== Qt, _.matrixAutoUpdate === !0 && _.updateMatrix(), u.material.uniforms.uvTransform.value.copy(_.matrix), (h !== _ || p !== _.version || f !== s.toneMapping) && (u.material.needsUpdate = !0, h = _, p = _.version, f = s.toneMapping), u.layers.enableAll(), w.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function x(w, M) {
    w.getRGB(kl, wm(s)), i.buffers.color.setClear(kl.r, kl.g, kl.b, M, r);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(w, M = 1) {
      l.set(w), c = M, x(l, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(w) {
      c = w, x(l, c);
    },
    render: y,
    addToRenderList: g
  };
}
function Ex(s, e) {
  const n = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, o = p(null);
  let a = o, r = !1;
  function l(S, A, R, k, U) {
    let I = !1;
    const W = h(k, R, A);
    a !== W && (a = W, u(a.object)), I = f(S, k, R, U), I && m(S, k, R, U), U !== null && e.update(U, s.ELEMENT_ARRAY_BUFFER), (I || r) && (r = !1, _(S, A, R, k), U !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(U).buffer));
  }
  function c() {
    return s.createVertexArray();
  }
  function u(S) {
    return s.bindVertexArray(S);
  }
  function d(S) {
    return s.deleteVertexArray(S);
  }
  function h(S, A, R) {
    const k = R.wireframe === !0;
    let U = i[S.id];
    U === void 0 && (U = {}, i[S.id] = U);
    let I = U[A.id];
    I === void 0 && (I = {}, U[A.id] = I);
    let W = I[k];
    return W === void 0 && (W = p(c()), I[k] = W), W;
  }
  function p(S) {
    const A = [], R = [], k = [];
    for (let U = 0; U < n; U++)
      A[U] = 0, R[U] = 0, k[U] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: A,
      enabledAttributes: R,
      attributeDivisors: k,
      object: S,
      attributes: {},
      index: null
    };
  }
  function f(S, A, R, k) {
    const U = a.attributes, I = A.attributes;
    let W = 0;
    const fe = R.getAttributes();
    for (const q in fe)
      if (fe[q].location >= 0) {
        const Q = U[q];
        let K = I[q];
        if (K === void 0 && (q === "instanceMatrix" && S.instanceMatrix && (K = S.instanceMatrix), q === "instanceColor" && S.instanceColor && (K = S.instanceColor)), Q === void 0 || Q.attribute !== K || K && Q.data !== K.data) return !0;
        W++;
      }
    return a.attributesNum !== W || a.index !== k;
  }
  function m(S, A, R, k) {
    const U = {}, I = A.attributes;
    let W = 0;
    const fe = R.getAttributes();
    for (const q in fe)
      if (fe[q].location >= 0) {
        let Q = I[q];
        Q === void 0 && (q === "instanceMatrix" && S.instanceMatrix && (Q = S.instanceMatrix), q === "instanceColor" && S.instanceColor && (Q = S.instanceColor));
        const K = {};
        K.attribute = Q, Q && Q.data && (K.data = Q.data), U[q] = K, W++;
      }
    a.attributes = U, a.attributesNum = W, a.index = k;
  }
  function y() {
    const S = a.newAttributes;
    for (let A = 0, R = S.length; A < R; A++)
      S[A] = 0;
  }
  function g(S) {
    x(S, 0);
  }
  function x(S, A) {
    const R = a.newAttributes, k = a.enabledAttributes, U = a.attributeDivisors;
    R[S] = 1, k[S] === 0 && (s.enableVertexAttribArray(S), k[S] = 1), U[S] !== A && (s.vertexAttribDivisor(S, A), U[S] = A);
  }
  function w() {
    const S = a.newAttributes, A = a.enabledAttributes;
    for (let R = 0, k = A.length; R < k; R++)
      A[R] !== S[R] && (s.disableVertexAttribArray(R), A[R] = 0);
  }
  function M(S, A, R, k, U, I, W) {
    W === !0 ? s.vertexAttribIPointer(S, A, R, U, I) : s.vertexAttribPointer(S, A, R, k, U, I);
  }
  function _(S, A, R, k) {
    y();
    const U = k.attributes, I = R.getAttributes(), W = A.defaultAttributeValues;
    for (const fe in I) {
      const q = I[fe];
      if (q.location >= 0) {
        let G = U[fe];
        if (G === void 0 && (fe === "instanceMatrix" && S.instanceMatrix && (G = S.instanceMatrix), fe === "instanceColor" && S.instanceColor && (G = S.instanceColor)), G !== void 0) {
          const Q = G.normalized, K = G.itemSize, Y = e.get(G);
          if (Y === void 0) continue;
          const ee = Y.buffer, ce = Y.type, ae = Y.bytesPerElement, de = ce === s.INT || ce === s.UNSIGNED_INT || G.gpuType === bh;
          if (G.isInterleavedBufferAttribute) {
            const ie = G.data, he = ie.stride, ne = G.offset;
            if (ie.isInstancedInterleavedBuffer) {
              for (let N = 0; N < q.locationSize; N++)
                x(q.location + N, ie.meshPerAttribute);
              S.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = ie.meshPerAttribute * ie.count);
            } else
              for (let N = 0; N < q.locationSize; N++)
                g(q.location + N);
            s.bindBuffer(s.ARRAY_BUFFER, ee);
            for (let N = 0; N < q.locationSize; N++)
              M(
                q.location + N,
                K / q.locationSize,
                ce,
                Q,
                he * ae,
                (ne + K / q.locationSize * N) * ae,
                de
              );
          } else {
            if (G.isInstancedBufferAttribute) {
              for (let ie = 0; ie < q.locationSize; ie++)
                x(q.location + ie, G.meshPerAttribute);
              S.isInstancedMesh !== !0 && k._maxInstanceCount === void 0 && (k._maxInstanceCount = G.meshPerAttribute * G.count);
            } else
              for (let ie = 0; ie < q.locationSize; ie++)
                g(q.location + ie);
            s.bindBuffer(s.ARRAY_BUFFER, ee);
            for (let ie = 0; ie < q.locationSize; ie++)
              M(
                q.location + ie,
                K / q.locationSize,
                ce,
                Q,
                K * ae,
                K / q.locationSize * ie * ae,
                de
              );
          }
        } else if (W !== void 0) {
          const Q = W[fe];
          if (Q !== void 0)
            switch (Q.length) {
              case 2:
                s.vertexAttrib2fv(q.location, Q);
                break;
              case 3:
                s.vertexAttrib3fv(q.location, Q);
                break;
              case 4:
                s.vertexAttrib4fv(q.location, Q);
                break;
              default:
                s.vertexAttrib1fv(q.location, Q);
            }
        }
      }
    }
    w();
  }
  function C() {
    E();
    for (const S in i) {
      const A = i[S];
      for (const R in A) {
        const k = A[R];
        for (const U in k)
          d(k[U].object), delete k[U];
        delete A[R];
      }
      delete i[S];
    }
  }
  function T(S) {
    if (i[S.id] === void 0) return;
    const A = i[S.id];
    for (const R in A) {
      const k = A[R];
      for (const U in k)
        d(k[U].object), delete k[U];
      delete A[R];
    }
    delete i[S.id];
  }
  function P(S) {
    for (const A in i) {
      const R = i[A];
      if (R[S.id] === void 0) continue;
      const k = R[S.id];
      for (const U in k)
        d(k[U].object), delete k[U];
      delete R[S.id];
    }
  }
  function E() {
    b(), r = !0, a !== o && (a = o, u(a.object));
  }
  function b() {
    o.geometry = null, o.program = null, o.wireframe = !1;
  }
  return {
    setup: l,
    reset: E,
    resetDefaultState: b,
    dispose: C,
    releaseStatesOfGeometry: T,
    releaseStatesOfProgram: P,
    initAttributes: y,
    enableAttribute: g,
    disableUnusedAttributes: w
  };
}
function Ax(s, e, n) {
  let i;
  function o(u) {
    i = u;
  }
  function a(u, d) {
    s.drawArrays(i, u, d), n.update(d, i, 1);
  }
  function r(u, d, h) {
    h !== 0 && (s.drawArraysInstanced(i, u, d, h), n.update(d, i, h));
  }
  function l(u, d, h) {
    if (h === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, u, 0, d, 0, h);
    let f = 0;
    for (let m = 0; m < h; m++)
      f += d[m];
    n.update(f, i, 1);
  }
  function c(u, d, h, p) {
    if (h === 0) return;
    const f = e.get("WEBGL_multi_draw");
    if (f === null)
      for (let m = 0; m < u.length; m++)
        r(u[m], d[m], p[m]);
    else {
      f.multiDrawArraysInstancedWEBGL(i, u, 0, d, 0, p, 0, h);
      let m = 0;
      for (let y = 0; y < h; y++)
        m += d[y] * p[y];
      n.update(m, i, 1);
    }
  }
  this.setMode = o, this.render = a, this.renderInstances = r, this.renderMultiDraw = l, this.renderMultiDrawInstances = c;
}
function Px(s, e, n, i) {
  let o;
  function a() {
    if (o !== void 0) return o;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      o = s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      o = 0;
    return o;
  }
  function r(P) {
    return !(P !== Sn && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(P) {
    const E = P === gi && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(P !== ps && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    P !== Vn && !E);
  }
  function c(P) {
    if (P === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      P = "mediump";
    }
    return P === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = n.precision !== void 0 ? n.precision : "highp";
  const d = c(u);
  d !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", d, "instead."), u = d);
  const h = n.logarithmicDepthBuffer === !0, p = n.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), f = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), m = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), y = s.getParameter(s.MAX_TEXTURE_SIZE), g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), x = s.getParameter(s.MAX_VERTEX_ATTRIBS), w = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), M = s.getParameter(s.MAX_VARYING_VECTORS), _ = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), C = m > 0, T = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: a,
    getMaxPrecision: c,
    textureFormatReadable: r,
    textureTypeReadable: l,
    precision: u,
    logarithmicDepthBuffer: h,
    reverseDepthBuffer: p,
    maxTextures: f,
    maxVertexTextures: m,
    maxTextureSize: y,
    maxCubemapSize: g,
    maxAttributes: x,
    maxVertexUniforms: w,
    maxVaryings: M,
    maxFragmentUniforms: _,
    vertexTextures: C,
    maxSamples: T
  };
}
function kx(s) {
  const e = this;
  let n = null, i = 0, o = !1, a = !1;
  const r = new J0(), l = new At(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, p) {
    const f = h.length !== 0 || p || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || o;
    return o = p, i = h.length, f;
  }, this.beginShadows = function() {
    a = !0, d(null);
  }, this.endShadows = function() {
    a = !1;
  }, this.setGlobalState = function(h, p) {
    n = d(h, p, 0);
  }, this.setState = function(h, p, f) {
    const m = h.clippingPlanes, y = h.clipIntersection, g = h.clipShadows, x = s.get(h);
    if (!o || m === null || m.length === 0 || a && !g)
      a ? d(null) : u();
    else {
      const w = a ? 0 : i, M = w * 4;
      let _ = x.clippingState || null;
      c.value = _, _ = d(m, p, M, f);
      for (let C = 0; C !== M; ++C)
        _[C] = n[C];
      x.clippingState = _, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += w;
    }
  };
  function u() {
    c.value !== n && (c.value = n, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function d(h, p, f, m) {
    const y = h !== null ? h.length : 0;
    let g = null;
    if (y !== 0) {
      if (g = c.value, m !== !0 || g === null) {
        const x = f + y * 4, w = p.matrixWorldInverse;
        l.getNormalMatrix(w), (g === null || g.length < x) && (g = new Float32Array(x));
        for (let M = 0, _ = f; M !== y; ++M, _ += 4)
          r.copy(h[M]).applyMatrix4(w, l), r.normal.toArray(g, _), g[_ + 3] = r.constant;
      }
      c.value = g, c.needsUpdate = !0;
    }
    return e.numPlanes = y, e.numIntersection = 0, g;
  }
}
function Dx(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(r, l) {
    return l === fd ? r.mapping = pa : l === pd && (r.mapping = ma), r;
  }
  function i(r) {
    if (r && r.isTexture) {
      const l = r.mapping;
      if (l === fd || l === pd)
        if (e.has(r)) {
          const c = e.get(r).texture;
          return n(c, r.mapping);
        } else {
          const c = r.image;
          if (c && c.height > 0) {
            const u = new Hv(c.height);
            return u.fromEquirectangularTexture(s, r), e.set(r, u), r.addEventListener("dispose", o), n(u.texture, r.mapping);
          } else
            return null;
        }
    }
    return r;
  }
  function o(r) {
    const l = r.target;
    l.removeEventListener("dispose", o);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: a
  };
}
class du extends Mm {
  constructor(e = -1, n = 1, i = 1, o = -1, a = 0.1, r = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = i, this.bottom = o, this.near = a, this.far = r, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, n, i, o, a, r) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = o, this.view.width = a, this.view.height = r, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, o = (this.top + this.bottom) / 2;
    let a = i - e, r = i + e, l = o + n, c = o - n;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      a += u * this.view.offsetX, r = a + u * this.view.width, l -= d * this.view.offsetY, c = l - d * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(a, r, l, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const Ko = 4, Rp = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], no = 20, f1 = /* @__PURE__ */ new du(), Lp = /* @__PURE__ */ new Mt();
let p1 = null, m1 = 0, v1 = 0, g1 = !1;
const Q0 = (1 + Math.sqrt(5)) / 2, Vo = 1 / Q0, Fp = [
  /* @__PURE__ */ new pe(-Q0, Vo, 0),
  /* @__PURE__ */ new pe(Q0, Vo, 0),
  /* @__PURE__ */ new pe(-Vo, 0, Q0),
  /* @__PURE__ */ new pe(Vo, 0, Q0),
  /* @__PURE__ */ new pe(0, Q0, -Vo),
  /* @__PURE__ */ new pe(0, Q0, Vo),
  /* @__PURE__ */ new pe(-1, 1, -1),
  /* @__PURE__ */ new pe(1, 1, -1),
  /* @__PURE__ */ new pe(-1, 1, 1),
  /* @__PURE__ */ new pe(1, 1, 1)
];
class Op {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, n = 0, i = 0.1, o = 100) {
    p1 = this._renderer.getRenderTarget(), m1 = this._renderer.getActiveCubeFace(), v1 = this._renderer.getActiveMipmapLevel(), g1 = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const a = this._allocateTargets();
    return a.depthBuffer = !0, this._sceneToCubeUV(e, i, o, a), n > 0 && this._blur(a, 0, 0, n), this._applyPMREM(a), this._cleanup(a), a;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Bp(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = zp(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(p1, m1, v1), this._renderer.xr.enabled = g1, e.scissorTest = !1, Dl(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === pa || e.mapping === ma ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), p1 = this._renderer.getRenderTarget(), m1 = this._renderer.getActiveCubeFace(), v1 = this._renderer.getActiveMipmapLevel(), g1 = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = n || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, i = {
      magFilter: Dt,
      minFilter: Dt,
      generateMipmaps: !1,
      type: gi,
      format: Sn,
      colorSpace: Sa,
      depthBuffer: !1
    }, o = Up(e, n, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Up(e, n, i);
      const { _lodMax: a } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Ix(a)), this._blurMaterial = Rx(a, e, n);
    }
    return o;
  }
  _compileMaterial(e) {
    const n = new Ke(this._lodPlanes[0], e);
    this._renderer.compile(n, f1);
  }
  _sceneToCubeUV(e, n, i, o) {
    const l = new Ti(90, 1, n, i), c = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], d = this._renderer, h = d.autoClear, p = d.toneMapping;
    d.getClearColor(Lp), d.toneMapping = D0, d.autoClear = !1;
    const f = new _n({
      name: "PMREM.Background",
      side: vi,
      depthWrite: !1,
      depthTest: !1
    }), m = new Ke(new Mn(), f);
    let y = !1;
    const g = e.background;
    g ? g.isColor && (f.color.copy(g), e.background = null, y = !0) : (f.color.copy(Lp), y = !0);
    for (let x = 0; x < 6; x++) {
      const w = x % 3;
      w === 0 ? (l.up.set(0, c[x], 0), l.lookAt(u[x], 0, 0)) : w === 1 ? (l.up.set(0, 0, c[x]), l.lookAt(0, u[x], 0)) : (l.up.set(0, c[x], 0), l.lookAt(0, 0, u[x]));
      const M = this._cubeSize;
      Dl(o, w * M, x > 2 ? M : 0, M, M), d.setRenderTarget(o), y && d.render(m, l), d.render(e, l);
    }
    m.geometry.dispose(), m.material.dispose(), d.toneMapping = p, d.autoClear = h, e.background = g;
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer, o = e.mapping === pa || e.mapping === ma;
    o ? (this._cubemapMaterial === null && (this._cubemapMaterial = Bp()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = zp());
    const a = o ? this._cubemapMaterial : this._equirectMaterial, r = new Ke(this._lodPlanes[0], a), l = a.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    Dl(n, 0, 0, 3 * c, 2 * c), i.setRenderTarget(n), i.render(r, f1);
  }
  _applyPMREM(e) {
    const n = this._renderer, i = n.autoClear;
    n.autoClear = !1;
    const o = this._lodPlanes.length;
    for (let a = 1; a < o; a++) {
      const r = Math.sqrt(this._sigmas[a] * this._sigmas[a] - this._sigmas[a - 1] * this._sigmas[a - 1]), l = Fp[(o - a - 1) % Fp.length];
      this._blur(e, a - 1, a, r, l);
    }
    n.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, n, i, o, a) {
    const r = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      r,
      n,
      i,
      o,
      "latitudinal",
      a
    ), this._halfBlur(
      r,
      e,
      i,
      i,
      o,
      "longitudinal",
      a
    );
  }
  _halfBlur(e, n, i, o, a, r, l) {
    const c = this._renderer, u = this._blurMaterial;
    r !== "latitudinal" && r !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const d = 3, h = new Ke(this._lodPlanes[o], u), p = u.uniforms, f = this._sizeLods[i] - 1, m = isFinite(a) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * no - 1), y = a / m, g = isFinite(a) ? 1 + Math.floor(d * y) : no;
    g > no && console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${no}`);
    const x = [];
    let w = 0;
    for (let P = 0; P < no; ++P) {
      const E = P / y, b = Math.exp(-E * E / 2);
      x.push(b), P === 0 ? w += b : P < g && (w += 2 * b);
    }
    for (let P = 0; P < x.length; P++)
      x[P] = x[P] / w;
    p.envMap.value = e.texture, p.samples.value = g, p.weights.value = x, p.latitudinal.value = r === "latitudinal", l && (p.poleAxis.value = l);
    const { _lodMax: M } = this;
    p.dTheta.value = m, p.mipInt.value = M - i;
    const _ = this._sizeLods[o], C = 3 * _ * (o > M - Ko ? o - M + Ko : 0), T = 4 * (this._cubeSize - _);
    Dl(n, C, T, 3 * _, 2 * _), c.setRenderTarget(n), c.render(h, f1);
  }
}
function Ix(s) {
  const e = [], n = [], i = [];
  let o = s;
  const a = s - Ko + 1 + Rp.length;
  for (let r = 0; r < a; r++) {
    const l = Math.pow(2, o);
    n.push(l);
    let c = 1 / l;
    r > s - Ko ? c = Rp[r - s + Ko - 1] : r === 0 && (c = 0), i.push(c);
    const u = 1 / (l - 2), d = -u, h = 1 + u, p = [d, d, h, d, h, h, d, d, h, h, d, h], f = 6, m = 6, y = 3, g = 2, x = 1, w = new Float32Array(y * m * f), M = new Float32Array(g * m * f), _ = new Float32Array(x * m * f);
    for (let T = 0; T < f; T++) {
      const P = T % 3 * 2 / 3 - 1, E = T > 2 ? 0 : -1, b = [
        P,
        E,
        0,
        P + 2 / 3,
        E,
        0,
        P + 2 / 3,
        E + 1,
        0,
        P,
        E,
        0,
        P + 2 / 3,
        E + 1,
        0,
        P,
        E + 1,
        0
      ];
      w.set(b, y * m * T), M.set(p, g * m * T);
      const S = [T, T, T, T, T, T];
      _.set(S, x * m * T);
    }
    const C = new Ut();
    C.setAttribute("position", new Vi(w, y)), C.setAttribute("uv", new Vi(M, g)), C.setAttribute("faceIndex", new Vi(_, x)), e.push(C), o > Ko && o--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i };
}
function Up(s, e, n) {
  const i = new Xn(s, e, n);
  return i.texture.mapping = cu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function Dl(s, e, n, i, o) {
  s.viewport.set(e, n, i, o), s.scissor.set(e, n, i, o);
}
function Rx(s, e, n) {
  const i = new Float32Array(no), o = new pe(0, 1, 0);
  return new dn({
    name: "SphericalGaussianBlur",
    defines: {
      n: no,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: o }
    },
    vertexShader: Ih(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: si,
    depthTest: !1,
    depthWrite: !1
  });
}
function zp() {
  return new dn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Ih(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: si,
    depthTest: !1,
    depthWrite: !1
  });
}
function Bp() {
  return new dn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Ih(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: si,
    depthTest: !1,
    depthWrite: !1
  });
}
function Ih() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function Lx(s) {
  let e = /* @__PURE__ */ new WeakMap(), n = null;
  function i(l) {
    if (l && l.isTexture) {
      const c = l.mapping, u = c === fd || c === pd, d = c === pa || c === ma;
      if (u || d) {
        let h = e.get(l);
        const p = h !== void 0 ? h.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== p)
          return n === null && (n = new Op(s)), h = u ? n.fromEquirectangular(l, h) : n.fromCubemap(l, h), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), h.texture;
        if (h !== void 0)
          return h.texture;
        {
          const f = l.image;
          return u && f && f.height > 0 || d && f && o(f) ? (n === null && (n = new Op(s)), h = u ? n.fromEquirectangular(l) : n.fromCubemap(l), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), l.addEventListener("dispose", a), h.texture) : null;
        }
      }
    }
    return l;
  }
  function o(l) {
    let c = 0;
    const u = 6;
    for (let d = 0; d < u; d++)
      l[d] !== void 0 && c++;
    return c === u;
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a);
    const u = e.get(c);
    u !== void 0 && (e.delete(c), u.dispose());
  }
  function r() {
    e = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
  }
  return {
    get: i,
    dispose: r
  };
}
function Fx(s) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0)
      return e[i];
    let o;
    switch (i) {
      case "WEBGL_depth_texture":
        o = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        o = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        o = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        o = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        o = s.getExtension(i);
    }
    return e[i] = o, o;
  }
  return {
    has: function(i) {
      return n(i) !== null;
    },
    init: function() {
      n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent");
    },
    get: function(i) {
      const o = n(i);
      return o === null && or("THREE.WebGLRenderer: " + i + " extension not supported."), o;
    }
  };
}
function Ox(s, e, n, i) {
  const o = {}, a = /* @__PURE__ */ new WeakMap();
  function r(h) {
    const p = h.target;
    p.index !== null && e.remove(p.index);
    for (const m in p.attributes)
      e.remove(p.attributes[m]);
    for (const m in p.morphAttributes) {
      const y = p.morphAttributes[m];
      for (let g = 0, x = y.length; g < x; g++)
        e.remove(y[g]);
    }
    p.removeEventListener("dispose", r), delete o[p.id];
    const f = a.get(p);
    f && (e.remove(f), a.delete(p)), i.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount, n.memory.geometries--;
  }
  function l(h, p) {
    return o[p.id] === !0 || (p.addEventListener("dispose", r), o[p.id] = !0, n.memory.geometries++), p;
  }
  function c(h) {
    const p = h.attributes;
    for (const m in p)
      e.update(p[m], s.ARRAY_BUFFER);
    const f = h.morphAttributes;
    for (const m in f) {
      const y = f[m];
      for (let g = 0, x = y.length; g < x; g++)
        e.update(y[g], s.ARRAY_BUFFER);
    }
  }
  function u(h) {
    const p = [], f = h.index, m = h.attributes.position;
    let y = 0;
    if (f !== null) {
      const w = f.array;
      y = f.version;
      for (let M = 0, _ = w.length; M < _; M += 3) {
        const C = w[M + 0], T = w[M + 1], P = w[M + 2];
        p.push(C, T, T, P, P, C);
      }
    } else if (m !== void 0) {
      const w = m.array;
      y = m.version;
      for (let M = 0, _ = w.length / 3 - 1; M < _; M += 3) {
        const C = M + 0, T = M + 1, P = M + 2;
        p.push(C, T, T, P, P, C);
      }
    } else
      return;
    const g = new (vm(p) ? _m : bm)(p, 1);
    g.version = y;
    const x = a.get(h);
    x && e.remove(x), a.set(h, g);
  }
  function d(h) {
    const p = a.get(h);
    if (p) {
      const f = h.index;
      f !== null && p.version < f.version && u(h);
    } else
      u(h);
    return a.get(h);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: d
  };
}
function Ux(s, e, n) {
  let i;
  function o(p) {
    i = p;
  }
  let a, r;
  function l(p) {
    a = p.type, r = p.bytesPerElement;
  }
  function c(p, f) {
    s.drawElements(i, f, a, p * r), n.update(f, i, 1);
  }
  function u(p, f, m) {
    m !== 0 && (s.drawElementsInstanced(i, f, a, p * r, m), n.update(f, i, m));
  }
  function d(p, f, m) {
    if (m === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, f, 0, a, p, 0, m);
    let g = 0;
    for (let x = 0; x < m; x++)
      g += f[x];
    n.update(g, i, 1);
  }
  function h(p, f, m, y) {
    if (m === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null)
      for (let x = 0; x < p.length; x++)
        u(p[x] / r, f[x], y[x]);
    else {
      g.multiDrawElementsInstancedWEBGL(i, f, 0, a, p, 0, y, 0, m);
      let x = 0;
      for (let w = 0; w < m; w++)
        x += f[w] * y[w];
      n.update(x, i, 1);
    }
  }
  this.setMode = o, this.setIndex = l, this.render = c, this.renderInstances = u, this.renderMultiDraw = d, this.renderMultiDrawInstances = h;
}
function zx(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(a, r, l) {
    switch (n.calls++, r) {
      case s.TRIANGLES:
        n.triangles += l * (a / 3);
        break;
      case s.LINES:
        n.lines += l * (a / 2);
        break;
      case s.LINE_STRIP:
        n.lines += l * (a - 1);
        break;
      case s.LINE_LOOP:
        n.lines += l * a;
        break;
      case s.POINTS:
        n.points += l * a;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", r);
        break;
    }
  }
  function o() {
    n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: o,
    update: i
  };
}
function Bx(s, e, n) {
  const i = /* @__PURE__ */ new WeakMap(), o = new Kt();
  function a(r, l, c) {
    const u = r.morphTargetInfluences, d = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, h = d !== void 0 ? d.length : 0;
    let p = i.get(l);
    if (p === void 0 || p.count !== h) {
      let f = function() {
        E.dispose(), i.delete(l), l.removeEventListener("dispose", f);
      };
      p !== void 0 && p.texture.dispose();
      const m = l.morphAttributes.position !== void 0, y = l.morphAttributes.normal !== void 0, g = l.morphAttributes.color !== void 0, x = l.morphAttributes.position || [], w = l.morphAttributes.normal || [], M = l.morphAttributes.color || [];
      let _ = 0;
      m === !0 && (_ = 1), y === !0 && (_ = 2), g === !0 && (_ = 3);
      let C = l.attributes.position.count * _, T = 1;
      C > e.maxTextureSize && (T = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
      const P = new Float32Array(C * T * 4 * h), E = new ym(P, C, T, h);
      E.type = Vn, E.needsUpdate = !0;
      const b = _ * 4;
      for (let S = 0; S < h; S++) {
        const A = x[S], R = w[S], k = M[S], U = C * T * 4 * S;
        for (let I = 0; I < A.count; I++) {
          const W = I * b;
          m === !0 && (o.fromBufferAttribute(A, I), P[U + W + 0] = o.x, P[U + W + 1] = o.y, P[U + W + 2] = o.z, P[U + W + 3] = 0), y === !0 && (o.fromBufferAttribute(R, I), P[U + W + 4] = o.x, P[U + W + 5] = o.y, P[U + W + 6] = o.z, P[U + W + 7] = 0), g === !0 && (o.fromBufferAttribute(k, I), P[U + W + 8] = o.x, P[U + W + 9] = o.y, P[U + W + 10] = o.z, P[U + W + 11] = k.itemSize === 4 ? o.w : 1);
        }
      }
      p = {
        count: h,
        texture: E,
        size: new qe(C, T)
      }, i.set(l, p), l.addEventListener("dispose", f);
    }
    if (r.isInstancedMesh === !0 && r.morphTexture !== null)
      c.getUniforms().setValue(s, "morphTexture", r.morphTexture, n);
    else {
      let f = 0;
      for (let y = 0; y < u.length; y++)
        f += u[y];
      const m = l.morphTargetsRelative ? 1 : 1 - f;
      c.getUniforms().setValue(s, "morphTargetBaseInfluence", m), c.getUniforms().setValue(s, "morphTargetInfluences", u);
    }
    c.getUniforms().setValue(s, "morphTargetsTexture", p.texture, n), c.getUniforms().setValue(s, "morphTargetsTextureSize", p.size);
  }
  return {
    update: a
  };
}
function Nx(s, e, n, i) {
  let o = /* @__PURE__ */ new WeakMap();
  function a(c) {
    const u = i.render.frame, d = c.geometry, h = e.get(c, d);
    if (o.get(h) !== u && (e.update(h), o.set(h, u)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), o.get(c) !== u && (n.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && n.update(c.instanceColor, s.ARRAY_BUFFER), o.set(c, u))), c.isSkinnedMesh) {
      const p = c.skeleton;
      o.get(p) !== u && (p.update(), o.set(p, u));
    }
    return h;
  }
  function r() {
    o = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const u = c.target;
    u.removeEventListener("dispose", l), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor);
  }
  return {
    update: a,
    dispose: r
  };
}
class hu extends An {
  constructor(e, n, i, o, a, r, l, c, u, d = ho) {
    if (d !== ho && d !== go)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && d === ho && (i = mo), i === void 0 && d === go && (i = vo), super(null, o, a, r, l, c, d, i, u), this.isDepthTexture = !0, this.image = { width: e, height: n }, this.magFilter = l !== void 0 ? l : xn, this.minFilter = c !== void 0 ? c : xn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
const Tm = /* @__PURE__ */ new An(), Np = /* @__PURE__ */ new hu(1, 1), Em = /* @__PURE__ */ new ym(), Am = /* @__PURE__ */ new Sv(), Pm = /* @__PURE__ */ new Sm(), Vp = [], Hp = [], Gp = new Float32Array(16), $p = new Float32Array(9), Wp = new Float32Array(4);
function Ca(s, e, n) {
  const i = s[0];
  if (i <= 0 || i > 0) return s;
  const o = e * n;
  let a = Vp[o];
  if (a === void 0 && (a = new Float32Array(o), Vp[o] = a), e !== 0) {
    i.toArray(a, 0);
    for (let r = 1, l = 0; r !== e; ++r)
      l += n, s[r].toArray(a, l);
  }
  return a;
}
function Ln(s, e) {
  if (s.length !== e.length) return !1;
  for (let n = 0, i = s.length; n < i; n++)
    if (s[n] !== e[n]) return !1;
  return !0;
}
function Fn(s, e) {
  for (let n = 0, i = e.length; n < i; n++)
    s[n] = e[n];
}
function fu(s, e) {
  let n = Hp[e];
  n === void 0 && (n = new Int32Array(e), Hp[e] = n);
  for (let i = 0; i !== e; ++i)
    n[i] = s.allocateTextureUnit();
  return n;
}
function Vx(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1f(this.addr, e), n[0] = e);
}
function Hx(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Ln(n, e)) return;
    s.uniform2fv(this.addr, e), Fn(n, e);
  }
}
function Gx(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (Ln(n, e)) return;
    s.uniform3fv(this.addr, e), Fn(n, e);
  }
}
function $x(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Ln(n, e)) return;
    s.uniform4fv(this.addr, e), Fn(n, e);
  }
}
function Wx(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Ln(n, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), Fn(n, e);
  } else {
    if (Ln(n, i)) return;
    Wp.set(i), s.uniformMatrix2fv(this.addr, !1, Wp), Fn(n, i);
  }
}
function jx(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Ln(n, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), Fn(n, e);
  } else {
    if (Ln(n, i)) return;
    $p.set(i), s.uniformMatrix3fv(this.addr, !1, $p), Fn(n, i);
  }
}
function Xx(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Ln(n, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), Fn(n, e);
  } else {
    if (Ln(n, i)) return;
    Gp.set(i), s.uniformMatrix4fv(this.addr, !1, Gp), Fn(n, i);
  }
}
function Yx(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1i(this.addr, e), n[0] = e);
}
function qx(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Ln(n, e)) return;
    s.uniform2iv(this.addr, e), Fn(n, e);
  }
}
function Zx(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Ln(n, e)) return;
    s.uniform3iv(this.addr, e), Fn(n, e);
  }
}
function Kx(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Ln(n, e)) return;
    s.uniform4iv(this.addr, e), Fn(n, e);
  }
}
function Jx(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1ui(this.addr, e), n[0] = e);
}
function Qx(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Ln(n, e)) return;
    s.uniform2uiv(this.addr, e), Fn(n, e);
  }
}
function eb(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Ln(n, e)) return;
    s.uniform3uiv(this.addr, e), Fn(n, e);
  }
}
function tb(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Ln(n, e)) return;
    s.uniform4uiv(this.addr, e), Fn(n, e);
  }
}
function nb(s, e, n) {
  const i = this.cache, o = n.allocateTextureUnit();
  i[0] !== o && (s.uniform1i(this.addr, o), i[0] = o);
  let a;
  this.type === s.SAMPLER_2D_SHADOW ? (Np.compareFunction = mm, a = Np) : a = Tm, n.setTexture2D(e || a, o);
}
function ib(s, e, n) {
  const i = this.cache, o = n.allocateTextureUnit();
  i[0] !== o && (s.uniform1i(this.addr, o), i[0] = o), n.setTexture3D(e || Am, o);
}
function sb(s, e, n) {
  const i = this.cache, o = n.allocateTextureUnit();
  i[0] !== o && (s.uniform1i(this.addr, o), i[0] = o), n.setTextureCube(e || Pm, o);
}
function ob(s, e, n) {
  const i = this.cache, o = n.allocateTextureUnit();
  i[0] !== o && (s.uniform1i(this.addr, o), i[0] = o), n.setTexture2DArray(e || Em, o);
}
function ab(s) {
  switch (s) {
    case 5126:
      return Vx;
    case 35664:
      return Hx;
    case 35665:
      return Gx;
    case 35666:
      return $x;
    case 35674:
      return Wx;
    case 35675:
      return jx;
    case 35676:
      return Xx;
    case 5124:
    case 35670:
      return Yx;
    case 35667:
    case 35671:
      return qx;
    case 35668:
    case 35672:
      return Zx;
    case 35669:
    case 35673:
      return Kx;
    case 5125:
      return Jx;
    case 36294:
      return Qx;
    case 36295:
      return eb;
    case 36296:
      return tb;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return nb;
    case 35679:
    case 36299:
    case 36307:
      return ib;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return sb;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return ob;
  }
}
function rb(s, e) {
  s.uniform1fv(this.addr, e);
}
function lb(s, e) {
  const n = Ca(e, this.size, 2);
  s.uniform2fv(this.addr, n);
}
function cb(s, e) {
  const n = Ca(e, this.size, 3);
  s.uniform3fv(this.addr, n);
}
function ub(s, e) {
  const n = Ca(e, this.size, 4);
  s.uniform4fv(this.addr, n);
}
function db(s, e) {
  const n = Ca(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, n);
}
function hb(s, e) {
  const n = Ca(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, n);
}
function fb(s, e) {
  const n = Ca(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, n);
}
function pb(s, e) {
  s.uniform1iv(this.addr, e);
}
function mb(s, e) {
  s.uniform2iv(this.addr, e);
}
function vb(s, e) {
  s.uniform3iv(this.addr, e);
}
function gb(s, e) {
  s.uniform4iv(this.addr, e);
}
function yb(s, e) {
  s.uniform1uiv(this.addr, e);
}
function xb(s, e) {
  s.uniform2uiv(this.addr, e);
}
function bb(s, e) {
  s.uniform3uiv(this.addr, e);
}
function _b(s, e) {
  s.uniform4uiv(this.addr, e);
}
function wb(s, e, n) {
  const i = this.cache, o = e.length, a = fu(n, o);
  Ln(i, a) || (s.uniform1iv(this.addr, a), Fn(i, a));
  for (let r = 0; r !== o; ++r)
    n.setTexture2D(e[r] || Tm, a[r]);
}
function Mb(s, e, n) {
  const i = this.cache, o = e.length, a = fu(n, o);
  Ln(i, a) || (s.uniform1iv(this.addr, a), Fn(i, a));
  for (let r = 0; r !== o; ++r)
    n.setTexture3D(e[r] || Am, a[r]);
}
function Sb(s, e, n) {
  const i = this.cache, o = e.length, a = fu(n, o);
  Ln(i, a) || (s.uniform1iv(this.addr, a), Fn(i, a));
  for (let r = 0; r !== o; ++r)
    n.setTextureCube(e[r] || Pm, a[r]);
}
function Cb(s, e, n) {
  const i = this.cache, o = e.length, a = fu(n, o);
  Ln(i, a) || (s.uniform1iv(this.addr, a), Fn(i, a));
  for (let r = 0; r !== o; ++r)
    n.setTexture2DArray(e[r] || Em, a[r]);
}
function Tb(s) {
  switch (s) {
    case 5126:
      return rb;
    case 35664:
      return lb;
    case 35665:
      return cb;
    case 35666:
      return ub;
    case 35674:
      return db;
    case 35675:
      return hb;
    case 35676:
      return fb;
    case 5124:
    case 35670:
      return pb;
    case 35667:
    case 35671:
      return mb;
    case 35668:
    case 35672:
      return vb;
    case 35669:
    case 35673:
      return gb;
    case 5125:
      return yb;
    case 36294:
      return xb;
    case 36295:
      return bb;
    case 36296:
      return _b;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return wb;
    case 35679:
    case 36299:
    case 36307:
      return Mb;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Sb;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Cb;
  }
}
class Eb {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.setValue = ab(n.type);
  }
}
class Ab {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = Tb(n.type);
  }
}
class Pb {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, n, i) {
    const o = this.seq;
    for (let a = 0, r = o.length; a !== r; ++a) {
      const l = o[a];
      l.setValue(e, n[l.id], i);
    }
  }
}
const y1 = /(\w+)(\])?(\[|\.)?/g;
function jp(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function kb(s, e, n) {
  const i = s.name, o = i.length;
  for (y1.lastIndex = 0; ; ) {
    const a = y1.exec(i), r = y1.lastIndex;
    let l = a[1];
    const c = a[2] === "]", u = a[3];
    if (c && (l = l | 0), u === void 0 || u === "[" && r + 2 === o) {
      jp(n, u === void 0 ? new Eb(l, s, e) : new Ab(l, s, e));
      break;
    } else {
      let h = n.map[l];
      h === void 0 && (h = new Pb(l), jp(n, h)), n = h;
    }
  }
}
class gc {
  constructor(e, n) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let o = 0; o < i; ++o) {
      const a = e.getActiveUniform(n, o), r = e.getUniformLocation(n, a.name);
      kb(a, r, this);
    }
  }
  setValue(e, n, i, o) {
    const a = this.map[n];
    a !== void 0 && a.setValue(e, i, o);
  }
  setOptional(e, n, i) {
    const o = n[i];
    o !== void 0 && this.setValue(e, i, o);
  }
  static upload(e, n, i, o) {
    for (let a = 0, r = n.length; a !== r; ++a) {
      const l = n[a], c = i[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, o);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let o = 0, a = e.length; o !== a; ++o) {
      const r = e[o];
      r.id in n && i.push(r);
    }
    return i;
  }
}
function Xp(s, e, n) {
  const i = s.createShader(e);
  return s.shaderSource(i, n), s.compileShader(i), i;
}
const Db = 37297;
let Ib = 0;
function Rb(s, e) {
  const n = s.split(`
`), i = [], o = Math.max(e - 6, 0), a = Math.min(e + 6, n.length);
  for (let r = o; r < a; r++) {
    const l = r + 1;
    i.push(`${l === e ? ">" : " "} ${l}: ${n[r]}`);
  }
  return i.join(`
`);
}
const Yp = /* @__PURE__ */ new At();
function Lb(s) {
  Nt._getMatrix(Yp, Nt.workingColorSpace, s);
  const e = `mat3( ${Yp.elements.map((n) => n.toFixed(4))} )`;
  switch (Nt.getTransfer(s)) {
    case uu:
      return [e, "LinearTransferOETF"];
    case Qt:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [e, "LinearTransferOETF"];
  }
}
function qp(s, e, n) {
  const i = s.getShaderParameter(e, s.COMPILE_STATUS), o = s.getShaderInfoLog(e).trim();
  if (i && o === "") return "";
  const a = /ERROR: 0:(\d+)/.exec(o);
  if (a) {
    const r = parseInt(a[1]);
    return n.toUpperCase() + `

` + o + `

` + Rb(s.getShaderSource(e), r);
  } else
    return o;
}
function Fb(s, e) {
  const n = Lb(e);
  return [
    `vec4 ${s}( vec4 value ) {`,
    `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function Ob(s, e) {
  let n;
  switch (e) {
    case tm:
      n = "Linear";
      break;
    case nm:
      n = "Reinhard";
      break;
    case im:
      n = "Cineon";
      break;
    case xh:
      n = "ACESFilmic";
      break;
    case sm:
      n = "AgX";
      break;
    case om:
      n = "Neutral";
      break;
    case G7:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
const Il = /* @__PURE__ */ new pe();
function Ub() {
  Nt.getLuminanceCoefficients(Il);
  const s = Il.x.toFixed(4), e = Il.y.toFixed(4), n = Il.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${n} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function zb(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(ar).join(`
`);
}
function Bb(s) {
  const e = [];
  for (const n in s) {
    const i = s[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function Nb(s, e) {
  const n = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let o = 0; o < i; o++) {
    const a = s.getActiveAttrib(e, o), r = a.name;
    let l = 1;
    a.type === s.FLOAT_MAT2 && (l = 2), a.type === s.FLOAT_MAT3 && (l = 3), a.type === s.FLOAT_MAT4 && (l = 4), n[r] = {
      type: a.type,
      location: s.getAttribLocation(e, r),
      locationSize: l
    };
  }
  return n;
}
function ar(s) {
  return s !== "";
}
function Zp(s, e) {
  const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Kp(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Vb = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Hd(s) {
  return s.replace(Vb, Gb);
}
const Hb = /* @__PURE__ */ new Map();
function Gb(s, e) {
  let n = kt[e];
  if (n === void 0) {
    const i = Hb.get(e);
    if (i !== void 0)
      n = kt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Hd(n);
}
const $b = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Jp(s) {
  return s.replace($b, Wb);
}
function Wb(s, e, n, i) {
  let o = "";
  for (let a = parseInt(e); a < parseInt(n); a++)
    o += i.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
  return o;
}
function Qp(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function jb(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === j3 ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === X3 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === Vs && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Xb(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case pa:
      case ma:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case cu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Yb(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case ma:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function qb(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case em:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case V7:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case H7:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Zb(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: i, maxMip: n };
}
function Kb(s, e, n, i) {
  const o = s.getContext(), a = n.defines;
  let r = n.vertexShader, l = n.fragmentShader;
  const c = jb(n), u = Xb(n), d = Yb(n), h = qb(n), p = Zb(n), f = zb(n), m = Bb(a), y = o.createProgram();
  let g, x, w = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (g = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m
  ].filter(ar).join(`
`), g.length > 0 && (g += `
`), x = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m
  ].filter(ar).join(`
`), x.length > 0 && (x += `
`)) : (g = [
    Qp(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    n.batching ? "#define USE_BATCHING" : "",
    n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + d : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    n.mapUv ? "#define MAP_UV " + n.mapUv : "",
    n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
    n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
    n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
    n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
    n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
    n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
    n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
    n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
    n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
    n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
    n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
    n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "",
    n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "",
    n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
    n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "",
    n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
    n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "",
    n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
    n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
    n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "",
    n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
    n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
    //
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.morphColors ? "#define USE_MORPHCOLORS" : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(ar).join(`
`), x = [
    Qp(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    m,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + u : "",
    n.envMap ? "#define " + d : "",
    n.envMap ? "#define " + h : "",
    p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
    p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
    p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoat ? "#define USE_CLEARCOAT" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.dispersion ? "#define USE_DISPERSION" : "",
    n.iridescence ? "#define USE_IRIDESCENCE" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaTest ? "#define USE_ALPHATEST" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== D0 ? "#define TONE_MAPPING" : "",
    n.toneMapping !== D0 ? kt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== D0 ? Ob("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    n.opaque ? "#define OPAQUE" : "",
    kt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    Fb("linearToOutputTexel", n.outputColorSpace),
    Ub(),
    n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(ar).join(`
`)), r = Hd(r), r = Zp(r, n), r = Kp(r, n), l = Hd(l), l = Zp(l, n), l = Kp(l, n), r = Jp(r), l = Jp(l), n.isRawShaderMaterial !== !0 && (w = `#version 300 es
`, g = [
    f,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + g, x = [
    "#define varying in",
    n.glslVersion === up ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    n.glslVersion === up ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + x);
  const M = w + g + r, _ = w + x + l, C = Xp(o, o.VERTEX_SHADER, M), T = Xp(o, o.FRAGMENT_SHADER, _);
  o.attachShader(y, C), o.attachShader(y, T), n.index0AttributeName !== void 0 ? o.bindAttribLocation(y, 0, n.index0AttributeName) : n.morphTargets === !0 && o.bindAttribLocation(y, 0, "position"), o.linkProgram(y);
  function P(A) {
    if (s.debug.checkShaderErrors) {
      const R = o.getProgramInfoLog(y).trim(), k = o.getShaderInfoLog(C).trim(), U = o.getShaderInfoLog(T).trim();
      let I = !0, W = !0;
      if (o.getProgramParameter(y, o.LINK_STATUS) === !1)
        if (I = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(o, y, C, T);
        else {
          const fe = qp(o, C, "vertex"), q = qp(o, T, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(y, o.VALIDATE_STATUS) + `

Material Name: ` + A.name + `
Material Type: ` + A.type + `

Program Info Log: ` + R + `
` + fe + `
` + q
          );
        }
      else R !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", R) : (k === "" || U === "") && (W = !1);
      W && (A.diagnostics = {
        runnable: I,
        programLog: R,
        vertexShader: {
          log: k,
          prefix: g
        },
        fragmentShader: {
          log: U,
          prefix: x
        }
      });
    }
    o.deleteShader(C), o.deleteShader(T), E = new gc(o, y), b = Nb(o, y);
  }
  let E;
  this.getUniforms = function() {
    return E === void 0 && P(this), E;
  };
  let b;
  this.getAttributes = function() {
    return b === void 0 && P(this), b;
  };
  let S = n.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return S === !1 && (S = o.getProgramParameter(y, Db)), S;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), o.deleteProgram(y), this.program = void 0;
  }, this.type = n.shaderType, this.name = n.shaderName, this.id = Ib++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = C, this.fragmentShader = T, this;
}
let Jb = 0;
class Qb {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const n = e.vertexShader, i = e.fragmentShader, o = this._getShaderStage(n), a = this._getShaderStage(i), r = this._getShaderCacheForMaterial(e);
    return r.has(o) === !1 && (r.add(o), o.usedTimes++), r.has(a) === !1 && (r.add(a), a.usedTimes++), this;
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let i = n.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let i = n.get(e);
    return i === void 0 && (i = new e_(e), n.set(e, i)), i;
  }
}
class e_ {
  constructor(e) {
    this.id = Jb++, this.code = e, this.usedTimes = 0;
  }
}
function t_(s, e, n, i, o, a, r) {
  const l = new kh(), c = new Qb(), u = /* @__PURE__ */ new Set(), d = [], h = o.logarithmicDepthBuffer, p = o.vertexTextures;
  let f = o.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function y(b) {
    return u.add(b), b === 0 ? "uv" : `uv${b}`;
  }
  function g(b, S, A, R, k) {
    const U = R.fog, I = k.geometry, W = b.isMeshStandardMaterial ? R.environment : null, fe = (b.isMeshStandardMaterial ? n : e).get(b.envMap || W), q = fe && fe.mapping === cu ? fe.image.height : null, G = m[b.type];
    b.precision !== null && (f = o.getMaxPrecision(b.precision), f !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", f, "instead."));
    const Q = I.morphAttributes.position || I.morphAttributes.normal || I.morphAttributes.color, K = Q !== void 0 ? Q.length : 0;
    let Y = 0;
    I.morphAttributes.position !== void 0 && (Y = 1), I.morphAttributes.normal !== void 0 && (Y = 2), I.morphAttributes.color !== void 0 && (Y = 3);
    let ee, ce, ae, de;
    if (G) {
      const vt = Ss[G];
      ee = vt.vertexShader, ce = vt.fragmentShader;
    } else
      ee = b.vertexShader, ce = b.fragmentShader, c.update(b), ae = c.getVertexShaderID(b), de = c.getFragmentShaderID(b);
    const ie = s.getRenderTarget(), he = s.state.buffers.depth.getReversed(), ne = k.isInstancedMesh === !0, N = k.isBatchedMesh === !0, te = !!b.map, F = !!b.matcap, B = !!fe, L = !!b.aoMap, D = !!b.lightMap, j = !!b.bumpMap, Z = !!b.normalMap, z = !!b.displacementMap, $ = !!b.emissiveMap, oe = !!b.metalnessMap, O = !!b.roughnessMap, V = b.anisotropy > 0, H = b.clearcoat > 0, X = b.dispersion > 0, ue = b.iridescence > 0, me = b.sheen > 0, _e = b.transmission > 0, we = V && !!b.anisotropyMap, Ae = H && !!b.clearcoatMap, Ve = H && !!b.clearcoatNormalMap, Fe = H && !!b.clearcoatRoughnessMap, $e = ue && !!b.iridescenceMap, Ze = ue && !!b.iridescenceThicknessMap, je = me && !!b.sheenColorMap, Ue = me && !!b.sheenRoughnessMap, rt = !!b.specularMap, Qe = !!b.specularColorMap, yt = !!b.specularIntensityMap, Ce = _e && !!b.transmissionMap, Be = _e && !!b.thicknessMap, ke = !!b.gradientMap, Ge = !!b.alphaMap, Ye = b.alphaTest > 0, We = !!b.alphaHash, ht = !!b.extensions;
    let ut = D0;
    b.toneMapped && (ie === null || ie.isXRRenderTarget === !0) && (ut = s.toneMapping);
    const ft = {
      shaderID: G,
      shaderType: b.type,
      shaderName: b.name,
      vertexShader: ee,
      fragmentShader: ce,
      defines: b.defines,
      customVertexShaderID: ae,
      customFragmentShaderID: de,
      isRawShaderMaterial: b.isRawShaderMaterial === !0,
      glslVersion: b.glslVersion,
      precision: f,
      batching: N,
      batchingColor: N && k._colorsTexture !== null,
      instancing: ne,
      instancingColor: ne && k.instanceColor !== null,
      instancingMorph: ne && k.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace: ie === null ? s.outputColorSpace : ie.isXRRenderTarget === !0 ? ie.texture.colorSpace : Sa,
      alphaToCoverage: !!b.alphaToCoverage,
      map: te,
      matcap: F,
      envMap: B,
      envMapMode: B && fe.mapping,
      envMapCubeUVHeight: q,
      aoMap: L,
      lightMap: D,
      bumpMap: j,
      normalMap: Z,
      displacementMap: p && z,
      emissiveMap: $,
      normalMapObjectSpace: Z && b.normalMapType === j7,
      normalMapTangentSpace: Z && b.normalMapType === Eh,
      metalnessMap: oe,
      roughnessMap: O,
      anisotropy: V,
      anisotropyMap: we,
      clearcoat: H,
      clearcoatMap: Ae,
      clearcoatNormalMap: Ve,
      clearcoatRoughnessMap: Fe,
      dispersion: X,
      iridescence: ue,
      iridescenceMap: $e,
      iridescenceThicknessMap: Ze,
      sheen: me,
      sheenColorMap: je,
      sheenRoughnessMap: Ue,
      specularMap: rt,
      specularColorMap: Qe,
      specularIntensityMap: yt,
      transmission: _e,
      transmissionMap: Ce,
      thicknessMap: Be,
      gradientMap: ke,
      opaque: b.transparent === !1 && b.blending === rs && b.alphaToCoverage === !1,
      alphaMap: Ge,
      alphaTest: Ye,
      alphaHash: We,
      combine: b.combine,
      //
      mapUv: te && y(b.map.channel),
      aoMapUv: L && y(b.aoMap.channel),
      lightMapUv: D && y(b.lightMap.channel),
      bumpMapUv: j && y(b.bumpMap.channel),
      normalMapUv: Z && y(b.normalMap.channel),
      displacementMapUv: z && y(b.displacementMap.channel),
      emissiveMapUv: $ && y(b.emissiveMap.channel),
      metalnessMapUv: oe && y(b.metalnessMap.channel),
      roughnessMapUv: O && y(b.roughnessMap.channel),
      anisotropyMapUv: we && y(b.anisotropyMap.channel),
      clearcoatMapUv: Ae && y(b.clearcoatMap.channel),
      clearcoatNormalMapUv: Ve && y(b.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Fe && y(b.clearcoatRoughnessMap.channel),
      iridescenceMapUv: $e && y(b.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ze && y(b.iridescenceThicknessMap.channel),
      sheenColorMapUv: je && y(b.sheenColorMap.channel),
      sheenRoughnessMapUv: Ue && y(b.sheenRoughnessMap.channel),
      specularMapUv: rt && y(b.specularMap.channel),
      specularColorMapUv: Qe && y(b.specularColorMap.channel),
      specularIntensityMapUv: yt && y(b.specularIntensityMap.channel),
      transmissionMapUv: Ce && y(b.transmissionMap.channel),
      thicknessMapUv: Be && y(b.thicknessMap.channel),
      alphaMapUv: Ge && y(b.alphaMap.channel),
      //
      vertexTangents: !!I.attributes.tangent && (Z || V),
      vertexColors: b.vertexColors,
      vertexAlphas: b.vertexColors === !0 && !!I.attributes.color && I.attributes.color.itemSize === 4,
      pointsUvs: k.isPoints === !0 && !!I.attributes.uv && (te || Ge),
      fog: !!U,
      useFog: b.fog === !0,
      fogExp2: !!U && U.isFogExp2,
      flatShading: b.flatShading === !0,
      sizeAttenuation: b.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reverseDepthBuffer: he,
      skinning: k.isSkinnedMesh === !0,
      morphTargets: I.morphAttributes.position !== void 0,
      morphNormals: I.morphAttributes.normal !== void 0,
      morphColors: I.morphAttributes.color !== void 0,
      morphTargetsCount: K,
      morphTextureStride: Y,
      numDirLights: S.directional.length,
      numPointLights: S.point.length,
      numSpotLights: S.spot.length,
      numSpotLightMaps: S.spotLightMap.length,
      numRectAreaLights: S.rectArea.length,
      numHemiLights: S.hemi.length,
      numDirLightShadows: S.directionalShadowMap.length,
      numPointLightShadows: S.pointShadowMap.length,
      numSpotLightShadows: S.spotShadowMap.length,
      numSpotLightShadowsWithMaps: S.numSpotLightShadowsWithMaps,
      numLightProbes: S.numLightProbes,
      numClippingPlanes: r.numPlanes,
      numClipIntersection: r.numIntersection,
      dithering: b.dithering,
      shadowMapEnabled: s.shadowMap.enabled && A.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: ut,
      decodeVideoTexture: te && b.map.isVideoTexture === !0 && Nt.getTransfer(b.map.colorSpace) === Qt,
      decodeVideoTextureEmissive: $ && b.emissiveMap.isVideoTexture === !0 && Nt.getTransfer(b.emissiveMap.colorSpace) === Qt,
      premultipliedAlpha: b.premultipliedAlpha,
      doubleSided: b.side === mn,
      flipSided: b.side === vi,
      useDepthPacking: b.depthPacking >= 0,
      depthPacking: b.depthPacking || 0,
      index0AttributeName: b.index0AttributeName,
      extensionClipCullDistance: ht && b.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (ht && b.extensions.multiDraw === !0 || N) && i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: b.customProgramCacheKey()
    };
    return ft.vertexUv1s = u.has(1), ft.vertexUv2s = u.has(2), ft.vertexUv3s = u.has(3), u.clear(), ft;
  }
  function x(b) {
    const S = [];
    if (b.shaderID ? S.push(b.shaderID) : (S.push(b.customVertexShaderID), S.push(b.customFragmentShaderID)), b.defines !== void 0)
      for (const A in b.defines)
        S.push(A), S.push(b.defines[A]);
    return b.isRawShaderMaterial === !1 && (w(S, b), M(S, b), S.push(s.outputColorSpace)), S.push(b.customProgramCacheKey), S.join();
  }
  function w(b, S) {
    b.push(S.precision), b.push(S.outputColorSpace), b.push(S.envMapMode), b.push(S.envMapCubeUVHeight), b.push(S.mapUv), b.push(S.alphaMapUv), b.push(S.lightMapUv), b.push(S.aoMapUv), b.push(S.bumpMapUv), b.push(S.normalMapUv), b.push(S.displacementMapUv), b.push(S.emissiveMapUv), b.push(S.metalnessMapUv), b.push(S.roughnessMapUv), b.push(S.anisotropyMapUv), b.push(S.clearcoatMapUv), b.push(S.clearcoatNormalMapUv), b.push(S.clearcoatRoughnessMapUv), b.push(S.iridescenceMapUv), b.push(S.iridescenceThicknessMapUv), b.push(S.sheenColorMapUv), b.push(S.sheenRoughnessMapUv), b.push(S.specularMapUv), b.push(S.specularColorMapUv), b.push(S.specularIntensityMapUv), b.push(S.transmissionMapUv), b.push(S.thicknessMapUv), b.push(S.combine), b.push(S.fogExp2), b.push(S.sizeAttenuation), b.push(S.morphTargetsCount), b.push(S.morphAttributeCount), b.push(S.numDirLights), b.push(S.numPointLights), b.push(S.numSpotLights), b.push(S.numSpotLightMaps), b.push(S.numHemiLights), b.push(S.numRectAreaLights), b.push(S.numDirLightShadows), b.push(S.numPointLightShadows), b.push(S.numSpotLightShadows), b.push(S.numSpotLightShadowsWithMaps), b.push(S.numLightProbes), b.push(S.shadowMapType), b.push(S.toneMapping), b.push(S.numClippingPlanes), b.push(S.numClipIntersection), b.push(S.depthPacking);
  }
  function M(b, S) {
    l.disableAll(), S.supportsVertexTextures && l.enable(0), S.instancing && l.enable(1), S.instancingColor && l.enable(2), S.instancingMorph && l.enable(3), S.matcap && l.enable(4), S.envMap && l.enable(5), S.normalMapObjectSpace && l.enable(6), S.normalMapTangentSpace && l.enable(7), S.clearcoat && l.enable(8), S.iridescence && l.enable(9), S.alphaTest && l.enable(10), S.vertexColors && l.enable(11), S.vertexAlphas && l.enable(12), S.vertexUv1s && l.enable(13), S.vertexUv2s && l.enable(14), S.vertexUv3s && l.enable(15), S.vertexTangents && l.enable(16), S.anisotropy && l.enable(17), S.alphaHash && l.enable(18), S.batching && l.enable(19), S.dispersion && l.enable(20), S.batchingColor && l.enable(21), b.push(l.mask), l.disableAll(), S.fog && l.enable(0), S.useFog && l.enable(1), S.flatShading && l.enable(2), S.logarithmicDepthBuffer && l.enable(3), S.reverseDepthBuffer && l.enable(4), S.skinning && l.enable(5), S.morphTargets && l.enable(6), S.morphNormals && l.enable(7), S.morphColors && l.enable(8), S.premultipliedAlpha && l.enable(9), S.shadowMapEnabled && l.enable(10), S.doubleSided && l.enable(11), S.flipSided && l.enable(12), S.useDepthPacking && l.enable(13), S.dithering && l.enable(14), S.transmission && l.enable(15), S.sheen && l.enable(16), S.opaque && l.enable(17), S.pointsUvs && l.enable(18), S.decodeVideoTexture && l.enable(19), S.decodeVideoTextureEmissive && l.enable(20), S.alphaToCoverage && l.enable(21), b.push(l.mask);
  }
  function _(b) {
    const S = m[b.type];
    let A;
    if (S) {
      const R = Ss[S];
      A = ls.clone(R.uniforms);
    } else
      A = b.uniforms;
    return A;
  }
  function C(b, S) {
    let A;
    for (let R = 0, k = d.length; R < k; R++) {
      const U = d[R];
      if (U.cacheKey === S) {
        A = U, ++A.usedTimes;
        break;
      }
    }
    return A === void 0 && (A = new Kb(s, S, b, a), d.push(A)), A;
  }
  function T(b) {
    if (--b.usedTimes === 0) {
      const S = d.indexOf(b);
      d[S] = d[d.length - 1], d.pop(), b.destroy();
    }
  }
  function P(b) {
    c.remove(b);
  }
  function E() {
    c.dispose();
  }
  return {
    getParameters: g,
    getProgramCacheKey: x,
    getUniforms: _,
    acquireProgram: C,
    releaseProgram: T,
    releaseShaderCache: P,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: d,
    dispose: E
  };
}
function n_() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(r) {
    return s.has(r);
  }
  function n(r) {
    let l = s.get(r);
    return l === void 0 && (l = {}, s.set(r, l)), l;
  }
  function i(r) {
    s.delete(r);
  }
  function o(r, l, c) {
    s.get(r)[l] = c;
  }
  function a() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: n,
    remove: i,
    update: o,
    dispose: a
  };
}
function i_(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function e2(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function t2() {
  const s = [];
  let e = 0;
  const n = [], i = [], o = [];
  function a() {
    e = 0, n.length = 0, i.length = 0, o.length = 0;
  }
  function r(h, p, f, m, y, g) {
    let x = s[e];
    return x === void 0 ? (x = {
      id: h.id,
      object: h,
      geometry: p,
      material: f,
      groupOrder: m,
      renderOrder: h.renderOrder,
      z: y,
      group: g
    }, s[e] = x) : (x.id = h.id, x.object = h, x.geometry = p, x.material = f, x.groupOrder = m, x.renderOrder = h.renderOrder, x.z = y, x.group = g), e++, x;
  }
  function l(h, p, f, m, y, g) {
    const x = r(h, p, f, m, y, g);
    f.transmission > 0 ? i.push(x) : f.transparent === !0 ? o.push(x) : n.push(x);
  }
  function c(h, p, f, m, y, g) {
    const x = r(h, p, f, m, y, g);
    f.transmission > 0 ? i.unshift(x) : f.transparent === !0 ? o.unshift(x) : n.unshift(x);
  }
  function u(h, p) {
    n.length > 1 && n.sort(h || i_), i.length > 1 && i.sort(p || e2), o.length > 1 && o.sort(p || e2);
  }
  function d() {
    for (let h = e, p = s.length; h < p; h++) {
      const f = s[h];
      if (f.id === null) break;
      f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null;
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: o,
    init: a,
    push: l,
    unshift: c,
    finish: d,
    sort: u
  };
}
function s_() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(i, o) {
    const a = s.get(i);
    let r;
    return a === void 0 ? (r = new t2(), s.set(i, [r])) : o >= a.length ? (r = new t2(), a.push(r)) : r = a[o], r;
  }
  function n() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
function o_() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new pe(),
            color: new Mt()
          };
          break;
        case "SpotLight":
          n = {
            position: new pe(),
            direction: new pe(),
            color: new Mt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new pe(),
            color: new Mt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new pe(),
            skyColor: new Mt(),
            groundColor: new Mt()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Mt(),
            position: new pe(),
            halfWidth: new pe(),
            halfHeight: new pe()
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
function a_() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe()
          };
          break;
        case "SpotLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe()
          };
          break;
        case "PointLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
let r_ = 0;
function l_(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function c_(s) {
  const e = new o_(), n = a_(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++) i.probe.push(new pe());
  const o = new pe(), a = new jt(), r = new jt();
  function l(u) {
    let d = 0, h = 0, p = 0;
    for (let b = 0; b < 9; b++) i.probe[b].set(0, 0, 0);
    let f = 0, m = 0, y = 0, g = 0, x = 0, w = 0, M = 0, _ = 0, C = 0, T = 0, P = 0;
    u.sort(l_);
    for (let b = 0, S = u.length; b < S; b++) {
      const A = u[b], R = A.color, k = A.intensity, U = A.distance, I = A.shadow && A.shadow.map ? A.shadow.map.texture : null;
      if (A.isAmbientLight)
        d += R.r * k, h += R.g * k, p += R.b * k;
      else if (A.isLightProbe) {
        for (let W = 0; W < 9; W++)
          i.probe[W].addScaledVector(A.sh.coefficients[W], k);
        P++;
      } else if (A.isDirectionalLight) {
        const W = e.get(A);
        if (W.color.copy(A.color).multiplyScalar(A.intensity), A.castShadow) {
          const fe = A.shadow, q = n.get(A);
          q.shadowIntensity = fe.intensity, q.shadowBias = fe.bias, q.shadowNormalBias = fe.normalBias, q.shadowRadius = fe.radius, q.shadowMapSize = fe.mapSize, i.directionalShadow[f] = q, i.directionalShadowMap[f] = I, i.directionalShadowMatrix[f] = A.shadow.matrix, w++;
        }
        i.directional[f] = W, f++;
      } else if (A.isSpotLight) {
        const W = e.get(A);
        W.position.setFromMatrixPosition(A.matrixWorld), W.color.copy(R).multiplyScalar(k), W.distance = U, W.coneCos = Math.cos(A.angle), W.penumbraCos = Math.cos(A.angle * (1 - A.penumbra)), W.decay = A.decay, i.spot[y] = W;
        const fe = A.shadow;
        if (A.map && (i.spotLightMap[C] = A.map, C++, fe.updateMatrices(A), A.castShadow && T++), i.spotLightMatrix[y] = fe.matrix, A.castShadow) {
          const q = n.get(A);
          q.shadowIntensity = fe.intensity, q.shadowBias = fe.bias, q.shadowNormalBias = fe.normalBias, q.shadowRadius = fe.radius, q.shadowMapSize = fe.mapSize, i.spotShadow[y] = q, i.spotShadowMap[y] = I, _++;
        }
        y++;
      } else if (A.isRectAreaLight) {
        const W = e.get(A);
        W.color.copy(R).multiplyScalar(k), W.halfWidth.set(A.width * 0.5, 0, 0), W.halfHeight.set(0, A.height * 0.5, 0), i.rectArea[g] = W, g++;
      } else if (A.isPointLight) {
        const W = e.get(A);
        if (W.color.copy(A.color).multiplyScalar(A.intensity), W.distance = A.distance, W.decay = A.decay, A.castShadow) {
          const fe = A.shadow, q = n.get(A);
          q.shadowIntensity = fe.intensity, q.shadowBias = fe.bias, q.shadowNormalBias = fe.normalBias, q.shadowRadius = fe.radius, q.shadowMapSize = fe.mapSize, q.shadowCameraNear = fe.camera.near, q.shadowCameraFar = fe.camera.far, i.pointShadow[m] = q, i.pointShadowMap[m] = I, i.pointShadowMatrix[m] = A.shadow.matrix, M++;
        }
        i.point[m] = W, m++;
      } else if (A.isHemisphereLight) {
        const W = e.get(A);
        W.skyColor.copy(A.color).multiplyScalar(k), W.groundColor.copy(A.groundColor).multiplyScalar(k), i.hemi[x] = W, x++;
      }
    }
    g > 0 && (s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = nt.LTC_FLOAT_1, i.rectAreaLTC2 = nt.LTC_FLOAT_2) : (i.rectAreaLTC1 = nt.LTC_HALF_1, i.rectAreaLTC2 = nt.LTC_HALF_2)), i.ambient[0] = d, i.ambient[1] = h, i.ambient[2] = p;
    const E = i.hash;
    (E.directionalLength !== f || E.pointLength !== m || E.spotLength !== y || E.rectAreaLength !== g || E.hemiLength !== x || E.numDirectionalShadows !== w || E.numPointShadows !== M || E.numSpotShadows !== _ || E.numSpotMaps !== C || E.numLightProbes !== P) && (i.directional.length = f, i.spot.length = y, i.rectArea.length = g, i.point.length = m, i.hemi.length = x, i.directionalShadow.length = w, i.directionalShadowMap.length = w, i.pointShadow.length = M, i.pointShadowMap.length = M, i.spotShadow.length = _, i.spotShadowMap.length = _, i.directionalShadowMatrix.length = w, i.pointShadowMatrix.length = M, i.spotLightMatrix.length = _ + C - T, i.spotLightMap.length = C, i.numSpotLightShadowsWithMaps = T, i.numLightProbes = P, E.directionalLength = f, E.pointLength = m, E.spotLength = y, E.rectAreaLength = g, E.hemiLength = x, E.numDirectionalShadows = w, E.numPointShadows = M, E.numSpotShadows = _, E.numSpotMaps = C, E.numLightProbes = P, i.version = r_++);
  }
  function c(u, d) {
    let h = 0, p = 0, f = 0, m = 0, y = 0;
    const g = d.matrixWorldInverse;
    for (let x = 0, w = u.length; x < w; x++) {
      const M = u[x];
      if (M.isDirectionalLight) {
        const _ = i.directional[h];
        _.direction.setFromMatrixPosition(M.matrixWorld), o.setFromMatrixPosition(M.target.matrixWorld), _.direction.sub(o), _.direction.transformDirection(g), h++;
      } else if (M.isSpotLight) {
        const _ = i.spot[f];
        _.position.setFromMatrixPosition(M.matrixWorld), _.position.applyMatrix4(g), _.direction.setFromMatrixPosition(M.matrixWorld), o.setFromMatrixPosition(M.target.matrixWorld), _.direction.sub(o), _.direction.transformDirection(g), f++;
      } else if (M.isRectAreaLight) {
        const _ = i.rectArea[m];
        _.position.setFromMatrixPosition(M.matrixWorld), _.position.applyMatrix4(g), r.identity(), a.copy(M.matrixWorld), a.premultiply(g), r.extractRotation(a), _.halfWidth.set(M.width * 0.5, 0, 0), _.halfHeight.set(0, M.height * 0.5, 0), _.halfWidth.applyMatrix4(r), _.halfHeight.applyMatrix4(r), m++;
      } else if (M.isPointLight) {
        const _ = i.point[p];
        _.position.setFromMatrixPosition(M.matrixWorld), _.position.applyMatrix4(g), p++;
      } else if (M.isHemisphereLight) {
        const _ = i.hemi[y];
        _.direction.setFromMatrixPosition(M.matrixWorld), _.direction.transformDirection(g), y++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: i
  };
}
function n2(s) {
  const e = new c_(s), n = [], i = [];
  function o(d) {
    u.camera = d, n.length = 0, i.length = 0;
  }
  function a(d) {
    n.push(d);
  }
  function r(d) {
    i.push(d);
  }
  function l() {
    e.setup(n);
  }
  function c(d) {
    e.setupView(n, d);
  }
  const u = {
    lightsArray: n,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: o,
    state: u,
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: r
  };
}
function u_(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(o, a = 0) {
    const r = e.get(o);
    let l;
    return r === void 0 ? (l = new n2(s), e.set(o, [l])) : a >= r.length ? (l = new n2(s), r.push(l)) : l = r[a], l;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class Rh extends _o {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = W7, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class km extends _o {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const d_ = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, h_ = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function f_(s, e, n) {
  let i = new Dh();
  const o = new qe(), a = new qe(), r = new Kt(), l = new Rh({ depthPacking: Th }), c = new km(), u = {}, d = n.maxTextureSize, h = { [L0]: vi, [vi]: L0, [mn]: mn }, p = new dn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new qe() },
      radius: { value: 4 }
    },
    vertexShader: d_,
    fragmentShader: h_
  }), f = p.clone();
  f.defines.HORIZONTAL_PASS = 1;
  const m = new Ut();
  m.setAttribute(
    "position",
    new Vi(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const y = new Ke(m, p), g = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = j3;
  let x = this.type;
  this.render = function(T, P, E) {
    if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || T.length === 0) return;
    const b = s.getRenderTarget(), S = s.getActiveCubeFace(), A = s.getActiveMipmapLevel(), R = s.state;
    R.setBlending(si), R.buffers.color.setClear(1, 1, 1, 1), R.buffers.depth.setTest(!0), R.setScissorTest(!1);
    const k = x !== Vs && this.type === Vs, U = x === Vs && this.type !== Vs;
    for (let I = 0, W = T.length; I < W; I++) {
      const fe = T[I], q = fe.shadow;
      if (q === void 0) {
        console.warn("THREE.WebGLShadowMap:", fe, "has no shadow.");
        continue;
      }
      if (q.autoUpdate === !1 && q.needsUpdate === !1) continue;
      o.copy(q.mapSize);
      const G = q.getFrameExtents();
      if (o.multiply(G), a.copy(q.mapSize), (o.x > d || o.y > d) && (o.x > d && (a.x = Math.floor(d / G.x), o.x = a.x * G.x, q.mapSize.x = a.x), o.y > d && (a.y = Math.floor(d / G.y), o.y = a.y * G.y, q.mapSize.y = a.y)), q.map === null || k === !0 || U === !0) {
        const K = this.type !== Vs ? { minFilter: xn, magFilter: xn } : {};
        q.map !== null && q.map.dispose(), q.map = new Xn(o.x, o.y, K), q.map.texture.name = fe.name + ".shadowMap", q.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(q.map), s.clear();
      const Q = q.getViewportCount();
      for (let K = 0; K < Q; K++) {
        const Y = q.getViewport(K);
        r.set(
          a.x * Y.x,
          a.y * Y.y,
          a.x * Y.z,
          a.y * Y.w
        ), R.viewport(r), q.updateMatrices(fe, K), i = q.getFrustum(), _(P, E, q.camera, fe, this.type);
      }
      q.isPointLightShadow !== !0 && this.type === Vs && w(q, E), q.needsUpdate = !1;
    }
    x = this.type, g.needsUpdate = !1, s.setRenderTarget(b, S, A);
  };
  function w(T, P) {
    const E = e.update(y);
    p.defines.VSM_SAMPLES !== T.blurSamples && (p.defines.VSM_SAMPLES = T.blurSamples, f.defines.VSM_SAMPLES = T.blurSamples, p.needsUpdate = !0, f.needsUpdate = !0), T.mapPass === null && (T.mapPass = new Xn(o.x, o.y)), p.uniforms.shadow_pass.value = T.map.texture, p.uniforms.resolution.value = T.mapSize, p.uniforms.radius.value = T.radius, s.setRenderTarget(T.mapPass), s.clear(), s.renderBufferDirect(P, null, E, p, y, null), f.uniforms.shadow_pass.value = T.mapPass.texture, f.uniforms.resolution.value = T.mapSize, f.uniforms.radius.value = T.radius, s.setRenderTarget(T.map), s.clear(), s.renderBufferDirect(P, null, E, f, y, null);
  }
  function M(T, P, E, b) {
    let S = null;
    const A = E.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial;
    if (A !== void 0)
      S = A;
    else if (S = E.isPointLight === !0 ? c : l, s.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
      const R = S.uuid, k = P.uuid;
      let U = u[R];
      U === void 0 && (U = {}, u[R] = U);
      let I = U[k];
      I === void 0 && (I = S.clone(), U[k] = I, P.addEventListener("dispose", C)), S = I;
    }
    if (S.visible = P.visible, S.wireframe = P.wireframe, b === Vs ? S.side = P.shadowSide !== null ? P.shadowSide : P.side : S.side = P.shadowSide !== null ? P.shadowSide : h[P.side], S.alphaMap = P.alphaMap, S.alphaTest = P.alphaTest, S.map = P.map, S.clipShadows = P.clipShadows, S.clippingPlanes = P.clippingPlanes, S.clipIntersection = P.clipIntersection, S.displacementMap = P.displacementMap, S.displacementScale = P.displacementScale, S.displacementBias = P.displacementBias, S.wireframeLinewidth = P.wireframeLinewidth, S.linewidth = P.linewidth, E.isPointLight === !0 && S.isMeshDistanceMaterial === !0) {
      const R = s.properties.get(S);
      R.light = E;
    }
    return S;
  }
  function _(T, P, E, b, S) {
    if (T.visible === !1) return;
    if (T.layers.test(P.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && S === Vs) && (!T.frustumCulled || i.intersectsObject(T))) {
      T.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse, T.matrixWorld);
      const k = e.update(T), U = T.material;
      if (Array.isArray(U)) {
        const I = k.groups;
        for (let W = 0, fe = I.length; W < fe; W++) {
          const q = I[W], G = U[q.materialIndex];
          if (G && G.visible) {
            const Q = M(T, G, b, S);
            T.onBeforeShadow(s, T, P, E, k, Q, q), s.renderBufferDirect(E, null, k, Q, T, q), T.onAfterShadow(s, T, P, E, k, Q, q);
          }
        }
      } else if (U.visible) {
        const I = M(T, U, b, S);
        T.onBeforeShadow(s, T, P, E, k, I, null), s.renderBufferDirect(E, null, k, I, T, null), T.onAfterShadow(s, T, P, E, k, I, null);
      }
    }
    const R = T.children;
    for (let k = 0, U = R.length; k < U; k++)
      _(R[k], P, E, b, S);
  }
  function C(T) {
    T.target.removeEventListener("dispose", C);
    for (const E in u) {
      const b = u[E], S = T.target.uuid;
      S in b && (b[S].dispose(), delete b[S]);
    }
  }
}
const p_ = {
  [ad]: rd,
  [ld]: dd,
  [cd]: hd,
  [fa]: ud,
  [rd]: ad,
  [dd]: ld,
  [hd]: cd,
  [ud]: fa
};
function m_(s, e) {
  function n() {
    let Ce = !1;
    const Be = new Kt();
    let ke = null;
    const Ge = new Kt(0, 0, 0, 0);
    return {
      setMask: function(Ye) {
        ke !== Ye && !Ce && (s.colorMask(Ye, Ye, Ye, Ye), ke = Ye);
      },
      setLocked: function(Ye) {
        Ce = Ye;
      },
      setClear: function(Ye, We, ht, ut, ft) {
        ft === !0 && (Ye *= ut, We *= ut, ht *= ut), Be.set(Ye, We, ht, ut), Ge.equals(Be) === !1 && (s.clearColor(Ye, We, ht, ut), Ge.copy(Be));
      },
      reset: function() {
        Ce = !1, ke = null, Ge.set(-1, 0, 0, 0);
      }
    };
  }
  function i() {
    let Ce = !1, Be = !1, ke = null, Ge = null, Ye = null;
    return {
      setReversed: function(We) {
        if (Be !== We) {
          const ht = e.get("EXT_clip_control");
          Be ? ht.clipControlEXT(ht.LOWER_LEFT_EXT, ht.ZERO_TO_ONE_EXT) : ht.clipControlEXT(ht.LOWER_LEFT_EXT, ht.NEGATIVE_ONE_TO_ONE_EXT);
          const ut = Ye;
          Ye = null, this.setClear(ut);
        }
        Be = We;
      },
      getReversed: function() {
        return Be;
      },
      setTest: function(We) {
        We ? ie(s.DEPTH_TEST) : he(s.DEPTH_TEST);
      },
      setMask: function(We) {
        ke !== We && !Ce && (s.depthMask(We), ke = We);
      },
      setFunc: function(We) {
        if (Be && (We = p_[We]), Ge !== We) {
          switch (We) {
            case ad:
              s.depthFunc(s.NEVER);
              break;
            case rd:
              s.depthFunc(s.ALWAYS);
              break;
            case ld:
              s.depthFunc(s.LESS);
              break;
            case fa:
              s.depthFunc(s.LEQUAL);
              break;
            case cd:
              s.depthFunc(s.EQUAL);
              break;
            case ud:
              s.depthFunc(s.GEQUAL);
              break;
            case dd:
              s.depthFunc(s.GREATER);
              break;
            case hd:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Ge = We;
        }
      },
      setLocked: function(We) {
        Ce = We;
      },
      setClear: function(We) {
        Ye !== We && (Be && (We = 1 - We), s.clearDepth(We), Ye = We);
      },
      reset: function() {
        Ce = !1, ke = null, Ge = null, Ye = null, Be = !1;
      }
    };
  }
  function o() {
    let Ce = !1, Be = null, ke = null, Ge = null, Ye = null, We = null, ht = null, ut = null, ft = null;
    return {
      setTest: function(vt) {
        Ce || (vt ? ie(s.STENCIL_TEST) : he(s.STENCIL_TEST));
      },
      setMask: function(vt) {
        Be !== vt && !Ce && (s.stencilMask(vt), Be = vt);
      },
      setFunc: function(vt, Gt, en) {
        (ke !== vt || Ge !== Gt || Ye !== en) && (s.stencilFunc(vt, Gt, en), ke = vt, Ge = Gt, Ye = en);
      },
      setOp: function(vt, Gt, en) {
        (We !== vt || ht !== Gt || ut !== en) && (s.stencilOp(vt, Gt, en), We = vt, ht = Gt, ut = en);
      },
      setLocked: function(vt) {
        Ce = vt;
      },
      setClear: function(vt) {
        ft !== vt && (s.clearStencil(vt), ft = vt);
      },
      reset: function() {
        Ce = !1, Be = null, ke = null, Ge = null, Ye = null, We = null, ht = null, ut = null, ft = null;
      }
    };
  }
  const a = new n(), r = new i(), l = new o(), c = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, h = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, y = !1, g = null, x = null, w = null, M = null, _ = null, C = null, T = null, P = new Mt(0, 0, 0), E = 0, b = !1, S = null, A = null, R = null, k = null, U = null;
  const I = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let W = !1, fe = 0;
  const q = s.getParameter(s.VERSION);
  q.indexOf("WebGL") !== -1 ? (fe = parseFloat(/^WebGL (\d)/.exec(q)[1]), W = fe >= 1) : q.indexOf("OpenGL ES") !== -1 && (fe = parseFloat(/^OpenGL ES (\d)/.exec(q)[1]), W = fe >= 2);
  let G = null, Q = {};
  const K = s.getParameter(s.SCISSOR_BOX), Y = s.getParameter(s.VIEWPORT), ee = new Kt().fromArray(K), ce = new Kt().fromArray(Y);
  function ae(Ce, Be, ke, Ge) {
    const Ye = new Uint8Array(4), We = s.createTexture();
    s.bindTexture(Ce, We), s.texParameteri(Ce, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(Ce, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let ht = 0; ht < ke; ht++)
      Ce === s.TEXTURE_3D || Ce === s.TEXTURE_2D_ARRAY ? s.texImage3D(Be, 0, s.RGBA, 1, 1, Ge, 0, s.RGBA, s.UNSIGNED_BYTE, Ye) : s.texImage2D(Be + ht, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, Ye);
    return We;
  }
  const de = {};
  de[s.TEXTURE_2D] = ae(s.TEXTURE_2D, s.TEXTURE_2D, 1), de[s.TEXTURE_CUBE_MAP] = ae(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), de[s.TEXTURE_2D_ARRAY] = ae(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), de[s.TEXTURE_3D] = ae(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), a.setClear(0, 0, 0, 1), r.setClear(1), l.setClear(0), ie(s.DEPTH_TEST), r.setFunc(fa), j(!1), Z(rp), ie(s.CULL_FACE), L(si);
  function ie(Ce) {
    d[Ce] !== !0 && (s.enable(Ce), d[Ce] = !0);
  }
  function he(Ce) {
    d[Ce] !== !1 && (s.disable(Ce), d[Ce] = !1);
  }
  function ne(Ce, Be) {
    return h[Ce] !== Be ? (s.bindFramebuffer(Ce, Be), h[Ce] = Be, Ce === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = Be), Ce === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = Be), !0) : !1;
  }
  function N(Ce, Be) {
    let ke = f, Ge = !1;
    if (Ce) {
      ke = p.get(Be), ke === void 0 && (ke = [], p.set(Be, ke));
      const Ye = Ce.textures;
      if (ke.length !== Ye.length || ke[0] !== s.COLOR_ATTACHMENT0) {
        for (let We = 0, ht = Ye.length; We < ht; We++)
          ke[We] = s.COLOR_ATTACHMENT0 + We;
        ke.length = Ye.length, Ge = !0;
      }
    } else
      ke[0] !== s.BACK && (ke[0] = s.BACK, Ge = !0);
    Ge && s.drawBuffers(ke);
  }
  function te(Ce) {
    return m !== Ce ? (s.useProgram(Ce), m = Ce, !0) : !1;
  }
  const F = {
    [Oi]: s.FUNC_ADD,
    [Y3]: s.FUNC_SUBTRACT,
    [R7]: s.FUNC_REVERSE_SUBTRACT
  };
  F[q3] = s.MIN, F[Z3] = s.MAX;
  const B = {
    [sd]: s.ZERO,
    [Hs]: s.ONE,
    [L7]: s.SRC_COLOR,
    [Uc]: s.SRC_ALPHA,
    [O7]: s.SRC_ALPHA_SATURATE,
    [J3]: s.DST_COLOR,
    [K3]: s.DST_ALPHA,
    [od]: s.ONE_MINUS_SRC_COLOR,
    [Or]: s.ONE_MINUS_SRC_ALPHA,
    [Q3]: s.ONE_MINUS_DST_COLOR,
    [F7]: s.ONE_MINUS_DST_ALPHA,
    [U7]: s.CONSTANT_COLOR,
    [z7]: s.ONE_MINUS_CONSTANT_COLOR,
    [B7]: s.CONSTANT_ALPHA,
    [N7]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function L(Ce, Be, ke, Ge, Ye, We, ht, ut, ft, vt) {
    if (Ce === si) {
      y === !0 && (he(s.BLEND), y = !1);
      return;
    }
    if (y === !1 && (ie(s.BLEND), y = !0), Ce !== E0) {
      if (Ce !== g || vt !== b) {
        if ((x !== Oi || _ !== Oi) && (s.blendEquation(s.FUNC_ADD), x = Oi, _ = Oi), vt)
          switch (Ce) {
            case rs:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case ha:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case id:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case ra:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Ce);
              break;
          }
        else
          switch (Ce) {
            case rs:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case ha:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case id:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case ra:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", Ce);
              break;
          }
        w = null, M = null, C = null, T = null, P.set(0, 0, 0), E = 0, g = Ce, b = vt;
      }
      return;
    }
    Ye = Ye || Be, We = We || ke, ht = ht || Ge, (Be !== x || Ye !== _) && (s.blendEquationSeparate(F[Be], F[Ye]), x = Be, _ = Ye), (ke !== w || Ge !== M || We !== C || ht !== T) && (s.blendFuncSeparate(B[ke], B[Ge], B[We], B[ht]), w = ke, M = Ge, C = We, T = ht), (ut.equals(P) === !1 || ft !== E) && (s.blendColor(ut.r, ut.g, ut.b, ft), P.copy(ut), E = ft), g = Ce, b = !1;
  }
  function D(Ce, Be) {
    Ce.side === mn ? he(s.CULL_FACE) : ie(s.CULL_FACE);
    let ke = Ce.side === vi;
    Be && (ke = !ke), j(ke), Ce.blending === rs && Ce.transparent === !1 ? L(si) : L(Ce.blending, Ce.blendEquation, Ce.blendSrc, Ce.blendDst, Ce.blendEquationAlpha, Ce.blendSrcAlpha, Ce.blendDstAlpha, Ce.blendColor, Ce.blendAlpha, Ce.premultipliedAlpha), r.setFunc(Ce.depthFunc), r.setTest(Ce.depthTest), r.setMask(Ce.depthWrite), a.setMask(Ce.colorWrite);
    const Ge = Ce.stencilWrite;
    l.setTest(Ge), Ge && (l.setMask(Ce.stencilWriteMask), l.setFunc(Ce.stencilFunc, Ce.stencilRef, Ce.stencilFuncMask), l.setOp(Ce.stencilFail, Ce.stencilZFail, Ce.stencilZPass)), $(Ce.polygonOffset, Ce.polygonOffsetFactor, Ce.polygonOffsetUnits), Ce.alphaToCoverage === !0 ? ie(s.SAMPLE_ALPHA_TO_COVERAGE) : he(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function j(Ce) {
    S !== Ce && (Ce ? s.frontFace(s.CW) : s.frontFace(s.CCW), S = Ce);
  }
  function Z(Ce) {
    Ce !== D7 ? (ie(s.CULL_FACE), Ce !== A && (Ce === rp ? s.cullFace(s.BACK) : Ce === I7 ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : he(s.CULL_FACE), A = Ce;
  }
  function z(Ce) {
    Ce !== R && (W && s.lineWidth(Ce), R = Ce);
  }
  function $(Ce, Be, ke) {
    Ce ? (ie(s.POLYGON_OFFSET_FILL), (k !== Be || U !== ke) && (s.polygonOffset(Be, ke), k = Be, U = ke)) : he(s.POLYGON_OFFSET_FILL);
  }
  function oe(Ce) {
    Ce ? ie(s.SCISSOR_TEST) : he(s.SCISSOR_TEST);
  }
  function O(Ce) {
    Ce === void 0 && (Ce = s.TEXTURE0 + I - 1), G !== Ce && (s.activeTexture(Ce), G = Ce);
  }
  function V(Ce, Be, ke) {
    ke === void 0 && (G === null ? ke = s.TEXTURE0 + I - 1 : ke = G);
    let Ge = Q[ke];
    Ge === void 0 && (Ge = { type: void 0, texture: void 0 }, Q[ke] = Ge), (Ge.type !== Ce || Ge.texture !== Be) && (G !== ke && (s.activeTexture(ke), G = ke), s.bindTexture(Ce, Be || de[Ce]), Ge.type = Ce, Ge.texture = Be);
  }
  function H() {
    const Ce = Q[G];
    Ce !== void 0 && Ce.type !== void 0 && (s.bindTexture(Ce.type, null), Ce.type = void 0, Ce.texture = void 0);
  }
  function X() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function ue() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function me() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function _e() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function we() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function Ae() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function Ve() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function Fe() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function $e() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function Ze() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (Ce) {
      console.error("THREE.WebGLState:", Ce);
    }
  }
  function je(Ce) {
    ee.equals(Ce) === !1 && (s.scissor(Ce.x, Ce.y, Ce.z, Ce.w), ee.copy(Ce));
  }
  function Ue(Ce) {
    ce.equals(Ce) === !1 && (s.viewport(Ce.x, Ce.y, Ce.z, Ce.w), ce.copy(Ce));
  }
  function rt(Ce, Be) {
    let ke = u.get(Be);
    ke === void 0 && (ke = /* @__PURE__ */ new WeakMap(), u.set(Be, ke));
    let Ge = ke.get(Ce);
    Ge === void 0 && (Ge = s.getUniformBlockIndex(Be, Ce.name), ke.set(Ce, Ge));
  }
  function Qe(Ce, Be) {
    const Ge = u.get(Be).get(Ce);
    c.get(Be) !== Ge && (s.uniformBlockBinding(Be, Ge, Ce.__bindingPointIndex), c.set(Be, Ge));
  }
  function yt() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), r.setReversed(!1), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), d = {}, G = null, Q = {}, h = {}, p = /* @__PURE__ */ new WeakMap(), f = [], m = null, y = !1, g = null, x = null, w = null, M = null, _ = null, C = null, T = null, P = new Mt(0, 0, 0), E = 0, b = !1, S = null, A = null, R = null, k = null, U = null, ee.set(0, 0, s.canvas.width, s.canvas.height), ce.set(0, 0, s.canvas.width, s.canvas.height), a.reset(), r.reset(), l.reset();
  }
  return {
    buffers: {
      color: a,
      depth: r,
      stencil: l
    },
    enable: ie,
    disable: he,
    bindFramebuffer: ne,
    drawBuffers: N,
    useProgram: te,
    setBlending: L,
    setMaterial: D,
    setFlipSided: j,
    setCullFace: Z,
    setLineWidth: z,
    setPolygonOffset: $,
    setScissorTest: oe,
    activeTexture: O,
    bindTexture: V,
    unbindTexture: H,
    compressedTexImage2D: X,
    compressedTexImage3D: ue,
    texImage2D: $e,
    texImage3D: Ze,
    updateUBOMapping: rt,
    uniformBlockBinding: Qe,
    texStorage2D: Ve,
    texStorage3D: Fe,
    texSubImage2D: me,
    texSubImage3D: _e,
    compressedTexSubImage2D: we,
    compressedTexSubImage3D: Ae,
    scissor: je,
    viewport: Ue,
    reset: yt
  };
}
function i2(s, e, n, i) {
  const o = v_(i);
  switch (n) {
    case cm:
      return s * e;
    case dm:
      return s * e;
    case hm:
      return s * e * 2;
    case Br:
      return s * e / o.components * o.byteLength;
    case Mh:
      return s * e / o.components * o.byteLength;
    case fm:
      return s * e * 2 / o.components * o.byteLength;
    case Sh:
      return s * e * 2 / o.components * o.byteLength;
    case um:
      return s * e * 3 / o.components * o.byteLength;
    case Sn:
      return s * e * 4 / o.components * o.byteLength;
    case Ch:
      return s * e * 4 / o.components * o.byteLength;
    case hc:
    case fc:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case pc:
    case mc:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case gd:
    case xd:
      return Math.max(s, 16) * Math.max(e, 8) / 4;
    case vd:
    case yd:
      return Math.max(s, 8) * Math.max(e, 8) / 2;
    case bd:
    case _d:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case wd:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Md:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Sd:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Cd:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Td:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Ed:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Ad:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Pd:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case kd:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Dd:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Id:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Rd:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Ld:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Fd:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Od:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case vc:
    case Ud:
    case zd:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case pm:
    case Bd:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case Nd:
    case Vd:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${n} format.`
  );
}
function v_(s) {
  switch (s) {
    case ps:
    case am:
      return { byteLength: 1, components: 1 };
    case zr:
    case rm:
    case gi:
      return { byteLength: 2, components: 1 };
    case _h:
    case wh:
      return { byteLength: 2, components: 4 };
    case mo:
    case bh:
    case Vn:
      return { byteLength: 4, components: 1 };
    case lm:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
function g_(s, e, n, i, o, a, r) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new qe(), d = /* @__PURE__ */ new WeakMap();
  let h;
  const p = /* @__PURE__ */ new WeakMap();
  let f = !1;
  try {
    f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function m(O, V) {
    return f ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(O, V)
    ) : Nr("canvas");
  }
  function y(O, V, H) {
    let X = 1;
    const ue = oe(O);
    if ((ue.width > H || ue.height > H) && (X = H / Math.max(ue.width, ue.height)), X < 1)
      if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap || typeof VideoFrame < "u" && O instanceof VideoFrame) {
        const me = Math.floor(X * ue.width), _e = Math.floor(X * ue.height);
        h === void 0 && (h = m(me, _e));
        const we = V ? m(me, _e) : h;
        return we.width = me, we.height = _e, we.getContext("2d").drawImage(O, 0, 0, me, _e), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ue.width + "x" + ue.height + ") to (" + me + "x" + _e + ")."), we;
      } else
        return "data" in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ue.width + "x" + ue.height + ")."), O;
    return O;
  }
  function g(O) {
    return O.generateMipmaps;
  }
  function x(O) {
    s.generateMipmap(O);
  }
  function w(O) {
    return O.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : O.isWebGL3DRenderTarget ? s.TEXTURE_3D : O.isWebGLArrayRenderTarget || O.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
  }
  function M(O, V, H, X, ue = !1) {
    if (O !== null) {
      if (s[O] !== void 0) return s[O];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'");
    }
    let me = V;
    if (V === s.RED && (H === s.FLOAT && (me = s.R32F), H === s.HALF_FLOAT && (me = s.R16F), H === s.UNSIGNED_BYTE && (me = s.R8)), V === s.RED_INTEGER && (H === s.UNSIGNED_BYTE && (me = s.R8UI), H === s.UNSIGNED_SHORT && (me = s.R16UI), H === s.UNSIGNED_INT && (me = s.R32UI), H === s.BYTE && (me = s.R8I), H === s.SHORT && (me = s.R16I), H === s.INT && (me = s.R32I)), V === s.RG && (H === s.FLOAT && (me = s.RG32F), H === s.HALF_FLOAT && (me = s.RG16F), H === s.UNSIGNED_BYTE && (me = s.RG8)), V === s.RG_INTEGER && (H === s.UNSIGNED_BYTE && (me = s.RG8UI), H === s.UNSIGNED_SHORT && (me = s.RG16UI), H === s.UNSIGNED_INT && (me = s.RG32UI), H === s.BYTE && (me = s.RG8I), H === s.SHORT && (me = s.RG16I), H === s.INT && (me = s.RG32I)), V === s.RGB_INTEGER && (H === s.UNSIGNED_BYTE && (me = s.RGB8UI), H === s.UNSIGNED_SHORT && (me = s.RGB16UI), H === s.UNSIGNED_INT && (me = s.RGB32UI), H === s.BYTE && (me = s.RGB8I), H === s.SHORT && (me = s.RGB16I), H === s.INT && (me = s.RGB32I)), V === s.RGBA_INTEGER && (H === s.UNSIGNED_BYTE && (me = s.RGBA8UI), H === s.UNSIGNED_SHORT && (me = s.RGBA16UI), H === s.UNSIGNED_INT && (me = s.RGBA32UI), H === s.BYTE && (me = s.RGBA8I), H === s.SHORT && (me = s.RGBA16I), H === s.INT && (me = s.RGBA32I)), V === s.RGB && H === s.UNSIGNED_INT_5_9_9_9_REV && (me = s.RGB9_E5), V === s.RGBA) {
      const _e = ue ? uu : Nt.getTransfer(X);
      H === s.FLOAT && (me = s.RGBA32F), H === s.HALF_FLOAT && (me = s.RGBA16F), H === s.UNSIGNED_BYTE && (me = _e === Qt ? s.SRGB8_ALPHA8 : s.RGBA8), H === s.UNSIGNED_SHORT_4_4_4_4 && (me = s.RGBA4), H === s.UNSIGNED_SHORT_5_5_5_1 && (me = s.RGB5_A1);
    }
    return (me === s.R16F || me === s.R32F || me === s.RG16F || me === s.RG32F || me === s.RGBA16F || me === s.RGBA32F) && e.get("EXT_color_buffer_float"), me;
  }
  function _(O, V) {
    let H;
    return O ? V === null || V === mo || V === vo ? H = s.DEPTH24_STENCIL8 : V === Vn ? H = s.DEPTH32F_STENCIL8 : V === zr && (H = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : V === null || V === mo || V === vo ? H = s.DEPTH_COMPONENT24 : V === Vn ? H = s.DEPTH_COMPONENT32F : V === zr && (H = s.DEPTH_COMPONENT16), H;
  }
  function C(O, V) {
    return g(O) === !0 || O.isFramebufferTexture && O.minFilter !== xn && O.minFilter !== Dt ? Math.log2(Math.max(V.width, V.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? V.mipmaps.length : 1;
  }
  function T(O) {
    const V = O.target;
    V.removeEventListener("dispose", T), E(V), V.isVideoTexture && d.delete(V);
  }
  function P(O) {
    const V = O.target;
    V.removeEventListener("dispose", P), S(V);
  }
  function E(O) {
    const V = i.get(O);
    if (V.__webglInit === void 0) return;
    const H = O.source, X = p.get(H);
    if (X) {
      const ue = X[V.__cacheKey];
      ue.usedTimes--, ue.usedTimes === 0 && b(O), Object.keys(X).length === 0 && p.delete(H);
    }
    i.remove(O);
  }
  function b(O) {
    const V = i.get(O);
    s.deleteTexture(V.__webglTexture);
    const H = O.source, X = p.get(H);
    delete X[V.__cacheKey], r.memory.textures--;
  }
  function S(O) {
    const V = i.get(O);
    if (O.depthTexture && (O.depthTexture.dispose(), i.remove(O.depthTexture)), O.isWebGLCubeRenderTarget)
      for (let X = 0; X < 6; X++) {
        if (Array.isArray(V.__webglFramebuffer[X]))
          for (let ue = 0; ue < V.__webglFramebuffer[X].length; ue++) s.deleteFramebuffer(V.__webglFramebuffer[X][ue]);
        else
          s.deleteFramebuffer(V.__webglFramebuffer[X]);
        V.__webglDepthbuffer && s.deleteRenderbuffer(V.__webglDepthbuffer[X]);
      }
    else {
      if (Array.isArray(V.__webglFramebuffer))
        for (let X = 0; X < V.__webglFramebuffer.length; X++) s.deleteFramebuffer(V.__webglFramebuffer[X]);
      else
        s.deleteFramebuffer(V.__webglFramebuffer);
      if (V.__webglDepthbuffer && s.deleteRenderbuffer(V.__webglDepthbuffer), V.__webglMultisampledFramebuffer && s.deleteFramebuffer(V.__webglMultisampledFramebuffer), V.__webglColorRenderbuffer)
        for (let X = 0; X < V.__webglColorRenderbuffer.length; X++)
          V.__webglColorRenderbuffer[X] && s.deleteRenderbuffer(V.__webglColorRenderbuffer[X]);
      V.__webglDepthRenderbuffer && s.deleteRenderbuffer(V.__webglDepthRenderbuffer);
    }
    const H = O.textures;
    for (let X = 0, ue = H.length; X < ue; X++) {
      const me = i.get(H[X]);
      me.__webglTexture && (s.deleteTexture(me.__webglTexture), r.memory.textures--), i.remove(H[X]);
    }
    i.remove(O);
  }
  let A = 0;
  function R() {
    A = 0;
  }
  function k() {
    const O = A;
    return O >= o.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + o.maxTextures), A += 1, O;
  }
  function U(O) {
    const V = [];
    return V.push(O.wrapS), V.push(O.wrapT), V.push(O.wrapR || 0), V.push(O.magFilter), V.push(O.minFilter), V.push(O.anisotropy), V.push(O.internalFormat), V.push(O.format), V.push(O.type), V.push(O.generateMipmaps), V.push(O.premultiplyAlpha), V.push(O.flipY), V.push(O.unpackAlignment), V.push(O.colorSpace), V.join();
  }
  function I(O, V) {
    const H = i.get(O);
    if (O.isVideoTexture && z(O), O.isRenderTargetTexture === !1 && O.version > 0 && H.__version !== O.version) {
      const X = O.image;
      if (X === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (X.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ce(H, O, V);
        return;
      }
    }
    n.bindTexture(s.TEXTURE_2D, H.__webglTexture, s.TEXTURE0 + V);
  }
  function W(O, V) {
    const H = i.get(O);
    if (O.version > 0 && H.__version !== O.version) {
      ce(H, O, V);
      return;
    }
    n.bindTexture(s.TEXTURE_2D_ARRAY, H.__webglTexture, s.TEXTURE0 + V);
  }
  function fe(O, V) {
    const H = i.get(O);
    if (O.version > 0 && H.__version !== O.version) {
      ce(H, O, V);
      return;
    }
    n.bindTexture(s.TEXTURE_3D, H.__webglTexture, s.TEXTURE0 + V);
  }
  function q(O, V) {
    const H = i.get(O);
    if (O.version > 0 && H.__version !== O.version) {
      ae(H, O, V);
      return;
    }
    n.bindTexture(s.TEXTURE_CUBE_MAP, H.__webglTexture, s.TEXTURE0 + V);
  }
  const G = {
    [Ur]: s.REPEAT,
    [pi]: s.CLAMP_TO_EDGE,
    [md]: s.MIRRORED_REPEAT
  }, Q = {
    [xn]: s.NEAREST,
    [$7]: s.NEAREST_MIPMAP_NEAREST,
    [hl]: s.NEAREST_MIPMAP_LINEAR,
    [Dt]: s.LINEAR,
    [ju]: s.LINEAR_MIPMAP_NEAREST,
    [ao]: s.LINEAR_MIPMAP_LINEAR
  }, K = {
    [X7]: s.NEVER,
    [Q7]: s.ALWAYS,
    [Y7]: s.LESS,
    [mm]: s.LEQUAL,
    [q7]: s.EQUAL,
    [J7]: s.GEQUAL,
    [Z7]: s.GREATER,
    [K7]: s.NOTEQUAL
  };
  function Y(O, V) {
    if (V.type === Vn && e.has("OES_texture_float_linear") === !1 && (V.magFilter === Dt || V.magFilter === ju || V.magFilter === hl || V.magFilter === ao || V.minFilter === Dt || V.minFilter === ju || V.minFilter === hl || V.minFilter === ao) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(O, s.TEXTURE_WRAP_S, G[V.wrapS]), s.texParameteri(O, s.TEXTURE_WRAP_T, G[V.wrapT]), (O === s.TEXTURE_3D || O === s.TEXTURE_2D_ARRAY) && s.texParameteri(O, s.TEXTURE_WRAP_R, G[V.wrapR]), s.texParameteri(O, s.TEXTURE_MAG_FILTER, Q[V.magFilter]), s.texParameteri(O, s.TEXTURE_MIN_FILTER, Q[V.minFilter]), V.compareFunction && (s.texParameteri(O, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(O, s.TEXTURE_COMPARE_FUNC, K[V.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (V.magFilter === xn || V.minFilter !== hl && V.minFilter !== ao || V.type === Vn && e.has("OES_texture_float_linear") === !1) return;
      if (V.anisotropy > 1 || i.get(V).__currentAnisotropy) {
        const H = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(O, H.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(V.anisotropy, o.getMaxAnisotropy())), i.get(V).__currentAnisotropy = V.anisotropy;
      }
    }
  }
  function ee(O, V) {
    let H = !1;
    O.__webglInit === void 0 && (O.__webglInit = !0, V.addEventListener("dispose", T));
    const X = V.source;
    let ue = p.get(X);
    ue === void 0 && (ue = {}, p.set(X, ue));
    const me = U(V);
    if (me !== O.__cacheKey) {
      ue[me] === void 0 && (ue[me] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, r.memory.textures++, H = !0), ue[me].usedTimes++;
      const _e = ue[O.__cacheKey];
      _e !== void 0 && (ue[O.__cacheKey].usedTimes--, _e.usedTimes === 0 && b(V)), O.__cacheKey = me, O.__webglTexture = ue[me].texture;
    }
    return H;
  }
  function ce(O, V, H) {
    let X = s.TEXTURE_2D;
    (V.isDataArrayTexture || V.isCompressedArrayTexture) && (X = s.TEXTURE_2D_ARRAY), V.isData3DTexture && (X = s.TEXTURE_3D);
    const ue = ee(O, V), me = V.source;
    n.bindTexture(X, O.__webglTexture, s.TEXTURE0 + H);
    const _e = i.get(me);
    if (me.version !== _e.__version || ue === !0) {
      n.activeTexture(s.TEXTURE0 + H);
      const we = Nt.getPrimaries(Nt.workingColorSpace), Ae = V.colorSpace === A0 ? null : Nt.getPrimaries(V.colorSpace), Ve = V.colorSpace === A0 || we === Ae ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, V.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, V.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, V.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ve);
      let Fe = y(V.image, !1, o.maxTextureSize);
      Fe = $(V, Fe);
      const $e = a.convert(V.format, V.colorSpace), Ze = a.convert(V.type);
      let je = M(V.internalFormat, $e, Ze, V.colorSpace, V.isVideoTexture);
      Y(X, V);
      let Ue;
      const rt = V.mipmaps, Qe = V.isVideoTexture !== !0, yt = _e.__version === void 0 || ue === !0, Ce = me.dataReady, Be = C(V, Fe);
      if (V.isDepthTexture)
        je = _(V.format === go, V.type), yt && (Qe ? n.texStorage2D(s.TEXTURE_2D, 1, je, Fe.width, Fe.height) : n.texImage2D(s.TEXTURE_2D, 0, je, Fe.width, Fe.height, 0, $e, Ze, null));
      else if (V.isDataTexture)
        if (rt.length > 0) {
          Qe && yt && n.texStorage2D(s.TEXTURE_2D, Be, je, rt[0].width, rt[0].height);
          for (let ke = 0, Ge = rt.length; ke < Ge; ke++)
            Ue = rt[ke], Qe ? Ce && n.texSubImage2D(s.TEXTURE_2D, ke, 0, 0, Ue.width, Ue.height, $e, Ze, Ue.data) : n.texImage2D(s.TEXTURE_2D, ke, je, Ue.width, Ue.height, 0, $e, Ze, Ue.data);
          V.generateMipmaps = !1;
        } else
          Qe ? (yt && n.texStorage2D(s.TEXTURE_2D, Be, je, Fe.width, Fe.height), Ce && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Fe.width, Fe.height, $e, Ze, Fe.data)) : n.texImage2D(s.TEXTURE_2D, 0, je, Fe.width, Fe.height, 0, $e, Ze, Fe.data);
      else if (V.isCompressedTexture)
        if (V.isCompressedArrayTexture) {
          Qe && yt && n.texStorage3D(s.TEXTURE_2D_ARRAY, Be, je, rt[0].width, rt[0].height, Fe.depth);
          for (let ke = 0, Ge = rt.length; ke < Ge; ke++)
            if (Ue = rt[ke], V.format !== Sn)
              if ($e !== null)
                if (Qe) {
                  if (Ce)
                    if (V.layerUpdates.size > 0) {
                      const Ye = i2(Ue.width, Ue.height, V.format, V.type);
                      for (const We of V.layerUpdates) {
                        const ht = Ue.data.subarray(
                          We * Ye / Ue.data.BYTES_PER_ELEMENT,
                          (We + 1) * Ye / Ue.data.BYTES_PER_ELEMENT
                        );
                        n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ke, 0, 0, We, Ue.width, Ue.height, 1, $e, ht);
                      }
                      V.clearLayerUpdates();
                    } else
                      n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, ke, 0, 0, 0, Ue.width, Ue.height, Fe.depth, $e, Ue.data);
                } else
                  n.compressedTexImage3D(s.TEXTURE_2D_ARRAY, ke, je, Ue.width, Ue.height, Fe.depth, 0, Ue.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Qe ? Ce && n.texSubImage3D(s.TEXTURE_2D_ARRAY, ke, 0, 0, 0, Ue.width, Ue.height, Fe.depth, $e, Ze, Ue.data) : n.texImage3D(s.TEXTURE_2D_ARRAY, ke, je, Ue.width, Ue.height, Fe.depth, 0, $e, Ze, Ue.data);
        } else {
          Qe && yt && n.texStorage2D(s.TEXTURE_2D, Be, je, rt[0].width, rt[0].height);
          for (let ke = 0, Ge = rt.length; ke < Ge; ke++)
            Ue = rt[ke], V.format !== Sn ? $e !== null ? Qe ? Ce && n.compressedTexSubImage2D(s.TEXTURE_2D, ke, 0, 0, Ue.width, Ue.height, $e, Ue.data) : n.compressedTexImage2D(s.TEXTURE_2D, ke, je, Ue.width, Ue.height, 0, Ue.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Qe ? Ce && n.texSubImage2D(s.TEXTURE_2D, ke, 0, 0, Ue.width, Ue.height, $e, Ze, Ue.data) : n.texImage2D(s.TEXTURE_2D, ke, je, Ue.width, Ue.height, 0, $e, Ze, Ue.data);
        }
      else if (V.isDataArrayTexture)
        if (Qe) {
          if (yt && n.texStorage3D(s.TEXTURE_2D_ARRAY, Be, je, Fe.width, Fe.height, Fe.depth), Ce)
            if (V.layerUpdates.size > 0) {
              const ke = i2(Fe.width, Fe.height, V.format, V.type);
              for (const Ge of V.layerUpdates) {
                const Ye = Fe.data.subarray(
                  Ge * ke / Fe.data.BYTES_PER_ELEMENT,
                  (Ge + 1) * ke / Fe.data.BYTES_PER_ELEMENT
                );
                n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, Ge, Fe.width, Fe.height, 1, $e, Ze, Ye);
              }
              V.clearLayerUpdates();
            } else
              n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Fe.width, Fe.height, Fe.depth, $e, Ze, Fe.data);
        } else
          n.texImage3D(s.TEXTURE_2D_ARRAY, 0, je, Fe.width, Fe.height, Fe.depth, 0, $e, Ze, Fe.data);
      else if (V.isData3DTexture)
        Qe ? (yt && n.texStorage3D(s.TEXTURE_3D, Be, je, Fe.width, Fe.height, Fe.depth), Ce && n.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, Fe.width, Fe.height, Fe.depth, $e, Ze, Fe.data)) : n.texImage3D(s.TEXTURE_3D, 0, je, Fe.width, Fe.height, Fe.depth, 0, $e, Ze, Fe.data);
      else if (V.isFramebufferTexture) {
        if (yt)
          if (Qe)
            n.texStorage2D(s.TEXTURE_2D, Be, je, Fe.width, Fe.height);
          else {
            let ke = Fe.width, Ge = Fe.height;
            for (let Ye = 0; Ye < Be; Ye++)
              n.texImage2D(s.TEXTURE_2D, Ye, je, ke, Ge, 0, $e, Ze, null), ke >>= 1, Ge >>= 1;
          }
      } else if (rt.length > 0) {
        if (Qe && yt) {
          const ke = oe(rt[0]);
          n.texStorage2D(s.TEXTURE_2D, Be, je, ke.width, ke.height);
        }
        for (let ke = 0, Ge = rt.length; ke < Ge; ke++)
          Ue = rt[ke], Qe ? Ce && n.texSubImage2D(s.TEXTURE_2D, ke, 0, 0, $e, Ze, Ue) : n.texImage2D(s.TEXTURE_2D, ke, je, $e, Ze, Ue);
        V.generateMipmaps = !1;
      } else if (Qe) {
        if (yt) {
          const ke = oe(Fe);
          n.texStorage2D(s.TEXTURE_2D, Be, je, ke.width, ke.height);
        }
        Ce && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, $e, Ze, Fe);
      } else
        n.texImage2D(s.TEXTURE_2D, 0, je, $e, Ze, Fe);
      g(V) && x(X), _e.__version = me.version, V.onUpdate && V.onUpdate(V);
    }
    O.__version = V.version;
  }
  function ae(O, V, H) {
    if (V.image.length !== 6) return;
    const X = ee(O, V), ue = V.source;
    n.bindTexture(s.TEXTURE_CUBE_MAP, O.__webglTexture, s.TEXTURE0 + H);
    const me = i.get(ue);
    if (ue.version !== me.__version || X === !0) {
      n.activeTexture(s.TEXTURE0 + H);
      const _e = Nt.getPrimaries(Nt.workingColorSpace), we = V.colorSpace === A0 ? null : Nt.getPrimaries(V.colorSpace), Ae = V.colorSpace === A0 || _e === we ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, V.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, V.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, V.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
      const Ve = V.isCompressedTexture || V.image[0].isCompressedTexture, Fe = V.image[0] && V.image[0].isDataTexture, $e = [];
      for (let Ge = 0; Ge < 6; Ge++)
        !Ve && !Fe ? $e[Ge] = y(V.image[Ge], !0, o.maxCubemapSize) : $e[Ge] = Fe ? V.image[Ge].image : V.image[Ge], $e[Ge] = $(V, $e[Ge]);
      const Ze = $e[0], je = a.convert(V.format, V.colorSpace), Ue = a.convert(V.type), rt = M(V.internalFormat, je, Ue, V.colorSpace), Qe = V.isVideoTexture !== !0, yt = me.__version === void 0 || X === !0, Ce = ue.dataReady;
      let Be = C(V, Ze);
      Y(s.TEXTURE_CUBE_MAP, V);
      let ke;
      if (Ve) {
        Qe && yt && n.texStorage2D(s.TEXTURE_CUBE_MAP, Be, rt, Ze.width, Ze.height);
        for (let Ge = 0; Ge < 6; Ge++) {
          ke = $e[Ge].mipmaps;
          for (let Ye = 0; Ye < ke.length; Ye++) {
            const We = ke[Ye];
            V.format !== Sn ? je !== null ? Qe ? Ce && n.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye, 0, 0, We.width, We.height, je, We.data) : n.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye, rt, We.width, We.height, 0, We.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Qe ? Ce && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye, 0, 0, We.width, We.height, je, Ue, We.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye, rt, We.width, We.height, 0, je, Ue, We.data);
          }
        }
      } else {
        if (ke = V.mipmaps, Qe && yt) {
          ke.length > 0 && Be++;
          const Ge = oe($e[0]);
          n.texStorage2D(s.TEXTURE_CUBE_MAP, Be, rt, Ge.width, Ge.height);
        }
        for (let Ge = 0; Ge < 6; Ge++)
          if (Fe) {
            Qe ? Ce && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, 0, 0, $e[Ge].width, $e[Ge].height, je, Ue, $e[Ge].data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, rt, $e[Ge].width, $e[Ge].height, 0, je, Ue, $e[Ge].data);
            for (let Ye = 0; Ye < ke.length; Ye++) {
              const ht = ke[Ye].image[Ge].image;
              Qe ? Ce && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye + 1, 0, 0, ht.width, ht.height, je, Ue, ht.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye + 1, rt, ht.width, ht.height, 0, je, Ue, ht.data);
            }
          } else {
            Qe ? Ce && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, 0, 0, je, Ue, $e[Ge]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, 0, rt, je, Ue, $e[Ge]);
            for (let Ye = 0; Ye < ke.length; Ye++) {
              const We = ke[Ye];
              Qe ? Ce && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye + 1, 0, 0, je, Ue, We.image[Ge]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Ge, Ye + 1, rt, je, Ue, We.image[Ge]);
            }
          }
      }
      g(V) && x(s.TEXTURE_CUBE_MAP), me.__version = ue.version, V.onUpdate && V.onUpdate(V);
    }
    O.__version = V.version;
  }
  function de(O, V, H, X, ue, me) {
    const _e = a.convert(H.format, H.colorSpace), we = a.convert(H.type), Ae = M(H.internalFormat, _e, we, H.colorSpace), Ve = i.get(V), Fe = i.get(H);
    if (Fe.__renderTarget = V, !Ve.__hasExternalTextures) {
      const $e = Math.max(1, V.width >> me), Ze = Math.max(1, V.height >> me);
      ue === s.TEXTURE_3D || ue === s.TEXTURE_2D_ARRAY ? n.texImage3D(ue, me, Ae, $e, Ze, V.depth, 0, _e, we, null) : n.texImage2D(ue, me, Ae, $e, Ze, 0, _e, we, null);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, O), Z(V) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, X, ue, Fe.__webglTexture, 0, j(V)) : (ue === s.TEXTURE_2D || ue >= s.TEXTURE_CUBE_MAP_POSITIVE_X && ue <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, X, ue, Fe.__webglTexture, me), n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function ie(O, V, H) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, O), V.depthBuffer) {
      const X = V.depthTexture, ue = X && X.isDepthTexture ? X.type : null, me = _(V.stencilBuffer, ue), _e = V.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, we = j(V);
      Z(V) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, we, me, V.width, V.height) : H ? s.renderbufferStorageMultisample(s.RENDERBUFFER, we, me, V.width, V.height) : s.renderbufferStorage(s.RENDERBUFFER, me, V.width, V.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, _e, s.RENDERBUFFER, O);
    } else {
      const X = V.textures;
      for (let ue = 0; ue < X.length; ue++) {
        const me = X[ue], _e = a.convert(me.format, me.colorSpace), we = a.convert(me.type), Ae = M(me.internalFormat, _e, we, me.colorSpace), Ve = j(V);
        H && Z(V) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Ve, Ae, V.width, V.height) : Z(V) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Ve, Ae, V.width, V.height) : s.renderbufferStorage(s.RENDERBUFFER, Ae, V.width, V.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function he(O, V) {
    if (V && V.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (n.bindFramebuffer(s.FRAMEBUFFER, O), !(V.depthTexture && V.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const X = i.get(V.depthTexture);
    X.__renderTarget = V, (!X.__webglTexture || V.depthTexture.image.width !== V.width || V.depthTexture.image.height !== V.height) && (V.depthTexture.image.width = V.width, V.depthTexture.image.height = V.height, V.depthTexture.needsUpdate = !0), I(V.depthTexture, 0);
    const ue = X.__webglTexture, me = j(V);
    if (V.depthTexture.format === ho)
      Z(V) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ue, 0, me) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, ue, 0);
    else if (V.depthTexture.format === go)
      Z(V) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ue, 0, me) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, ue, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function ne(O) {
    const V = i.get(O), H = O.isWebGLCubeRenderTarget === !0;
    if (V.__boundDepthTexture !== O.depthTexture) {
      const X = O.depthTexture;
      if (V.__depthDisposeCallback && V.__depthDisposeCallback(), X) {
        const ue = () => {
          delete V.__boundDepthTexture, delete V.__depthDisposeCallback, X.removeEventListener("dispose", ue);
        };
        X.addEventListener("dispose", ue), V.__depthDisposeCallback = ue;
      }
      V.__boundDepthTexture = X;
    }
    if (O.depthTexture && !V.__autoAllocateDepthBuffer) {
      if (H) throw new Error("target.depthTexture not supported in Cube render targets");
      he(V.__webglFramebuffer, O);
    } else if (H) {
      V.__webglDepthbuffer = [];
      for (let X = 0; X < 6; X++)
        if (n.bindFramebuffer(s.FRAMEBUFFER, V.__webglFramebuffer[X]), V.__webglDepthbuffer[X] === void 0)
          V.__webglDepthbuffer[X] = s.createRenderbuffer(), ie(V.__webglDepthbuffer[X], O, !1);
        else {
          const ue = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, me = V.__webglDepthbuffer[X];
          s.bindRenderbuffer(s.RENDERBUFFER, me), s.framebufferRenderbuffer(s.FRAMEBUFFER, ue, s.RENDERBUFFER, me);
        }
    } else if (n.bindFramebuffer(s.FRAMEBUFFER, V.__webglFramebuffer), V.__webglDepthbuffer === void 0)
      V.__webglDepthbuffer = s.createRenderbuffer(), ie(V.__webglDepthbuffer, O, !1);
    else {
      const X = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, ue = V.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, ue), s.framebufferRenderbuffer(s.FRAMEBUFFER, X, s.RENDERBUFFER, ue);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function N(O, V, H) {
    const X = i.get(O);
    V !== void 0 && de(X.__webglFramebuffer, O, O.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), H !== void 0 && ne(O);
  }
  function te(O) {
    const V = O.texture, H = i.get(O), X = i.get(V);
    O.addEventListener("dispose", P);
    const ue = O.textures, me = O.isWebGLCubeRenderTarget === !0, _e = ue.length > 1;
    if (_e || (X.__webglTexture === void 0 && (X.__webglTexture = s.createTexture()), X.__version = V.version, r.memory.textures++), me) {
      H.__webglFramebuffer = [];
      for (let we = 0; we < 6; we++)
        if (V.mipmaps && V.mipmaps.length > 0) {
          H.__webglFramebuffer[we] = [];
          for (let Ae = 0; Ae < V.mipmaps.length; Ae++)
            H.__webglFramebuffer[we][Ae] = s.createFramebuffer();
        } else
          H.__webglFramebuffer[we] = s.createFramebuffer();
    } else {
      if (V.mipmaps && V.mipmaps.length > 0) {
        H.__webglFramebuffer = [];
        for (let we = 0; we < V.mipmaps.length; we++)
          H.__webglFramebuffer[we] = s.createFramebuffer();
      } else
        H.__webglFramebuffer = s.createFramebuffer();
      if (_e)
        for (let we = 0, Ae = ue.length; we < Ae; we++) {
          const Ve = i.get(ue[we]);
          Ve.__webglTexture === void 0 && (Ve.__webglTexture = s.createTexture(), r.memory.textures++);
        }
      if (O.samples > 0 && Z(O) === !1) {
        H.__webglMultisampledFramebuffer = s.createFramebuffer(), H.__webglColorRenderbuffer = [], n.bindFramebuffer(s.FRAMEBUFFER, H.__webglMultisampledFramebuffer);
        for (let we = 0; we < ue.length; we++) {
          const Ae = ue[we];
          H.__webglColorRenderbuffer[we] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, H.__webglColorRenderbuffer[we]);
          const Ve = a.convert(Ae.format, Ae.colorSpace), Fe = a.convert(Ae.type), $e = M(Ae.internalFormat, Ve, Fe, Ae.colorSpace, O.isXRRenderTarget === !0), Ze = j(O);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, Ze, $e, O.width, O.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + we, s.RENDERBUFFER, H.__webglColorRenderbuffer[we]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), O.depthBuffer && (H.__webglDepthRenderbuffer = s.createRenderbuffer(), ie(H.__webglDepthRenderbuffer, O, !0)), n.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (me) {
      n.bindTexture(s.TEXTURE_CUBE_MAP, X.__webglTexture), Y(s.TEXTURE_CUBE_MAP, V);
      for (let we = 0; we < 6; we++)
        if (V.mipmaps && V.mipmaps.length > 0)
          for (let Ae = 0; Ae < V.mipmaps.length; Ae++)
            de(H.__webglFramebuffer[we][Ae], O, V, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + we, Ae);
        else
          de(H.__webglFramebuffer[we], O, V, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + we, 0);
      g(V) && x(s.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (_e) {
      for (let we = 0, Ae = ue.length; we < Ae; we++) {
        const Ve = ue[we], Fe = i.get(Ve);
        n.bindTexture(s.TEXTURE_2D, Fe.__webglTexture), Y(s.TEXTURE_2D, Ve), de(H.__webglFramebuffer, O, Ve, s.COLOR_ATTACHMENT0 + we, s.TEXTURE_2D, 0), g(Ve) && x(s.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let we = s.TEXTURE_2D;
      if ((O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (we = O.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), n.bindTexture(we, X.__webglTexture), Y(we, V), V.mipmaps && V.mipmaps.length > 0)
        for (let Ae = 0; Ae < V.mipmaps.length; Ae++)
          de(H.__webglFramebuffer[Ae], O, V, s.COLOR_ATTACHMENT0, we, Ae);
      else
        de(H.__webglFramebuffer, O, V, s.COLOR_ATTACHMENT0, we, 0);
      g(V) && x(we), n.unbindTexture();
    }
    O.depthBuffer && ne(O);
  }
  function F(O) {
    const V = O.textures;
    for (let H = 0, X = V.length; H < X; H++) {
      const ue = V[H];
      if (g(ue)) {
        const me = w(O), _e = i.get(ue).__webglTexture;
        n.bindTexture(me, _e), x(me), n.unbindTexture();
      }
    }
  }
  const B = [], L = [];
  function D(O) {
    if (O.samples > 0) {
      if (Z(O) === !1) {
        const V = O.textures, H = O.width, X = O.height;
        let ue = s.COLOR_BUFFER_BIT;
        const me = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, _e = i.get(O), we = V.length > 1;
        if (we)
          for (let Ae = 0; Ae < V.length; Ae++)
            n.bindFramebuffer(s.FRAMEBUFFER, _e.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, null), n.bindFramebuffer(s.FRAMEBUFFER, _e.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, null, 0);
        n.bindFramebuffer(s.READ_FRAMEBUFFER, _e.__webglMultisampledFramebuffer), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, _e.__webglFramebuffer);
        for (let Ae = 0; Ae < V.length; Ae++) {
          if (O.resolveDepthBuffer && (O.depthBuffer && (ue |= s.DEPTH_BUFFER_BIT), O.stencilBuffer && O.resolveStencilBuffer && (ue |= s.STENCIL_BUFFER_BIT)), we) {
            s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, _e.__webglColorRenderbuffer[Ae]);
            const Ve = i.get(V[Ae]).__webglTexture;
            s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Ve, 0);
          }
          s.blitFramebuffer(0, 0, H, X, 0, 0, H, X, ue, s.NEAREST), c === !0 && (B.length = 0, L.length = 0, B.push(s.COLOR_ATTACHMENT0 + Ae), O.depthBuffer && O.resolveDepthBuffer === !1 && (B.push(me), L.push(me), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, L)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, B));
        }
        if (n.bindFramebuffer(s.READ_FRAMEBUFFER, null), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), we)
          for (let Ae = 0; Ae < V.length; Ae++) {
            n.bindFramebuffer(s.FRAMEBUFFER, _e.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, _e.__webglColorRenderbuffer[Ae]);
            const Ve = i.get(V[Ae]).__webglTexture;
            n.bindFramebuffer(s.FRAMEBUFFER, _e.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, Ve, 0);
          }
        n.bindFramebuffer(s.DRAW_FRAMEBUFFER, _e.__webglMultisampledFramebuffer);
      } else if (O.depthBuffer && O.resolveDepthBuffer === !1 && c) {
        const V = O.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [V]);
      }
    }
  }
  function j(O) {
    return Math.min(o.maxSamples, O.samples);
  }
  function Z(O) {
    const V = i.get(O);
    return O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && V.__useRenderToTexture !== !1;
  }
  function z(O) {
    const V = r.render.frame;
    d.get(O) !== V && (d.set(O, V), O.update());
  }
  function $(O, V) {
    const H = O.colorSpace, X = O.format, ue = O.type;
    return O.isCompressedTexture === !0 || O.isVideoTexture === !0 || H !== Sa && H !== A0 && (Nt.getTransfer(H) === Qt ? (X !== Sn || ue !== ps) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", H)), V;
  }
  function oe(O) {
    return typeof HTMLImageElement < "u" && O instanceof HTMLImageElement ? (u.width = O.naturalWidth || O.width, u.height = O.naturalHeight || O.height) : typeof VideoFrame < "u" && O instanceof VideoFrame ? (u.width = O.displayWidth, u.height = O.displayHeight) : (u.width = O.width, u.height = O.height), u;
  }
  this.allocateTextureUnit = k, this.resetTextureUnits = R, this.setTexture2D = I, this.setTexture2DArray = W, this.setTexture3D = fe, this.setTextureCube = q, this.rebindTextures = N, this.setupRenderTarget = te, this.updateRenderTargetMipmap = F, this.updateMultisampleRenderTarget = D, this.setupDepthRenderbuffer = ne, this.setupFrameBufferTexture = de, this.useMultisampledRTT = Z;
}
function y_(s, e) {
  function n(i, o = A0) {
    let a;
    const r = Nt.getTransfer(o);
    if (i === ps) return s.UNSIGNED_BYTE;
    if (i === _h) return s.UNSIGNED_SHORT_4_4_4_4;
    if (i === wh) return s.UNSIGNED_SHORT_5_5_5_1;
    if (i === lm) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (i === am) return s.BYTE;
    if (i === rm) return s.SHORT;
    if (i === zr) return s.UNSIGNED_SHORT;
    if (i === bh) return s.INT;
    if (i === mo) return s.UNSIGNED_INT;
    if (i === Vn) return s.FLOAT;
    if (i === gi) return s.HALF_FLOAT;
    if (i === cm) return s.ALPHA;
    if (i === um) return s.RGB;
    if (i === Sn) return s.RGBA;
    if (i === dm) return s.LUMINANCE;
    if (i === hm) return s.LUMINANCE_ALPHA;
    if (i === ho) return s.DEPTH_COMPONENT;
    if (i === go) return s.DEPTH_STENCIL;
    if (i === Br) return s.RED;
    if (i === Mh) return s.RED_INTEGER;
    if (i === fm) return s.RG;
    if (i === Sh) return s.RG_INTEGER;
    if (i === Ch) return s.RGBA_INTEGER;
    if (i === hc || i === fc || i === pc || i === mc)
      if (r === Qt)
        if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
          if (i === hc) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === fc) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === pc) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === mc) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
        if (i === hc) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === fc) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === pc) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === mc) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (i === vd || i === gd || i === yd || i === xd)
      if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
        if (i === vd) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === gd) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === yd) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === xd) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (i === bd || i === _d || i === wd)
      if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
        if (i === bd || i === _d) return r === Qt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (i === wd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (i === Md || i === Sd || i === Cd || i === Td || i === Ed || i === Ad || i === Pd || i === kd || i === Dd || i === Id || i === Rd || i === Ld || i === Fd || i === Od)
      if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
        if (i === Md) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === Sd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === Cd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === Td) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === Ed) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === Ad) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === Pd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === kd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === Dd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Id) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === Rd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Ld) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === Fd) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === Od) return r === Qt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (i === vc || i === Ud || i === zd)
      if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
        if (i === vc) return r === Qt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === Ud) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === zd) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (i === pm || i === Bd || i === Nd || i === Vd)
      if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
        if (i === vc) return a.COMPRESSED_RED_RGTC1_EXT;
        if (i === Bd) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === Nd) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Vd) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return i === vo ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
  }
  return { convert: n };
}
class x_ extends Ti {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Bi extends vn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const b_ = { type: "move" };
class x1 {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Bi(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Bi(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new pe(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new pe()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Bi(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new pe(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new pe()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n)
        for (const i of e.hand.values())
          this._getHandJoint(n, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, n, i) {
    let o = null, a = null, r = null;
    const l = this._targetRay, c = this._grip, u = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        r = !0;
        for (const y of e.hand.values()) {
          const g = n.getJointPose(y, i), x = this._getHandJoint(u, y);
          g !== null && (x.matrix.fromArray(g.transform.matrix), x.matrix.decompose(x.position, x.rotation, x.scale), x.matrixWorldNeedsUpdate = !0, x.jointRadius = g.radius), x.visible = g !== null;
        }
        const d = u.joints["index-finger-tip"], h = u.joints["thumb-tip"], p = d.position.distanceTo(h.position), f = 0.02, m = 5e-3;
        u.inputState.pinching && p > f + m ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !u.inputState.pinching && p <= f - m && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (a = n.getPose(e.gripSpace, i), a !== null && (c.matrix.fromArray(a.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, a.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(a.linearVelocity)) : c.hasLinearVelocity = !1, a.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(a.angularVelocity)) : c.hasAngularVelocity = !1));
      l !== null && (o = n.getPose(e.targetRaySpace, i), o === null && a !== null && (o = a), o !== null && (l.matrix.fromArray(o.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(o.linearVelocity)) : l.hasLinearVelocity = !1, o.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(o.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(b_)));
    }
    return l !== null && (l.visible = o !== null), c !== null && (c.visible = a !== null), u !== null && (u.visible = r !== null), this;
  }
  // private method
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const i = new Bi();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[n.jointName] = i, e.add(i);
    }
    return e.joints[n.jointName];
  }
}
const __ = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, w_ = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class M_ {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, n, i) {
    if (this.texture === null) {
      const o = new An(), a = e.properties.get(o);
      a.__webglTexture = n.texture, (n.depthNear != i.depthNear || n.depthFar != i.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = o;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const n = e.cameras[0].viewport, i = new dn({
        vertexShader: __,
        fragmentShader: w_,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: n.z },
          depthHeight: { value: n.w }
        }
      });
      this.mesh = new Ke(new nn(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class S_ extends xo {
  constructor(e, n) {
    super();
    const i = this;
    let o = null, a = 1, r = null, l = "local-floor", c = 1, u = null, d = null, h = null, p = null, f = null, m = null;
    const y = new M_(), g = n.getContextAttributes();
    let x = null, w = null;
    const M = [], _ = [], C = new qe();
    let T = null;
    const P = new Ti();
    P.viewport = new Kt();
    const E = new Ti();
    E.viewport = new Kt();
    const b = [P, E], S = new x_();
    let A = null, R = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(ce) {
      let ae = M[ce];
      return ae === void 0 && (ae = new x1(), M[ce] = ae), ae.getTargetRaySpace();
    }, this.getControllerGrip = function(ce) {
      let ae = M[ce];
      return ae === void 0 && (ae = new x1(), M[ce] = ae), ae.getGripSpace();
    }, this.getHand = function(ce) {
      let ae = M[ce];
      return ae === void 0 && (ae = new x1(), M[ce] = ae), ae.getHandSpace();
    };
    function k(ce) {
      const ae = _.indexOf(ce.inputSource);
      if (ae === -1)
        return;
      const de = M[ae];
      de !== void 0 && (de.update(ce.inputSource, ce.frame, u || r), de.dispatchEvent({ type: ce.type, data: ce.inputSource }));
    }
    function U() {
      o.removeEventListener("select", k), o.removeEventListener("selectstart", k), o.removeEventListener("selectend", k), o.removeEventListener("squeeze", k), o.removeEventListener("squeezestart", k), o.removeEventListener("squeezeend", k), o.removeEventListener("end", U), o.removeEventListener("inputsourceschange", I);
      for (let ce = 0; ce < M.length; ce++) {
        const ae = _[ce];
        ae !== null && (_[ce] = null, M[ce].disconnect(ae));
      }
      A = null, R = null, y.reset(), e.setRenderTarget(x), f = null, p = null, h = null, o = null, w = null, ee.stop(), i.isPresenting = !1, e.setPixelRatio(T), e.setSize(C.width, C.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ce) {
      a = ce, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ce) {
      l = ce, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || r;
    }, this.setReferenceSpace = function(ce) {
      u = ce;
    }, this.getBaseLayer = function() {
      return p !== null ? p : f;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return o;
    }, this.setSession = async function(ce) {
      if (o = ce, o !== null) {
        if (x = e.getRenderTarget(), o.addEventListener("select", k), o.addEventListener("selectstart", k), o.addEventListener("selectend", k), o.addEventListener("squeeze", k), o.addEventListener("squeezestart", k), o.addEventListener("squeezeend", k), o.addEventListener("end", U), o.addEventListener("inputsourceschange", I), g.xrCompatible !== !0 && await n.makeXRCompatible(), T = e.getPixelRatio(), e.getSize(C), o.renderState.layers === void 0) {
          const ae = {
            antialias: g.antialias,
            alpha: !0,
            depth: g.depth,
            stencil: g.stencil,
            framebufferScaleFactor: a
          };
          f = new XRWebGLLayer(o, n, ae), o.updateRenderState({ baseLayer: f }), e.setPixelRatio(1), e.setSize(f.framebufferWidth, f.framebufferHeight, !1), w = new Xn(
            f.framebufferWidth,
            f.framebufferHeight,
            {
              format: Sn,
              type: ps,
              colorSpace: e.outputColorSpace,
              stencilBuffer: g.stencil
            }
          );
        } else {
          let ae = null, de = null, ie = null;
          g.depth && (ie = g.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, ae = g.stencil ? go : ho, de = g.stencil ? vo : mo);
          const he = {
            colorFormat: n.RGBA8,
            depthFormat: ie,
            scaleFactor: a
          };
          h = new XRWebGLBinding(o, n), p = h.createProjectionLayer(he), o.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, !1), w = new Xn(
            p.textureWidth,
            p.textureHeight,
            {
              format: Sn,
              type: ps,
              depthTexture: new hu(p.textureWidth, p.textureHeight, de, void 0, void 0, void 0, void 0, void 0, void 0, ae),
              stencilBuffer: g.stencil,
              colorSpace: e.outputColorSpace,
              samples: g.antialias ? 4 : 0,
              resolveDepthBuffer: p.ignoreDepthValues === !1
            }
          );
        }
        w.isXRRenderTarget = !0, this.setFoveation(c), u = null, r = await o.requestReferenceSpace(l), ee.setContext(o), ee.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (o !== null)
        return o.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return y.getDepthTexture();
    };
    function I(ce) {
      for (let ae = 0; ae < ce.removed.length; ae++) {
        const de = ce.removed[ae], ie = _.indexOf(de);
        ie >= 0 && (_[ie] = null, M[ie].disconnect(de));
      }
      for (let ae = 0; ae < ce.added.length; ae++) {
        const de = ce.added[ae];
        let ie = _.indexOf(de);
        if (ie === -1) {
          for (let ne = 0; ne < M.length; ne++)
            if (ne >= _.length) {
              _.push(de), ie = ne;
              break;
            } else if (_[ne] === null) {
              _[ne] = de, ie = ne;
              break;
            }
          if (ie === -1) break;
        }
        const he = M[ie];
        he && he.connect(de);
      }
    }
    const W = new pe(), fe = new pe();
    function q(ce, ae, de) {
      W.setFromMatrixPosition(ae.matrixWorld), fe.setFromMatrixPosition(de.matrixWorld);
      const ie = W.distanceTo(fe), he = ae.projectionMatrix.elements, ne = de.projectionMatrix.elements, N = he[14] / (he[10] - 1), te = he[14] / (he[10] + 1), F = (he[9] + 1) / he[5], B = (he[9] - 1) / he[5], L = (he[8] - 1) / he[0], D = (ne[8] + 1) / ne[0], j = N * L, Z = N * D, z = ie / (-L + D), $ = z * -L;
      if (ae.matrixWorld.decompose(ce.position, ce.quaternion, ce.scale), ce.translateX($), ce.translateZ(z), ce.matrixWorld.compose(ce.position, ce.quaternion, ce.scale), ce.matrixWorldInverse.copy(ce.matrixWorld).invert(), he[10] === -1)
        ce.projectionMatrix.copy(ae.projectionMatrix), ce.projectionMatrixInverse.copy(ae.projectionMatrixInverse);
      else {
        const oe = N + z, O = te + z, V = j - $, H = Z + (ie - $), X = F * te / O * oe, ue = B * te / O * oe;
        ce.projectionMatrix.makePerspective(V, H, X, ue, oe, O), ce.projectionMatrixInverse.copy(ce.projectionMatrix).invert();
      }
    }
    function G(ce, ae) {
      ae === null ? ce.matrixWorld.copy(ce.matrix) : ce.matrixWorld.multiplyMatrices(ae.matrixWorld, ce.matrix), ce.matrixWorldInverse.copy(ce.matrixWorld).invert();
    }
    this.updateCamera = function(ce) {
      if (o === null) return;
      let ae = ce.near, de = ce.far;
      y.texture !== null && (y.depthNear > 0 && (ae = y.depthNear), y.depthFar > 0 && (de = y.depthFar)), S.near = E.near = P.near = ae, S.far = E.far = P.far = de, (A !== S.near || R !== S.far) && (o.updateRenderState({
        depthNear: S.near,
        depthFar: S.far
      }), A = S.near, R = S.far), P.layers.mask = ce.layers.mask | 2, E.layers.mask = ce.layers.mask | 4, S.layers.mask = P.layers.mask | E.layers.mask;
      const ie = ce.parent, he = S.cameras;
      G(S, ie);
      for (let ne = 0; ne < he.length; ne++)
        G(he[ne], ie);
      he.length === 2 ? q(S, P, E) : S.projectionMatrix.copy(P.projectionMatrix), Q(ce, S, ie);
    };
    function Q(ce, ae, de) {
      de === null ? ce.matrix.copy(ae.matrixWorld) : (ce.matrix.copy(de.matrixWorld), ce.matrix.invert(), ce.matrix.multiply(ae.matrixWorld)), ce.matrix.decompose(ce.position, ce.quaternion, ce.scale), ce.updateMatrixWorld(!0), ce.projectionMatrix.copy(ae.projectionMatrix), ce.projectionMatrixInverse.copy(ae.projectionMatrixInverse), ce.isPerspectiveCamera && (ce.fov = va * 2 * Math.atan(1 / ce.projectionMatrix.elements[5]), ce.zoom = 1);
    }
    this.getCamera = function() {
      return S;
    }, this.getFoveation = function() {
      if (!(p === null && f === null))
        return c;
    }, this.setFoveation = function(ce) {
      c = ce, p !== null && (p.fixedFoveation = ce), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = ce);
    }, this.hasDepthSensing = function() {
      return y.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return y.getMesh(S);
    };
    let K = null;
    function Y(ce, ae) {
      if (d = ae.getViewerPose(u || r), m = ae, d !== null) {
        const de = d.views;
        f !== null && (e.setRenderTargetFramebuffer(w, f.framebuffer), e.setRenderTarget(w));
        let ie = !1;
        de.length !== S.cameras.length && (S.cameras.length = 0, ie = !0);
        for (let ne = 0; ne < de.length; ne++) {
          const N = de[ne];
          let te = null;
          if (f !== null)
            te = f.getViewport(N);
          else {
            const B = h.getViewSubImage(p, N);
            te = B.viewport, ne === 0 && (e.setRenderTargetTextures(
              w,
              B.colorTexture,
              p.ignoreDepthValues ? void 0 : B.depthStencilTexture
            ), e.setRenderTarget(w));
          }
          let F = b[ne];
          F === void 0 && (F = new Ti(), F.layers.enable(ne), F.viewport = new Kt(), b[ne] = F), F.matrix.fromArray(N.transform.matrix), F.matrix.decompose(F.position, F.quaternion, F.scale), F.projectionMatrix.fromArray(N.projectionMatrix), F.projectionMatrixInverse.copy(F.projectionMatrix).invert(), F.viewport.set(te.x, te.y, te.width, te.height), ne === 0 && (S.matrix.copy(F.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), ie === !0 && S.cameras.push(F);
        }
        const he = o.enabledFeatures;
        if (he && he.includes("depth-sensing")) {
          const ne = h.getDepthInformation(de[0]);
          ne && ne.isValid && ne.texture && y.init(e, ne, o.renderState);
        }
      }
      for (let de = 0; de < M.length; de++) {
        const ie = _[de], he = M[de];
        ie !== null && he !== void 0 && he.update(ie, ae, u || r);
      }
      K && K(ce, ae), ae.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: ae }), m = null;
    }
    const ee = new Cm();
    ee.setAnimationLoop(Y), this.setAnimationLoop = function(ce) {
      K = ce;
    }, this.dispose = function() {
    };
  }
}
const j0 = /* @__PURE__ */ new Hi(), C_ = /* @__PURE__ */ new jt();
function T_(s, e) {
  function n(g, x) {
    g.matrixAutoUpdate === !0 && g.updateMatrix(), x.value.copy(g.matrix);
  }
  function i(g, x) {
    x.color.getRGB(g.fogColor.value, wm(s)), x.isFog ? (g.fogNear.value = x.near, g.fogFar.value = x.far) : x.isFogExp2 && (g.fogDensity.value = x.density);
  }
  function o(g, x, w, M, _) {
    x.isMeshBasicMaterial || x.isMeshLambertMaterial ? a(g, x) : x.isMeshToonMaterial ? (a(g, x), h(g, x)) : x.isMeshPhongMaterial ? (a(g, x), d(g, x)) : x.isMeshStandardMaterial ? (a(g, x), p(g, x), x.isMeshPhysicalMaterial && f(g, x, _)) : x.isMeshMatcapMaterial ? (a(g, x), m(g, x)) : x.isMeshDepthMaterial ? a(g, x) : x.isMeshDistanceMaterial ? (a(g, x), y(g, x)) : x.isMeshNormalMaterial ? a(g, x) : x.isLineBasicMaterial ? (r(g, x), x.isLineDashedMaterial && l(g, x)) : x.isPointsMaterial ? c(g, x, w, M) : x.isSpriteMaterial ? u(g, x) : x.isShadowMaterial ? (g.color.value.copy(x.color), g.opacity.value = x.opacity) : x.isShaderMaterial && (x.uniformsNeedUpdate = !1);
  }
  function a(g, x) {
    g.opacity.value = x.opacity, x.color && g.diffuse.value.copy(x.color), x.emissive && g.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity), x.map && (g.map.value = x.map, n(x.map, g.mapTransform)), x.alphaMap && (g.alphaMap.value = x.alphaMap, n(x.alphaMap, g.alphaMapTransform)), x.bumpMap && (g.bumpMap.value = x.bumpMap, n(x.bumpMap, g.bumpMapTransform), g.bumpScale.value = x.bumpScale, x.side === vi && (g.bumpScale.value *= -1)), x.normalMap && (g.normalMap.value = x.normalMap, n(x.normalMap, g.normalMapTransform), g.normalScale.value.copy(x.normalScale), x.side === vi && g.normalScale.value.negate()), x.displacementMap && (g.displacementMap.value = x.displacementMap, n(x.displacementMap, g.displacementMapTransform), g.displacementScale.value = x.displacementScale, g.displacementBias.value = x.displacementBias), x.emissiveMap && (g.emissiveMap.value = x.emissiveMap, n(x.emissiveMap, g.emissiveMapTransform)), x.specularMap && (g.specularMap.value = x.specularMap, n(x.specularMap, g.specularMapTransform)), x.alphaTest > 0 && (g.alphaTest.value = x.alphaTest);
    const w = e.get(x), M = w.envMap, _ = w.envMapRotation;
    M && (g.envMap.value = M, j0.copy(_), j0.x *= -1, j0.y *= -1, j0.z *= -1, M.isCubeTexture && M.isRenderTargetTexture === !1 && (j0.y *= -1, j0.z *= -1), g.envMapRotation.value.setFromMatrix4(C_.makeRotationFromEuler(j0)), g.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, g.reflectivity.value = x.reflectivity, g.ior.value = x.ior, g.refractionRatio.value = x.refractionRatio), x.lightMap && (g.lightMap.value = x.lightMap, g.lightMapIntensity.value = x.lightMapIntensity, n(x.lightMap, g.lightMapTransform)), x.aoMap && (g.aoMap.value = x.aoMap, g.aoMapIntensity.value = x.aoMapIntensity, n(x.aoMap, g.aoMapTransform));
  }
  function r(g, x) {
    g.diffuse.value.copy(x.color), g.opacity.value = x.opacity, x.map && (g.map.value = x.map, n(x.map, g.mapTransform));
  }
  function l(g, x) {
    g.dashSize.value = x.dashSize, g.totalSize.value = x.dashSize + x.gapSize, g.scale.value = x.scale;
  }
  function c(g, x, w, M) {
    g.diffuse.value.copy(x.color), g.opacity.value = x.opacity, g.size.value = x.size * w, g.scale.value = M * 0.5, x.map && (g.map.value = x.map, n(x.map, g.uvTransform)), x.alphaMap && (g.alphaMap.value = x.alphaMap, n(x.alphaMap, g.alphaMapTransform)), x.alphaTest > 0 && (g.alphaTest.value = x.alphaTest);
  }
  function u(g, x) {
    g.diffuse.value.copy(x.color), g.opacity.value = x.opacity, g.rotation.value = x.rotation, x.map && (g.map.value = x.map, n(x.map, g.mapTransform)), x.alphaMap && (g.alphaMap.value = x.alphaMap, n(x.alphaMap, g.alphaMapTransform)), x.alphaTest > 0 && (g.alphaTest.value = x.alphaTest);
  }
  function d(g, x) {
    g.specular.value.copy(x.specular), g.shininess.value = Math.max(x.shininess, 1e-4);
  }
  function h(g, x) {
    x.gradientMap && (g.gradientMap.value = x.gradientMap);
  }
  function p(g, x) {
    g.metalness.value = x.metalness, x.metalnessMap && (g.metalnessMap.value = x.metalnessMap, n(x.metalnessMap, g.metalnessMapTransform)), g.roughness.value = x.roughness, x.roughnessMap && (g.roughnessMap.value = x.roughnessMap, n(x.roughnessMap, g.roughnessMapTransform)), x.envMap && (g.envMapIntensity.value = x.envMapIntensity);
  }
  function f(g, x, w) {
    g.ior.value = x.ior, x.sheen > 0 && (g.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen), g.sheenRoughness.value = x.sheenRoughness, x.sheenColorMap && (g.sheenColorMap.value = x.sheenColorMap, n(x.sheenColorMap, g.sheenColorMapTransform)), x.sheenRoughnessMap && (g.sheenRoughnessMap.value = x.sheenRoughnessMap, n(x.sheenRoughnessMap, g.sheenRoughnessMapTransform))), x.clearcoat > 0 && (g.clearcoat.value = x.clearcoat, g.clearcoatRoughness.value = x.clearcoatRoughness, x.clearcoatMap && (g.clearcoatMap.value = x.clearcoatMap, n(x.clearcoatMap, g.clearcoatMapTransform)), x.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = x.clearcoatRoughnessMap, n(x.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), x.clearcoatNormalMap && (g.clearcoatNormalMap.value = x.clearcoatNormalMap, n(x.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(x.clearcoatNormalScale), x.side === vi && g.clearcoatNormalScale.value.negate())), x.dispersion > 0 && (g.dispersion.value = x.dispersion), x.iridescence > 0 && (g.iridescence.value = x.iridescence, g.iridescenceIOR.value = x.iridescenceIOR, g.iridescenceThicknessMinimum.value = x.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = x.iridescenceThicknessRange[1], x.iridescenceMap && (g.iridescenceMap.value = x.iridescenceMap, n(x.iridescenceMap, g.iridescenceMapTransform)), x.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = x.iridescenceThicknessMap, n(x.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), x.transmission > 0 && (g.transmission.value = x.transmission, g.transmissionSamplerMap.value = w.texture, g.transmissionSamplerSize.value.set(w.width, w.height), x.transmissionMap && (g.transmissionMap.value = x.transmissionMap, n(x.transmissionMap, g.transmissionMapTransform)), g.thickness.value = x.thickness, x.thicknessMap && (g.thicknessMap.value = x.thicknessMap, n(x.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = x.attenuationDistance, g.attenuationColor.value.copy(x.attenuationColor)), x.anisotropy > 0 && (g.anisotropyVector.value.set(x.anisotropy * Math.cos(x.anisotropyRotation), x.anisotropy * Math.sin(x.anisotropyRotation)), x.anisotropyMap && (g.anisotropyMap.value = x.anisotropyMap, n(x.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = x.specularIntensity, g.specularColor.value.copy(x.specularColor), x.specularColorMap && (g.specularColorMap.value = x.specularColorMap, n(x.specularColorMap, g.specularColorMapTransform)), x.specularIntensityMap && (g.specularIntensityMap.value = x.specularIntensityMap, n(x.specularIntensityMap, g.specularIntensityMapTransform));
  }
  function m(g, x) {
    x.matcap && (g.matcap.value = x.matcap);
  }
  function y(g, x) {
    const w = e.get(x).light;
    g.referencePosition.value.setFromMatrixPosition(w.matrixWorld), g.nearDistance.value = w.shadow.camera.near, g.farDistance.value = w.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: o
  };
}
function E_(s, e, n, i) {
  let o = {}, a = {}, r = [];
  const l = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function c(w, M) {
    const _ = M.program;
    i.uniformBlockBinding(w, _);
  }
  function u(w, M) {
    let _ = o[w.id];
    _ === void 0 && (m(w), _ = d(w), o[w.id] = _, w.addEventListener("dispose", g));
    const C = M.program;
    i.updateUBOMapping(w, C);
    const T = e.render.frame;
    a[w.id] !== T && (p(w), a[w.id] = T);
  }
  function d(w) {
    const M = h();
    w.__bindingPointIndex = M;
    const _ = s.createBuffer(), C = w.__size, T = w.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, _), s.bufferData(s.UNIFORM_BUFFER, C, T), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, M, _), _;
  }
  function h() {
    for (let w = 0; w < l; w++)
      if (r.indexOf(w) === -1)
        return r.push(w), w;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(w) {
    const M = o[w.id], _ = w.uniforms, C = w.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, M);
    for (let T = 0, P = _.length; T < P; T++) {
      const E = Array.isArray(_[T]) ? _[T] : [_[T]];
      for (let b = 0, S = E.length; b < S; b++) {
        const A = E[b];
        if (f(A, T, b, C) === !0) {
          const R = A.__offset, k = Array.isArray(A.value) ? A.value : [A.value];
          let U = 0;
          for (let I = 0; I < k.length; I++) {
            const W = k[I], fe = y(W);
            typeof W == "number" || typeof W == "boolean" ? (A.__data[0] = W, s.bufferSubData(s.UNIFORM_BUFFER, R + U, A.__data)) : W.isMatrix3 ? (A.__data[0] = W.elements[0], A.__data[1] = W.elements[1], A.__data[2] = W.elements[2], A.__data[3] = 0, A.__data[4] = W.elements[3], A.__data[5] = W.elements[4], A.__data[6] = W.elements[5], A.__data[7] = 0, A.__data[8] = W.elements[6], A.__data[9] = W.elements[7], A.__data[10] = W.elements[8], A.__data[11] = 0) : (W.toArray(A.__data, U), U += fe.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, R, A.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function f(w, M, _, C) {
    const T = w.value, P = M + "_" + _;
    if (C[P] === void 0)
      return typeof T == "number" || typeof T == "boolean" ? C[P] = T : C[P] = T.clone(), !0;
    {
      const E = C[P];
      if (typeof T == "number" || typeof T == "boolean") {
        if (E !== T)
          return C[P] = T, !0;
      } else if (E.equals(T) === !1)
        return E.copy(T), !0;
    }
    return !1;
  }
  function m(w) {
    const M = w.uniforms;
    let _ = 0;
    const C = 16;
    for (let P = 0, E = M.length; P < E; P++) {
      const b = Array.isArray(M[P]) ? M[P] : [M[P]];
      for (let S = 0, A = b.length; S < A; S++) {
        const R = b[S], k = Array.isArray(R.value) ? R.value : [R.value];
        for (let U = 0, I = k.length; U < I; U++) {
          const W = k[U], fe = y(W), q = _ % C, G = q % fe.boundary, Q = q + G;
          _ += G, Q !== 0 && C - Q < fe.storage && (_ += C - Q), R.__data = new Float32Array(fe.storage / Float32Array.BYTES_PER_ELEMENT), R.__offset = _, _ += fe.storage;
        }
      }
    }
    const T = _ % C;
    return T > 0 && (_ += C - T), w.__size = _, w.__cache = {}, this;
  }
  function y(w) {
    const M = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof w == "number" || typeof w == "boolean" ? (M.boundary = 4, M.storage = 4) : w.isVector2 ? (M.boundary = 8, M.storage = 8) : w.isVector3 || w.isColor ? (M.boundary = 16, M.storage = 12) : w.isVector4 ? (M.boundary = 16, M.storage = 16) : w.isMatrix3 ? (M.boundary = 48, M.storage = 48) : w.isMatrix4 ? (M.boundary = 64, M.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w), M;
  }
  function g(w) {
    const M = w.target;
    M.removeEventListener("dispose", g);
    const _ = r.indexOf(M.__bindingPointIndex);
    r.splice(_, 1), s.deleteBuffer(o[M.id]), delete o[M.id], delete a[M.id];
  }
  function x() {
    for (const w in o)
      s.deleteBuffer(o[w]);
    r = [], o = {}, a = {};
  }
  return {
    bind: c,
    update: u,
    dispose: x
  };
}
class A_ {
  constructor(e = {}) {
    const {
      canvas: n = vv(),
      context: i = null,
      depth: o = !0,
      stencil: a = !1,
      alpha: r = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: h = !1,
      reverseDepthBuffer: p = !1
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    if (i !== null) {
      if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      f = i.getContextAttributes().alpha;
    } else
      f = r;
    const m = new Uint32Array(4), y = new Int32Array(4);
    let g = null, x = null;
    const w = [], M = [];
    this.domElement = n, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = pn, this.toneMapping = D0, this.toneMappingExposure = 1;
    const _ = this;
    let C = !1, T = 0, P = 0, E = null, b = -1, S = null;
    const A = new Kt(), R = new Kt();
    let k = null;
    const U = new Mt(0);
    let I = 0, W = n.width, fe = n.height, q = 1, G = null, Q = null;
    const K = new Kt(0, 0, W, fe), Y = new Kt(0, 0, W, fe);
    let ee = !1;
    const ce = new Dh();
    let ae = !1, de = !1;
    const ie = new jt(), he = new jt(), ne = new pe(), N = new Kt(), te = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let F = !1;
    function B() {
      return E === null ? q : 1;
    }
    let L = i;
    function D(J, ge) {
      return n.getContext(J, ge);
    }
    try {
      const J = {
        alpha: !0,
        depth: o,
        stencil: a,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: d,
        failIfMajorPerformanceCaveat: h
      };
      if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${yh}`), n.addEventListener("webglcontextlost", Ge, !1), n.addEventListener("webglcontextrestored", Ye, !1), n.addEventListener("webglcontextcreationerror", We, !1), L === null) {
        const ge = "webgl2";
        if (L = D(ge, J), L === null)
          throw D(ge) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (J) {
      throw console.error("THREE.WebGLRenderer: " + J.message), J;
    }
    let j, Z, z, $, oe, O, V, H, X, ue, me, _e, we, Ae, Ve, Fe, $e, Ze, je, Ue, rt, Qe, yt, Ce;
    function Be() {
      j = new Fx(L), j.init(), Qe = new y_(L, j), Z = new Px(L, j, e, Qe), z = new m_(L, j), Z.reverseDepthBuffer && p && z.buffers.depth.setReversed(!0), $ = new zx(L), oe = new n_(), O = new g_(L, j, z, oe, Z, Qe, $), V = new Dx(_), H = new Lx(_), X = new Wv(L), yt = new Ex(L, X), ue = new Ox(L, X, $, yt), me = new Nx(L, ue, X, $), je = new Bx(L, Z, O), Fe = new kx(oe), _e = new t_(_, V, H, j, Z, yt, Fe), we = new T_(_, oe), Ae = new s_(), Ve = new u_(j), Ze = new Tx(_, V, H, z, me, f, c), $e = new f_(_, me, Z), Ce = new E_(L, $, Z, z), Ue = new Ax(L, j, $), rt = new Ux(L, j, $), $.programs = _e.programs, _.capabilities = Z, _.extensions = j, _.properties = oe, _.renderLists = Ae, _.shadowMap = $e, _.state = z, _.info = $;
    }
    Be();
    const ke = new S_(_, L);
    this.xr = ke, this.getContext = function() {
      return L;
    }, this.getContextAttributes = function() {
      return L.getContextAttributes();
    }, this.forceContextLoss = function() {
      const J = j.get("WEBGL_lose_context");
      J && J.loseContext();
    }, this.forceContextRestore = function() {
      const J = j.get("WEBGL_lose_context");
      J && J.restoreContext();
    }, this.getPixelRatio = function() {
      return q;
    }, this.setPixelRatio = function(J) {
      J !== void 0 && (q = J, this.setSize(W, fe, !1));
    }, this.getSize = function(J) {
      return J.set(W, fe);
    }, this.setSize = function(J, ge, be = !0) {
      if (ke.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      W = J, fe = ge, n.width = Math.floor(J * q), n.height = Math.floor(ge * q), be === !0 && (n.style.width = J + "px", n.style.height = ge + "px"), this.setViewport(0, 0, J, ge);
    }, this.getDrawingBufferSize = function(J) {
      return J.set(W * q, fe * q).floor();
    }, this.setDrawingBufferSize = function(J, ge, be) {
      W = J, fe = ge, q = be, n.width = Math.floor(J * be), n.height = Math.floor(ge * be), this.setViewport(0, 0, J, ge);
    }, this.getCurrentViewport = function(J) {
      return J.copy(A);
    }, this.getViewport = function(J) {
      return J.copy(K);
    }, this.setViewport = function(J, ge, be, Ee) {
      J.isVector4 ? K.set(J.x, J.y, J.z, J.w) : K.set(J, ge, be, Ee), z.viewport(A.copy(K).multiplyScalar(q).round());
    }, this.getScissor = function(J) {
      return J.copy(Y);
    }, this.setScissor = function(J, ge, be, Ee) {
      J.isVector4 ? Y.set(J.x, J.y, J.z, J.w) : Y.set(J, ge, be, Ee), z.scissor(R.copy(Y).multiplyScalar(q).round());
    }, this.getScissorTest = function() {
      return ee;
    }, this.setScissorTest = function(J) {
      z.setScissorTest(ee = J);
    }, this.setOpaqueSort = function(J) {
      G = J;
    }, this.setTransparentSort = function(J) {
      Q = J;
    }, this.getClearColor = function(J) {
      return J.copy(Ze.getClearColor());
    }, this.setClearColor = function() {
      Ze.setClearColor.apply(Ze, arguments);
    }, this.getClearAlpha = function() {
      return Ze.getClearAlpha();
    }, this.setClearAlpha = function() {
      Ze.setClearAlpha.apply(Ze, arguments);
    }, this.clear = function(J = !0, ge = !0, be = !0) {
      let Ee = 0;
      if (J) {
        let Se = !1;
        if (E !== null) {
          const Oe = E.texture.format;
          Se = Oe === Ch || Oe === Sh || Oe === Mh;
        }
        if (Se) {
          const Oe = E.texture.type, De = Oe === ps || Oe === mo || Oe === zr || Oe === vo || Oe === _h || Oe === wh, et = Ze.getClearColor(), lt = Ze.getClearAlpha(), gt = et.r, wt = et.g, dt = et.b;
          De ? (m[0] = gt, m[1] = wt, m[2] = dt, m[3] = lt, L.clearBufferuiv(L.COLOR, 0, m)) : (y[0] = gt, y[1] = wt, y[2] = dt, y[3] = lt, L.clearBufferiv(L.COLOR, 0, y));
        } else
          Ee |= L.COLOR_BUFFER_BIT;
      }
      ge && (Ee |= L.DEPTH_BUFFER_BIT), be && (Ee |= L.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), L.clear(Ee);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      n.removeEventListener("webglcontextlost", Ge, !1), n.removeEventListener("webglcontextrestored", Ye, !1), n.removeEventListener("webglcontextcreationerror", We, !1), Ae.dispose(), Ve.dispose(), oe.dispose(), V.dispose(), H.dispose(), me.dispose(), yt.dispose(), Ce.dispose(), _e.dispose(), ke.dispose(), ke.removeEventListener("sessionstart", hn), ke.removeEventListener("sessionend", Yn), Pn.stop();
    };
    function Ge(J) {
      J.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0;
    }
    function Ye() {
      console.log("THREE.WebGLRenderer: Context Restored."), C = !1;
      const J = $.autoReset, ge = $e.enabled, be = $e.autoUpdate, Ee = $e.needsUpdate, Se = $e.type;
      Be(), $.autoReset = J, $e.enabled = ge, $e.autoUpdate = be, $e.needsUpdate = Ee, $e.type = Se;
    }
    function We(J) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", J.statusMessage);
    }
    function ht(J) {
      const ge = J.target;
      ge.removeEventListener("dispose", ht), ut(ge);
    }
    function ut(J) {
      ft(J), oe.remove(J);
    }
    function ft(J) {
      const ge = oe.get(J).programs;
      ge !== void 0 && (ge.forEach(function(be) {
        _e.releaseProgram(be);
      }), J.isShaderMaterial && _e.releaseShaderCache(J));
    }
    this.renderBufferDirect = function(J, ge, be, Ee, Se, Oe) {
      ge === null && (ge = te);
      const De = Se.isMesh && Se.matrixWorld.determinant() < 0, et = Me(J, ge, be, Ee, Se);
      z.setMaterial(Ee, De);
      let lt = be.index, gt = 1;
      if (Ee.wireframe === !0) {
        if (lt = ue.getWireframeAttribute(be), lt === void 0) return;
        gt = 2;
      }
      const wt = be.drawRange, dt = be.attributes.position;
      let Rt = wt.start * gt, Wt = (wt.start + wt.count) * gt;
      Oe !== null && (Rt = Math.max(Rt, Oe.start * gt), Wt = Math.min(Wt, (Oe.start + Oe.count) * gt)), lt !== null ? (Rt = Math.max(Rt, 0), Wt = Math.min(Wt, lt.count)) : dt != null && (Rt = Math.max(Rt, 0), Wt = Math.min(Wt, dt.count));
      const Xt = Wt - Rt;
      if (Xt < 0 || Xt === 1 / 0) return;
      yt.setup(Se, Ee, et, be, lt);
      let Hn, zt = Ue;
      if (lt !== null && (Hn = X.get(lt), zt = rt, zt.setIndex(Hn)), Se.isMesh)
        Ee.wireframe === !0 ? (z.setLineWidth(Ee.wireframeLinewidth * B()), zt.setMode(L.LINES)) : zt.setMode(L.TRIANGLES);
      else if (Se.isLine) {
        let pt = Ee.linewidth;
        pt === void 0 && (pt = 1), z.setLineWidth(pt * B()), Se.isLineSegments ? zt.setMode(L.LINES) : Se.isLineLoop ? zt.setMode(L.LINE_LOOP) : zt.setMode(L.LINE_STRIP);
      } else Se.isPoints ? zt.setMode(L.POINTS) : Se.isSprite && zt.setMode(L.TRIANGLES);
      if (Se.isBatchedMesh)
        if (Se._multiDrawInstances !== null)
          zt.renderMultiDrawInstances(Se._multiDrawStarts, Se._multiDrawCounts, Se._multiDrawCount, Se._multiDrawInstances);
        else if (j.get("WEBGL_multi_draw"))
          zt.renderMultiDraw(Se._multiDrawStarts, Se._multiDrawCounts, Se._multiDrawCount);
        else {
          const pt = Se._multiDrawStarts, Pi = Se._multiDrawCounts, Ht = Se._multiDrawCount, Gn = lt ? X.get(lt).bytesPerElement : 1, ms = oe.get(Ee).currentProgram.getUniforms();
          for (let Dn = 0; Dn < Ht; Dn++)
            ms.setValue(L, "_gl_DrawID", Dn), zt.render(pt[Dn] / Gn, Pi[Dn]);
        }
      else if (Se.isInstancedMesh)
        zt.renderInstances(Rt, Xt, Se.count);
      else if (be.isInstancedBufferGeometry) {
        const pt = be._maxInstanceCount !== void 0 ? be._maxInstanceCount : 1 / 0, Pi = Math.min(be.instanceCount, pt);
        zt.renderInstances(Rt, Xt, Pi);
      } else
        zt.render(Rt, Xt);
    };
    function vt(J, ge, be) {
      J.transparent === !0 && J.side === mn && J.forceSinglePass === !1 ? (J.side = vi, J.needsUpdate = !0, yi(J, ge, be), J.side = L0, J.needsUpdate = !0, yi(J, ge, be), J.side = mn) : yi(J, ge, be);
    }
    this.compile = function(J, ge, be = null) {
      be === null && (be = J), x = Ve.get(be), x.init(ge), M.push(x), be.traverseVisible(function(Se) {
        Se.isLight && Se.layers.test(ge.layers) && (x.pushLight(Se), Se.castShadow && x.pushShadow(Se));
      }), J !== be && J.traverseVisible(function(Se) {
        Se.isLight && Se.layers.test(ge.layers) && (x.pushLight(Se), Se.castShadow && x.pushShadow(Se));
      }), x.setupLights();
      const Ee = /* @__PURE__ */ new Set();
      return J.traverse(function(Se) {
        if (!(Se.isMesh || Se.isPoints || Se.isLine || Se.isSprite))
          return;
        const Oe = Se.material;
        if (Oe)
          if (Array.isArray(Oe))
            for (let De = 0; De < Oe.length; De++) {
              const et = Oe[De];
              vt(et, be, Se), Ee.add(et);
            }
          else
            vt(Oe, be, Se), Ee.add(Oe);
      }), M.pop(), x = null, Ee;
    }, this.compileAsync = function(J, ge, be = null) {
      const Ee = this.compile(J, ge, be);
      return new Promise((Se) => {
        function Oe() {
          if (Ee.forEach(function(De) {
            oe.get(De).currentProgram.isReady() && Ee.delete(De);
          }), Ee.size === 0) {
            Se(J);
            return;
          }
          setTimeout(Oe, 10);
        }
        j.get("KHR_parallel_shader_compile") !== null ? Oe() : setTimeout(Oe, 10);
      });
    };
    let Gt = null;
    function en(J) {
      Gt && Gt(J);
    }
    function hn() {
      Pn.stop();
    }
    function Yn() {
      Pn.start();
    }
    const Pn = new Cm();
    Pn.setAnimationLoop(en), typeof self < "u" && Pn.setContext(self), this.setAnimationLoop = function(J) {
      Gt = J, ke.setAnimationLoop(J), J === null ? Pn.stop() : Pn.start();
    }, ke.addEventListener("sessionstart", hn), ke.addEventListener("sessionend", Yn), this.render = function(J, ge) {
      if (ge !== void 0 && ge.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (C === !0) return;
      if (J.matrixWorldAutoUpdate === !0 && J.updateMatrixWorld(), ge.parent === null && ge.matrixWorldAutoUpdate === !0 && ge.updateMatrixWorld(), ke.enabled === !0 && ke.isPresenting === !0 && (ke.cameraAutoUpdate === !0 && ke.updateCamera(ge), ge = ke.getCamera()), J.isScene === !0 && J.onBeforeRender(_, J, ge, E), x = Ve.get(J, M.length), x.init(ge), M.push(x), he.multiplyMatrices(ge.projectionMatrix, ge.matrixWorldInverse), ce.setFromProjectionMatrix(he), de = this.localClippingEnabled, ae = Fe.init(this.clippingPlanes, de), g = Ae.get(J, w.length), g.init(), w.push(g), ke.enabled === !0 && ke.isPresenting === !0) {
        const Oe = _.xr.getDepthSensingMesh();
        Oe !== null && li(Oe, ge, -1 / 0, _.sortObjects);
      }
      li(J, ge, 0, _.sortObjects), g.finish(), _.sortObjects === !0 && g.sort(G, Q), F = ke.enabled === !1 || ke.isPresenting === !1 || ke.hasDepthSensing() === !1, F && Ze.addToRenderList(g, J), this.info.render.frame++, ae === !0 && Fe.beginShadows();
      const be = x.state.shadowsArray;
      $e.render(be, J, ge), ae === !0 && Fe.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Ee = g.opaque, Se = g.transmissive;
      if (x.setupLights(), ge.isArrayCamera) {
        const Oe = ge.cameras;
        if (Se.length > 0)
          for (let De = 0, et = Oe.length; De < et; De++) {
            const lt = Oe[De];
            Ai(Ee, Se, J, lt);
          }
        F && Ze.render(J);
        for (let De = 0, et = Oe.length; De < et; De++) {
          const lt = Oe[De];
          Ei(g, J, lt, lt.viewport);
        }
      } else
        Se.length > 0 && Ai(Ee, Se, J, ge), F && Ze.render(J), Ei(g, J, ge);
      E !== null && (O.updateMultisampleRenderTarget(E), O.updateRenderTargetMipmap(E)), J.isScene === !0 && J.onAfterRender(_, J, ge), yt.resetDefaultState(), b = -1, S = null, M.pop(), M.length > 0 ? (x = M[M.length - 1], ae === !0 && Fe.setGlobalState(_.clippingPlanes, x.state.camera)) : x = null, w.pop(), w.length > 0 ? g = w[w.length - 1] : g = null;
    };
    function li(J, ge, be, Ee) {
      if (J.visible === !1) return;
      if (J.layers.test(ge.layers)) {
        if (J.isGroup)
          be = J.renderOrder;
        else if (J.isLOD)
          J.autoUpdate === !0 && J.update(ge);
        else if (J.isLight)
          x.pushLight(J), J.castShadow && x.pushShadow(J);
        else if (J.isSprite) {
          if (!J.frustumCulled || ce.intersectsSprite(J)) {
            Ee && N.setFromMatrixPosition(J.matrixWorld).applyMatrix4(he);
            const De = me.update(J), et = J.material;
            et.visible && g.push(J, De, et, be, N.z, null);
          }
        } else if ((J.isMesh || J.isLine || J.isPoints) && (!J.frustumCulled || ce.intersectsObject(J))) {
          const De = me.update(J), et = J.material;
          if (Ee && (J.boundingSphere !== void 0 ? (J.boundingSphere === null && J.computeBoundingSphere(), N.copy(J.boundingSphere.center)) : (De.boundingSphere === null && De.computeBoundingSphere(), N.copy(De.boundingSphere.center)), N.applyMatrix4(J.matrixWorld).applyMatrix4(he)), Array.isArray(et)) {
            const lt = De.groups;
            for (let gt = 0, wt = lt.length; gt < wt; gt++) {
              const dt = lt[gt], Rt = et[dt.materialIndex];
              Rt && Rt.visible && g.push(J, De, Rt, be, N.z, dt);
            }
          } else et.visible && g.push(J, De, et, be, N.z, null);
        }
      }
      const Oe = J.children;
      for (let De = 0, et = Oe.length; De < et; De++)
        li(Oe[De], ge, be, Ee);
    }
    function Ei(J, ge, be, Ee) {
      const Se = J.opaque, Oe = J.transmissive, De = J.transparent;
      x.setupLightsView(be), ae === !0 && Fe.setGlobalState(_.clippingPlanes, be), Ee && z.viewport(A.copy(Ee)), Se.length > 0 && qn(Se, ge, be), Oe.length > 0 && qn(Oe, ge, be), De.length > 0 && qn(De, ge, be), z.buffers.depth.setTest(!0), z.buffers.depth.setMask(!0), z.buffers.color.setMask(!0), z.setPolygonOffset(!1);
    }
    function Ai(J, ge, be, Ee) {
      if ((be.isScene === !0 ? be.overrideMaterial : null) !== null)
        return;
      x.state.transmissionRenderTarget[Ee.id] === void 0 && (x.state.transmissionRenderTarget[Ee.id] = new Xn(1, 1, {
        generateMipmaps: !0,
        type: j.has("EXT_color_buffer_half_float") || j.has("EXT_color_buffer_float") ? gi : ps,
        minFilter: ao,
        samples: 4,
        stencilBuffer: a,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: Nt.workingColorSpace
      }));
      const Oe = x.state.transmissionRenderTarget[Ee.id], De = Ee.viewport || A;
      Oe.setSize(De.z, De.w);
      const et = _.getRenderTarget();
      _.setRenderTarget(Oe), _.getClearColor(U), I = _.getClearAlpha(), I < 1 && _.setClearColor(16777215, 0.5), _.clear(), F && Ze.render(be);
      const lt = _.toneMapping;
      _.toneMapping = D0;
      const gt = Ee.viewport;
      if (Ee.viewport !== void 0 && (Ee.viewport = void 0), x.setupLightsView(Ee), ae === !0 && Fe.setGlobalState(_.clippingPlanes, Ee), qn(J, be, Ee), O.updateMultisampleRenderTarget(Oe), O.updateRenderTargetMipmap(Oe), j.has("WEBGL_multisampled_render_to_texture") === !1) {
        let wt = !1;
        for (let dt = 0, Rt = ge.length; dt < Rt; dt++) {
          const Wt = ge[dt], Xt = Wt.object, Hn = Wt.geometry, zt = Wt.material, pt = Wt.group;
          if (zt.side === mn && Xt.layers.test(Ee.layers)) {
            const Pi = zt.side;
            zt.side = vi, zt.needsUpdate = !0, kn(Xt, be, Ee, Hn, zt, pt), zt.side = Pi, zt.needsUpdate = !0, wt = !0;
          }
        }
        wt === !0 && (O.updateMultisampleRenderTarget(Oe), O.updateRenderTargetMipmap(Oe));
      }
      _.setRenderTarget(et), _.setClearColor(U, I), gt !== void 0 && (Ee.viewport = gt), _.toneMapping = lt;
    }
    function qn(J, ge, be) {
      const Ee = ge.isScene === !0 ? ge.overrideMaterial : null;
      for (let Se = 0, Oe = J.length; Se < Oe; Se++) {
        const De = J[Se], et = De.object, lt = De.geometry, gt = Ee === null ? De.material : Ee, wt = De.group;
        et.layers.test(be.layers) && kn(et, ge, be, lt, gt, wt);
      }
    }
    function kn(J, ge, be, Ee, Se, Oe) {
      J.onBeforeRender(_, ge, be, Ee, Se, Oe), J.modelViewMatrix.multiplyMatrices(be.matrixWorldInverse, J.matrixWorld), J.normalMatrix.getNormalMatrix(J.modelViewMatrix), Se.onBeforeRender(_, ge, be, Ee, J, Oe), Se.transparent === !0 && Se.side === mn && Se.forceSinglePass === !1 ? (Se.side = vi, Se.needsUpdate = !0, _.renderBufferDirect(be, ge, Ee, Se, J, Oe), Se.side = L0, Se.needsUpdate = !0, _.renderBufferDirect(be, ge, Ee, Se, J, Oe), Se.side = mn) : _.renderBufferDirect(be, ge, Ee, Se, J, Oe), J.onAfterRender(_, ge, be, Ee, Se, Oe);
    }
    function yi(J, ge, be) {
      ge.isScene !== !0 && (ge = te);
      const Ee = oe.get(J), Se = x.state.lights, Oe = x.state.shadowsArray, De = Se.state.version, et = _e.getParameters(J, Se.state, Oe, ge, be), lt = _e.getProgramCacheKey(et);
      let gt = Ee.programs;
      Ee.environment = J.isMeshStandardMaterial ? ge.environment : null, Ee.fog = ge.fog, Ee.envMap = (J.isMeshStandardMaterial ? H : V).get(J.envMap || Ee.environment), Ee.envMapRotation = Ee.environment !== null && J.envMap === null ? ge.environmentRotation : J.envMapRotation, gt === void 0 && (J.addEventListener("dispose", ht), gt = /* @__PURE__ */ new Map(), Ee.programs = gt);
      let wt = gt.get(lt);
      if (wt !== void 0) {
        if (Ee.currentProgram === wt && Ee.lightsStateVersion === De)
          return ve(J, et), wt;
      } else
        et.uniforms = _e.getUniforms(J), J.onBeforeCompile(et, _), wt = _e.acquireProgram(et, lt), gt.set(lt, wt), Ee.uniforms = et.uniforms;
      const dt = Ee.uniforms;
      return (!J.isShaderMaterial && !J.isRawShaderMaterial || J.clipping === !0) && (dt.clippingPlanes = Fe.uniform), ve(J, et), Ee.needsLights = ze(J), Ee.lightsStateVersion = De, Ee.needsLights && (dt.ambientLightColor.value = Se.state.ambient, dt.lightProbe.value = Se.state.probe, dt.directionalLights.value = Se.state.directional, dt.directionalLightShadows.value = Se.state.directionalShadow, dt.spotLights.value = Se.state.spot, dt.spotLightShadows.value = Se.state.spotShadow, dt.rectAreaLights.value = Se.state.rectArea, dt.ltc_1.value = Se.state.rectAreaLTC1, dt.ltc_2.value = Se.state.rectAreaLTC2, dt.pointLights.value = Se.state.point, dt.pointLightShadows.value = Se.state.pointShadow, dt.hemisphereLights.value = Se.state.hemi, dt.directionalShadowMap.value = Se.state.directionalShadowMap, dt.directionalShadowMatrix.value = Se.state.directionalShadowMatrix, dt.spotShadowMap.value = Se.state.spotShadowMap, dt.spotLightMatrix.value = Se.state.spotLightMatrix, dt.spotLightMap.value = Se.state.spotLightMap, dt.pointShadowMap.value = Se.state.pointShadowMap, dt.pointShadowMatrix.value = Se.state.pointShadowMatrix), Ee.currentProgram = wt, Ee.uniformsList = null, wt;
    }
    function Ki(J) {
      if (J.uniformsList === null) {
        const ge = J.currentProgram.getUniforms();
        J.uniformsList = gc.seqWithValue(ge.seq, J.uniforms);
      }
      return J.uniformsList;
    }
    function ve(J, ge) {
      const be = oe.get(J);
      be.outputColorSpace = ge.outputColorSpace, be.batching = ge.batching, be.batchingColor = ge.batchingColor, be.instancing = ge.instancing, be.instancingColor = ge.instancingColor, be.instancingMorph = ge.instancingMorph, be.skinning = ge.skinning, be.morphTargets = ge.morphTargets, be.morphNormals = ge.morphNormals, be.morphColors = ge.morphColors, be.morphTargetsCount = ge.morphTargetsCount, be.numClippingPlanes = ge.numClippingPlanes, be.numIntersection = ge.numClipIntersection, be.vertexAlphas = ge.vertexAlphas, be.vertexTangents = ge.vertexTangents, be.toneMapping = ge.toneMapping;
    }
    function Me(J, ge, be, Ee, Se) {
      ge.isScene !== !0 && (ge = te), O.resetTextureUnits();
      const Oe = ge.fog, De = Ee.isMeshStandardMaterial ? ge.environment : null, et = E === null ? _.outputColorSpace : E.isXRRenderTarget === !0 ? E.texture.colorSpace : Sa, lt = (Ee.isMeshStandardMaterial ? H : V).get(Ee.envMap || De), gt = Ee.vertexColors === !0 && !!be.attributes.color && be.attributes.color.itemSize === 4, wt = !!be.attributes.tangent && (!!Ee.normalMap || Ee.anisotropy > 0), dt = !!be.morphAttributes.position, Rt = !!be.morphAttributes.normal, Wt = !!be.morphAttributes.color;
      let Xt = D0;
      Ee.toneMapped && (E === null || E.isXRRenderTarget === !0) && (Xt = _.toneMapping);
      const Hn = be.morphAttributes.position || be.morphAttributes.normal || be.morphAttributes.color, zt = Hn !== void 0 ? Hn.length : 0, pt = oe.get(Ee), Pi = x.state.lights;
      if (ae === !0 && (de === !0 || J !== S)) {
        const bi = J === S && Ee.id === b;
        Fe.setState(Ee, J, bi);
      }
      let Ht = !1;
      Ee.version === pt.__version ? (pt.needsLights && pt.lightsStateVersion !== Pi.state.version || pt.outputColorSpace !== et || Se.isBatchedMesh && pt.batching === !1 || !Se.isBatchedMesh && pt.batching === !0 || Se.isBatchedMesh && pt.batchingColor === !0 && Se.colorTexture === null || Se.isBatchedMesh && pt.batchingColor === !1 && Se.colorTexture !== null || Se.isInstancedMesh && pt.instancing === !1 || !Se.isInstancedMesh && pt.instancing === !0 || Se.isSkinnedMesh && pt.skinning === !1 || !Se.isSkinnedMesh && pt.skinning === !0 || Se.isInstancedMesh && pt.instancingColor === !0 && Se.instanceColor === null || Se.isInstancedMesh && pt.instancingColor === !1 && Se.instanceColor !== null || Se.isInstancedMesh && pt.instancingMorph === !0 && Se.morphTexture === null || Se.isInstancedMesh && pt.instancingMorph === !1 && Se.morphTexture !== null || pt.envMap !== lt || Ee.fog === !0 && pt.fog !== Oe || pt.numClippingPlanes !== void 0 && (pt.numClippingPlanes !== Fe.numPlanes || pt.numIntersection !== Fe.numIntersection) || pt.vertexAlphas !== gt || pt.vertexTangents !== wt || pt.morphTargets !== dt || pt.morphNormals !== Rt || pt.morphColors !== Wt || pt.toneMapping !== Xt || pt.morphTargetsCount !== zt) && (Ht = !0) : (Ht = !0, pt.__version = Ee.version);
      let Gn = pt.currentProgram;
      Ht === !0 && (Gn = yi(Ee, ge, Se));
      let ms = !1, Dn = !1, ks = !1;
      const Jt = Gn.getUniforms(), xi = pt.uniforms;
      if (z.useProgram(Gn.program) && (ms = !0, Dn = !0, ks = !0), Ee.id !== b && (b = Ee.id, Dn = !0), ms || S !== J) {
        z.buffers.depth.getReversed() ? (ie.copy(J.projectionMatrix), yv(ie), xv(ie), Jt.setValue(L, "projectionMatrix", ie)) : Jt.setValue(L, "projectionMatrix", J.projectionMatrix), Jt.setValue(L, "viewMatrix", J.matrixWorldInverse);
        const ki = Jt.map.cameraPosition;
        ki !== void 0 && ki.setValue(L, ne.setFromMatrixPosition(J.matrixWorld)), Z.logarithmicDepthBuffer && Jt.setValue(
          L,
          "logDepthBufFC",
          2 / (Math.log(J.far + 1) / Math.LN2)
        ), (Ee.isMeshPhongMaterial || Ee.isMeshToonMaterial || Ee.isMeshLambertMaterial || Ee.isMeshBasicMaterial || Ee.isMeshStandardMaterial || Ee.isShaderMaterial) && Jt.setValue(L, "isOrthographic", J.isOrthographicCamera === !0), S !== J && (S = J, Dn = !0, ks = !0);
      }
      if (Se.isSkinnedMesh) {
        Jt.setOptional(L, Se, "bindMatrix"), Jt.setOptional(L, Se, "bindMatrixInverse");
        const bi = Se.skeleton;
        bi && (bi.boneTexture === null && bi.computeBoneTexture(), Jt.setValue(L, "boneTexture", bi.boneTexture, O));
      }
      Se.isBatchedMesh && (Jt.setOptional(L, Se, "batchingTexture"), Jt.setValue(L, "batchingTexture", Se._matricesTexture, O), Jt.setOptional(L, Se, "batchingIdTexture"), Jt.setValue(L, "batchingIdTexture", Se._indirectTexture, O), Jt.setOptional(L, Se, "batchingColorTexture"), Se._colorsTexture !== null && Jt.setValue(L, "batchingColorTexture", Se._colorsTexture, O));
      const Zn = be.morphAttributes;
      if ((Zn.position !== void 0 || Zn.normal !== void 0 || Zn.color !== void 0) && je.update(Se, be, Gn), (Dn || pt.receiveShadow !== Se.receiveShadow) && (pt.receiveShadow = Se.receiveShadow, Jt.setValue(L, "receiveShadow", Se.receiveShadow)), Ee.isMeshGouraudMaterial && Ee.envMap !== null && (xi.envMap.value = lt, xi.flipEnvMap.value = lt.isCubeTexture && lt.isRenderTargetTexture === !1 ? -1 : 1), Ee.isMeshStandardMaterial && Ee.envMap === null && ge.environment !== null && (xi.envMapIntensity.value = ge.environmentIntensity), Dn && (Jt.setValue(L, "toneMappingExposure", _.toneMappingExposure), pt.needsLights && Pe(xi, ks), Oe && Ee.fog === !0 && we.refreshFogUniforms(xi, Oe), we.refreshMaterialUniforms(xi, Ee, q, fe, x.state.transmissionRenderTarget[J.id]), gc.upload(L, Ki(pt), xi, O)), Ee.isShaderMaterial && Ee.uniformsNeedUpdate === !0 && (gc.upload(L, Ki(pt), xi, O), Ee.uniformsNeedUpdate = !1), Ee.isSpriteMaterial && Jt.setValue(L, "center", Se.center), Jt.setValue(L, "modelViewMatrix", Se.modelViewMatrix), Jt.setValue(L, "normalMatrix", Se.normalMatrix), Jt.setValue(L, "modelMatrix", Se.matrixWorld), Ee.isShaderMaterial || Ee.isRawShaderMaterial) {
        const bi = Ee.uniformsGroups;
        for (let ki = 0, _i = bi.length; ki < _i; ki++) {
          const ka = bi[ki];
          Ce.update(ka, Gn), Ce.bind(ka, Gn);
        }
      }
      return Gn;
    }
    function Pe(J, ge) {
      J.ambientLightColor.needsUpdate = ge, J.lightProbe.needsUpdate = ge, J.directionalLights.needsUpdate = ge, J.directionalLightShadows.needsUpdate = ge, J.pointLights.needsUpdate = ge, J.pointLightShadows.needsUpdate = ge, J.spotLights.needsUpdate = ge, J.spotLightShadows.needsUpdate = ge, J.rectAreaLights.needsUpdate = ge, J.hemisphereLights.needsUpdate = ge;
    }
    function ze(J) {
      return J.isMeshLambertMaterial || J.isMeshToonMaterial || J.isMeshPhongMaterial || J.isMeshStandardMaterial || J.isShadowMaterial || J.isShaderMaterial && J.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return T;
    }, this.getActiveMipmapLevel = function() {
      return P;
    }, this.getRenderTarget = function() {
      return E;
    }, this.setRenderTargetTextures = function(J, ge, be) {
      oe.get(J.texture).__webglTexture = ge, oe.get(J.depthTexture).__webglTexture = be;
      const Ee = oe.get(J);
      Ee.__hasExternalTextures = !0, Ee.__autoAllocateDepthBuffer = be === void 0, Ee.__autoAllocateDepthBuffer || j.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Ee.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(J, ge) {
      const be = oe.get(J);
      be.__webglFramebuffer = ge, be.__useDefaultFramebuffer = ge === void 0;
    }, this.setRenderTarget = function(J, ge = 0, be = 0) {
      E = J, T = ge, P = be;
      let Ee = !0, Se = null, Oe = !1, De = !1;
      if (J) {
        const lt = oe.get(J);
        if (lt.__useDefaultFramebuffer !== void 0)
          z.bindFramebuffer(L.FRAMEBUFFER, null), Ee = !1;
        else if (lt.__webglFramebuffer === void 0)
          O.setupRenderTarget(J);
        else if (lt.__hasExternalTextures)
          O.rebindTextures(J, oe.get(J.texture).__webglTexture, oe.get(J.depthTexture).__webglTexture);
        else if (J.depthBuffer) {
          const dt = J.depthTexture;
          if (lt.__boundDepthTexture !== dt) {
            if (dt !== null && oe.has(dt) && (J.width !== dt.image.width || J.height !== dt.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            O.setupDepthRenderbuffer(J);
          }
        }
        const gt = J.texture;
        (gt.isData3DTexture || gt.isDataArrayTexture || gt.isCompressedArrayTexture) && (De = !0);
        const wt = oe.get(J).__webglFramebuffer;
        J.isWebGLCubeRenderTarget ? (Array.isArray(wt[ge]) ? Se = wt[ge][be] : Se = wt[ge], Oe = !0) : J.samples > 0 && O.useMultisampledRTT(J) === !1 ? Se = oe.get(J).__webglMultisampledFramebuffer : Array.isArray(wt) ? Se = wt[be] : Se = wt, A.copy(J.viewport), R.copy(J.scissor), k = J.scissorTest;
      } else
        A.copy(K).multiplyScalar(q).floor(), R.copy(Y).multiplyScalar(q).floor(), k = ee;
      if (z.bindFramebuffer(L.FRAMEBUFFER, Se) && Ee && z.drawBuffers(J, Se), z.viewport(A), z.scissor(R), z.setScissorTest(k), Oe) {
        const lt = oe.get(J.texture);
        L.framebufferTexture2D(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, L.TEXTURE_CUBE_MAP_POSITIVE_X + ge, lt.__webglTexture, be);
      } else if (De) {
        const lt = oe.get(J.texture), gt = ge || 0;
        L.framebufferTextureLayer(L.FRAMEBUFFER, L.COLOR_ATTACHMENT0, lt.__webglTexture, be || 0, gt);
      }
      b = -1;
    }, this.readRenderTargetPixels = function(J, ge, be, Ee, Se, Oe, De) {
      if (!(J && J.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let et = oe.get(J).__webglFramebuffer;
      if (J.isWebGLCubeRenderTarget && De !== void 0 && (et = et[De]), et) {
        z.bindFramebuffer(L.FRAMEBUFFER, et);
        try {
          const lt = J.texture, gt = lt.format, wt = lt.type;
          if (!Z.textureFormatReadable(gt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!Z.textureTypeReadable(wt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ge >= 0 && ge <= J.width - Ee && be >= 0 && be <= J.height - Se && L.readPixels(ge, be, Ee, Se, Qe.convert(gt), Qe.convert(wt), Oe);
        } finally {
          const lt = E !== null ? oe.get(E).__webglFramebuffer : null;
          z.bindFramebuffer(L.FRAMEBUFFER, lt);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(J, ge, be, Ee, Se, Oe, De) {
      if (!(J && J.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let et = oe.get(J).__webglFramebuffer;
      if (J.isWebGLCubeRenderTarget && De !== void 0 && (et = et[De]), et) {
        const lt = J.texture, gt = lt.format, wt = lt.type;
        if (!Z.textureFormatReadable(gt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!Z.textureTypeReadable(wt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (ge >= 0 && ge <= J.width - Ee && be >= 0 && be <= J.height - Se) {
          z.bindFramebuffer(L.FRAMEBUFFER, et);
          const dt = L.createBuffer();
          L.bindBuffer(L.PIXEL_PACK_BUFFER, dt), L.bufferData(L.PIXEL_PACK_BUFFER, Oe.byteLength, L.STREAM_READ), L.readPixels(ge, be, Ee, Se, Qe.convert(gt), Qe.convert(wt), 0);
          const Rt = E !== null ? oe.get(E).__webglFramebuffer : null;
          z.bindFramebuffer(L.FRAMEBUFFER, Rt);
          const Wt = L.fenceSync(L.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return L.flush(), await gv(L, Wt, 4), L.bindBuffer(L.PIXEL_PACK_BUFFER, dt), L.getBufferSubData(L.PIXEL_PACK_BUFFER, 0, Oe), L.deleteBuffer(dt), L.deleteSync(Wt), Oe;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(J, ge = null, be = 0) {
      J.isTexture !== !0 && (or("WebGLRenderer: copyFramebufferToTexture function signature has changed."), ge = arguments[0] || null, J = arguments[1]);
      const Ee = Math.pow(2, -be), Se = Math.floor(J.image.width * Ee), Oe = Math.floor(J.image.height * Ee), De = ge !== null ? ge.x : 0, et = ge !== null ? ge.y : 0;
      O.setTexture2D(J, 0), L.copyTexSubImage2D(L.TEXTURE_2D, be, 0, 0, De, et, Se, Oe), z.unbindTexture();
    }, this.copyTextureToTexture = function(J, ge, be = null, Ee = null, Se = 0) {
      J.isTexture !== !0 && (or("WebGLRenderer: copyTextureToTexture function signature has changed."), Ee = arguments[0] || null, J = arguments[1], ge = arguments[2], Se = arguments[3] || 0, be = null);
      let Oe, De, et, lt, gt, wt, dt, Rt, Wt;
      const Xt = J.isCompressedTexture ? J.mipmaps[Se] : J.image;
      be !== null ? (Oe = be.max.x - be.min.x, De = be.max.y - be.min.y, et = be.isBox3 ? be.max.z - be.min.z : 1, lt = be.min.x, gt = be.min.y, wt = be.isBox3 ? be.min.z : 0) : (Oe = Xt.width, De = Xt.height, et = Xt.depth || 1, lt = 0, gt = 0, wt = 0), Ee !== null ? (dt = Ee.x, Rt = Ee.y, Wt = Ee.z) : (dt = 0, Rt = 0, Wt = 0);
      const Hn = Qe.convert(ge.format), zt = Qe.convert(ge.type);
      let pt;
      ge.isData3DTexture ? (O.setTexture3D(ge, 0), pt = L.TEXTURE_3D) : ge.isDataArrayTexture || ge.isCompressedArrayTexture ? (O.setTexture2DArray(ge, 0), pt = L.TEXTURE_2D_ARRAY) : (O.setTexture2D(ge, 0), pt = L.TEXTURE_2D), L.pixelStorei(L.UNPACK_FLIP_Y_WEBGL, ge.flipY), L.pixelStorei(L.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ge.premultiplyAlpha), L.pixelStorei(L.UNPACK_ALIGNMENT, ge.unpackAlignment);
      const Pi = L.getParameter(L.UNPACK_ROW_LENGTH), Ht = L.getParameter(L.UNPACK_IMAGE_HEIGHT), Gn = L.getParameter(L.UNPACK_SKIP_PIXELS), ms = L.getParameter(L.UNPACK_SKIP_ROWS), Dn = L.getParameter(L.UNPACK_SKIP_IMAGES);
      L.pixelStorei(L.UNPACK_ROW_LENGTH, Xt.width), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, Xt.height), L.pixelStorei(L.UNPACK_SKIP_PIXELS, lt), L.pixelStorei(L.UNPACK_SKIP_ROWS, gt), L.pixelStorei(L.UNPACK_SKIP_IMAGES, wt);
      const ks = J.isDataArrayTexture || J.isData3DTexture, Jt = ge.isDataArrayTexture || ge.isData3DTexture;
      if (J.isRenderTargetTexture || J.isDepthTexture) {
        const xi = oe.get(J), Zn = oe.get(ge), bi = oe.get(xi.__renderTarget), ki = oe.get(Zn.__renderTarget);
        z.bindFramebuffer(L.READ_FRAMEBUFFER, bi.__webglFramebuffer), z.bindFramebuffer(L.DRAW_FRAMEBUFFER, ki.__webglFramebuffer);
        for (let _i = 0; _i < et; _i++)
          ks && L.framebufferTextureLayer(L.READ_FRAMEBUFFER, L.COLOR_ATTACHMENT0, oe.get(J).__webglTexture, Se, wt + _i), J.isDepthTexture ? (Jt && L.framebufferTextureLayer(L.DRAW_FRAMEBUFFER, L.COLOR_ATTACHMENT0, oe.get(ge).__webglTexture, Se, Wt + _i), L.blitFramebuffer(lt, gt, Oe, De, dt, Rt, Oe, De, L.DEPTH_BUFFER_BIT, L.NEAREST)) : Jt ? L.copyTexSubImage3D(pt, Se, dt, Rt, Wt + _i, lt, gt, Oe, De) : L.copyTexSubImage2D(pt, Se, dt, Rt, Wt + _i, lt, gt, Oe, De);
        z.bindFramebuffer(L.READ_FRAMEBUFFER, null), z.bindFramebuffer(L.DRAW_FRAMEBUFFER, null);
      } else
        Jt ? J.isDataTexture || J.isData3DTexture ? L.texSubImage3D(pt, Se, dt, Rt, Wt, Oe, De, et, Hn, zt, Xt.data) : ge.isCompressedArrayTexture ? L.compressedTexSubImage3D(pt, Se, dt, Rt, Wt, Oe, De, et, Hn, Xt.data) : L.texSubImage3D(pt, Se, dt, Rt, Wt, Oe, De, et, Hn, zt, Xt) : J.isDataTexture ? L.texSubImage2D(L.TEXTURE_2D, Se, dt, Rt, Oe, De, Hn, zt, Xt.data) : J.isCompressedTexture ? L.compressedTexSubImage2D(L.TEXTURE_2D, Se, dt, Rt, Xt.width, Xt.height, Hn, Xt.data) : L.texSubImage2D(L.TEXTURE_2D, Se, dt, Rt, Oe, De, Hn, zt, Xt);
      L.pixelStorei(L.UNPACK_ROW_LENGTH, Pi), L.pixelStorei(L.UNPACK_IMAGE_HEIGHT, Ht), L.pixelStorei(L.UNPACK_SKIP_PIXELS, Gn), L.pixelStorei(L.UNPACK_SKIP_ROWS, ms), L.pixelStorei(L.UNPACK_SKIP_IMAGES, Dn), Se === 0 && ge.generateMipmaps && L.generateMipmap(pt), z.unbindTexture();
    }, this.copyTextureToTexture3D = function(J, ge, be = null, Ee = null, Se = 0) {
      return J.isTexture !== !0 && (or("WebGLRenderer: copyTextureToTexture3D function signature has changed."), be = arguments[0] || null, Ee = arguments[1] || null, J = arguments[2], ge = arguments[3], Se = arguments[4] || 0), or('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(J, ge, be, Ee, Se);
    }, this.initRenderTarget = function(J) {
      oe.get(J).__webglFramebuffer === void 0 && O.setupRenderTarget(J);
    }, this.initTexture = function(J) {
      J.isCubeTexture ? O.setTextureCube(J, 0) : J.isData3DTexture ? O.setTexture3D(J, 0) : J.isDataArrayTexture || J.isCompressedArrayTexture ? O.setTexture2DArray(J, 0) : O.setTexture2D(J, 0), z.unbindTexture();
    }, this.resetState = function() {
      T = 0, P = 0, E = null, z.reset(), yt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return qs;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    n.drawingBufferColorspace = Nt._getDrawingBufferColorSpace(e), n.unpackColorSpace = Nt._getUnpackColorSpace();
  }
}
class P_ extends vn {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Hi(), this.environmentIntensity = 1, this.environmentRotation = new Hi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class cs extends An {
  constructor(e = null, n = 1, i = 1, o, a, r, l, c, u = xn, d = xn, h, p) {
    super(null, r, l, c, u, d, o, a, h, p), this.isDataTexture = !0, this.image = { data: e, width: n, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class eo extends Vi {
  constructor(e, n, i, o = 1) {
    super(e, n, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = o;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class Gi extends _o {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const Bc = /* @__PURE__ */ new pe(), Nc = /* @__PURE__ */ new pe(), s2 = /* @__PURE__ */ new jt(), ja = /* @__PURE__ */ new Ph(), Rl = /* @__PURE__ */ new Zr(), b1 = /* @__PURE__ */ new pe(), o2 = /* @__PURE__ */ new pe();
class cn extends vn {
  constructor(e = new Ut(), n = new Gi()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [0];
      for (let o = 1, a = n.count; o < a; o++)
        Bc.fromBufferAttribute(n, o - 1), Nc.fromBufferAttribute(n, o), i[o] = i[o - 1], i[o] += Bc.distanceTo(Nc);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, n) {
    const i = this.geometry, o = this.matrixWorld, a = e.params.Line.threshold, r = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Rl.copy(i.boundingSphere), Rl.applyMatrix4(o), Rl.radius += a, e.ray.intersectsSphere(Rl) === !1) return;
    s2.copy(o).invert(), ja.copy(e.ray).applyMatrix4(s2);
    const l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, u = this.isLineSegments ? 2 : 1, d = i.index, p = i.attributes.position;
    if (d !== null) {
      const f = Math.max(0, r.start), m = Math.min(d.count, r.start + r.count);
      for (let y = f, g = m - 1; y < g; y += u) {
        const x = d.getX(y), w = d.getX(y + 1), M = Ll(this, e, ja, c, x, w);
        M && n.push(M);
      }
      if (this.isLineLoop) {
        const y = d.getX(m - 1), g = d.getX(f), x = Ll(this, e, ja, c, y, g);
        x && n.push(x);
      }
    } else {
      const f = Math.max(0, r.start), m = Math.min(p.count, r.start + r.count);
      for (let y = f, g = m - 1; y < g; y += u) {
        const x = Ll(this, e, ja, c, y, y + 1);
        x && n.push(x);
      }
      if (this.isLineLoop) {
        const y = Ll(this, e, ja, c, m - 1, f);
        y && n.push(y);
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const o = n[i[0]];
      if (o !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let a = 0, r = o.length; a < r; a++) {
          const l = o[a].name || String(a);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = a;
        }
      }
    }
  }
}
function Ll(s, e, n, i, o, a) {
  const r = s.geometry.attributes.position;
  if (Bc.fromBufferAttribute(r, o), Nc.fromBufferAttribute(r, a), n.distanceSqToSegment(Bc, Nc, b1, o2) > i) return;
  b1.applyMatrix4(s.matrixWorld);
  const c = e.ray.origin.distanceTo(b1);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: o2.clone().applyMatrix4(s.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s
    };
}
const a2 = /* @__PURE__ */ new pe(), r2 = /* @__PURE__ */ new pe();
class Lh extends cn {
  constructor(e, n) {
    super(e, n), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [];
      for (let o = 0, a = n.count; o < a; o += 2)
        a2.fromBufferAttribute(n, o), r2.fromBufferAttribute(n, o + 1), i[o] = o === 0 ? 0 : i[o - 1], i[o + 1] = i[o] + a2.distanceTo(r2);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class k_ extends cn {
  constructor(e, n) {
    super(e, n), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class D_ extends An {
  constructor(e, n, i, o, a, r, l, c, u) {
    super(e, n, i, o, a, r, l, c, u), this.isVideoTexture = !0, this.minFilter = r !== void 0 ? r : Dt, this.magFilter = a !== void 0 ? a : Dt, this.generateMipmaps = !1;
    const d = this;
    function h() {
      d.needsUpdate = !0, e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class Vc extends An {
  constructor(e, n, i, o, a, r, l, c, u) {
    super(e, n, i, o, a, r, l, c, u), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class As {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, n);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return n;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPointAt(i / e));
    return n;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let i, o = this.getPoint(0), a = 0;
    n.push(0);
    for (let r = 1; r <= e; r++)
      i = this.getPoint(r / e), a += i.distanceTo(o), n.push(a), o = i;
    return this.cacheArcLengths = n, n;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, n) {
    const i = this.getLengths();
    let o = 0;
    const a = i.length;
    let r;
    n ? r = n : r = e * i[a - 1];
    let l = 0, c = a - 1, u;
    for (; l <= c; )
      if (o = Math.floor(l + (c - l) / 2), u = i[o] - r, u < 0)
        l = o + 1;
      else if (u > 0)
        c = o - 1;
      else {
        c = o;
        break;
      }
    if (o = c, i[o] === r)
      return o / (a - 1);
    const d = i[o], p = i[o + 1] - d, f = (r - d) / p;
    return (o + f) / (a - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, n) {
    let o = e - 1e-4, a = e + 1e-4;
    o < 0 && (o = 0), a > 1 && (a = 1);
    const r = this.getPoint(o), l = this.getPoint(a), c = n || (r.isVector2 ? new qe() : new pe());
    return c.copy(l).sub(r).normalize(), c;
  }
  getTangentAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, n);
  }
  computeFrenetFrames(e, n) {
    const i = new pe(), o = [], a = [], r = [], l = new pe(), c = new jt();
    for (let f = 0; f <= e; f++) {
      const m = f / e;
      o[f] = this.getTangentAt(m, new pe());
    }
    a[0] = new pe(), r[0] = new pe();
    let u = Number.MAX_VALUE;
    const d = Math.abs(o[0].x), h = Math.abs(o[0].y), p = Math.abs(o[0].z);
    d <= u && (u = d, i.set(1, 0, 0)), h <= u && (u = h, i.set(0, 1, 0)), p <= u && i.set(0, 0, 1), l.crossVectors(o[0], i).normalize(), a[0].crossVectors(o[0], l), r[0].crossVectors(o[0], a[0]);
    for (let f = 1; f <= e; f++) {
      if (a[f] = a[f - 1].clone(), r[f] = r[f - 1].clone(), l.crossVectors(o[f - 1], o[f]), l.length() > Number.EPSILON) {
        l.normalize();
        const m = Math.acos(Nn(o[f - 1].dot(o[f]), -1, 1));
        a[f].applyMatrix4(c.makeRotationAxis(l, m));
      }
      r[f].crossVectors(o[f], a[f]);
    }
    if (n === !0) {
      let f = Math.acos(Nn(a[0].dot(a[e]), -1, 1));
      f /= e, o[0].dot(l.crossVectors(a[0], a[e])) > 0 && (f = -f);
      for (let m = 1; m <= e; m++)
        a[m].applyMatrix4(c.makeRotationAxis(o[m], f * m)), r[m].crossVectors(o[m], a[m]);
    }
    return {
      tangents: o,
      normals: a,
      binormals: r
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Fh extends As {
  constructor(e = 0, n = 0, i = 1, o = 1, a = 0, r = Math.PI * 2, l = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = i, this.yRadius = o, this.aStartAngle = a, this.aEndAngle = r, this.aClockwise = l, this.aRotation = c;
  }
  getPoint(e, n = new qe()) {
    const i = n, o = Math.PI * 2;
    let a = this.aEndAngle - this.aStartAngle;
    const r = Math.abs(a) < Number.EPSILON;
    for (; a < 0; ) a += o;
    for (; a > o; ) a -= o;
    a < Number.EPSILON && (r ? a = 0 : a = o), this.aClockwise === !0 && !r && (a === o ? a = -o : a = a - o);
    const l = this.aStartAngle + e * a;
    let c = this.aX + this.xRadius * Math.cos(l), u = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation), h = Math.sin(this.aRotation), p = c - this.aX, f = u - this.aY;
      c = p * d - f * h + this.aX, u = p * h + f * d + this.aY;
    }
    return i.set(c, u);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class I_ extends Fh {
  constructor(e, n, i, o, a, r) {
    super(e, n, i, i, o, a, r), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Oh() {
  let s = 0, e = 0, n = 0, i = 0;
  function o(a, r, l, c) {
    s = a, e = l, n = -3 * a + 3 * r - 2 * l - c, i = 2 * a - 2 * r + l + c;
  }
  return {
    initCatmullRom: function(a, r, l, c, u) {
      o(r, l, u * (l - a), u * (c - r));
    },
    initNonuniformCatmullRom: function(a, r, l, c, u, d, h) {
      let p = (r - a) / u - (l - a) / (u + d) + (l - r) / d, f = (l - r) / d - (c - r) / (d + h) + (c - l) / h;
      p *= d, f *= d, o(r, l, p, f);
    },
    calc: function(a) {
      const r = a * a, l = r * a;
      return s + e * a + n * r + i * l;
    }
  };
}
const Fl = /* @__PURE__ */ new pe(), _1 = /* @__PURE__ */ new Oh(), w1 = /* @__PURE__ */ new Oh(), M1 = /* @__PURE__ */ new Oh();
class R_ extends As {
  constructor(e = [], n = !1, i = "centripetal", o = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = i, this.tension = o;
  }
  getPoint(e, n = new pe()) {
    const i = n, o = this.points, a = o.length, r = (a - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(r), c = r - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / a) + 1) * a : c === 0 && l === a - 1 && (l = a - 2, c = 1);
    let u, d;
    this.closed || l > 0 ? u = o[(l - 1) % a] : (Fl.subVectors(o[0], o[1]).add(o[0]), u = Fl);
    const h = o[l % a], p = o[(l + 1) % a];
    if (this.closed || l + 2 < a ? d = o[(l + 2) % a] : (Fl.subVectors(o[a - 1], o[a - 2]).add(o[a - 1]), d = Fl), this.curveType === "centripetal" || this.curveType === "chordal") {
      const f = this.curveType === "chordal" ? 0.5 : 0.25;
      let m = Math.pow(u.distanceToSquared(h), f), y = Math.pow(h.distanceToSquared(p), f), g = Math.pow(p.distanceToSquared(d), f);
      y < 1e-4 && (y = 1), m < 1e-4 && (m = y), g < 1e-4 && (g = y), _1.initNonuniformCatmullRom(u.x, h.x, p.x, d.x, m, y, g), w1.initNonuniformCatmullRom(u.y, h.y, p.y, d.y, m, y, g), M1.initNonuniformCatmullRom(u.z, h.z, p.z, d.z, m, y, g);
    } else this.curveType === "catmullrom" && (_1.initCatmullRom(u.x, h.x, p.x, d.x, this.tension), w1.initCatmullRom(u.y, h.y, p.y, d.y, this.tension), M1.initCatmullRom(u.z, h.z, p.z, d.z, this.tension));
    return i.set(
      _1.calc(c),
      w1.calc(c),
      M1.calc(c)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const o = e.points[n];
      this.points.push(o.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const o = this.points[n];
      e.points.push(o.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const o = e.points[n];
      this.points.push(new pe().fromArray(o));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function l2(s, e, n, i, o) {
  const a = (i - e) * 0.5, r = (o - n) * 0.5, l = s * s, c = s * l;
  return (2 * n - 2 * i + a + r) * c + (-3 * n + 3 * i - 2 * a - r) * l + a * s + n;
}
function L_(s, e) {
  const n = 1 - s;
  return n * n * e;
}
function F_(s, e) {
  return 2 * (1 - s) * s * e;
}
function O_(s, e) {
  return s * s * e;
}
function _r(s, e, n, i) {
  return L_(s, e) + F_(s, n) + O_(s, i);
}
function U_(s, e) {
  const n = 1 - s;
  return n * n * n * e;
}
function z_(s, e) {
  const n = 1 - s;
  return 3 * n * n * s * e;
}
function B_(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function N_(s, e) {
  return s * s * s * e;
}
function wr(s, e, n, i, o) {
  return U_(s, e) + z_(s, n) + B_(s, i) + N_(s, o);
}
class Dm extends As {
  constructor(e = new qe(), n = new qe(), i = new qe(), o = new qe()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = o;
  }
  getPoint(e, n = new qe()) {
    const i = n, o = this.v0, a = this.v1, r = this.v2, l = this.v3;
    return i.set(
      wr(e, o.x, a.x, r.x, l.x),
      wr(e, o.y, a.y, r.y, l.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class ro extends As {
  constructor(e = new pe(), n = new pe(), i = new pe(), o = new pe()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = o;
  }
  getPoint(e, n = new pe()) {
    const i = n, o = this.v0, a = this.v1, r = this.v2, l = this.v3;
    return i.set(
      wr(e, o.x, a.x, r.x, l.x),
      wr(e, o.y, a.y, r.y, l.y),
      wr(e, o.z, a.z, r.z, l.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Im extends As {
  constructor(e = new qe(), n = new qe()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new qe()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new qe()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class V_ extends As {
  constructor(e = new pe(), n = new pe()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new pe()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new pe()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Rm extends As {
  constructor(e = new qe(), n = new qe(), i = new qe()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new qe()) {
    const i = n, o = this.v0, a = this.v1, r = this.v2;
    return i.set(
      _r(e, o.x, a.x, r.x),
      _r(e, o.y, a.y, r.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class H_ extends As {
  constructor(e = new pe(), n = new pe(), i = new pe()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new pe()) {
    const i = n, o = this.v0, a = this.v1, r = this.v2;
    return i.set(
      _r(e, o.x, a.x, r.x),
      _r(e, o.y, a.y, r.y),
      _r(e, o.z, a.z, r.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Lm extends As {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, n = new qe()) {
    const i = n, o = this.points, a = (o.length - 1) * e, r = Math.floor(a), l = a - r, c = o[r === 0 ? r : r - 1], u = o[r], d = o[r > o.length - 2 ? o.length - 1 : r + 1], h = o[r > o.length - 3 ? o.length - 1 : r + 2];
    return i.set(
      l2(l, c.x, u.x, d.x, h.x),
      l2(l, c.y, u.y, d.y, h.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const o = e.points[n];
      this.points.push(o.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const o = this.points[n];
      e.points.push(o.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const o = e.points[n];
      this.points.push(new qe().fromArray(o));
    }
    return this;
  }
}
var Gd = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: I_,
  CatmullRomCurve3: R_,
  CubicBezierCurve: Dm,
  CubicBezierCurve3: ro,
  EllipseCurve: Fh,
  LineCurve: Im,
  LineCurve3: V_,
  QuadraticBezierCurve: Rm,
  QuadraticBezierCurve3: H_,
  SplineCurve: Lm
});
class Hc extends As {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Gd[i](n, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, n) {
    const i = e * this.getLength(), o = this.getCurveLengths();
    let a = 0;
    for (; a < o.length; ) {
      if (o[a] >= i) {
        const r = o[a] - i, l = this.curves[a], c = l.getLength(), u = c === 0 ? 0 : 1 - r / c;
        return l.getPointAt(u, n);
      }
      a++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let i = 0, o = this.curves.length; i < o; i++)
      n += this.curves[i].getLength(), e.push(n);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let i;
    for (let o = 0, a = this.curves; o < a.length; o++) {
      const r = a[o], l = r.isEllipseCurve ? e * 2 : r.isLineCurve || r.isLineCurve3 ? 1 : r.isSplineCurve ? e * r.points.length : e, c = r.getPoints(l);
      for (let u = 0; u < c.length; u++) {
        const d = c[u];
        i && i.equals(d) || (n.push(d), i = d);
      }
    }
    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const o = e.curves[n];
      this.curves.push(o.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let n = 0, i = this.curves.length; n < i; n++) {
      const o = this.curves[n];
      e.curves.push(o.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const o = e.curves[n];
      this.curves.push(new Gd[o.type]().fromJSON(o));
    }
    return this;
  }
}
class c2 extends Hc {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new qe(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, i = e.length; n < i; n++)
      this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const i = new Im(this.currentPoint.clone(), new qe(e, n));
    return this.curves.push(i), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, i, o) {
    const a = new Rm(
      this.currentPoint.clone(),
      new qe(e, n),
      new qe(i, o)
    );
    return this.curves.push(a), this.currentPoint.set(i, o), this;
  }
  bezierCurveTo(e, n, i, o, a, r) {
    const l = new Dm(
      this.currentPoint.clone(),
      new qe(e, n),
      new qe(i, o),
      new qe(a, r)
    );
    return this.curves.push(l), this.currentPoint.set(a, r), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e), i = new Lm(n);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, i, o, a, r) {
    const l = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + l,
      n + c,
      i,
      o,
      a,
      r
    ), this;
  }
  absarc(e, n, i, o, a, r) {
    return this.absellipse(e, n, i, i, o, a, r), this;
  }
  ellipse(e, n, i, o, a, r, l, c) {
    const u = this.currentPoint.x, d = this.currentPoint.y;
    return this.absellipse(e + u, n + d, i, o, a, r, l, c), this;
  }
  absellipse(e, n, i, o, a, r, l, c) {
    const u = new Fh(e, n, i, o, a, r, l, c);
    if (this.curves.length > 0) {
      const h = u.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(u);
    const d = u.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class pu extends Ut {
  constructor(e = 1, n = 32, i = 0, o = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: n,
      thetaStart: i,
      thetaLength: o
    }, n = Math.max(3, n);
    const a = [], r = [], l = [], c = [], u = new pe(), d = new qe();
    r.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let h = 0, p = 3; h <= n; h++, p += 3) {
      const f = i + h / n * o;
      u.x = e * Math.cos(f), u.y = e * Math.sin(f), r.push(u.x, u.y, u.z), l.push(0, 0, 1), d.x = (r[p] / e + 1) / 2, d.y = (r[p + 1] / e + 1) / 2, c.push(d.x, d.y);
    }
    for (let h = 1; h <= n; h++)
      a.push(h, h + 1, 0);
    this.setIndex(a), this.setAttribute("position", new Pt(r, 3)), this.setAttribute("normal", new Pt(l, 3)), this.setAttribute("uv", new Pt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pu(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Wn extends Ut {
  constructor(e = 1, n = 1, i = 1, o = 32, a = 1, r = !1, l = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: i,
      radialSegments: o,
      heightSegments: a,
      openEnded: r,
      thetaStart: l,
      thetaLength: c
    };
    const u = this;
    o = Math.floor(o), a = Math.floor(a);
    const d = [], h = [], p = [], f = [];
    let m = 0;
    const y = [], g = i / 2;
    let x = 0;
    w(), r === !1 && (e > 0 && M(!0), n > 0 && M(!1)), this.setIndex(d), this.setAttribute("position", new Pt(h, 3)), this.setAttribute("normal", new Pt(p, 3)), this.setAttribute("uv", new Pt(f, 2));
    function w() {
      const _ = new pe(), C = new pe();
      let T = 0;
      const P = (n - e) / i;
      for (let E = 0; E <= a; E++) {
        const b = [], S = E / a, A = S * (n - e) + e;
        for (let R = 0; R <= o; R++) {
          const k = R / o, U = k * c + l, I = Math.sin(U), W = Math.cos(U);
          C.x = A * I, C.y = -S * i + g, C.z = A * W, h.push(C.x, C.y, C.z), _.set(I, P, W).normalize(), p.push(_.x, _.y, _.z), f.push(k, 1 - S), b.push(m++);
        }
        y.push(b);
      }
      for (let E = 0; E < o; E++)
        for (let b = 0; b < a; b++) {
          const S = y[b][E], A = y[b + 1][E], R = y[b + 1][E + 1], k = y[b][E + 1];
          (e > 0 || b !== 0) && (d.push(S, A, k), T += 3), (n > 0 || b !== a - 1) && (d.push(A, R, k), T += 3);
        }
      u.addGroup(x, T, 0), x += T;
    }
    function M(_) {
      const C = m, T = new qe(), P = new pe();
      let E = 0;
      const b = _ === !0 ? e : n, S = _ === !0 ? 1 : -1;
      for (let R = 1; R <= o; R++)
        h.push(0, g * S, 0), p.push(0, S, 0), f.push(0.5, 0.5), m++;
      const A = m;
      for (let R = 0; R <= o; R++) {
        const U = R / o * c + l, I = Math.cos(U), W = Math.sin(U);
        P.x = b * W, P.y = g * S, P.z = b * I, h.push(P.x, P.y, P.z), p.push(0, S, 0), T.x = I * 0.5 + 0.5, T.y = W * 0.5 * S + 0.5, f.push(T.x, T.y), m++;
      }
      for (let R = 0; R < o; R++) {
        const k = C + R, U = A + R;
        _ === !0 ? d.push(U, U + 1, k) : d.push(U + 1, U, k), E += 3;
      }
      u.addGroup(x, E, _ === !0 ? 1 : 2), x += E;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Wn(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Uh extends Wn {
  constructor(e = 1, n = 1, i = 32, o = 1, a = !1, r = 0, l = Math.PI * 2) {
    super(0, e, n, i, o, a, r, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: n,
      radialSegments: i,
      heightSegments: o,
      openEnded: a,
      thetaStart: r,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new Uh(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class zh extends Ut {
  constructor(e = [], n = [], i = 1, o = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: n,
      radius: i,
      detail: o
    };
    const a = [], r = [];
    l(o), u(i), d(), this.setAttribute("position", new Pt(a, 3)), this.setAttribute("normal", new Pt(a.slice(), 3)), this.setAttribute("uv", new Pt(r, 2)), o === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(w) {
      const M = new pe(), _ = new pe(), C = new pe();
      for (let T = 0; T < n.length; T += 3)
        f(n[T + 0], M), f(n[T + 1], _), f(n[T + 2], C), c(M, _, C, w);
    }
    function c(w, M, _, C) {
      const T = C + 1, P = [];
      for (let E = 0; E <= T; E++) {
        P[E] = [];
        const b = w.clone().lerp(_, E / T), S = M.clone().lerp(_, E / T), A = T - E;
        for (let R = 0; R <= A; R++)
          R === 0 && E === T ? P[E][R] = b : P[E][R] = b.clone().lerp(S, R / A);
      }
      for (let E = 0; E < T; E++)
        for (let b = 0; b < 2 * (T - E) - 1; b++) {
          const S = Math.floor(b / 2);
          b % 2 === 0 ? (p(P[E][S + 1]), p(P[E + 1][S]), p(P[E][S])) : (p(P[E][S + 1]), p(P[E + 1][S + 1]), p(P[E + 1][S]));
        }
    }
    function u(w) {
      const M = new pe();
      for (let _ = 0; _ < a.length; _ += 3)
        M.x = a[_ + 0], M.y = a[_ + 1], M.z = a[_ + 2], M.normalize().multiplyScalar(w), a[_ + 0] = M.x, a[_ + 1] = M.y, a[_ + 2] = M.z;
    }
    function d() {
      const w = new pe();
      for (let M = 0; M < a.length; M += 3) {
        w.x = a[M + 0], w.y = a[M + 1], w.z = a[M + 2];
        const _ = g(w) / 2 / Math.PI + 0.5, C = x(w) / Math.PI + 0.5;
        r.push(_, 1 - C);
      }
      m(), h();
    }
    function h() {
      for (let w = 0; w < r.length; w += 6) {
        const M = r[w + 0], _ = r[w + 2], C = r[w + 4], T = Math.max(M, _, C), P = Math.min(M, _, C);
        T > 0.9 && P < 0.1 && (M < 0.2 && (r[w + 0] += 1), _ < 0.2 && (r[w + 2] += 1), C < 0.2 && (r[w + 4] += 1));
      }
    }
    function p(w) {
      a.push(w.x, w.y, w.z);
    }
    function f(w, M) {
      const _ = w * 3;
      M.x = e[_ + 0], M.y = e[_ + 1], M.z = e[_ + 2];
    }
    function m() {
      const w = new pe(), M = new pe(), _ = new pe(), C = new pe(), T = new qe(), P = new qe(), E = new qe();
      for (let b = 0, S = 0; b < a.length; b += 9, S += 6) {
        w.set(a[b + 0], a[b + 1], a[b + 2]), M.set(a[b + 3], a[b + 4], a[b + 5]), _.set(a[b + 6], a[b + 7], a[b + 8]), T.set(r[S + 0], r[S + 1]), P.set(r[S + 2], r[S + 3]), E.set(r[S + 4], r[S + 5]), C.copy(w).add(M).add(_).divideScalar(3);
        const A = g(C);
        y(T, S + 0, w, A), y(P, S + 2, M, A), y(E, S + 4, _, A);
      }
    }
    function y(w, M, _, C) {
      C < 0 && w.x === 1 && (r[M] = w.x - 1), _.x === 0 && _.z === 0 && (r[M] = C / 2 / Math.PI + 0.5);
    }
    function g(w) {
      return Math.atan2(w.z, -w.x);
    }
    function x(w) {
      return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new zh(e.vertices, e.indices, e.radius, e.details);
  }
}
class mu extends c2 {
  constructor(e) {
    super(e), this.uuid = bo(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const n = [];
    for (let i = 0, o = this.holes.length; i < o; i++)
      n[i] = this.holes[i].getPoints(e);
    return n;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const o = e.holes[n];
      this.holes.push(o.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let n = 0, i = this.holes.length; n < i; n++) {
      const o = this.holes[n];
      e.holes.push(o.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const o = e.holes[n];
      this.holes.push(new c2().fromJSON(o));
    }
    return this;
  }
}
const G_ = {
  triangulate: function(s, e, n = 2) {
    const i = e && e.length, o = i ? e[0] * n : s.length;
    let a = Fm(s, 0, o, n, !0);
    const r = [];
    if (!a || a.next === a.prev) return r;
    let l, c, u, d, h, p, f;
    if (i && (a = Y_(s, e, a, n)), s.length > 80 * n) {
      l = u = s[0], c = d = s[1];
      for (let m = n; m < o; m += n)
        h = s[m], p = s[m + 1], h < l && (l = h), p < c && (c = p), h > u && (u = h), p > d && (d = p);
      f = Math.max(u - l, d - c), f = f !== 0 ? 32767 / f : 0;
    }
    return Vr(a, r, n, l, c, f, 0), r;
  }
};
function Fm(s, e, n, i, o) {
  let a, r;
  if (o === ow(s, e, n, i) > 0)
    for (a = e; a < n; a += i) r = u2(a, s[a], s[a + 1], r);
  else
    for (a = n - i; a >= e; a -= i) r = u2(a, s[a], s[a + 1], r);
  return r && vu(r, r.next) && (Gr(r), r = r.next), r;
}
function yo(s, e) {
  if (!s) return s;
  e || (e = s);
  let n = s, i;
  do
    if (i = !1, !n.steiner && (vu(n, n.next) || yn(n.prev, n, n.next) === 0)) {
      if (Gr(n), n = e = n.prev, n === n.next) break;
      i = !0;
    } else
      n = n.next;
  while (i || n !== e);
  return e;
}
function Vr(s, e, n, i, o, a, r) {
  if (!s) return;
  !r && a && Q_(s, i, o, a);
  let l = s, c, u;
  for (; s.prev !== s.next; ) {
    if (c = s.prev, u = s.next, a ? W_(s, i, o, a) : $_(s)) {
      e.push(c.i / n | 0), e.push(s.i / n | 0), e.push(u.i / n | 0), Gr(s), s = u.next, l = u.next;
      continue;
    }
    if (s = u, s === l) {
      r ? r === 1 ? (s = j_(yo(s), e, n), Vr(s, e, n, i, o, a, 2)) : r === 2 && X_(s, e, n, i, o, a) : Vr(yo(s), e, n, i, o, a, 1);
      break;
    }
  }
}
function $_(s) {
  const e = s.prev, n = s, i = s.next;
  if (yn(e, n, i) >= 0) return !1;
  const o = e.x, a = n.x, r = i.x, l = e.y, c = n.y, u = i.y, d = o < a ? o < r ? o : r : a < r ? a : r, h = l < c ? l < u ? l : u : c < u ? c : u, p = o > a ? o > r ? o : r : a > r ? a : r, f = l > c ? l > u ? l : u : c > u ? c : u;
  let m = i.next;
  for (; m !== e; ) {
    if (m.x >= d && m.x <= p && m.y >= h && m.y <= f && Jo(o, l, a, c, r, u, m.x, m.y) && yn(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function W_(s, e, n, i) {
  const o = s.prev, a = s, r = s.next;
  if (yn(o, a, r) >= 0) return !1;
  const l = o.x, c = a.x, u = r.x, d = o.y, h = a.y, p = r.y, f = l < c ? l < u ? l : u : c < u ? c : u, m = d < h ? d < p ? d : p : h < p ? h : p, y = l > c ? l > u ? l : u : c > u ? c : u, g = d > h ? d > p ? d : p : h > p ? h : p, x = $d(f, m, e, n, i), w = $d(y, g, e, n, i);
  let M = s.prevZ, _ = s.nextZ;
  for (; M && M.z >= x && _ && _.z <= w; ) {
    if (M.x >= f && M.x <= y && M.y >= m && M.y <= g && M !== o && M !== r && Jo(l, d, c, h, u, p, M.x, M.y) && yn(M.prev, M, M.next) >= 0 || (M = M.prevZ, _.x >= f && _.x <= y && _.y >= m && _.y <= g && _ !== o && _ !== r && Jo(l, d, c, h, u, p, _.x, _.y) && yn(_.prev, _, _.next) >= 0)) return !1;
    _ = _.nextZ;
  }
  for (; M && M.z >= x; ) {
    if (M.x >= f && M.x <= y && M.y >= m && M.y <= g && M !== o && M !== r && Jo(l, d, c, h, u, p, M.x, M.y) && yn(M.prev, M, M.next) >= 0) return !1;
    M = M.prevZ;
  }
  for (; _ && _.z <= w; ) {
    if (_.x >= f && _.x <= y && _.y >= m && _.y <= g && _ !== o && _ !== r && Jo(l, d, c, h, u, p, _.x, _.y) && yn(_.prev, _, _.next) >= 0) return !1;
    _ = _.nextZ;
  }
  return !0;
}
function j_(s, e, n) {
  let i = s;
  do {
    const o = i.prev, a = i.next.next;
    !vu(o, a) && Om(o, i, i.next, a) && Hr(o, a) && Hr(a, o) && (e.push(o.i / n | 0), e.push(i.i / n | 0), e.push(a.i / n | 0), Gr(i), Gr(i.next), i = s = a), i = i.next;
  } while (i !== s);
  return yo(i);
}
function X_(s, e, n, i, o, a) {
  let r = s;
  do {
    let l = r.next.next;
    for (; l !== r.prev; ) {
      if (r.i !== l.i && nw(r, l)) {
        let c = Um(r, l);
        r = yo(r, r.next), c = yo(c, c.next), Vr(r, e, n, i, o, a, 0), Vr(c, e, n, i, o, a, 0);
        return;
      }
      l = l.next;
    }
    r = r.next;
  } while (r !== s);
}
function Y_(s, e, n, i) {
  const o = [];
  let a, r, l, c, u;
  for (a = 0, r = e.length; a < r; a++)
    l = e[a] * i, c = a < r - 1 ? e[a + 1] * i : s.length, u = Fm(s, l, c, i, !1), u === u.next && (u.steiner = !0), o.push(tw(u));
  for (o.sort(q_), a = 0; a < o.length; a++)
    n = Z_(o[a], n);
  return n;
}
function q_(s, e) {
  return s.x - e.x;
}
function Z_(s, e) {
  const n = K_(s, e);
  if (!n)
    return e;
  const i = Um(n, s);
  return yo(i, i.next), yo(n, n.next);
}
function K_(s, e) {
  let n = e, i = -1 / 0, o;
  const a = s.x, r = s.y;
  do {
    if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
      const p = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (p <= a && p > i && (i = p, o = n.x < n.next.x ? n : n.next, p === a))
        return o;
    }
    n = n.next;
  } while (n !== e);
  if (!o) return null;
  const l = o, c = o.x, u = o.y;
  let d = 1 / 0, h;
  n = o;
  do
    a >= n.x && n.x >= c && a !== n.x && Jo(r < u ? a : i, r, c, u, r < u ? i : a, r, n.x, n.y) && (h = Math.abs(r - n.y) / (a - n.x), Hr(n, s) && (h < d || h === d && (n.x > o.x || n.x === o.x && J_(o, n))) && (o = n, d = h)), n = n.next;
  while (n !== l);
  return o;
}
function J_(s, e) {
  return yn(s.prev, s, e.prev) < 0 && yn(e.next, s, s.next) < 0;
}
function Q_(s, e, n, i) {
  let o = s;
  do
    o.z === 0 && (o.z = $d(o.x, o.y, e, n, i)), o.prevZ = o.prev, o.nextZ = o.next, o = o.next;
  while (o !== s);
  o.prevZ.nextZ = null, o.prevZ = null, ew(o);
}
function ew(s) {
  let e, n, i, o, a, r, l, c, u = 1;
  do {
    for (n = s, s = null, a = null, r = 0; n; ) {
      for (r++, i = n, l = 0, e = 0; e < u && (l++, i = i.nextZ, !!i); e++)
        ;
      for (c = u; l > 0 || c > 0 && i; )
        l !== 0 && (c === 0 || !i || n.z <= i.z) ? (o = n, n = n.nextZ, l--) : (o = i, i = i.nextZ, c--), a ? a.nextZ = o : s = o, o.prevZ = a, a = o;
      n = i;
    }
    a.nextZ = null, u *= 2;
  } while (r > 1);
  return s;
}
function $d(s, e, n, i, o) {
  return s = (s - n) * o | 0, e = (e - i) * o | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function tw(s) {
  let e = s, n = s;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== s);
  return n;
}
function Jo(s, e, n, i, o, a, r, l) {
  return (o - r) * (e - l) >= (s - r) * (a - l) && (s - r) * (i - l) >= (n - r) * (e - l) && (n - r) * (a - l) >= (o - r) * (i - l);
}
function nw(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !iw(s, e) && // dones't intersect other edges
  (Hr(s, e) && Hr(e, s) && sw(s, e) && // locally visible
  (yn(s.prev, s, e.prev) || yn(s, e.prev, e)) || // does not create opposite-facing sectors
  vu(s, e) && yn(s.prev, s, s.next) > 0 && yn(e.prev, e, e.next) > 0);
}
function yn(s, e, n) {
  return (e.y - s.y) * (n.x - e.x) - (e.x - s.x) * (n.y - e.y);
}
function vu(s, e) {
  return s.x === e.x && s.y === e.y;
}
function Om(s, e, n, i) {
  const o = Ul(yn(s, e, n)), a = Ul(yn(s, e, i)), r = Ul(yn(n, i, s)), l = Ul(yn(n, i, e));
  return !!(o !== a && r !== l || o === 0 && Ol(s, n, e) || a === 0 && Ol(s, i, e) || r === 0 && Ol(n, s, i) || l === 0 && Ol(n, e, i));
}
function Ol(s, e, n) {
  return e.x <= Math.max(s.x, n.x) && e.x >= Math.min(s.x, n.x) && e.y <= Math.max(s.y, n.y) && e.y >= Math.min(s.y, n.y);
}
function Ul(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function iw(s, e) {
  let n = s;
  do {
    if (n.i !== s.i && n.next.i !== s.i && n.i !== e.i && n.next.i !== e.i && Om(n, n.next, s, e)) return !0;
    n = n.next;
  } while (n !== s);
  return !1;
}
function Hr(s, e) {
  return yn(s.prev, s, s.next) < 0 ? yn(s, e, s.next) >= 0 && yn(s, s.prev, e) >= 0 : yn(s, e, s.prev) < 0 || yn(s, s.next, e) < 0;
}
function sw(s, e) {
  let n = s, i = !1;
  const o = (s.x + e.x) / 2, a = (s.y + e.y) / 2;
  do
    n.y > a != n.next.y > a && n.next.y !== n.y && o < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
  while (n !== s);
  return i;
}
function Um(s, e) {
  const n = new Wd(s.i, s.x, s.y), i = new Wd(e.i, e.x, e.y), o = s.next, a = e.prev;
  return s.next = e, e.prev = s, n.next = o, o.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i;
}
function u2(s, e, n, i) {
  const o = new Wd(s, e, n);
  return i ? (o.next = i.next, o.prev = i, i.next.prev = o, i.next = o) : (o.prev = o, o.next = o), o;
}
function Gr(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Wd(s, e, n) {
  this.i = s, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function ow(s, e, n, i) {
  let o = 0;
  for (let a = e, r = n - i; a < n; a += i)
    o += (s[r] - s[a]) * (s[a + 1] + s[r + 1]), r = a;
  return o;
}
class I0 {
  // calculate area of the contour polygon
  static area(e) {
    const n = e.length;
    let i = 0;
    for (let o = n - 1, a = 0; a < n; o = a++)
      i += e[o].x * e[a].y - e[a].x * e[o].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return I0.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const i = [], o = [], a = [];
    d2(e), h2(i, e);
    let r = e.length;
    n.forEach(d2);
    for (let c = 0; c < n.length; c++)
      o.push(r), r += n[c].length, h2(i, n[c]);
    const l = G_.triangulate(i, o);
    for (let c = 0; c < l.length; c += 3)
      a.push(l.slice(c, c + 3));
    return a;
  }
}
function d2(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function h2(s, e) {
  for (let n = 0; n < e.length; n++)
    s.push(e[n].x), s.push(e[n].y);
}
class Bh extends Ut {
  constructor(e = new mu([new qe(0.5, 0.5), new qe(-0.5, 0.5), new qe(-0.5, -0.5), new qe(0.5, -0.5)]), n = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: n
    }, e = Array.isArray(e) ? e : [e];
    const i = this, o = [], a = [];
    for (let l = 0, c = e.length; l < c; l++) {
      const u = e[l];
      r(u);
    }
    this.setAttribute("position", new Pt(o, 3)), this.setAttribute("uv", new Pt(a, 2)), this.computeVertexNormals();
    function r(l) {
      const c = [], u = n.curveSegments !== void 0 ? n.curveSegments : 12, d = n.steps !== void 0 ? n.steps : 1, h = n.depth !== void 0 ? n.depth : 1;
      let p = n.bevelEnabled !== void 0 ? n.bevelEnabled : !0, f = n.bevelThickness !== void 0 ? n.bevelThickness : 0.2, m = n.bevelSize !== void 0 ? n.bevelSize : f - 0.1, y = n.bevelOffset !== void 0 ? n.bevelOffset : 0, g = n.bevelSegments !== void 0 ? n.bevelSegments : 3;
      const x = n.extrudePath, w = n.UVGenerator !== void 0 ? n.UVGenerator : aw;
      let M, _ = !1, C, T, P, E;
      x && (M = x.getSpacedPoints(d), _ = !0, p = !1, C = x.computeFrenetFrames(d, !1), T = new pe(), P = new pe(), E = new pe()), p || (g = 0, f = 0, m = 0, y = 0);
      const b = l.extractPoints(u);
      let S = b.shape;
      const A = b.holes;
      if (!I0.isClockWise(S)) {
        S = S.reverse();
        for (let F = 0, B = A.length; F < B; F++) {
          const L = A[F];
          I0.isClockWise(L) && (A[F] = L.reverse());
        }
      }
      const k = I0.triangulateShape(S, A), U = S;
      for (let F = 0, B = A.length; F < B; F++) {
        const L = A[F];
        S = S.concat(L);
      }
      function I(F, B, L) {
        return B || console.error("THREE.ExtrudeGeometry: vec does not exist"), F.clone().addScaledVector(B, L);
      }
      const W = S.length, fe = k.length;
      function q(F, B, L) {
        let D, j, Z;
        const z = F.x - B.x, $ = F.y - B.y, oe = L.x - F.x, O = L.y - F.y, V = z * z + $ * $, H = z * O - $ * oe;
        if (Math.abs(H) > Number.EPSILON) {
          const X = Math.sqrt(V), ue = Math.sqrt(oe * oe + O * O), me = B.x - $ / X, _e = B.y + z / X, we = L.x - O / ue, Ae = L.y + oe / ue, Ve = ((we - me) * O - (Ae - _e) * oe) / (z * O - $ * oe);
          D = me + z * Ve - F.x, j = _e + $ * Ve - F.y;
          const Fe = D * D + j * j;
          if (Fe <= 2)
            return new qe(D, j);
          Z = Math.sqrt(Fe / 2);
        } else {
          let X = !1;
          z > Number.EPSILON ? oe > Number.EPSILON && (X = !0) : z < -Number.EPSILON ? oe < -Number.EPSILON && (X = !0) : Math.sign($) === Math.sign(O) && (X = !0), X ? (D = -$, j = z, Z = Math.sqrt(V)) : (D = z, j = $, Z = Math.sqrt(V / 2));
        }
        return new qe(D / Z, j / Z);
      }
      const G = [];
      for (let F = 0, B = U.length, L = B - 1, D = F + 1; F < B; F++, L++, D++)
        L === B && (L = 0), D === B && (D = 0), G[F] = q(U[F], U[L], U[D]);
      const Q = [];
      let K, Y = G.concat();
      for (let F = 0, B = A.length; F < B; F++) {
        const L = A[F];
        K = [];
        for (let D = 0, j = L.length, Z = j - 1, z = D + 1; D < j; D++, Z++, z++)
          Z === j && (Z = 0), z === j && (z = 0), K[D] = q(L[D], L[Z], L[z]);
        Q.push(K), Y = Y.concat(K);
      }
      for (let F = 0; F < g; F++) {
        const B = F / g, L = f * Math.cos(B * Math.PI / 2), D = m * Math.sin(B * Math.PI / 2) + y;
        for (let j = 0, Z = U.length; j < Z; j++) {
          const z = I(U[j], G[j], D);
          ie(z.x, z.y, -L);
        }
        for (let j = 0, Z = A.length; j < Z; j++) {
          const z = A[j];
          K = Q[j];
          for (let $ = 0, oe = z.length; $ < oe; $++) {
            const O = I(z[$], K[$], D);
            ie(O.x, O.y, -L);
          }
        }
      }
      const ee = m + y;
      for (let F = 0; F < W; F++) {
        const B = p ? I(S[F], Y[F], ee) : S[F];
        _ ? (P.copy(C.normals[0]).multiplyScalar(B.x), T.copy(C.binormals[0]).multiplyScalar(B.y), E.copy(M[0]).add(P).add(T), ie(E.x, E.y, E.z)) : ie(B.x, B.y, 0);
      }
      for (let F = 1; F <= d; F++)
        for (let B = 0; B < W; B++) {
          const L = p ? I(S[B], Y[B], ee) : S[B];
          _ ? (P.copy(C.normals[F]).multiplyScalar(L.x), T.copy(C.binormals[F]).multiplyScalar(L.y), E.copy(M[F]).add(P).add(T), ie(E.x, E.y, E.z)) : ie(L.x, L.y, h / d * F);
        }
      for (let F = g - 1; F >= 0; F--) {
        const B = F / g, L = f * Math.cos(B * Math.PI / 2), D = m * Math.sin(B * Math.PI / 2) + y;
        for (let j = 0, Z = U.length; j < Z; j++) {
          const z = I(U[j], G[j], D);
          ie(z.x, z.y, h + L);
        }
        for (let j = 0, Z = A.length; j < Z; j++) {
          const z = A[j];
          K = Q[j];
          for (let $ = 0, oe = z.length; $ < oe; $++) {
            const O = I(z[$], K[$], D);
            _ ? ie(O.x, O.y + M[d - 1].y, M[d - 1].x + L) : ie(O.x, O.y, h + L);
          }
        }
      }
      ce(), ae();
      function ce() {
        const F = o.length / 3;
        if (p) {
          let B = 0, L = W * B;
          for (let D = 0; D < fe; D++) {
            const j = k[D];
            he(j[2] + L, j[1] + L, j[0] + L);
          }
          B = d + g * 2, L = W * B;
          for (let D = 0; D < fe; D++) {
            const j = k[D];
            he(j[0] + L, j[1] + L, j[2] + L);
          }
        } else {
          for (let B = 0; B < fe; B++) {
            const L = k[B];
            he(L[2], L[1], L[0]);
          }
          for (let B = 0; B < fe; B++) {
            const L = k[B];
            he(L[0] + W * d, L[1] + W * d, L[2] + W * d);
          }
        }
        i.addGroup(F, o.length / 3 - F, 0);
      }
      function ae() {
        const F = o.length / 3;
        let B = 0;
        de(U, B), B += U.length;
        for (let L = 0, D = A.length; L < D; L++) {
          const j = A[L];
          de(j, B), B += j.length;
        }
        i.addGroup(F, o.length / 3 - F, 1);
      }
      function de(F, B) {
        let L = F.length;
        for (; --L >= 0; ) {
          const D = L;
          let j = L - 1;
          j < 0 && (j = F.length - 1);
          for (let Z = 0, z = d + g * 2; Z < z; Z++) {
            const $ = W * Z, oe = W * (Z + 1), O = B + D + $, V = B + j + $, H = B + j + oe, X = B + D + oe;
            ne(O, V, H, X);
          }
        }
      }
      function ie(F, B, L) {
        c.push(F), c.push(B), c.push(L);
      }
      function he(F, B, L) {
        N(F), N(B), N(L);
        const D = o.length / 3, j = w.generateTopUV(i, o, D - 3, D - 2, D - 1);
        te(j[0]), te(j[1]), te(j[2]);
      }
      function ne(F, B, L, D) {
        N(F), N(B), N(D), N(B), N(L), N(D);
        const j = o.length / 3, Z = w.generateSideWallUV(i, o, j - 6, j - 3, j - 2, j - 1);
        te(Z[0]), te(Z[1]), te(Z[3]), te(Z[1]), te(Z[2]), te(Z[3]);
      }
      function N(F) {
        o.push(c[F * 3 + 0]), o.push(c[F * 3 + 1]), o.push(c[F * 3 + 2]);
      }
      function te(F) {
        a.push(F.x), a.push(F.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes, i = this.parameters.options;
    return rw(n, i, e);
  }
  static fromJSON(e, n) {
    const i = [];
    for (let a = 0, r = e.shapes.length; a < r; a++) {
      const l = n[e.shapes[a]];
      i.push(l);
    }
    const o = e.options.extrudePath;
    return o !== void 0 && (e.options.extrudePath = new Gd[o.type]().fromJSON(o)), new Bh(i, e.options);
  }
}
const aw = {
  generateTopUV: function(s, e, n, i, o) {
    const a = e[n * 3], r = e[n * 3 + 1], l = e[i * 3], c = e[i * 3 + 1], u = e[o * 3], d = e[o * 3 + 1];
    return [
      new qe(a, r),
      new qe(l, c),
      new qe(u, d)
    ];
  },
  generateSideWallUV: function(s, e, n, i, o, a) {
    const r = e[n * 3], l = e[n * 3 + 1], c = e[n * 3 + 2], u = e[i * 3], d = e[i * 3 + 1], h = e[i * 3 + 2], p = e[o * 3], f = e[o * 3 + 1], m = e[o * 3 + 2], y = e[a * 3], g = e[a * 3 + 1], x = e[a * 3 + 2];
    return Math.abs(l - d) < Math.abs(r - u) ? [
      new qe(r, 1 - c),
      new qe(u, 1 - h),
      new qe(p, 1 - m),
      new qe(y, 1 - x)
    ] : [
      new qe(l, 1 - c),
      new qe(d, 1 - h),
      new qe(f, 1 - m),
      new qe(g, 1 - x)
    ];
  }
};
function rw(s, e, n) {
  if (n.shapes = [], Array.isArray(s))
    for (let i = 0, o = s.length; i < o; i++) {
      const a = s[i];
      n.shapes.push(a.uuid);
    }
  else
    n.shapes.push(s.uuid);
  return n.options = Object.assign({}, e), e.extrudePath !== void 0 && (n.options.extrudePath = e.extrudePath.toJSON()), n;
}
class Qo extends zh {
  constructor(e = 1, n = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], o = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, o, e, n), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  static fromJSON(e) {
    return new Qo(e.radius, e.detail);
  }
}
class Nh extends Ut {
  constructor(e = new mu([new qe(0, 0.5), new qe(-0.5, -0.5), new qe(0.5, -0.5)]), n = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const i = [], o = [], a = [], r = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      u(e);
    else
      for (let d = 0; d < e.length; d++)
        u(e[d]), this.addGroup(l, c, d), l += c, c = 0;
    this.setIndex(i), this.setAttribute("position", new Pt(o, 3)), this.setAttribute("normal", new Pt(a, 3)), this.setAttribute("uv", new Pt(r, 2));
    function u(d) {
      const h = o.length / 3, p = d.extractPoints(n);
      let f = p.shape;
      const m = p.holes;
      I0.isClockWise(f) === !1 && (f = f.reverse());
      for (let g = 0, x = m.length; g < x; g++) {
        const w = m[g];
        I0.isClockWise(w) === !0 && (m[g] = w.reverse());
      }
      const y = I0.triangulateShape(f, m);
      for (let g = 0, x = m.length; g < x; g++) {
        const w = m[g];
        f = f.concat(w);
      }
      for (let g = 0, x = f.length; g < x; g++) {
        const w = f[g];
        o.push(w.x, w.y, 0), a.push(0, 0, 1), r.push(w.x, w.y);
      }
      for (let g = 0, x = y.length; g < x; g++) {
        const w = y[g], M = w[0] + h, _ = w[1] + h, C = w[2] + h;
        i.push(M, _, C), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes;
    return lw(n, e);
  }
  static fromJSON(e, n) {
    const i = [];
    for (let o = 0, a = e.shapes.length; o < a; o++) {
      const r = n[e.shapes[o]];
      i.push(r);
    }
    return new Nh(i, e.curveSegments);
  }
}
function lw(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const o = s[n];
      e.shapes.push(o.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class gu extends Ut {
  constructor(e = 1, n = 32, i = 16, o = 0, a = Math.PI * 2, r = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: i,
      phiStart: o,
      phiLength: a,
      thetaStart: r,
      thetaLength: l
    }, n = Math.max(3, Math.floor(n)), i = Math.max(2, Math.floor(i));
    const c = Math.min(r + l, Math.PI);
    let u = 0;
    const d = [], h = new pe(), p = new pe(), f = [], m = [], y = [], g = [];
    for (let x = 0; x <= i; x++) {
      const w = [], M = x / i;
      let _ = 0;
      x === 0 && r === 0 ? _ = 0.5 / n : x === i && c === Math.PI && (_ = -0.5 / n);
      for (let C = 0; C <= n; C++) {
        const T = C / n;
        h.x = -e * Math.cos(o + T * a) * Math.sin(r + M * l), h.y = e * Math.cos(r + M * l), h.z = e * Math.sin(o + T * a) * Math.sin(r + M * l), m.push(h.x, h.y, h.z), p.copy(h).normalize(), y.push(p.x, p.y, p.z), g.push(T + _, 1 - M), w.push(u++);
      }
      d.push(w);
    }
    for (let x = 0; x < i; x++)
      for (let w = 0; w < n; w++) {
        const M = d[x][w + 1], _ = d[x][w], C = d[x + 1][w], T = d[x + 1][w + 1];
        (x !== 0 || r > 0) && f.push(M, _, T), (x !== i - 1 || c < Math.PI) && f.push(_, C, T);
      }
    this.setIndex(f), this.setAttribute("position", new Pt(m, 3)), this.setAttribute("normal", new Pt(y, 3)), this.setAttribute("uv", new Pt(g, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new gu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class io extends Ut {
  constructor(e = 1, n = 0.4, i = 12, o = 48, a = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: n,
      radialSegments: i,
      tubularSegments: o,
      arc: a
    }, i = Math.floor(i), o = Math.floor(o);
    const r = [], l = [], c = [], u = [], d = new pe(), h = new pe(), p = new pe();
    for (let f = 0; f <= i; f++)
      for (let m = 0; m <= o; m++) {
        const y = m / o * a, g = f / i * Math.PI * 2;
        h.x = (e + n * Math.cos(g)) * Math.cos(y), h.y = (e + n * Math.cos(g)) * Math.sin(y), h.z = n * Math.sin(g), l.push(h.x, h.y, h.z), d.x = e * Math.cos(y), d.y = e * Math.sin(y), p.subVectors(h, d).normalize(), c.push(p.x, p.y, p.z), u.push(m / o), u.push(f / i);
      }
    for (let f = 1; f <= i; f++)
      for (let m = 1; m <= o; m++) {
        const y = (o + 1) * f + m - 1, g = (o + 1) * (f - 1) + m - 1, x = (o + 1) * (f - 1) + m, w = (o + 1) * f + m;
        r.push(y, g, w), r.push(g, x, w);
      }
    this.setIndex(r), this.setAttribute("position", new Pt(l, 3)), this.setAttribute("normal", new Pt(c, 3)), this.setAttribute("uv", new Pt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new io(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class cw extends dn {
  static get type() {
    return "RawShaderMaterial";
  }
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0;
  }
}
class zm extends _o {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Mt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Mt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Eh, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Hi(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Bm extends _o {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Eh, this.normalScale = new qe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
const f2 = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class uw {
  constructor(e, n, i) {
    const o = this;
    let a = !1, r = 0, l = 0, c;
    const u = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = i, this.itemStart = function(d) {
      l++, a === !1 && o.onStart !== void 0 && o.onStart(d, r, l), a = !0;
    }, this.itemEnd = function(d) {
      r++, o.onProgress !== void 0 && o.onProgress(d, r, l), r === l && (a = !1, o.onLoad !== void 0 && o.onLoad());
    }, this.itemError = function(d) {
      o.onError !== void 0 && o.onError(d);
    }, this.resolveURL = function(d) {
      return c ? c(d) : d;
    }, this.setURLModifier = function(d) {
      return c = d, this;
    }, this.addHandler = function(d, h) {
      return u.push(d, h), this;
    }, this.removeHandler = function(d) {
      const h = u.indexOf(d);
      return h !== -1 && u.splice(h, 2), this;
    }, this.getHandler = function(d) {
      for (let h = 0, p = u.length; h < p; h += 2) {
        const f = u[h], m = u[h + 1];
        if (f.global && (f.lastIndex = 0), f.test(d))
          return m;
      }
      return null;
    };
  }
}
const dw = /* @__PURE__ */ new uw();
class Vh {
  constructor(e) {
    this.manager = e !== void 0 ? e : dw, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, n) {
    const i = this;
    return new Promise(function(o, a) {
      i.load(e, o, n, a);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Vh.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class hw extends Vh {
  constructor(e) {
    super(e);
  }
  load(e, n, i, o) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const a = this, r = f2.get(e);
    if (r !== void 0)
      return a.manager.itemStart(e), setTimeout(function() {
        n && n(r), a.manager.itemEnd(e);
      }, 0), r;
    const l = Nr("img");
    function c() {
      d(), f2.add(e, this), n && n(this), a.manager.itemEnd(e);
    }
    function u(h) {
      d(), o && o(h), a.manager.itemError(e), a.manager.itemEnd(e);
    }
    function d() {
      l.removeEventListener("load", c, !1), l.removeEventListener("error", u, !1);
    }
    return l.addEventListener("load", c, !1), l.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), a.manager.itemStart(e), l.src = e, l;
  }
}
class fw extends Vh {
  constructor(e) {
    super(e);
  }
  load(e, n, i, o) {
    const a = new An(), r = new hw(this.manager);
    return r.setCrossOrigin(this.crossOrigin), r.setPath(this.path), r.load(e, function(l) {
      a.image = l, a.needsUpdate = !0, n !== void 0 && n(a);
    }, i, o), a;
  }
}
class Kr extends vn {
  constructor(e, n = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Mt(e), this.intensity = n;
  }
  dispose() {
  }
  copy(e, n) {
    return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (n.object.target = this.target.uuid), n;
  }
}
const S1 = /* @__PURE__ */ new jt(), p2 = /* @__PURE__ */ new pe(), m2 = /* @__PURE__ */ new pe();
class Hh {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new qe(512, 512), this.map = null, this.mapPass = null, this.matrix = new jt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Dh(), this._frameExtents = new qe(1, 1), this._viewportCount = 1, this._viewports = [
      new Kt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera, i = this.matrix;
    p2.setFromMatrixPosition(e.matrixWorld), n.position.copy(p2), m2.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(m2), n.updateMatrixWorld(), S1.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(S1), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(S1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class pw extends Hh {
  constructor() {
    super(new Ti(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const n = this.camera, i = va * 2 * e.angle * this.focus, o = this.mapSize.width / this.mapSize.height, a = e.distance || n.far;
    (i !== n.fov || o !== n.aspect || a !== n.far) && (n.fov = i, n.aspect = o, n.far = a, n.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Si extends Kr {
  constructor(e, n, i = 0, o = Math.PI / 3, a = 0, r = 2) {
    super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(vn.DEFAULT_UP), this.updateMatrix(), this.target = new vn(), this.distance = i, this.angle = o, this.penumbra = a, this.decay = r, this.map = null, this.shadow = new pw();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const v2 = /* @__PURE__ */ new jt(), Xa = /* @__PURE__ */ new pe(), C1 = /* @__PURE__ */ new pe();
class mw extends Hh {
  constructor() {
    super(new Ti(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new qe(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Kt(2, 1, 1, 1),
      // negative X
      new Kt(0, 1, 1, 1),
      // positive Z
      new Kt(3, 1, 1, 1),
      // negative Z
      new Kt(1, 1, 1, 1),
      // positive Y
      new Kt(3, 0, 1, 1),
      // negative Y
      new Kt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new pe(1, 0, 0),
      new pe(-1, 0, 0),
      new pe(0, 0, 1),
      new pe(0, 0, -1),
      new pe(0, 1, 0),
      new pe(0, -1, 0)
    ], this._cubeUps = [
      new pe(0, 1, 0),
      new pe(0, 1, 0),
      new pe(0, 1, 0),
      new pe(0, 1, 0),
      new pe(0, 0, 1),
      new pe(0, 0, -1)
    ];
  }
  updateMatrices(e, n = 0) {
    const i = this.camera, o = this.matrix, a = e.distance || i.far;
    a !== i.far && (i.far = a, i.updateProjectionMatrix()), Xa.setFromMatrixPosition(e.matrixWorld), i.position.copy(Xa), C1.copy(i.position), C1.add(this._cubeDirections[n]), i.up.copy(this._cubeUps[n]), i.lookAt(C1), i.updateMatrixWorld(), o.makeTranslation(-Xa.x, -Xa.y, -Xa.z), v2.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(v2);
  }
}
class zs extends Kr {
  constructor(e, n, i = 0, o = 2) {
    super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = o, this.shadow = new mw();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class vw extends Hh {
  constructor() {
    super(new du(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class ws extends Kr {
  constructor(e, n) {
    super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(vn.DEFAULT_UP), this.updateMatrix(), this.target = new vn(), this.shadow = new vw();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Nm extends Kr {
  constructor(e, n) {
    super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class g2 extends Kr {
  constructor(e, n, i = 10, o = 10) {
    super(e, n), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = o;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.width = this.width, n.object.height = this.height, n;
  }
}
class Vm extends Ut {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class gw {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = y2(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const n = y2();
      e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e;
    }
    return e;
  }
}
function y2() {
  return performance.now();
}
const x2 = /* @__PURE__ */ new jt();
class Gh {
  constructor(e, n, i = 0, o = 1 / 0) {
    this.ray = new Ph(e, n), this.near = i, this.far = o, this.camera = null, this.layers = new kh(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  setFromXRController(e) {
    return x2.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(x2), this;
  }
  intersectObject(e, n = !0, i = []) {
    return jd(e, this, i, n), i.sort(b2), i;
  }
  intersectObjects(e, n = !0, i = []) {
    for (let o = 0, a = e.length; o < a; o++)
      jd(e[o], this, i, n);
    return i.sort(b2), i;
  }
}
function b2(s, e) {
  return s.distance - e.distance;
}
function jd(s, e, n, i) {
  let o = !0;
  if (s.layers.test(e.layers) && s.raycast(e, n) === !1 && (o = !1), o === !0 && i === !0) {
    const a = s.children;
    for (let r = 0, l = a.length; r < l; r++)
      jd(a[r], e, n, !0);
  }
}
const _2 = /* @__PURE__ */ new pe();
class Ya extends vn {
  constructor(e, n) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
    const i = new Ut(), o = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let r = 0, l = 1, c = 32; r < c; r++, l++) {
      const u = r / c * Math.PI * 2, d = l / c * Math.PI * 2;
      o.push(
        Math.cos(u),
        Math.sin(u),
        1,
        Math.cos(d),
        Math.sin(d),
        1
      );
    }
    i.setAttribute("position", new Pt(o, 3));
    const a = new Gi({ fog: !1, toneMapped: !1 });
    this.cone = new Lh(i, a), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e), _2.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(_2), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
class w2 extends Ke {
  constructor(e, n, i) {
    const o = new gu(n, 4, 2), a = new _n({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(o, a), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
class yw extends Lh {
  constructor(e = 10, n = 10, i = 4473924, o = 8947848) {
    i = new Mt(i), o = new Mt(o);
    const a = n / 2, r = e / n, l = e / 2, c = [], u = [];
    for (let p = 0, f = 0, m = -l; p <= n; p++, m += r) {
      c.push(-l, 0, m, l, 0, m), c.push(m, 0, -l, m, 0, l);
      const y = p === a ? i : o;
      y.toArray(u, f), f += 3, y.toArray(u, f), f += 3, y.toArray(u, f), f += 3, y.toArray(u, f), f += 3;
    }
    const d = new Ut();
    d.setAttribute("position", new Pt(c, 3)), d.setAttribute("color", new Pt(u, 3));
    const h = new Gi({ vertexColors: !0, toneMapped: !1 });
    super(d, h), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const M2 = /* @__PURE__ */ new pe(), zl = /* @__PURE__ */ new pe(), S2 = /* @__PURE__ */ new pe();
class C2 extends vn {
  constructor(e, n, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
    let o = new Ut();
    o.setAttribute("position", new Pt([
      -n,
      n,
      0,
      n,
      n,
      0,
      n,
      -n,
      0,
      -n,
      -n,
      0,
      -n,
      n,
      0
    ], 3));
    const a = new Gi({ fog: !1, toneMapped: !1 });
    this.lightPlane = new cn(o, a), this.add(this.lightPlane), o = new Ut(), o.setAttribute("position", new Pt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new cn(o, a), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), M2.setFromMatrixPosition(this.light.matrixWorld), zl.setFromMatrixPosition(this.light.target.matrixWorld), S2.subVectors(zl, M2), this.lightPlane.lookAt(zl), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(zl), this.targetLine.scale.z = S2.length();
  }
}
class xw extends Lh {
  constructor(e = 1) {
    const n = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], o = new Ut();
    o.setAttribute("position", new Pt(n, 3)), o.setAttribute("color", new Pt(i, 3));
    const a = new Gi({ vertexColors: !0, toneMapped: !1 });
    super(o, a), this.type = "AxesHelper";
  }
  setColors(e, n, i) {
    const o = new Mt(), a = this.geometry.attributes.color.array;
    return o.set(e), o.toArray(a, 0), o.toArray(a, 3), o.set(n), o.toArray(a, 6), o.toArray(a, 9), o.set(i), o.toArray(a, 12), o.toArray(a, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class bw extends xo {
  constructor(e, n = null) {
    super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: yh
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = yh);
const yc = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (s) => s,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (s) => 1 - Math.cos(s * Math.PI / 2),
  easeOutSine: (s) => Math.sin(s * Math.PI / 2),
  easeInOutSine: (s) => -(Math.cos(Math.PI * s) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (s) => 2.70158 * s * s * s - 1.70158 * s * s,
  easeOutBack: (s) => 1 + 2.70158 * Math.pow(s - 1, 3) + 1.70158 * Math.pow(s - 1, 2),
  easeInOutBack: (s) => {
    const n = 2.5949095;
    return s < 0.5 ? Math.pow(2 * s, 2) * ((n + 1) * 2 * s - n) / 2 : (Math.pow(2 * s - 2, 2) * ((n + 1) * (s * 2 - 2) + n) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * e);
  },
  easeOutElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * e) + 1;
  },
  easeInOutElastic: (s) => {
    const e = 2 * Math.PI / 4.5;
    return s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * e)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * e) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (s) => 1 - yc.easeOutBounce(1 - s),
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInOutBounce: (s) => s < 0.5 ? (1 - yc.easeOutBounce(1 - 2 * s)) / 2 : (1 + yc.easeOutBounce(2 * s - 1)) / 2
};
class Ta {
  constructor() {
    // Cache for recent evaluations (cleared per frame batch)
    le(this, "cache", /* @__PURE__ */ new Map());
  }
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(e, n) {
    const i = e.id, o = this.cache.get(i);
    if (o && o.frame === n)
      return o.value;
    let a;
    return !e.animated || !e.keyframes || e.keyframes.length === 0 ? a = e.value : a = this.evaluateKeyframes(e.keyframes, n, e.value), this.cache.set(i, { frame: n, value: a }), a;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(e, n, i) {
    const o = [...e].sort((d, h) => d.frame - h.frame);
    if (n <= o[0].frame)
      return o[0].value;
    if (n >= o[o.length - 1].frame)
      return o[o.length - 1].value;
    let a = o[0], r = o[o.length - 1];
    for (let d = 0; d < o.length - 1; d++)
      if (o[d].frame <= n && o[d + 1].frame > n) {
        a = o[d], r = o[d + 1];
        break;
      }
    const l = r.frame - a.frame, c = l > 0 ? (n - a.frame) / l : 0, u = this.applyEasing(c, a.interpolation, a, r);
    return this.interpolateValue(a.value, r.value, u, i);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(e, n, i, o) {
    switch (n) {
      case "hold":
        return 0;
      case "linear":
        return e;
      case "bezier":
        return this.evaluateBezier(e, i, o);
      default:
        const a = yc[n];
        return a ? a(e) : e;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(e, n, i) {
    const o = n.outHandle, a = i.inHandle;
    if (!(o != null && o.enabled) && !(a != null && a.enabled))
      return e;
    const r = i.frame - n.frame, l = { x: 0, y: 0 }, c = {
      x: o != null && o.enabled ? Math.min(1, Math.max(0, o.frame / r)) : 0.33,
      y: o != null && o.enabled ? o.value : 0
    }, u = {
      x: a != null && a.enabled ? Math.min(1, Math.max(0, 1 + a.frame / r)) : 0.67,
      y: a != null && a.enabled ? 1 + a.value : 1
    }, d = { x: 1, y: 1 };
    return this.solveCubicBezier(e, l.x, c.x, u.x, d.x, l.y, c.y, u.y, d.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(e, n, i, o, a, r, l, c, u) {
    let d = e;
    const h = 1e-4;
    for (let p = 0; p < 10; p++) {
      const m = this.cubicBezier(d, n, i, o, a) - e;
      if (Math.abs(m) < h)
        break;
      const y = this.cubicBezierDerivative(d, n, i, o, a);
      if (Math.abs(y) < h)
        break;
      d -= m / y, d = Math.max(0, Math.min(1, d));
    }
    return this.cubicBezier(d, r, l, c, u);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(e, n, i, o, a) {
    const r = 1 - e;
    return r * r * r * n + 3 * r * r * e * i + 3 * r * e * e * o + e * e * e * a;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(e, n, i, o, a) {
    const r = 1 - e;
    return 3 * r * r * (i - n) + 6 * r * e * (o - i) + 3 * e * e * (a - o);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(e, n, i, o) {
    return typeof e == "number" && typeof n == "number" ? e + (n - e) * i : this.isPositionLike(e) && this.isPositionLike(n) ? this.interpolatePosition(e, n, i) : typeof e == "string" && typeof n == "string" && e.startsWith("#") && n.startsWith("#") ? this.interpolateColor(e, n, i) : Array.isArray(e) && Array.isArray(n) ? this.interpolateArray(e, n, i) : i < 0.5 ? e : n;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(e) {
    return e !== null && typeof e == "object" && "x" in e && "y" in e;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(e, n, i) {
    const o = {
      x: e.x + (n.x - e.x) * i,
      y: e.y + (n.y - e.y) * i
    };
    return ("z" in e || "z" in n) && (o.z = (e.z ?? 0) + ((n.z ?? 0) - (e.z ?? 0)) * i), o;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(e, n, i) {
    const o = this.hexToRGB(e), a = this.hexToRGB(n), r = Math.round(o.r + (a.r - o.r) * i), l = Math.round(o.g + (a.g - o.g) * i), c = Math.round(o.b + (a.b - o.b) * i);
    return this.rgbToHex(r, l, c);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(e, n, i) {
    const o = Math.max(e.length, n.length), a = [];
    for (let r = 0; r < o; r++) {
      const l = e[r] ?? 0, c = n[r] ?? 0;
      a.push(l + (c - l) * i);
    }
    return a;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(e) {
    const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return n ? {
      r: parseInt(n[1], 16),
      g: parseInt(n[2], 16),
      b: parseInt(n[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(e, n, i) {
    return "#" + [e, n, i].map((o) => Math.max(0, Math.min(255, o)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}
const Hm = /* @__PURE__ */ new Map();
function Bn(s, e) {
  Hm.set(s, e);
}
function _w(s, e) {
  const n = {};
  for (const [i, o] of Object.entries(s.parameters)) {
    const a = o;
    n[i] = mt(a, e);
  }
  return n;
}
function ww(s, e, n) {
  const i = document.createElement("canvas");
  i.width = e.width, i.height = e.height;
  const o = i.getContext("2d");
  o.drawImage(e, 0, 0);
  let a = {
    canvas: i,
    ctx: o
  };
  for (const r of s) {
    if (!r.enabled)
      continue;
    const l = Hm.get(r.effectKey);
    if (!l) {
      Fr.warn(`No renderer registered for effect: ${r.effectKey}`);
      continue;
    }
    const c = _w(r, n);
    try {
      a = l(a, c);
    } catch (u) {
      Fr.error(`Error applying effect ${r.name}:`, u);
    }
  }
  return a;
}
function On(s) {
  const e = document.createElement("canvas");
  e.width = s.width, e.height = s.height;
  const n = e.getContext("2d");
  return { canvas: e, ctx: n };
}
function Mw(s) {
  return s.some((e) => e.enabled);
}
function Sw(s, e) {
  if (e.vertices.length < 2) return;
  s.beginPath();
  const n = e.vertices, i = n.length;
  s.moveTo(n[0].x, n[0].y);
  for (let o = 0; o < i; o++) {
    const a = n[o], r = n[(o + 1) % i];
    if (!e.closed && o === i - 1) break;
    const l = a.x + a.outTangentX, c = a.y + a.outTangentY, u = r.x + r.inTangentX, d = r.y + r.inTangentY;
    l === a.x && c === a.y && u === r.x && d === r.y ? s.lineTo(r.x, r.y) : s.bezierCurveTo(l, c, u, d, r.x, r.y);
  }
  e.closed && s.closePath();
}
function Cw(s, e, n) {
  let i, o;
  e.inTangentX || e.inTangentY ? (i = -e.inTangentX, o = -e.inTangentY) : (i = e.x - s.x, o = e.y - s.y);
  let a, r;
  e.outTangentX || e.outTangentY ? (a = e.outTangentX, r = e.outTangentY) : (a = n.x - e.x, r = n.y - e.y);
  const l = Math.sqrt(i * i + o * o);
  l > 0 && (i /= l, o /= l);
  const c = Math.sqrt(a * a + r * r);
  c > 0 && (a /= c, r /= c);
  const u = -o, d = i, h = -r, p = a;
  let f = (u + h) / 2, m = (d + p) / 2;
  const y = Math.sqrt(f * f + m * m);
  y > 0 ? (f /= y, m /= y) : (f = u, m = d);
  const g = u * h + d * p, x = 1 / Math.max(0.5, (1 + g) / 2);
  return {
    nx: f * Math.min(x, 2),
    ny: m * Math.min(x, 2)
  };
}
function Tw(s, e) {
  if (e === 0) return s;
  const n = s.vertices;
  if (n.length < 2) return s;
  const i = [];
  for (let o = 0; o < n.length; o++) {
    const a = n[(o - 1 + n.length) % n.length], r = n[o], l = n[(o + 1) % n.length], c = !s.closed && o === 0 ? r : a, u = !s.closed && o === n.length - 1 ? r : l, { nx: d, ny: h } = Cw(c, r, u), p = d * e, f = h * e, m = 1 + e / 100;
    i.push({
      x: r.x + p,
      y: r.y + f,
      // Scale handles to maintain curve shape
      inTangentX: r.inTangentX * m,
      inTangentY: r.inTangentY * m,
      outTangentX: r.outTangentX * m,
      outTangentY: r.outTangentY * m
    });
  }
  return { ...s, vertices: i };
}
function Ew(s, e) {
  return !e || s.vertices.length !== e.vertices.length ? s.vertices.map(() => ({
    dx: 0,
    dy: 0,
    magnitude: 0,
    angle: 0
  })) : s.vertices.map((n, i) => {
    const o = e.vertices[i], a = n.x - o.x, r = n.y - o.y, l = Math.sqrt(a * a + r * r), c = Math.atan2(r, a);
    return { dx: a, dy: r, magnitude: l, angle: c };
  });
}
function Aw(s, e, n, i = 1) {
  const o = s.width, a = s.height;
  let r = 0, l = 0, c = 0;
  for (const _ of n)
    r += _.dx, l += _.dy, c += _.magnitude;
  const u = n.length || 1;
  if (r /= u, l /= u, c /= u, c < 0.5) {
    if (e > 0) {
      const _ = s.getContext("2d"), C = document.createElement("canvas");
      C.width = o, C.height = a;
      const T = C.getContext("2d");
      T.filter = `blur(${e}px)`, T.drawImage(s, 0, 0), _.clearRect(0, 0, o, a), _.drawImage(C, 0, 0);
    }
    return s;
  }
  const d = c * i, h = Math.sqrt(r * r + l * l), p = h > 0 ? r / h : 0, f = h > 0 ? l / h : 0, m = document.createElement("canvas");
  m.width = o, m.height = a;
  const y = m.getContext("2d"), g = document.createElement("canvas");
  g.width = o, g.height = a;
  const x = g.getContext("2d");
  e > 0 && (x.filter = `blur(${e}px)`), x.drawImage(s, 0, 0);
  const w = Math.max(3, Math.min(15, Math.ceil(d / 2)));
  y.globalAlpha = 1 / w;
  for (let _ = 0; _ < w; _++) {
    const C = _ / (w - 1) - 0.5, T = p * d * C, P = f * d * C;
    y.drawImage(g, T, P);
  }
  const M = s.getContext("2d");
  return M.clearRect(0, 0, o, a), M.globalAlpha = 1, M.drawImage(m, 0, 0), s;
}
const Gm = /* @__PURE__ */ new Map();
function Pw(s, e) {
  const n = Gm.get(s);
  return n && n.frame === e - 1 ? n.path : null;
}
function kw(s, e, n) {
  Gm.set(s, { frame: e, path: n });
}
function Dw(s, e, n, i) {
  const o = document.createElement("canvas");
  o.width = e, o.height = n;
  const a = o.getContext("2d");
  if (a.fillStyle = "black", a.fillRect(0, 0, e, n), !s.enabled) return o;
  const r = mt(s.path, i), l = mt(s.expansion, i), c = mt(s.opacity, i), u = mt(s.feather, i), d = Tw(r, l);
  if (a.fillStyle = "white", Sw(a, d), a.fill(), c < 100) {
    const m = c / 100, y = a.getImageData(0, 0, e, n);
    for (let g = 0; g < y.data.length; g += 4)
      y.data[g] = Math.round(y.data[g] * m);
    a.putImageData(y, 0, 0);
  }
  const h = Pw(s.id, i), p = Ew(r, h);
  kw(s.id, i, r);
  const f = p.reduce((m, y) => m + y.magnitude, 0) / p.length;
  if ((u > 0 || f > 1) && Aw(o, u, p, 0.5), s.inverted) {
    const m = a.getImageData(0, 0, e, n);
    for (let y = 0; y < m.data.length; y += 4)
      m.data[y] = 255 - m.data[y], m.data[y + 1] = 255 - m.data[y + 1], m.data[y + 2] = 255 - m.data[y + 2];
    a.putImageData(m, 0, 0);
  }
  return o;
}
function Iw(s, e, n, i) {
  const o = document.createElement("canvas");
  o.width = e, o.height = n;
  const a = o.getContext("2d"), r = s.filter((u) => u.enabled && u.mode !== "none");
  if (r.length === 0)
    return a.fillStyle = "white", a.fillRect(0, 0, e, n), o;
  a.fillStyle = "black", a.fillRect(0, 0, e, n);
  const l = a.getImageData(0, 0, e, n), c = l.data;
  for (const u of r) {
    const f = Dw(u, e, n, i).getContext("2d").getImageData(0, 0, e, n).data;
    for (let m = 0; m < c.length; m += 4) {
      const y = f[m];
      switch (u.mode) {
        case "add":
          c[m] = Math.max(c[m], y), c[m + 1] = Math.max(c[m + 1], y), c[m + 2] = Math.max(c[m + 2], y);
          break;
        case "subtract":
          c[m] = Math.max(0, c[m] - y), c[m + 1] = Math.max(0, c[m + 1] - y), c[m + 2] = Math.max(0, c[m + 2] - y);
          break;
        case "intersect":
          c[m] = Math.min(c[m], y), c[m + 1] = Math.min(c[m + 1], y), c[m + 2] = Math.min(c[m + 2], y);
          break;
        case "lighten":
          c[m] = Math.max(c[m], y), c[m + 1] = Math.max(c[m + 1], y), c[m + 2] = Math.max(c[m + 2], y);
          break;
        case "darken":
          c[m] = Math.min(c[m], y), c[m + 1] = Math.min(c[m + 1], y), c[m + 2] = Math.min(c[m + 2], y);
          break;
        case "difference":
          c[m] = Math.abs(c[m] - y), c[m + 1] = Math.abs(c[m + 1] - y), c[m + 2] = Math.abs(c[m + 2] - y);
          break;
      }
    }
  }
  return a.putImageData(l, 0, 0), o;
}
function Rw(s, e, n) {
  if (n === "none") return s;
  const i = s.width, o = s.height, a = document.createElement("canvas");
  a.width = i, a.height = o;
  const r = a.getContext("2d"), c = s.getContext("2d").getImageData(0, 0, i, o), u = c.data, d = document.createElement("canvas");
  d.width = i, d.height = o;
  const h = d.getContext("2d");
  h.drawImage(e, 0, 0, i, o);
  const f = h.getImageData(0, 0, i, o).data;
  for (let m = 0; m < u.length; m += 4) {
    let y;
    switch (n) {
      case "alpha":
        y = f[m + 3] / 255;
        break;
      case "alpha_inverted":
        y = 1 - f[m + 3] / 255;
        break;
      case "luma":
        y = (f[m] * 0.299 + f[m + 1] * 0.587 + f[m + 2] * 0.114) / 255;
        break;
      case "luma_inverted":
        y = 1 - (f[m] * 0.299 + f[m + 1] * 0.587 + f[m + 2] * 0.114) / 255;
        break;
      default:
        y = 1;
    }
    u[m + 3] = Math.round(u[m + 3] * y);
  }
  return r.putImageData(c, 0, 0), a;
}
function Lw(s, e, n) {
  if (!e || e.length === 0) return s;
  const i = s.width, o = s.height, a = Iw(e, i, o, n), r = document.createElement("canvas");
  r.width = i, r.height = o;
  const l = r.getContext("2d"), u = s.getContext("2d").getImageData(0, 0, i, o), d = u.data, f = a.getContext("2d").getImageData(0, 0, i, o).data;
  for (let m = 0; m < d.length; m += 4) {
    const y = f[m] / 255;
    d[m + 3] = Math.round(d[m + 3] * y);
  }
  return l.putImageData(u, 0, 0), r;
}
class $i {
  constructor(e) {
    /** Unique layer identifier */
    le(this, "id");
    /** Layer type */
    le(this, "type");
    /** The Three.js group containing this layer's content */
    le(this, "group");
    /** Keyframe evaluator for animated properties */
    le(this, "evaluator");
    /** Layer visibility */
    le(this, "visible");
    /** Layer locked state */
    le(this, "locked");
    /** In point (start frame) */
    le(this, "inPoint");
    /** Out point (end frame) */
    le(this, "outPoint");
    /** Layer opacity (0-100) */
    le(this, "opacity");
    /** Layer transform */
    le(this, "transform");
    /** 3D layer flag */
    le(this, "threeD");
    /** Blend mode */
    le(this, "blendMode");
    /** Parent layer ID (for parenting hierarchy) */
    le(this, "parentId");
    /** Reference to parent layer (set by LayerManager) */
    le(this, "parentLayer", null);
    /** Driven values override (from property drivers/expressions) */
    le(this, "drivenValues", /* @__PURE__ */ new Map());
    /** Audio reactive values (from audio analysis mapping) */
    le(this, "audioReactiveValues", /* @__PURE__ */ new Map());
    /** Effects stack for this layer */
    le(this, "effects", []);
    /** Source canvas for effect processing (lazy initialized) */
    le(this, "effectSourceCanvas", null);
    /** Flag to track if effects need processing */
    le(this, "effectsDirty", !1);
    // ============================================================================
    // MASK & MATTE SYSTEM
    // ============================================================================
    /** Masks applied to this layer (vector cutouts) */
    le(this, "masks", []);
    /** Track matte type (uses another layer as alpha/luma source) */
    le(this, "trackMatteType", "none");
    /** ID of the layer used as track matte source */
    le(this, "trackMatteLayerId", null);
    /** ID of composition containing matte layer (for cross-comp mattes) */
    le(this, "trackMatteCompositionId", null);
    /** Canvas of track matte layer (set externally by LayerManager) */
    le(this, "trackMatteCanvas", null);
    /** Preserve transparency - only paint on existing pixels */
    le(this, "preserveTransparency", !1);
    this.id = e.id, this.type = e.type, this.group = new Bi(), this.group.name = `layer_${this.id}`, this.group.userData.layerId = this.id, this.group.userData.layerType = this.type, this.evaluator = new Ta(), this.visible = e.visible, this.locked = e.locked, this.inPoint = e.inPoint, this.outPoint = e.outPoint, this.opacity = e.opacity, this.transform = e.transform, this.threeD = e.threeD ?? !1, this.blendMode = e.blendMode ?? "normal", this.parentId = e.parentId ?? null, this.effects = e.effects ?? [], this.masks = e.masks ?? [], this.trackMatteType = e.trackMatteType ?? "none", this.trackMatteLayerId = e.trackMatteLayerId ?? null, this.trackMatteCompositionId = e.trackMatteCompositionId ?? null, this.preserveTransparency = e.preserveTransparency ?? !1;
  }
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    this.blendMode !== "normal" && this.applyBlendMode(this.blendMode);
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(e) {
    const n = e >= this.inPoint && e <= this.outPoint;
    if (this.group.visible = this.visible && n, !this.group.visible)
      return;
    let i = this.evaluator.evaluate(this.opacity, e);
    i = this.getDrivenOrBase("opacity", i);
    const o = this.applyAudioModulation(i, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(o), this.evaluateTransform(e), this.onEvaluateFrame(e);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(e) {
    const n = this.evaluator.evaluate(this.transform.position, e);
    let i = this.getDrivenOrBase("transform.position.x", n.x), o = this.getDrivenOrBase("transform.position.y", n.y);
    const a = this.getDrivenOrBase("transform.position.z", n.z ?? 0);
    i = this.applyAudioModulation(i, "layer.x", "add"), o = this.applyAudioModulation(o, "layer.y", "add");
    const r = { x: i, y: o, z: a }, l = this.evaluator.evaluate(this.transform.scale, e);
    let c = this.getDrivenOrBase("transform.scale.x", l.x ?? 100), u = this.getDrivenOrBase("transform.scale.y", l.y ?? 100);
    const d = this.getDrivenOrBase("transform.scale.z", l.z ?? 100), h = this.getAudioReactiveValue("layer.scale");
    if (h !== 0) {
      const M = 0.5 + h;
      c *= M, u *= M;
    }
    const p = { x: c, y: u, z: d }, f = this.evaluator.evaluate(this.transform.anchorPoint, e), m = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", f.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", f.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", f.z ?? 0)
    };
    let y = 0, g = 0, x = 0;
    if (this.threeD) {
      const M = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, e) : 0;
      g = this.getDrivenOrBase("transform.rotationX", M);
      const _ = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, e) : 0;
      x = this.getDrivenOrBase("transform.rotationY", _);
      const C = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, e) : 0;
      y = this.getDrivenOrBase("transform.rotationZ", C);
    } else {
      const M = this.evaluator.evaluate(this.transform.rotation, e);
      y = this.getDrivenOrBase("transform.rotation", M);
    }
    const w = this.getAudioReactiveValue("layer.rotation");
    w !== 0 && (y += w * 360), this.applyTransform({
      position: {
        x: r.x,
        y: r.y,
        z: r.z
      },
      rotation: {
        x: g,
        y: x,
        z: y
      },
      scale: {
        x: p.x / 100,
        y: p.y / 100,
        z: p.z / 100
      },
      anchorPoint: {
        x: m.x,
        y: m.y,
        z: m.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(e) {
    const { position: n, rotation: i, scale: o, anchorPoint: a } = e;
    this.group.position.set(
      n.x - a.x,
      -(n.y - a.y),
      // Negate for screen coords
      n.z - a.z
    ), this.group.rotation.set(
      ln.degToRad(i.x),
      ln.degToRad(i.y),
      ln.degToRad(-i.z)
    ), this.group.scale.set(o.x, o.y, o.z), this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(e) {
    const n = Math.max(0, Math.min(100, e)) / 100;
    this.group.traverse((i) => {
      if (i instanceof Ke && i.material) {
        const o = i.material;
        "opacity" in o && (o.opacity = n, o.transparent = n < 1, o.needsUpdate = !0);
      }
    });
  }
  // ============================================================================
  // EVALUATED STATE APPLICATION (NEW - SINGLE SOURCE OF TRUTH)
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer visual state.
   * All values are already computed - layers only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * @param state - Pre-evaluated layer state from MotionEngine
   */
  applyEvaluatedState(e) {
    if (this.group.visible = e.visible, !e.visible)
      return;
    const n = this.getDrivenOrBase("opacity", e.opacity);
    this.applyOpacity(n);
    const i = e.transform;
    this.applyTransform({
      position: {
        x: this.getDrivenOrBase("transform.position.x", i.position.x),
        y: this.getDrivenOrBase("transform.position.y", i.position.y),
        z: this.getDrivenOrBase("transform.position.z", i.position.z ?? 0)
      },
      rotation: {
        x: this.getDrivenOrBase("transform.rotationX", i.rotationX ?? 0),
        y: this.getDrivenOrBase("transform.rotationY", i.rotationY ?? 0),
        z: this.getDrivenOrBase("transform.rotation", i.rotation)
      },
      scale: {
        x: this.getDrivenOrBase("transform.scale.x", i.scale.x ?? 100) / 100,
        y: this.getDrivenOrBase("transform.scale.y", i.scale.y ?? 100) / 100,
        z: this.getDrivenOrBase("transform.scale.z", i.scale.z ?? 100) / 100
      },
      anchorPoint: {
        x: this.getDrivenOrBase("transform.anchorPoint.x", i.anchorPoint.x),
        y: this.getDrivenOrBase("transform.anchorPoint.y", i.anchorPoint.y),
        z: this.getDrivenOrBase("transform.anchorPoint.z", i.anchorPoint.z ?? 0)
      }
    }), this.onApplyEvaluatedState(e);
  }
  /**
   * Override in subclasses for type-specific state application
   * Default implementation calls legacy onEvaluateFrame for compatibility
   */
  onApplyEvaluatedState(e) {
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(e) {
    e.visible !== void 0 && (this.visible = e.visible, this.group.visible = this.visible), e.locked !== void 0 && (this.locked = e.locked), e.inPoint !== void 0 && (this.inPoint = e.inPoint), e.outPoint !== void 0 && (this.outPoint = e.outPoint), e.opacity !== void 0 && (this.opacity = e.opacity), e.transform !== void 0 && (this.transform = e.transform), e.threeD !== void 0 && (this.threeD = e.threeD), e.blendMode !== void 0 && (this.blendMode = e.blendMode, this.applyBlendMode(this.blendMode)), e.effects !== void 0 && this.setEffects(e.effects), e.masks !== void 0 && (this.masks = e.masks), e.trackMatteType !== void 0 && (this.trackMatteType = e.trackMatteType), e.trackMatteLayerId !== void 0 && (this.trackMatteLayerId = e.trackMatteLayerId, this.trackMatteCanvas = null), e.trackMatteCompositionId !== void 0 && (this.trackMatteCompositionId = e.trackMatteCompositionId, this.trackMatteCanvas = null), e.preserveTransparency !== void 0 && (this.preserveTransparency = e.preserveTransparency), this.onUpdate(e);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(e) {
    this.visible = e, this.group.visible = e;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(e) {
    this.drivenValues = e;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(e, n) {
    return this.drivenValues.get(e) ?? n;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(e) {
    this.audioReactiveValues = e;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(e) {
    return this.audioReactiveValues.get(e) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(e, n, i = "add", o = {}) {
    const a = this.getAudioReactiveValue(n);
    if (a === 0) return e;
    let r;
    switch (i) {
      case "multiply":
        r = e * (0.5 + a);
        break;
      case "replace":
        r = a;
        break;
      case "add":
      default:
        r = e + a * 100;
        break;
    }
    return o.min !== void 0 && (r = Math.max(o.min, r)), o.max !== void 0 && (r = Math.min(o.max, r)), r;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(e) {
    this.effects = e, this.effectsDirty = !0;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   */
  hasEnabledEffects() {
    return Mw(this.effects);
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(e) {
    if (!this.hasEnabledEffects())
      return null;
    const n = this.getSourceCanvas();
    if (!n)
      return null;
    try {
      return ww(this.effects, n, e).canvas;
    } catch (i) {
      return fi.error(`Error processing effects for layer ${this.id}:`, i), null;
    }
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(e) {
  }
  // ============================================================================
  // MASK PROCESSING
  // ============================================================================
  /**
   * Check if this layer has any enabled masks
   */
  hasMasks() {
    return this.masks.length > 0 && this.masks.some((e) => e.enabled);
  }
  /**
   * Check if this layer has a track matte assigned
   */
  hasTrackMatte() {
    return this.trackMatteType !== "none" && this.trackMatteCanvas !== null;
  }
  /**
   * Set the track matte canvas (called by LayerManager when compositing)
   * @param canvas - The rendered canvas of the matte layer
   */
  setTrackMatteCanvas(e) {
    this.trackMatteCanvas = e;
  }
  /**
   * Get the track matte layer ID
   */
  getTrackMatteLayerId() {
    return this.trackMatteLayerId;
  }
  /**
   * Get the track matte composition ID (for cross-comp mattes)
   * Returns null if matte is in the same composition
   */
  getTrackMatteCompositionId() {
    return this.trackMatteCompositionId;
  }
  /**
   * Check if this layer uses a cross-composition track matte
   */
  hasCrossCompMatte() {
    return this.trackMatteCompositionId !== null && this.trackMatteLayerId !== null;
  }
  /**
   * Get the track matte type
   */
  getTrackMatteType() {
    return this.trackMatteType;
  }
  /**
   * Update masks
   */
  setMasks(e) {
    this.masks = e;
  }
  /**
   * Process masks and track matte on a canvas
   * @param canvas - Source canvas to apply masks to
   * @param frame - Current frame for animated masks
   * @returns Processed canvas with masks applied
   */
  processMasksAndMattes(e, n) {
    let i = e;
    return this.hasMasks() && (i = Lw(i, this.masks, n)), this.hasTrackMatte() && this.trackMatteCanvas && (i = Rw(i, this.trackMatteCanvas, this.trackMatteType)), i;
  }
  /**
   * Called after frame evaluation to apply effects AND masks
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(e) {
    const n = this.hasEnabledEffects(), i = this.hasMasks(), o = this.hasTrackMatte();
    if (!n && !i && !o)
      return;
    const a = this.getSourceCanvas();
    if (!a)
      return;
    let r = a;
    if (n) {
      const l = this.processEffects(e);
      l && (r = l);
    }
    (i || o) && (r = this.processMasksAndMattes(r, e)), r !== a && this.applyProcessedEffects(r);
  }
  /**
   * Apply pre-evaluated effects from MotionEngine
   * Uses the evaluated effect parameters rather than re-evaluating
   */
  applyEvaluatedEffects(e) {
    if (e.length === 0 || !this.hasEnabledEffects())
      return;
    const n = this.processEffectsWithEvaluated(e);
    n && this.applyProcessedEffects(n);
  }
  /**
   * Process effects using pre-evaluated parameters
   */
  processEffectsWithEvaluated(e) {
    const n = this.getSourceCanvas();
    if (!n)
      return null;
    let i = n;
    for (const o of e) {
      if (!o.enabled) continue;
      const a = this.effects.find((l) => l.id === o.id);
      if (!a) continue;
      const r = this.processEffectWithParams(a, i, o.parameters);
      r && (i = r);
    }
    return i !== n ? i : null;
  }
  /**
   * Process a single effect with pre-evaluated parameters
   */
  processEffectWithParams(e, n, i) {
    return null;
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(e) {
    this.parentLayer && this.parentLayer.getObject().remove(this.group), this.parentLayer = e, e && e.getObject().add(this.group);
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(e) {
    this.group.traverse((n) => {
      if (n instanceof Ke && n.material) {
        const i = n.material;
        this.setMaterialBlendMode(i, e), i.needsUpdate = !0;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(e, n) {
    switch (e.blending = rs, e.blendEquation = Oi, e.blendSrc = Uc, e.blendDst = Or, e.blendEquationAlpha = Oi, e.blendSrcAlpha = Hs, e.blendDstAlpha = Or, n) {
      case "normal":
        e.blending = rs;
        break;
      case "add":
        e.blending = ha;
        break;
      case "multiply":
        e.blending = ra;
        break;
      case "screen":
        e.blending = E0, e.blendEquation = Oi, e.blendSrc = Hs, e.blendDst = od;
        break;
      case "overlay":
        e.blending = ra;
        break;
      case "soft-light":
        e.blending = rs;
        break;
      case "hard-light":
        e.blending = ra;
        break;
      case "color-dodge":
        e.blending = ha;
        break;
      case "color-burn":
        e.blending = id;
        break;
      case "difference":
        e.blending = E0, e.blendEquation = Y3, e.blendSrc = Hs, e.blendDst = Hs;
        break;
      case "exclusion":
        e.blending = E0, e.blendEquation = Oi, e.blendSrc = Q3, e.blendDst = od;
        break;
      case "darken":
        e.blending = E0, e.blendEquation = q3, e.blendSrc = Hs, e.blendDst = Hs;
        break;
      case "lighten":
        e.blending = E0, e.blendEquation = Z3, e.blendSrc = Hs, e.blendDst = Hs;
        break;
      default:
        e.blending = rs;
        break;
    }
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const e = new O0();
    return e.setFromObject(this.group), e;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const e = this.getBoundingBox(), n = new pe();
    return e.getCenter(n), n;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    this.group.traverse((e) => {
      var n;
      e instanceof Ke && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => i.dispose()) : e.material && e.material.dispose());
    }), this.group.clear(), this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}
class Fw extends $i {
  constructor(n, i) {
    super(n);
    le(this, "resources");
    // Video elements
    le(this, "videoElement", null);
    le(this, "videoTexture", null);
    le(this, "mesh", null);
    le(this, "material", null);
    // Video data
    le(this, "videoData");
    le(this, "assetRef", null);
    // Metadata (populated after video loads)
    le(this, "metadata", null);
    // Animation evaluator
    le(this, "videoEvaluator");
    // Playback state
    le(this, "lastEvaluatedFrame", -1);
    le(this, "isPlaying", !1);
    // Callbacks for composition auto-resize
    le(this, "onMetadataLoaded");
    // Composition FPS for time calculation
    le(this, "compositionFPS", 30);
    // Canvas for effect processing
    le(this, "effectCanvas", null);
    le(this, "effectCanvasCtx", null);
    this.resources = i, this.videoEvaluator = new Ta(), this.videoData = this.extractVideoData(n), this.createPlaceholderMesh(), this.videoData.assetId && this.loadVideo(this.videoData.assetId), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(n) {
    const i = n.data;
    return {
      assetId: (i == null ? void 0 : i.assetId) ?? null,
      loop: (i == null ? void 0 : i.loop) ?? !1,
      pingPong: (i == null ? void 0 : i.pingPong) ?? !1,
      startTime: (i == null ? void 0 : i.startTime) ?? 0,
      endTime: i == null ? void 0 : i.endTime,
      speed: (i == null ? void 0 : i.speed) ?? 1,
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      frameBlending: (i == null ? void 0 : i.frameBlending) ?? "none",
      audioEnabled: (i == null ? void 0 : i.audioEnabled) ?? !0,
      audioLevel: (i == null ? void 0 : i.audioLevel) ?? 100,
      posterFrame: (i == null ? void 0 : i.posterFrame) ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const n = new nn(1, 1);
    this.material = new _n({
      color: 3355443,
      transparent: !0,
      side: mn
    }), this.mesh = new Ke(n, this.material), this.mesh.name = `video_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(n) {
    const i = this.resources.getAsset(n);
    if (!i || i.type !== "video") {
      fi.warn(`VideoLayer: Asset ${n} not found or not a video`);
      return;
    }
    this.assetRef = i, this.videoData.assetId = n, this.videoElement = document.createElement("video"), this.videoElement.crossOrigin = "anonymous", this.videoElement.playsInline = !0, this.videoElement.muted = !this.videoData.audioEnabled, this.videoElement.loop = !1, this.videoElement.preload = "auto", i.data && (this.videoElement.src = i.data), await this.waitForMetadata(), this.createVideoTexture(), this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((n, i) => {
      if (!this.videoElement) {
        i(new Error("No video element"));
        return;
      }
      const o = () => {
        this.extractMetadata(), r(), n();
      }, a = (l) => {
        r(), i(new Error(`Video load error: ${l}`));
      }, r = () => {
        var l, c;
        (l = this.videoElement) == null || l.removeEventListener("loadedmetadata", o), (c = this.videoElement) == null || c.removeEventListener("error", a);
      };
      this.videoElement.addEventListener("loadedmetadata", o), this.videoElement.addEventListener("error", a), this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    var l, c;
    if (!this.videoElement) return;
    const n = this.videoElement.duration, i = this.videoElement.videoWidth, o = this.videoElement.videoHeight, a = ((l = this.assetRef) == null ? void 0 : l.fps) ?? 30, r = Math.ceil(n * a);
    this.metadata = {
      duration: n,
      frameCount: r,
      fps: a,
      width: i,
      height: o,
      hasAudio: this.hasAudioTrack()
    }, this.assetRef && (this.assetRef.duration = n, this.assetRef.frameCount = r, this.assetRef.fps = a, this.assetRef.hasAudio = this.metadata.hasAudio), (c = this.onMetadataLoaded) == null || c.call(this, this.metadata), fi.debug(`VideoLayer: Loaded: ${i}x${o}, ${r} frames @ ${a}fps, ${n.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return !1;
    const n = this.videoElement.audioTracks;
    return n ? n.length > 0 : !0;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    !this.videoElement || !this.metadata || (this.videoTexture = new D_(this.videoElement), this.videoTexture.minFilter = Dt, this.videoTexture.magFilter = Dt, this.videoTexture.format = Sn, this.videoTexture.colorSpace = pn, this.material && (this.material.map = this.videoTexture, this.material.color.setHex(16777215), this.material.needsUpdate = !0), this.resizeMesh(this.metadata.width, this.metadata.height));
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new nn(n, i));
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(n) {
    if (!this.videoElement || !this.metadata) return;
    const i = this.calculateVideoTime(n), o = Math.max(0, Math.min(i, this.videoElement.duration));
    this.videoElement.currentTime = o;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(n) {
    var l;
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && ((l = this.videoData.timeRemap) != null && l.animated))
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, n);
    const i = this.compositionFPS;
    let a = n / i * this.videoData.speed;
    a += this.videoData.startTime;
    const r = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && r > 0) {
      if (this.videoData.pingPong) {
        const c = Math.floor(a / r), u = a % r;
        a = c % 2 === 0 ? u : r - u;
      } else
        a = a % r;
      a += this.videoData.startTime;
    }
    return a;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(n) {
    this.videoData.audioLevel = n, this.videoElement && (this.videoElement.volume = Math.max(0, Math.min(1, n / 100)));
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(n) {
    this.videoData.audioEnabled = n, this.videoElement && (this.videoElement.muted = !n);
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.compositionFPS = n;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(n) {
    this.onMetadataLoaded = n, this.metadata && n(this.metadata);
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(n) {
    this.videoData.loop = n;
  }
  setPingPong(n) {
    this.videoData.pingPong = n;
  }
  setSpeed(n) {
    this.videoData.speed = n, this.videoElement && (this.videoElement.playbackRate = n);
  }
  setStartTime(n) {
    this.videoData.startTime = n;
  }
  setEndTime(n) {
    this.videoData.endTime = n;
  }
  setFrameBlending(n) {
    this.videoData.frameBlending = n;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata)
      return null;
    const n = this.metadata.width, i = this.metadata.height;
    return (!this.effectCanvas || this.effectCanvas.width !== n || this.effectCanvas.height !== i) && (this.effectCanvas = document.createElement("canvas"), this.effectCanvas.width = n, this.effectCanvas.height = i, this.effectCanvasCtx = this.effectCanvas.getContext("2d")), this.effectCanvasCtx ? (this.effectCanvasCtx.clearRect(0, 0, n, i), this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, n, i), this.effectCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    if (!this.material || !this.metadata) return;
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Dt,
        magFilter: Dt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    n !== this.lastEvaluatedFrame && (this.lastEvaluatedFrame = n, this.seekToFrame(n), this.videoTexture && (this.videoTexture.needsUpdate = !0), this.hasEnabledEffects() ? this.evaluateEffects(n) : this.material && this.videoTexture && (this.material.map = this.videoTexture, this.material.needsUpdate = !0));
  }
  onApplyEvaluatedState(n) {
    const i = n.properties;
    if (i.timeRemap !== void 0 && this.videoElement) {
      const o = i.timeRemap, a = Math.max(0, Math.min(o, this.videoElement.duration || o));
      this.videoElement.currentTime = a;
    }
    i.speed !== void 0 && (this.videoData.speed = i.speed), i.audioLevel !== void 0 && this.setAudioLevel(i.audioLevel), n.effects.length > 0 && this.applyEvaluatedEffects(n.effects);
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.assetId !== void 0 && i.assetId !== this.videoData.assetId && (i.assetId ? this.loadVideo(i.assetId) : this.clearVideo()), i.loop !== void 0 && this.setLoop(i.loop), i.pingPong !== void 0 && this.setPingPong(i.pingPong), i.speed !== void 0 && this.setSpeed(i.speed), i.startTime !== void 0 && this.setStartTime(i.startTime), i.endTime !== void 0 && this.setEndTime(i.endTime), i.frameBlending !== void 0 && this.setFrameBlending(i.frameBlending), i.audioEnabled !== void 0 && this.setAudioEnabled(i.audioEnabled), i.audioLevel !== void 0 && this.setAudioLevel(i.audioLevel));
  }
  /**
   * Clear current video
   */
  clearVideo() {
    this.videoElement && (this.videoElement.pause(), this.videoElement.src = "", this.videoElement = null), this.videoTexture && (this.videoTexture.dispose(), this.videoTexture = null), this.material && (this.material.map = null, this.material.color.setHex(3355443)), this.metadata = null, this.videoData.assetId = null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo(), this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh));
  }
}
async function Ow(s) {
  return new Promise((e, n) => {
    const i = document.createElement("video");
    i.crossOrigin = "anonymous", i.preload = "metadata";
    const o = () => {
      i.removeEventListener("loadedmetadata", a), i.removeEventListener("error", r), URL.revokeObjectURL(i.src);
    }, a = () => {
      const l = {
        duration: i.duration,
        frameCount: Math.ceil(i.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: i.videoWidth,
        height: i.videoHeight,
        hasAudio: !0
        // Assume true
      };
      o(), e(l);
    }, r = () => {
      o(), n(new Error("Failed to load video metadata"));
    };
    i.addEventListener("loadedmetadata", a), i.addEventListener("error", r), typeof s == "string" ? i.src = s : i.src = URL.createObjectURL(s);
  });
}
function Uw(s, e = 16) {
  const n = Math.round(s.width / 8) * 8, i = Math.round(s.height / 8) * 8, o = Math.ceil(s.duration * e);
  return { width: n, height: i, frameCount: o };
}
const zw = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function $m(s, e, n) {
  const i = e / 2, o = n / 2;
  return {
    id: s,
    name: "Camera 1",
    type: "two-node",
    position: { x: i, y: o, z: -1500 },
    pointOfInterest: { x: i, y: o, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function Wm() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function Bw() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: !0,
    showLayerHandles: !0,
    showSafeZones: !1,
    showGrid: !1,
    showRulers: !0,
    show3DReferenceAxes: !0,
    showCompositionBounds: !0,
    showFocalPlane: !1
  };
}
function Ct(s, e, n) {
  return { x: s, y: e, z: n };
}
function It(s, e) {
  return { x: s.x + e.x, y: s.y + e.y, z: s.z + e.z };
}
function $h(s, e) {
  return { x: s.x - e.x, y: s.y - e.y, z: s.z - e.z };
}
function Lt(s, e) {
  return { x: s.x * e, y: s.y * e, z: s.z * e };
}
function Nw(s) {
  return Math.sqrt(s.x * s.x + s.y * s.y + s.z * s.z);
}
function Qs(s) {
  const e = Nw(s);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: s.x / e, y: s.y / e, z: s.z / e };
}
function ya(s, e) {
  return {
    x: s.y * e.z - s.z * e.y,
    y: s.z * e.x - s.x * e.z,
    z: s.x * e.y - s.y * e.x
  };
}
function T1(s, e) {
  return s.x * e.x + s.y * e.y + s.z * e.z;
}
function Vw(s, e, n, i) {
  const o = new Float32Array(16), a = 1 / Math.tan(s / 2), r = 1 / (n - i);
  return o[0] = a / e, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = a, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = (i + n) * r, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = 2 * i * n * r, o[15] = 0, { elements: o };
}
function Hw(s, e, n, i, o, a) {
  const r = new Float32Array(16), l = 1 / (e - s), c = 1 / (i - n), u = 1 / (a - o);
  return r[0] = 2 * l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 2 * c, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = -2 * u, r[11] = 0, r[12] = -(e + s) * l, r[13] = -(i + n) * c, r[14] = -10001 * u, r[15] = 1, { elements: r };
}
function xs(s, e, n) {
  const i = new Float32Array(16);
  let o = s.x - e.x, a = s.y - e.y, r = s.z - e.z, l = Math.sqrt(o * o + a * a + r * r);
  l === 0 ? r = 1 : (l = 1 / l, o *= l, a *= l, r *= l);
  let c = n.y * r - n.z * a, u = n.z * o - n.x * r, d = n.x * a - n.y * o;
  l = Math.sqrt(c * c + u * u + d * d), l === 0 ? (c = 0, u = 0, d = 0) : (l = 1 / l, c *= l, u *= l, d *= l);
  let h = a * d - r * u, p = r * c - o * d, f = o * u - a * c;
  return l = Math.sqrt(h * h + p * p + f * f), l === 0 ? (h = 0, p = 0, f = 0) : (l = 1 / l, h *= l, p *= l, f *= l), i[0] = c, i[4] = u, i[8] = d, i[12] = -T1({ x: c, y: u, z: d }, s), i[1] = h, i[5] = p, i[9] = f, i[13] = -T1({ x: h, y: p, z: f }, s), i[2] = o, i[6] = a, i[10] = r, i[14] = -T1({ x: o, y: a, z: r }, s), i[3] = 0, i[7] = 0, i[11] = 0, i[15] = 1, { elements: i };
}
function Gw(s, e) {
  const n = s.elements, i = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / i,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / i,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / i
  };
}
function Jr(s, e) {
  return 2 * Math.atan(e / (2 * s));
}
function $w(s, e) {
  return e / (2 * Math.tan(s / 2));
}
function $r(s, e, n) {
  if (!e || e.length === 0)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  let i = null, o = null;
  for (const y of e)
    y.frame <= n && (i = y), y.frame >= n && !o && (o = y);
  if (!i && !o)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  i || (i = o), o || (o = i);
  const a = (y) => (y == null ? void 0 : y.position) ?? s.position, r = (y) => (y == null ? void 0 : y.orientation) ?? s.orientation, l = (y) => (y == null ? void 0 : y.focalLength) ?? s.focalLength, c = (y) => (y == null ? void 0 : y.zoom) ?? s.zoom, u = (y) => (y == null ? void 0 : y.focusDistance) ?? s.depthOfField.focusDistance;
  if (i.frame === o.frame)
    return {
      position: a(i),
      rotation: r(i),
      focalLength: l(i),
      zoom: c(i),
      focusDistance: u(i)
    };
  const d = (n - i.frame) / (o.frame - i.frame), h = a(i), p = a(o), f = r(i), m = r(o);
  return {
    position: {
      x: Ho(h.x, p.x, d),
      y: Ho(h.y, p.y, d),
      z: Ho(h.z, p.z, d)
    },
    rotation: {
      x: E1(f.x, m.x, d),
      y: E1(f.y, m.y, d),
      z: E1(f.z, m.z, d)
    },
    focalLength: Ho(l(i), l(o), d),
    zoom: Ho(c(i), c(o), d),
    focusDistance: Ho(u(i), u(o), d)
  };
}
function Ho(s, e, n) {
  return s + (e - s) * n;
}
function E1(s, e, n) {
  let i = e - s;
  return i > 180 && (i -= 360), i < -180 && (i += 360), s + i * n;
}
function jm(s) {
  const { position: e, rotation: n } = s, i = n.x * Math.PI / 180, o = n.y * Math.PI / 180, a = n.z * Math.PI / 180, r = Math.cos(i), l = Math.sin(i), c = Math.cos(o), u = Math.sin(o), d = Math.cos(a), h = Math.sin(a), p = c * d + u * l * h, f = -c * h + u * l * d, m = u * r, y = r * h, g = r * d, x = -l, w = -u * d + c * l * h, M = u * h + c * l * d, _ = c * r, C = -(p * e.x + y * e.y + w * e.z), T = -(f * e.x + g * e.y + M * e.z), P = -(m * e.x + x * e.y + _ * e.z);
  return [
    [p, f, m, C],
    [y, g, x, T],
    [w, M, _, P],
    [0, 0, 0, 1]
  ];
}
function Ww(s, e, n = 0.1, i = 1e3) {
  const a = Jr(s.focalLength, 36) * Math.PI / 180, l = 1 / Math.tan(a / 2), c = 1 / (n - i);
  return [
    [l / e, 0, 0, 0],
    [0, l, 0, 0],
    [0, 0, (i + n) * c, 2 * i * n * c],
    [0, 0, -1, 0]
  ];
}
function Xm(s, e, n) {
  const i = [];
  for (let o = 0; o < n; o++) {
    const a = $r(s, e, o), r = jm(a);
    i.push({
      RT: r
    });
  }
  return { camera_poses: i };
}
function jw(s) {
  if (!s || s.length < 2) return "static";
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, o = n.position ?? { x: 0, y: 0, z: 0 }, a = e.orientation ?? { y: 0 }, r = n.orientation ?? { y: 0 }, l = o.x - i.x, c = o.y - i.y, u = o.z - i.z, d = r.y - a.y, h = 50;
  return Math.abs(u) > h ? u < 0 ? "zoom_in" : "zoom_out" : Math.abs(d) > 15 ? d > 0 ? "rotate_cw" : "rotate_ccw" : Math.abs(l) > h ? l > 0 ? "pan_right" : "pan_left" : Math.abs(c) > h ? c > 0 ? "pan_down" : "pan_up" : "static";
}
function Xw(s, e, n) {
  const i = jw(e);
  if (i !== "static" && e.length <= 2)
    return { motion_camera: i };
  const o = Xm(s, e, n);
  return {
    motion_camera: i,
    camera_poses: JSON.stringify(o.camera_poses)
  };
}
function yu(s) {
  if (!s || s.length < 2)
    return {
      hasPan: !1,
      panMagnitude: 0,
      hasZoom: !1,
      zoomMagnitude: 0,
      hasOrbit: !1,
      orbitMagnitude: 0,
      hasRotation: !1,
      rotationMagnitude: 0
    };
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, o = n.position ?? { x: 0, y: 0, z: 0 }, a = e.orientation ?? { y: 0 }, r = n.orientation ?? { y: 0 }, l = o.x - i.x, c = o.y - i.y, u = o.z - i.z, d = r.y - a.y, h = 30, p = 50, f = 20;
  let m;
  const y = Math.abs(l), g = Math.abs(c);
  (y > h || g > h) && (y > g ? m = l > 0 ? "right" : "left" : m = c > 0 ? "down" : "up");
  let x;
  Math.abs(u) > p && (x = u < 0 ? "in" : "out");
  let w;
  return Math.abs(d) > f && Math.abs(l) > h && (w = d > 0 ? "right" : "left"), {
    hasPan: !!m,
    panDirection: m,
    panMagnitude: Math.max(y, g),
    hasZoom: !!x,
    zoomDirection: x,
    zoomMagnitude: Math.abs(u),
    hasOrbit: !!w,
    orbitDirection: w,
    orbitMagnitude: Math.abs(d),
    hasRotation: Math.abs(d) > 5,
    rotationMagnitude: Math.abs(d)
  };
}
function Yw(s) {
  const e = yu(s);
  let n = "Static";
  if (e.hasOrbit)
    n = e.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  else if (e.hasZoom && e.hasPan) {
    const i = T2(e.panDirection || "up"), o = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    n = `Pan ${i} + ${o}`;
  } else e.hasZoom ? n = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out" : e.hasPan && (n = `Pan ${T2(e.panDirection || "up")}`);
  return { camera_motion: n };
}
function T2(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function qw(s) {
  const e = yu(s);
  return e.hasOrbit && e.orbitMagnitude > 45 ? "orbit" : e.hasPan && e.hasZoom ? "custom" : !e.hasPan && !e.hasZoom && !e.hasOrbit ? "free1" : "custom";
}
function Zw(s, e, n, i, o) {
  const a = qw(e);
  if (a !== "custom")
    return { traj_type: a };
  const r = [], l = $r(s, e, 0);
  for (let c = 0; c < n; c++) {
    const u = $r(s, e, c);
    r.push({
      zoom: u.zoom / l.zoom,
      x_offset: (u.position.x - l.position.x) / i,
      y_offset: (u.position.y - l.position.y) / o,
      z_offset: (u.position.z - l.position.z) / 1e3,
      pitch: u.rotation.x,
      yaw: u.rotation.y,
      roll: u.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: r
  };
}
function Kw(s) {
  const e = yu(s);
  if (!e.hasPan && !e.hasZoom && !e.hasRotation)
    return "Static";
  if (e.hasZoom)
    return e.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  if (e.hasPan)
    switch (e.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  if (e.hasRotation) {
    const n = s[0], i = s[s.length - 1], o = n.orientation ?? { x: 0, y: 0, z: 0 }, a = i.orientation ?? { x: 0, y: 0, z: 0 }, r = a.x - o.x, l = a.y - o.y, c = a.z - o.z;
    return Math.abs(l) > Math.abs(r) && Math.abs(l) > Math.abs(c) ? l > 0 ? "Rotate Right" : "Rotate Left" : Math.abs(r) > Math.abs(c) ? r > 0 ? "Rotate Down" : "Rotate Up" : c > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function Jw(s, e) {
  const n = Kw(s), i = yu(s);
  let o = 0;
  return i.hasZoom ? o = Math.min(100, i.zoomMagnitude / 5) : i.hasPan ? o = Math.min(100, i.panMagnitude / 3) : i.hasRotation && (o = Math.min(100, i.rotationMagnitude * 2)), {
    motion_type: n,
    speed: Math.round(o),
    frame_length: e
  };
}
function Qw(s, e, n) {
  const i = [], o = n.width / n.height;
  for (let a = 0; a < n.frameCount; a++) {
    const r = $r(s, e, a), l = jm(r), c = Ww(r, o);
    i.push({
      frame: a,
      timestamp: a / n.fps,
      view_matrix: l,
      projection_matrix: c,
      position: [r.position.x, r.position.y, r.position.z],
      rotation: [r.rotation.x, r.rotation.y, r.rotation.z],
      fov: Jr(r.focalLength, s.filmSize),
      focal_length: r.focalLength,
      focus_distance: r.focusDistance
    });
  }
  return {
    frames: i,
    metadata: {
      width: n.width,
      height: n.height,
      fps: n.fps,
      total_frames: n.frameCount,
      camera_type: s.type,
      film_size: s.filmSize
    }
  };
}
function eM(s, e, n, i, o = 1920, a = 1080, r = 24) {
  switch (s) {
    case "motionctrl":
      return Xm(e, n, i);
    case "motionctrl-svd":
      return Xw(e, n, i);
    case "wan22-fun-camera":
      return Yw(n);
    case "uni3c-camera":
    case "uni3c-motion":
      return Zw(e, n, i, o, a);
    case "animatediff-cameractrl":
      return Jw(n, i);
    default:
      return Qw(e, n, {
        frameCount: i,
        width: o,
        height: a,
        fps: r
      });
  }
}
let so = null, Wr = null, ea = null, Gc = null;
function tM() {
  return so || (so = new Worker(
    new URL(
      /* @vite-ignore */
      "/assets/audioWorker-DAB3gMSK.js",
      import.meta.url
    ),
    { type: "module" }
  ), so.onmessage = (s) => {
    const e = s.data;
    switch (e.type) {
      case "progress":
        Gc && Gc({
          phase: e.payload.phase,
          progress: e.payload.progress,
          message: e.payload.message
        });
        break;
      case "complete":
        Wr && (Wr(e.payload), A1());
        break;
      case "error":
        ea && (ea(new Error(e.payload.message)), A1());
        break;
    }
  }, so.onerror = (s) => {
    console.error("[AudioWorker] Worker error:", s), ea && (ea(new Error(`Worker error: ${s.message}`)), A1());
  }), so;
}
function A1() {
  Wr = null, ea = null, Gc = null;
}
function nM() {
  so && so.postMessage({ type: "cancel" });
}
async function iM(s, e, n = {}) {
  const i = tM();
  if (Wr)
    throw new Error("Analysis already in progress. Cancel it first.");
  const o = s.getChannelData(0), a = new Float32Array(o);
  return new Promise((r, l) => {
    Wr = r, ea = l, Gc = n.onProgress || null, i.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: a,
          sampleRate: s.sampleRate,
          fps: e
        }
      },
      [a.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function sM(s, e, n = {}) {
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 0,
    message: "Decoding audio file..."
  });
  const i = await s.arrayBuffer(), o = new AudioContext();
  let a;
  try {
    a = await o.decodeAudioData(i);
  } finally {
    await o.close();
  }
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 1,
    message: "Audio decoded successfully"
  });
  const r = await iM(a, e, n);
  return { buffer: a, analysis: r };
}
function Yt(s, e, n = "number", i) {
  return {
    id: `prop_${s}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name: s,
    type: n,
    value: e,
    animated: !1,
    keyframes: [],
    group: i
  };
}
function P1() {
  return {
    position: Yt("position", { x: 0, y: 0 }, "position"),
    anchorPoint: Yt("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: Yt("scale", { x: 100, y: 100 }, "position"),
    rotation: Yt("rotation", 0, "number")
  };
}
function oM(s, e) {
  const n = "main", i = {
    width: s,
    height: e,
    frameCount: 81,
    fps: 16,
    duration: 5.0625,
    backgroundColor: "#000000",
    autoResizeToContent: !0
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [n]: {
        id: n,
        name: "Main Comp",
        settings: i,
        layers: [],
        currentFrame: 0,
        isPrecomp: !1
      }
    },
    mainCompositionId: n,
    // Legacy alias
    composition: i,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
function aM(s, e = "amplitude", n = "particle.emissionRate") {
  return {
    id: s || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature: e,
    target: n,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    // Core
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: !1,
    threshold: 0,
    enabled: !0,
    // ATI style
    amplitudeCurve: 1,
    // Linear by default
    release: 0.5,
    // Medium decay
    beatResponse: "none",
    beatThreshold: 0.5,
    curve: "linear"
  };
}
class rM {
  constructor(e) {
    le(this, "analysis");
    le(this, "mappings", /* @__PURE__ */ new Map());
    le(this, "smoothedValues", /* @__PURE__ */ new Map());
    le(this, "releaseEnvelopes", /* @__PURE__ */ new Map());
    // ATI-style release tracking
    le(this, "beatToggleStates", /* @__PURE__ */ new Map());
    // For beat toggle/flip
    le(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0), this.releaseEnvelopes.set(e.id, 0), this.beatToggleStates.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e), this.releaseEnvelopes.delete(e), this.beatToggleStates.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const i = this.mappings.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && b7(this.peakData, n) ? 1 : 0 : Li(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const i = this.mappings.get(e);
    if (!i || !i.enabled) return 0;
    let o = this.getFeatureAtFrame(i.feature, n);
    o < i.threshold && (o = 0), i.amplitudeCurve !== 1 && (o = Math.pow(o, i.amplitudeCurve));
    const a = this.releaseEnvelopes.get(e) || 0;
    if (o > a)
      this.releaseEnvelopes.set(e, o);
    else {
      const c = 1 - i.release * 0.98, u = a * c;
      this.releaseEnvelopes.set(e, u), o = Math.max(o, u);
    }
    if (i.beatResponse !== "none") {
      if (this.analysis.onsets.includes(n) && this.getFeatureAtFrame(i.feature, n) > i.beatThreshold) {
        const u = this.beatToggleStates.get(e) || 0;
        switch (i.beatResponse) {
          case "flip":
            this.beatToggleStates.set(e, u === 0 ? 1 : 0);
            break;
          case "pulse":
            o = 1;
            break;
          case "toggle":
            const d = u === 0 ? 1 : 0;
            this.beatToggleStates.set(e, d), o = d;
            break;
        }
      }
      i.beatResponse === "flip" && (this.beatToggleStates.get(e) || 0) === 1 && (o = 1 - o);
    }
    o = this.applyCurve(o, i.curve), i.invert && (o = 1 - o), o *= i.sensitivity, o += i.offset, o = Math.max(i.min, Math.min(i.max, o));
    const l = (this.smoothedValues.get(e) || 0) * i.smoothing + o * (1 - i.smoothing);
    return this.smoothedValues.set(e, l), l;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const i of this.mappings.values()) {
      if (!i.enabled) continue;
      const o = this.getValueAtFrame(i.id, e), a = n.get(i.target);
      a !== void 0 ? n.set(i.target, a + o) : n.set(i.target, o);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const i = /* @__PURE__ */ new Map();
    for (const o of this.mappings.values()) {
      if (!o.enabled || o.targetLayerId && o.targetLayerId !== e) continue;
      const a = this.getValueAtFrame(o.id, n), r = i.get(o.target);
      r !== void 0 ? i.set(o.target, r + a) : i.set(o.target, a);
    }
    return i;
  }
  /**
   * Apply curve shaping to a value
   */
  applyCurve(e, n) {
    const i = Math.max(0, Math.min(1, e));
    switch (n) {
      case "exponential":
        return i * i;
      case "logarithmic":
        return Math.sqrt(i);
      case "smoothstep":
        return i * i * (3 - 2 * i);
      case "bounce":
        if (i < 0.5)
          return 2 * i * i;
        {
          const o = i - 0.5;
          return 0.5 + 0.5 * (1 - Math.pow(1 - 2 * o, 2));
        }
      case "linear":
      default:
        return i;
    }
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear(), this.releaseEnvelopes.clear(), this.beatToggleStates.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0), this.releaseEnvelopes.set(e.id, 0), this.beatToggleStates.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear(), this.releaseEnvelopes.clear(), this.beatToggleStates.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
function k1(s) {
  return {
    // Core
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    // Frequency bands
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    // Events
    onsets: "Beat Onsets",
    peaks: "Detected Peaks",
    // Enhanced features
    spectralFlux: "Spectral Flux (Transients)",
    zeroCrossingRate: "Zero Crossing (Percussive)",
    spectralRolloff: "Spectral Rolloff (High Freq)",
    spectralFlatness: "Spectral Flatness (Noise)",
    chromaEnergy: "Chroma Energy (Harmonic)",
    // Pitch classes
    chromaC: "Chroma: C",
    chromaCs: "Chroma: C#/Db",
    chromaD: "Chroma: D",
    chromaDs: "Chroma: D#/Eb",
    chromaE: "Chroma: E",
    chromaF: "Chroma: F",
    chromaFs: "Chroma: F#/Gb",
    chromaG: "Chroma: G",
    chromaGs: "Chroma: G#/Ab",
    chromaA: "Chroma: A",
    chromaAs: "Chroma: A#/Bb",
    chromaB: "Chroma: B"
  }[s] || s;
}
function E2(s) {
  const e = s.match(/^spline\.controlPoint\.(\d+)\.(x|y|depth)$/);
  if (e) {
    const i = e[1], o = e[2] === "x" ? "X" : e[2] === "y" ? "Y" : "Depth";
    return `Spline: Control Point ${i} ${o}`;
  }
  return {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  }[s] || s;
}
function lM() {
  return [
    // Core
    "amplitude",
    "rms",
    "spectralCentroid",
    // Frequency bands
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    // Events
    "onsets",
    "peaks",
    // Enhanced
    "spectralFlux",
    "zeroCrossingRate",
    "spectralRolloff",
    "spectralFlatness",
    "chromaEnergy",
    // Pitch classes
    "chromaC",
    "chromaCs",
    "chromaD",
    "chromaDs",
    "chromaE",
    "chromaF",
    "chromaFs",
    "chromaG",
    "chromaGs",
    "chromaA",
    "chromaAs",
    "chromaB"
  ];
}
function cM() {
  return {
    Energy: ["amplitude", "rms"],
    "Frequency Bands": ["sub", "bass", "lowMid", "mid", "highMid", "high"],
    Spectral: ["spectralCentroid", "spectralFlux", "spectralRolloff", "spectralFlatness"],
    Events: ["onsets", "peaks"],
    Harmonic: ["chromaEnergy", "zeroCrossingRate"],
    "Pitch Classes": [
      "chromaC",
      "chromaCs",
      "chromaD",
      "chromaDs",
      "chromaE",
      "chromaF",
      "chromaFs",
      "chromaG",
      "chromaGs",
      "chromaA",
      "chromaAs",
      "chromaB"
    ]
  };
}
function uM() {
  return {
    Particle: [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    Depthflow: [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    Path: ["path.position"],
    Layer: [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
    // Note: 'Spline' targets are generated dynamically based on control point count
    // Use createSplineControlPointTargets() to get targets for a specific spline
  };
}
const dM = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class hM {
  // For amplitude mode release tracking
  constructor(e = {}) {
    le(this, "config");
    le(this, "state");
    le(this, "pathSegments", []);
    le(this, "totalLength", 0);
    le(this, "releaseState", 0);
    this.config = { ...dM, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], i = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let o = 0, a = 0;
    for (const r of i) {
      const l = r[0].toUpperCase(), c = r.slice(1).trim().split(/[\s,]+/).map(Number).filter((u) => !isNaN(u));
      switch (l) {
        case "M":
          o = c[0] || 0, a = c[1] || 0, n.push({
            type: "M",
            points: [o, a],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [o, a, c[0], c[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), o = c[0], a = c[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [o, a, c[0], c[1], c[2], c[3], c[4], c[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), o = c[4], a = c[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [o, a, c[0], c[1], c[2], c[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), o = c[2], a = c[3];
          break;
        case "Z":
          const u = n.find((d) => d.type === "M");
          u && n.push({
            type: "L",
            points: [o, a, u.points[0], u.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], i = e[3] - e[1];
    return Math.sqrt(n * n + i * i);
  }
  bezierLength(e, n) {
    let o = 0, a = e[0], r = e[1];
    for (let l = 1; l <= 20; l++) {
      const c = l / 20, { x: u, y: d } = this.getBezierPoint(e, c, n), h = u - a, p = d - r;
      o += Math.sqrt(h * h + p * p), a = u, r = d;
    }
    return o;
  }
  getBezierPoint(e, n, i) {
    if (i === 2) {
      const o = 1 - n;
      return {
        x: o * o * e[0] + 2 * o * n * e[2] + n * n * e[4],
        y: o * o * e[1] + 2 * o * n * e[3] + n * n * e[5]
      };
    } else {
      const o = 1 - n, a = o * o, r = n * n;
      return {
        x: a * o * e[0] + 3 * a * n * e[2] + 3 * o * r * e[4] + r * n * e[6],
        y: a * o * e[1] + 3 * a * n * e[3] + 3 * o * r * e[5] + r * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const i = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = i, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(i) : this.updateAccumulateMode(i, n);
    const o = this.getPositionOnPath(this.state.position);
    return this.state.x = o.x, this.state.y = o.y, this.state.angle = o.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const o = 1 - this.config.release * 0.95;
      this.releaseState *= o;
    }
    const i = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, i * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const i = e * this.config.sensitivity * 0.02 * this.state.direction;
    let o = this.state.position + i;
    o > 1 ? (o = 2 - o, this.state.direction = -1) : o < 0 && (o = -o, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, o));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const u of this.pathSegments)
      if (u.type !== "M" && e >= u.startT && e <= u.endT) {
        n = u;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const i = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let o, a, r, l;
    switch (n.type) {
      case "L":
        o = n.points[0] + (n.points[2] - n.points[0]) * i, a = n.points[1] + (n.points[3] - n.points[1]) * i, r = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const u = this.getBezierPoint(n.points, i, 2);
        o = u.x, a = u.y;
        const d = 1 - i;
        r = 2 * d * (n.points[2] - n.points[0]) + 2 * i * (n.points[4] - n.points[2]), l = 2 * d * (n.points[3] - n.points[1]) + 2 * i * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const u = this.getBezierPoint(n.points, i, 3);
        o = u.x, a = u.y;
        const d = 1 - i, h = d * d, p = i * i;
        r = 3 * h * (n.points[2] - n.points[0]) + 6 * d * i * (n.points[4] - n.points[2]) + 3 * p * (n.points[6] - n.points[4]), l = 3 * h * (n.points[3] - n.points[1]) + 6 * d * i * (n.points[5] - n.points[3]) + 3 * p * (n.points[7] - n.points[5]);
        break;
      }
      default:
        o = 0, a = 0, r = 1, l = 0;
    }
    const c = Math.atan2(l, r);
    return { x: o, y: a, angle: c };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], i = this.state.previousPosition, o = this.state.position;
    for (let a = 0; a <= e; a++) {
      const r = i + (o - i) * (a / e), l = this.getPositionOnPath(r), c = a / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: c });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
function fM(s) {
  switch (s) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "point3d":
      return "vector3";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const $c = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, Xd = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function pM(s) {
  const e = $c[s];
  if (!e) return null;
  const n = {};
  return e.parameters.forEach((i, o) => {
    const a = i.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    n[a] = {
      id: `${s}-${a}-${o}`,
      name: i.name,
      type: fM(i.type),
      value: i.defaultValue,
      animated: !1,
      keyframes: []
    };
  }), {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: s,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: n
  };
}
const mM = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];
function vM(s) {
  return s.startsWith("spline.controlPoint.");
}
function gM(s, e) {
  return `spline.controlPoint.${s}.${e}`;
}
class yM {
  constructor() {
    le(this, "drivers", /* @__PURE__ */ new Map());
    le(this, "smoothedValues", /* @__PURE__ */ new Map());
    le(this, "audioAnalysis", null);
    le(this, "propertyGetter", null);
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(e) {
    this.audioAnalysis = e;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(e) {
    this.propertyGetter = e;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(e) {
    return e.sourceType === "property" && e.sourceLayerId && e.sourceProperty && this.wouldCreateCycle(e) ? (bt.warn("PropertyDriverSystem: Cannot add driver: would create circular dependency"), !1) : (this.drivers.set(e.id, e), this.smoothedValues.set(e.id, 0), !0);
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(e) {
    if (e.sourceType !== "property" || !e.sourceLayerId || !e.sourceProperty) return !1;
    const n = /* @__PURE__ */ new Set(), i = `${e.targetLayerId}:${e.targetProperty}`, o = (a, r) => {
      const l = `${a}:${r}`;
      if (l === i) return !0;
      if (n.has(l)) return !1;
      n.add(l);
      for (const c of this.drivers.values())
        if (c.sourceType === "property" && !(c.targetLayerId !== a || c.targetProperty !== r) && !(!c.sourceLayerId || !c.sourceProperty) && o(c.sourceLayerId, c.sourceProperty))
          return !0;
      return !1;
    };
    return o(e.sourceLayerId, e.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(e) {
    this.drivers.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update a driver
   */
  updateDriver(e, n) {
    const i = this.drivers.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a driver by ID
   */
  getDriver(e) {
    return this.drivers.get(e);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(e) {
    return Array.from(this.drivers.values()).filter((n) => n.targetLayerId === e);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(e, n) {
    return Array.from(this.drivers.values()).filter(
      (i) => i.targetLayerId === e && i.targetProperty === n && i.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(e, n, i) {
    if (!e.enabled) return i;
    let o = this.getSourceValue(e, n);
    return o === null ? i : (o = this.applyTransforms(e, o), this.blendValue(i, o, e.blendMode, e.blendAmount));
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(e, n) {
    switch (e.sourceType) {
      case "property":
        return this.getPropertySourceValue(e, n);
      case "audio":
        return this.getAudioSourceValue(e, n);
      case "time":
        return n;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(e, n) {
    return !this.propertyGetter || !e.sourceLayerId || !e.sourceProperty ? null : this.propertyGetter(e.sourceLayerId, e.sourceProperty, n);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(e, n) {
    if (!this.audioAnalysis || !e.audioFeature)
      return null;
    let i = Li(this.audioAnalysis, e.audioFeature, n);
    return e.audioThreshold !== void 0 && (e.audioAboveThreshold ? i = i > e.audioThreshold ? i : 0 : i = i >= e.audioThreshold ? i : 0), i;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(e, n) {
    for (const i of e.transforms)
      n = this.applyTransform(e.id, i, n);
    return n;
  }
  /**
   * Apply a single transform
   */
  applyTransform(e, n, i) {
    switch (n.type) {
      case "scale":
        return i * (n.factor ?? 1);
      case "offset":
        return i + (n.amount ?? 0);
      case "clamp":
        return Math.max(n.min ?? -1 / 0, Math.min(n.max ?? 1 / 0, i));
      case "smooth": {
        const o = this.smoothedValues.get(e) ?? i, a = n.smoothing ?? 0.5, r = o * a + i * (1 - a);
        return this.smoothedValues.set(e, r), r;
      }
      case "invert":
        return 1 - i;
      case "remap": {
        const o = n.inMin ?? 0, a = n.inMax ?? 1, r = n.outMin ?? 0, l = n.outMax ?? 1, c = (i - o) / (a - o);
        return r + c * (l - r);
      }
      case "threshold":
        return i > (n.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const o = n.frequency ?? 1, a = n.amplitude ?? 1, r = n.phase ?? 0;
        return Math.sin((i * o + r) * Math.PI * 2) * a;
      }
      default:
        return i;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(e, n, i, o) {
    let a;
    switch (i) {
      case "replace":
        a = n;
        break;
      case "add":
        a = e + n;
        break;
      case "multiply":
        a = e * n;
        break;
      default:
        a = n;
    }
    return e * (1 - o) + a * o;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(e, n, i) {
    const o = /* @__PURE__ */ new Map(), a = this.getDriversForLayer(e);
    for (const r of a) {
      if (!r.enabled) continue;
      const l = i.get(r.targetProperty) ?? 0, c = this.evaluateDriver(r, n, l), u = o.get(r.targetProperty);
      u !== void 0 ? o.set(r.targetProperty, u + c - l) : o.set(r.targetProperty, c);
    }
    return o;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addDriver(n);
  }
}
function Ym(s, e, n = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: !0,
    targetLayerId: s,
    targetProperty: e,
    sourceType: n,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function xM(s, e, n, i = {}) {
  const o = Ym(s, e, "audio");
  return o.audioFeature = n, o.audioThreshold = i.threshold ?? 0, o.audioAboveThreshold = i.threshold !== void 0, i.scale !== void 0 && i.scale !== 1 && o.transforms.push({ type: "scale", factor: i.scale }), i.offset !== void 0 && i.offset !== 0 && o.transforms.push({ type: "offset", amount: i.offset }), i.smoothing !== void 0 && i.smoothing > 0 && o.transforms.push({ type: "smooth", smoothing: i.smoothing }), o;
}
function bM(s, e, n, i, o = {}) {
  const a = Ym(s, e, "property");
  return a.sourceLayerId = n, a.sourceProperty = i, a.blendMode = o.blendMode ?? "add", o.scale !== void 0 && o.scale !== 1 && a.transforms.push({ type: "scale", factor: o.scale }), o.offset !== void 0 && o.offset !== 0 && a.transforms.push({ type: "offset", amount: o.offset }), a;
}
const _M = {
  enabled: !0,
  snapToGrid: !0,
  snapToKeyframes: !0,
  snapToBeats: !0,
  snapToPeaks: !0,
  snapToLayerBounds: !0,
  snapToPlayhead: !0,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function Wh(s, e, n, i) {
  var l, c;
  if (!e.enabled)
    return null;
  const o = [], a = e.threshold / n;
  if (e.snapToGrid) {
    const u = Math.round(s / e.gridInterval) * e.gridInterval, d = Math.abs(s - u);
    d <= a && o.push({
      frame: u,
      type: "frame",
      distance: d * n
    });
  }
  if (e.snapToKeyframes && i.layers)
    for (const u of i.layers)
      u.id !== i.selectedLayerId && wM(u, s, a, n, o);
  if (e.snapToBeats && ((l = i.audioAnalysis) != null && l.onsets))
    for (const u of i.audioAnalysis.onsets) {
      const d = Math.abs(s - u);
      d <= a && o.push({
        frame: u,
        type: "beat",
        distance: d * n
      });
    }
  if (e.snapToPeaks && ((c = i.peakData) != null && c.indices))
    for (const u of i.peakData.indices) {
      const d = Math.abs(s - u);
      d <= a && o.push({
        frame: u,
        type: "peak",
        distance: d * n
      });
    }
  if (e.snapToLayerBounds && i.layers)
    for (const u of i.layers) {
      if (u.id === i.selectedLayerId) continue;
      const d = Math.abs(s - u.inPoint), h = Math.abs(s - u.outPoint);
      d <= a && o.push({
        frame: u.inPoint,
        type: "layer-in",
        distance: d * n
      }), h <= a && o.push({
        frame: u.outPoint,
        type: "layer-out",
        distance: h * n
      });
    }
  if (e.snapToPlayhead && i.currentFrame !== void 0) {
    const u = Math.abs(s - i.currentFrame);
    u <= a && u > 0 && o.push({
      frame: i.currentFrame,
      type: "playhead",
      distance: u * n
    });
  }
  if (o.length === 0)
    return null;
  const r = {
    playhead: 5,
    beat: 4,
    peak: 4,
    keyframe: 3,
    "layer-in": 2,
    "layer-out": 2,
    frame: 1
  };
  return o.sort((u, d) => {
    const h = u.distance - d.distance;
    return Math.abs(h) < 0.5 ? r[d.type] - r[u.type] : h;
  }), o[0];
}
function wM(s, e, n, i, o) {
  const a = [
    s.transform.position,
    s.transform.scale,
    s.transform.rotation,
    s.opacity,
    ...s.properties
  ];
  for (const r of a)
    if (!(!r.animated || !r.keyframes))
      for (const l of r.keyframes) {
        const c = Math.abs(e - l.frame);
        c <= n && (o.some((u) => u.frame === l.frame && u.type === "keyframe") || o.push({
          frame: l.frame,
          type: "keyframe",
          distance: c * i
        }));
      }
}
function MM(s) {
  return (s == null ? void 0 : s.onsets) ?? [];
}
function SM(s) {
  return (s == null ? void 0 : s.indices) ?? [];
}
function CM() {
  return "";
}
async function xu(s) {
  const e = await fetch(`${CM()}/weyl/segment`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(s)
  });
  if (!e.ok) {
    const n = await e.json().catch(() => ({}));
    throw new Error(n.message || `Segmentation failed: ${e.status}`);
  }
  return e.json();
}
async function qm(s, e, n = "sam2") {
  return xu({
    image: s,
    mode: "point",
    model: n,
    points: [e],
    labels: [1]
    // Foreground
  });
}
async function Zm(s, e, n = "sam2") {
  return xu({
    image: s,
    mode: "box",
    model: n,
    box: e
  });
}
async function TM(s, e, n = [], i = "sam2") {
  const o = [...e, ...n], a = [
    ...e.map(() => 1),
    // Foreground
    ...n.map(() => 0)
    // Background
  ];
  return xu({
    image: s,
    mode: "point",
    model: i,
    points: o,
    labels: a
  });
}
async function EM(s, e = {}) {
  return xu({
    image: s,
    mode: "auto",
    model: e.model || "sam2",
    minArea: e.minArea || 100,
    maxMasks: e.maxMasks || 20
  });
}
function AM(s, e, n) {
  return new Promise((i, o) => {
    const a = new Image(), r = new Image();
    let l = !1, c = !1;
    const u = () => {
      if (!(!l || !c))
        try {
          const d = document.createElement("canvas");
          d.width = n.width, d.height = n.height;
          const h = d.getContext("2d");
          if (!h) {
            o(new Error("Failed to get canvas context"));
            return;
          }
          const p = document.createElement("canvas");
          p.width = r.width, p.height = r.height;
          const f = p.getContext("2d");
          if (!f) {
            o(new Error("Failed to get mask canvas context"));
            return;
          }
          f.drawImage(r, 0, 0);
          const m = f.getImageData(n.x, n.y, n.width, n.height);
          h.drawImage(
            a,
            n.x,
            n.y,
            n.width,
            n.height,
            0,
            0,
            n.width,
            n.height
          );
          const y = h.getImageData(0, 0, n.width, n.height);
          for (let x = 0; x < y.data.length; x += 4)
            y.data[x + 3] = m.data[x];
          h.putImageData(y, 0, 0);
          const g = d.toDataURL("image/png").split(",")[1];
          i(g);
        } catch (d) {
          o(d);
        }
    };
    a.onload = () => {
      l = !0, u();
    }, a.onerror = () => o(new Error("Failed to load source image")), r.onload = () => {
      c = !0, u();
    }, r.onerror = () => o(new Error("Failed to load mask image")), a.src = `data:image/png;base64,${s}`, r.src = `data:image/png;base64,${e}`;
  });
}
const un = /* @__PURE__ */ w6("compositor", {
  state: () => ({
    project: oM(1024, 1024),
    activeCompositionId: "main",
    openCompositionIds: ["main"],
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    selectedPropertyPath: null,
    currentTool: "select",
    segmentMode: "point",
    segmentPendingMask: null,
    segmentBoxStart: null,
    segmentIsLoading: !1,
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: Wm(),
    viewOptions: Bw(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ..._M },
    // Clipboard
    clipboard: {
      layers: [],
      keyframes: []
    }
  }),
  getters: {
    // Active composition helper
    activeComposition: (s) => s.project.compositions[s.activeCompositionId] || null,
    // Project info - now uses active composition
    hasProject: (s) => s.sourceImage !== null,
    width(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.width) || 1024;
    },
    height(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.height) || 1024;
    },
    frameCount(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.frameCount) || 81;
    },
    fps(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.fps) || 16;
    },
    duration(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.duration) || 5;
    },
    // Current frame - per composition
    currentFrame(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.currentFrame) || 0;
    },
    currentTime(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return e ? e.currentFrame / e.settings.fps : 0;
    },
    // Layers - from active composition
    layers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.layers) || [];
    },
    visibleLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.visible);
    },
    // Selection
    selectedLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => s.selectedLayerIds.includes(n.id));
    },
    selectedLayer(s) {
      if (s.selectedLayerIds.length !== 1) return null;
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).find((n) => n.id === s.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (s) => Object.values(s.project.compositions),
    openCompositions(s) {
      return s.openCompositionIds.map((e) => s.project.compositions[e]).filter(Boolean);
    },
    // Assets
    assets: (s) => s.project.assets,
    // History
    canUndo: (s) => s.historyIndex > 0,
    canRedo: (s) => s.historyIndex < s.historyStack.length - 1,
    // Camera
    activeCamera: (s) => s.activeCameraId && s.cameras.get(s.activeCameraId) || null,
    allCameras: (s) => Array.from(s.cameras.values()),
    cameraLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const s = this.project.compositions[this.activeCompositionId];
      return (s == null ? void 0 : s.layers) || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(s, e, n = !1) {
      const i = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = this.project.compositions[this.activeCompositionId], a = {
        width: (e == null ? void 0 : e.width) ?? (o == null ? void 0 : o.settings.width) ?? 1024,
        height: (e == null ? void 0 : e.height) ?? (o == null ? void 0 : o.settings.height) ?? 1024,
        frameCount: (e == null ? void 0 : e.frameCount) ?? (o == null ? void 0 : o.settings.frameCount) ?? 81,
        fps: (e == null ? void 0 : e.fps) ?? (o == null ? void 0 : o.settings.fps) ?? 16,
        duration: 0,
        backgroundColor: (e == null ? void 0 : e.backgroundColor) ?? "#000000",
        autoResizeToContent: (e == null ? void 0 : e.autoResizeToContent) ?? !0
      };
      a.duration = a.frameCount / a.fps;
      const r = {
        id: i,
        name: s,
        settings: a,
        layers: [],
        currentFrame: 0,
        isPrecomp: n
      };
      return this.project.compositions[i] = r, this.openCompositionIds.includes(i) || this.openCompositionIds.push(i), this.activeCompositionId = i, bt.debug("Created composition:", s, i), r;
    },
    /**
     * Delete a composition
     */
    deleteComposition(s) {
      if (s === this.project.mainCompositionId)
        return bt.warn("Cannot delete main composition"), !1;
      if (!this.project.compositions[s]) return !1;
      delete this.project.compositions[s];
      const n = this.openCompositionIds.indexOf(s);
      return n >= 0 && this.openCompositionIds.splice(n, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId), bt.debug("Deleted composition:", s), !0;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(s) {
      if (!this.project.compositions[s]) {
        bt.warn("Composition not found:", s);
        return;
      }
      this.openCompositionIds.includes(s) || this.openCompositionIds.push(s), this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.activeCompositionId = s, bt.debug("Switched to composition:", s);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(s) {
      if (this.openCompositionIds.length <= 1) {
        bt.warn("Cannot close the last tab");
        return;
      }
      const e = this.openCompositionIds.indexOf(s);
      e >= 0 && this.openCompositionIds.splice(e, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[Math.max(0, e - 1)]);
    },
    /**
     * Rename a composition
     */
    renameComposition(s, e) {
      const n = this.project.compositions[s];
      n && (n.name = e);
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(s, e) {
      const n = this.project.compositions[s];
      if (!n) return;
      const i = n.settings.frameCount;
      if (Object.assign(n.settings, e), n.settings.duration = n.settings.frameCount / n.settings.fps, e.frameCount && e.frameCount > i)
        for (const o of n.layers)
          o.outPoint === i - 1 && (o.outPoint = e.frameCount - 1);
      s === this.project.mainCompositionId && Object.assign(this.project.composition, n.settings);
    },
    /**
     * Get a composition by ID
     */
    getComposition(s) {
      return this.project.compositions[s] || null;
    },
    /**
     * Pre-compose selected layers into a new composition
     */
    precomposeSelectedLayers(s) {
      if (this.selectedLayerIds.length === 0)
        return bt.warn("No layers selected for pre-compose"), null;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return null;
      const n = this.createComposition(
        s || "Pre-comp",
        e.settings,
        !0
      ), i = e.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      ), o = Math.min(...i.map((l) => l.inPoint));
      for (const l of i) {
        l.inPoint -= o, l.outPoint -= o;
        const c = e.layers.indexOf(l);
        c >= 0 && e.layers.splice(c, 1), n.layers.push(l);
      }
      const a = Math.max(...n.layers.map((l) => l.outPoint));
      n.settings.frameCount = a + 1, n.settings.duration = n.settings.frameCount / n.settings.fps;
      const r = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: n.name,
        type: "precomp",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        inPoint: o,
        outPoint: o + n.settings.frameCount - 1,
        parentId: null,
        transform: P1(),
        opacity: Yt("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: !1,
        data: {
          compositionId: n.id,
          timeRemapEnabled: !1,
          collapseTransformations: !1
        }
      };
      return e.layers.push(r), this.selectedLayerIds = [], this.activeCompositionId = e.id, bt.debug("Pre-composed layers into:", n.name), n;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(s) {
      this.comfyuiNodeId = s.node_id, this.sourceImage = s.source_image, this.depthMap = s.depth_map;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return;
      const n = e.settings.frameCount;
      if (e.settings.width = s.width, e.settings.height = s.height, e.settings.frameCount = s.frame_count, e.settings.duration = s.frame_count / e.settings.fps, this.project.composition.width = s.width, this.project.composition.height = s.height, this.project.composition.frameCount = s.frame_count, this.project.composition.duration = s.frame_count / this.project.composition.fps, s.frame_count > n)
        for (const i of e.layers)
          i.outPoint === n - 1 && (i.outPoint = s.frame_count - 1);
      s.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.source_image
      }), s.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.depth_map
      }), e && (e.currentFrame = 0), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), bt.debug("Loaded inputs from ComfyUI:", {
        width: s.width,
        height: s.height,
        frameCount: s.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(s, e) {
      const n = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let i = null;
      switch (s) {
        case "text":
          i = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: !1,
            pathPerpendicularToPath: !0,
            pathForceAlignment: !1,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          i = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          i = {
            size: 40
          };
          break;
        case "spline":
          i = {
            pathData: "",
            controlPoints: [],
            closed: !1,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          i = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: !1,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: !0,
              burstOnBeat: !1,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: !1,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: !1,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: !1,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: !1,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: !0
              }
            }
          };
          break;
        case "depthflow":
          i = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: !1
            }
          };
          break;
        case "light":
          i = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: !1,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          i = {
            cameraId: null,
            isActiveCamera: !1
          };
          break;
        case "image":
          i = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          i = {
            assetId: null,
            loop: !1,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let o;
      (s === "video" || s === "audio") && (o = {
        level: Yt("Audio Levels", 0, "number")
        // 0dB default
      });
      const a = this.getActiveComp(), r = this.getActiveCompLayers(), l = {
        id: n,
        name: e || `${s.charAt(0).toUpperCase() + s.slice(1)} ${r.length + 1}`,
        type: s,
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((a == null ? void 0 : a.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Yt("opacity", 100, "number"),
        transform: P1(),
        audio: o,
        properties: [],
        effects: [],
        data: i
      };
      return s === "camera" && bt.warn("Use createCameraLayer() for camera layers"), r.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), l;
    },
    /**
     * Delete a layer
     */
    deleteLayer(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex((i) => i.id === s);
      n !== -1 && (e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((i) => i !== s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(s) {
      const e = this.getActiveCompLayers(), n = e.find((a) => a.id === s);
      if (!n) return null;
      const i = JSON.parse(JSON.stringify(n));
      if (i.id = crypto.randomUUID(), i.name = n.name + " Copy", i.transform)
        for (const a of Object.keys(i.transform)) {
          const r = i.transform[a];
          r != null && r.keyframes && (r.keyframes = r.keyframes.map((l) => ({
            ...l,
            id: crypto.randomUUID()
          })));
        }
      if (i.properties)
        for (const a of i.properties)
          a.keyframes && (a.keyframes = a.keyframes.map((r) => ({
            ...r,
            id: crypto.randomUUID()
          })));
      const o = e.findIndex((a) => a.id === s);
      return e.splice(o, 0, i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), i;
    },
    /**
     * Copy selected layers to clipboard
     */
    copySelectedLayers() {
      const e = this.getActiveCompLayers().filter((n) => this.selectedLayerIds.includes(n.id));
      e.length !== 0 && (this.clipboard.layers = e.map((n) => JSON.parse(JSON.stringify(n))), bt.debug(`Copied ${this.clipboard.layers.length} layer(s) to clipboard`));
    },
    /**
     * Paste layers from clipboard
     */
    pasteLayers() {
      if (this.clipboard.layers.length === 0) return [];
      const s = this.getActiveCompLayers(), e = [];
      for (const n of this.clipboard.layers) {
        const i = JSON.parse(JSON.stringify(n));
        if (i.id = crypto.randomUUID(), i.name = n.name + " Copy", i.transform)
          for (const o of Object.keys(i.transform)) {
            const a = i.transform[o];
            a != null && a.keyframes && (a.keyframes = a.keyframes.map((r) => ({
              ...r,
              id: crypto.randomUUID()
            })));
          }
        if (i.properties)
          for (const o of i.properties)
            o.keyframes && (o.keyframes = o.keyframes.map((a) => ({
              ...a,
              id: crypto.randomUUID()
            })));
        i.parentId = null, s.unshift(i), e.push(i);
      }
      return this.selectedLayerIds = e.map((n) => n.id), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), bt.debug(`Pasted ${e.length} layer(s)`), e;
    },
    /**
     * Cut selected layers (copy + delete)
     */
    cutSelectedLayers() {
      this.copySelectedLayers();
      const s = [...this.selectedLayerIds];
      for (const e of s)
        this.deleteLayer(e);
    },
    /**
     * Update layer properties
     */
    updateLayer(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      !n || !n.data || (Object.assign(n.data, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      i.controlPoints || (i.controlPoints = []), i.controlPoints.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(s, e, n) {
      var r;
      const i = this.getActiveCompLayers().find((l) => l.id === s);
      if (!i || i.type !== "spline" || !i.data) return;
      const a = (r = i.data.controlPoints) == null ? void 0 : r.find((l) => l.id === e);
      a && (Object.assign(a, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((a) => a.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      if (!i.controlPoints) return;
      const o = i.controlPoints.findIndex((a) => a.id === e);
      o >= 0 && (i.controlPoints.splice(o, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(s) {
      const e = this.getActiveCompLayers().find((n) => n.id === s);
      if (e) {
        if (e.threeD = !e.threeD, e.threeD) {
          const n = e.transform, i = n.position.value;
          n.position.value = { x: i.x, y: i.y, z: i.z ?? 0 }, n.position.type = "vector3";
          const o = n.anchorPoint.value;
          n.anchorPoint.value = { x: o.x, y: o.y, z: o.z ?? 0 }, n.anchorPoint.type = "vector3";
          const a = n.scale.value;
          n.scale.value = { x: a.x, y: a.y, z: a.z ?? 100 }, n.scale.type = "vector3", n.orientation || (n.orientation = Yt("orientation", { x: 0, y: 0, z: 0 }, "vector3")), n.rotationX || (n.rotationX = Yt("rotationX", 0, "number")), n.rotationY || (n.rotationY = Yt("rotationY", 0, "number")), n.rotationZ || (n.rotationZ = Yt("rotationZ", 0, "number"), n.rotationZ.value = n.rotation.value);
        } else
          e.transform.rotationZ && (e.transform.rotation.value = e.transform.rotationZ.value);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Reorder layers
     */
    moveLayer(s, e) {
      const n = this.getActiveCompLayers(), i = n.findIndex((a) => a.id === s);
      if (i === -1) return;
      const [o] = n.splice(i, 1);
      n.splice(e, 0, o), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(s, e = !1) {
      e ? this.selectedLayerIds.includes(s) || this.selectedLayerIds.push(s) : this.selectedLayerIds = [s];
    },
    deselectLayer(s) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== s);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(s, e) {
      const n = this.getActiveCompLayers(), i = n.find((o) => o.id === s);
      if (i && e !== s) {
        if (e) {
          const o = (r) => {
            const l = n.filter((u) => u.parentId === r);
            let c = l.map((u) => u.id);
            for (const u of l)
              c = c.concat(o(u.id));
            return c;
          };
          if (new Set(o(s)).has(e)) {
            bt.warn("Cannot set parent: would create circular reference");
            return;
          }
        }
        i.parentId = e, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
      }
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.selectedPropertyPath = null;
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(s) {
      this.selectedPropertyPath = s;
    },
    // ============================================================
    // MOTION ENGINE INTEGRATION
    // ============================================================
    /**
     * Get evaluated FrameState for the current frame
     *
     * This is the CANONICAL way to get evaluated state for rendering.
     * Uses MotionEngine.evaluate() which is PURE and deterministic.
     *
     * @param frame - Optional frame override (defaults to currentFrame)
     * @returns Immutable FrameState snapshot
     */
    getFrameState(s) {
      const e = this.getActiveComp(), n = s ?? (e == null ? void 0 : e.currentFrame) ?? 0;
      return k7.evaluate(
        n,
        this.project,
        this.audioAnalysis,
        this.activeCameraId
      );
    },
    // ============================================================
    // PLAYBACK CONTROLS
    // ============================================================
    /**
     * Start playback
     * NOTE: This only updates UI state (currentFrame).
     * Actual frame evaluation happens via getFrameState().
     */
    play() {
      if (this.isPlaying) return;
      const s = this.getActiveComp();
      s && (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = s.currentFrame, this.playbackLoop());
    },
    /**
     * Pause playback
     */
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    /**
     * Toggle playback state
     */
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     *
     * ARCHITECTURAL NOTE:
     * This method ONLY updates the UI state (currentFrame).
     * It does NOT evaluate or render frames directly.
     * The render loop in Vue components should watch currentFrame
     * and call getFrameState()  engine.applyFrameState().
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const s = this.getActiveComp();
      if (!s) return;
      const e = performance.now() - (this.playbackStartTime || 0), n = s.settings.fps, i = s.settings.frameCount, o = Math.floor(e / 1e3 * n);
      let a = this.playbackStartFrame + o;
      a >= i && (a = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), s.currentFrame = a, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    /**
     * Set current frame (UI state only)
     * Components watching currentFrame should call getFrameState() to evaluate.
     */
    setFrame(s) {
      const e = this.getActiveComp();
      e && (e.currentFrame = Math.max(0, Math.min(s, e.settings.frameCount - 1)));
    },
    /**
     * Advance to next frame (UI state only)
     */
    nextFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame < s.settings.frameCount - 1 && s.currentFrame++;
    },
    /**
     * Go to previous frame (UI state only)
     */
    prevFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame > 0 && s.currentFrame--;
    },
    /**
     * Jump to first frame (UI state only)
     */
    goToStart() {
      const s = this.getActiveComp();
      s && (s.currentFrame = 0);
    },
    /**
     * Jump to last frame (UI state only)
     */
    goToEnd() {
      const s = this.getActiveComp();
      s && (s.currentFrame = s.settings.frameCount - 1);
    },
    /**
     * Tool selection
     */
    setTool(s) {
      this.currentTool = s, s !== "segment" && this.clearSegmentPendingMask();
    },
    /**
     * Set segmentation mode (point or box)
     */
    setSegmentMode(s) {
      this.segmentMode = s, this.clearSegmentPendingMask();
    },
    /**
     * Clear pending segmentation mask
     */
    clearSegmentPendingMask() {
      this.segmentPendingMask = null, this.segmentBoxStart = null;
    },
    /**
     * Set pending segmentation mask (preview before creating layer)
     */
    setSegmentPendingMask(s) {
      this.segmentPendingMask = s;
    },
    /**
     * Set box selection start point
     */
    setSegmentBoxStart(s) {
      this.segmentBoxStart = s;
    },
    /**
     * Set segmentation loading state
     */
    setSegmentLoading(s) {
      this.segmentIsLoading = s;
    },
    /**
     * Confirm pending mask and create layer from it
     */
    async confirmSegmentMask(s) {
      if (!this.segmentPendingMask || !this.sourceImage)
        return null;
      const e = await this._createLayerFromMask(
        this.sourceImage,
        this.segmentPendingMask,
        s,
        !1
      );
      return this.clearSegmentPendingMask(), e;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const s = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(s), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(s) {
      try {
        const e = JSON.parse(s);
        this.project = e, this.pushHistory();
      } catch (e) {
        bt.error("Failed to import project:", e);
      }
    },
    /**
     * Save project to server (ComfyUI backend)
     * @param projectId - Optional existing project ID for overwriting
     * @returns The project ID if successful, null otherwise
     */
    async saveProjectToServer(s) {
      try {
        const { saveProject: e } = await Promise.resolve().then(() => sc), n = await e(this.project, s);
        return n.status === "success" && n.project_id ? (bt.info("Project saved to server:", n.project_id), n.project_id) : (bt.error("Failed to save project:", n.message), null);
      } catch (e) {
        return bt.error("Error saving project to server:", e), null;
      }
    },
    /**
     * Load project from server (ComfyUI backend)
     * @param projectId - The project ID to load
     * @returns True if successful
     */
    async loadProjectFromServer(s) {
      try {
        const { loadProject: e } = await Promise.resolve().then(() => sc), n = await e(s);
        return n.status === "success" && n.project ? (this.project = n.project, this.pushHistory(), bt.info("Project loaded from server:", s), !0) : (bt.error("Failed to load project:", n.message), !1);
      } catch (e) {
        return bt.error("Error loading project from server:", e), !1;
      }
    },
    /**
     * List all projects saved on server
     */
    async listServerProjects() {
      try {
        const { listProjects: s } = await Promise.resolve().then(() => sc), e = await s();
        return e.status === "success" && e.projects ? e.projects : [];
      } catch (s) {
        return bt.error("Error listing projects:", s), [];
      }
    },
    /**
     * Delete a project from server
     * @param projectId - The project ID to delete
     * @returns True if successful
     */
    async deleteServerProject(s) {
      try {
        const { deleteProject: e } = await Promise.resolve().then(() => sc);
        return (await e(s)).status === "success";
      } catch (e) {
        return bt.error("Error deleting project:", e), !1;
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(s) {
      var e;
      return mt(s, ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(s, e, n, i) {
      var u, d, h;
      const o = i ?? ((u = this.getActiveComp()) == null ? void 0 : u.currentFrame) ?? 0;
      bt.debug("addKeyframe called:", { layerId: s, propertyName: e, value: n, frame: o });
      const a = this.getActiveCompLayers().find((p) => p.id === s);
      if (!a)
        return bt.debug("addKeyframe: layer not found"), null;
      let r;
      if (e === "position" || e === "transform.position" ? r = a.transform.position : e === "scale" || e === "transform.scale" ? r = a.transform.scale : e === "rotation" || e === "transform.rotation" ? r = a.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = a.transform.anchorPoint : e === "opacity" ? r = a.opacity : r = a.properties.find((p) => p.name === e), !r)
        return bt.debug("addKeyframe: property not found:", e), null;
      r.animated = !0;
      const l = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: o,
        value: n,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 },
        controlMode: "smooth"
      }, c = r.keyframes.findIndex((p) => p.frame === o);
      return c >= 0 ? (r.keyframes[c] = l, bt.debug("addKeyframe: replaced existing keyframe at frame", ((d = this.getActiveComp()) == null ? void 0 : d.currentFrame) ?? 0)) : (r.keyframes.push(l), r.keyframes.sort((p, f) => p.frame - f.frame), bt.debug("addKeyframe: added new keyframe at frame", ((h = this.getActiveComp()) == null ? void 0 : h.currentFrame) ?? 0, "total keyframes:", r.keyframes.length)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), l;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(s, e, n) {
      const i = this.getActiveCompLayers().find((r) => r.id === s);
      if (!i) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = i.transform.position : e === "scale" || e === "transform.scale" ? o = i.transform.scale : e === "rotation" || e === "transform.rotation" ? o = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = i.transform.anchorPoint : e === "opacity" ? o = i.opacity : o = i.properties.find((r) => r.name === e), !o) return;
      const a = o.keyframes.findIndex((r) => r.id === n);
      a >= 0 && (o.keyframes.splice(a, 1), o.keyframes.length === 0 && (o.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = i.transform.position : e === "scale" || e === "transform.scale" ? o = i.transform.scale : e === "rotation" || e === "transform.rotation" ? o = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = i.transform.anchorPoint : e === "opacity" ? o = i.opacity : o = i.properties.find((a) => a.name === e), !!o) {
        if (o.value = n, o.animated && o.keyframes.length > 0) {
          const a = o.keyframes.find((r) => {
            var l;
            return r.frame === (((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0);
          });
          a && (a.value = n);
        }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i) return;
      let o;
      e === "position" || e === "transform.position" ? o = i.transform.position : e === "scale" || e === "transform.scale" ? o = i.transform.scale : e === "rotation" || e === "transform.rotation" ? o = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = i.transform.anchorPoint : e === "opacity" ? o = i.opacity : o = i.properties.find((a) => a.name === e), o && (o.animated = n, n && o.keyframes.length === 0 && this.addKeyframe(s, e, o.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(s, e, n, i) {
      const o = this.getActiveCompLayers().find((c) => c.id === s);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : e === "opacity" ? a = o.opacity : a = o.properties.find((c) => c.name === e), !a) return;
      const r = a.keyframes.find((c) => c.id === n);
      if (!r) return;
      const l = a.keyframes.find((c) => c.frame === i && c.id !== n);
      l && (a.keyframes = a.keyframes.filter((c) => c.id !== l.id)), r.frame = i, a.keyframes.sort((c, u) => c.frame - u.frame), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set keyframe value (for graph editor numeric input)
     */
    setKeyframeValue(s, e, n, i) {
      const o = this.getActiveCompLayers().find((l) => l.id === s);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : e === "opacity" ? a = o.opacity : a = o.properties.find((l) => l.name === e), !a) return;
      const r = a.keyframes.find((l) => l.id === n);
      r && (typeof r.value == "object" && r.value !== null ? bt.warn("setKeyframeValue: Cannot directly update vector keyframes from graph editor. Use separate dimension curves.") : r.value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(s, e, n, i) {
      const o = this.getActiveCompLayers().find((l) => l.id === s);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : e === "opacity" ? a = o.opacity : a = o.properties.find((l) => l.name === e), !a) return;
      const r = a.keyframes.find((l) => l.id === n);
      r && (r.interpolation = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(s, e, n, i) {
      const o = this.getActiveCompLayers().find((l) => l.id === s);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "opacity" ? a = o.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : a = o.properties.find((l) => l.id === e || l.name === e), !a) return;
      const r = a.keyframes.find((l) => l.id === n);
      r && (i.frame !== void 0 && (r.frame = i.frame, a.keyframes.sort((l, c) => l.frame - c.frame)), i.value !== void 0 && (r.value = i.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(s, e, n, i, o) {
      const a = this.getActiveCompLayers().find((c) => c.id === s);
      if (!a) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = a.transform.position : e === "scale" || e === "transform.scale" ? r = a.transform.scale : e === "rotation" || e === "transform.rotation" ? r = a.transform.rotation : e === "opacity" ? r = a.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? r = a.transform.anchorPoint : r = a.properties.find((c) => c.id === e || c.name === e), !r) return;
      const l = r.keyframes.find((c) => c.id === n);
      l && (i === "in" ? l.inHandle = { ...o } : l.outHandle = { ...o }, o.enabled && l.interpolation === "linear" && (l.interpolation = "bezier"), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(s = "Text") {
      const e = this.createLayer("text", s.substring(0, 20)), n = {
        text: s,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: !1,
        pathPerpendicularToPath: !0,
        pathForceAlignment: !1,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: !1
      };
      return e.data = n, e.properties.push(Yt("Font Size", 72, "number", "Text")), e.properties.push(Yt("Fill Color", "#ffffff", "color", "Text")), e.properties.push(Yt("Stroke Color", "#000000", "color", "Text")), e.properties.push(Yt("Stroke Width", 0, "number", "Text")), e.properties.push(Yt("Path Offset", 0, "number", "Path Options")), e.properties.push(Yt("First Margin", 0, "number", "Path Options")), e.properties.push(Yt("Last Margin", 0, "number", "Path Options")), e.properties.push(Yt("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options")), e.properties.push(Yt("Tracking", 0, "number", "Advanced")), e.properties.push(Yt("Line Spacing", 0, "number", "Advanced")), e.properties.push(Yt("Character Offset", 0, "number", "Advanced")), e.properties.push(Yt("Character Value", 0, "number", "Advanced")), e.properties.push(Yt("Blur", { x: 0, y: 0 }, "position", "Advanced")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const s = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return s.data = e, s;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const s = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20,
          // Geometric emitter shape defaults
          shape: "point",
          shapeRadius: 0.1,
          shapeWidth: 0.2,
          shapeHeight: 0.2,
          shapeDepth: 0.2,
          shapeInnerRadius: 0.05,
          emitFromEdge: !1,
          emitFromVolume: !1,
          // Spline path emission (null = disabled)
          splinePath: null,
          // Sprite configuration
          sprite: {
            enabled: !1,
            imageUrl: null,
            imageData: null,
            isSheet: !1,
            columns: 1,
            rows: 1,
            totalFrames: 1,
            frameRate: 30,
            playMode: "loop",
            billboard: !0,
            rotationEnabled: !1,
            rotationSpeed: 0,
            rotationSpeedVariance: 0,
            alignToVelocity: !1
          }
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return s.data = e, s;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(s, e, n) {
      const i = this.getActiveCompLayers().find((r) => r.id === s);
      if (!i || i.type !== "particles") return;
      const a = i.data.emitters.find((r) => r.id === e);
      a && (Object.assign(a, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      i.emitters = i.emitters.filter((o) => o.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(s = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), i = {
        sourceLayerId: s,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: Yt("zoom", 1, "number"),
        animatedOffsetX: Yt("offsetX", 0, "number"),
        animatedOffsetY: Yt("offsetY", 0, "number"),
        animatedRotation: Yt("rotation", 0, "number"),
        animatedDepthScale: Yt("depthScale", 1, "number")
      };
      return n.data = i, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "depthflow") return;
      const i = n.data;
      Object.assign(i.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(s, e = !0) {
      let n;
      try {
        n = URL.createObjectURL(s);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let i;
      try {
        i = await Ow(n);
      } catch (c) {
        throw URL.revokeObjectURL(n), new Error(`Failed to load video metadata: ${c.message}`);
      }
      const o = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, a = {
        id: o,
        type: "video",
        source: "file",
        width: i.width,
        height: i.height,
        data: n,
        // Video-specific metadata
        duration: i.duration,
        frameCount: i.frameCount,
        fps: i.fps,
        hasAudio: i.hasAudio
      };
      if (this.project.assets[o] = a, e) {
        const c = Uw(i, this.project.composition.fps);
        bt.debug("Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: c.width,
          newHeight: c.height,
          newFrameCount: c.frameCount,
          videoDuration: i.duration
        }), this.project.composition.width = c.width, this.project.composition.height = c.height, this.project.composition.frameCount = c.frameCount, this.project.composition.duration = c.frameCount / this.project.composition.fps;
      }
      const r = this.createLayer("video", s.name.replace(/\.[^.]+$/, "")), l = {
        assetId: o,
        loop: !1,
        pingPong: !1,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: i.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      if (r.data = l, !e) {
        const c = Math.ceil(i.duration * this.project.composition.fps);
        r.outPoint = Math.min(c - 1, this.project.composition.frameCount - 1);
      }
      return this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), bt.debug("Created video layer:", {
        layerId: r.id,
        assetId: o,
        dimensions: `${i.width}x${i.height}`,
        duration: `${i.duration.toFixed(2)}s`,
        frameCount: i.frameCount,
        hasAudio: i.hasAudio
      }), r;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(s, e) {
      const n = this.getActiveCompLayers().find((a) => a.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      if (!i.assetId) return;
      const o = this.project.assets[i.assetId];
      o && (o.width = e.width, o.height = e.height, o.duration = e.duration, o.frameCount = e.frameCount, o.fps = e.fps, o.hasAudio = e.hasAudio), bt.debug("Video metadata loaded:", { layerId: s, metadata: e });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(s, e, n) {
      const i = this.getActiveComp();
      if (!i) return;
      const o = i.settings.frameCount;
      if (i.settings.width = s, i.settings.height = e, this.project.composition.width = s, this.project.composition.height = e, n !== void 0 && (i.settings.frameCount = n, i.settings.duration = n / i.settings.fps, this.project.composition.frameCount = n, this.project.composition.duration = n / this.project.composition.fps, n > o))
        for (const a of i.layers)
          a.outPoint === o - 1 && (a.outPoint = n - 1);
      i.currentFrame >= i.settings.frameCount && (i.currentFrame = i.settings.frameCount - 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), bt.debug("Composition resized:", {
        width: s,
        height: e,
        frameCount: i.settings.frameCount
      });
    },
    // ============================================================
    // PRECOMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a precomp layer referencing another composition
     * (For future multi-composition architecture)
     */
    createPrecompLayer(s, e) {
      const n = this.createLayer("precomp", e || "Precomp"), i = {
        compositionId: s,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        collapseTransformations: !1,
        overrideFrameRate: !1,
        frameRate: void 0
      };
      return n.data = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), n;
    },
    /**
     * Update precomp layer data
     */
    updatePrecompLayerData(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "precomp") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // SEGMENTATION  LAYER PIPELINE (Vision Model Integration)
    // ============================================================
    /**
     * Segment source image by clicking a point and create a layer from the result.
     * This is the primary entry point for the Vision  Layer pipeline used by
     * Time-to-Move and other diffusion model integrations.
     *
     * @param point - Click coordinates in image space
     * @param options - Additional options
     * @returns Promise resolving to the created layer, or null if failed
     */
    async segmentToLayerByPoint(s, e = {}) {
      const n = this.sourceImage;
      if (!n)
        return bt.error("No source image available for segmentation"), null;
      try {
        const i = await qm(n, s, e.model || "sam2");
        if (i.status !== "success" || !i.masks || i.masks.length === 0)
          return bt.error("Segmentation failed:", i.message), null;
        const o = i.masks[0];
        return this._createLayerFromMask(n, o, e.layerName, e.positionAtCenter);
      } catch (i) {
        return bt.error("Segmentation error:", i), null;
      }
    },
    /**
     * Segment source image by box selection and create a layer from the result.
     *
     * @param box - Selection box [x1, y1, x2, y2] in image space
     * @param options - Additional options
     * @returns Promise resolving to the created layer, or null if failed
     */
    async segmentToLayerByBox(s, e = {}) {
      const n = this.sourceImage;
      if (!n)
        return bt.error("No source image available for segmentation"), null;
      try {
        const i = await Zm(n, s, e.model || "sam2");
        if (i.status !== "success" || !i.masks || i.masks.length === 0)
          return bt.error("Segmentation failed:", i.message), null;
        const o = i.masks[0];
        return this._createLayerFromMask(n, o, e.layerName, e.positionAtCenter);
      } catch (i) {
        return bt.error("Segmentation error:", i), null;
      }
    },
    /**
     * Segment source image with multiple positive/negative points.
     *
     * @param foregroundPoints - Points to include in selection
     * @param backgroundPoints - Points to exclude from selection
     * @param options - Additional options
     */
    async segmentToLayerByMultiplePoints(s, e = [], n = {}) {
      const i = this.sourceImage;
      if (!i)
        return bt.error("No source image available for segmentation"), null;
      try {
        const o = await TM(
          i,
          s,
          e,
          n.model || "sam2"
        );
        if (o.status !== "success" || !o.masks || o.masks.length === 0)
          return bt.error("Segmentation failed:", o.message), null;
        const a = o.masks[0];
        return this._createLayerFromMask(i, a, n.layerName, n.positionAtCenter);
      } catch (o) {
        return bt.error("Segmentation error:", o), null;
      }
    },
    /**
     * Auto-segment all objects in the source image and create layers.
     *
     * @param options - Segmentation options
     * @returns Promise resolving to array of created layers
     */
    async autoSegmentToLayers(s = {}) {
      const e = this.sourceImage;
      if (!e)
        return bt.error("No source image available for segmentation"), [];
      try {
        const n = await EM(e, {
          model: s.model || "sam2",
          minArea: s.minArea || 1e3,
          maxMasks: s.maxMasks || 10
        });
        if (n.status !== "success" || !n.masks || n.masks.length === 0)
          return bt.error("Auto-segmentation failed:", n.message), [];
        const i = [], o = s.namePrefix || "Segment";
        for (let a = 0; a < n.masks.length; a++) {
          const r = n.masks[a], l = await this._createLayerFromMask(
            e,
            r,
            `${o} ${a + 1}`,
            !1
            // Don't center - preserve original position
          );
          l && i.push(l);
        }
        return i;
      } catch (n) {
        return bt.error("Auto-segmentation error:", n), [];
      }
    },
    /**
     * Internal: Create an image layer from a segmentation mask
     */
    async _createLayerFromMask(s, e, n, i = !1) {
      try {
        const o = await AM(
          s,
          e.mask,
          e.bounds
        ), a = `seg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, r = {
          id: a,
          type: "image",
          source: "generated",
          width: e.bounds.width,
          height: e.bounds.height,
          data: o
        };
        this.project.assets[a] = r;
        const l = this.createLayer("image", n || "Segmented"), c = {
          assetId: a,
          fit: "none",
          // Don't scale - use original size
          sourceType: "segmented"
        };
        return l.data = c, i ? l.transform.position.value = {
          x: this.project.composition.width / 2,
          y: this.project.composition.height / 2
        } : l.transform.position.value = {
          x: e.bounds.x + e.bounds.width / 2,
          y: e.bounds.y + e.bounds.height / 2
        }, l.transform.anchorPoint.value = {
          x: e.bounds.width / 2,
          y: e.bounds.height / 2
        }, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), bt.info(`Created segmented layer: ${l.name} (${e.bounds.width}x${e.bounds.height})`), l;
      } catch (o) {
        return bt.error("Failed to create layer from mask:", o), null;
      }
    },
    // ============================================================
    // EFFECT ACTIONS
    // ============================================================
    /**
     * Add effect to layer
     */
    addEffectToLayer(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n) return;
      const i = pM(e);
      i && (n.effects || (n.effects = []), n.effects.push(i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Remove effect from layer
     */
    removeEffectFromLayer(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.findIndex((o) => o.id === e);
      i >= 0 && (n.effects.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update effect parameter value
     */
    updateEffectParameter(s, e, n, i) {
      const o = this.getActiveCompLayers().find((r) => r.id === s);
      if (!o || !o.effects) return;
      const a = o.effects.find((r) => r.id === e);
      !a || !a.parameters[n] || (a.parameters[n].value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle effect parameter animation state
     */
    setEffectParamAnimated(s, e, n, i) {
      const o = this.getActiveCompLayers().find((l) => l.id === s);
      if (!o || !o.effects) return;
      const a = o.effects.find((l) => l.id === e);
      if (!a || !a.parameters[n]) return;
      const r = a.parameters[n];
      r.animated = i, i && (!r.keyframes || r.keyframes.length === 0) && (r.keyframes = [{
        id: `kf_${Date.now()}`,
        frame: this.currentFrame,
        value: r.value,
        interpolation: "linear",
        inHandle: { frame: -5, value: 0, enabled: !1 },
        outHandle: { frame: 5, value: 0, enabled: !1 },
        controlMode: "smooth"
      }]), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Toggle effect enabled state
     */
    toggleEffect(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.find((o) => o.id === e);
      i && (i.enabled = !i.enabled, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder effects in stack
     */
    reorderEffects(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i || !i.effects || e < 0 || e >= i.effects.length || n < 0 || n >= i.effects.length) return;
      const [o] = i.effects.splice(e, 1);
      i.effects.splice(n, 0, o), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get evaluated effect parameter value at a given frame
     */
    getEffectParameterValue(s, e, n, i) {
      var c;
      const o = this.getActiveCompLayers().find((u) => u.id === s);
      if (!o || !o.effects) return null;
      const a = o.effects.find((u) => u.id === e);
      if (!a || !a.parameters[n]) return null;
      const r = a.parameters[n], l = i ?? ((c = this.getActiveComp()) == null ? void 0 : c.currentFrame) ?? 0;
      return r.animated && r.keyframes.length > 0 ? mt(r, l) : r.value;
    },
    // ============================================================
    // CAMERA ACTIONS
    // ============================================================
    /**
     * Create a new camera and corresponding layer
     * Returns both the camera and the layer
     */
    createCameraLayer(s) {
      const e = this.getActiveComp(), n = this.getActiveCompLayers(), i = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = s || `Camera ${this.cameras.size + 1}`, a = $m(
        i,
        (e == null ? void 0 : e.settings.width) || 1024,
        (e == null ? void 0 : e.settings.height) || 1024
      );
      a.name = o, this.cameras.set(i, a), this.activeCameraId || (this.activeCameraId = i);
      const r = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, l = {
        id: r,
        name: o,
        type: "camera",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !0,
        // Cameras are always 3D
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((e == null ? void 0 : e.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Yt("opacity", 100, "number"),
        transform: P1(),
        properties: [],
        effects: [],
        data: {
          cameraId: i,
          isActiveCamera: !this.activeCameraId || this.activeCameraId === i
        }
      };
      return n.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), this.selectLayer(r), { camera: a, layer: l };
    },
    /**
     * Get a camera by ID
     */
    getCamera(s) {
      return this.cameras.get(s) || null;
    },
    /**
     * Update camera properties
     */
    updateCamera(s, e) {
      const n = this.cameras.get(s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set the active camera
     */
    setActiveCamera(s) {
      if (!this.cameras.has(s)) return;
      this.activeCameraId = s;
      const e = this.getActiveCompLayers();
      for (const n of e)
        if (n.type === "camera" && n.data) {
          const i = n.data;
          i.isActiveCamera = i.cameraId === s;
        }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Delete a camera (and its layer)
     */
    deleteCamera(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex(
        (i) => {
          var o;
          return i.type === "camera" && ((o = i.data) == null ? void 0 : o.cameraId) === s;
        }
      );
      if (n !== -1) {
        const i = e[n].id;
        e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((o) => o !== i);
      }
      if (this.cameras.delete(s), this.activeCameraId === s) {
        const i = Array.from(this.cameras.keys());
        this.activeCameraId = i.length > 0 ? i[0] : null, this.activeCameraId && this.setActiveCamera(this.activeCameraId);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get camera keyframes for a specific camera
     */
    getCameraKeyframes(s) {
      return this.cameraKeyframes.get(s) || [];
    },
    /**
     * Add a keyframe to a camera
     */
    addCameraKeyframe(s, e) {
      let n = this.cameraKeyframes.get(s);
      n || (n = [], this.cameraKeyframes.set(s, n));
      const i = n.findIndex((o) => o.frame === e.frame);
      i >= 0 ? n[i] = e : (n.push(e), n.sort((o, a) => o.frame - a.frame)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Remove a keyframe from a camera
     */
    removeCameraKeyframe(s, e) {
      const n = this.cameraKeyframes.get(s);
      if (!n) return;
      const i = n.findIndex((o) => o.frame === e);
      i >= 0 && (n.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Get camera with keyframe interpolation applied at a specific frame
     * This is the main method for getting animated camera values
     */
    getCameraAtFrame(s, e) {
      const n = this.cameras.get(s);
      if (!n) return null;
      const i = this.cameraKeyframes.get(s);
      if (!i || i.length === 0)
        return n;
      const o = $r(n, i, e);
      return {
        ...n,
        position: o.position,
        orientation: o.rotation,
        focalLength: o.focalLength,
        zoom: o.zoom,
        depthOfField: {
          ...n.depthOfField,
          focusDistance: o.focusDistance
        }
      };
    },
    /**
     * Get the active camera with interpolation at current frame
     */
    getActiveCameraAtFrame(s) {
      return this.activeCameraId ? this.getCameraAtFrame(this.activeCameraId, s ?? this.currentFrame) : null;
    },
    /**
     * Update viewport state
     */
    updateViewportState(s) {
      Object.assign(this.viewportState, s);
    },
    /**
     * Update view options
     */
    updateViewOptions(s) {
      Object.assign(this.viewOptions, s);
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(s) {
      this.audioFile = s, this.audioBuffer = null, this.audioAnalysis = null, this.audioLoadingState = "decoding", this.audioLoadingProgress = 0, this.audioLoadingPhase = "Preparing...", this.audioLoadingError = null;
      try {
        const e = await sM(
          s,
          this.project.composition.fps,
          {
            onProgress: (n) => {
              n.phase === "decoding" ? this.audioLoadingState = "decoding" : this.audioLoadingState = "analyzing", this.audioLoadingProgress = n.progress, this.audioLoadingPhase = n.message;
            }
          }
        );
        this.audioBuffer = e.buffer, this.audioAnalysis = e.analysis, this.audioLoadingState = "complete", this.audioLoadingProgress = 1, this.audioLoadingPhase = "Complete", this.initializeAudioReactiveMapper(), this.propertyDriverSystem && this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis), bt.debug("Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        bt.error("Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null, this.audioLoadingState = "error", this.audioLoadingError = e.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelAudioLoad() {
      nM(), this.audioLoadingState = "idle", this.audioLoadingProgress = 0, this.audioLoadingPhase = "", this.audioLoadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.cancelAudioLoad(), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(s, e) {
      var n;
      return this.audioAnalysis ? Li(this.audioAnalysis, s, e ?? ((n = this.getActiveComp()) == null ? void 0 : n.currentFrame) ?? 0) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(s, e) {
      const n = this.audioMappings.get(s) || [];
      n.push(e), this.audioMappings.set(s, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(s, e) {
      const n = this.audioMappings.get(s);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(s));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(s) {
      return this.audioMappings.get(s) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(s) {
      this.peakData = s, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(s);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(s) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = G3(e, s);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(s) {
      this.audioReactiveMappings.push(s), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(s);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(s) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === s);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(s);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(s, e) {
      const n = this.audioReactiveMappings.find((i) => i.id === s);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(s, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(s, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(s) {
      var e;
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(s ?? ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(s) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === s || e.targetLayerId === void 0)
      );
    },
    /**
     * Get audio reactive values for a specific layer at a specific frame
     * This is called by the engine during frame evaluation
     */
    getAudioReactiveValuesForLayer(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValuesForLayerAtFrame(s, e) : /* @__PURE__ */ new Map();
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      var s;
      return this.audioAnalysis ? np(this.audioAnalysis, ((s = this.getActiveComp()) == null ? void 0 : s.currentFrame) ?? 0) : !1;
    },
    // ============================================================
    // TIMELINE SNAPPING
    // ============================================================
    /**
     * Find nearest snap point for a given frame
     * @param frame - The frame to snap
     * @param pixelsPerFrame - Current zoom level
     * @param selectedLayerId - Currently selected layer (excluded from keyframe snapping)
     */
    findSnapPoint(s, e, n) {
      var i;
      return Wh(s, this.snapConfig, e, {
        layers: this.layers,
        selectedLayerId: n,
        currentFrame: ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    /**
     * Get all beat frames from audio analysis
     */
    getAudioBeatFrames() {
      return MM(this.audioAnalysis);
    },
    /**
     * Get all peak frames from peak data
     */
    getAudioPeakFrames() {
      return SM(this.peakData);
    },
    /**
     * Update snap configuration
     */
    setSnapConfig(s) {
      this.snapConfig = { ...this.snapConfig, ...s };
    },
    /**
     * Toggle snapping enabled
     */
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    /**
     * Toggle specific snap type
     */
    toggleSnapType(s) {
      const n = {
        grid: "snapToGrid",
        keyframes: "snapToKeyframes",
        beats: "snapToBeats",
        peaks: "snapToPeaks",
        layerBounds: "snapToLayerBounds",
        playhead: "snapToPlayhead"
      }[s];
      n && typeof this.snapConfig[n] == "boolean" && (this.snapConfig[n] = !this.snapConfig[n]);
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(s, e = {}) {
      const n = new hM(e);
      this.pathAnimators.set(s, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(s) {
      this.pathAnimators.delete(s);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(s) {
      return this.pathAnimators.get(s);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      var i;
      if (!this.audioAnalysis) return;
      const s = ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0, e = Li(this.audioAnalysis, "amplitude", s), n = np(this.audioAnalysis, s);
      for (const [o, a] of this.pathAnimators)
        a.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const s of this.pathAnimators.values())
        s.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new rM(this.audioAnalysis);
        for (const s of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(s);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (Expressions/Links)
    // ============================================================
    /**
     * Initialize the property driver system
     */
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new yM(), this.propertyDriverSystem.setPropertyGetter((s, e, n) => this.getPropertyValueAtFrame(s, e, n)), this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const s of this.propertyDrivers)
        this.propertyDriverSystem.addDriver(s);
    },
    /**
     * Get a property value at a specific frame
     * Used by the driver system to read source properties
     */
    getPropertyValueAtFrame(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i) return null;
      const o = e.split(".");
      if (o[0] === "transform") {
        const a = i.transform;
        if (o[1] === "position") {
          const r = mt(a.position, n);
          if (o[2] === "x") return r.x;
          if (o[2] === "y") return r.y;
          if (o[2] === "z") return r.z ?? 0;
        }
        if (o[1] === "anchorPoint") {
          const r = mt(a.anchorPoint, n);
          if (o[2] === "x") return r.x;
          if (o[2] === "y") return r.y;
          if (o[2] === "z") return r.z ?? 0;
        }
        if (o[1] === "scale") {
          const r = mt(a.scale, n);
          if (o[2] === "x") return r.x;
          if (o[2] === "y") return r.y;
          if (o[2] === "z") return r.z ?? 100;
        }
        if (o[1] === "rotation")
          return mt(a.rotation, n);
        if (o[1] === "rotationX" && a.rotationX)
          return mt(a.rotationX, n);
        if (o[1] === "rotationY" && a.rotationY)
          return mt(a.rotationY, n);
        if (o[1] === "rotationZ" && a.rotationZ)
          return mt(a.rotationZ, n);
      }
      return o[0] === "opacity" ? mt(i.opacity, n) : null;
    },
    /**
     * Get driven property values for a layer at current frame
     */
    getDrivenValuesForLayer(s) {
      var l;
      if (!this.propertyDriverSystem)
        return /* @__PURE__ */ new Map();
      const e = this.getActiveCompLayers().find((c) => c.id === s);
      if (!e) return /* @__PURE__ */ new Map();
      const n = /* @__PURE__ */ new Map(), i = ((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0, o = mt(e.transform.position, i);
      n.set("transform.position.x", o.x), n.set("transform.position.y", o.y), n.set("transform.position.z", o.z ?? 0);
      const a = mt(e.transform.anchorPoint, i);
      n.set("transform.anchorPoint.x", a.x), n.set("transform.anchorPoint.y", a.y), n.set("transform.anchorPoint.z", a.z ?? 0);
      const r = mt(e.transform.scale, i);
      return n.set("transform.scale.x", r.x), n.set("transform.scale.y", r.y), n.set("transform.scale.z", r.z ?? 100), n.set("transform.rotation", mt(e.transform.rotation, i)), e.transform.rotationX && n.set("transform.rotationX", mt(e.transform.rotationX, i)), e.transform.rotationY && n.set("transform.rotationY", mt(e.transform.rotationY, i)), e.transform.rotationZ && n.set("transform.rotationZ", mt(e.transform.rotationZ, i)), n.set("opacity", mt(e.opacity, i)), this.propertyDriverSystem.evaluateLayerDrivers(s, i, n);
    },
    /**
     * Add a property driver
     * Returns false if adding would create a circular dependency
     */
    addPropertyDriver(s) {
      return this.propertyDriverSystem && !this.propertyDriverSystem.addDriver(s) ? (bt.warn("Cannot add property driver: would create circular dependency"), !1) : (this.propertyDrivers.push(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), !0);
    },
    /**
     * Create and add an audio-driven property driver
     */
    createAudioPropertyDriver(s, e, n, i = {}) {
      const o = xM(s, e, n, i);
      return this.addPropertyDriver(o), o;
    },
    /**
     * Create and add a property-to-property link
     * Returns null if creating would cause a circular dependency
     */
    createPropertyLink(s, e, n, i, o = {}) {
      const a = bM(
        s,
        e,
        n,
        i,
        o
      );
      return this.addPropertyDriver(a) ? a : null;
    },
    /**
     * Remove a property driver
     */
    removePropertyDriver(s) {
      const e = this.propertyDrivers.findIndex((n) => n.id === s);
      e >= 0 && this.propertyDrivers.splice(e, 1), this.propertyDriverSystem && this.propertyDriverSystem.removeDriver(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Update a property driver
     */
    updatePropertyDriver(s, e) {
      const n = this.propertyDrivers.find((i) => i.id === s);
      n && Object.assign(n, e), this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Get all drivers for a layer
     */
    getDriversForLayer(s) {
      return this.propertyDrivers.filter((e) => e.targetLayerId === s);
    },
    /**
     * Toggle driver enabled state
     */
    togglePropertyDriver(s) {
      const e = this.propertyDrivers.find((n) => n.id === s);
      e && (e.enabled = !e.enabled, this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, { enabled: e.enabled }), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    // ============================================================
    // PARTICLE SIMULATION ACTIONS
    // ============================================================
    /**
     * Reset a particle layer's simulation
     * Called when particle configuration changes
     */
    resetParticleSimulation(s) {
      nd.resetLayer(s), bt.debug("Reset particle simulation for layer:", s);
    },
    /**
     * Clear all particle simulations
     * Called on project load/new
     */
    clearAllParticleSimulations() {
      nd.clear(), bt.debug("Cleared all particle simulations");
    },
    /**
     * Get particle snapshot for a layer at a specific frame
     * Evaluates the frame state to get the deterministic snapshot
     */
    getParticleSnapshot(s, e) {
      return this.getFrameState(e).particleSnapshots[s] ?? null;
    },
    /**
     * Get all particle snapshots from current frame
     */
    getAllParticleSnapshots(s) {
      return this.getFrameState(s).particleSnapshots;
    }
  }
});
async function A2(s) {
  try {
    const e = await s.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function PM() {
  if ("gpu" in navigator)
    try {
      const i = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (i) {
        let o = "";
        if ("info" in i) {
          const a = i.info;
          o = (a == null ? void 0 : a.device) || (a == null ? void 0 : a.description) || "";
        }
        return o.includes("RTX 50") || o.toLowerCase().includes("blackwell") || o.includes("B100") || o.includes("B200") ? {
          tier: "blackwell",
          vram: await A2(i),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await A2(i),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      _s.warn("WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), i = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return _s.debug("WebGL renderer:", i), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const kM = { class: "project-panel" }, DM = { class: "panel-header" }, IM = { class: "header-actions" }, RM = { class: "dropdown-container" }, LM = {
  key: 0,
  class: "dropdown-menu"
}, FM = {
  key: 0,
  class: "search-bar"
}, OM = { class: "panel-content" }, UM = { class: "folder-tree" }, zM = ["onClick", "onDblclick"], BM = ["onClick"], NM = { class: "folder-name" }, VM = { class: "item-count" }, HM = {
  key: 0,
  class: "folder-contents"
}, GM = ["onClick", "onDblclick", "onDragstart"], $M = { class: "item-icon" }, WM = { class: "item-name" }, jM = { class: "item-info" }, XM = ["onClick", "onDblclick", "onDragstart"], YM = { class: "item-icon" }, qM = { class: "item-name" }, ZM = { class: "item-info" }, KM = {
  key: 0,
  class: "empty-state"
}, JM = {
  key: 1,
  class: "panel-footer"
}, QM = { class: "item-details" }, eS = { class: "detail-label" }, tS = { class: "detail-info" }, nS = /* @__PURE__ */ Bt({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = un(), o = xe(null), a = xe(!1), r = xe(!1), l = xe(""), c = xe(null), u = xe(["compositions", "footage"]), d = xe([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), h = xe([]), p = Re(() => {
      if (!l.value) return d.value;
      const k = l.value.toLowerCase();
      return d.value.map((U) => ({
        ...U,
        items: U.items.filter(
          (I) => I.name.toLowerCase().includes(k)
        )
      })).filter((U) => U.items.length > 0 || U.name.toLowerCase().includes(k));
    }), f = Re(() => {
      if (!l.value) return h.value;
      const k = l.value.toLowerCase();
      return h.value.filter(
        (U) => U.name.toLowerCase().includes(k)
      );
    }), m = Re(() => {
      if (!c.value) return null;
      for (const U of d.value) {
        const I = U.items.find((W) => W.id === c.value);
        if (I)
          return {
            name: I.name,
            info: A(I)
          };
      }
      const k = h.value.find((U) => U.id === c.value);
      return k ? {
        name: k.name,
        info: A(k)
      } : null;
    });
    function y(k) {
      const U = u.value.indexOf(k);
      U >= 0 ? u.value.splice(U, 1) : u.value.push(k);
    }
    function g(k) {
      c.value = k;
    }
    function x(k) {
      k.type === "composition" && console.log("Opening composition:", k.name);
    }
    function w() {
      r.value = !1, n("openCompositionSettings");
    }
    function M() {
      r.value = !1;
      const k = i.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", k.id);
    }
    function _() {
      r.value = !1;
      const k = i.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", k.id);
    }
    function C() {
      r.value = !1;
      const k = i.createLayer("null", "Null");
      console.log("[ProjectPanel] Created null layer:", k.id);
    }
    function T() {
      r.value = !1;
      const k = i.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", k.id);
    }
    function P() {
      var k;
      (k = o.value) == null || k.click();
    }
    async function E(k) {
      const U = k.target, I = U.files;
      if (!(!I || I.length === 0)) {
        for (const W of Array.from(I)) {
          const fe = b(W), q = {
            id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: W.name,
            type: fe
          };
          if (fe === "audio")
            i.loadAudio(W);
          else if (W.type.startsWith("video/"))
            try {
              const Q = await i.createVideoLayer(W, !0);
              q.id = Q.id, q.width = i.width, q.height = i.height, q.duration = i.frameCount, q.fps = i.fps, console.log("[ProjectPanel] Video layer created:", Q.id, Q.name);
            } catch (Q) {
              console.error("[ProjectPanel] Failed to import video:", Q);
              continue;
            }
          else if (W.type.startsWith("image/")) {
            const Q = URL.createObjectURL(W), K = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            i.project.assets[K] = {
              id: K,
              type: "image",
              source: "file",
              width: 0,
              // Will be updated when image loads
              height: 0,
              data: Q
            };
            const Y = i.createLayer("image", W.name.replace(/\.[^.]+$/, ""));
            Y.data = { assetId: K }, q.id = Y.id;
          }
          const G = d.value.find((Q) => Q.id === "footage");
          G ? G.items.push(q) : h.value.push(q), console.log("[ProjectPanel] Imported:", W.name, fe);
        }
        U.value = "";
      }
    }
    function b(k) {
      const U = k.type;
      return U.startsWith("audio/") ? "audio" : (U.startsWith("video/") || U.startsWith("image/"), "footage");
    }
    function S(k) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[k] || "";
    }
    function A(k) {
      if (k.type === "composition" || k.type === "footage") {
        const U = [];
        if (k.width && k.height && U.push(`${k.width}${k.height}`), k.fps && U.push(`${k.fps}fps`), k.duration) {
          const I = k.duration / (k.fps || 30);
          U.push(`${I.toFixed(1)}s`);
        }
        return U.join("  ");
      }
      return "";
    }
    function R(k, U) {
      var I;
      (I = U.dataTransfer) == null || I.setData("application/project-item", JSON.stringify(k));
    }
    return (k, U) => (se(), re("div", kM, [
      v("div", DM, [
        U[3] || (U[3] = v("span", { class: "panel-title" }, "Project", -1)),
        v("div", IM, [
          v("button", {
            onClick: P,
            title: "Import File (Ctrl+I)"
          }, ""),
          v("div", RM, [
            v("button", {
              onClick: U[0] || (U[0] = (I) => r.value = !r.value),
              title: "New Item"
            }, "+"),
            r.value ? (se(), re("div", LM, [
              v("button", { onClick: w }, " New Composition"),
              v("button", { onClick: M }, " New Solid"),
              v("button", { onClick: _ }, "T New Text"),
              v("button", { onClick: C }, " New Null"),
              v("button", { onClick: T }, " New Spline")
            ])) : Te("", !0)
          ]),
          v("button", {
            onClick: U[1] || (U[1] = (I) => a.value = !a.value),
            title: "Search"
          }, "")
        ])
      ]),
      v("input", {
        ref_key: "fileInputRef",
        ref: o,
        type: "file",
        multiple: "",
        accept: "image/*,video/*,audio/*,.json",
        style: { display: "none" },
        onChange: E
      }, null, 544),
      a.value ? (se(), re("div", FM, [
        st(v("input", {
          type: "text",
          "onUpdate:modelValue": U[2] || (U[2] = (I) => l.value = I),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [Ot, l.value]
        ])
      ])) : Te("", !0),
      v("div", OM, [
        v("div", UM, [
          (se(!0), re(Xe, null, at(p.value, (I) => (se(), re("div", {
            key: I.id,
            class: "folder-item"
          }, [
            v("div", {
              class: Le(["folder-header", { selected: c.value === I.id }]),
              onClick: (W) => g(I.id),
              onDblclick: (W) => y(I.id)
            }, [
              v("span", {
                class: "expand-icon",
                onClick: _t((W) => y(I.id), ["stop"])
              }, ye(u.value.includes(I.id) ? "" : ""), 9, BM),
              U[4] || (U[4] = v("span", { class: "folder-icon" }, "", -1)),
              v("span", NM, ye(I.name), 1),
              v("span", VM, ye(I.items.length), 1)
            ], 42, zM),
            u.value.includes(I.id) ? (se(), re("div", HM, [
              (se(!0), re(Xe, null, at(I.items, (W) => (se(), re("div", {
                key: W.id,
                class: Le(["project-item", { selected: c.value === W.id }]),
                onClick: (fe) => g(W.id),
                onDblclick: (fe) => x(W),
                draggable: "true",
                onDragstart: (fe) => R(W, fe)
              }, [
                v("span", $M, ye(S(W.type)), 1),
                v("span", WM, ye(W.name), 1),
                v("span", jM, ye(A(W)), 1)
              ], 42, GM))), 128))
            ])) : Te("", !0)
          ]))), 128)),
          (se(!0), re(Xe, null, at(f.value, (I) => (se(), re("div", {
            key: I.id,
            class: Le(["project-item", { selected: c.value === I.id }]),
            onClick: (W) => g(I.id),
            onDblclick: (W) => x(I),
            draggable: "true",
            onDragstart: (W) => R(I, W)
          }, [
            v("span", YM, ye(S(I.type)), 1),
            v("span", qM, ye(I.name), 1),
            v("span", ZM, ye(A(I)), 1)
          ], 42, XM))), 128))
        ]),
        h.value.length === 0 ? (se(), re("div", KM, [...U[5] || (U[5] = [
          v("p", null, "No items in project", -1),
          v("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : Te("", !0)
      ]),
      m.value ? (se(), re("div", JM, [
        v("div", QM, [
          v("span", eS, ye(m.value.name), 1),
          v("span", tS, ye(m.value.info), 1)
        ])
      ])) : Te("", !0)
    ]));
  }
}), Vt = (s, e) => {
  const n = s.__vccOpts || s;
  for (const [i, o] of e)
    n[i] = o;
  return n;
}, iS = /* @__PURE__ */ Vt(nS, [["__scopeId", "data-v-8f208c83"]]), sS = { class: "effects-panel" }, oS = { class: "panel-header" }, aS = { class: "header-actions" }, rS = { class: "panel-content" }, lS = { class: "tabs" }, cS = {
  key: 0,
  class: "effects-list"
}, uS = ["onClick"], dS = { class: "expand-icon" }, hS = { class: "category-icon" }, fS = { class: "category-name" }, pS = { class: "effect-count" }, mS = {
  key: 0,
  class: "category-effects"
}, vS = ["onDblclick", "onDragstart"], gS = { class: "effect-name" }, yS = ["onClick", "title"], xS = {
  key: 1,
  class: "presets-list"
}, bS = ["onClick"], _S = { class: "expand-icon" }, wS = { class: "category-name" }, MS = { class: "preset-count" }, SS = {
  key: 0,
  class: "category-presets"
}, CS = ["onDblclick", "onDragstart"], TS = { class: "preset-info" }, ES = { class: "preset-name" }, AS = { class: "preset-description" }, PS = {
  key: 2,
  class: "favorites-list"
}, kS = {
  key: 0,
  class: "empty-favorites"
}, DS = ["onDblclick", "onDragstart"], IS = { class: "category-badge" }, RS = { class: "effect-name" }, LS = ["onClick"], FS = /* @__PURE__ */ Bt({
  __name: "EffectsPanel",
  setup(s) {
    const e = un(), n = xe("effects"), i = xe(""), o = xe(["blur-sharpen", "color-correction"]), a = xe(["Fade", "Scale"]), r = xe([]);
    gn(() => {
      const _ = localStorage.getItem("effect-favorites");
      if (_)
        try {
          r.value = JSON.parse(_);
        } catch {
          r.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(r.value));
    }
    const c = Re(() => Object.entries($c).map(([_, C]) => ({
      key: _,
      name: C.name,
      category: C.category,
      description: C.description
    }))), u = Re(() => {
      const _ = i.value.toLowerCase();
      return Object.entries(Xd).map(([C, T]) => {
        const P = c.value.filter((E) => !(E.category !== C || _ && !E.name.toLowerCase().includes(_)));
        return {
          key: C,
          label: T.label,
          icon: T.icon,
          effects: P
        };
      }).filter((C) => C.effects.length > 0);
    }), d = Re(() => {
      const _ = i.value.toLowerCase(), C = {};
      for (const T of mM)
        _ && !T.name.toLowerCase().includes(_) || (C[T.category] || (C[T.category] = []), C[T.category].push(T));
      return Object.entries(C).map(([T, P]) => ({
        category: T,
        presets: P
      }));
    }), h = Re(() => c.value.filter((_) => r.value.includes(_.key)));
    function p(_) {
      const C = o.value.indexOf(_);
      C >= 0 ? o.value.splice(C, 1) : o.value.push(_);
    }
    function f(_) {
      const C = a.value.indexOf(_);
      C >= 0 ? a.value.splice(C, 1) : a.value.push(_);
    }
    function m(_) {
      const C = r.value.indexOf(_);
      C >= 0 ? r.value.splice(C, 1) : r.value.push(_), l();
    }
    function y(_) {
      var C;
      return ((C = Xd[_]) == null ? void 0 : C.icon) || "?";
    }
    function g(_) {
      const C = e.selectedLayer;
      if (!C) {
        console.warn("No layer selected to apply effect");
        return;
      }
      e.addEffectToLayer(C.id, _);
    }
    function x(_) {
      const C = e.selectedLayer;
      if (!C || !e.getActiveComp()) return;
      const P = C.inPoint, b = C.outPoint - P;
      for (const S of _.keyframes)
        for (const A of S.keyframes) {
          const R = Math.round(P + A.time * b);
          e.addKeyframe(C.id, S.property, A.value, R);
        }
    }
    function w(_, C) {
      var T;
      (T = C.dataTransfer) == null || T.setData("application/effect", _);
    }
    function M(_, C) {
      var T;
      (T = C.dataTransfer) == null || T.setData("application/preset", JSON.stringify(_));
    }
    return (_, C) => (se(), re("div", sS, [
      v("div", oS, [
        C[4] || (C[4] = v("span", { class: "panel-title" }, "Effects & Presets", -1)),
        v("div", aS, [
          st(v("input", {
            type: "text",
            "onUpdate:modelValue": C[0] || (C[0] = (T) => i.value = T),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [Ot, i.value]
          ])
        ])
      ]),
      v("div", rS, [
        v("div", lS, [
          v("button", {
            class: Le({ active: n.value === "effects" }),
            onClick: C[1] || (C[1] = (T) => n.value = "effects")
          }, " Effects ", 2),
          v("button", {
            class: Le({ active: n.value === "presets" }),
            onClick: C[2] || (C[2] = (T) => n.value = "presets")
          }, " Presets ", 2),
          v("button", {
            class: Le({ active: n.value === "favorites" }),
            onClick: C[3] || (C[3] = (T) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? (se(), re("div", cS, [
          (se(!0), re(Xe, null, at(u.value, (T) => (se(), re("div", {
            key: T.key,
            class: "effect-category"
          }, [
            v("div", {
              class: "category-header",
              onClick: (P) => p(T.key)
            }, [
              v("span", dS, ye(o.value.includes(T.key) ? "" : ""), 1),
              v("span", hS, ye(T.icon), 1),
              v("span", fS, ye(T.label), 1),
              v("span", pS, ye(T.effects.length), 1)
            ], 8, uS),
            o.value.includes(T.key) ? (se(), re("div", mS, [
              (se(!0), re(Xe, null, at(T.effects, (P) => (se(), re("div", {
                key: P.key,
                class: Le(["effect-item", { favorite: r.value.includes(P.key) }]),
                onDblclick: (E) => g(P.key),
                onDragstart: (E) => w(P.key, E),
                draggable: "true"
              }, [
                v("span", gS, ye(P.name), 1),
                v("button", {
                  class: "favorite-btn",
                  onClick: _t((E) => m(P.key), ["stop"]),
                  title: r.value.includes(P.key) ? "Remove from favorites" : "Add to favorites"
                }, ye(r.value.includes(P.key) ? "" : ""), 9, yS)
              ], 42, vS))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? (se(), re("div", xS, [
          (se(!0), re(Xe, null, at(d.value, (T) => (se(), re("div", {
            key: T.category,
            class: "preset-category"
          }, [
            v("div", {
              class: "category-header",
              onClick: (P) => f(T.category)
            }, [
              v("span", _S, ye(a.value.includes(T.category) ? "" : ""), 1),
              v("span", wS, ye(T.category), 1),
              v("span", MS, ye(T.presets.length), 1)
            ], 8, bS),
            a.value.includes(T.category) ? (se(), re("div", SS, [
              (se(!0), re(Xe, null, at(T.presets, (P) => (se(), re("div", {
                key: P.id,
                class: "preset-item",
                onDblclick: (E) => x(P),
                onDragstart: (E) => M(P, E),
                draggable: "true"
              }, [
                C[5] || (C[5] = v("div", { class: "preset-preview" }, [
                  v("span", { class: "preview-icon" }, "")
                ], -1)),
                v("div", TS, [
                  v("span", ES, ye(P.name), 1),
                  v("span", AS, ye(P.description), 1)
                ])
              ], 40, CS))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? (se(), re("div", PS, [
          h.value.length === 0 ? (se(), re("div", kS, [...C[6] || (C[6] = [
            v("p", null, "No favorites yet", -1),
            v("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : Te("", !0),
          (se(!0), re(Xe, null, at(h.value, (T) => (se(), re("div", {
            key: T.key,
            class: "effect-item",
            onDblclick: (P) => g(T.key),
            onDragstart: (P) => w(T.key, P),
            draggable: "true"
          }, [
            v("span", IS, ye(y(T.category)), 1),
            v("span", RS, ye(T.name), 1),
            v("button", {
              class: "favorite-btn active",
              onClick: _t((P) => m(T.key), ["stop"])
            }, "  ", 8, LS)
          ], 40, DS))), 128))
        ])) : Te("", !0)
      ]),
      C[7] || (C[7] = v("div", { class: "panel-footer" }, [
        v("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), OS = /* @__PURE__ */ Vt(FS, [["__scopeId", "data-v-5e081b38"]]), US = ["value", "min", "max", "step", "disabled"], zS = {
  key: 1,
  class: "scrub-unit"
}, BS = /* @__PURE__ */ Bt({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = xe(!1), a = xe(0), r = xe(0), l = Re(() => n.default ?? n.modelValue), c = Re(() => n.default !== void 0), u = Re(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function d(M) {
      return Math.max(n.min, Math.min(n.max, M));
    }
    function h(M) {
      const _ = Math.pow(10, n.precision);
      return Math.round(M * _) / _;
    }
    function p(M) {
      n.disabled || (o.value = !0, a.value = M.clientX, r.value = n.modelValue, document.addEventListener("mousemove", f), document.addEventListener("mouseup", m), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function f(M) {
      const _ = M.clientX - a.value;
      let C = n.sensitivity;
      M.shiftKey && (C *= 10), (M.ctrlKey || M.metaKey) && (C *= 0.1);
      const T = _ * n.step * C * 0.5, P = h(d(r.value + T));
      P !== n.modelValue && i("update:modelValue", P);
    }
    function m() {
      o.value = !1, document.removeEventListener("mousemove", f), document.removeEventListener("mouseup", m), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function y(M) {
      const _ = M.target, C = parseFloat(_.value);
      isNaN(C) || i("update:modelValue", h(d(C)));
    }
    function g(M) {
      if (n.disabled) return;
      let _ = 0;
      M.key === "ArrowUp" ? _ = n.step : M.key === "ArrowDown" && (_ = -n.step), _ !== 0 && (M.preventDefault(), M.shiftKey && (_ *= 10), (M.ctrlKey || M.metaKey) && (_ *= 0.1), i("update:modelValue", h(d(n.modelValue + _))));
    }
    function x(M) {
      const _ = M.target, C = parseFloat(_.value);
      isNaN(C) && (_.value = u.value.toString());
    }
    function w() {
      n.default !== void 0 && i("update:modelValue", n.default);
    }
    return (M, _) => (se(), re("div", {
      class: Le(["scrubable-number", { disabled: s.disabled }])
    }, [
      s.label ? (se(), re("label", {
        key: 0,
        class: Le(["scrub-label", { scrubbing: o.value }]),
        onMousedown: p
      }, ye(s.label), 35)) : Te("", !0),
      v("input", {
        type: "number",
        class: "scrub-input",
        value: u.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: y,
        onKeydown: g,
        onBlur: x
      }, null, 40, US),
      s.unit ? (se(), re("span", zS, ye(s.unit), 1)) : Te("", !0),
      c.value && s.modelValue !== l.value ? (se(), re("button", {
        key: 2,
        class: "reset-btn",
        onClick: w,
        title: "Reset to default"
      }, [..._[0] || (_[0] = [
        v("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : Te("", !0)
    ], 2));
  }
}), it = /* @__PURE__ */ Vt(BS, [["__scopeId", "data-v-dcc786e6"]]), NS = ["value", "min", "max", "step", "disabled"], VS = {
  key: 2,
  class: "slider-unit"
}, HS = /* @__PURE__ */ Bt({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = xe(null), a = xe(!1), r = xe(!1), l = xe(0), c = xe(0), u = Re(() => {
      const T = n.max - n.min;
      return T === 0 ? 0 : (n.modelValue - n.min) / T * 100;
    }), d = Re(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function h(T) {
      return Math.max(n.min, Math.min(n.max, T));
    }
    function p(T) {
      const P = Math.pow(10, n.precision);
      return Math.round(T * P) / P;
    }
    function f(T) {
      n.disabled || (a.value = !0, l.value = T.clientX, c.value = n.modelValue, document.addEventListener("mousemove", m), document.addEventListener("mouseup", y), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function m(T) {
      const P = T.clientX - l.value, E = n.max - n.min;
      let b = 1;
      T.shiftKey && (b *= 10), (T.ctrlKey || T.metaKey) && (b *= 0.1);
      const S = P / 200 * E * b, A = p(h(c.value + S));
      A !== n.modelValue && i("update:modelValue", A);
    }
    function y() {
      a.value = !1, document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", y), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function g(T) {
      if (n.disabled || !o.value) return;
      const P = o.value.getBoundingClientRect(), E = (T.clientX - P.left) / P.width, b = n.min + E * (n.max - n.min);
      i("update:modelValue", p(h(b)));
    }
    function x(T) {
      n.disabled || (r.value = !0, document.addEventListener("mousemove", w), document.addEventListener("mouseup", M), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function w(T) {
      if (!o.value) return;
      const P = o.value.getBoundingClientRect(), E = (T.clientX - P.left) / P.width, b = n.min + Math.max(0, Math.min(1, E)) * (n.max - n.min);
      i("update:modelValue", p(h(b)));
    }
    function M() {
      r.value = !1, document.removeEventListener("mousemove", w), document.removeEventListener("mouseup", M), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function _(T) {
      const P = T.target, E = parseFloat(P.value);
      isNaN(E) || i("update:modelValue", p(h(E)));
    }
    function C(T) {
      const P = T.target, E = parseFloat(P.value);
      isNaN(E) && (P.value = d.value.toString());
    }
    return (T, P) => (se(), re("div", {
      class: Le(["slider-input", { disabled: s.disabled }])
    }, [
      s.label ? (se(), re("label", {
        key: 0,
        class: Le(["slider-label", { scrubbing: a.value }]),
        onMousedown: f
      }, ye(s.label), 35)) : Te("", !0),
      v("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: o,
        onMousedown: g
      }, [
        v("div", {
          class: "slider-fill",
          style: xt({ width: u.value + "%", background: s.gradient || void 0 })
        }, null, 4),
        v("div", {
          class: "slider-thumb",
          style: xt({ left: u.value + "%" }),
          onMousedown: _t(x, ["stop"])
        }, null, 36)
      ], 544),
      s.showValue ? (se(), re("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: d.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: _,
        onBlur: C
      }, null, 40, NS)) : Te("", !0),
      s.unit ? (se(), re("span", VS, ye(s.unit), 1)) : Te("", !0)
    ], 2));
  }
}), ti = /* @__PURE__ */ Vt(HS, [["__scopeId", "data-v-9dd40416"]]), GS = { class: "dial-marks" }, $S = {
  key: 0,
  class: "angle-value"
}, WS = ["value", "disabled"], jS = /* @__PURE__ */ Bt({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = xe(null), a = xe(!1), r = Re(() => Math.round(n.modelValue * 10) / 10);
    function l(m) {
      return (m % 360 + 360) % 360;
    }
    function c(m) {
      n.disabled || (a.value = !0, d(m), document.addEventListener("mousemove", u), document.addEventListener("mouseup", h), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function u(m) {
      a.value && d(m);
    }
    function d(m) {
      if (!o.value) return;
      const y = o.value.getBoundingClientRect(), g = y.left + y.width / 2, x = y.top + y.height / 2, w = m.clientX - g, M = m.clientY - x;
      let _ = Math.atan2(w, -M) * (180 / Math.PI);
      _ = l(_), m.shiftKey && (_ = Math.round(_ / 45) * 45), i("update:modelValue", _);
    }
    function h() {
      a.value = !1, document.removeEventListener("mousemove", u), document.removeEventListener("mouseup", h), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function p(m) {
      const y = m.target, g = parseFloat(y.value);
      isNaN(g) || i("update:modelValue", l(g));
    }
    function f(m) {
      const y = m.target, g = parseFloat(y.value);
      isNaN(g) && (y.value = r.value.toString());
    }
    return (m, y) => (se(), re("div", {
      class: Le(["angle-dial", { disabled: s.disabled }])
    }, [
      v("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: o,
        style: xt({ width: s.size + "px", height: s.size + "px" }),
        onMousedown: c
      }, [
        y[0] || (y[0] = v("div", { class: "dial-ring" }, null, -1)),
        y[1] || (y[1] = v("div", { class: "dial-center" }, null, -1)),
        v("div", {
          class: "dial-indicator",
          style: xt({ transform: `rotate(${s.modelValue}deg)` })
        }, null, 4),
        v("div", GS, [
          (se(), re(Xe, null, at(8, (g) => v("div", {
            class: "dial-mark",
            key: g,
            style: xt({ transform: `rotate(${g * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      s.showValue ? (se(), re("div", $S, [
        v("input", {
          type: "number",
          class: "angle-input",
          value: r.value,
          disabled: s.disabled,
          onInput: p,
          onBlur: f
        }, null, 40, WS),
        y[2] || (y[2] = v("span", { class: "angle-unit" }, "", -1))
      ])) : Te("", !0)
    ], 2));
  }
}), jh = /* @__PURE__ */ Vt(jS, [["__scopeId", "data-v-04a5caf6"]]);
function P2(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = n * e, o = i * (1 - Math.abs(s / 60 % 2 - 1)), a = n - i;
  let r = 0, l = 0, c = 0;
  return s < 60 ? (r = i, l = o, c = 0) : s < 120 ? (r = o, l = i, c = 0) : s < 180 ? (r = 0, l = i, c = o) : s < 240 ? (r = 0, l = o, c = i) : s < 300 ? (r = o, l = 0, c = i) : (r = i, l = 0, c = o), [
    Math.round((r + a) * 255),
    Math.round((l + a) * 255),
    Math.round((c + a) * 255)
  ];
}
function Bs(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), o = Math.min(s, e, n), a = i - o;
  let r = 0;
  const l = i === 0 ? 0 : a / i, c = i;
  if (a !== 0)
    switch (i) {
      case s:
        r = ((e - n) / a + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        r = ((n - s) / a + 2) * 60;
        break;
      case n:
        r = ((s - e) / a + 4) * 60;
        break;
    }
  return [r, l, c];
}
function Bl(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = (1 - Math.abs(2 * n - 1)) * e, o = i * (1 - Math.abs(s / 60 % 2 - 1)), a = n - i / 2;
  let r = 0, l = 0, c = 0;
  return s < 60 ? (r = i, l = o, c = 0) : s < 120 ? (r = o, l = i, c = 0) : s < 180 ? (r = 0, l = i, c = o) : s < 240 ? (r = 0, l = o, c = i) : s < 300 ? (r = o, l = 0, c = i) : (r = i, l = 0, c = o), [
    Math.round((r + a) * 255),
    Math.round((l + a) * 255),
    Math.round((c + a) * 255)
  ];
}
function X0(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), o = Math.min(s, e, n), a = (i + o) / 2;
  let r = 0, l = 0;
  if (i !== o) {
    const c = i - o;
    switch (l = a > 0.5 ? c / (2 - i - o) : c / (i + o), i) {
      case s:
        r = ((e - n) / c + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        r = ((n - s) / c + 2) * 60;
        break;
      case n:
        r = ((s - e) / c + 4) * 60;
        break;
    }
  }
  return [r, l, a];
}
function XS(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2]), s.length === 6 || s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16);
    if (!isNaN(e) && !isNaN(n) && !isNaN(i))
      return [e, n, i];
  }
  return null;
}
function YS(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2] + "ff"), s.length === 6 && (s = s + "ff"), s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16), o = parseInt(s.slice(6, 8), 16) / 255;
    if (!isNaN(e) && !isNaN(n) && !isNaN(i) && !isNaN(o))
      return [e, n, i, o];
  }
  return null;
}
function qS(s, e, n) {
  const i = (o) => Math.max(0, Math.min(255, Math.round(o))).toString(16).padStart(2, "0");
  return `#${i(s)}${i(e)}${i(n)}`;
}
function ZS(s, e, n, i) {
  const o = (a) => Math.max(0, Math.min(255, Math.round(a))).toString(16).padStart(2, "0");
  return `#${o(s)}${o(e)}${o(n)}${o(i * 255)}`;
}
const KS = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
], JS = {
  key: 0,
  class: "checkerboard"
}, QS = ["value"], eC = { class: "mode-tabs" }, tC = ["onClick"], nC = {
  key: 1,
  class: "rgb-sliders"
}, iC = { class: "color-slider" }, sC = ["value"], oC = { class: "color-slider" }, aC = ["value"], rC = { class: "color-slider" }, lC = ["value"], cC = {
  key: 2,
  class: "hsl-sliders"
}, uC = { class: "color-slider" }, dC = ["value"], hC = { class: "color-slider" }, fC = ["value"], pC = { class: "color-slider" }, mC = ["value"], vC = {
  key: 3,
  class: "alpha-slider"
}, gC = ["value"], yC = { class: "swatches-section" }, xC = { class: "swatches-grid" }, bC = ["onClick"], _C = {
  key: 4,
  class: "recent-section"
}, wC = { class: "swatches-grid" }, MC = ["onClick"], SC = /* @__PURE__ */ Bt({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: !1 },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = ["hsv", "rgb", "hsl"], a = xe(null), r = xe(null), l = xe(null), c = xe(null), u = xe(null), d = xe(!1), h = xe("hsv"), p = xe(1), f = xe([]), m = xe([255, 255, 255]), y = xe([0, 0, 1]), g = xe([0, 0, 1]), x = Re(() => n.swatches || KS), w = Re(() => {
      if (!a.value || !n.teleport) return {};
      const j = a.value.getBoundingClientRect();
      return {
        top: `${j.bottom + 4}px`,
        left: `${j.left}px`
      };
    });
    function M(j) {
      const Z = XS(j);
      Z && (m.value = Z, y.value = Bs(Z[0], Z[1], Z[2]), g.value = X0(Z[0], Z[1], Z[2]));
    }
    function _() {
      const j = qS(m.value[0], m.value[1], m.value[2]);
      i("update:modelValue", j);
    }
    function C() {
      d.value = !d.value;
    }
    function T() {
      d.value && (d.value = !1, P(n.modelValue));
    }
    function P(j) {
      const Z = f.value.indexOf(j);
      Z !== -1 && f.value.splice(Z, 1), f.value.unshift(j), f.value.length > n.recentCount && f.value.pop();
    }
    function E(j) {
      i("update:modelValue", j);
    }
    let b = !1;
    function S(j) {
      b = !0, R(j), document.addEventListener("mousemove", A), document.addEventListener("mouseup", k);
    }
    function A(j) {
      b && R(j);
    }
    function R(j) {
      if (!l.value) return;
      const Z = l.value.getBoundingClientRect(), z = Math.max(0, Math.min(1, (j.clientX - Z.left) / Z.width)), $ = Math.max(0, Math.min(1, 1 - (j.clientY - Z.top) / Z.height));
      y.value = [y.value[0], z, $], m.value = P2(y.value[0], y.value[1], y.value[2]), g.value = X0(m.value[0], m.value[1], m.value[2]), _();
    }
    function k() {
      b = !1, document.removeEventListener("mousemove", A), document.removeEventListener("mouseup", k);
    }
    let U = !1;
    function I(j) {
      U = !0, fe(j), document.addEventListener("mousemove", W), document.addEventListener("mouseup", q);
    }
    function W(j) {
      U && fe(j);
    }
    function fe(j) {
      if (!c.value) return;
      const Z = c.value.getBoundingClientRect(), z = Math.max(0, Math.min(360, (j.clientX - Z.left) / Z.width * 360));
      y.value = [z, y.value[1], y.value[2]], m.value = P2(y.value[0], y.value[1], y.value[2]), g.value = X0(m.value[0], m.value[1], m.value[2]), _();
    }
    function q() {
      U = !1, document.removeEventListener("mousemove", W), document.removeEventListener("mouseup", q);
    }
    let G = null, Q = null;
    function K(j, Z) {
      G = j;
      const z = Z.target.closest(".slider-track");
      z && (Q = z.getBoundingClientRect(), ee(Z), document.addEventListener("mousemove", Y), document.addEventListener("mouseup", ce));
    }
    function Y(j) {
      G && ee(j);
    }
    function ee(j) {
      if (!Q || !G) return;
      const Z = Math.max(0, Math.min(1, (j.clientX - Q.left) / Q.width));
      switch (G) {
        case "r":
          m.value = [Math.round(Z * 255), m.value[1], m.value[2]], y.value = Bs(m.value[0], m.value[1], m.value[2]), g.value = X0(m.value[0], m.value[1], m.value[2]);
          break;
        case "g":
          m.value = [m.value[0], Math.round(Z * 255), m.value[2]], y.value = Bs(m.value[0], m.value[1], m.value[2]), g.value = X0(m.value[0], m.value[1], m.value[2]);
          break;
        case "b":
          m.value = [m.value[0], m.value[1], Math.round(Z * 255)], y.value = Bs(m.value[0], m.value[1], m.value[2]), g.value = X0(m.value[0], m.value[1], m.value[2]);
          break;
        case "h":
          g.value = [Z * 360, g.value[1], g.value[2]], m.value = Bl(g.value[0], g.value[1], g.value[2]), y.value = Bs(m.value[0], m.value[1], m.value[2]);
          break;
        case "s":
          g.value = [g.value[0], Z, g.value[2]], m.value = Bl(g.value[0], g.value[1], g.value[2]), y.value = Bs(m.value[0], m.value[1], m.value[2]);
          break;
        case "l":
          g.value = [g.value[0], g.value[1], Z], m.value = Bl(g.value[0], g.value[1], g.value[2]), y.value = Bs(m.value[0], m.value[1], m.value[2]);
          break;
      }
      _();
    }
    function ce() {
      G = null, Q = null, document.removeEventListener("mousemove", Y), document.removeEventListener("mouseup", ce);
    }
    let ae = !1;
    function de(j) {
      ae = !0, he(j), document.addEventListener("mousemove", ie), document.addEventListener("mouseup", ne);
    }
    function ie(j) {
      ae && he(j);
    }
    function he(j) {
      if (!u.value) return;
      const Z = u.value.getBoundingClientRect();
      p.value = Math.max(0, Math.min(1, (j.clientX - Z.left) / Z.width));
    }
    function ne() {
      ae = !1, document.removeEventListener("mousemove", ie), document.removeEventListener("mouseup", ne);
    }
    function N(j) {
      let z = j.target.value.trim();
      z.startsWith("#") || (z = "#" + z), /^#[0-9a-f]{6}$/i.test(z) && i("update:modelValue", z.toLowerCase());
    }
    function te(j) {
      const Z = j.target;
      Z.value = n.modelValue;
    }
    function F(j, Z) {
      const z = Z.target, $ = Math.max(0, Math.min(255, parseInt(z.value) || 0)), oe = [...m.value];
      oe[j] = $, m.value = oe, y.value = Bs(m.value[0], m.value[1], m.value[2]), g.value = X0(m.value[0], m.value[1], m.value[2]), _();
    }
    function B(j, Z) {
      const z = Z.target;
      let $ = parseFloat(z.value) || 0;
      j === 0 ? ($ = Math.max(0, Math.min(360, $)), g.value = [$, g.value[1], g.value[2]]) : ($ = Math.max(0, Math.min(100, $)) / 100, j === 1 ? g.value = [g.value[0], $, g.value[2]] : g.value = [g.value[0], g.value[1], $]), m.value = Bl(g.value[0], g.value[1], g.value[2]), y.value = Bs(m.value[0], m.value[1], m.value[2]), _();
    }
    function L(j) {
      const Z = j.target;
      p.value = Math.max(0, Math.min(100, parseInt(Z.value) || 0)) / 100;
    }
    function D(j) {
      a.value && !a.value.contains(j.target) && r.value && !r.value.contains(j.target) && T();
    }
    return Ft(() => n.modelValue, (j) => {
      M(j);
    }, { immediate: !0 }), gn(() => {
      document.addEventListener("mousedown", D);
    }), Un(() => {
      document.removeEventListener("mousedown", D);
    }), (j, Z) => (se(), re("div", {
      class: "color-picker",
      ref_key: "containerRef",
      ref: a
    }, [
      v("button", {
        class: "color-swatch",
        style: xt({ backgroundColor: s.modelValue }),
        onClick: C
      }, [
        s.alpha ? (se(), re("span", JS)) : Te("", !0)
      ], 4),
      v("input", {
        type: "text",
        class: "hex-input",
        value: s.modelValue,
        onInput: N,
        onBlur: te,
        onKeydown: Z[0] || (Z[0] = Lr((z) => z.target.blur(), ["enter"]))
      }, null, 40, QS),
      (se(), Tt(R0, {
        to: "body",
        disabled: !s.teleport
      }, [
        d.value ? (se(), re("div", {
          key: 0,
          class: "picker-panel",
          style: xt(w.value),
          ref_key: "panelRef",
          ref: r
        }, [
          v("div", eC, [
            (se(), re(Xe, null, at(o, (z) => v("button", {
              key: z,
              class: Le({ active: h.value === z }),
              onClick: ($) => h.value = z
            }, ye(z.toUpperCase()), 11, tC)), 64))
          ]),
          h.value === "hsv" ? (se(), re(Xe, { key: 0 }, [
            v("div", {
              class: "sv-square",
              style: xt({ backgroundColor: `hsl(${y.value[0]}, 100%, 50%)` }),
              onMousedown: S,
              ref_key: "svSquareRef",
              ref: l
            }, [
              Z[13] || (Z[13] = v("div", { class: "sv-white" }, null, -1)),
              Z[14] || (Z[14] = v("div", { class: "sv-black" }, null, -1)),
              v("div", {
                class: "sv-cursor",
                style: xt({ left: y.value[1] * 100 + "%", top: (1 - y.value[2]) * 100 + "%" })
              }, null, 4)
            ], 36),
            v("div", {
              class: "hue-slider",
              onMousedown: I,
              ref_key: "hueSliderRef",
              ref: c
            }, [
              v("div", {
                class: "hue-cursor",
                style: xt({ left: y.value[0] / 360 * 100 + "%" })
              }, null, 4)
            ], 544)
          ], 64)) : h.value === "rgb" ? (se(), re("div", nC, [
            v("div", iC, [
              Z[15] || (Z[15] = v("label", null, "R", -1)),
              v("div", {
                class: "slider-track r-track",
                onMousedown: Z[1] || (Z[1] = (z) => K("r", z))
              }, [
                v("div", {
                  class: "slider-cursor",
                  style: xt({ left: m.value[0] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              v("input", {
                type: "number",
                value: m.value[0],
                min: "0",
                max: "255",
                onInput: Z[2] || (Z[2] = (z) => F(0, z))
              }, null, 40, sC)
            ]),
            v("div", oC, [
              Z[16] || (Z[16] = v("label", null, "G", -1)),
              v("div", {
                class: "slider-track g-track",
                onMousedown: Z[3] || (Z[3] = (z) => K("g", z))
              }, [
                v("div", {
                  class: "slider-cursor",
                  style: xt({ left: m.value[1] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              v("input", {
                type: "number",
                value: m.value[1],
                min: "0",
                max: "255",
                onInput: Z[4] || (Z[4] = (z) => F(1, z))
              }, null, 40, aC)
            ]),
            v("div", rC, [
              Z[17] || (Z[17] = v("label", null, "B", -1)),
              v("div", {
                class: "slider-track b-track",
                onMousedown: Z[5] || (Z[5] = (z) => K("b", z))
              }, [
                v("div", {
                  class: "slider-cursor",
                  style: xt({ left: m.value[2] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              v("input", {
                type: "number",
                value: m.value[2],
                min: "0",
                max: "255",
                onInput: Z[6] || (Z[6] = (z) => F(2, z))
              }, null, 40, lC)
            ])
          ])) : h.value === "hsl" ? (se(), re("div", cC, [
            v("div", uC, [
              Z[18] || (Z[18] = v("label", null, "H", -1)),
              v("div", {
                class: "slider-track hue-track",
                onMousedown: Z[7] || (Z[7] = (z) => K("h", z))
              }, [
                v("div", {
                  class: "slider-cursor",
                  style: xt({ left: g.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 32),
              v("input", {
                type: "number",
                value: Math.round(g.value[0]),
                min: "0",
                max: "360",
                onInput: Z[8] || (Z[8] = (z) => B(0, z))
              }, null, 40, dC)
            ]),
            v("div", hC, [
              Z[19] || (Z[19] = v("label", null, "S", -1)),
              v("div", {
                class: "slider-track sat-track",
                style: xt({ "--hue": g.value[0] }),
                onMousedown: Z[9] || (Z[9] = (z) => K("s", z))
              }, [
                v("div", {
                  class: "slider-cursor",
                  style: xt({ left: g.value[1] * 100 + "%" })
                }, null, 4)
              ], 36),
              v("input", {
                type: "number",
                value: Math.round(g.value[1] * 100),
                min: "0",
                max: "100",
                onInput: Z[10] || (Z[10] = (z) => B(1, z))
              }, null, 40, fC)
            ]),
            v("div", pC, [
              Z[20] || (Z[20] = v("label", null, "L", -1)),
              v("div", {
                class: "slider-track light-track",
                style: xt({ "--hue": g.value[0] }),
                onMousedown: Z[11] || (Z[11] = (z) => K("l", z))
              }, [
                v("div", {
                  class: "slider-cursor",
                  style: xt({ left: g.value[2] * 100 + "%" })
                }, null, 4)
              ], 36),
              v("input", {
                type: "number",
                value: Math.round(g.value[2] * 100),
                min: "0",
                max: "100",
                onInput: Z[12] || (Z[12] = (z) => B(2, z))
              }, null, 40, mC)
            ])
          ])) : Te("", !0),
          s.alpha ? (se(), re("div", vC, [
            Z[21] || (Z[21] = v("label", null, "A", -1)),
            v("div", {
              class: "slider-track alpha-track",
              style: xt({ "--color": s.modelValue }),
              onMousedown: de,
              ref_key: "alphaSliderRef",
              ref: u
            }, [
              v("div", {
                class: "slider-cursor",
                style: xt({ left: p.value * 100 + "%" })
              }, null, 4)
            ], 36),
            v("input", {
              type: "number",
              value: Math.round(p.value * 100),
              min: "0",
              max: "100",
              onInput: L
            }, null, 40, gC)
          ])) : Te("", !0),
          v("div", yC, [
            Z[22] || (Z[22] = v("div", { class: "swatches-label" }, "Swatches", -1)),
            v("div", xC, [
              (se(!0), re(Xe, null, at(x.value, (z) => (se(), re("button", {
                key: z,
                class: "swatch",
                style: xt({ backgroundColor: z }),
                onClick: ($) => E(z)
              }, null, 12, bC))), 128))
            ])
          ]),
          f.value.length > 0 ? (se(), re("div", _C, [
            Z[23] || (Z[23] = v("div", { class: "swatches-label" }, "Recent", -1)),
            v("div", wC, [
              (se(!0), re(Xe, null, at(f.value, (z) => (se(), re("button", {
                key: z,
                class: "swatch",
                style: xt({ backgroundColor: z }),
                onClick: ($) => E(z)
              }, null, 12, MC))), 128))
            ])
          ])) : Te("", !0)
        ], 4)) : Te("", !0)
      ], 8, ["disabled"]))
    ], 512));
  }
}), Wc = /* @__PURE__ */ Vt(SC, [["__scopeId", "data-v-05165efb"]]), CC = { class: "effect-controls" }, TC = { class: "panel-header" }, EC = { class: "header-row" }, AC = {
  key: 0,
  class: "layer-badge"
}, PC = { class: "layer-type-icon" }, kC = ["disabled"], DC = {
  key: 0,
  class: "effect-menu"
}, IC = { class: "category-label" }, RC = { class: "cat-icon" }, LC = { class: "category-items" }, FC = ["onClick"], OC = { class: "panel-content" }, UC = {
  key: 0,
  class: "empty-state"
}, zC = {
  key: 1,
  class: "empty-state"
}, BC = {
  key: 2,
  class: "effects-list"
}, NC = ["onClick"], VC = { class: "header-left" }, HC = { class: "arrow" }, GC = ["onClick"], $C = { class: "effect-name" }, WC = { class: "header-right" }, jC = ["onClick"], XC = {
  key: 0,
  class: "effect-params"
}, YC = { class: "param-header" }, qC = ["title"], ZC = ["onClick"], KC = { class: "param-control" }, JC = {
  key: 0,
  class: "control-group"
}, QC = {
  key: 1,
  class: "control-group"
}, eT = {
  key: 2,
  class: "control-group point-group"
}, tT = ["checked", "onChange"], nT = ["value", "onChange"], iT = ["value"], sT = /* @__PURE__ */ Bt({
  __name: "EffectControlsPanel",
  setup(s) {
    const e = un(), n = xe(!1), i = xe(null), o = Re(() => e.selectedLayer), a = Xd;
    function r(E) {
      return Object.entries($c).filter(([b, S]) => S.category === E).map(([b, S]) => ({ key: b, ...S }));
    }
    function l(E, b) {
      const S = $c[E];
      return S == null ? void 0 : S.parameters.find((A) => c(A.name) === b);
    }
    function c(E) {
      return E.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function u(E, b) {
      const S = l(E, b);
      return S && (S.min !== void 0 || S.max !== void 0);
    }
    function d(E, b) {
      const S = l(E, b);
      return (S == null ? void 0 : S.type) === "checkbox";
    }
    function h(E, b) {
      const S = l(E, b);
      return (S == null ? void 0 : S.type) === "angle";
    }
    function p(E, b) {
      const S = l(E, b);
      return (S == null ? void 0 : S.options) || [];
    }
    function f(E) {
      return {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      }[E] || "";
    }
    function m(E) {
      o.value && (e.addEffectToLayer(o.value.id, E), n.value = !1);
    }
    function y(E) {
      o.value && e.removeEffectFromLayer(o.value.id, E.id);
    }
    function g(E) {
      o.value && e.toggleEffect(o.value.id, E.id);
    }
    function x(E) {
      E.expanded = !E.expanded;
    }
    function w(E, b, S) {
      o.value && e.updateEffectParameter(o.value.id, E, b, S);
    }
    function M(E, b, S, A) {
      if (!o.value) return;
      const R = o.value.effects.find((I) => I.id === E);
      if (!R) return;
      const U = { ...R.parameters[b].value, [S]: A };
      e.updateEffectParameter(o.value.id, E, b, U);
    }
    function _(E) {
      return typeof E == "string" ? E : ZS(E.r, E.g, E.b, E.a ?? 1);
    }
    function C(E, b, S) {
      const A = YS(S);
      if (A && o.value) {
        const R = { r: A[0], g: A[1], b: A[2], a: A[3] };
        e.updateEffectParameter(o.value.id, E, b, R);
      }
    }
    function T(E, b) {
      if (!o.value) return;
      const S = o.value.effects.find((R) => R.id === E), A = S == null ? void 0 : S.parameters[b];
      A && e.setEffectParamAnimated(o.value.id, E, b, !A.animated);
    }
    function P(E) {
      i.value && !i.value.contains(E.target) && (n.value = !1);
    }
    return gn(() => window.addEventListener("mousedown", P)), Un(() => window.removeEventListener("mousedown", P)), (E, b) => (se(), re("div", CC, [
      v("div", TC, [
        v("div", EC, [
          b[1] || (b[1] = v("h3", null, "Effect Controls", -1)),
          o.value ? (se(), re("div", AC, [
            v("span", PC, ye(f(o.value.type)), 1),
            ct(" " + ye(o.value.name), 1)
          ])) : Te("", !0)
        ]),
        v("div", {
          class: "add-effect-wrapper",
          ref_key: "menuRef",
          ref: i
        }, [
          v("button", {
            class: "add-btn",
            onClick: b[0] || (b[0] = (S) => n.value = !n.value),
            disabled: !o.value
          }, [...b[2] || (b[2] = [
            v("span", { class: "icon" }, "+", -1),
            ct(" Add Effect ", -1)
          ])], 8, kC),
          n.value ? (se(), re("div", DC, [
            (se(!0), re(Xe, null, at(He(a), (S, A) => (se(), re("div", {
              key: A,
              class: "effect-category"
            }, [
              v("div", IC, [
                v("span", RC, ye(S.icon), 1),
                ct(" " + ye(S.label), 1)
              ]),
              v("div", LC, [
                (se(!0), re(Xe, null, at(r(A), (R) => (se(), re("button", {
                  key: R.key,
                  onClick: (k) => m(R.key)
                }, ye(R.name), 9, FC))), 128))
              ])
            ]))), 128))
          ])) : Te("", !0)
        ], 512)
      ]),
      v("div", OC, [
        o.value ? !o.value.effects || o.value.effects.length === 0 ? (se(), re("div", zC, " No effects applied ")) : (se(), re("div", BC, [
          (se(!0), re(Xe, null, at(o.value.effects, (S, A) => (se(), re("div", {
            key: S.id,
            class: Le(["effect-item", { collapsed: !S.expanded }])
          }, [
            v("div", {
              class: "effect-header",
              onClick: (R) => x(S)
            }, [
              v("div", VC, [
                v("span", HC, ye(S.expanded ? "" : ""), 1),
                v("button", {
                  class: "icon-btn",
                  onClick: _t((R) => g(S), ["stop"])
                }, [
                  v("span", {
                    class: Le(["fx-icon", { disabled: !S.enabled }])
                  }, "fx", 2)
                ], 8, GC),
                v("span", $C, ye(S.name), 1)
              ]),
              v("div", WC, [
                v("button", {
                  class: "icon-btn delete",
                  onClick: _t((R) => y(S), ["stop"]),
                  title: "Remove Effect"
                }, "", 8, jC)
              ])
            ], 8, NC),
            S.expanded ? (se(), re("div", XC, [
              (se(!0), re(Xe, null, at(S.parameters, (R, k) => {
                var U, I, W, fe;
                return se(), re("div", {
                  key: k,
                  class: "param-row"
                }, [
                  v("div", YC, [
                    v("span", {
                      class: "param-name",
                      title: String(k)
                    }, ye(R.name), 9, qC),
                    v("button", {
                      class: Le(["stopwatch", { active: R.animated }]),
                      onClick: (q) => T(S.id, String(k)),
                      title: "Toggle Animation"
                    }, "", 10, ZC)
                  ]),
                  v("div", KC, [
                    R.type === "number" && h(S.effectKey, String(k)) ? (se(), re("div", JC, [
                      Ne(jh, {
                        modelValue: R.value,
                        "onUpdate:modelValue": (q) => w(S.id, String(k), q),
                        size: 32,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ne(it, {
                        modelValue: R.value,
                        "onUpdate:modelValue": (q) => w(S.id, String(k), q),
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : R.type === "number" ? (se(), re("div", QC, [
                      u(S.effectKey, String(k)) ? (se(), Tt(ti, {
                        key: 0,
                        modelValue: R.value,
                        "onUpdate:modelValue": (q) => w(S.id, String(k), q),
                        min: ((U = l(S.effectKey, String(k))) == null ? void 0 : U.min) ?? 0,
                        max: ((I = l(S.effectKey, String(k))) == null ? void 0 : I.max) ?? 100,
                        step: ((W = l(S.effectKey, String(k))) == null ? void 0 : W.step) ?? 1,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : Te("", !0),
                      Ne(it, {
                        modelValue: R.value,
                        "onUpdate:modelValue": (q) => w(S.id, String(k), q),
                        step: ((fe = l(S.effectKey, String(k))) == null ? void 0 : fe.step) ?? 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                    ])) : R.type === "position" ? (se(), re("div", eT, [
                      Ne(it, {
                        modelValue: R.value.x,
                        "onUpdate:modelValue": (q) => M(S.id, String(k), "x", q),
                        label: "X"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ne(it, {
                        modelValue: R.value.y,
                        "onUpdate:modelValue": (q) => M(S.id, String(k), "y", q),
                        label: "Y"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : R.type === "color" ? (se(), Tt(Wc, {
                      key: 3,
                      modelValue: _(R.value),
                      "onUpdate:modelValue": (q) => C(S.id, String(k), q),
                      alpha: !0
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : R.type === "enum" && d(S.effectKey, String(k)) ? (se(), re("input", {
                      key: 4,
                      type: "checkbox",
                      checked: R.value,
                      onChange: (q) => w(S.id, String(k), q.target.checked)
                    }, null, 40, tT)) : R.type === "enum" ? (se(), re("select", {
                      key: 5,
                      value: R.value,
                      onChange: (q) => w(S.id, String(k), q.target.value),
                      class: "param-select"
                    }, [
                      (se(!0), re(Xe, null, at(p(S.effectKey, String(k)), (q) => (se(), re("option", {
                        key: q.value,
                        value: q.value
                      }, ye(q.label), 9, iT))), 128))
                    ], 40, nT)) : Te("", !0)
                  ])
                ]);
              }), 128))
            ])) : Te("", !0)
          ], 2))), 128))
        ])) : (se(), re("div", UC, " Select a layer to edit effects "))
      ])
    ]));
  }
}), oT = /* @__PURE__ */ Vt(sT, [["__scopeId", "data-v-8ac57c6b"]]), Go = r0("Font"), Nl = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], Vl = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class aT {
  constructor() {
    le(this, "systemFonts", []);
    le(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    le(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const i of e)
        (!n.has(i.family) || i.style === "Regular") && n.set(i.family, {
          family: i.family,
          fullName: i.fullName,
          style: i.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((i, o) => i.family.localeCompare(o.family)), Go.debug(`Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? Go.info("User denied font access permission") : Go.error("Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: Nl
    }), e.push({
      name: "Google Fonts",
      fonts: Vl.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return Nl.forEach((n) => e.add(n.family)), Vl.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const i = n.join(";"), o = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${i}&display=swap`, a = document.createElement("link");
    a.rel = "stylesheet", a.href = o, document.head.appendChild(a);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), Go.debug(`Loaded Google Font: ${e}`);
    } catch (r) {
      Go.error(`Failed to load Google Font: ${e}`, r);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return Nl.some((n) => n.family === e) ? !0 : Vl.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", o = document.createElement("canvas").getContext("2d");
    o.font = "72px monospace";
    const a = o.measureText(n).width;
    o.font = `72px "${e}", monospace`;
    const r = o.measureText(n).width;
    return a !== r;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return Nl;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return Vl;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (Go.info("Local Font Access API not available"), !1);
  }
}
const $o = new aT(), rT = { class: "text-properties" }, lT = { class: "prop-section" }, cT = ["value"], uT = { class: "prop-section" }, dT = { class: "row font-row" }, hT = ["value"], fT = ["label"], pT = ["value"], mT = { class: "style-toggles" }, vT = {
  key: 0,
  class: "row"
}, gT = ["disabled"], yT = { class: "row" }, xT = { class: "row color-row" }, bT = { class: "color-item" }, _T = ["value"], wT = { class: "color-item" }, MT = ["value"], ST = { class: "row" }, CT = { class: "row" }, TT = { class: "align-buttons" }, ET = { class: "prop-section" }, AT = { class: "row" }, PT = { class: "vec2" }, kT = { class: "row" }, DT = { class: "vec2" }, IT = { class: "row" }, RT = { class: "vec2" }, LT = { class: "row" }, FT = { class: "row" }, OT = { class: "prop-section" }, UT = { class: "row" }, zT = ["value"], BT = ["value"], NT = { class: "row" }, VT = { class: "row" }, HT = { class: "row" }, GT = { class: "row checkbox-row" }, $T = ["checked"], WT = { class: "row checkbox-row" }, jT = ["checked"], XT = { class: "row checkbox-row" }, YT = ["checked"], qT = { class: "prop-section" }, ZT = { class: "row" }, KT = { class: "row" }, JT = { class: "row" }, QT = { class: "prop-section checkbox" }, eE = ["checked"], tE = /* @__PURE__ */ Bt({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = un(), a = xe([]), r = xe(!1), l = xe(!1);
    gn(async () => {
      await $o.initialize(), a.value = $o.getFontCategories(), r.value = $o.hasSystemFonts();
    });
    async function c() {
      l.value = !0;
      try {
        await $o.requestSystemFontAccess() && (a.value = $o.getFontCategories(), r.value = !0);
      } finally {
        l.value = !1;
      }
    }
    const u = Re(() => n.layer.data), d = Re(() => n.layer.transform), h = Re(() => o.layers.filter((E) => E.type === "spline"));
    function p(E) {
      var b;
      return (b = n.layer.properties) == null ? void 0 : b.find((S) => S.name === E);
    }
    function f(E) {
      const b = p(E);
      return b ? b.value : null;
    }
    function m(E) {
      o.setPropertyValue(n.layer.id, "Source Text", E), o.updateLayerData(n.layer.id, { text: E }), i("update");
    }
    function y(E, b) {
      o.updateLayerData(n.layer.id, { [E]: b });
      const S = {
        fill: "Fill Color",
        stroke: "Stroke Color",
        fontSize: "Font Size",
        strokeWidth: "Stroke Width"
      };
      S[E] && o.setPropertyValue(n.layer.id, S[E], b), i("update");
    }
    function g(E, b) {
      o.setPropertyValue(n.layer.id, E, b);
      const S = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        Tracking: "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      S[E] && o.updateLayerData(n.layer.id, { [S[E]]: b }), i("update");
    }
    function x(E) {
      const b = p(E);
      return (b == null ? void 0 : b.animated) ?? !1;
    }
    function w(E) {
      var R;
      const b = p(E);
      if (!b) return;
      const S = o.currentFrame, A = (R = b.keyframes) == null ? void 0 : R.find((k) => k.frame === S);
      A ? o.removeKeyframe(n.layer.id, E, A.id) : o.addKeyframe(n.layer.id, E, b.value, S), i("update");
    }
    function M(E, b, S) {
      const A = d.value[E];
      let R;
      b ? R = { ...A.value, [b]: S } : R = S, o.setPropertyValue(n.layer.id, `transform.${E}`, R), i("update");
    }
    function _(E) {
      o.setPropertyValue(n.layer.id, "opacity", E), i("update");
    }
    function C() {
      y("fontWeight", u.value.fontWeight === "bold" ? "400" : "bold");
    }
    function T() {
      y("fontStyle", u.value.fontStyle === "italic" ? "normal" : "italic");
    }
    async function P(E) {
      await $o.ensureFont(E), y("fontFamily", E);
    }
    return (E, b) => {
      var S;
      return se(), re("div", rT, [
        v("div", lT, [
          b[29] || (b[29] = v("div", { class: "section-title" }, "Source Text", -1)),
          v("textarea", {
            value: u.value.text,
            onInput: b[0] || (b[0] = (A) => m(A.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, cT)
        ]),
        v("div", uT, [
          b[35] || (b[35] = v("div", { class: "section-title" }, "Character", -1)),
          v("div", dT, [
            v("select", {
              value: u.value.fontFamily,
              onChange: b[1] || (b[1] = (A) => P(A.target.value)),
              class: "font-select"
            }, [
              (se(!0), re(Xe, null, at(a.value, (A) => (se(), re("optgroup", {
                key: A.name,
                label: A.name
              }, [
                (se(!0), re(Xe, null, at(A.fonts, (R) => (se(), re("option", {
                  key: R.family,
                  value: R.family
                }, ye(R.family), 9, pT))), 128))
              ], 8, fT))), 128))
            ], 40, hT),
            v("div", mT, [
              v("button", {
                class: Le({ active: u.value.fontWeight === "bold" }),
                onClick: C
              }, "B", 2),
              v("button", {
                class: Le({ active: u.value.fontStyle === "italic" }),
                onClick: T
              }, "I", 2)
            ])
          ]),
          r.value ? Te("", !0) : (se(), re("div", vT, [
            v("button", {
              class: "font-access-btn",
              onClick: c,
              disabled: l.value
            }, ye(l.value ? "Loading..." : "+ Load System Fonts"), 9, gT)
          ])),
          v("div", yT, [
            b[30] || (b[30] = v("label", null, "Size", -1)),
            Ne(He(it), {
              modelValue: f("Font Size") || u.value.fontSize,
              "onUpdate:modelValue": b[2] || (b[2] = (A) => g("Font Size", A))
            }, null, 8, ["modelValue"])
          ]),
          v("div", xT, [
            v("div", bT, [
              v("input", {
                type: "color",
                value: u.value.fill,
                onInput: b[3] || (b[3] = (A) => y("fill", A.target.value))
              }, null, 40, _T),
              b[31] || (b[31] = v("span", null, "Fill", -1))
            ]),
            v("div", wT, [
              v("input", {
                type: "color",
                value: u.value.stroke || "#000000",
                onInput: b[4] || (b[4] = (A) => y("stroke", A.target.value))
              }, null, 40, MT),
              b[32] || (b[32] = v("span", null, "Stroke", -1))
            ])
          ]),
          v("div", ST, [
            b[33] || (b[33] = v("label", null, "Stroke Width", -1)),
            Ne(He(it), {
              modelValue: f("Stroke Width") || u.value.strokeWidth || 0,
              "onUpdate:modelValue": b[5] || (b[5] = (A) => g("Stroke Width", A)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          v("div", CT, [
            b[34] || (b[34] = v("label", null, "Alignment", -1)),
            v("div", TT, [
              v("button", {
                class: Le({ active: u.value.textAlign === "left" }),
                onClick: b[6] || (b[6] = (A) => y("textAlign", "left"))
              }, "", 2),
              v("button", {
                class: Le({ active: u.value.textAlign === "center" }),
                onClick: b[7] || (b[7] = (A) => y("textAlign", "center"))
              }, "", 2),
              v("button", {
                class: Le({ active: u.value.textAlign === "right" }),
                onClick: b[8] || (b[8] = (A) => y("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        v("div", ET, [
          b[41] || (b[41] = v("div", { class: "section-title" }, "Transform", -1)),
          v("div", AT, [
            b[36] || (b[36] = v("label", null, "Position", -1)),
            v("div", PT, [
              Ne(He(it), {
                modelValue: d.value.position.value.x,
                "onUpdate:modelValue": b[9] || (b[9] = (A) => M("position", "x", A))
              }, null, 8, ["modelValue"]),
              Ne(He(it), {
                modelValue: d.value.position.value.y,
                "onUpdate:modelValue": b[10] || (b[10] = (A) => M("position", "y", A))
              }, null, 8, ["modelValue"])
            ])
          ]),
          v("div", kT, [
            b[37] || (b[37] = v("label", null, "Anchor Pt", -1)),
            v("div", DT, [
              Ne(He(it), {
                modelValue: d.value.anchorPoint.value.x,
                "onUpdate:modelValue": b[11] || (b[11] = (A) => M("anchorPoint", "x", A))
              }, null, 8, ["modelValue"]),
              Ne(He(it), {
                modelValue: d.value.anchorPoint.value.y,
                "onUpdate:modelValue": b[12] || (b[12] = (A) => M("anchorPoint", "y", A))
              }, null, 8, ["modelValue"])
            ])
          ]),
          v("div", IT, [
            b[38] || (b[38] = v("label", null, "Scale %", -1)),
            v("div", RT, [
              Ne(He(it), {
                modelValue: d.value.scale.value.x,
                "onUpdate:modelValue": b[13] || (b[13] = (A) => M("scale", "x", A))
              }, null, 8, ["modelValue"]),
              Ne(He(it), {
                modelValue: d.value.scale.value.y,
                "onUpdate:modelValue": b[14] || (b[14] = (A) => M("scale", "y", A))
              }, null, 8, ["modelValue"])
            ])
          ]),
          v("div", LT, [
            b[39] || (b[39] = v("label", null, "Rotation", -1)),
            Ne(He(it), {
              modelValue: d.value.rotation.value,
              "onUpdate:modelValue": b[15] || (b[15] = (A) => M("rotation", null, A))
            }, null, 8, ["modelValue"])
          ]),
          v("div", FT, [
            b[40] || (b[40] = v("label", null, "Opacity", -1)),
            Ne(He(it), {
              modelValue: ((S = s.layer.opacity) == null ? void 0 : S.value) ?? 100,
              "onUpdate:modelValue": b[16] || (b[16] = (A) => _(A)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        v("div", OT, [
          b[50] || (b[50] = v("div", { class: "section-title" }, "Path Options", -1)),
          v("div", UT, [
            b[43] || (b[43] = v("label", null, "Path", -1)),
            v("select", {
              value: u.value.pathLayerId || "",
              onChange: b[17] || (b[17] = (A) => y("pathLayerId", A.target.value || null)),
              class: "full-select"
            }, [
              b[42] || (b[42] = v("option", { value: "" }, "None", -1)),
              (se(!0), re(Xe, null, at(h.value, (A) => (se(), re("option", {
                key: A.id,
                value: A.id
              }, ye(A.name), 9, BT))), 128))
            ], 40, zT)
          ]),
          u.value.pathLayerId ? (se(), re(Xe, { key: 0 }, [
            v("div", NT, [
              b[44] || (b[44] = v("label", null, "Path Offset %", -1)),
              Ne(He(it), {
                modelValue: f("Path Offset") ?? u.value.pathOffset ?? 0,
                "onUpdate:modelValue": b[18] || (b[18] = (A) => g("Path Offset", A)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              v("button", {
                class: Le(["keyframe-btn", { active: x("Path Offset") }]),
                onClick: b[19] || (b[19] = (A) => w("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            v("div", VT, [
              b[45] || (b[45] = v("label", null, "First Margin", -1)),
              Ne(He(it), {
                modelValue: f("First Margin") ?? u.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": b[20] || (b[20] = (A) => g("First Margin", A)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            v("div", HT, [
              b[46] || (b[46] = v("label", null, "Last Margin", -1)),
              Ne(He(it), {
                modelValue: f("Last Margin") ?? u.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": b[21] || (b[21] = (A) => g("Last Margin", A)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            v("div", GT, [
              v("label", null, [
                v("input", {
                  type: "checkbox",
                  checked: u.value.pathReversed,
                  onChange: b[22] || (b[22] = (A) => y("pathReversed", !u.value.pathReversed))
                }, null, 40, $T),
                b[47] || (b[47] = ct(" Reverse Path ", -1))
              ])
            ]),
            v("div", WT, [
              v("label", null, [
                v("input", {
                  type: "checkbox",
                  checked: u.value.pathPerpendicularToPath ?? !0,
                  onChange: b[23] || (b[23] = (A) => y("pathPerpendicularToPath", !u.value.pathPerpendicularToPath))
                }, null, 40, jT),
                b[48] || (b[48] = ct(" Perpendicular to Path ", -1))
              ])
            ]),
            v("div", XT, [
              v("label", null, [
                v("input", {
                  type: "checkbox",
                  checked: u.value.pathForceAlignment,
                  onChange: b[24] || (b[24] = (A) => y("pathForceAlignment", !u.value.pathForceAlignment))
                }, null, 40, YT),
                b[49] || (b[49] = ct(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : Te("", !0)
        ]),
        v("div", qT, [
          b[54] || (b[54] = v("div", { class: "section-title" }, "Advanced", -1)),
          v("div", ZT, [
            b[51] || (b[51] = v("label", null, "Tracking", -1)),
            Ne(He(it), {
              modelValue: f("Tracking") || u.value.tracking || 0,
              "onUpdate:modelValue": b[25] || (b[25] = (A) => g("Tracking", A))
            }, null, 8, ["modelValue"])
          ]),
          v("div", KT, [
            b[52] || (b[52] = v("label", null, "Line Spacing", -1)),
            Ne(He(it), {
              modelValue: f("Line Spacing") || u.value.lineSpacing || 0,
              "onUpdate:modelValue": b[26] || (b[26] = (A) => g("Line Spacing", A))
            }, null, 8, ["modelValue"])
          ]),
          v("div", JT, [
            b[53] || (b[53] = v("label", null, "Char Offset", -1)),
            Ne(He(it), {
              modelValue: f("Character Offset") || u.value.characterOffset || 0,
              "onUpdate:modelValue": b[27] || (b[27] = (A) => g("Character Offset", A)),
              precision: 0
            }, null, 8, ["modelValue"])
          ])
        ]),
        v("div", QT, [
          v("label", null, [
            v("input", {
              type: "checkbox",
              checked: u.value.perCharacter3D,
              onChange: b[28] || (b[28] = (A) => y("perCharacter3D", !u.value.perCharacter3D))
            }, null, 40, eE),
            b[55] || (b[55] = ct(" Enable Per-Character 3D ", -1))
          ])
        ])
      ]);
    };
  }
}), nE = /* @__PURE__ */ Vt(tE, [["__scopeId", "data-v-947c42b2"]]), iE = { class: "particle-properties" }, sE = { class: "property-section" }, oE = {
  key: 0,
  class: "section-content"
}, aE = { class: "property-row" }, rE = ["value"], lE = { class: "value-display" }, cE = { class: "property-row" }, uE = ["value"], dE = { class: "value-display" }, hE = { class: "property-row" }, fE = ["value"], pE = { class: "value-display" }, mE = { class: "property-row" }, vE = ["value"], gE = { class: "value-display" }, yE = { class: "property-row" }, xE = ["value"], bE = { class: "value-display" }, _E = { class: "property-row" }, wE = ["value"], ME = { class: "property-section" }, SE = {
  key: 0,
  class: "section-content"
}, CE = ["onClick"], TE = ["value", "onInput"], EE = { class: "enabled-toggle" }, AE = ["checked", "onChange"], PE = ["onClick"], kE = {
  key: 0,
  class: "emitter-content"
}, DE = { class: "property-row" }, IE = ["value", "onInput"], RE = { class: "value-display" }, LE = { class: "property-row" }, FE = ["value", "onInput"], OE = { class: "value-display" }, UE = { class: "property-row" }, zE = ["value", "onInput"], BE = { class: "value-display" }, NE = { class: "property-row" }, VE = ["value", "onInput"], HE = { class: "value-display" }, GE = { class: "property-row" }, $E = ["value", "onInput"], WE = { class: "value-display" }, jE = { class: "property-row" }, XE = ["value", "onInput"], YE = { class: "value-display" }, qE = { class: "property-row" }, ZE = ["value", "onInput"], KE = { class: "value-display" }, JE = { class: "property-row" }, QE = ["value", "onInput"], eA = { class: "value-display" }, tA = { class: "property-row" }, nA = ["value", "onInput"], iA = { class: "property-row" }, sA = ["value", "onInput"], oA = { class: "value-display" }, aA = { class: "property-row" }, rA = ["value", "onInput"], lA = { class: "value-display" }, cA = { class: "property-row" }, uA = ["value", "onInput"], dA = { class: "value-display" }, hA = { class: "property-row checkbox-row" }, fA = ["checked", "onChange"], pA = {
  key: 0,
  class: "property-row"
}, mA = ["value", "onInput"], vA = { class: "value-display" }, gA = {
  key: 0,
  class: "empty-message"
}, yA = { class: "property-section" }, xA = {
  key: 0,
  class: "section-content"
}, bA = { class: "force-tabs" }, _A = {
  key: 0,
  class: "force-list"
}, wA = { class: "force-header" }, MA = ["value", "onInput"], SA = { class: "enabled-toggle" }, CA = ["checked", "onChange"], TA = ["onClick"], EA = { class: "property-row" }, AA = ["value", "onInput"], PA = { class: "value-display" }, kA = { class: "property-row" }, DA = ["value", "onInput"], IA = { class: "value-display" }, RA = { class: "property-row" }, LA = ["value", "onInput"], FA = { class: "value-display" }, OA = { class: "property-row" }, UA = ["value", "onInput"], zA = { class: "value-display" }, BA = { class: "property-row" }, NA = ["value", "onChange"], VA = {
  key: 1,
  class: "force-list"
}, HA = { class: "force-header" }, GA = ["value", "onInput"], $A = { class: "enabled-toggle" }, WA = ["checked", "onChange"], jA = ["onClick"], XA = { class: "property-row" }, YA = ["value", "onInput"], qA = { class: "value-display" }, ZA = { class: "property-row" }, KA = ["value", "onInput"], JA = { class: "value-display" }, QA = { class: "property-row" }, eP = ["value", "onInput"], tP = { class: "value-display" }, nP = { class: "property-row" }, iP = ["value", "onInput"], sP = { class: "value-display" }, oP = { class: "property-row" }, aP = ["value", "onInput"], rP = { class: "value-display" }, lP = { class: "property-row" }, cP = ["value", "onInput"], uP = { class: "value-display" }, dP = { class: "property-section" }, hP = {
  key: 0,
  class: "section-content"
}, fP = { class: "force-header" }, pP = { class: "enabled-toggle" }, mP = ["checked", "onChange"], vP = ["onClick"], gP = { class: "property-row" }, yP = ["value", "onInput"], xP = { class: "value-display" }, bP = { class: "property-row" }, _P = ["value", "onInput"], wP = { class: "value-display" }, MP = { class: "property-row" }, SP = ["value", "onInput"], CP = { class: "value-display" }, TP = {
  key: 0,
  class: "empty-message"
}, EP = { class: "property-section" }, AP = {
  key: 0,
  class: "section-content"
}, PP = { class: "force-header" }, kP = ["value", "onChange"], DP = ["value"], IP = { class: "enabled-toggle" }, RP = ["checked", "onChange"], LP = ["onClick"], FP = { class: "property-row" }, OP = ["value", "onChange"], UP = { class: "property-row" }, zP = ["value", "onInput"], BP = { class: "value-display" }, NP = { class: "property-row" }, VP = ["value", "onInput"], HP = { class: "value-display" }, GP = { class: "property-row" }, $P = ["value", "onInput"], WP = { class: "value-display" }, jP = { class: "property-row" }, XP = ["value", "onInput"], YP = { class: "value-display" }, qP = { class: "property-row" }, ZP = ["value", "onInput"], KP = { class: "value-display" }, JP = { class: "property-row" }, QP = ["value", "onInput"], ek = { class: "value-display" }, tk = { class: "property-row" }, nk = ["value", "onInput"], ik = {
  key: 0,
  class: "empty-message"
}, sk = { class: "property-section" }, ok = {
  key: 0,
  class: "section-content"
}, ak = { class: "modulation-header" }, rk = ["value", "onChange"], lk = ["value"], ck = ["onClick"], uk = { class: "property-row" }, dk = ["value", "onChange"], hk = { class: "property-row" }, fk = ["value", "onInput"], pk = { class: "property-row" }, mk = ["value", "onInput"], vk = { class: "property-row" }, gk = ["value", "onChange"], yk = {
  key: 0,
  class: "empty-message"
}, xk = { class: "property-section" }, bk = {
  key: 0,
  class: "section-content"
}, _k = { class: "property-row" }, wk = ["value"], Mk = { class: "property-row" }, Sk = ["value"], Ck = { class: "property-row checkbox-row" }, Tk = ["checked"], Ek = {
  key: 0,
  class: "property-row"
}, Ak = ["value"], Pk = { class: "value-display" }, kk = { class: "property-row checkbox-row" }, Dk = ["checked"], Ik = {
  key: 1,
  class: "property-row"
}, Rk = ["value"], Lk = { class: "value-display" }, Fk = {
  key: 2,
  class: "property-row"
}, Ok = ["value"], Uk = { class: "value-display" }, zk = { class: "property-row checkbox-row" }, Bk = ["checked"], Nk = {
  key: 3,
  class: "property-row"
}, Vk = ["value"], Hk = { class: "value-display" }, Gk = {
  key: 4,
  class: "property-row"
}, $k = ["value"], Wk = { class: "value-display" }, jk = {
  key: 5,
  class: "property-row"
}, Xk = ["value"], Yk = { class: "value-display" }, qk = {
  key: 6,
  class: "property-row"
}, Zk = ["value"], Kk = { class: "value-display" }, Jk = {
  key: 7,
  class: "property-row checkbox-row"
}, Qk = ["checked"], eD = { class: "particle-count" }, tD = /* @__PURE__ */ Bt({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = xe(/* @__PURE__ */ new Set(["system", "emitters"])), a = xe(/* @__PURE__ */ new Set()), r = xe("wells"), l = Re(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), c = Re(() => l.value.systemConfig), u = Re(() => l.value.emitters), d = Re(() => l.value.gravityWells), h = Re(() => l.value.vortices), p = Re(() => l.value.modulations), f = Re(() => l.value.renderOptions), m = Re(() => l.value.turbulenceFields || []), y = Re(() => l.value.subEmitters || []), g = Re(() => f.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), x = Re(() => n.particleCount);
    function w(ne) {
      o.value.has(ne) ? o.value.delete(ne) : o.value.add(ne);
    }
    function M(ne) {
      a.value.has(ne) ? a.value.delete(ne) : a.value.add(ne);
    }
    function _(ne, N) {
      i("update", {
        systemConfig: { ...c.value, [ne]: N }
      });
    }
    function C(ne, N, te) {
      const F = u.value.map(
        (B) => B.id === ne ? { ...B, [N]: te } : B
      );
      i("update", { emitters: F });
    }
    function T(ne, N) {
      const te = he(N);
      C(ne, "color", te);
    }
    function P() {
      const ne = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${u.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      i("update", { emitters: [...u.value, ne] }), a.value.add(ne.id);
    }
    function E(ne) {
      i("update", { emitters: u.value.filter((N) => N.id !== ne) });
    }
    function b(ne, N, te) {
      const F = d.value.map(
        (B) => B.id === ne ? { ...B, [N]: te } : B
      );
      i("update", { gravityWells: F });
    }
    function S() {
      const ne = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${d.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      i("update", { gravityWells: [...d.value, ne] });
    }
    function A(ne) {
      i("update", { gravityWells: d.value.filter((N) => N.id !== ne) });
    }
    function R(ne, N, te) {
      const F = h.value.map(
        (B) => B.id === ne ? { ...B, [N]: te } : B
      );
      i("update", { vortices: F });
    }
    function k() {
      const ne = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${h.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      i("update", { vortices: [...h.value, ne] });
    }
    function U(ne) {
      i("update", { vortices: h.value.filter((N) => N.id !== ne) });
    }
    function I(ne, N, te) {
      const F = p.value.map(
        (B) => B.id === ne ? { ...B, [N]: te } : B
      );
      i("update", { modulations: F });
    }
    function W() {
      const ne = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      i("update", { modulations: [...p.value, ne] });
    }
    function fe(ne) {
      i("update", { modulations: p.value.filter((N) => N.id !== ne) });
    }
    function q(ne, N) {
      i("update", {
        renderOptions: { ...f.value, [ne]: N }
      });
    }
    function G(ne, N) {
      i("update", {
        renderOptions: {
          ...f.value,
          connections: { ...g.value, [ne]: N }
        }
      });
    }
    function Q(ne, N, te) {
      const F = m.value.map(
        (B) => B.id === ne ? { ...B, [N]: te } : B
      );
      i("update", { turbulenceFields: F });
    }
    function K() {
      const ne = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      i("update", { turbulenceFields: [...m.value, ne] });
    }
    function Y(ne) {
      i("update", { turbulenceFields: m.value.filter((N) => N.id !== ne) });
    }
    function ee(ne, N, te) {
      const F = y.value.map(
        (B) => B.id === ne ? { ...B, [N]: te } : B
      );
      i("update", { subEmitters: F });
    }
    function ce(ne, N) {
      const te = he(N);
      ee(ne, "color", te);
    }
    function ae() {
      const ne = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      i("update", { subEmitters: [...y.value, ne] });
    }
    function de(ne) {
      i("update", { subEmitters: y.value.filter((N) => N.id !== ne) });
    }
    function ie(ne) {
      return "#" + ne.map((N) => N.toString(16).padStart(2, "0")).join("");
    }
    function he(ne) {
      const N = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(ne);
      return N ? [parseInt(N[1], 16), parseInt(N[2], 16), parseInt(N[3], 16)] : [255, 255, 255];
    }
    return (ne, N) => (se(), re("div", iE, [
      v("div", sE, [
        v("div", {
          class: "section-header",
          onClick: N[0] || (N[0] = (te) => w("system"))
        }, [
          v("i", {
            class: Le(["pi", o.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          N[30] || (N[30] = v("span", null, "System Settings", -1))
        ]),
        o.value.has("system") ? (se(), re("div", oE, [
          v("div", aE, [
            N[31] || (N[31] = v("label", null, "Max Particles", -1)),
            v("input", {
              type: "range",
              value: c.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: N[1] || (N[1] = (te) => _("maxParticles", Number(te.target.value)))
            }, null, 40, rE),
            v("span", lE, ye(c.value.maxParticles), 1)
          ]),
          v("div", cE, [
            N[32] || (N[32] = v("label", null, "Gravity", -1)),
            v("input", {
              type: "range",
              value: c.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: N[2] || (N[2] = (te) => _("gravity", Number(te.target.value)))
            }, null, 40, uE),
            v("span", dE, ye(c.value.gravity), 1)
          ]),
          v("div", hE, [
            N[33] || (N[33] = v("label", null, "Wind Strength", -1)),
            v("input", {
              type: "range",
              value: c.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: N[3] || (N[3] = (te) => _("windStrength", Number(te.target.value)))
            }, null, 40, fE),
            v("span", pE, ye(c.value.windStrength), 1)
          ]),
          v("div", mE, [
            N[34] || (N[34] = v("label", null, "Wind Direction", -1)),
            v("input", {
              type: "range",
              value: c.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: N[4] || (N[4] = (te) => _("windDirection", Number(te.target.value)))
            }, null, 40, vE),
            v("span", gE, ye(c.value.windDirection) + "", 1)
          ]),
          v("div", yE, [
            N[35] || (N[35] = v("label", null, "Friction", -1)),
            v("input", {
              type: "range",
              value: c.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: N[5] || (N[5] = (te) => _("friction", Number(te.target.value)))
            }, null, 40, xE),
            v("span", bE, ye(c.value.friction.toFixed(2)), 1)
          ]),
          v("div", _E, [
            N[37] || (N[37] = v("label", null, "Boundary", -1)),
            v("select", {
              value: c.value.boundaryBehavior,
              onChange: N[6] || (N[6] = (te) => _("boundaryBehavior", te.target.value))
            }, [...N[36] || (N[36] = [
              v("option", { value: "kill" }, "Kill", -1),
              v("option", { value: "bounce" }, "Bounce", -1),
              v("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, wE)
          ])
        ])) : Te("", !0)
      ]),
      v("div", ME, [
        v("div", {
          class: "section-header",
          onClick: N[7] || (N[7] = (te) => w("emitters"))
        }, [
          v("i", {
            class: Le(["pi", o.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          N[39] || (N[39] = v("span", null, "Emitters", -1)),
          v("button", {
            class: "add-btn",
            onClick: _t(P, ["stop"]),
            title: "Add Emitter"
          }, [...N[38] || (N[38] = [
            v("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("emitters") ? (se(), re("div", SE, [
          (se(!0), re(Xe, null, at(u.value, (te) => (se(), re("div", {
            key: te.id,
            class: "emitter-item"
          }, [
            v("div", {
              class: "emitter-header",
              onClick: (F) => M(te.id)
            }, [
              v("i", {
                class: Le(["pi", a.value.has(te.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              v("input", {
                type: "text",
                value: te.name,
                onInput: (F) => C(te.id, "name", F.target.value),
                onClick: N[8] || (N[8] = _t(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, TE),
              v("label", EE, [
                v("input", {
                  type: "checkbox",
                  checked: te.enabled,
                  onChange: (F) => C(te.id, "enabled", F.target.checked),
                  onClick: N[9] || (N[9] = _t(() => {
                  }, ["stop"]))
                }, null, 40, AE)
              ]),
              v("button", {
                class: "remove-btn",
                onClick: _t((F) => E(te.id), ["stop"]),
                title: "Remove"
              }, [...N[40] || (N[40] = [
                v("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, PE)
            ], 8, CE),
            a.value.has(te.id) ? (se(), re("div", kE, [
              v("div", DE, [
                N[41] || (N[41] = v("label", null, "Position X", -1)),
                v("input", {
                  type: "range",
                  value: te.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => C(te.id, "x", Number(F.target.value))
                }, null, 40, IE),
                v("span", RE, ye(te.x.toFixed(2)), 1)
              ]),
              v("div", LE, [
                N[42] || (N[42] = v("label", null, "Position Y", -1)),
                v("input", {
                  type: "range",
                  value: te.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => C(te.id, "y", Number(F.target.value))
                }, null, 40, FE),
                v("span", OE, ye(te.y.toFixed(2)), 1)
              ]),
              v("div", UE, [
                N[43] || (N[43] = v("label", null, "Direction", -1)),
                v("input", {
                  type: "range",
                  value: te.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (F) => C(te.id, "direction", Number(F.target.value))
                }, null, 40, zE),
                v("span", BE, ye(te.direction) + "", 1)
              ]),
              v("div", NE, [
                N[44] || (N[44] = v("label", null, "Spread", -1)),
                v("input", {
                  type: "range",
                  value: te.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (F) => C(te.id, "spread", Number(F.target.value))
                }, null, 40, VE),
                v("span", HE, ye(te.spread) + "", 1)
              ]),
              v("div", GE, [
                N[45] || (N[45] = v("label", null, "Speed", -1)),
                v("input", {
                  type: "range",
                  value: te.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (F) => C(te.id, "speed", Number(F.target.value))
                }, null, 40, $E),
                v("span", WE, ye(te.speed), 1)
              ]),
              v("div", jE, [
                N[46] || (N[46] = v("label", null, "Speed Variance", -1)),
                v("input", {
                  type: "range",
                  value: te.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (F) => C(te.id, "speedVariance", Number(F.target.value))
                }, null, 40, XE),
                v("span", YE, ye(te.speedVariance), 1)
              ]),
              v("div", qE, [
                N[47] || (N[47] = v("label", null, "Size", -1)),
                v("input", {
                  type: "range",
                  value: te.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (F) => C(te.id, "size", Number(F.target.value))
                }, null, 40, ZE),
                v("span", KE, ye(te.size) + "px", 1)
              ]),
              v("div", JE, [
                N[48] || (N[48] = v("label", null, "Size Variance", -1)),
                v("input", {
                  type: "range",
                  value: te.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (F) => C(te.id, "sizeVariance", Number(F.target.value))
                }, null, 40, QE),
                v("span", eA, ye(te.sizeVariance), 1)
              ]),
              v("div", tA, [
                N[49] || (N[49] = v("label", null, "Color", -1)),
                v("input", {
                  type: "color",
                  value: ie(te.color),
                  onInput: (F) => T(te.id, F.target.value)
                }, null, 40, nA)
              ]),
              v("div", iA, [
                N[50] || (N[50] = v("label", null, "Emission Rate", -1)),
                v("input", {
                  type: "range",
                  value: te.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (F) => C(te.id, "emissionRate", Number(F.target.value))
                }, null, 40, sA),
                v("span", oA, ye(te.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              v("div", aA, [
                N[51] || (N[51] = v("label", null, "Lifetime", -1)),
                v("input", {
                  type: "range",
                  value: te.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (F) => C(te.id, "particleLifetime", Number(F.target.value))
                }, null, 40, rA),
                v("span", lA, ye(te.particleLifetime) + "f", 1)
              ]),
              v("div", cA, [
                N[52] || (N[52] = v("label", null, "Initial Burst", -1)),
                v("input", {
                  type: "range",
                  value: te.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (F) => C(te.id, "initialBurst", Number(F.target.value))
                }, null, 40, uA),
                v("span", dA, ye((te.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              v("div", hA, [
                v("label", null, [
                  v("input", {
                    type: "checkbox",
                    checked: te.burstOnBeat,
                    onChange: (F) => C(te.id, "burstOnBeat", F.target.checked)
                  }, null, 40, fA),
                  N[53] || (N[53] = ct(" Burst on Beat ", -1))
                ])
              ]),
              te.burstOnBeat ? (se(), re("div", pA, [
                N[54] || (N[54] = v("label", null, "Burst Count", -1)),
                v("input", {
                  type: "range",
                  value: te.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (F) => C(te.id, "burstCount", Number(F.target.value))
                }, null, 40, mA),
                v("span", vA, ye(te.burstCount), 1)
              ])) : Te("", !0)
            ])) : Te("", !0)
          ]))), 128)),
          u.value.length === 0 ? (se(), re("div", gA, " No emitters. Click + to add one. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", yA, [
        v("div", {
          class: "section-header",
          onClick: N[10] || (N[10] = (te) => w("forces"))
        }, [
          v("i", {
            class: Le(["pi", o.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          N[55] || (N[55] = v("span", null, "Force Fields", -1))
        ]),
        o.value.has("forces") ? (se(), re("div", xA, [
          v("div", bA, [
            v("button", {
              class: Le({ active: r.value === "wells" }),
              onClick: N[11] || (N[11] = (te) => r.value = "wells")
            }, " Gravity Wells ", 2),
            v("button", {
              class: Le({ active: r.value === "vortices" }),
              onClick: N[12] || (N[12] = (te) => r.value = "vortices")
            }, " Vortices ", 2)
          ]),
          r.value === "wells" ? (se(), re("div", _A, [
            v("button", {
              class: "add-btn full-width",
              onClick: S
            }, [...N[56] || (N[56] = [
              v("i", { class: "pi pi-plus" }, null, -1),
              ct(" Add Gravity Well ", -1)
            ])]),
            (se(!0), re(Xe, null, at(d.value, (te) => (se(), re("div", {
              key: te.id,
              class: "force-item"
            }, [
              v("div", wA, [
                v("input", {
                  type: "text",
                  value: te.name,
                  onInput: (F) => b(te.id, "name", F.target.value),
                  class: "force-name"
                }, null, 40, MA),
                v("label", SA, [
                  v("input", {
                    type: "checkbox",
                    checked: te.enabled,
                    onChange: (F) => b(te.id, "enabled", F.target.checked)
                  }, null, 40, CA)
                ]),
                v("button", {
                  class: "remove-btn",
                  onClick: (F) => A(te.id)
                }, [...N[57] || (N[57] = [
                  v("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, TA)
              ]),
              v("div", EA, [
                N[58] || (N[58] = v("label", null, "Position X", -1)),
                v("input", {
                  type: "range",
                  value: te.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => b(te.id, "x", Number(F.target.value))
                }, null, 40, AA),
                v("span", PA, ye(te.x.toFixed(2)), 1)
              ]),
              v("div", kA, [
                N[59] || (N[59] = v("label", null, "Position Y", -1)),
                v("input", {
                  type: "range",
                  value: te.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => b(te.id, "y", Number(F.target.value))
                }, null, 40, DA),
                v("span", IA, ye(te.y.toFixed(2)), 1)
              ]),
              v("div", RA, [
                N[60] || (N[60] = v("label", null, "Strength", -1)),
                v("input", {
                  type: "range",
                  value: te.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (F) => b(te.id, "strength", Number(F.target.value))
                }, null, 40, LA),
                v("span", FA, ye(te.strength), 1)
              ]),
              v("div", OA, [
                N[61] || (N[61] = v("label", null, "Radius", -1)),
                v("input", {
                  type: "range",
                  value: te.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => b(te.id, "radius", Number(F.target.value))
                }, null, 40, UA),
                v("span", zA, ye(te.radius.toFixed(2)), 1)
              ]),
              v("div", BA, [
                N[63] || (N[63] = v("label", null, "Falloff", -1)),
                v("select", {
                  value: te.falloff,
                  onChange: (F) => b(te.id, "falloff", F.target.value)
                }, [...N[62] || (N[62] = [
                  v("option", { value: "linear" }, "Linear", -1),
                  v("option", { value: "quadratic" }, "Quadratic", -1),
                  v("option", { value: "constant" }, "Constant", -1)
                ])], 40, NA)
              ])
            ]))), 128))
          ])) : Te("", !0),
          r.value === "vortices" ? (se(), re("div", VA, [
            v("button", {
              class: "add-btn full-width",
              onClick: k
            }, [...N[64] || (N[64] = [
              v("i", { class: "pi pi-plus" }, null, -1),
              ct(" Add Vortex ", -1)
            ])]),
            (se(!0), re(Xe, null, at(h.value, (te) => (se(), re("div", {
              key: te.id,
              class: "force-item"
            }, [
              v("div", HA, [
                v("input", {
                  type: "text",
                  value: te.name,
                  onInput: (F) => R(te.id, "name", F.target.value),
                  class: "force-name"
                }, null, 40, GA),
                v("label", $A, [
                  v("input", {
                    type: "checkbox",
                    checked: te.enabled,
                    onChange: (F) => R(te.id, "enabled", F.target.checked)
                  }, null, 40, WA)
                ]),
                v("button", {
                  class: "remove-btn",
                  onClick: (F) => U(te.id)
                }, [...N[65] || (N[65] = [
                  v("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, jA)
              ]),
              v("div", XA, [
                N[66] || (N[66] = v("label", null, "Position X", -1)),
                v("input", {
                  type: "range",
                  value: te.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => R(te.id, "x", Number(F.target.value))
                }, null, 40, YA),
                v("span", qA, ye(te.x.toFixed(2)), 1)
              ]),
              v("div", ZA, [
                N[67] || (N[67] = v("label", null, "Position Y", -1)),
                v("input", {
                  type: "range",
                  value: te.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => R(te.id, "y", Number(F.target.value))
                }, null, 40, KA),
                v("span", JA, ye(te.y.toFixed(2)), 1)
              ]),
              v("div", QA, [
                N[68] || (N[68] = v("label", null, "Strength", -1)),
                v("input", {
                  type: "range",
                  value: te.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (F) => R(te.id, "strength", Number(F.target.value))
                }, null, 40, eP),
                v("span", tP, ye(te.strength), 1)
              ]),
              v("div", nP, [
                N[69] || (N[69] = v("label", null, "Radius", -1)),
                v("input", {
                  type: "range",
                  value: te.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (F) => R(te.id, "radius", Number(F.target.value))
                }, null, 40, iP),
                v("span", sP, ye(te.radius.toFixed(2)), 1)
              ]),
              v("div", oP, [
                N[70] || (N[70] = v("label", null, "Rotation Speed", -1)),
                v("input", {
                  type: "range",
                  value: te.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (F) => R(te.id, "rotationSpeed", Number(F.target.value))
                }, null, 40, aP),
                v("span", rP, ye(te.rotationSpeed) + "/f", 1)
              ]),
              v("div", lP, [
                N[71] || (N[71] = v("label", null, "Inward Pull", -1)),
                v("input", {
                  type: "range",
                  value: te.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (F) => R(te.id, "inwardPull", Number(F.target.value))
                }, null, 40, cP),
                v("span", uP, ye(te.inwardPull), 1)
              ])
            ]))), 128))
          ])) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", dP, [
        v("div", {
          class: "section-header",
          onClick: N[13] || (N[13] = (te) => w("turbulence"))
        }, [
          v("i", {
            class: Le(["pi", o.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          N[73] || (N[73] = v("span", null, "Turbulence", -1)),
          v("button", {
            class: "add-btn",
            onClick: _t(K, ["stop"]),
            title: "Add Turbulence Field"
          }, [...N[72] || (N[72] = [
            v("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("turbulence") ? (se(), re("div", hP, [
          (se(!0), re(Xe, null, at(m.value, (te) => (se(), re("div", {
            key: te.id,
            class: "force-item"
          }, [
            v("div", fP, [
              N[75] || (N[75] = v("span", { class: "force-label" }, "Turbulence Field", -1)),
              v("label", pP, [
                v("input", {
                  type: "checkbox",
                  checked: te.enabled,
                  onChange: (F) => Q(te.id, "enabled", F.target.checked)
                }, null, 40, mP)
              ]),
              v("button", {
                class: "remove-btn",
                onClick: (F) => Y(te.id)
              }, [...N[74] || (N[74] = [
                v("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, vP)
            ]),
            v("div", gP, [
              N[76] || (N[76] = v("label", null, "Scale", -1)),
              v("input", {
                type: "range",
                value: te.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (F) => Q(te.id, "scale", Number(F.target.value))
              }, null, 40, yP),
              v("span", xP, ye(te.scale.toFixed(3)), 1)
            ]),
            v("div", bP, [
              N[77] || (N[77] = v("label", null, "Strength", -1)),
              v("input", {
                type: "range",
                value: te.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (F) => Q(te.id, "strength", Number(F.target.value))
              }, null, 40, _P),
              v("span", wP, ye(te.strength), 1)
            ]),
            v("div", MP, [
              N[78] || (N[78] = v("label", null, "Evolution", -1)),
              v("input", {
                type: "range",
                value: te.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (F) => Q(te.id, "evolutionSpeed", Number(F.target.value))
              }, null, 40, SP),
              v("span", CP, ye(te.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          m.value.length === 0 ? (se(), re("div", TP, " No turbulence fields. Add one for organic particle motion. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", EP, [
        v("div", {
          class: "section-header",
          onClick: N[14] || (N[14] = (te) => w("subEmitters"))
        }, [
          v("i", {
            class: Le(["pi", o.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          N[80] || (N[80] = v("span", null, "Sub-Emitters", -1)),
          v("button", {
            class: "add-btn",
            onClick: _t(ae, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...N[79] || (N[79] = [
            v("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("subEmitters") ? (se(), re("div", AP, [
          (se(!0), re(Xe, null, at(y.value, (te) => (se(), re("div", {
            key: te.id,
            class: "force-item"
          }, [
            v("div", PP, [
              v("select", {
                value: te.parentEmitterId,
                onChange: (F) => ee(te.id, "parentEmitterId", F.target.value),
                class: "sub-emitter-parent"
              }, [
                N[81] || (N[81] = v("option", { value: "*" }, "All Emitters", -1)),
                (se(!0), re(Xe, null, at(u.value, (F) => (se(), re("option", {
                  key: F.id,
                  value: F.id
                }, ye(F.name), 9, DP))), 128))
              ], 40, kP),
              v("label", IP, [
                v("input", {
                  type: "checkbox",
                  checked: te.enabled,
                  onChange: (F) => ee(te.id, "enabled", F.target.checked)
                }, null, 40, RP)
              ]),
              v("button", {
                class: "remove-btn",
                onClick: (F) => de(te.id)
              }, [...N[82] || (N[82] = [
                v("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, LP)
            ]),
            v("div", FP, [
              N[84] || (N[84] = v("label", null, "Trigger", -1)),
              v("select", {
                value: te.trigger,
                onChange: (F) => ee(te.id, "trigger", F.target.value)
              }, [...N[83] || (N[83] = [
                v("option", { value: "death" }, "On Death", -1)
              ])], 40, OP)
            ]),
            v("div", UP, [
              N[85] || (N[85] = v("label", null, "Spawn Count", -1)),
              v("input", {
                type: "range",
                value: te.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (F) => ee(te.id, "spawnCount", Number(F.target.value))
              }, null, 40, zP),
              v("span", BP, ye(te.spawnCount), 1)
            ]),
            v("div", NP, [
              N[86] || (N[86] = v("label", null, "Inherit Velocity", -1)),
              v("input", {
                type: "range",
                value: te.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (F) => ee(te.id, "inheritVelocity", Number(F.target.value))
              }, null, 40, VP),
              v("span", HP, ye((te.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            v("div", GP, [
              N[87] || (N[87] = v("label", null, "Size", -1)),
              v("input", {
                type: "range",
                value: te.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (F) => ee(te.id, "size", Number(F.target.value))
              }, null, 40, $P),
              v("span", WP, ye(te.size) + "px", 1)
            ]),
            v("div", jP, [
              N[88] || (N[88] = v("label", null, "Lifetime", -1)),
              v("input", {
                type: "range",
                value: te.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (F) => ee(te.id, "lifetime", Number(F.target.value))
              }, null, 40, XP),
              v("span", YP, ye(te.lifetime) + "f", 1)
            ]),
            v("div", qP, [
              N[89] || (N[89] = v("label", null, "Speed", -1)),
              v("input", {
                type: "range",
                value: te.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (F) => ee(te.id, "speed", Number(F.target.value))
              }, null, 40, ZP),
              v("span", KP, ye(te.speed), 1)
            ]),
            v("div", JP, [
              N[90] || (N[90] = v("label", null, "Spread", -1)),
              v("input", {
                type: "range",
                value: te.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (F) => ee(te.id, "spread", Number(F.target.value))
              }, null, 40, QP),
              v("span", ek, ye(te.spread) + "", 1)
            ]),
            v("div", tk, [
              N[91] || (N[91] = v("label", null, "Color", -1)),
              v("input", {
                type: "color",
                value: ie(te.color),
                onInput: (F) => ce(te.id, F.target.value)
              }, null, 40, nk)
            ])
          ]))), 128)),
          y.value.length === 0 ? (se(), re("div", ik, " No sub-emitters. Add one for particle death effects. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", sk, [
        v("div", {
          class: "section-header",
          onClick: N[15] || (N[15] = (te) => w("modulations"))
        }, [
          v("i", {
            class: Le(["pi", o.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          N[93] || (N[93] = v("span", null, "Modulations", -1)),
          v("button", {
            class: "add-btn",
            onClick: _t(W, ["stop"]),
            title: "Add Modulation"
          }, [...N[92] || (N[92] = [
            v("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        o.value.has("modulations") ? (se(), re("div", ok, [
          (se(!0), re(Xe, null, at(p.value, (te) => (se(), re("div", {
            key: te.id,
            class: "modulation-item"
          }, [
            v("div", ak, [
              v("select", {
                value: te.emitterId,
                onChange: (F) => I(te.id, "emitterId", F.target.value)
              }, [
                N[94] || (N[94] = v("option", { value: "*" }, "All Emitters", -1)),
                (se(!0), re(Xe, null, at(u.value, (F) => (se(), re("option", {
                  key: F.id,
                  value: F.id
                }, ye(F.name), 9, lk))), 128))
              ], 40, rk),
              v("button", {
                class: "remove-btn",
                onClick: (F) => fe(te.id)
              }, [...N[95] || (N[95] = [
                v("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, ck)
            ]),
            v("div", uk, [
              N[97] || (N[97] = v("label", null, "Property", -1)),
              v("select", {
                value: te.property,
                onChange: (F) => I(te.id, "property", F.target.value)
              }, [...N[96] || (N[96] = [
                fs('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, dk)
            ]),
            v("div", hk, [
              N[98] || (N[98] = v("label", null, "Start Value", -1)),
              v("input", {
                type: "number",
                value: te.startValue,
                step: "0.1",
                onInput: (F) => I(te.id, "startValue", Number(F.target.value))
              }, null, 40, fk)
            ]),
            v("div", pk, [
              N[99] || (N[99] = v("label", null, "End Value", -1)),
              v("input", {
                type: "number",
                value: te.endValue,
                step: "0.1",
                onInput: (F) => I(te.id, "endValue", Number(F.target.value))
              }, null, 40, mk)
            ]),
            v("div", vk, [
              N[101] || (N[101] = v("label", null, "Easing", -1)),
              v("select", {
                value: te.easing,
                onChange: (F) => I(te.id, "easing", F.target.value)
              }, [...N[100] || (N[100] = [
                fs('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, gk)
            ])
          ]))), 128)),
          p.value.length === 0 ? (se(), re("div", yk, " No modulations. Add one to animate particle properties over lifetime. ")) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", xk, [
        v("div", {
          class: "section-header",
          onClick: N[16] || (N[16] = (te) => w("render"))
        }, [
          v("i", {
            class: Le(["pi", o.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          N[102] || (N[102] = v("span", null, "Render Options", -1))
        ]),
        o.value.has("render") ? (se(), re("div", bk, [
          v("div", _k, [
            N[104] || (N[104] = v("label", null, "Blend Mode", -1)),
            v("select", {
              value: f.value.blendMode,
              onChange: N[17] || (N[17] = (te) => q("blendMode", te.target.value))
            }, [...N[103] || (N[103] = [
              v("option", { value: "normal" }, "Normal", -1),
              v("option", { value: "additive" }, "Additive", -1),
              v("option", { value: "multiply" }, "Multiply", -1),
              v("option", { value: "screen" }, "Screen", -1)
            ])], 40, wk)
          ]),
          v("div", Mk, [
            N[106] || (N[106] = v("label", null, "Shape", -1)),
            v("select", {
              value: f.value.particleShape,
              onChange: N[18] || (N[18] = (te) => q("particleShape", te.target.value))
            }, [...N[105] || (N[105] = [
              v("option", { value: "circle" }, "Circle", -1),
              v("option", { value: "square" }, "Square", -1),
              v("option", { value: "triangle" }, "Triangle", -1),
              v("option", { value: "star" }, "Star", -1)
            ])], 40, Sk)
          ]),
          v("div", Ck, [
            v("label", null, [
              v("input", {
                type: "checkbox",
                checked: f.value.renderTrails,
                onChange: N[19] || (N[19] = (te) => q("renderTrails", te.target.checked))
              }, null, 40, Tk),
              N[107] || (N[107] = ct(" Render Trails ", -1))
            ])
          ]),
          f.value.renderTrails ? (se(), re("div", Ek, [
            N[108] || (N[108] = v("label", null, "Trail Length", -1)),
            v("input", {
              type: "range",
              value: f.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: N[20] || (N[20] = (te) => q("trailLength", Number(te.target.value)))
            }, null, 40, Ak),
            v("span", Pk, ye(f.value.trailLength), 1)
          ])) : Te("", !0),
          v("div", kk, [
            v("label", null, [
              v("input", {
                type: "checkbox",
                checked: f.value.glowEnabled,
                onChange: N[21] || (N[21] = (te) => q("glowEnabled", te.target.checked))
              }, null, 40, Dk),
              N[109] || (N[109] = ct(" Enable Glow ", -1))
            ])
          ]),
          f.value.glowEnabled ? (se(), re("div", Ik, [
            N[110] || (N[110] = v("label", null, "Glow Radius", -1)),
            v("input", {
              type: "range",
              value: f.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: N[22] || (N[22] = (te) => q("glowRadius", Number(te.target.value)))
            }, null, 40, Rk),
            v("span", Lk, ye(f.value.glowRadius) + "px", 1)
          ])) : Te("", !0),
          f.value.glowEnabled ? (se(), re("div", Fk, [
            N[111] || (N[111] = v("label", null, "Glow Intensity", -1)),
            v("input", {
              type: "range",
              value: f.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: N[23] || (N[23] = (te) => q("glowIntensity", Number(te.target.value)))
            }, null, 40, Ok),
            v("span", Uk, ye(f.value.glowIntensity.toFixed(2)), 1)
          ])) : Te("", !0),
          N[118] || (N[118] = v("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          v("div", zk, [
            v("label", null, [
              v("input", {
                type: "checkbox",
                checked: g.value.enabled,
                onChange: N[24] || (N[24] = (te) => G("enabled", te.target.checked))
              }, null, 40, Bk),
              N[112] || (N[112] = ct(" Enable Connections ", -1))
            ])
          ]),
          g.value.enabled ? (se(), re("div", Nk, [
            N[113] || (N[113] = v("label", null, "Max Distance", -1)),
            v("input", {
              type: "range",
              value: g.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: N[25] || (N[25] = (te) => G("maxDistance", Number(te.target.value)))
            }, null, 40, Vk),
            v("span", Hk, ye(g.value.maxDistance) + "px", 1)
          ])) : Te("", !0),
          g.value.enabled ? (se(), re("div", Gk, [
            N[114] || (N[114] = v("label", null, "Max Connections", -1)),
            v("input", {
              type: "range",
              value: g.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: N[26] || (N[26] = (te) => G("maxConnections", Number(te.target.value)))
            }, null, 40, $k),
            v("span", Wk, ye(g.value.maxConnections), 1)
          ])) : Te("", !0),
          g.value.enabled ? (se(), re("div", jk, [
            N[115] || (N[115] = v("label", null, "Line Width", -1)),
            v("input", {
              type: "range",
              value: g.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: N[27] || (N[27] = (te) => G("lineWidth", Number(te.target.value)))
            }, null, 40, Xk),
            v("span", Yk, ye(g.value.lineWidth.toFixed(1)), 1)
          ])) : Te("", !0),
          g.value.enabled ? (se(), re("div", qk, [
            N[116] || (N[116] = v("label", null, "Line Opacity", -1)),
            v("input", {
              type: "range",
              value: g.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: N[28] || (N[28] = (te) => G("lineOpacity", Number(te.target.value)))
            }, null, 40, Zk),
            v("span", Kk, ye(g.value.lineOpacity.toFixed(2)), 1)
          ])) : Te("", !0),
          g.value.enabled ? (se(), re("div", Jk, [
            v("label", null, [
              v("input", {
                type: "checkbox",
                checked: g.value.fadeByDistance,
                onChange: N[29] || (N[29] = (te) => G("fadeByDistance", te.target.checked))
              }, null, 40, Qk),
              N[117] || (N[117] = ct(" Fade by Distance ", -1))
            ])
          ])) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", eD, [
        N[119] || (N[119] = v("i", { class: "pi pi-circle-fill" }, null, -1)),
        v("span", null, ye(x.value) + " particles", 1)
      ])
    ]));
  }
}), nD = /* @__PURE__ */ Vt(tD, [["__scopeId", "data-v-60b9bdc8"]]), iD = ["title"], sD = /* @__PURE__ */ Bt({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = un(), a = Re(() => n.property.animated ? n.property.keyframes.some((p) => p.frame === o.currentFrame) : !1), r = Re(() => n.property.animated && n.property.keyframes.find((p) => p.frame === o.currentFrame) || null), l = Re(() => a.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), c = Re(() => a.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function u() {
      a.value ? h() : d();
    }
    function d() {
      const p = { frame: 0, value: 0, enabled: !1 }, f = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: o.currentFrame,
        value: n.property.value,
        interpolation: "linear",
        inHandle: { ...p },
        outHandle: { ...p },
        controlMode: "smooth"
      };
      n.property.animated || (n.property.animated = !0, i("animationToggled", !0)), n.property.keyframes.push(f), n.property.keyframes.sort((m, y) => m.frame - y.frame), i("keyframeAdded", f);
    }
    function h() {
      const p = r.value;
      if (!p) return;
      const f = n.property.keyframes.findIndex((m) => m.id === p.id);
      f >= 0 && (n.property.keyframes.splice(f, 1), i("keyframeRemoved", p.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, i("animationToggled", !1));
    }
    return (p, f) => (se(), re("button", {
      class: Le(["keyframe-toggle", {
        animated: s.property.animated,
        "has-keyframe": a.value
      }]),
      onClick: u,
      title: c.value
    }, [
      v("i", {
        class: Le(["pi", l.value])
      }, null, 2)
    ], 10, iD));
  }
}), oo = /* @__PURE__ */ Vt(sD, [["__scopeId", "data-v-b9271c8f"]]), oD = { class: "depthflow-properties" }, aD = { class: "property-section" }, rD = {
  key: 0,
  class: "section-content"
}, lD = { class: "property-row" }, cD = ["value"], uD = ["value"], dD = { class: "property-row" }, hD = ["value"], fD = ["value"], pD = { class: "property-section" }, mD = {
  key: 0,
  class: "section-content"
}, vD = { class: "preset-grid" }, gD = ["onClick"], yD = {
  key: 0,
  class: "property-row"
}, xD = ["value"], bD = { class: "value-display" }, _D = { class: "property-section" }, wD = {
  key: 0,
  class: "section-content"
}, MD = { class: "property-row" }, SD = ["value"], CD = { class: "value-display" }, TD = { class: "property-row" }, ED = ["value"], AD = { class: "value-display" }, PD = { class: "property-row" }, kD = ["value"], DD = { class: "value-display" }, ID = { class: "property-row" }, RD = ["value"], LD = { class: "value-display" }, FD = { class: "property-section" }, OD = {
  key: 0,
  class: "section-content"
}, UD = { class: "property-row" }, zD = ["value"], BD = { class: "value-display" }, ND = { class: "property-row" }, VD = ["value"], HD = { class: "value-display" }, GD = {
  key: 0,
  class: "property-section"
}, $D = {
  key: 0,
  class: "section-content"
}, WD = { class: "property-row" }, jD = ["value"], XD = { class: "value-display" }, YD = { class: "property-row" }, qD = ["value"], ZD = { class: "value-display" }, KD = { class: "property-row" }, JD = ["value"], QD = { class: "value-display" }, eI = { class: "property-row" }, tI = ["value"], nI = { class: "value-display" }, iI = {
  key: 2,
  class: "property-row"
}, sI = ["value"], oI = { class: "value-display" }, aI = { class: "property-section" }, rI = {
  key: 0,
  class: "section-content"
}, lI = { class: "property-row" }, cI = ["value"], uI = { class: "value-display" }, dI = { class: "property-row checkbox-row" }, hI = ["checked"], fI = { class: "property-section" }, pI = {
  key: 0,
  class: "sync-badge"
}, mI = {
  key: 0,
  class: "section-content"
}, vI = { class: "property-row checkbox-row" }, gI = ["checked"], yI = { class: "property-row" }, xI = ["value"], bI = ["value"], _I = { class: "property-row" }, wI = ["value"], MI = { class: "value-display" }, SI = { class: "property-row" }, CI = ["value"], TI = { class: "value-display" }, EI = { class: "property-row" }, AI = ["value"], PI = { class: "value-display" }, kI = { class: "property-row" }, DI = ["value"], II = { class: "value-display" }, RI = { class: "property-row checkbox-row" }, LI = ["checked"], FI = { style: { "margin-left": "16px" } }, OI = ["checked"], UI = { class: "property-row" }, zI = ["value"], BI = { class: "value-display" }, NI = { class: "property-section" }, VI = {
  key: 0,
  class: "section-content"
}, HI = { class: "preview-container" }, GI = { class: "preview-controls" }, $I = { class: "frame-indicator" }, gs = 200, WI = /* @__PURE__ */ Bt({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = {
      sensitivityX: 0.5,
      sensitivityY: 0.5,
      sensitivityZ: 1e-3,
      sensitivityRotation: 1,
      baseZoom: 1,
      invertX: !1,
      invertY: !1,
      zoomClamp: { min: 0.5, max: 3 },
      offsetClamp: { min: -1, max: 1 }
    }, i = s, o = e, a = un(), r = xe(null), l = xe(!1), c = xe(0), u = xe(null), d = xe(/* @__PURE__ */ new Set(["source", "preset", "camera"])), h = xe(1), p = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], f = Re(() => i.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), m = Re(() => f.value.config), y = Re(() => a.frameCount), g = Re(
      () => a.layers.filter((q) => q.type === "image" || q.type === "generated")
    ), x = Re(
      () => a.layers.filter((q) => q.type === "depth" || q.type === "generated")
    ), w = Re(
      () => a.layers.filter((q) => q.type === "camera")
    ), M = Re(() => f.value.cameraSyncConfig ?? n), _ = Re(
      () => ["circle_cw", "circle_ccw"].includes(m.value.preset)
    ), C = Re(
      () => ["horizontal_swing", "vertical_swing"].includes(m.value.preset)
    ), T = Re(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(m.value.preset)
    ), P = Re(
      () => _.value || C.value || T.value
    ), E = Re(() => _.value ? "Orbit Settings" : C.value ? "Swing Settings" : T.value ? "Dolly Zoom Settings" : "Preset Settings");
    function b(q) {
      d.value.has(q) ? d.value.delete(q) : d.value.add(q);
    }
    function S(q, G) {
      o("update", { [q]: G });
    }
    function A(q, G) {
      o("update", {
        config: { ...m.value, [q]: G }
      });
    }
    function R(q) {
      A("preset", q);
    }
    function k(q, G) {
      o("update", {
        cameraSyncConfig: { ...M.value, [q]: G }
      });
    }
    function U(q) {
      h.value = q, _.value ? A("orbitRadius", 0.1 * q) : C.value ? A("swingAmplitude", 0.1 * q) : A("depthScale", 1 * q);
    }
    function I() {
      l.value = !l.value, l.value ? W() : u.value !== null && (cancelAnimationFrame(u.value), u.value = null);
    }
    function W() {
      l.value && (c.value = (c.value + 1) % y.value, fe(), u.value = requestAnimationFrame(() => {
        setTimeout(W, 1e3 / a.fps);
      }));
    }
    function fe() {
      const q = r.value;
      if (!q) return;
      const G = q.getContext("2d");
      G && (G.fillStyle = "#1e1e1e", G.fillRect(0, 0, gs, gs), G.fillStyle = "#333", G.fillRect(10, 10, gs - 20, gs - 20), G.fillStyle = "#666", G.font = "12px sans-serif", G.textAlign = "center", G.fillText("Depthflow Preview", gs / 2, gs / 2), G.fillText(`Frame ${c.value}`, gs / 2, gs / 2 + 16));
    }
    return gn(() => {
      fe();
    }), Un(() => {
      u.value !== null && cancelAnimationFrame(u.value);
    }), (q, G) => (se(), re("div", oD, [
      v("div", aD, [
        v("div", {
          class: "section-header",
          onClick: G[0] || (G[0] = (Q) => b("source"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          G[33] || (G[33] = v("span", null, "Source Selection", -1))
        ]),
        d.value.has("source") ? (se(), re("div", rD, [
          v("div", lD, [
            G[35] || (G[35] = v("label", null, "Source Layer", -1)),
            v("select", {
              value: f.value.sourceLayerId,
              onChange: G[1] || (G[1] = (Q) => S("sourceLayerId", Q.target.value))
            }, [
              G[34] || (G[34] = v("option", { value: "" }, "Select source...", -1)),
              (se(!0), re(Xe, null, at(g.value, (Q) => (se(), re("option", {
                key: Q.id,
                value: Q.id
              }, ye(Q.name), 9, uD))), 128))
            ], 40, cD)
          ]),
          v("div", dD, [
            G[37] || (G[37] = v("label", null, "Depth Layer", -1)),
            v("select", {
              value: f.value.depthLayerId,
              onChange: G[2] || (G[2] = (Q) => S("depthLayerId", Q.target.value))
            }, [
              G[36] || (G[36] = v("option", { value: "" }, "Select depth map...", -1)),
              (se(!0), re(Xe, null, at(x.value, (Q) => (se(), re("option", {
                key: Q.id,
                value: Q.id
              }, ye(Q.name), 9, fD))), 128))
            ], 40, hD)
          ])
        ])) : Te("", !0)
      ]),
      v("div", pD, [
        v("div", {
          class: "section-header",
          onClick: G[3] || (G[3] = (Q) => b("preset"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          G[38] || (G[38] = v("span", null, "Motion Preset", -1))
        ]),
        d.value.has("preset") ? (se(), re("div", mD, [
          v("div", vD, [
            (se(), re(Xe, null, at(p, (Q) => v("button", {
              key: Q.value,
              class: Le(["preset-btn", { active: m.value.preset === Q.value }]),
              onClick: (K) => R(Q.value)
            }, [
              v("i", {
                class: Le(Q.icon)
              }, null, 2),
              v("span", null, ye(Q.label), 1)
            ], 10, gD)), 64))
          ]),
          m.value.preset !== "static" ? (se(), re("div", yD, [
            G[39] || (G[39] = v("label", null, "Intensity", -1)),
            v("input", {
              type: "range",
              value: h.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: G[4] || (G[4] = (Q) => U(Number(Q.target.value)))
            }, null, 40, xD),
            v("span", bD, ye(h.value.toFixed(1)) + "x", 1)
          ])) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", _D, [
        v("div", {
          class: "section-header",
          onClick: G[5] || (G[5] = (Q) => b("camera"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          G[40] || (G[40] = v("span", null, "Camera Controls", -1))
        ]),
        d.value.has("camera") ? (se(), re("div", wD, [
          v("div", MD, [
            G[41] || (G[41] = v("label", null, "Zoom", -1)),
            f.value.animatedZoom ? (se(), Tt(oo, {
              key: 0,
              property: f.value.animatedZoom,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            v("input", {
              type: "range",
              value: m.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: G[6] || (G[6] = (Q) => A("zoom", Number(Q.target.value)))
            }, null, 40, SD),
            v("span", CD, ye(m.value.zoom.toFixed(2)), 1)
          ]),
          v("div", TD, [
            G[42] || (G[42] = v("label", null, "Offset X", -1)),
            f.value.animatedOffsetX ? (se(), Tt(oo, {
              key: 0,
              property: f.value.animatedOffsetX,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            v("input", {
              type: "range",
              value: m.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: G[7] || (G[7] = (Q) => A("offsetX", Number(Q.target.value)))
            }, null, 40, ED),
            v("span", AD, ye(m.value.offsetX.toFixed(2)), 1)
          ]),
          v("div", PD, [
            G[43] || (G[43] = v("label", null, "Offset Y", -1)),
            f.value.animatedOffsetY ? (se(), Tt(oo, {
              key: 0,
              property: f.value.animatedOffsetY,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            v("input", {
              type: "range",
              value: m.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: G[8] || (G[8] = (Q) => A("offsetY", Number(Q.target.value)))
            }, null, 40, kD),
            v("span", DD, ye(m.value.offsetY.toFixed(2)), 1)
          ]),
          v("div", ID, [
            G[44] || (G[44] = v("label", null, "Rotation", -1)),
            f.value.animatedRotation ? (se(), Tt(oo, {
              key: 0,
              property: f.value.animatedRotation,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            v("input", {
              type: "range",
              value: m.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: G[9] || (G[9] = (Q) => A("rotation", Number(Q.target.value)))
            }, null, 40, RD),
            v("span", LD, ye(m.value.rotation) + "", 1)
          ])
        ])) : Te("", !0)
      ]),
      v("div", FD, [
        v("div", {
          class: "section-header",
          onClick: G[10] || (G[10] = (Q) => b("depth"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          G[45] || (G[45] = v("span", null, "Depth Settings", -1))
        ]),
        d.value.has("depth") ? (se(), re("div", OD, [
          v("div", UD, [
            G[46] || (G[46] = v("label", null, "Depth Scale", -1)),
            f.value.animatedDepthScale ? (se(), Tt(oo, {
              key: 0,
              property: f.value.animatedDepthScale,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Te("", !0),
            v("input", {
              type: "range",
              value: m.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: G[11] || (G[11] = (Q) => A("depthScale", Number(Q.target.value)))
            }, null, 40, zD),
            v("span", BD, ye(m.value.depthScale.toFixed(2)), 1)
          ]),
          v("div", ND, [
            G[47] || (G[47] = v("label", null, "Focus Depth", -1)),
            v("input", {
              type: "range",
              value: m.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: G[12] || (G[12] = (Q) => A("focusDepth", Number(Q.target.value)))
            }, null, 40, VD),
            v("span", HD, ye(m.value.focusDepth.toFixed(2)), 1)
          ]),
          G[48] || (G[48] = v("div", { class: "depth-hint" }, [
            ct(" Objects at focus depth stay stationary."),
            v("br"),
            ct(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : Te("", !0)
      ]),
      P.value ? (se(), re("div", GD, [
        v("div", {
          class: "section-header",
          onClick: G[13] || (G[13] = (Q) => b("presetSettings"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          v("span", null, ye(E.value), 1)
        ]),
        d.value.has("presetSettings") ? (se(), re("div", $D, [
          _.value ? (se(), re(Xe, { key: 0 }, [
            v("div", WD, [
              G[49] || (G[49] = v("label", null, "Orbit Radius", -1)),
              v("input", {
                type: "range",
                value: m.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: G[14] || (G[14] = (Q) => A("orbitRadius", Number(Q.target.value)))
              }, null, 40, jD),
              v("span", XD, ye(m.value.orbitRadius.toFixed(2)), 1)
            ]),
            v("div", YD, [
              G[50] || (G[50] = v("label", null, "Orbit Speed", -1)),
              v("input", {
                type: "range",
                value: m.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: G[15] || (G[15] = (Q) => A("orbitSpeed", Number(Q.target.value)))
              }, null, 40, qD),
              v("span", ZD, ye(m.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : Te("", !0),
          C.value ? (se(), re(Xe, { key: 1 }, [
            v("div", KD, [
              G[51] || (G[51] = v("label", null, "Amplitude", -1)),
              v("input", {
                type: "range",
                value: m.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: G[16] || (G[16] = (Q) => A("swingAmplitude", Number(Q.target.value)))
              }, null, 40, JD),
              v("span", QD, ye(m.value.swingAmplitude.toFixed(2)), 1)
            ]),
            v("div", eI, [
              G[52] || (G[52] = v("label", null, "Frequency", -1)),
              v("input", {
                type: "range",
                value: m.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: G[17] || (G[17] = (Q) => A("swingFrequency", Number(Q.target.value)))
              }, null, 40, tI),
              v("span", nI, ye(m.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : Te("", !0),
          T.value ? (se(), re("div", iI, [
            G[53] || (G[53] = v("label", null, "Dolly Rate", -1)),
            v("input", {
              type: "range",
              value: m.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: G[18] || (G[18] = (Q) => A("dollyZoom", Number(Q.target.value)))
            }, null, 40, sI),
            v("span", oI, ye(m.value.dollyZoom.toFixed(2)), 1)
          ])) : Te("", !0)
        ])) : Te("", !0)
      ])) : Te("", !0),
      v("div", aI, [
        v("div", {
          class: "section-header",
          onClick: G[19] || (G[19] = (Q) => b("quality"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          G[54] || (G[54] = v("span", null, "Quality", -1))
        ]),
        d.value.has("quality") ? (se(), re("div", rI, [
          v("div", lI, [
            G[55] || (G[55] = v("label", null, "Edge Dilation", -1)),
            v("input", {
              type: "range",
              value: m.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: G[20] || (G[20] = (Q) => A("edgeDilation", Number(Q.target.value)))
            }, null, 40, cI),
            v("span", uI, ye(m.value.edgeDilation) + "px", 1)
          ]),
          v("div", dI, [
            v("label", null, [
              v("input", {
                type: "checkbox",
                checked: m.value.inpaintEdges,
                onChange: G[21] || (G[21] = (Q) => A("inpaintEdges", Q.target.checked))
              }, null, 40, hI),
              G[56] || (G[56] = ct(" Inpaint Edges ", -1))
            ])
          ])
        ])) : Te("", !0)
      ]),
      v("div", fI, [
        v("div", {
          class: "section-header",
          onClick: G[22] || (G[22] = (Q) => b("cameraSync"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("cameraSync") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          G[57] || (G[57] = v("span", null, "Camera Sync", -1)),
          f.value.cameraSyncEnabled ? (se(), re("span", pI, "Active")) : Te("", !0)
        ]),
        d.value.has("cameraSync") ? (se(), re("div", mI, [
          v("div", vI, [
            v("label", null, [
              v("input", {
                type: "checkbox",
                checked: f.value.cameraSyncEnabled ?? !1,
                onChange: G[23] || (G[23] = (Q) => S("cameraSyncEnabled", Q.target.checked))
              }, null, 40, gI),
              G[58] || (G[58] = ct(" Enable Camera Sync ", -1))
            ])
          ]),
          f.value.cameraSyncEnabled ? (se(), re(Xe, { key: 0 }, [
            v("div", yI, [
              G[60] || (G[60] = v("label", null, "Camera Layer", -1)),
              v("select", {
                value: f.value.cameraSyncLayerId ?? "",
                onChange: G[24] || (G[24] = (Q) => S("cameraSyncLayerId", Q.target.value))
              }, [
                G[59] || (G[59] = v("option", { value: "" }, "Select camera...", -1)),
                (se(!0), re(Xe, null, at(w.value, (Q) => (se(), re("option", {
                  key: Q.id,
                  value: Q.id
                }, ye(Q.name), 9, bI))), 128))
              ], 40, xI)
            ]),
            G[68] || (G[68] = v("div", { class: "sync-hint" }, " Camera movement will drive parallax. Adjust sensitivity below. ", -1)),
            v("div", _I, [
              G[61] || (G[61] = v("label", null, "X Sensitivity", -1)),
              v("input", {
                type: "range",
                value: M.value.sensitivityX,
                min: "0",
                max: "2",
                step: "0.05",
                onInput: G[25] || (G[25] = (Q) => k("sensitivityX", Number(Q.target.value)))
              }, null, 40, wI),
              v("span", MI, ye(M.value.sensitivityX.toFixed(2)), 1)
            ]),
            v("div", SI, [
              G[62] || (G[62] = v("label", null, "Y Sensitivity", -1)),
              v("input", {
                type: "range",
                value: M.value.sensitivityY,
                min: "0",
                max: "2",
                step: "0.05",
                onInput: G[26] || (G[26] = (Q) => k("sensitivityY", Number(Q.target.value)))
              }, null, 40, CI),
              v("span", TI, ye(M.value.sensitivityY.toFixed(2)), 1)
            ]),
            v("div", EI, [
              G[63] || (G[63] = v("label", null, "Z Sensitivity", -1)),
              v("input", {
                type: "range",
                value: M.value.sensitivityZ * 1e3,
                min: "0",
                max: "10",
                step: "0.1",
                onInput: G[27] || (G[27] = (Q) => k("sensitivityZ", Number(Q.target.value) / 1e3))
              }, null, 40, AI),
              v("span", PI, ye((M.value.sensitivityZ * 1e3).toFixed(1)), 1)
            ]),
            v("div", kI, [
              G[64] || (G[64] = v("label", null, "Rotation Sens.", -1)),
              v("input", {
                type: "range",
                value: M.value.sensitivityRotation,
                min: "0",
                max: "2",
                step: "0.05",
                onInput: G[28] || (G[28] = (Q) => k("sensitivityRotation", Number(Q.target.value)))
              }, null, 40, DI),
              v("span", II, ye(M.value.sensitivityRotation.toFixed(2)), 1)
            ]),
            v("div", RI, [
              v("label", null, [
                v("input", {
                  type: "checkbox",
                  checked: M.value.invertX,
                  onChange: G[29] || (G[29] = (Q) => k("invertX", Q.target.checked))
                }, null, 40, LI),
                G[65] || (G[65] = ct(" Invert X ", -1))
              ]),
              v("label", FI, [
                v("input", {
                  type: "checkbox",
                  checked: M.value.invertY,
                  onChange: G[30] || (G[30] = (Q) => k("invertY", Q.target.checked))
                }, null, 40, OI),
                G[66] || (G[66] = ct(" Invert Y ", -1))
              ])
            ]),
            v("div", UI, [
              G[67] || (G[67] = v("label", null, "Base Zoom", -1)),
              v("input", {
                type: "range",
                value: M.value.baseZoom,
                min: "0.5",
                max: "2",
                step: "0.05",
                onInput: G[31] || (G[31] = (Q) => k("baseZoom", Number(Q.target.value)))
              }, null, 40, zI),
              v("span", BI, ye(M.value.baseZoom.toFixed(2)), 1)
            ])
          ], 64)) : Te("", !0)
        ])) : Te("", !0)
      ]),
      v("div", NI, [
        v("div", {
          class: "section-header",
          onClick: G[32] || (G[32] = (Q) => b("preview"))
        }, [
          v("i", {
            class: Le(["pi", d.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          G[69] || (G[69] = v("span", null, "Preview", -1))
        ]),
        d.value.has("preview") ? (se(), re("div", VI, [
          v("div", HI, [
            v("canvas", {
              ref_key: "previewCanvas",
              ref: r,
              class: "preview-canvas",
              width: gs,
              height: gs
            }, null, 512)
          ]),
          v("div", GI, [
            v("button", {
              class: Le(["preview-btn", { active: l.value }]),
              onClick: I
            }, [
              v("i", {
                class: Le(l.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              ct(" " + ye(l.value ? "Pause" : "Play"), 1)
            ], 2),
            v("span", $I, " Frame " + ye(c.value) + " / " + ye(y.value - 1), 1)
          ])
        ])) : Te("", !0)
      ])
    ]));
  }
}), jI = /* @__PURE__ */ Vt(WI, [["__scopeId", "data-v-fe3d8389"]]), XI = { class: "light-properties" }, YI = { class: "property-section" }, qI = { class: "section-content" }, ZI = { class: "property-row" }, KI = ["value"], JI = { class: "property-group" }, QI = { class: "property-group" }, eR = { class: "control-row" }, tR = { class: "property-group" }, nR = { class: "control-row" }, iR = { class: "property-group" }, sR = {
  key: 1,
  class: "property-row"
}, oR = ["value"], aR = {
  key: 2,
  class: "property-group"
}, rR = {
  key: 3,
  class: "property-group"
}, lR = { class: "property-group checkbox-row" }, cR = ["checked"], uR = { class: "property-group" }, dR = { class: "property-group" }, hR = {
  key: 5,
  class: "note"
}, fR = /* @__PURE__ */ Bt({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = un(), a = Re(() => n.layer.data || {
      lightType: "spot",
      color: "#ffffff",
      intensity: 100,
      radius: 500,
      falloff: "none",
      falloffDistance: 500,
      castShadows: !1,
      shadowDarkness: 100,
      shadowDiffusion: 0,
      coneAngle: 90,
      coneFeather: 50
    });
    function r(l, c) {
      o.updateLayer(n.layer.id, {
        data: { ...a.value, [l]: c }
      }), i("update");
    }
    return (l, c) => (se(), re("div", XI, [
      v("div", YI, [
        c[25] || (c[25] = v("div", { class: "section-header" }, "Light Settings", -1)),
        v("div", qI, [
          v("div", ZI, [
            c[13] || (c[13] = v("label", null, "Type", -1)),
            v("select", {
              value: a.value.lightType,
              onChange: c[0] || (c[0] = (u) => r("lightType", u.target.value)),
              class: "type-select"
            }, [...c[12] || (c[12] = [
              v("option", { value: "parallel" }, "Parallel", -1),
              v("option", { value: "spot" }, "Spot", -1),
              v("option", { value: "point" }, "Point", -1),
              v("option", { value: "ambient" }, "Ambient", -1)
            ])], 40, KI)
          ]),
          v("div", JI, [
            c[14] || (c[14] = v("label", null, "Color", -1)),
            Ne(He(Wc), {
              modelValue: a.value.color,
              "onUpdate:modelValue": c[1] || (c[1] = (u) => r("color", u))
            }, null, 8, ["modelValue"])
          ]),
          v("div", QI, [
            c[15] || (c[15] = v("label", null, "Intensity", -1)),
            v("div", eR, [
              Ne(He(ti), {
                modelValue: a.value.intensity,
                "onUpdate:modelValue": c[2] || (c[2] = (u) => r("intensity", u)),
                min: 0,
                max: 500,
                step: 1,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ]),
          a.value.lightType === "spot" ? (se(), re(Xe, { key: 0 }, [
            v("div", tR, [
              c[16] || (c[16] = v("label", null, "Cone Angle", -1)),
              v("div", nR, [
                Ne(He(jh), {
                  modelValue: a.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[3] || (c[3] = (u) => r("coneAngle", u)),
                  size: 32
                }, null, 8, ["modelValue"]),
                Ne(He(it), {
                  modelValue: a.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[4] || (c[4] = (u) => r("coneAngle", u)),
                  unit: ""
                }, null, 8, ["modelValue"])
              ])
            ]),
            v("div", iR, [
              c[17] || (c[17] = v("label", null, "Cone Feather", -1)),
              Ne(He(ti), {
                modelValue: a.value.coneFeather ?? 50,
                "onUpdate:modelValue": c[5] || (c[5] = (u) => r("coneFeather", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Te("", !0),
          a.value.lightType !== "ambient" ? (se(), re("div", sR, [
            c[19] || (c[19] = v("label", null, "Falloff", -1)),
            v("select", {
              value: a.value.falloff,
              onChange: c[6] || (c[6] = (u) => r("falloff", u.target.value)),
              class: "type-select"
            }, [...c[18] || (c[18] = [
              v("option", { value: "none" }, "None", -1),
              v("option", { value: "smooth" }, "Smooth", -1),
              v("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
            ])], 40, oR)
          ])) : Te("", !0),
          a.value.lightType !== "ambient" && a.value.lightType !== "parallel" ? (se(), re("div", aR, [
            c[20] || (c[20] = v("label", null, "Radius", -1)),
            Ne(He(it), {
              modelValue: a.value.radius,
              "onUpdate:modelValue": c[7] || (c[7] = (u) => r("radius", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Te("", !0),
          a.value.lightType !== "ambient" ? (se(), re("div", rR, [
            c[21] || (c[21] = v("label", null, "Falloff Distance", -1)),
            Ne(He(it), {
              modelValue: a.value.falloffDistance ?? 500,
              "onUpdate:modelValue": c[8] || (c[8] = (u) => r("falloffDistance", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Te("", !0),
          v("div", lR, [
            v("label", null, [
              v("input", {
                type: "checkbox",
                checked: a.value.castShadows,
                onChange: c[9] || (c[9] = (u) => r("castShadows", u.target.checked))
              }, null, 40, cR),
              c[22] || (c[22] = ct(" Casts Shadows ", -1))
            ])
          ]),
          a.value.castShadows ? (se(), re(Xe, { key: 4 }, [
            v("div", uR, [
              c[23] || (c[23] = v("label", null, "Shadow Darkness", -1)),
              Ne(He(ti), {
                modelValue: a.value.shadowDarkness ?? 100,
                "onUpdate:modelValue": c[10] || (c[10] = (u) => r("shadowDarkness", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            v("div", dR, [
              c[24] || (c[24] = v("label", null, "Shadow Diffusion", -1)),
              Ne(He(it), {
                modelValue: a.value.shadowDiffusion ?? 0,
                "onUpdate:modelValue": c[11] || (c[11] = (u) => r("shadowDiffusion", u)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Te("", !0),
          a.value.castShadows ? (se(), re("div", hR, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : Te("", !0)
        ])
      ])
    ]));
  }
}), pR = /* @__PURE__ */ Vt(fR, [["__scopeId", "data-v-7bf0f1bf"]]), mR = { class: "shape-properties" }, vR = { class: "property-section" }, gR = { class: "section-content" }, yR = { class: "property-group" }, xR = { class: "group-header" }, bR = ["checked"], _R = {
  key: 0,
  class: "control-row"
}, wR = { class: "property-group" }, MR = { class: "group-header" }, SR = ["checked"], CR = {
  key: 0,
  class: "stroke-controls"
}, TR = { class: "control-row" }, ER = { class: "property-row" }, AR = { class: "property-row" }, PR = { class: "icon-toggle-group" }, kR = { class: "property-group" }, DR = { class: "control-row checkbox-row" }, IR = ["checked"], RR = /* @__PURE__ */ Bt({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = un(), a = Re(() => n.layer.data || {
      pathData: "",
      controlPoints: [],
      closed: !1,
      stroke: "#ffffff",
      strokeWidth: 2,
      fill: ""
    }), r = Re(() => !!a.value.fill && a.value.fill !== "transparent"), l = Re(() => !!a.value.stroke && a.value.strokeWidth > 0), c = Re(() => a.value.strokeLineCap || "round");
    function u(p, f) {
      o.updateLayer(n.layer.id, {
        data: { ...a.value, [p]: f }
      }), i("update");
    }
    function d(p) {
      const f = p.target.checked;
      u("fill", f ? "#ffffff" : "");
    }
    function h(p) {
      p.target.checked ? (u("stroke", "#ffffff"), u("strokeWidth", 2)) : u("strokeWidth", 0);
    }
    return (p, f) => (se(), re("div", mR, [
      v("div", vR, [
        f[13] || (f[13] = v("div", { class: "section-header" }, "Shape Appearance", -1)),
        v("div", gR, [
          v("div", yR, [
            v("div", xR, [
              f[7] || (f[7] = v("label", null, "Fill", -1)),
              v("input", {
                type: "checkbox",
                checked: r.value,
                onChange: d
              }, null, 40, bR)
            ]),
            r.value ? (se(), re("div", _R, [
              Ne(He(Wc), {
                modelValue: a.value.fill || "#ffffff",
                "onUpdate:modelValue": f[0] || (f[0] = (m) => u("fill", m)),
                alpha: !0
              }, null, 8, ["modelValue"])
            ])) : Te("", !0)
          ]),
          v("div", wR, [
            v("div", MR, [
              f[8] || (f[8] = v("label", null, "Stroke", -1)),
              v("input", {
                type: "checkbox",
                checked: l.value,
                onChange: h
              }, null, 40, SR)
            ]),
            l.value ? (se(), re("div", CR, [
              v("div", TR, [
                Ne(He(Wc), {
                  modelValue: a.value.stroke || "#ffffff",
                  "onUpdate:modelValue": f[1] || (f[1] = (m) => u("stroke", m)),
                  alpha: !0
                }, null, 8, ["modelValue"])
              ]),
              v("div", ER, [
                f[9] || (f[9] = v("label", { class: "sub-label" }, "Width", -1)),
                Ne(He(it), {
                  modelValue: a.value.strokeWidth || 0,
                  "onUpdate:modelValue": f[2] || (f[2] = (m) => u("strokeWidth", m)),
                  min: 0,
                  max: 500,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              v("div", AR, [
                f[10] || (f[10] = v("label", { class: "sub-label" }, "Cap", -1)),
                v("div", PR, [
                  v("button", {
                    class: Le({ active: c.value === "butt" }),
                    onClick: f[3] || (f[3] = (m) => u("strokeLineCap", "butt")),
                    title: "Butt Cap"
                  }, "I", 2),
                  v("button", {
                    class: Le({ active: c.value === "round" }),
                    onClick: f[4] || (f[4] = (m) => u("strokeLineCap", "round")),
                    title: "Round Cap"
                  }, "C", 2),
                  v("button", {
                    class: Le({ active: c.value === "square" }),
                    onClick: f[5] || (f[5] = (m) => u("strokeLineCap", "square")),
                    title: "Square Cap"
                  }, "H", 2)
                ])
              ])
            ])) : Te("", !0)
          ]),
          v("div", kR, [
            f[12] || (f[12] = v("label", null, "Path", -1)),
            v("div", DR, [
              v("label", null, [
                v("input", {
                  type: "checkbox",
                  checked: a.value.closed,
                  onChange: f[6] || (f[6] = (m) => u("closed", m.target.checked))
                }, null, 40, IR),
                f[11] || (f[11] = ct(" Closed Path ", -1))
              ])
            ])
          ])
        ])
      ])
    ]));
  }
}), LR = /* @__PURE__ */ Vt(RR, [["__scopeId", "data-v-e2af8c92"]]), FR = { class: "video-properties" }, OR = {
  key: 0,
  class: "property-section"
}, UR = { class: "section-content info-grid" }, zR = { class: "info-row" }, BR = { class: "info-value" }, NR = { class: "info-row" }, VR = { class: "info-value" }, HR = { class: "info-row" }, GR = { class: "info-value" }, $R = { class: "info-row" }, WR = { class: "info-value" }, jR = { class: "property-section" }, XR = { class: "section-content" }, YR = { class: "property-row" }, qR = { class: "property-row" }, ZR = { class: "property-row" }, KR = { class: "checkbox-group" }, JR = { class: "checkbox-row" }, QR = ["checked"], eL = { class: "checkbox-row" }, tL = ["checked"], nL = { class: "property-section" }, iL = { class: "section-header" }, sL = { class: "header-toggle" }, oL = ["checked"], aL = {
  key: 0,
  class: "section-content"
}, rL = { class: "property-row" }, lL = { class: "control-with-keyframe" }, cL = { class: "property-section" }, uL = { class: "section-content" }, dL = { class: "property-row" }, hL = ["value"], fL = {
  key: 1,
  class: "property-section"
}, pL = { class: "section-content" }, mL = { class: "checkbox-group" }, vL = { class: "checkbox-row" }, gL = ["checked"], yL = {
  key: 0,
  class: "property-row"
}, xL = { class: "control-with-keyframe" }, bL = {
  key: 1,
  class: "property-row"
}, _L = {
  key: 2,
  class: "waveform-container"
}, wL = /* @__PURE__ */ Bt({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = un(), a = Re(() => n.layer.data || {
      assetId: null,
      loop: !1,
      pingPong: !1,
      startTime: 0,
      endTime: void 0,
      speed: 1,
      timeRemapEnabled: !1,
      timeRemap: void 0,
      frameBlending: "none",
      audioEnabled: !0,
      audioLevel: 100,
      posterFrame: 0
    }), r = Re(() => {
      const C = a.value.assetId;
      return C && o.assets[C] || null;
    }), l = Re(() => {
      var C;
      return (C = n.layer.audio) == null ? void 0 : C.level;
    }), c = Re(() => a.value.timeRemap ? a.value.timeRemap.value : 0);
    function u(C) {
      var b;
      if (!C) return "0:00";
      const T = Math.floor(C / 60), P = Math.floor(C % 60), E = Math.floor(C % 1 * (((b = r.value) == null ? void 0 : b.fps) || 30));
      return `${T}:${P.toString().padStart(2, "0")}:${E.toString().padStart(2, "0")}`;
    }
    function d(C) {
      o.updateVideoLayerData(n.layer.id, { speed: C }), i("update");
    }
    function h(C) {
      o.updateVideoLayerData(n.layer.id, { startTime: C }), i("update");
    }
    function p(C) {
      o.updateVideoLayerData(n.layer.id, { endTime: C }), i("update");
    }
    function f(C) {
      const T = C.target;
      o.updateVideoLayerData(n.layer.id, { loop: T.checked }), i("update");
    }
    function m(C) {
      const T = C.target;
      o.updateVideoLayerData(n.layer.id, { pingPong: T.checked }), i("update");
    }
    function y(C) {
      const T = C.target;
      o.updateVideoLayerData(n.layer.id, { timeRemapEnabled: T.checked }), i("update");
    }
    function g(C) {
      const T = n.layer.data;
      T.timeRemap && (T.timeRemap.value = C), i("update");
    }
    function x(C) {
      const T = C.target;
      o.updateVideoLayerData(n.layer.id, { frameBlending: T.value }), i("update");
    }
    function w(C) {
      const T = C.target;
      o.updateVideoLayerData(n.layer.id, { audioEnabled: T.checked }), i("update");
    }
    function M(C) {
      o.updateVideoLayerData(n.layer.id, { audioLevel: C }), i("update");
    }
    function _(C) {
      var T;
      (T = n.layer.audio) != null && T.level && (n.layer.audio.level.value = C, i("update"));
    }
    return (C, T) => {
      var P, E, b;
      return se(), re("div", FR, [
        r.value ? (se(), re("div", OR, [
          T[4] || (T[4] = v("div", { class: "section-header" }, "Video Info", -1)),
          v("div", UR, [
            v("div", zR, [
              T[0] || (T[0] = v("span", { class: "info-label" }, "Dimensions", -1)),
              v("span", BR, ye(r.value.width) + "  " + ye(r.value.height), 1)
            ]),
            v("div", NR, [
              T[1] || (T[1] = v("span", { class: "info-label" }, "Duration", -1)),
              v("span", VR, ye(u(r.value.duration)), 1)
            ]),
            v("div", HR, [
              T[2] || (T[2] = v("span", { class: "info-label" }, "Frame Rate", -1)),
              v("span", GR, ye(((P = r.value.fps) == null ? void 0 : P.toFixed(2)) || "?") + " fps", 1)
            ]),
            v("div", $R, [
              T[3] || (T[3] = v("span", { class: "info-label" }, "Has Audio", -1)),
              v("span", WR, ye(r.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : Te("", !0),
        v("div", jR, [
          T[10] || (T[10] = v("div", { class: "section-header" }, "Playback", -1)),
          v("div", XR, [
            v("div", YR, [
              T[5] || (T[5] = v("label", null, "Speed", -1)),
              Ne(He(it), {
                modelValue: a.value.speed,
                "onUpdate:modelValue": d,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            v("div", qR, [
              T[6] || (T[6] = v("label", null, "Start Time", -1)),
              Ne(He(it), {
                modelValue: a.value.startTime,
                "onUpdate:modelValue": h,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            v("div", ZR, [
              T[7] || (T[7] = v("label", null, "End Time", -1)),
              Ne(He(it), {
                modelValue: a.value.endTime || ((E = r.value) == null ? void 0 : E.duration) || 0,
                "onUpdate:modelValue": p,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            v("div", KR, [
              v("label", JR, [
                v("input", {
                  type: "checkbox",
                  checked: a.value.loop,
                  onChange: f
                }, null, 40, QR),
                T[8] || (T[8] = v("span", null, "Loop", -1))
              ]),
              v("label", eL, [
                v("input", {
                  type: "checkbox",
                  checked: a.value.pingPong,
                  onChange: m
                }, null, 40, tL),
                T[9] || (T[9] = v("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        v("div", nL, [
          v("div", iL, [
            T[11] || (T[11] = v("span", null, "Time Remap", -1)),
            v("label", sL, [
              v("input", {
                type: "checkbox",
                checked: a.value.timeRemapEnabled,
                onChange: y
              }, null, 40, oL)
            ])
          ]),
          a.value.timeRemapEnabled ? (se(), re("div", aL, [
            v("div", rL, [
              T[12] || (T[12] = v("label", null, "Remap Time", -1)),
              v("div", lL, [
                Ne(He(it), {
                  modelValue: c.value,
                  "onUpdate:modelValue": g,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                a.value.timeRemap ? (se(), Tt(oo, {
                  key: 0,
                  property: a.value.timeRemap,
                  layerId: s.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : Te("", !0)
              ])
            ]),
            T[13] || (T[13] = v("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : Te("", !0)
        ]),
        v("div", cL, [
          T[16] || (T[16] = v("div", { class: "section-header" }, "Frame Blending", -1)),
          v("div", uL, [
            v("div", dL, [
              T[15] || (T[15] = v("label", null, "Mode", -1)),
              v("select", {
                value: a.value.frameBlending,
                onChange: x,
                class: "select-input"
              }, [...T[14] || (T[14] = [
                v("option", { value: "none" }, "None", -1),
                v("option", { value: "frame-mix" }, "Frame Mix", -1),
                v("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, hL)
            ])
          ])
        ]),
        ((b = r.value) == null ? void 0 : b.hasAudio) !== !1 ? (se(), re("div", fL, [
          T[21] || (T[21] = v("div", { class: "section-header" }, "Audio", -1)),
          v("div", pL, [
            v("div", mL, [
              v("label", vL, [
                v("input", {
                  type: "checkbox",
                  checked: a.value.audioEnabled,
                  onChange: w
                }, null, 40, gL),
                T[17] || (T[17] = v("span", null, "Audio Enabled", -1))
              ])
            ]),
            a.value.audioEnabled ? (se(), re("div", yL, [
              T[18] || (T[18] = v("label", null, "Level", -1)),
              v("div", xL, [
                l.value ? (se(), Tt(He(it), {
                  key: 0,
                  modelValue: l.value.value,
                  "onUpdate:modelValue": _,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : Te("", !0),
                l.value ? (se(), Tt(oo, {
                  key: 1,
                  property: l.value,
                  layerId: s.layer.id
                }, null, 8, ["property", "layerId"])) : Te("", !0)
              ])
            ])) : Te("", !0),
            a.value.audioEnabled ? (se(), re("div", bL, [
              T[19] || (T[19] = v("label", null, "Volume", -1)),
              Ne(He(it), {
                modelValue: a.value.audioLevel,
                "onUpdate:modelValue": M,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : Te("", !0),
            a.value.audioEnabled ? (se(), re("div", _L, [...T[20] || (T[20] = [
              v("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : Te("", !0)
          ])
        ])) : Te("", !0)
      ]);
    };
  }
}), ML = /* @__PURE__ */ Vt(wL, [["__scopeId", "data-v-5f46759a"]]), SL = ["title"], CL = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
}, TL = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, EL = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, AL = ["x1", "y1", "x2", "y2"], PL = ["cx", "cy"], kL = { class: "drop-label" }, DL = /* @__PURE__ */ Bt({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = xe(null), a = xe(!1), r = xe({ x: 0, y: 0 }), l = xe({ x: 0, y: 0 }), c = xe(null), u = Re(() => !!n.linkedTo), d = Re(() => n.linkedTo ? `${n.linkedTo.layerId}.${n.linkedTo.property}` : ""), h = Re(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    })), p = Re(() => {
      if (!c.value) return {};
      const _ = c.value.rect;
      return {
        position: "fixed",
        top: `${_.top}px`,
        left: `${_.left}px`,
        width: `${_.width}px`,
        height: `${_.height}px`,
        zIndex: 9999
      };
    });
    function f() {
      const _ = [];
      return document.querySelectorAll("[data-pickwhip-target]").forEach((T) => {
        const P = T, E = P.dataset.pickwhipLayerId, b = P.dataset.pickwhipTarget, S = P.dataset.pickwhipLabel || b;
        E === n.layerId && b === n.property || E && b && _.push({
          layerId: E,
          property: b,
          label: S,
          element: P,
          rect: P.getBoundingClientRect()
        });
      }), _;
    }
    function m(_, C, T) {
      for (const P of T) {
        const E = P.rect;
        if (_ >= E.left && _ <= E.right && C >= E.top && C <= E.bottom)
          return P;
      }
      return null;
    }
    let y = [];
    function g(_) {
      var E;
      _.preventDefault(), _.stopPropagation();
      const C = "touches" in _ ? _.touches[0].clientX : _.clientX, T = "touches" in _ ? _.touches[0].clientY : _.clientY, P = (E = o.value) == null ? void 0 : E.getBoundingClientRect();
      P ? r.value = { x: P.left + P.width / 2, y: P.top + P.height / 2 } : r.value = { x: C, y: T }, l.value = { x: C, y: T }, a.value = !0, y = f(), window.addEventListener("mousemove", x), window.addEventListener("mouseup", w), window.addEventListener("touchmove", x), window.addEventListener("touchend", w);
    }
    function x(_) {
      if (!a.value) return;
      const C = "touches" in _ ? _.touches[0].clientX : _.clientX, T = "touches" in _ ? _.touches[0].clientY : _.clientY;
      l.value = { x: C, y: T }, y.forEach((P) => {
        P.rect = P.element.getBoundingClientRect();
      }), c.value = m(C, T, y);
    }
    function w(_) {
      if (!a.value) return;
      const C = "changedTouches" in _ ? _.changedTouches[0].clientX : _.clientX, T = "changedTouches" in _ ? _.changedTouches[0].clientY : _.clientY, P = m(C, T, y);
      P && i("link", { layerId: P.layerId, property: P.property }), a.value = !1, c.value = null, y = [], window.removeEventListener("mousemove", x), window.removeEventListener("mouseup", w), window.removeEventListener("touchmove", x), window.removeEventListener("touchend", w);
    }
    function M() {
      i("unlink");
    }
    return Un(() => {
      window.removeEventListener("mousemove", x), window.removeEventListener("mouseup", w), window.removeEventListener("touchmove", x), window.removeEventListener("touchend", w);
    }), (_, C) => (se(), re("div", {
      class: "pickwhip-container",
      ref_key: "containerRef",
      ref: o
    }, [
      v("div", {
        class: Le(["pickwhip-handle", { dragging: a.value, linked: u.value }]),
        onMousedown: g,
        onTouchstart: _t(g, ["prevent"]),
        title: u.value ? `Linked to: ${d.value}` : "Drag to link property"
      }, [
        (se(), re("svg", CL, [
          C[0] || (C[0] = v("circle", {
            cx: "8",
            cy: "8",
            r: "3",
            fill: "currentColor"
          }, null, -1)),
          u.value ? (se(), re("path", EL)) : (se(), re("path", TL))
        ]))
      ], 42, SL),
      u.value ? (se(), re("button", {
        key: 0,
        class: "clear-link-btn",
        onClick: M,
        title: "Remove link"
      }, "  ")) : Te("", !0),
      (se(), Tt(R0, { to: "body" }, [
        a.value ? (se(), re("svg", {
          key: 0,
          class: "pickwhip-line",
          style: xt(h.value)
        }, [
          v("line", {
            x1: r.value.x,
            y1: r.value.y,
            x2: l.value.x,
            y2: l.value.y,
            stroke: "#4a90d9",
            "stroke-width": "2",
            "stroke-dasharray": "4 2"
          }, null, 8, AL),
          v("circle", {
            cx: l.value.x,
            cy: l.value.y,
            r: "6",
            fill: "#4a90d9",
            stroke: "#fff",
            "stroke-width": "1"
          }, null, 8, PL)
        ], 4)) : Te("", !0)
      ])),
      (se(), Tt(R0, { to: "body" }, [
        a.value && c.value ? (se(), re("div", {
          key: 0,
          class: "drop-target-highlight",
          style: xt(p.value)
        }, [
          v("span", kL, ye(c.value.label), 1)
        ], 4)) : Te("", !0)
      ]))
    ], 512));
  }
}), Hl = /* @__PURE__ */ Vt(DL, [["__scopeId", "data-v-da1938e3"]]), IL = {
  key: 0,
  class: "driver-list"
}, RL = { class: "expand-icon" }, LL = { class: "count" }, FL = {
  key: 0,
  class: "driver-items"
}, OL = { class: "driver-header" }, UL = ["onClick"], zL = { class: "driver-info" }, BL = { class: "target" }, NL = {
  key: 0,
  class: "source"
}, VL = {
  key: 1,
  class: "source audio"
}, HL = {
  key: 2,
  class: "source time"
}, GL = ["onClick"], $L = {
  key: 0,
  class: "driver-transforms"
}, WL = ["title"], jL = {
  key: 1,
  class: "add-driver-section"
}, XL = {
  key: 0,
  class: "add-menu"
}, YL = { class: "menu-section" }, qL = { class: "menu-section" }, ZL = { class: "menu-section" }, KL = { class: "menu-section" }, JL = { class: "menu-actions" }, QL = /* @__PURE__ */ Bt({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(s) {
    const e = s, n = un(), i = xe(!0), o = xe(!1), a = xe({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    }), r = Re(() => n.getDriversForLayer(e.layerId));
    function l(f) {
      return f ? {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        opacity: "Opacity"
      }[f] || f : "?";
    }
    function c(f) {
      if (!f) return "?";
      const m = n.layers.find((y) => y.id === f);
      return (m == null ? void 0 : m.name) || f.slice(0, 8);
    }
    function u(f) {
      switch (f.type) {
        case "scale":
          return `Scale: ${f.factor}`;
        case "offset":
          return `Offset: ${f.amount}`;
        case "clamp":
          return `Clamp: ${f.min}-${f.max}`;
        case "smooth":
          return `Smooth: ${f.smoothing}`;
        case "threshold":
          return `Threshold: ${f.threshold}`;
        default:
          return f.type;
      }
    }
    function d(f) {
      n.togglePropertyDriver(f);
    }
    function h(f) {
      n.removePropertyDriver(f);
    }
    function p() {
      n.createAudioPropertyDriver(
        e.layerId,
        a.value.targetProperty,
        a.value.audioFeature,
        {
          scale: a.value.scale,
          threshold: a.value.threshold > 0 ? a.value.threshold : void 0
        }
      ), o.value = !1;
    }
    return (f, m) => r.value.length > 0 ? (se(), re("div", IL, [
      v("div", {
        class: "driver-list-header",
        onClick: m[0] || (m[0] = (y) => i.value = !i.value)
      }, [
        v("span", RL, ye(i.value ? "" : ""), 1),
        m[7] || (m[7] = v("span", { class: "title" }, "Property Drivers", -1)),
        v("span", LL, "(" + ye(r.value.length) + ")", 1)
      ]),
      i.value ? (se(), re("div", FL, [
        (se(!0), re(Xe, null, at(r.value, (y) => (se(), re("div", {
          key: y.id,
          class: Le(["driver-item", { disabled: !y.enabled }])
        }, [
          v("div", OL, [
            v("button", {
              class: Le(["toggle-btn", { active: y.enabled }]),
              onClick: (g) => d(y.id),
              title: "Toggle driver"
            }, "  ", 10, UL),
            v("div", zL, [
              v("span", BL, ye(l(y.targetProperty)), 1),
              m[8] || (m[8] = v("span", { class: "arrow" }, "", -1)),
              y.sourceType === "property" ? (se(), re("span", NL, ye(c(y.sourceLayerId)) + "." + ye(l(y.sourceProperty)), 1)) : y.sourceType === "audio" ? (se(), re("span", VL, "  " + ye(y.audioFeature), 1)) : y.sourceType === "time" ? (se(), re("span", HL, "  Time ")) : Te("", !0)
            ]),
            v("button", {
              class: "remove-btn",
              onClick: (g) => h(y.id),
              title: "Remove driver"
            }, "  ", 8, GL)
          ]),
          y.transforms.length > 0 ? (se(), re("div", $L, [
            (se(!0), re(Xe, null, at(y.transforms, (g, x) => (se(), re("span", {
              key: x,
              class: "transform-chip",
              title: u(g)
            }, ye(g.type), 9, WL))), 128))
          ])) : Te("", !0)
        ], 2))), 128))
      ])) : Te("", !0),
      i.value ? (se(), re("div", jL, [
        v("button", {
          class: "add-driver-btn",
          onClick: m[1] || (m[1] = (y) => o.value = !o.value)
        }, " + Add Audio Driver "),
        o.value ? (se(), re("div", XL, [
          v("div", YL, [
            m[10] || (m[10] = v("label", null, "Audio Feature:", -1)),
            st(v("select", {
              "onUpdate:modelValue": m[2] || (m[2] = (y) => a.value.audioFeature = y)
            }, [...m[9] || (m[9] = [
              fs('<option value="amplitude" data-v-d3107912>Amplitude</option><option value="bass" data-v-d3107912>Bass</option><option value="mid" data-v-d3107912>Mid</option><option value="high" data-v-d3107912>High</option><option value="rms" data-v-d3107912>RMS</option>', 5)
            ])], 512), [
              [En, a.value.audioFeature]
            ])
          ]),
          v("div", qL, [
            m[12] || (m[12] = v("label", null, "Target Property:", -1)),
            st(v("select", {
              "onUpdate:modelValue": m[3] || (m[3] = (y) => a.value.targetProperty = y)
            }, [...m[11] || (m[11] = [
              fs('<option value="transform.position.x" data-v-d3107912>Position X</option><option value="transform.position.y" data-v-d3107912>Position Y</option><option value="transform.scale.x" data-v-d3107912>Scale X</option><option value="transform.scale.y" data-v-d3107912>Scale Y</option><option value="transform.rotation" data-v-d3107912>Rotation</option><option value="opacity" data-v-d3107912>Opacity</option>', 6)
            ])], 512), [
              [En, a.value.targetProperty]
            ])
          ]),
          v("div", ZL, [
            m[13] || (m[13] = v("label", null, "Scale:", -1)),
            st(v("input", {
              type: "number",
              "onUpdate:modelValue": m[4] || (m[4] = (y) => a.value.scale = y),
              step: "10"
            }, null, 512), [
              [
                Ot,
                a.value.scale,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          v("div", KL, [
            m[14] || (m[14] = v("label", null, "Threshold:", -1)),
            st(v("input", {
              type: "number",
              "onUpdate:modelValue": m[5] || (m[5] = (y) => a.value.threshold = y),
              min: "0",
              max: "1",
              step: "0.1"
            }, null, 512), [
              [
                Ot,
                a.value.threshold,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          v("div", JL, [
            v("button", { onClick: p }, "Create"),
            v("button", {
              onClick: m[6] || (m[6] = (y) => o.value = !1)
            }, "Cancel")
          ])
        ])) : Te("", !0)
      ])) : Te("", !0)
    ])) : Te("", !0);
  }
}), eF = /* @__PURE__ */ Vt(QL, [["__scopeId", "data-v-d3107912"]]), tF = { class: "properties-panel" }, nF = {
  key: 0,
  class: "panel-content"
}, iF = { class: "property-section" }, sF = { class: "property-row" }, oF = { class: "property-section" }, aF = { class: "property-row" }, rF = ["value"], lF = ["value"], cF = { class: "property-section" }, uF = { class: "expand-icon" }, dF = {
  key: 0,
  class: "section-content"
}, hF = ["data-pickwhip-layer-id"], fF = { class: "multi-value" }, pF = { class: "multi-value" }, mF = { class: "property-row" }, vF = { class: "multi-value orientation-row" }, gF = { class: "property-row" }, yF = { class: "single-value" }, xF = { class: "property-row" }, bF = { class: "single-value" }, _F = { class: "property-row" }, wF = { class: "single-value" }, MF = { class: "single-value" }, SF = { class: "property-row" }, CF = { class: "multi-value" }, TF = { class: "single-value" }, EF = { class: "property-section" }, AF = { class: "property-row" }, PF = ["value"], kF = {
  key: 1,
  class: "empty-state"
}, DF = /* @__PURE__ */ Bt({
  __name: "PropertiesPanel",
  setup(s) {
    const e = un(), n = xe(["transform"]), i = xe(!0), o = xe(""), a = xe({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    }), r = xe("normal"), l = xe([]), c = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], u = Re(() => e.selectedLayer), d = Re(() => {
      if (!u.value) return [];
      const E = u.value.id, b = (A) => {
        const R = e.layers.filter((U) => U.parentId === A);
        let k = R.map((U) => U.id);
        for (const U of R)
          k = k.concat(b(U.id));
        return k;
      }, S = new Set(b(E));
      return e.layers.filter(
        (A) => A.id !== E && !S.has(A.id) && A.type !== "camera"
        // Camera layers shouldn't be parents
      );
    }), h = Re(() => {
      if (!u.value) return null;
      switch (u.value.type) {
        case "text":
          return $s(nE);
        case "particles":
          return $s(nD);
        case "depthflow":
          return $s(jI);
        case "light":
          return $s(pR);
        case "spline":
          return $s(LR);
        case "video":
          return $s(ML);
        default:
          return null;
      }
    });
    Ft(u, (E) => {
      var b, S, A, R, k, U, I, W, fe, q, G, Q, K, Y, ee, ce, ae, de, ie, he, ne, N, te, F, B;
      if (E) {
        o.value = E.name;
        const L = E.transform;
        a.value = {
          position: {
            x: ((S = (b = L == null ? void 0 : L.position) == null ? void 0 : b.value) == null ? void 0 : S.x) || 0,
            y: ((R = (A = L == null ? void 0 : L.position) == null ? void 0 : A.value) == null ? void 0 : R.y) || 0,
            z: ((U = (k = L == null ? void 0 : L.position) == null ? void 0 : k.value) == null ? void 0 : U.z) || 0
          },
          scale: { x: ((W = (I = L == null ? void 0 : L.scale) == null ? void 0 : I.value) == null ? void 0 : W.x) || 100, y: ((q = (fe = L == null ? void 0 : L.scale) == null ? void 0 : fe.value) == null ? void 0 : q.y) || 100 },
          rotation: ((G = L == null ? void 0 : L.rotation) == null ? void 0 : G.value) || 0,
          anchorPoint: { x: ((K = (Q = L == null ? void 0 : L.anchorPoint) == null ? void 0 : Q.value) == null ? void 0 : K.x) || 0, y: ((ee = (Y = L == null ? void 0 : L.anchorPoint) == null ? void 0 : Y.value) == null ? void 0 : ee.y) || 0 },
          opacity: ((ce = E.opacity) == null ? void 0 : ce.value) || 100,
          // 3D properties
          orientationX: ((de = (ae = L == null ? void 0 : L.orientation) == null ? void 0 : ae.value) == null ? void 0 : de.x) || 0,
          orientationY: ((he = (ie = L == null ? void 0 : L.orientation) == null ? void 0 : ie.value) == null ? void 0 : he.y) || 0,
          orientationZ: ((N = (ne = L == null ? void 0 : L.orientation) == null ? void 0 : ne.value) == null ? void 0 : N.z) || 0,
          rotationX: ((te = L == null ? void 0 : L.rotationX) == null ? void 0 : te.value) || 0,
          rotationY: ((F = L == null ? void 0 : L.rotationY) == null ? void 0 : F.value) || 0,
          rotationZ: ((B = L == null ? void 0 : L.rotationZ) == null ? void 0 : B.value) || 0
        }, r.value = E.blendMode || "normal";
      }
    }, { immediate: !0 }), Ft(() => a.value.scale.x, (E, b) => {
      if (i.value && E !== b) {
        const S = E / b;
        a.value.scale.y = Math.round(a.value.scale.y * S * 10) / 10;
      }
    });
    function p(E) {
      const b = n.value.indexOf(E);
      b >= 0 ? n.value.splice(b, 1) : n.value.push(E);
    }
    function f() {
      u.value && o.value && (u.value.name = o.value);
    }
    function m() {
      if (!u.value) return;
      const E = u.value.transform, b = a.value;
      E != null && E.position && (E.position.value = { x: b.position.x, y: b.position.y, z: b.position.z }), E != null && E.scale && (E.scale.value = { x: b.scale.x, y: b.scale.y }), E != null && E.rotation && (E.rotation.value = b.rotation), E != null && E.anchorPoint && (E.anchorPoint.value = { x: b.anchorPoint.x, y: b.anchorPoint.y }), u.value.opacity && (u.value.opacity.value = b.opacity), u.value.threeD && (E != null && E.orientation && (E.orientation.value = { x: b.orientationX, y: b.orientationY, z: b.orientationZ }), E != null && E.rotationX && (E.rotationX.value = b.rotationX), E != null && E.rotationY && (E.rotationY.value = b.rotationY), E != null && E.rotationZ && (E.rotationZ.value = b.rotationZ)), w();
    }
    function y() {
      u.value && (u.value.blendMode = r.value);
    }
    function g(E) {
      return l.value.includes(E);
    }
    function x(E) {
      const b = l.value.indexOf(E);
      b >= 0 ? l.value.splice(b, 1) : (l.value.push(E), console.log(`Added keyframe for ${E} at frame ${e.currentFrame}`));
    }
    function w(E) {
      u.value && (E && Object.keys(E).length > 0 ? e.updateLayerData(u.value.id, E) : e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
    function M(E) {
      if (!u.value) return;
      const b = E.target.value || null;
      e.setLayerParent(u.value.id, b);
    }
    function _(E) {
      if (!u.value) return null;
      const S = e.getDriversForLayer(u.value.id).find((A) => A.targetProperty === E && A.sourceType === "property");
      return S && S.sourceLayerId && S.sourceProperty ? {
        layerId: S.sourceLayerId,
        property: S.sourceProperty
      } : null;
    }
    function C(E, b) {
      u.value && (e.createPropertyLink(
        u.value.id,
        E,
        b.layerId,
        b.property,
        { blendMode: "add" }
      ), console.log(`[PropertiesPanel] Linked ${u.value.id}.${E} <- ${b.layerId}.${b.property}`));
    }
    function T(E) {
      if (!u.value) return;
      const S = e.getDriversForLayer(u.value.id).find((A) => A.targetProperty === E && A.sourceType === "property");
      S && (e.removePropertyDriver(S.id), console.log(`[PropertiesPanel] Unlinked ${u.value.id}.${E}`));
    }
    function P(E) {
      return u.value ? e.getDriversForLayer(u.value.id).some((S) => S.targetProperty === E && S.enabled) : !1;
    }
    return (E, b) => {
      var S, A, R, k, U, I, W, fe, q, G, Q;
      return se(), re("div", tF, [
        b[49] || (b[49] = v("div", { class: "panel-header" }, [
          v("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        u.value ? (se(), re("div", nF, [
          v("div", iF, [
            v("div", sF, [
              st(v("input", {
                type: "text",
                "onUpdate:modelValue": b[0] || (b[0] = (K) => o.value = K),
                class: "layer-name-input",
                onBlur: f,
                onKeydown: b[1] || (b[1] = Lr((K) => K.target.blur(), ["enter"]))
              }, null, 544), [
                [Ot, o.value]
              ])
            ])
          ]),
          v("div", oF, [
            v("div", aF, [
              b[37] || (b[37] = v("label", null, "Parent", -1)),
              v("select", {
                class: "parent-select",
                value: ((S = u.value) == null ? void 0 : S.parentId) || "",
                onChange: M
              }, [
                b[36] || (b[36] = v("option", { value: "" }, "None", -1)),
                (se(!0), re(Xe, null, at(d.value, (K) => (se(), re("option", {
                  key: K.id,
                  value: K.id
                }, ye(K.name), 9, lF))), 128))
              ], 40, rF)
            ])
          ]),
          v("div", cF, [
            v("div", {
              class: "section-header",
              onClick: b[2] || (b[2] = (K) => p("transform"))
            }, [
              v("span", uF, ye(n.value.includes("transform") ? "" : ""), 1),
              b[38] || (b[38] = v("span", { class: "section-title" }, "Transform", -1))
            ]),
            n.value.includes("transform") ? (se(), re("div", dF, [
              v("div", {
                class: Le(["property-row", { "has-driver": P("transform.position.x") }])
              }, [
                u.value ? (se(), Tt(Hl, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.position.x",
                  linkedTo: _("transform.position.x"),
                  onLink: b[3] || (b[3] = (K) => C("transform.position.x", K)),
                  onUnlink: b[4] || (b[4] = () => T("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Te("", !0),
                v("label", {
                  "data-pickwhip-target": "transform.position.x",
                  "data-pickwhip-layer-id": (A = u.value) == null ? void 0 : A.id,
                  "data-pickwhip-label": "Position X"
                }, "Position", 8, hF),
                v("div", fF, [
                  Ne(He(it), {
                    modelValue: a.value.position.x,
                    "onUpdate:modelValue": [
                      b[5] || (b[5] = (K) => a.value.position.x = K),
                      m
                    ],
                    precision: 1,
                    unit: "X",
                    "data-pickwhip-target": "transform.position.x",
                    "data-pickwhip-layer-id": (R = u.value) == null ? void 0 : R.id,
                    "data-pickwhip-label": "Position X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  Ne(He(it), {
                    modelValue: a.value.position.y,
                    "onUpdate:modelValue": [
                      b[6] || (b[6] = (K) => a.value.position.y = K),
                      m
                    ],
                    precision: 1,
                    unit: "Y",
                    "data-pickwhip-target": "transform.position.y",
                    "data-pickwhip-layer-id": (k = u.value) == null ? void 0 : k.id,
                    "data-pickwhip-label": "Position Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  (U = u.value) != null && U.threeD ? (se(), Tt(He(it), {
                    key: 0,
                    modelValue: a.value.position.z,
                    "onUpdate:modelValue": [
                      b[7] || (b[7] = (K) => a.value.position.z = K),
                      m
                    ],
                    precision: 1,
                    unit: "Z",
                    "data-pickwhip-target": "transform.position.z",
                    "data-pickwhip-layer-id": (I = u.value) == null ? void 0 : I.id,
                    "data-pickwhip-label": "Position Z"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])) : Te("", !0)
                ]),
                v("button", {
                  class: Le(["keyframe-btn", { active: g("position") }]),
                  onClick: b[8] || (b[8] = (K) => x("position"))
                }, "", 2)
              ], 2),
              v("div", {
                class: Le(["property-row", { "has-driver": P("transform.scale.x") || P("transform.scale.y") }])
              }, [
                u.value ? (se(), Tt(Hl, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.scale.x",
                  linkedTo: _("transform.scale.x"),
                  onLink: b[9] || (b[9] = (K) => C("transform.scale.x", K)),
                  onUnlink: b[10] || (b[10] = () => T("transform.scale.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Te("", !0),
                b[39] || (b[39] = v("label", null, "Scale", -1)),
                v("div", pF, [
                  Ne(He(it), {
                    modelValue: a.value.scale.x,
                    "onUpdate:modelValue": [
                      b[11] || (b[11] = (K) => a.value.scale.x = K),
                      m
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.x",
                    "data-pickwhip-layer-id": (W = u.value) == null ? void 0 : W.id,
                    "data-pickwhip-label": "Scale X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  v("button", {
                    class: Le(["link-btn", { active: i.value }]),
                    onClick: b[12] || (b[12] = (K) => i.value = !i.value),
                    title: "Link scale values"
                  }, "  ", 2),
                  Ne(He(it), {
                    modelValue: a.value.scale.y,
                    "onUpdate:modelValue": [
                      b[13] || (b[13] = (K) => a.value.scale.y = K),
                      m
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.y",
                    "data-pickwhip-layer-id": (fe = u.value) == null ? void 0 : fe.id,
                    "data-pickwhip-label": "Scale Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                v("button", {
                  class: Le(["keyframe-btn", { active: g("scale") }]),
                  onClick: b[14] || (b[14] = (K) => x("scale"))
                }, "", 2)
              ], 2),
              (q = u.value) != null && q.threeD ? (se(), re(Xe, { key: 0 }, [
                v("div", mF, [
                  b[40] || (b[40] = v("label", null, "Orientation", -1)),
                  v("div", vF, [
                    Ne(He(it), {
                      modelValue: a.value.orientationX,
                      "onUpdate:modelValue": [
                        b[15] || (b[15] = (K) => a.value.orientationX = K),
                        m
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    Ne(He(it), {
                      modelValue: a.value.orientationY,
                      "onUpdate:modelValue": [
                        b[16] || (b[16] = (K) => a.value.orientationY = K),
                        m
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    Ne(He(it), {
                      modelValue: a.value.orientationZ,
                      "onUpdate:modelValue": [
                        b[17] || (b[17] = (K) => a.value.orientationZ = K),
                        m
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                v("div", gF, [
                  b[41] || (b[41] = v("label", null, "X Rotation", -1)),
                  v("div", yF, [
                    Ne(He(it), {
                      modelValue: a.value.rotationX,
                      "onUpdate:modelValue": [
                        b[18] || (b[18] = (K) => a.value.rotationX = K),
                        m
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  v("button", {
                    class: Le(["keyframe-btn", { active: g("rotationX") }]),
                    onClick: b[19] || (b[19] = (K) => x("rotationX"))
                  }, "", 2)
                ]),
                v("div", xF, [
                  b[42] || (b[42] = v("label", null, "Y Rotation", -1)),
                  v("div", bF, [
                    Ne(He(it), {
                      modelValue: a.value.rotationY,
                      "onUpdate:modelValue": [
                        b[20] || (b[20] = (K) => a.value.rotationY = K),
                        m
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  v("button", {
                    class: Le(["keyframe-btn", { active: g("rotationY") }]),
                    onClick: b[21] || (b[21] = (K) => x("rotationY"))
                  }, "", 2)
                ]),
                v("div", _F, [
                  b[43] || (b[43] = v("label", null, "Z Rotation", -1)),
                  v("div", wF, [
                    Ne(He(it), {
                      modelValue: a.value.rotationZ,
                      "onUpdate:modelValue": [
                        b[22] || (b[22] = (K) => a.value.rotationZ = K),
                        m
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  v("button", {
                    class: Le(["keyframe-btn", { active: g("rotationZ") }]),
                    onClick: b[23] || (b[23] = (K) => x("rotationZ"))
                  }, "", 2)
                ])
              ], 64)) : (se(), re("div", {
                key: 1,
                class: Le(["property-row", { "has-driver": P("transform.rotation") }])
              }, [
                u.value ? (se(), Tt(Hl, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.rotation",
                  linkedTo: _("transform.rotation"),
                  onLink: b[24] || (b[24] = (K) => C("transform.rotation", K)),
                  onUnlink: b[25] || (b[25] = () => T("transform.rotation"))
                }, null, 8, ["layerId", "linkedTo"])) : Te("", !0),
                b[44] || (b[44] = v("label", null, "Rotation", -1)),
                v("div", MF, [
                  Ne(He(it), {
                    modelValue: a.value.rotation,
                    "onUpdate:modelValue": [
                      b[26] || (b[26] = (K) => a.value.rotation = K),
                      m
                    ],
                    min: -360,
                    max: 360,
                    unit: "",
                    "data-pickwhip-target": "transform.rotation",
                    "data-pickwhip-layer-id": (G = u.value) == null ? void 0 : G.id,
                    "data-pickwhip-label": "Rotation"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                v("button", {
                  class: Le(["keyframe-btn", { active: g("rotation") }]),
                  onClick: b[27] || (b[27] = (K) => x("rotation"))
                }, "", 2)
              ], 2)),
              v("div", SF, [
                b[45] || (b[45] = v("label", null, "Anchor Point", -1)),
                v("div", CF, [
                  Ne(He(it), {
                    modelValue: a.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      b[28] || (b[28] = (K) => a.value.anchorPoint.x = K),
                      m
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  Ne(He(it), {
                    modelValue: a.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      b[29] || (b[29] = (K) => a.value.anchorPoint.y = K),
                      m
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                v("button", {
                  class: Le(["keyframe-btn", { active: g("anchorPoint") }]),
                  onClick: b[30] || (b[30] = (K) => x("anchorPoint"))
                }, "", 2)
              ]),
              v("div", {
                class: Le(["property-row", { "has-driver": P("opacity") }])
              }, [
                u.value ? (se(), Tt(Hl, {
                  key: 0,
                  layerId: u.value.id,
                  property: "opacity",
                  linkedTo: _("opacity"),
                  onLink: b[31] || (b[31] = (K) => C("opacity", K)),
                  onUnlink: b[32] || (b[32] = () => T("opacity"))
                }, null, 8, ["layerId", "linkedTo"])) : Te("", !0),
                b[46] || (b[46] = v("label", null, "Opacity", -1)),
                v("div", TF, [
                  Ne(He(ti), {
                    modelValue: a.value.opacity,
                    "onUpdate:modelValue": [
                      b[33] || (b[33] = (K) => a.value.opacity = K),
                      m
                    ],
                    min: 0,
                    max: 100,
                    unit: "%",
                    "data-pickwhip-target": "opacity",
                    "data-pickwhip-layer-id": (Q = u.value) == null ? void 0 : Q.id,
                    "data-pickwhip-label": "Opacity"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                v("button", {
                  class: Le(["keyframe-btn", { active: g("opacity") }]),
                  onClick: b[34] || (b[34] = (K) => x("opacity"))
                }, "", 2)
              ], 2)
            ])) : Te("", !0)
          ]),
          v("div", EF, [
            v("div", AF, [
              b[47] || (b[47] = v("label", null, "Blend Mode", -1)),
              st(v("select", {
                "onUpdate:modelValue": b[35] || (b[35] = (K) => r.value = K),
                class: "blend-select",
                onChange: y
              }, [
                (se(), re(Xe, null, at(c, (K) => v("option", {
                  key: K.value,
                  value: K.value
                }, ye(K.label), 9, PF)), 64))
              ], 544), [
                [En, r.value]
              ])
            ])
          ]),
          h.value ? (se(), Tt(i3(h.value), {
            key: 0,
            layer: u.value,
            onUpdate: w
          }, null, 40, ["layer"])) : Te("", !0),
          u.value ? (se(), Tt(eF, {
            key: 1,
            layerId: u.value.id
          }, null, 8, ["layerId"])) : Te("", !0)
        ])) : (se(), re("div", kF, [...b[48] || (b[48] = [
          v("p", null, "No layer selected", -1),
          v("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
}), IF = /* @__PURE__ */ Vt(DF, [["__scopeId", "data-v-a5a9c7d6"]]), RF = {
  type: "custom",
  baseDistance: 1500,
  center: { x: 960, y: 540, z: 0 },
  duration: 150,
  // 5 seconds at 30fps
  startPhase: 0,
  loops: 1,
  amplitude: 1,
  easing: "ease-in-out",
  audioReactive: !1
}, LF = {
  custom: {},
  orbit: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  orbit_reverse: {
    loops: 1,
    amplitude: -1,
    // Negative for reverse
    easing: "linear"
  },
  swing1: {
    amplitude: 0.25,
    // Smaller arc
    easing: "ease-in-out"
  },
  swing2: {
    amplitude: 0.5,
    // Larger arc
    easing: "ease-in-out"
  },
  dolly_in: {
    amplitude: 0.5,
    // Move 50% closer
    easing: "ease-out"
  },
  dolly_out: {
    amplitude: -0.5,
    // Move 50% away
    easing: "ease-in"
  },
  pan_left: {
    amplitude: 30,
    // 30 degree pan
    easing: "ease-in-out"
  },
  pan_right: {
    amplitude: -30,
    easing: "ease-in-out"
  },
  tilt_up: {
    amplitude: 20,
    // 20 degree tilt
    easing: "ease-in-out"
  },
  tilt_down: {
    amplitude: -20,
    easing: "ease-in-out"
  },
  zoom_in: {
    amplitude: 0.5,
    // 50% zoom increase
    easing: "ease-out"
  },
  zoom_out: {
    amplitude: -0.3,
    // 30% zoom decrease
    easing: "ease-in"
  },
  circle: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  figure8: {
    loops: 1,
    amplitude: 1,
    easing: "linear"
  },
  spiral_in: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-out"
  },
  spiral_out: {
    loops: 2,
    amplitude: 0.6,
    easing: "ease-in"
  },
  crane_up: {
    amplitude: 500,
    // Pixels to move up
    easing: "ease-in-out"
  },
  crane_down: {
    amplitude: -500,
    easing: "ease-in-out"
  },
  truck_left: {
    amplitude: 300,
    // Pixels to move left
    easing: "ease-in-out"
  },
  truck_right: {
    amplitude: -300,
    easing: "ease-in-out"
  },
  arc_left: {
    amplitude: 0.25,
    // Quarter circle left
    easing: "ease-in-out"
  },
  arc_right: {
    amplitude: -0.25,
    easing: "ease-in-out"
  }
};
function Km(s, e) {
  switch (e) {
    case "linear":
      return s;
    case "ease-in":
      return s * s;
    case "ease-out":
      return 1 - (1 - s) * (1 - s);
    case "ease-in-out":
      return s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2;
    case "bounce":
      if (s < 0.5)
        return 8 * s * s * s * s;
      const n = s - 1;
      return 1 - 8 * n * n * n * n;
    default:
      return s;
  }
}
function Jm(s, e) {
  const n = Km(e, s.easing), { center: i, baseDistance: o, amplitude: a, loops: r, startPhase: l, type: c } = s;
  let u = { x: i.x, y: i.y, z: i.z - o }, d = { ...i };
  switch (c) {
    case "orbit":
    case "orbit_reverse": {
      const h = (l + n * r) * 2 * Math.PI * Math.sign(a);
      u = {
        x: i.x + Math.sin(h) * o,
        y: i.y,
        z: i.z - Math.cos(h) * o
      };
      break;
    }
    case "swing1":
    case "swing2": {
      const h = Math.abs(a) * Math.PI, p = Math.sin(n * Math.PI) * h;
      u = {
        x: i.x + Math.sin(p) * o,
        y: i.y,
        z: i.z - Math.cos(p) * o
      };
      break;
    }
    case "dolly_in": {
      const h = o * (1 - n * Math.abs(a));
      u = {
        x: i.x,
        y: i.y,
        z: i.z - h
      };
      break;
    }
    case "dolly_out": {
      const h = o * (1 + n * Math.abs(a));
      u = {
        x: i.x,
        y: i.y,
        z: i.z - h
      };
      break;
    }
    case "pan_left":
    case "pan_right": {
      const h = n * a * (Math.PI / 180);
      d = {
        x: i.x + Math.sin(h) * o,
        y: i.y,
        z: i.z + Math.cos(h) * o - o
      };
      break;
    }
    case "tilt_up":
    case "tilt_down": {
      const h = n * a * (Math.PI / 180);
      d = {
        x: i.x,
        y: i.y + Math.sin(h) * o,
        z: i.z
      };
      break;
    }
    case "circle": {
      const h = (l + n * r) * 2 * Math.PI, p = o * 0.3 * Math.abs(a);
      u = {
        x: i.x + Math.sin(h) * p,
        y: i.y + Math.cos(h) * p * 0.5,
        // Elliptical
        z: i.z - o + Math.cos(h) * p * 0.3
      };
      break;
    }
    case "figure8": {
      const h = (l + n * r) * 2 * Math.PI, p = o * 0.3 * Math.abs(a);
      u = {
        x: i.x + Math.sin(h) * p,
        y: i.y + Math.sin(h * 2) * p * 0.3,
        z: i.z - o
      };
      break;
    }
    case "spiral_in": {
      const h = (l + n * r) * 2 * Math.PI, p = o * (1 - n * Math.abs(a));
      u = {
        x: i.x + Math.sin(h) * p * 0.3,
        y: i.y,
        z: i.z - p
      };
      break;
    }
    case "spiral_out": {
      const h = (l + n * r) * 2 * Math.PI, p = o * (1 + n * Math.abs(a));
      u = {
        x: i.x + Math.sin(h) * p * 0.3,
        y: i.y,
        z: i.z - p
      };
      break;
    }
    case "crane_up":
    case "crane_down": {
      u = {
        x: i.x,
        y: i.y + n * a,
        z: i.z - o
      }, d = {
        x: i.x,
        y: i.y + n * a * 0.5,
        // Target moves less
        z: i.z
      };
      break;
    }
    case "truck_left":
    case "truck_right": {
      u = {
        x: i.x + n * a,
        y: i.y,
        z: i.z - o
      }, d = {
        x: i.x + n * a,
        y: i.y,
        z: i.z
      };
      break;
    }
    case "arc_left":
    case "arc_right": {
      const h = n * a * 2 * Math.PI;
      u = {
        x: i.x + Math.sin(h) * o,
        y: i.y,
        z: i.z - Math.cos(h) * o
      };
      break;
    }
  }
  return { position: u, target: d };
}
function FF(s, e = 0, n = 5) {
  const i = [], o = [], a = [], r = Math.ceil(s.duration / n) + 1;
  for (let l = 0; l < r; l++) {
    const c = e + Math.min(l * n, s.duration), u = Math.min(l * n, s.duration) / s.duration, { position: d, target: h } = Jm(s, u);
    if (i.push({
      frame: c,
      position: d,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    }), o.push({
      frame: c,
      pointOfInterest: h,
      spatialInterpolation: "bezier",
      temporalInterpolation: "linear"
    }), s.type === "zoom_in" || s.type === "zoom_out") {
      const p = Km(u, s.easing), f = s.type === "zoom_in" ? 1 + p * Math.abs(s.amplitude) : 1 - p * Math.abs(s.amplitude);
      a.push({
        frame: c,
        zoom: 1778 * f,
        // Base 50mm zoom
        temporalInterpolation: "linear"
      });
    }
  }
  return {
    position: i,
    pointOfInterest: o,
    zoom: a.length > 0 ? a : void 0
  };
}
function OF(s) {
  return {
    custom: "Custom trajectory with manual keyframes",
    orbit: "360 horizontal orbit around target",
    orbit_reverse: "360 reverse orbit around target",
    swing1: "Gentle pendulum swing (45)",
    swing2: "Wide pendulum swing (90)",
    dolly_in: "Move camera toward target",
    dolly_out: "Move camera away from target",
    pan_left: "Rotate camera left while stationary",
    pan_right: "Rotate camera right while stationary",
    tilt_up: "Tilt camera up while stationary",
    tilt_down: "Tilt camera down while stationary",
    zoom_in: "Zoom lens in (narrower FOV)",
    zoom_out: "Zoom lens out (wider FOV)",
    circle: "Elliptical circling motion",
    figure8: "Figure-8 weaving pattern",
    spiral_in: "Spiral toward target",
    spiral_out: "Spiral away from target",
    crane_up: "Vertical lift (crane shot up)",
    crane_down: "Vertical descent (crane shot down)",
    truck_left: "Horizontal slide left",
    truck_right: "Horizontal slide right",
    arc_left: "Curved arc movement left",
    arc_right: "Curved arc movement right"
  }[s] || "Unknown trajectory";
}
function UF(s) {
  return {
    custom: "Custom",
    orbit: "Orbital",
    orbit_reverse: "Orbital",
    swing1: "Orbital",
    swing2: "Orbital",
    circle: "Orbital",
    figure8: "Orbital",
    arc_left: "Orbital",
    arc_right: "Orbital",
    dolly_in: "Dolly",
    dolly_out: "Dolly",
    spiral_in: "Dolly",
    spiral_out: "Dolly",
    pan_left: "Pan/Tilt",
    pan_right: "Pan/Tilt",
    tilt_up: "Pan/Tilt",
    tilt_down: "Pan/Tilt",
    crane_up: "Crane",
    crane_down: "Crane",
    truck_left: "Truck",
    truck_right: "Truck",
    zoom_in: "Zoom",
    zoom_out: "Zoom"
  }[s] || "Other";
}
function zF() {
  const s = Object.keys(LF), e = {};
  for (const n of s) {
    const i = UF(n);
    e[i] || (e[i] = []), e[i].push(n);
  }
  return e;
}
const BF = { class: "camera-properties" }, NF = { class: "panel-header" }, VF = { class: "camera-name" }, HF = {
  key: 0,
  class: "properties-content"
}, GF = { class: "property-section" }, $F = { class: "property-row" }, WF = ["value"], jF = { class: "property-section" }, XF = { class: "toggle-icon" }, YF = { class: "section-content" }, qF = { class: "property-group" }, ZF = { class: "xyz-inputs" }, KF = {
  key: 0,
  class: "property-group"
}, JF = { class: "xyz-inputs" }, QF = { class: "property-group" }, eO = { class: "xyz-inputs" }, tO = { class: "property-group" }, nO = { class: "property-group" }, iO = { class: "property-group" }, sO = { class: "property-section" }, oO = { class: "toggle-icon" }, aO = { class: "section-content" }, rO = { class: "preset-row" }, lO = ["onClick"], cO = { class: "property-group" }, uO = { class: "property-group" }, dO = { class: "property-group" }, hO = { class: "property-group" }, fO = ["value"], pO = { class: "property-section" }, mO = { class: "toggle-icon" }, vO = { class: "section-content" }, gO = { class: "property-group checkbox-group" }, yO = ["checked"], xO = { class: "property-group" }, bO = { class: "property-group" }, _O = { class: "property-group" }, wO = { class: "property-group checkbox-group" }, MO = ["checked"], SO = { class: "property-section" }, CO = { class: "toggle-icon" }, TO = { class: "section-content" }, EO = { class: "property-group" }, AO = { class: "property-group" }, PO = { class: "property-group" }, kO = { class: "property-group" }, DO = { class: "property-group" }, IO = { class: "property-section" }, RO = { class: "toggle-icon" }, LO = { class: "section-content" }, FO = { class: "property-group" }, OO = { class: "property-group" }, UO = { class: "property-group" }, zO = { class: "property-section" }, BO = { class: "toggle-icon" }, NO = { class: "section-content" }, VO = { class: "property-group" }, HO = ["value"], GO = { class: "property-section" }, $O = { class: "toggle-icon" }, WO = { class: "section-content" }, jO = { class: "property-group" }, XO = { class: "property-group" }, YO = { class: "property-section" }, qO = { class: "toggle-icon" }, ZO = { class: "section-content" }, KO = { class: "property-group" }, JO = ["label"], QO = ["value"], eU = { class: "trajectory-description" }, tU = { class: "property-group" }, nU = { class: "property-group" }, iU = {
  key: 0,
  class: "property-group"
}, sU = { class: "property-group" }, oU = { class: "property-group checkbox-group" }, aU = { class: "property-group" }, rU = { class: "property-group" }, lU = {
  key: 1,
  class: "no-camera"
}, cU = /* @__PURE__ */ Bt({
  __name: "CameraProperties",
  setup(s) {
    const e = un(), n = Re(() => {
      const E = e.selectedLayer;
      if ((E == null ? void 0 : E.type) === "camera" && E.data) {
        const b = E.data;
        return e.getCamera(b.cameraId);
      }
      return e.activeCamera;
    }), i = po({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1,
      trajectory: !1
    }), o = po({
      ...RF
    }), a = Re(() => zF()), r = Re(() => OF(o.type)), l = Re(() => ["orbit", "orbit_reverse", "circle", "figure8", "spiral_in", "spiral_out"].includes(o.type));
    function c(E) {
      return E.split("_").map((b) => b.charAt(0).toUpperCase() + b.slice(1)).join(" ");
    }
    const u = xe(null);
    function d() {
      if (!n.value) return;
      u.value !== null && cancelAnimationFrame(u.value);
      const E = performance.now(), b = o.duration / 30 * 1e3, S = {
        ...o,
        center: { ...n.value.pointOfInterest },
        baseDistance: Math.sqrt(
          Math.pow(n.value.position.x - n.value.pointOfInterest.x, 2) + Math.pow(n.value.position.y - n.value.pointOfInterest.y, 2) + Math.pow(n.value.position.z - n.value.pointOfInterest.z, 2)
        )
      };
      function A() {
        const R = performance.now() - E, k = Math.min(R / b, 1), { position: U, target: I } = Jm(S, k);
        e.updateCamera(n.value.id, {
          position: U,
          pointOfInterest: I
        }), k < 1 ? u.value = requestAnimationFrame(A) : u.value = null;
      }
      A();
    }
    function h() {
      if (!n.value) return;
      const E = Math.sqrt(
        Math.pow(n.value.position.x - n.value.pointOfInterest.x, 2) + Math.pow(n.value.position.y - n.value.pointOfInterest.y, 2) + Math.pow(n.value.position.z - n.value.pointOfInterest.z, 2)
      ), b = {
        ...o,
        center: { ...n.value.pointOfInterest },
        baseDistance: E
      }, S = FF(b, e.currentFrame);
      for (const A of S.position)
        e.addCameraKeyframe(n.value.id, {
          frame: A.frame,
          position: A.position,
          spatialInterpolation: A.spatialInterpolation,
          temporalInterpolation: A.temporalInterpolation
        });
      for (const A of S.pointOfInterest)
        e.addCameraKeyframe(n.value.id, {
          frame: A.frame,
          pointOfInterest: A.pointOfInterest,
          spatialInterpolation: A.spatialInterpolation,
          temporalInterpolation: A.temporalInterpolation
        });
      if (S.zoom)
        for (const A of S.zoom)
          e.addCameraKeyframe(n.value.id, {
            frame: A.frame,
            zoom: A.zoom,
            temporalInterpolation: A.temporalInterpolation
          });
      console.log(`Applied ${S.position.length} camera trajectory keyframes`);
    }
    function p(E) {
      i[E] = !i[E];
    }
    function f(E, b) {
      n.value && e.updateCamera(n.value.id, { [E]: b });
    }
    function m(E, b) {
      n.value && e.updateCamera(n.value.id, {
        position: { ...n.value.position, [E]: b }
      });
    }
    function y(E, b) {
      n.value && e.updateCamera(n.value.id, {
        pointOfInterest: { ...n.value.pointOfInterest, [E]: b }
      });
    }
    function g(E, b) {
      n.value && e.updateCamera(n.value.id, {
        orientation: { ...n.value.orientation, [E]: b }
      });
    }
    function x(E) {
      if (!n.value) return;
      const b = Jr(E, n.value.filmSize);
      e.updateCamera(n.value.id, {
        focalLength: E,
        angleOfView: b
      });
    }
    function w(E) {
      if (!n.value) return;
      const b = $w(E, n.value.filmSize);
      e.updateCamera(n.value.id, {
        angleOfView: E,
        focalLength: b
      });
    }
    function M(E, b) {
      n.value && e.updateCamera(n.value.id, {
        depthOfField: { ...n.value.depthOfField, [E]: b }
      });
    }
    function _(E, b) {
      n.value && e.updateCamera(n.value.id, {
        iris: { ...n.value.iris, [E]: b }
      });
    }
    function C(E, b) {
      n.value && e.updateCamera(n.value.id, {
        highlight: { ...n.value.highlight, [E]: b }
      });
    }
    function T(E) {
      n.value && e.updateCamera(n.value.id, {
        focalLength: E.focalLength,
        angleOfView: E.angleOfView,
        zoom: E.zoom
      });
    }
    function P() {
      e.createCameraLayer();
    }
    return (E, b) => {
      var S;
      return se(), re("div", BF, [
        v("div", NF, [
          b[47] || (b[47] = v("span", { class: "panel-title" }, "Camera", -1)),
          v("span", VF, ye(((S = n.value) == null ? void 0 : S.name) ?? "No Camera"), 1)
        ]),
        n.value ? (se(), re("div", HF, [
          v("div", GF, [
            b[49] || (b[49] = v("div", { class: "section-header" }, "Type", -1)),
            v("div", $F, [
              v("select", {
                value: n.value.type,
                onChange: b[0] || (b[0] = (A) => f("type", A.target.value)),
                class: "type-select"
              }, [...b[48] || (b[48] = [
                v("option", { value: "one-node" }, "One-Node Camera", -1),
                v("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, WF)
            ])
          ]),
          v("div", jF, [
            v("div", {
              class: "section-header",
              onClick: b[1] || (b[1] = (A) => p("transform"))
            }, [
              v("span", XF, ye(i.transform ? "" : ""), 1),
              b[50] || (b[50] = ct(" Transform ", -1))
            ]),
            st(v("div", YF, [
              v("div", qF, [
                b[51] || (b[51] = v("label", null, "Position", -1)),
                v("div", ZF, [
                  Ne(He(it), {
                    modelValue: n.value.position.x,
                    "onUpdate:modelValue": b[2] || (b[2] = (A) => m("x", A)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(He(it), {
                    modelValue: n.value.position.y,
                    "onUpdate:modelValue": b[3] || (b[3] = (A) => m("y", A)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(He(it), {
                    modelValue: n.value.position.z,
                    "onUpdate:modelValue": b[4] || (b[4] = (A) => m("z", A)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              n.value.type === "two-node" ? (se(), re("div", KF, [
                b[52] || (b[52] = v("label", null, "Point of Interest", -1)),
                v("div", JF, [
                  Ne(He(it), {
                    modelValue: n.value.pointOfInterest.x,
                    "onUpdate:modelValue": b[5] || (b[5] = (A) => y("x", A)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(He(it), {
                    modelValue: n.value.pointOfInterest.y,
                    "onUpdate:modelValue": b[6] || (b[6] = (A) => y("y", A)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(He(it), {
                    modelValue: n.value.pointOfInterest.z,
                    "onUpdate:modelValue": b[7] || (b[7] = (A) => y("z", A)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : Te("", !0),
              v("div", QF, [
                b[53] || (b[53] = v("label", null, "Orientation", -1)),
                v("div", eO, [
                  Ne(He(it), {
                    modelValue: n.value.orientation.x,
                    "onUpdate:modelValue": b[8] || (b[8] = (A) => g("x", A)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(He(it), {
                    modelValue: n.value.orientation.y,
                    "onUpdate:modelValue": b[9] || (b[9] = (A) => g("y", A)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(He(it), {
                    modelValue: n.value.orientation.z,
                    "onUpdate:modelValue": b[10] || (b[10] = (A) => g("z", A)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              v("div", tO, [
                b[54] || (b[54] = v("label", null, "X Rotation", -1)),
                Ne(He(it), {
                  modelValue: n.value.xRotation,
                  "onUpdate:modelValue": b[11] || (b[11] = (A) => f("xRotation", A)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              v("div", nO, [
                b[55] || (b[55] = v("label", null, "Y Rotation", -1)),
                Ne(He(it), {
                  modelValue: n.value.yRotation,
                  "onUpdate:modelValue": b[12] || (b[12] = (A) => f("yRotation", A)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              v("div", iO, [
                b[56] || (b[56] = v("label", null, "Z Rotation", -1)),
                Ne(He(it), {
                  modelValue: n.value.zRotation,
                  "onUpdate:modelValue": b[13] || (b[13] = (A) => f("zRotation", A)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [u0, i.transform]
            ])
          ]),
          v("div", sO, [
            v("div", {
              class: "section-header",
              onClick: b[14] || (b[14] = (A) => p("lens"))
            }, [
              v("span", oO, ye(i.lens ? "" : ""), 1),
              b[57] || (b[57] = ct(" Lens ", -1))
            ]),
            st(v("div", aO, [
              v("div", rO, [
                (se(!0), re(Xe, null, at(He(zw), (A) => (se(), re("button", {
                  key: A.name,
                  class: Le({ active: Math.abs(n.value.focalLength - A.focalLength) < 0.5 }),
                  onClick: (R) => T(A)
                }, ye(A.name), 11, lO))), 128))
              ]),
              v("div", cO, [
                b[58] || (b[58] = v("label", null, "Focal Length", -1)),
                Ne(He(it), {
                  modelValue: n.value.focalLength,
                  "onUpdate:modelValue": x,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              v("div", uO, [
                b[59] || (b[59] = v("label", null, "Angle of View", -1)),
                Ne(He(it), {
                  modelValue: n.value.angleOfView,
                  "onUpdate:modelValue": w,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              v("div", dO, [
                b[60] || (b[60] = v("label", null, "Film Size", -1)),
                Ne(He(it), {
                  modelValue: n.value.filmSize,
                  "onUpdate:modelValue": b[15] || (b[15] = (A) => f("filmSize", A)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              v("div", hO, [
                b[62] || (b[62] = v("label", null, "Measure Film Size", -1)),
                v("select", {
                  value: n.value.measureFilmSize,
                  onChange: b[16] || (b[16] = (A) => f("measureFilmSize", A.target.value))
                }, [...b[61] || (b[61] = [
                  v("option", { value: "horizontal" }, "Horizontal", -1),
                  v("option", { value: "vertical" }, "Vertical", -1),
                  v("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, fO)
              ])
            ], 512), [
              [u0, i.lens]
            ])
          ]),
          v("div", pO, [
            v("div", {
              class: "section-header",
              onClick: b[17] || (b[17] = (A) => p("dof"))
            }, [
              v("span", mO, ye(i.dof ? "" : ""), 1),
              b[63] || (b[63] = ct(" Depth of Field ", -1))
            ]),
            st(v("div", vO, [
              v("div", gO, [
                v("label", null, [
                  v("input", {
                    type: "checkbox",
                    checked: n.value.depthOfField.enabled,
                    onChange: b[18] || (b[18] = (A) => M("enabled", A.target.checked))
                  }, null, 40, yO),
                  b[64] || (b[64] = ct(" Enable DOF ", -1))
                ])
              ]),
              n.value.depthOfField.enabled ? (se(), re(Xe, { key: 0 }, [
                v("div", xO, [
                  b[65] || (b[65] = v("label", null, "Focus Distance", -1)),
                  Ne(He(it), {
                    modelValue: n.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": b[19] || (b[19] = (A) => M("focusDistance", A)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                v("div", bO, [
                  b[66] || (b[66] = v("label", null, "f-Stop", -1)),
                  Ne(He(it), {
                    modelValue: n.value.depthOfField.fStop,
                    "onUpdate:modelValue": b[20] || (b[20] = (A) => M("fStop", A)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                v("div", _O, [
                  b[67] || (b[67] = v("label", null, "Blur Level", -1)),
                  Ne(He(ti), {
                    modelValue: n.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": b[21] || (b[21] = (A) => M("blurLevel", A)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                v("div", wO, [
                  v("label", null, [
                    v("input", {
                      type: "checkbox",
                      checked: n.value.depthOfField.lockToZoom,
                      onChange: b[22] || (b[22] = (A) => M("lockToZoom", A.target.checked))
                    }, null, 40, MO),
                    b[68] || (b[68] = ct(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : Te("", !0)
            ], 512), [
              [u0, i.dof]
            ])
          ]),
          v("div", SO, [
            v("div", {
              class: "section-header",
              onClick: b[23] || (b[23] = (A) => p("iris"))
            }, [
              v("span", CO, ye(i.iris ? "" : ""), 1),
              b[69] || (b[69] = ct(" Iris ", -1))
            ]),
            st(v("div", TO, [
              v("div", EO, [
                v("label", null, "Shape (" + ye(Math.round(n.value.iris.shape)) + "-gon)", 1),
                Ne(He(ti), {
                  modelValue: n.value.iris.shape,
                  "onUpdate:modelValue": b[24] || (b[24] = (A) => _("shape", A)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              v("div", AO, [
                b[70] || (b[70] = v("label", null, "Rotation", -1)),
                Ne(He(jh), {
                  modelValue: n.value.iris.rotation,
                  "onUpdate:modelValue": b[25] || (b[25] = (A) => _("rotation", A)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              v("div", PO, [
                b[71] || (b[71] = v("label", null, "Roundness", -1)),
                Ne(He(ti), {
                  modelValue: n.value.iris.roundness,
                  "onUpdate:modelValue": b[26] || (b[26] = (A) => _("roundness", A)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              v("div", kO, [
                b[72] || (b[72] = v("label", null, "Aspect Ratio", -1)),
                Ne(He(ti), {
                  modelValue: n.value.iris.aspectRatio,
                  "onUpdate:modelValue": b[27] || (b[27] = (A) => _("aspectRatio", A)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              v("div", DO, [
                b[73] || (b[73] = v("label", null, "Diffraction Fringe", -1)),
                Ne(He(ti), {
                  modelValue: n.value.iris.diffractionFringe,
                  "onUpdate:modelValue": b[28] || (b[28] = (A) => _("diffractionFringe", A)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [u0, i.iris]
            ])
          ]),
          v("div", IO, [
            v("div", {
              class: "section-header",
              onClick: b[29] || (b[29] = (A) => p("highlight"))
            }, [
              v("span", RO, ye(i.highlight ? "" : ""), 1),
              b[74] || (b[74] = ct(" Highlight ", -1))
            ]),
            st(v("div", LO, [
              v("div", FO, [
                b[75] || (b[75] = v("label", null, "Gain", -1)),
                Ne(He(ti), {
                  modelValue: n.value.highlight.gain,
                  "onUpdate:modelValue": b[30] || (b[30] = (A) => C("gain", A)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              v("div", OO, [
                b[76] || (b[76] = v("label", null, "Threshold", -1)),
                Ne(He(ti), {
                  modelValue: n.value.highlight.threshold,
                  "onUpdate:modelValue": b[31] || (b[31] = (A) => C("threshold", A)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              v("div", UO, [
                b[77] || (b[77] = v("label", null, "Saturation", -1)),
                Ne(He(ti), {
                  modelValue: n.value.highlight.saturation,
                  "onUpdate:modelValue": b[32] || (b[32] = (A) => C("saturation", A)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [u0, i.highlight]
            ])
          ]),
          v("div", zO, [
            v("div", {
              class: "section-header",
              onClick: b[33] || (b[33] = (A) => p("autoOrient"))
            }, [
              v("span", BO, ye(i.autoOrient ? "" : ""), 1),
              b[78] || (b[78] = ct(" Auto-Orient ", -1))
            ]),
            st(v("div", NO, [
              v("div", VO, [
                v("select", {
                  value: n.value.autoOrient,
                  onChange: b[34] || (b[34] = (A) => f("autoOrient", A.target.value))
                }, [...b[79] || (b[79] = [
                  v("option", { value: "off" }, "Off", -1),
                  v("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  v("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, HO)
              ])
            ], 512), [
              [u0, i.autoOrient]
            ])
          ]),
          v("div", GO, [
            v("div", {
              class: "section-header",
              onClick: b[35] || (b[35] = (A) => p("clipping"))
            }, [
              v("span", $O, ye(i.clipping ? "" : ""), 1),
              b[80] || (b[80] = ct(" Clipping ", -1))
            ]),
            st(v("div", WO, [
              v("div", jO, [
                b[81] || (b[81] = v("label", null, "Near Clip", -1)),
                Ne(He(it), {
                  modelValue: n.value.nearClip,
                  "onUpdate:modelValue": b[36] || (b[36] = (A) => f("nearClip", A)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              v("div", XO, [
                b[82] || (b[82] = v("label", null, "Far Clip", -1)),
                Ne(He(it), {
                  modelValue: n.value.farClip,
                  "onUpdate:modelValue": b[37] || (b[37] = (A) => f("farClip", A)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [u0, i.clipping]
            ])
          ]),
          v("div", YO, [
            v("div", {
              class: "section-header",
              onClick: b[38] || (b[38] = (A) => p("trajectory"))
            }, [
              v("span", qO, ye(i.trajectory ? "" : ""), 1),
              b[83] || (b[83] = ct(" Trajectory ", -1))
            ]),
            st(v("div", ZO, [
              v("div", KO, [
                b[84] || (b[84] = v("label", null, "Motion Preset", -1)),
                st(v("select", {
                  "onUpdate:modelValue": b[39] || (b[39] = (A) => o.type = A),
                  class: "trajectory-select"
                }, [
                  (se(!0), re(Xe, null, at(a.value, (A, R) => (se(), re("optgroup", {
                    key: R,
                    label: R
                  }, [
                    (se(!0), re(Xe, null, at(A, (k) => (se(), re("option", {
                      key: k,
                      value: k
                    }, ye(c(k)), 9, QO))), 128))
                  ], 8, JO))), 128))
                ], 512), [
                  [En, o.type]
                ])
              ]),
              v("div", eU, ye(r.value), 1),
              v("div", tU, [
                b[85] || (b[85] = v("label", null, "Duration (frames)", -1)),
                Ne(He(it), {
                  modelValue: o.duration,
                  "onUpdate:modelValue": b[40] || (b[40] = (A) => o.duration = A),
                  min: 1,
                  max: 600,
                  precision: 0
                }, null, 8, ["modelValue"])
              ]),
              v("div", nU, [
                b[86] || (b[86] = v("label", null, "Amplitude", -1)),
                Ne(He(ti), {
                  modelValue: Math.abs(o.amplitude),
                  "onUpdate:modelValue": b[41] || (b[41] = (A) => o.amplitude = A * Math.sign(o.amplitude || 1)),
                  min: 0.1,
                  max: 2,
                  step: 0.1
                }, null, 8, ["modelValue"])
              ]),
              l.value ? (se(), re("div", iU, [
                b[87] || (b[87] = v("label", null, "Loops", -1)),
                Ne(He(it), {
                  modelValue: o.loops,
                  "onUpdate:modelValue": b[42] || (b[42] = (A) => o.loops = A),
                  min: 0.25,
                  max: 5,
                  precision: 2
                }, null, 8, ["modelValue"])
              ])) : Te("", !0),
              v("div", sU, [
                b[89] || (b[89] = v("label", null, "Easing", -1)),
                st(v("select", {
                  "onUpdate:modelValue": b[43] || (b[43] = (A) => o.easing = A)
                }, [...b[88] || (b[88] = [
                  fs('<option value="linear" data-v-e0e3fe0b>Linear</option><option value="ease-in" data-v-e0e3fe0b>Ease In</option><option value="ease-out" data-v-e0e3fe0b>Ease Out</option><option value="ease-in-out" data-v-e0e3fe0b>Ease In-Out</option><option value="bounce" data-v-e0e3fe0b>Bounce</option>', 5)
                ])], 512), [
                  [En, o.easing]
                ])
              ]),
              v("div", oU, [
                v("label", null, [
                  st(v("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": b[44] || (b[44] = (A) => o.audioReactive = A)
                  }, null, 512), [
                    [Ci, o.audioReactive]
                  ]),
                  b[90] || (b[90] = ct(" Audio Reactive ", -1))
                ])
              ]),
              o.audioReactive ? (se(), re(Xe, { key: 1 }, [
                v("div", aU, [
                  b[92] || (b[92] = v("label", null, "Audio Feature", -1)),
                  st(v("select", {
                    "onUpdate:modelValue": b[45] || (b[45] = (A) => o.audioFeature = A)
                  }, [...b[91] || (b[91] = [
                    fs('<option value="amplitude" data-v-e0e3fe0b>Amplitude</option><option value="bass" data-v-e0e3fe0b>Bass</option><option value="mid" data-v-e0e3fe0b>Mid</option><option value="high" data-v-e0e3fe0b>High</option><option value="onsets" data-v-e0e3fe0b>Onsets</option>', 5)
                  ])], 512), [
                    [En, o.audioFeature]
                  ])
                ]),
                v("div", rU, [
                  b[93] || (b[93] = v("label", null, "Sensitivity", -1)),
                  Ne(He(ti), {
                    modelValue: o.audioSensitivity ?? 1,
                    "onUpdate:modelValue": b[46] || (b[46] = (A) => o.audioSensitivity = A),
                    min: 0.1,
                    max: 3,
                    step: 0.1
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : Te("", !0),
              v("div", { class: "trajectory-actions" }, [
                v("button", {
                  class: "action-btn preview",
                  onClick: d
                }, " Preview "),
                v("button", {
                  class: "action-btn apply",
                  onClick: h
                }, " Apply Keyframes ")
              ])
            ], 512), [
              [u0, i.trajectory]
            ])
          ])
        ])) : (se(), re("div", lU, [
          b[94] || (b[94] = v("p", null, "No camera selected", -1)),
          v("button", { onClick: P }, "Create Camera")
        ]))
      ]);
    };
  }
}), uU = /* @__PURE__ */ Vt(cU, [["__scopeId", "data-v-e0e3fe0b"]]), dU = { class: "audio-properties" }, hU = { class: "property-section" }, fU = {
  key: 0,
  class: "section-content"
}, pU = { class: "property-row" }, mU = { class: "value-display" }, vU = { class: "property-row" }, gU = { class: "value-display" }, yU = { class: "property-row" }, xU = { class: "value-display" }, bU = { class: "property-row" }, _U = {
  key: 0,
  class: "peak-count"
}, wU = { class: "property-section" }, MU = { class: "mapping-count" }, SU = {
  key: 0,
  class: "section-content"
}, CU = { class: "mapping-header" }, TU = { class: "mapping-enabled" }, EU = ["onUpdate:modelValue"], AU = { class: "mapping-name" }, PU = ["onClick"], kU = {
  key: 0,
  class: "mapping-details"
}, DU = { class: "property-row" }, IU = ["onUpdate:modelValue"], RU = ["label"], LU = ["value"], FU = { class: "property-row" }, OU = ["onUpdate:modelValue"], UU = ["label"], zU = ["value"], BU = { class: "property-row" }, NU = ["onUpdate:modelValue"], VU = { class: "value-display" }, HU = { class: "property-row" }, GU = ["onUpdate:modelValue"], $U = { class: "value-display" }, WU = { class: "property-row" }, jU = ["onUpdate:modelValue"], XU = { class: "value-display" }, YU = { class: "property-row" }, qU = ["onUpdate:modelValue"], ZU = ["onUpdate:modelValue"], KU = { class: "property-row" }, JU = ["onUpdate:modelValue"], QU = { class: "value-display" }, ez = { class: "property-row" }, tz = ["onUpdate:modelValue"], nz = { class: "value-display" }, iz = { class: "property-row" }, sz = ["onUpdate:modelValue"], oz = { class: "property-row" }, az = ["onUpdate:modelValue"], rz = {
  key: 0,
  class: "property-row"
}, lz = ["onUpdate:modelValue"], cz = { class: "value-display" }, uz = { class: "property-row checkbox-row" }, dz = ["onUpdate:modelValue"], hz = ["onClick"], fz = { class: "property-section" }, pz = {
  key: 0,
  class: "section-content"
}, mz = { class: "property-row" }, vz = ["value"], gz = { class: "visualizer-canvas-container" }, yz = { class: "visualizer-value" }, xz = /* @__PURE__ */ Bt({
  __name: "AudioProperties",
  setup(s) {
    const e = un(), n = xe(/* @__PURE__ */ new Set(["peaks", "mappings"])), i = xe(/* @__PURE__ */ new Set()), o = xe({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    }), a = xe(null), r = xe([]), l = xe("amplitude"), c = xe(null), u = Re(() => lM()), d = Re(() => cM()), h = Re(() => uM()), p = Re(
      () => e.currentFrame / e.frameCount * 100
    ), f = Re(() => e.audioAnalysis ? Li(e.audioAnalysis, l.value, e.currentFrame) : 0);
    function m(_) {
      n.value.has(_) ? n.value.delete(_) : n.value.add(_);
    }
    function y(_) {
      i.value.has(_) ? i.value.delete(_) : i.value.add(_);
    }
    function g() {
      if (!e.audioAnalysis) return;
      const _ = e.audioAnalysis.amplitudeEnvelope;
      a.value = G3(_, o.value), e.setPeakData(a.value);
    }
    function x() {
      const _ = aM();
      r.value.push(_), i.value.add(_.id), e.addAudioMapping(_);
    }
    function w(_) {
      const C = r.value.findIndex((T) => T.id === _);
      C >= 0 && (r.value.splice(C, 1), i.value.delete(_), e.removeAudioMapping(_));
    }
    function M() {
      var S, A;
      const _ = c.value;
      if (!_ || !e.audioAnalysis) return;
      const C = _.getContext("2d");
      if (!C) return;
      const T = _.width, P = _.height;
      C.fillStyle = "#1e1e1e", C.fillRect(0, 0, T, P);
      let E = [];
      const b = e.audioAnalysis;
      switch (l.value) {
        case "amplitude":
          E = b.amplitudeEnvelope;
          break;
        case "rms":
          E = b.rmsEnergy;
          break;
        case "spectralCentroid":
          E = b.spectralCentroid;
          break;
        case "bass":
          E = b.frequencyBands.bass;
          break;
        case "mid":
          E = b.frequencyBands.mid;
          break;
        case "high":
          E = b.frequencyBands.high;
          break;
        case "sub":
          E = b.frequencyBands.sub;
          break;
        case "lowMid":
          E = b.frequencyBands.lowMid;
          break;
        case "highMid":
          E = b.frequencyBands.highMid;
          break;
        case "spectralFlux":
          E = b.spectralFlux || [];
          break;
        case "zeroCrossingRate":
          E = b.zeroCrossingRate || [];
          break;
        case "spectralRolloff":
          E = b.spectralRolloff || [];
          break;
        case "spectralFlatness":
          E = b.spectralFlatness || [];
          break;
        case "chromaEnergy":
          E = ((S = b.chromaFeatures) == null ? void 0 : S.chromaEnergy) || [];
          break;
        case "chromaC":
        case "chromaCs":
        case "chromaD":
        case "chromaDs":
        case "chromaE":
        case "chromaF":
        case "chromaFs":
        case "chromaG":
        case "chromaGs":
        case "chromaA":
        case "chromaAs":
        case "chromaB":
          if ((A = b.chromaFeatures) != null && A.chroma) {
            const R = [
              "chromaC",
              "chromaCs",
              "chromaD",
              "chromaDs",
              "chromaE",
              "chromaF",
              "chromaFs",
              "chromaG",
              "chromaGs",
              "chromaA",
              "chromaAs",
              "chromaB"
            ].indexOf(l.value);
            E = b.chromaFeatures.chroma.map((k) => k[R] || 0);
          }
          break;
        case "onsets":
          E = new Array(b.frameCount).fill(0);
          for (const R of b.onsets)
            R < E.length && (E[R] = 1);
          break;
        case "peaks":
          if (a.value) {
            E = new Array(b.frameCount).fill(0);
            for (const R of a.value.indices)
              R < E.length && (E[R] = 1);
          }
          break;
      }
      if (E.length !== 0) {
        C.strokeStyle = "#4a90d9", C.lineWidth = 1.5, C.beginPath();
        for (let R = 0; R < E.length; R++) {
          const k = R / E.length * T, U = P - E[R] * P * 0.9 - 5;
          R === 0 ? C.moveTo(k, U) : C.lineTo(k, U);
        }
        if (C.stroke(), a.value && l.value !== "peaks") {
          C.fillStyle = "#ff6b6b";
          for (const R of a.value.indices) {
            const k = R / E.length * T;
            C.beginPath(), C.moveTo(k, 0), C.lineTo(k, P), C.strokeStyle = "rgba(255, 107, 107, 0.3)", C.stroke();
          }
        }
      }
    }
    return Ft(
      () => [e.audioAnalysis, l.value, a.value],
      () => {
        M();
      }
    ), Ft(
      r,
      (_) => {
        for (const C of _)
          e.updateAudioMapping(C.id, C);
      },
      { deep: !0 }
    ), gn(() => {
      M();
      const _ = e.getAudioMappings();
      _.length > 0 && (r.value = [..._]);
    }), (_, C) => (se(), re("div", dU, [
      v("div", hU, [
        v("div", {
          class: "section-header",
          onClick: C[0] || (C[0] = (T) => m("peaks"))
        }, [
          v("i", {
            class: Le(["pi", n.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[7] || (C[7] = v("span", null, "Peak Detection", -1))
        ]),
        n.value.has("peaks") ? (se(), re("div", fU, [
          v("div", pU, [
            C[8] || (C[8] = v("label", null, "Threshold", -1)),
            st(v("input", {
              type: "range",
              "onUpdate:modelValue": C[1] || (C[1] = (T) => o.value.threshold = T),
              min: "0",
              max: "1",
              step: "0.01"
            }, null, 512), [
              [
                Ot,
                o.value.threshold,
                void 0,
                { number: !0 }
              ]
            ]),
            v("span", mU, ye(o.value.threshold.toFixed(2)), 1)
          ]),
          v("div", vU, [
            C[9] || (C[9] = v("label", null, "Min Peak Distance", -1)),
            st(v("input", {
              type: "range",
              "onUpdate:modelValue": C[2] || (C[2] = (T) => o.value.minPeaksDistance = T),
              min: "1",
              max: "60",
              step: "1"
            }, null, 512), [
              [
                Ot,
                o.value.minPeaksDistance,
                void 0,
                { number: !0 }
              ]
            ]),
            v("span", gU, ye(o.value.minPeaksDistance) + " frames", 1)
          ]),
          v("div", yU, [
            C[10] || (C[10] = v("label", null, "Multiply", -1)),
            st(v("input", {
              type: "range",
              "onUpdate:modelValue": C[3] || (C[3] = (T) => o.value.multiply = T),
              min: "0.1",
              max: "5",
              step: "0.1"
            }, null, 512), [
              [
                Ot,
                o.value.multiply,
                void 0,
                { number: !0 }
              ]
            ]),
            v("span", xU, ye(o.value.multiply.toFixed(1)) + "x", 1)
          ]),
          v("div", bU, [
            v("button", {
              class: "action-btn",
              onClick: g
            }, [...C[11] || (C[11] = [
              v("i", { class: "pi pi-bolt" }, null, -1),
              ct(" Detect Peaks ", -1)
            ])]),
            a.value ? (se(), re("span", _U, ye(a.value.count) + " peaks found ", 1)) : Te("", !0)
          ])
        ])) : Te("", !0)
      ]),
      v("div", wU, [
        v("div", {
          class: "section-header",
          onClick: C[4] || (C[4] = (T) => m("mappings"))
        }, [
          v("i", {
            class: Le(["pi", n.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[12] || (C[12] = v("span", null, "Audio Mappings", -1)),
          v("span", MU, ye(r.value.length), 1)
        ]),
        n.value.has("mappings") ? (se(), re("div", SU, [
          v("button", {
            class: "action-btn add-mapping-btn",
            onClick: x
          }, [...C[13] || (C[13] = [
            v("i", { class: "pi pi-plus" }, null, -1),
            ct(" Add Mapping ", -1)
          ])]),
          (se(!0), re(Xe, null, at(r.value, (T) => {
            var P, E, b;
            return se(), re("div", {
              key: T.id,
              class: "mapping-item"
            }, [
              v("div", CU, [
                v("label", TU, [
                  st(v("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": (S) => T.enabled = S
                  }, null, 8, EU), [
                    [Ci, T.enabled]
                  ])
                ]),
                v("span", AU, ye(He(k1)(T.feature)) + "  " + ye(He(E2)(T.target)), 1),
                v("button", {
                  class: "delete-btn",
                  onClick: (S) => w(T.id)
                }, [...C[14] || (C[14] = [
                  v("i", { class: "pi pi-times" }, null, -1)
                ])], 8, PU)
              ]),
              i.value.has(T.id) ? (se(), re("div", kU, [
                v("div", DU, [
                  C[15] || (C[15] = v("label", null, "Feature", -1)),
                  st(v("select", {
                    "onUpdate:modelValue": (S) => T.feature = S
                  }, [
                    (se(!0), re(Xe, null, at(d.value, (S, A) => (se(), re("optgroup", {
                      key: A,
                      label: A
                    }, [
                      (se(!0), re(Xe, null, at(S, (R) => (se(), re("option", {
                        key: R,
                        value: R
                      }, ye(He(k1)(R)), 9, LU))), 128))
                    ], 8, RU))), 128))
                  ], 8, IU), [
                    [En, T.feature]
                  ])
                ]),
                v("div", FU, [
                  C[16] || (C[16] = v("label", null, "Target", -1)),
                  st(v("select", {
                    "onUpdate:modelValue": (S) => T.target = S
                  }, [
                    (se(!0), re(Xe, null, at(h.value, (S, A) => (se(), re("optgroup", {
                      key: A,
                      label: A
                    }, [
                      (se(!0), re(Xe, null, at(S, (R) => (se(), re("option", {
                        key: R,
                        value: R
                      }, ye(He(E2)(R)), 9, zU))), 128))
                    ], 8, UU))), 128))
                  ], 8, OU), [
                    [En, T.target]
                  ])
                ]),
                C[30] || (C[30] = v("div", { class: "subsection-header" }, "Basic Controls", -1)),
                v("div", BU, [
                  C[17] || (C[17] = v("label", null, "Sensitivity", -1)),
                  st(v("input", {
                    type: "range",
                    "onUpdate:modelValue": (S) => T.sensitivity = S,
                    min: "0.1",
                    max: "5",
                    step: "0.1"
                  }, null, 8, NU), [
                    [
                      Ot,
                      T.sensitivity,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  v("span", VU, ye(T.sensitivity.toFixed(1)) + "x", 1)
                ]),
                v("div", HU, [
                  C[18] || (C[18] = v("label", null, "Threshold", -1)),
                  st(v("input", {
                    type: "range",
                    "onUpdate:modelValue": (S) => T.threshold = S,
                    min: "0",
                    max: "1",
                    step: "0.01"
                  }, null, 8, GU), [
                    [
                      Ot,
                      T.threshold,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  v("span", $U, ye(T.threshold.toFixed(2)), 1)
                ]),
                v("div", WU, [
                  C[19] || (C[19] = v("label", null, "Smoothing", -1)),
                  st(v("input", {
                    type: "range",
                    "onUpdate:modelValue": (S) => T.smoothing = S,
                    min: "0",
                    max: "0.99",
                    step: "0.01"
                  }, null, 8, jU), [
                    [
                      Ot,
                      T.smoothing,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  v("span", XU, ye(T.smoothing.toFixed(2)), 1)
                ]),
                v("div", YU, [
                  C[20] || (C[20] = v("label", null, "Min/Max", -1)),
                  st(v("input", {
                    type: "number",
                    "onUpdate:modelValue": (S) => T.min = S,
                    step: "0.1",
                    class: "small-input"
                  }, null, 8, qU), [
                    [
                      Ot,
                      T.min,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  C[21] || (C[21] = v("span", { class: "separator" }, "-", -1)),
                  st(v("input", {
                    type: "number",
                    "onUpdate:modelValue": (S) => T.max = S,
                    step: "0.1",
                    class: "small-input"
                  }, null, 8, ZU), [
                    [
                      Ot,
                      T.max,
                      void 0,
                      { number: !0 }
                    ]
                  ])
                ]),
                C[31] || (C[31] = v("div", { class: "subsection-header" }, "ATI-Style Effects", -1)),
                v("div", KU, [
                  C[22] || (C[22] = v("label", { title: ">1 = expander (emphasize loud), <1 = compressor (boost quiet)" }, "Amp Curve", -1)),
                  st(v("input", {
                    type: "range",
                    "onUpdate:modelValue": (S) => T.amplitudeCurve = S,
                    min: "0.1",
                    max: "4",
                    step: "0.1"
                  }, null, 8, JU), [
                    [
                      Ot,
                      T.amplitudeCurve,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  v("span", QU, ye(((P = T.amplitudeCurve) == null ? void 0 : P.toFixed(1)) || "1.0"), 1)
                ]),
                v("div", ez, [
                  C[23] || (C[23] = v("label", { title: "How slowly the value decays after a peak (0=instant, 1=slow)" }, "Release", -1)),
                  st(v("input", {
                    type: "range",
                    "onUpdate:modelValue": (S) => T.release = S,
                    min: "0",
                    max: "1",
                    step: "0.01"
                  }, null, 8, tz), [
                    [
                      Ot,
                      T.release,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  v("span", nz, ye(((E = T.release) == null ? void 0 : E.toFixed(2)) || "0.50"), 1)
                ]),
                v("div", iz, [
                  C[25] || (C[25] = v("label", null, "Curve", -1)),
                  st(v("select", {
                    "onUpdate:modelValue": (S) => T.curve = S,
                    class: "curve-select"
                  }, [...C[24] || (C[24] = [
                    fs('<option value="linear" data-v-0611c34c>Linear</option><option value="exponential" data-v-0611c34c>Exponential</option><option value="logarithmic" data-v-0611c34c>Logarithmic</option><option value="smoothstep" data-v-0611c34c>Smoothstep</option><option value="bounce" data-v-0611c34c>Bounce</option>', 5)
                  ])], 8, sz), [
                    [En, T.curve]
                  ])
                ]),
                C[32] || (C[32] = v("div", { class: "subsection-header" }, "Beat Response", -1)),
                v("div", oz, [
                  C[27] || (C[27] = v("label", null, "On Beat", -1)),
                  st(v("select", {
                    "onUpdate:modelValue": (S) => T.beatResponse = S,
                    class: "beat-select"
                  }, [...C[26] || (C[26] = [
                    v("option", { value: "none" }, "None", -1),
                    v("option", { value: "flip" }, "Flip (reverse direction)", -1),
                    v("option", { value: "pulse" }, "Pulse (spike to max)", -1),
                    v("option", { value: "toggle" }, "Toggle (0/1 switch)", -1)
                  ])], 8, az), [
                    [En, T.beatResponse]
                  ])
                ]),
                T.beatResponse !== "none" ? (se(), re("div", rz, [
                  C[28] || (C[28] = v("label", { title: "Lower = more sensitive to quieter beats" }, "Beat Sens.", -1)),
                  st(v("input", {
                    type: "range",
                    "onUpdate:modelValue": (S) => T.beatThreshold = S,
                    min: "0.01",
                    max: "1",
                    step: "0.01"
                  }, null, 8, lz), [
                    [
                      Ot,
                      T.beatThreshold,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  v("span", cz, ye(((b = T.beatThreshold) == null ? void 0 : b.toFixed(2)) || "0.50"), 1)
                ])) : Te("", !0),
                v("div", uz, [
                  v("label", null, [
                    st(v("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": (S) => T.invert = S
                    }, null, 8, dz), [
                      [Ci, T.invert]
                    ]),
                    C[29] || (C[29] = ct(" Invert Output ", -1))
                  ])
                ])
              ])) : Te("", !0),
              v("button", {
                class: "expand-btn",
                onClick: (S) => y(T.id)
              }, [
                v("i", {
                  class: Le(["pi", i.value.has(T.id) ? "pi-chevron-up" : "pi-chevron-down"])
                }, null, 2)
              ], 8, hz)
            ]);
          }), 128))
        ])) : Te("", !0)
      ]),
      v("div", fz, [
        v("div", {
          class: "section-header",
          onClick: C[5] || (C[5] = (T) => m("visualizer"))
        }, [
          v("i", {
            class: Le(["pi", n.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          C[33] || (C[33] = v("span", null, "Feature Visualizer", -1))
        ]),
        n.value.has("visualizer") ? (se(), re("div", pz, [
          v("div", mz, [
            C[34] || (C[34] = v("label", null, "Feature", -1)),
            st(v("select", {
              "onUpdate:modelValue": C[6] || (C[6] = (T) => l.value = T)
            }, [
              (se(!0), re(Xe, null, at(u.value, (T) => (se(), re("option", {
                key: T,
                value: T
              }, ye(He(k1)(T)), 9, vz))), 128))
            ], 512), [
              [En, l.value]
            ])
          ]),
          v("div", gz, [
            v("canvas", {
              ref_key: "visualizerCanvas",
              ref: c,
              class: "visualizer-canvas",
              width: "240",
              height: "60"
            }, null, 512),
            v("div", {
              class: "visualizer-playhead",
              style: xt({ left: `${p.value}%` })
            }, null, 4)
          ]),
          v("div", yz, " Current: " + ye(f.value.toFixed(3)), 1)
        ])) : Te("", !0)
      ])
    ]));
  }
}), bz = /* @__PURE__ */ Vt(xz, [["__scopeId", "data-v-0611c34c"]]), _z = { class: "audio-panel" }, wz = {
  key: 0,
  class: "panel-content"
}, Mz = { class: "audio-info" }, Sz = { class: "file-info" }, Cz = { class: "file-details" }, Tz = { class: "file-name" }, Ez = { class: "file-meta" }, Az = { class: "control-section" }, Pz = { class: "control-row" }, kz = { class: "waveform-section" }, Dz = { class: "waveform-display" }, Iz = { class: "linker-section" }, Rz = {
  key: 1,
  class: "empty-state"
}, Lz = /* @__PURE__ */ Bt({
  __name: "AudioPanel",
  setup(s) {
    const e = un(), n = xe(null), i = xe(null), o = xe(100), a = xe(!1), r = Re(() => !!e.audioBuffer), l = Re(() => {
      var y;
      return ((y = e.audioFile) == null ? void 0 : y.name) || "Unknown";
    }), c = Re(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : ""), u = Re(() => {
      if (!e.audioBuffer) return "0:00";
      const y = Math.floor(e.audioBuffer.duration / 60), g = Math.floor(e.audioBuffer.duration % 60);
      return `${y}:${g.toString().padStart(2, "0")}`;
    });
    function d() {
      var y;
      (y = n.value) == null || y.click();
    }
    async function h(y) {
      var x;
      const g = y.target;
      (x = g.files) != null && x.length && await e.loadAudio(g.files[0]), g.value = "";
    }
    function p() {
      e.clearAudio();
    }
    function f() {
      a.value = !a.value;
    }
    function m() {
      if (!i.value || !e.audioBuffer) return;
      const y = i.value, g = y.getContext("2d");
      if (!g) return;
      const x = y.getBoundingClientRect();
      y.width = x.width * window.devicePixelRatio, y.height = 60 * window.devicePixelRatio, g.scale(window.devicePixelRatio, window.devicePixelRatio);
      const w = e.audioBuffer.getChannelData(0), M = Math.ceil(w.length / x.width), _ = 30;
      g.fillStyle = "#1a1a1a", g.fillRect(0, 0, x.width, 60), g.beginPath(), g.strokeStyle = "#4a90d9", g.lineWidth = 1;
      for (let T = 0; T < x.width; T++) {
        let P = 1, E = -1;
        for (let b = 0; b < M; b++) {
          const S = w[T * M + b];
          S < P && (P = S), S > E && (E = S);
        }
        g.moveTo(T, (1 + P) * _), g.lineTo(T, (1 + E) * _);
      }
      g.stroke();
      const C = e.currentFrame / e.frameCount * x.width;
      g.fillStyle = "#fff", g.fillRect(C, 0, 1, 60);
    }
    return Ft(() => [e.audioBuffer, e.currentFrame], m), gn(() => {
      r.value && setTimeout(m, 100);
    }), (y, g) => (se(), re("div", _z, [
      v("div", { class: "panel-header" }, [
        g[2] || (g[2] = v("span", { class: "panel-title" }, "Audio Source", -1)),
        v("div", { class: "header-actions" }, [
          v("button", {
            onClick: d,
            title: "Load Audio"
          }, [...g[1] || (g[1] = [
            v("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      r.value ? (se(), re("div", wz, [
        v("div", Mz, [
          v("div", Sz, [
            g[3] || (g[3] = v("span", { class: "file-icon" }, "", -1)),
            v("div", Cz, [
              v("span", Tz, ye(l.value), 1),
              v("span", Ez, ye(u.value) + "  " + ye(c.value), 1)
            ]),
            v("button", {
              class: "remove-btn",
              onClick: p,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        v("div", Az, [
          v("div", Pz, [
            g[4] || (g[4] = v("label", null, "Master Vol", -1)),
            Ne(He(ti), {
              modelValue: o.value,
              "onUpdate:modelValue": g[0] || (g[0] = (x) => o.value = x),
              min: 0,
              max: 100,
              unit: "%"
            }, null, 8, ["modelValue"]),
            v("button", {
              class: Le(["mute-btn", { active: a.value }]),
              onClick: f,
              title: "Mute"
            }, ye(a.value ? "" : ""), 3)
          ])
        ]),
        v("div", kz, [
          g[5] || (g[5] = v("div", { class: "section-header" }, [
            v("span", { class: "section-title" }, "Waveform")
          ], -1)),
          v("div", Dz, [
            v("canvas", {
              ref_key: "waveformCanvas",
              ref: i,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        v("div", Iz, [
          g[6] || (g[6] = v("div", { class: "linker-header" }, "Audio Linker", -1)),
          Ne(bz)
        ])
      ])) : (se(), re("div", Rz, [
        g[7] || (g[7] = v("div", { class: "empty-icon" }, "", -1)),
        g[8] || (g[8] = v("p", null, "No audio loaded", -1)),
        v("button", {
          class: "load-btn",
          onClick: d
        }, "Load Audio File"),
        g[9] || (g[9] = v("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      v("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: h
      }, null, 544)
    ]));
  }
}), Fz = /* @__PURE__ */ Vt(Lz, [["__scopeId", "data-v-66384e06"]]), k2 = 40, Oz = 30;
function Uz(s) {
  const e = [], n = "#ffcc00", i = s.position;
  let o;
  if (s.type === "two-node")
    o = Qs($h(s.pointOfInterest, i));
  else {
    const f = s.orientation.x * Math.PI / 180, m = s.orientation.y * Math.PI / 180;
    o = Ct(
      Math.sin(m) * Math.cos(f),
      -Math.sin(f),
      Math.cos(m) * Math.cos(f)
    );
  }
  const a = Ct(0, -1, 0);
  let r = Qs(ya(o, a));
  isNaN(r.x) && (r = Ct(1, 0, 0));
  const l = Qs(ya(r, o)), c = k2 / 2, u = It(i, Lt(o, -k2)), d = [];
  for (let f = 0; f < 2; f++) {
    const m = f === 0 ? i : u;
    for (let y = -1; y <= 1; y += 2)
      for (let g = -1; g <= 1; g += 2)
        d.push(It(
          It(m, Lt(r, y * c)),
          Lt(l, g * c)
        ));
  }
  e.push({ start: d[0], end: d[1], color: n }), e.push({ start: d[1], end: d[3], color: n }), e.push({ start: d[3], end: d[2], color: n }), e.push({ start: d[2], end: d[0], color: n }), e.push({ start: d[4], end: d[5], color: n }), e.push({ start: d[5], end: d[7], color: n }), e.push({ start: d[7], end: d[6], color: n }), e.push({ start: d[6], end: d[4], color: n }), e.push({ start: d[0], end: d[4], color: n }), e.push({ start: d[1], end: d[5], color: n }), e.push({ start: d[2], end: d[6], color: n }), e.push({ start: d[3], end: d[7], color: n });
  const h = It(i, Lt(o, Oz)), p = 8;
  for (let f = 0; f < p; f++) {
    const m = f / p * Math.PI * 2, y = (f + 1) / p * Math.PI * 2, g = It(
      It(i, Lt(r, Math.cos(m) * c * 0.5)),
      Lt(l, Math.sin(m) * c * 0.5)
    ), x = It(
      It(i, Lt(r, Math.cos(y) * c * 0.5)),
      Lt(l, Math.sin(y) * c * 0.5)
    );
    e.push({ start: g, end: x, color: n }), e.push({ start: g, end: h, color: n });
  }
  return e;
}
function zz(s, e, n, i = 2e3) {
  const o = [], a = "#7c9cff", r = Jr(s.focalLength, s.filmSize), l = e / n, c = s.position;
  let u;
  if (s.type === "two-node")
    u = Qs($h(s.pointOfInterest, c));
  else {
    const P = s.orientation.x * Math.PI / 180, E = s.orientation.y * Math.PI / 180;
    u = Ct(
      Math.sin(E) * Math.cos(P),
      -Math.sin(P),
      Math.cos(E) * Math.cos(P)
    );
  }
  const d = Ct(0, -1, 0);
  let h = Qs(ya(u, d));
  isNaN(h.x) && (h = Ct(1, 0, 0));
  const p = Qs(ya(h, u)), f = s.nearClip, m = Math.min(s.farClip, i), y = f * Math.tan(r * Math.PI / 360), g = y * l, x = m * Math.tan(r * Math.PI / 360), w = x * l, M = It(c, Lt(u, f)), _ = [
    It(It(M, Lt(h, -g)), Lt(p, y)),
    It(It(M, Lt(h, g)), Lt(p, y)),
    It(It(M, Lt(h, g)), Lt(p, -y)),
    It(It(M, Lt(h, -g)), Lt(p, -y))
  ], C = It(c, Lt(u, m)), T = [
    It(It(C, Lt(h, -w)), Lt(p, x)),
    It(It(C, Lt(h, w)), Lt(p, x)),
    It(It(C, Lt(h, w)), Lt(p, -x)),
    It(It(C, Lt(h, -w)), Lt(p, -x))
  ];
  for (let P = 0; P < 4; P++)
    o.push({ start: _[P], end: _[(P + 1) % 4], color: a });
  for (let P = 0; P < 4; P++)
    o.push({ start: T[P], end: T[(P + 1) % 4], color: a });
  for (let P = 0; P < 4; P++)
    o.push({ start: _[P], end: T[P], color: a });
  return o;
}
function Bz(s, e) {
  const n = "#00ff88", i = [
    Ct(0, 0, 0),
    Ct(s, 0, 0),
    Ct(s, e, 0),
    Ct(0, e, 0)
  ], o = [];
  for (let a = 0; a < 4; a++)
    o.push({ start: i[a], end: i[(a + 1) % 4], color: n });
  return o.push({ start: i[0], end: i[2], color: "#005533" }), o.push({ start: i[1], end: i[3], color: "#005533" }), o;
}
function Nz(s) {
  return s.type !== "two-node" ? null : {
    start: s.position,
    end: s.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function Vz(s, e, n) {
  if (!s.depthOfField.enabled)
    return [];
  const i = "#ff00ff", o = [], a = s.position, r = s.depthOfField.focusDistance;
  let l;
  if (s.type === "two-node")
    l = Qs($h(s.pointOfInterest, a));
  else {
    const y = s.orientation.x * Math.PI / 180, g = s.orientation.y * Math.PI / 180;
    l = Ct(
      Math.sin(g) * Math.cos(y),
      -Math.sin(y),
      Math.cos(g) * Math.cos(y)
    );
  }
  const c = Ct(0, -1, 0);
  let u = Qs(ya(l, c));
  isNaN(u.x) && (u = Ct(1, 0, 0));
  const d = Qs(ya(u, l)), h = It(a, Lt(l, r)), p = e / 4, f = n / 4, m = [
    It(It(h, Lt(u, -p)), Lt(d, f)),
    It(It(h, Lt(u, p)), Lt(d, f)),
    It(It(h, Lt(u, p)), Lt(d, -f)),
    It(It(h, Lt(u, -p)), Lt(d, -f))
  ];
  for (let y = 0; y < 4; y++)
    o.push({ start: m[y], end: m[(y + 1) % 4], color: i });
  return o;
}
function D2(s, e, n, i = !0, o = !0, a = !1) {
  return {
    body: Uz(s),
    frustum: i ? zz(s, e, n) : [],
    compositionBounds: o ? Bz(e, n) : [],
    poiLine: Nz(s),
    focalPlane: a ? Vz(s, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function Hz(s, e, n) {
  const i = e / n, o = Jr(s.focalLength, s.filmSize);
  let a;
  if (s.type === "two-node")
    a = s.pointOfInterest;
  else {
    const u = s.orientation.x * Math.PI / 180, d = s.orientation.y * Math.PI / 180, h = Ct(
      Math.sin(d) * Math.cos(u),
      -Math.sin(u),
      Math.cos(d) * Math.cos(u)
    );
    a = It(s.position, Lt(h, 1e3));
  }
  const r = xs(s.position, a, Ct(0, -1, 0)), l = Vw(o, i, s.nearClip, s.farClip), c = Qm(l, r);
  return { view: r, projection: l, viewProjection: c };
}
function I2(s, e, n, i) {
  const o = e / n;
  let a, r = 1e3;
  const l = e / 2, c = n / 2;
  switch (s) {
    case "front":
      a = xs(
        Ct(l, c, -2e3),
        Ct(l, c, 0),
        Ct(0, -1, 0)
      );
      break;
    case "back":
      a = xs(
        Ct(l, c, 2e3),
        Ct(l, c, 0),
        Ct(0, -1, 0)
      );
      break;
    case "left":
      a = xs(
        Ct(-2e3, c, 0),
        Ct(l, c, 0),
        Ct(0, -1, 0)
      );
      break;
    case "right":
      a = xs(
        Ct(l + 2e3, c, 0),
        Ct(l, c, 0),
        Ct(0, -1, 0)
      );
      break;
    case "top":
      a = xs(
        Ct(l, -2e3, 0),
        Ct(l, c, 0),
        Ct(0, 0, 1)
      );
      break;
    case "bottom":
      a = xs(
        Ct(l, c + 2e3, 0),
        Ct(l, c, 0),
        Ct(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (i) {
        const h = i.orbitPhi * Math.PI / 180, p = i.orbitTheta * Math.PI / 180, f = i.orbitDistance, m = Ct(
          i.orbitCenter.x + f * Math.sin(h) * Math.sin(p),
          i.orbitCenter.y + f * Math.cos(h),
          i.orbitCenter.z + f * Math.sin(h) * Math.cos(p)
        );
        a = xs(
          m,
          i.orbitCenter,
          Ct(0, -1, 0)
        ), r = 1e3 / i.orthoZoom;
      } else
        a = xs(
          Ct(l, c, -2e3),
          Ct(l, c, 0),
          Ct(0, -1, 0)
        );
      break;
    default:
      a = xs(
        Ct(l, c, -2e3),
        Ct(l, c, 0),
        Ct(0, -1, 0)
      );
  }
  const u = Hw(
    -r * o,
    r * o,
    -r,
    r,
    1,
    1e4
  ), d = Qm(u, a);
  return { view: a, projection: u, viewProjection: d };
}
function Qm(s, e) {
  const n = s.elements, i = e.elements, o = new Float32Array(16);
  for (let a = 0; a < 4; a++)
    for (let r = 0; r < 4; r++) {
      let l = 0;
      for (let c = 0; c < 4; c++)
        l += n[a + c * 4] * i[c + r * 4];
      o[a + r * 4] = l;
    }
  return { elements: o };
}
function D1(s, e, n, i) {
  const o = Gw(e, s), a = e.elements, r = s.x * a[3] + s.y * a[7] + s.z * a[11] + a[15];
  if (r <= 0)
    return { x: 0, y: 0, z: o.z, visible: !1 };
  const l = (o.x / r * 0.5 + 0.5) * n, c = (-o.y / r * 0.5 + 0.5) * i;
  return {
    x: l,
    y: c,
    z: o.z / r,
    visible: !0
  };
}
function Gz(s, e = 100) {
  return [
    { start: s, end: It(s, Ct(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: s, end: It(s, Ct(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: s, end: It(s, Ct(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function $z(s, e, n = 100) {
  const i = [], o = "#333333", a = "#444444", r = s / 2, l = e / 2, c = Math.max(s, e);
  for (let u = -c; u <= c + s; u += n) {
    const d = Math.abs(u - r) < n / 2;
    i.push({
      start: Ct(u, -c, 0),
      end: Ct(u, c + e, 0),
      color: d ? a : o
    });
  }
  for (let u = -c; u <= c + e; u += n) {
    const d = Math.abs(u - l) < n / 2;
    i.push({
      start: Ct(-c, u, 0),
      end: Ct(c + s, u, 0),
      color: d ? a : o
    });
  }
  return i;
}
const Wz = ["onClick"], jz = { class: "view-header" }, Xz = ["value", "onChange"], Yz = { class: "view-tools" }, qz = ["onClick"], Zz = ["onMousedown", "onWheel"], Kz = { class: "view-info" }, Jz = { class: "view-name" }, Qz = {
  key: 0,
  class: "view-coords"
}, eB = { class: "layout-controls" }, tB = ["onClick", "title"], nB = /* @__PURE__ */ Bt({
  __name: "ViewportRenderer",
  setup(s) {
    const e = un(), n = Re(() => e.activeCamera), i = Re(() => e.width), o = Re(() => e.height), a = Re(() => e.viewportState), r = Re(() => e.viewOptions), l = Re(() => e.layers.filter((G) => G.type !== "camera").map((G) => ({
      id: G.id,
      name: G.name,
      position: {
        x: G.transform.position.value.x,
        y: G.transform.position.value.y,
        z: 0
        // 2D layers at z=0
      },
      selected: e.selectedLayerIds.includes(G.id)
    }))), c = xe([null, null, null, null]), u = xe([null, null, null, null]), d = xe(!1), h = xe({ x: 0, y: 0 }), p = xe(0), f = xe(0), m = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], y = Re(() => a.value.layout), g = Re(() => a.value.activeViewIndex), x = Re(() => a.value.customViews), w = Re(() => {
      switch (a.value.layout) {
        case "1-view":
          return [a.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return a.value.views.slice(0, 2);
        case "4-view":
          return a.value.views.slice(0, 4);
        default:
          return [a.value.views[0]];
      }
    });
    function M(G, Q) {
      c.value[Q] = G, G && (u.value[Q] = G.getContext("2d"));
    }
    function _(G) {
      return G.startsWith("custom-");
    }
    function C(G) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[G];
    }
    function T(G) {
      e.updateViewportState({
        activeViewIndex: G
      });
    }
    function P(G, Q) {
      const K = [...a.value.views];
      K[G] = Q, e.updateViewportState({
        views: K
      });
    }
    function E(G) {
      const Q = ["active-camera", "top", "front", "right"];
      let K = [...a.value.views];
      for (; K.length < 4; )
        K.push(Q[K.length] || "front");
      e.updateViewportState({
        layout: G,
        views: K,
        activeViewIndex: Math.min(a.value.activeViewIndex, b(G) - 1)
      });
    }
    function b(G) {
      switch (G) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function S(G) {
      const Q = {
        orbitCenter: { x: i.value / 2, y: o.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      e.updateViewportState({
        customViews: {
          ...a.value.customViews,
          [G]: Q
        }
      });
    }
    function A(G, Q) {
      d.value = !0, h.value = { x: G.clientX, y: G.clientY }, p.value = Q, f.value = G.button, document.addEventListener("mousemove", R), document.addEventListener("mouseup", k);
    }
    function R(G) {
      if (!d.value) return;
      const Q = G.clientX - h.value.x, K = G.clientY - h.value.y;
      h.value = { x: G.clientX, y: G.clientY };
      const Y = w.value[p.value];
      if (_(Y)) {
        const ee = x.value[Y];
        if (f.value === 0) {
          const ce = ee.orbitTheta + Q * 0.5, ae = Math.max(1, Math.min(179, ee.orbitPhi + K * 0.5));
          e.updateViewportState({
            customViews: {
              ...a.value.customViews,
              [Y]: {
                ...ee,
                orbitTheta: ce,
                orbitPhi: ae
              }
            }
          });
        } else (f.value === 1 || f.value === 2) && e.updateViewportState({
          customViews: {
            ...a.value.customViews,
            [Y]: {
              ...ee,
              orthoOffset: {
                x: ee.orthoOffset.x + Q,
                y: ee.orthoOffset.y + K
              }
            }
          }
        });
      }
    }
    function k() {
      d.value = !1, document.removeEventListener("mousemove", R), document.removeEventListener("mouseup", k);
    }
    function U(G, Q) {
      G.preventDefault();
      const K = w.value[Q];
      if (_(K)) {
        const Y = x.value[K], ee = G.deltaY > 0 ? 1.1 : 0.9;
        e.updateViewportState({
          customViews: {
            ...a.value.customViews,
            [K]: {
              ...Y,
              orbitDistance: Y.orbitDistance * ee
            }
          }
        });
      }
    }
    function I() {
      w.value.forEach((G, Q) => {
        const K = c.value[Q], Y = u.value[Q];
        if (!K || !Y) return;
        const ee = K.getBoundingClientRect(), ce = window.devicePixelRatio || 1;
        K.width = ee.width * ce, K.height = ee.height * ce, Y.scale(ce, ce), Y.fillStyle = "#1a1a1a", Y.fillRect(0, 0, ee.width, ee.height);
        let ae;
        G === "active-camera" && n.value ? ae = Hz(n.value, i.value, o.value) : _(G) ? ae = I2(G, i.value, o.value, x.value[G]) : ae = I2(G, i.value, o.value);
        const de = [];
        if (r.value.showGrid && de.push(...$z(i.value, o.value)), r.value.show3DReferenceAxes && de.push(...Gz(Ct(i.value / 2, o.value / 2, 0))), r.value.showCompositionBounds) {
          const ie = D2(
            n.value ?? W(),
            i.value,
            o.value,
            !1,
            !0,
            !1
          );
          de.push(...ie.compositionBounds);
        }
        if (G !== "active-camera" && n.value && (r.value.cameraWireframes === "always" || r.value.cameraWireframes === "selected")) {
          const he = D2(
            n.value,
            i.value,
            o.value,
            !0,
            !1,
            r.value.showFocalPlane
          );
          de.push(...he.body), de.push(...he.frustum), de.push(...he.focalPlane), he.poiLine && de.push(he.poiLine);
        }
        for (const ie of de) {
          const he = D1(ie.start, ae.viewProjection, ee.width, ee.height), ne = D1(ie.end, ae.viewProjection, ee.width, ee.height);
          !he.visible && !ne.visible || (Y.beginPath(), Y.strokeStyle = ie.color, Y.lineWidth = 1, Y.moveTo(he.x, he.y), Y.lineTo(ne.x, ne.y), Y.stroke());
        }
        if (r.value.showLayerHandles)
          for (const ie of l.value) {
            const he = D1(ie.position, ae.viewProjection, ee.width, ee.height);
            he.visible && (Y.beginPath(), Y.fillStyle = ie.selected ? "#ffcc00" : "#888888", Y.arc(he.x, he.y, ie.selected ? 6 : 4, 0, Math.PI * 2), Y.fill(), Y.fillStyle = "#ffffff", Y.font = "10px sans-serif", Y.fillText(ie.name, he.x + 8, he.y + 4));
          }
      });
    }
    function W() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: i.value / 2, y: o.value / 2, z: -1500 },
        pointOfInterest: { x: i.value / 2, y: o.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let fe;
    function q() {
      I(), fe = requestAnimationFrame(q);
    }
    return gn(() => {
      q();
    }), Un(() => {
      cancelAnimationFrame(fe);
    }), Ft([n, a, r, l], () => {
    }, { deep: !0 }), (G, Q) => (se(), re("div", {
      class: Le(["viewport-renderer", [`layout-${y.value}`]])
    }, [
      (se(!0), re(Xe, null, at(w.value, (K, Y) => {
        var ee, ce;
        return se(), re("div", {
          key: Y,
          class: Le(["view-panel", { active: Y === g.value }]),
          onClick: (ae) => T(Y)
        }, [
          v("div", jz, [
            v("select", {
              value: K,
              onChange: (ae) => P(Y, ae.target.value),
              class: "view-select"
            }, [...Q[1] || (Q[1] = [
              fs('<option value="active-camera" data-v-cdf0e094>Active Camera</option><option value="custom-1" data-v-cdf0e094>Custom View 1</option><option value="custom-2" data-v-cdf0e094>Custom View 2</option><option value="custom-3" data-v-cdf0e094>Custom View 3</option><option value="front" data-v-cdf0e094>Front</option><option value="back" data-v-cdf0e094>Back</option><option value="left" data-v-cdf0e094>Left</option><option value="right" data-v-cdf0e094>Right</option><option value="top" data-v-cdf0e094>Top</option><option value="bottom" data-v-cdf0e094>Bottom</option>', 10)
            ])], 40, Xz),
            v("div", Yz, [
              _(K) ? (se(), re("button", {
                key: 0,
                onClick: _t((ae) => S(K), ["stop"]),
                title: "Reset View"
              }, [...Q[2] || (Q[2] = [
                v("span", { class: "icon" }, "", -1)
              ])], 8, qz)) : Te("", !0)
            ])
          ]),
          v("canvas", {
            ref_for: !0,
            ref: (ae) => M(ae, Y),
            class: "view-canvas",
            onMousedown: (ae) => A(ae, Y),
            onWheel: (ae) => U(ae, Y),
            onContextmenu: Q[0] || (Q[0] = _t(() => {
            }, ["prevent"]))
          }, null, 40, Zz),
          v("div", Kz, [
            v("span", Jz, ye(C(K)), 1),
            _(K) ? (se(), re("span", Qz, " : " + ye(Math.round(((ee = x.value[K]) == null ? void 0 : ee.orbitTheta) ?? 0)) + " : " + ye(Math.round(((ce = x.value[K]) == null ? void 0 : ce.orbitPhi) ?? 0)) + " ", 1)) : Te("", !0)
          ])
        ], 10, Wz);
      }), 128)),
      v("div", eB, [
        (se(), re(Xe, null, at(m, (K) => v("button", {
          key: K.value,
          class: Le({ active: y.value === K.value }),
          onClick: (Y) => E(K.value),
          title: K.label
        }, ye(K.icon), 11, tB)), 64))
      ])
    ], 2));
  }
}), iB = /* @__PURE__ */ Vt(nB, [["__scopeId", "data-v-cdf0e094"]]), Y0 = new Gh(), Qn = new pe(), g0 = new pe(), fn = new ni(), R2 = {
  X: new pe(1, 0, 0),
  Y: new pe(0, 1, 0),
  Z: new pe(0, 0, 1)
}, I1 = { type: "change" }, L2 = { type: "mouseDown", mode: null }, F2 = { type: "mouseUp", mode: null }, O2 = { type: "objectChange" };
class sB extends bw {
  constructor(e, n = null) {
    super(void 0, n);
    const i = new uB(this);
    this._root = i;
    const o = new dB();
    this._gizmo = o, i.add(o);
    const a = new hB();
    this._plane = a, i.add(a);
    const r = this;
    function l(M, _) {
      let C = _;
      Object.defineProperty(r, M, {
        get: function() {
          return C !== void 0 ? C : _;
        },
        set: function(T) {
          C !== T && (C = T, a[M] = T, o[M] = T, r.dispatchEvent({ type: M + "-changed", value: T }), r.dispatchEvent(I1));
        }
      }), r[M] = _, a[M] = _, o[M] = _;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "world"), l("size", 1), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0), l("minX", -1 / 0), l("maxX", 1 / 0), l("minY", -1 / 0), l("maxY", 1 / 0), l("minZ", -1 / 0), l("maxZ", 1 / 0);
    const c = new pe(), u = new pe(), d = new ni(), h = new ni(), p = new pe(), f = new ni(), m = new pe(), y = new pe(), g = new pe(), x = 0, w = new pe();
    l("worldPosition", c), l("worldPositionStart", u), l("worldQuaternion", d), l("worldQuaternionStart", h), l("cameraPosition", p), l("cameraQuaternion", f), l("pointStart", m), l("pointEnd", y), l("rotationAxis", g), l("rotationAngle", x), l("eye", w), this._offset = new pe(), this._startNorm = new pe(), this._endNorm = new pe(), this._cameraScale = new pe(), this._parentPosition = new pe(), this._parentQuaternion = new ni(), this._parentQuaternionInv = new ni(), this._parentScale = new pe(), this._worldScaleStart = new pe(), this._worldQuaternionInv = new ni(), this._worldScale = new pe(), this._positionStart = new pe(), this._quaternionStart = new ni(), this._scaleStart = new pe(), this._getPointer = oB.bind(this), this._onPointerDown = rB.bind(this), this._onPointerHover = aB.bind(this), this._onPointerMove = lB.bind(this), this._onPointerUp = cB.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && Y0.setFromCamera(e, this.camera);
    const n = R1(this._gizmo.picker[this.mode], Y0);
    n ? this.axis = n.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && Y0.setFromCamera(e, this.camera);
      const n = R1(this._plane, Y0, !0);
      n && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(n.point).sub(this.worldPositionStart)), this.dragging = !0, L2.mode = this.mode, this.dispatchEvent(L2);
    }
  }
  pointerMove(e) {
    const n = this.axis, i = this.mode, o = this.object;
    let a = this.space;
    if (i === "scale" ? a = "local" : (n === "E" || n === "XYZE" || n === "XYZ") && (a = "world"), o === void 0 || n === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && Y0.setFromCamera(e, this.camera);
    const r = R1(this._plane, Y0, !0);
    if (r) {
      if (this.pointEnd.copy(r.point).sub(this.worldPositionStart), i === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), a === "local" && n !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), n.indexOf("X") === -1 && (this._offset.x = 0), n.indexOf("Y") === -1 && (this._offset.y = 0), n.indexOf("Z") === -1 && (this._offset.z = 0), a === "local" && n !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), o.position.copy(this._offset).add(this._positionStart), this.translationSnap && (a === "local" && (o.position.applyQuaternion(fn.copy(this._quaternionStart).invert()), n.search("X") !== -1 && (o.position.x = Math.round(o.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (o.position.y = Math.round(o.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (o.position.z = Math.round(o.position.z / this.translationSnap) * this.translationSnap), o.position.applyQuaternion(this._quaternionStart)), a === "world" && (o.parent && o.position.add(Qn.setFromMatrixPosition(o.parent.matrixWorld)), n.search("X") !== -1 && (o.position.x = Math.round(o.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (o.position.y = Math.round(o.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (o.position.z = Math.round(o.position.z / this.translationSnap) * this.translationSnap), o.parent && o.position.sub(Qn.setFromMatrixPosition(o.parent.matrixWorld)))), o.position.x = Math.max(this.minX, Math.min(this.maxX, o.position.x)), o.position.y = Math.max(this.minY, Math.min(this.maxY, o.position.y)), o.position.z = Math.max(this.minZ, Math.min(this.maxZ, o.position.z));
      else if (i === "scale") {
        if (n.search("XYZ") !== -1) {
          let l = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (l *= -1), g0.set(l, l, l);
        } else
          Qn.copy(this.pointStart), g0.copy(this.pointEnd), Qn.applyQuaternion(this._worldQuaternionInv), g0.applyQuaternion(this._worldQuaternionInv), g0.divide(Qn), n.search("X") === -1 && (g0.x = 1), n.search("Y") === -1 && (g0.y = 1), n.search("Z") === -1 && (g0.z = 1);
        o.scale.copy(this._scaleStart).multiply(g0), this.scaleSnap && (n.search("X") !== -1 && (o.scale.x = Math.round(o.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Y") !== -1 && (o.scale.y = Math.round(o.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Z") !== -1 && (o.scale.z = Math.round(o.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const l = 20 / this.worldPosition.distanceTo(Qn.setFromMatrixPosition(this.camera.matrixWorld));
        let c = !1;
        n === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Qn.copy(this.rotationAxis).cross(this.eye)) * l) : (n === "X" || n === "Y" || n === "Z") && (this.rotationAxis.copy(R2[n]), Qn.copy(R2[n]), a === "local" && Qn.applyQuaternion(this.worldQuaternion), Qn.cross(this.eye), Qn.length() === 0 ? c = !0 : this.rotationAngle = this._offset.dot(Qn.normalize()) * l), (n === "E" || c) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), a === "local" && n !== "E" && n !== "XYZE" ? (o.quaternion.copy(this._quaternionStart), o.quaternion.multiply(fn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), o.quaternion.copy(fn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), o.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(I1), this.dispatchEvent(O2);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (F2.mode = this.mode, this.dispatchEvent(F2)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(I1), this.dispatchEvent(O2), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Y0;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function oB(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button
    };
  }
}
function aB(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function rB(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function lB(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function cB(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function R1(s, e, n) {
  const i = e.intersectObject(s, !0);
  for (let o = 0; o < i.length; o++)
    if (i[o].object.visible || n)
      return i[o];
  return !1;
}
const Gl = new Hi(), sn = new pe(0, 1, 0), U2 = new pe(0, 0, 0), z2 = new jt(), $l = new ni(), xc = new ni(), ys = new pe(), B2 = new jt(), rr = new pe(1, 0, 0), to = new pe(0, 1, 0), lr = new pe(0, 0, 1), Wl = new pe(), qa = new pe(), Za = new pe();
class uB extends vn {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const n = this.controls;
    n.object !== void 0 && (n.object.updateMatrixWorld(), n.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : n.object.parent.matrixWorld.decompose(n._parentPosition, n._parentQuaternion, n._parentScale), n.object.matrixWorld.decompose(n.worldPosition, n.worldQuaternion, n._worldScale), n._parentQuaternionInv.copy(n._parentQuaternion).invert(), n._worldQuaternionInv.copy(n.worldQuaternion).invert()), n.camera.updateMatrixWorld(), n.camera.matrixWorld.decompose(n.cameraPosition, n.cameraQuaternion, n._cameraScale), n.camera.isOrthographicCamera ? n.camera.getWorldDirection(n.eye).negate() : n.eye.copy(n.cameraPosition).sub(n.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  dispose() {
    this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
}
class dB extends vn {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new _n({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = new Gi({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = e.clone();
    i.opacity = 0.15;
    const o = n.clone();
    o.opacity = 0.5;
    const a = e.clone();
    a.color.setHex(16711680);
    const r = e.clone();
    r.color.setHex(65280);
    const l = e.clone();
    l.color.setHex(255);
    const c = e.clone();
    c.color.setHex(16711680), c.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(65280), u.opacity = 0.5;
    const d = e.clone();
    d.color.setHex(255), d.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const p = e.clone();
    p.color.setHex(16776960), p.opacity = 0.25, e.clone().color.setHex(16776960);
    const m = e.clone();
    m.color.setHex(7895160);
    const y = new Wn(0, 0.04, 0.1, 12);
    y.translate(0, 0.05, 0);
    const g = new Mn(0.08, 0.08, 0.08);
    g.translate(0, 0.04, 0);
    const x = new Ut();
    x.setAttribute("position", new Pt([0, 0, 0, 1, 0, 0], 3));
    const w = new Wn(75e-4, 75e-4, 0.5, 3);
    w.translate(0, 0.25, 0);
    function M(I, W) {
      const fe = new io(I, 75e-4, 3, 64, W * Math.PI * 2);
      return fe.rotateY(Math.PI / 2), fe.rotateX(Math.PI / 2), fe;
    }
    function _() {
      const I = new Ut();
      return I.setAttribute("position", new Pt([0, 0, 0, 1, 1, 1], 3)), I;
    }
    const C = {
      X: [
        [new Ke(y, a), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ke(y, a), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Ke(w, a), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Ke(y, r), [0, 0.5, 0]],
        [new Ke(y, r), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Ke(w, r)]
      ],
      Z: [
        [new Ke(y, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ke(y, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Ke(w, l), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ke(new Qo(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Ke(new Mn(0.15, 0.15, 0.01), d.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ke(new Mn(0.15, 0.15, 0.01), c.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ke(new Mn(0.15, 0.15, 0.01), u.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, T = {
      X: [
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ke(new Qo(0.2, 0), i)]
      ],
      XY: [
        [new Ke(new Mn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ke(new Mn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ke(new Mn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, P = {
      START: [
        [new Ke(new Qo(0.01, 2), o), null, null, null, "helper"]
      ],
      END: [
        [new Ke(new Qo(0.01, 2), o), null, null, null, "helper"]
      ],
      DELTA: [
        [new cn(_(), o), null, null, null, "helper"]
      ],
      X: [
        [new cn(x, o.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new cn(x, o.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new cn(x, o.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, E = {
      XYZE: [
        [new Ke(M(0.5, 1), m), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Ke(M(0.5, 0.5), a)]
      ],
      Y: [
        [new Ke(M(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Ke(M(0.5, 0.5), l), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Ke(M(0.75, 1), p), null, [0, Math.PI / 2, 0]]
      ]
    }, b = {
      AXIS: [
        [new cn(x, o.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, S = {
      XYZE: [
        [new Ke(new gu(0.25, 10, 8), i)]
      ],
      X: [
        [new Ke(new io(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Ke(new io(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Ke(new io(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Ke(new io(0.75, 0.1, 2, 24), i)]
      ]
    }, A = {
      X: [
        [new Ke(g, a), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ke(w, a), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ke(g, a), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ke(g, r), [0, 0.5, 0]],
        [new Ke(w, r)],
        [new Ke(g, r), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ke(g, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Ke(w, l), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Ke(g, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ke(new Mn(0.15, 0.15, 0.01), d), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ke(new Mn(0.15, 0.15, 0.01), c), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ke(new Mn(0.15, 0.15, 0.01), u), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ke(new Mn(0.1, 0.1, 0.1), h.clone())]
      ]
    }, R = {
      X: [
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Ke(new Wn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Ke(new Mn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Ke(new Mn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Ke(new Mn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Ke(new Mn(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, k = {
      X: [
        [new cn(x, o.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new cn(x, o.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new cn(x, o.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function U(I) {
      const W = new vn();
      for (const fe in I)
        for (let q = I[fe].length; q--; ) {
          const G = I[fe][q][0].clone(), Q = I[fe][q][1], K = I[fe][q][2], Y = I[fe][q][3], ee = I[fe][q][4];
          G.name = fe, G.tag = ee, Q && G.position.set(Q[0], Q[1], Q[2]), K && G.rotation.set(K[0], K[1], K[2]), Y && G.scale.set(Y[0], Y[1], Y[2]), G.updateMatrix();
          const ce = G.geometry.clone();
          ce.applyMatrix4(G.matrix), G.geometry = ce, G.renderOrder = 1 / 0, G.position.set(0, 0, 0), G.rotation.set(0, 0, 0), G.scale.set(1, 1, 1), W.add(G);
        }
      return W;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = U(C)), this.add(this.gizmo.rotate = U(E)), this.add(this.gizmo.scale = U(A)), this.add(this.picker.translate = U(T)), this.add(this.picker.rotate = U(S)), this.add(this.picker.scale = U(R)), this.add(this.helper.translate = U(P)), this.add(this.helper.rotate = U(b)), this.add(this.helper.scale = U(k)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : xc;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let o = [];
    o = o.concat(this.picker[this.mode].children), o = o.concat(this.gizmo[this.mode].children), o = o.concat(this.helper[this.mode].children);
    for (let a = 0; a < o.length; a++) {
      const r = o[a];
      r.visible = !0, r.rotation.set(0, 0, 0), r.position.copy(this.worldPosition);
      let l;
      if (this.camera.isOrthographicCamera ? l = (this.camera.top - this.camera.bottom) / this.camera.zoom : l = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), r.scale.set(1, 1, 1).multiplyScalar(l * this.size / 4), r.tag === "helper") {
        r.visible = !1, r.name === "AXIS" ? (r.visible = !!this.axis, this.axis === "X" && (fn.setFromEuler(Gl.set(0, 0, 0)), r.quaternion.copy(i).multiply(fn), Math.abs(sn.copy(rr).applyQuaternion(i).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "Y" && (fn.setFromEuler(Gl.set(0, 0, Math.PI / 2)), r.quaternion.copy(i).multiply(fn), Math.abs(sn.copy(to).applyQuaternion(i).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "Z" && (fn.setFromEuler(Gl.set(0, Math.PI / 2, 0)), r.quaternion.copy(i).multiply(fn), Math.abs(sn.copy(lr).applyQuaternion(i).dot(this.eye)) > 0.9 && (r.visible = !1)), this.axis === "XYZE" && (fn.setFromEuler(Gl.set(0, Math.PI / 2, 0)), sn.copy(this.rotationAxis), r.quaternion.setFromRotationMatrix(z2.lookAt(U2, sn, to)), r.quaternion.multiply(fn), r.visible = this.dragging), this.axis === "E" && (r.visible = !1)) : r.name === "START" ? (r.position.copy(this.worldPositionStart), r.visible = this.dragging) : r.name === "END" ? (r.position.copy(this.worldPosition), r.visible = this.dragging) : r.name === "DELTA" ? (r.position.copy(this.worldPositionStart), r.quaternion.copy(this.worldQuaternionStart), Qn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Qn.applyQuaternion(this.worldQuaternionStart.clone().invert()), r.scale.copy(Qn), r.visible = this.dragging) : (r.quaternion.copy(i), this.dragging ? r.position.copy(this.worldPositionStart) : r.position.copy(this.worldPosition), this.axis && (r.visible = this.axis.search(r.name) !== -1));
        continue;
      }
      r.quaternion.copy(i), this.mode === "translate" || this.mode === "scale" ? (r.name === "X" && Math.abs(sn.copy(rr).applyQuaternion(i).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "Y" && Math.abs(sn.copy(to).applyQuaternion(i).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "Z" && Math.abs(sn.copy(lr).applyQuaternion(i).dot(this.eye)) > 0.99 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "XY" && Math.abs(sn.copy(lr).applyQuaternion(i).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "YZ" && Math.abs(sn.copy(rr).applyQuaternion(i).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1), r.name === "XZ" && Math.abs(sn.copy(to).applyQuaternion(i).dot(this.eye)) < 0.2 && (r.scale.set(1e-10, 1e-10, 1e-10), r.visible = !1)) : this.mode === "rotate" && ($l.copy(i), sn.copy(this.eye).applyQuaternion(fn.copy(i).invert()), r.name.search("E") !== -1 && r.quaternion.setFromRotationMatrix(z2.lookAt(this.eye, U2, to)), r.name === "X" && (fn.setFromAxisAngle(rr, Math.atan2(-sn.y, sn.z)), fn.multiplyQuaternions($l, fn), r.quaternion.copy(fn)), r.name === "Y" && (fn.setFromAxisAngle(to, Math.atan2(sn.x, sn.z)), fn.multiplyQuaternions($l, fn), r.quaternion.copy(fn)), r.name === "Z" && (fn.setFromAxisAngle(lr, Math.atan2(sn.y, sn.x)), fn.multiplyQuaternions($l, fn), r.quaternion.copy(fn))), r.visible = r.visible && (r.name.indexOf("X") === -1 || this.showX), r.visible = r.visible && (r.name.indexOf("Y") === -1 || this.showY), r.visible = r.visible && (r.name.indexOf("Z") === -1 || this.showZ), r.visible = r.visible && (r.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), r.material._color = r.material._color || r.material.color.clone(), r.material._opacity = r.material._opacity || r.material.opacity, r.material.color.copy(r.material._color), r.material.opacity = r.material._opacity, this.enabled && this.axis && (r.name === this.axis || this.axis.split("").some(function(c) {
        return r.name === c;
      })) && (r.material.color.setHex(16776960), r.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class hB extends Ke {
  constructor() {
    super(
      new nn(1e5, 1e5, 2, 2),
      new _n({ visible: !1, wireframe: !0, side: mn, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let n = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (n = "local"), Wl.copy(rr).applyQuaternion(n === "local" ? this.worldQuaternion : xc), qa.copy(to).applyQuaternion(n === "local" ? this.worldQuaternion : xc), Za.copy(lr).applyQuaternion(n === "local" ? this.worldQuaternion : xc), sn.copy(qa), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            sn.copy(this.eye).cross(Wl), ys.copy(Wl).cross(sn);
            break;
          case "Y":
            sn.copy(this.eye).cross(qa), ys.copy(qa).cross(sn);
            break;
          case "Z":
            sn.copy(this.eye).cross(Za), ys.copy(Za).cross(sn);
            break;
          case "XY":
            ys.copy(Za);
            break;
          case "YZ":
            ys.copy(Wl);
            break;
          case "XZ":
            sn.copy(Za), ys.copy(qa);
            break;
          case "XYZ":
          case "E":
            ys.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        ys.set(0, 0, 0);
    }
    ys.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (B2.lookAt(Qn.set(0, 0, 0), ys, sn), this.quaternion.setFromRotationMatrix(B2)), super.updateMatrixWorld(e);
  }
}
class fB {
  constructor(e = null) {
    /** The main Three.js scene */
    le(this, "scene");
    /** Group for composition layers (rendered content) */
    le(this, "compositionGroup");
    /** Group for UI overlay elements */
    le(this, "overlayGroup");
    /** Group for debug helpers */
    le(this, "debugGroup");
    /** Composition bounds frame */
    le(this, "compositionBounds", null);
    /** Composition dimensions */
    le(this, "compositionWidth", 1920);
    le(this, "compositionHeight", 1080);
    /** O(1) layer lookup map - optimization for frequent ID-based lookups */
    le(this, "layerLookupMap", /* @__PURE__ */ new Map());
    /** Track Z positions to avoid unnecessary sorting */
    le(this, "zPositionCache", /* @__PURE__ */ new Map());
    le(this, "needsZSort", !1);
    this.scene = new P_(), this.scene.name = "WeylScene", e ? this.scene.background = new Mt(e) : this.scene.background = null, this.compositionGroup = new Bi(), this.compositionGroup.name = "composition", this.scene.add(this.compositionGroup), this.overlayGroup = new Bi(), this.overlayGroup.name = "overlay", this.overlayGroup.renderOrder = 1e3, this.scene.add(this.overlayGroup), this.debugGroup = new Bi(), this.debugGroup.name = "debug", this.debugGroup.visible = !1, this.scene.add(this.debugGroup), this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const e = new Nm(16777215, 0.6);
    e.name = "ambientLight", this.scene.add(e);
    const n = new ws(16777215, 0.8);
    n.name = "keyLight", n.position.set(1e3, -1e3, 2e3), n.castShadow = !0, n.shadow.mapSize.width = 2048, n.shadow.mapSize.height = 2048, this.scene.add(n);
    const i = new ws(16777215, 0.3);
    i.name = "fillLight", i.position.set(-500, 500, 1e3), this.scene.add(i);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(e) {
    var i;
    this.compositionGroup.add(e), this.markNeedsZSort();
    const n = (i = e.userData) == null ? void 0 : i.layerId;
    n && this.layerLookupMap.set(n, e);
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(e) {
    var i;
    this.compositionGroup.remove(e);
    const n = (i = e.userData) == null ? void 0 : i.layerId;
    n && this.layerLookupMap.delete(n), this.zPositionCache.delete(e);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   * Optimized to only sort when Z positions have actually changed
   */
  sortByZ() {
    if (!this.needsZSort) {
      let e = !1;
      for (const n of this.compositionGroup.children) {
        const i = this.zPositionCache.get(n), o = n.position.z || 0;
        if (i === void 0 || i !== o) {
          e = !0;
          break;
        }
      }
      if (!e)
        return;
    }
    this.compositionGroup.children.sort((e, n) => (e.position.z || 0) - (n.position.z || 0));
    for (const e of this.compositionGroup.children)
      this.zPositionCache.set(e, e.position.z || 0);
    this.needsZSort = !1;
  }
  /**
   * Mark that Z sorting is needed (call when Z positions may have changed)
   */
  markNeedsZSort() {
    this.needsZSort = !0;
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(e) {
    this.overlayGroup.add(e);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(e) {
    this.overlayGroup.remove(e);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    for (; this.overlayGroup.children.length > 0; ) {
      const e = this.overlayGroup.children[0];
      this.overlayGroup.remove(e), this.disposeObject(e);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(e) {
    this.scene.add(e);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(e) {
    this.scene.remove(e);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(e) {
    this.debugGroup.visible = e;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(e = 500) {
    const n = this.debugGroup.getObjectByName("axisHelper");
    n && this.debugGroup.remove(n);
    const i = new xw(e);
    i.name = "axisHelper", this.debugGroup.add(i);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(e = 2e3, n = 40) {
    const i = this.debugGroup.getObjectByName("gridHelper");
    i && this.debugGroup.remove(i);
    const o = new yw(e, n, 4473924, 2236962);
    o.name = "gridHelper", o.rotation.x = Math.PI / 2, this.debugGroup.add(o);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(e) {
    e ? this.scene.background = new Mt(e) : this.scene.background = null;
  }
  /**
   * Get current background color
   */
  getBackground() {
    return this.scene.background instanceof Mt ? "#" + this.scene.background.getHexString() : null;
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(e, n) {
    this.compositionWidth = e, this.compositionHeight = n, this.updateCompositionBounds();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    this.compositionBounds && (this.overlayGroup.remove(this.compositionBounds), this.compositionBounds.geometry.dispose(), this.compositionBounds.material.dispose());
    const e = this.compositionWidth, n = this.compositionHeight, i = [
      new pe(0, 0, 0),
      new pe(e, 0, 0),
      new pe(e, -n, 0),
      new pe(0, -n, 0)
    ], o = new Ut().setFromPoints(i), a = new Gi({
      color: 4886745,
      linewidth: 2,
      depthTest: !1
    });
    this.compositionBounds = new k_(o, a), this.compositionBounds.name = "compositionBounds", this.compositionBounds.renderOrder = 998, this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(e) {
    this.compositionBounds && (this.compositionBounds.visible = e);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(e) {
    return e.intersectObjects(this.compositionGroup.children, !0);
  }
  /**
   * Find layer object by ID - O(1) lookup via Map
   */
  findLayerById(e) {
    return this.layerLookupMap.get(e) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(e) {
    var n;
    for (e instanceof Ke && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => {
      this.disposeMaterial(i);
    }) : e.material && this.disposeMaterial(e.material)); e.children.length > 0; ) {
      const i = e.children[0];
      e.remove(i), this.disposeObject(i);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(e) {
    var i, o, a, r, l, c, u, d;
    const n = e;
    (i = n.map) == null || i.dispose(), (o = n.normalMap) == null || o.dispose(), (a = n.roughnessMap) == null || a.dispose(), (r = n.metalnessMap) == null || r.dispose(), (l = n.aoMap) == null || l.dispose(), (c = n.emissiveMap) == null || c.dispose(), (u = n.alphaMap) == null || u.dispose(), (d = n.envMap) == null || d.dispose(), e.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    for (; this.compositionGroup.children.length > 0; ) {
      const e = this.compositionGroup.children[0];
      this.compositionGroup.remove(e), this.disposeObject(e);
    }
    for (this.layerLookupMap.clear(), this.zPositionCache.clear(), this.clearOverlay(); this.debugGroup.children.length > 0; ) {
      const e = this.debugGroup.children[0];
      this.debugGroup.remove(e), this.disposeObject(e);
    }
    this.scene.clear();
  }
}
const Mr = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class U0 {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const pB = new du(-1, 1, 1, -1, 0, 1);
class mB extends Ut {
  constructor() {
    super(), this.setAttribute("position", new Pt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Pt([0, 2, 0, 0, 2, 0], 2));
  }
}
const vB = new mB();
class Qr {
  constructor(e) {
    this._mesh = new Ke(vB, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, pB);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class gB extends U0 {
  constructor(e, n) {
    super(), this.textureID = n !== void 0 ? n : "tDiffuse", e instanceof dn ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = ls.clone(e.uniforms), this.material = new dn({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new Qr(this.material);
  }
  render(e, n, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class N2 extends U0 {
  constructor(e, n) {
    super(), this.scene = e, this.camera = n, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, n, i) {
    const o = e.getContext(), a = e.state;
    a.buffers.color.setMask(!1), a.buffers.depth.setMask(!1), a.buffers.color.setLocked(!0), a.buffers.depth.setLocked(!0);
    let r, l;
    this.inverse ? (r = 0, l = 1) : (r = 1, l = 0), a.buffers.stencil.setTest(!0), a.buffers.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), a.buffers.stencil.setFunc(o.ALWAYS, r, 4294967295), a.buffers.stencil.setClear(l), a.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), a.buffers.color.setLocked(!1), a.buffers.depth.setLocked(!1), a.buffers.color.setMask(!0), a.buffers.depth.setMask(!0), a.buffers.stencil.setLocked(!1), a.buffers.stencil.setFunc(o.EQUAL, 1, 4294967295), a.buffers.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), a.buffers.stencil.setLocked(!0);
  }
}
class yB extends U0 {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class xB {
  constructor(e, n) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), n === void 0) {
      const i = e.getSize(new qe());
      this._width = i.width, this._height = i.height, n = new Xn(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: gi }), n.texture.name = "EffectComposer.rt1";
    } else
      this._width = n.width, this._height = n.height;
    this.renderTarget1 = n, this.renderTarget2 = n.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new gB(Mr), this.copyPass.material.blending = si, this.clock = new gw();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, n) {
    this.passes.splice(n, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const n = this.passes.indexOf(e);
    n !== -1 && this.passes.splice(n, 1);
  }
  isLastEnabledPass(e) {
    for (let n = e + 1; n < this.passes.length; n++)
      if (this.passes[n].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const n = this.renderer.getRenderTarget();
    let i = !1;
    for (let o = 0, a = this.passes.length; o < a; o++) {
      const r = this.passes[o];
      if (r.enabled !== !1) {
        if (r.renderToScreen = this.renderToScreen && this.isLastEnabledPass(o), r.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), r.needsSwap) {
          if (i) {
            const l = this.renderer.getContext(), c = this.renderer.state.buffers.stencil;
            c.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), c.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        N2 !== void 0 && (r instanceof N2 ? i = !0 : r instanceof yB && (i = !1));
      }
    }
    this.renderer.setRenderTarget(n);
  }
  reset(e) {
    if (e === void 0) {
      const n = this.renderer.getSize(new qe());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = n.width, this._height = n.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, n) {
    this._width = e, this._height = n;
    const i = this._width * this._pixelRatio, o = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, o), this.renderTarget2.setSize(i, o);
    for (let a = 0; a < this.passes.length; a++)
      this.passes[a].setSize(i, o);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class bB extends U0 {
  constructor(e, n, i = null, o = null, a = null) {
    super(), this.scene = e, this.camera = n, this.overrideMaterial = i, this.clearColor = o, this.clearAlpha = a, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    const o = e.autoClear;
    e.autoClear = !1;
    let a, r;
    this.overrideMaterial !== null && (r = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (a = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(a), this.overrideMaterial !== null && (this.scene.overrideMaterial = r), e.autoClear = o;
  }
}
const _B = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
  )
};
class wB extends U0 {
  constructor() {
    super();
    const e = _B;
    this.uniforms = ls.clone(e.uniforms), this.material = new cw({
      name: e.name,
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    }), this.fsQuad = new Qr(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(e, n, i) {
    this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, (this._outputColorSpace !== e.outputColorSpace || this._toneMapping !== e.toneMapping) && (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, Nt.getTransfer(this._outputColorSpace) === Qt && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === tm ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === nm ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === im ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === xh ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === sm ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === om && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const MB = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: { value: null },
    tDepth: { value: null },
    focus: { value: 1 },
    aspect: { value: 1 },
    aperture: { value: 0.025 },
    maxblur: { value: 0.01 },
    nearClip: { value: 1 },
    farClip: { value: 1e3 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`
  )
};
class SB extends U0 {
  constructor(e, n, i) {
    super(), this.scene = e, this.camera = n;
    const o = i.focus !== void 0 ? i.focus : 1, a = i.aperture !== void 0 ? i.aperture : 0.025, r = i.maxblur !== void 0 ? i.maxblur : 1;
    this.renderTargetDepth = new Xn(1, 1, {
      // will be resized later
      minFilter: xn,
      magFilter: xn,
      type: gi
    }), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new Rh(), this.materialDepth.depthPacking = Th, this.materialDepth.blending = si;
    const l = MB, c = ls.clone(l.uniforms);
    c.tDepth.value = this.renderTargetDepth.texture, c.focus.value = o, c.aspect.value = n.aspect, c.aperture.value = a, c.maxblur.value = r, c.nearClip.value = n.near, c.farClip.value = n.far, this.materialBokeh = new dn({
      defines: Object.assign({}, l.defines),
      uniforms: c,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader
    }), this.uniforms = c, this.fsQuad = new Qr(this.materialBokeh), this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this._oldClearColor);
    const o = e.getClearAlpha(), a = e.autoClear;
    e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = i.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), e.clear(), this.fsQuad.render(e)), this.scene.overrideMaterial = null, e.setClearColor(this._oldClearColor), e.setClearAlpha(o), e.autoClear = a;
  }
  setSize(e, n) {
    this.materialBokeh.uniforms.aspect.value = e / n, this.renderTargetDepth.setSize(e, n);
  }
  dispose() {
    this.renderTargetDepth.dispose(), this.materialDepth.dispose(), this.materialBokeh.dispose(), this.fsQuad.dispose();
  }
}
class CB {
  constructor(e = Math) {
    this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1]
    ], this.grad4 = [
      [0, 1, 1, 1],
      [0, 1, 1, -1],
      [0, 1, -1, 1],
      [0, 1, -1, -1],
      [0, -1, 1, 1],
      [0, -1, 1, -1],
      [0, -1, -1, 1],
      [0, -1, -1, -1],
      [1, 0, 1, 1],
      [1, 0, 1, -1],
      [1, 0, -1, 1],
      [1, 0, -1, -1],
      [-1, 0, 1, 1],
      [-1, 0, 1, -1],
      [-1, 0, -1, 1],
      [-1, 0, -1, -1],
      [1, 1, 0, 1],
      [1, 1, 0, -1],
      [1, -1, 0, 1],
      [1, -1, 0, -1],
      [-1, 1, 0, 1],
      [-1, 1, 0, -1],
      [-1, -1, 0, 1],
      [-1, -1, 0, -1],
      [1, 1, 1, 0],
      [1, 1, -1, 0],
      [1, -1, 1, 0],
      [1, -1, -1, 0],
      [-1, 1, 1, 0],
      [-1, 1, -1, 0],
      [-1, -1, 1, 0],
      [-1, -1, -1, 0]
    ], this.p = [];
    for (let n = 0; n < 256; n++)
      this.p[n] = Math.floor(e.random() * 256);
    this.perm = [];
    for (let n = 0; n < 512; n++)
      this.perm[n] = this.p[n & 255];
    this.simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0]
    ];
  }
  dot(e, n, i) {
    return e[0] * n + e[1] * i;
  }
  dot3(e, n, i, o) {
    return e[0] * n + e[1] * i + e[2] * o;
  }
  dot4(e, n, i, o, a) {
    return e[0] * n + e[1] * i + e[2] * o + e[3] * a;
  }
  noise(e, n) {
    let i, o, a;
    const r = 0.5 * (Math.sqrt(3) - 1), l = (e + n) * r, c = Math.floor(e + l), u = Math.floor(n + l), d = (3 - Math.sqrt(3)) / 6, h = (c + u) * d, p = c - h, f = u - h, m = e - p, y = n - f;
    let g, x;
    m > y ? (g = 1, x = 0) : (g = 0, x = 1);
    const w = m - g + d, M = y - x + d, _ = m - 1 + 2 * d, C = y - 1 + 2 * d, T = c & 255, P = u & 255, E = this.perm[T + this.perm[P]] % 12, b = this.perm[T + g + this.perm[P + x]] % 12, S = this.perm[T + 1 + this.perm[P + 1]] % 12;
    let A = 0.5 - m * m - y * y;
    A < 0 ? i = 0 : (A *= A, i = A * A * this.dot(this.grad3[E], m, y));
    let R = 0.5 - w * w - M * M;
    R < 0 ? o = 0 : (R *= R, o = R * R * this.dot(this.grad3[b], w, M));
    let k = 0.5 - _ * _ - C * C;
    return k < 0 ? a = 0 : (k *= k, a = k * k * this.dot(this.grad3[S], _, C)), 70 * (i + o + a);
  }
  // 3D simplex noise
  noise3d(e, n, i) {
    let o, a, r, l;
    const u = (e + n + i) * 0.3333333333333333, d = Math.floor(e + u), h = Math.floor(n + u), p = Math.floor(i + u), f = 1 / 6, m = (d + h + p) * f, y = d - m, g = h - m, x = p - m, w = e - y, M = n - g, _ = i - x;
    let C, T, P, E, b, S;
    w >= M ? M >= _ ? (C = 1, T = 0, P = 0, E = 1, b = 1, S = 0) : w >= _ ? (C = 1, T = 0, P = 0, E = 1, b = 0, S = 1) : (C = 0, T = 0, P = 1, E = 1, b = 0, S = 1) : M < _ ? (C = 0, T = 0, P = 1, E = 0, b = 1, S = 1) : w < _ ? (C = 0, T = 1, P = 0, E = 0, b = 1, S = 1) : (C = 0, T = 1, P = 0, E = 1, b = 1, S = 0);
    const A = w - C + f, R = M - T + f, k = _ - P + f, U = w - E + 2 * f, I = M - b + 2 * f, W = _ - S + 2 * f, fe = w - 1 + 3 * f, q = M - 1 + 3 * f, G = _ - 1 + 3 * f, Q = d & 255, K = h & 255, Y = p & 255, ee = this.perm[Q + this.perm[K + this.perm[Y]]] % 12, ce = this.perm[Q + C + this.perm[K + T + this.perm[Y + P]]] % 12, ae = this.perm[Q + E + this.perm[K + b + this.perm[Y + S]]] % 12, de = this.perm[Q + 1 + this.perm[K + 1 + this.perm[Y + 1]]] % 12;
    let ie = 0.6 - w * w - M * M - _ * _;
    ie < 0 ? o = 0 : (ie *= ie, o = ie * ie * this.dot3(this.grad3[ee], w, M, _));
    let he = 0.6 - A * A - R * R - k * k;
    he < 0 ? a = 0 : (he *= he, a = he * he * this.dot3(this.grad3[ce], A, R, k));
    let ne = 0.6 - U * U - I * I - W * W;
    ne < 0 ? r = 0 : (ne *= ne, r = ne * ne * this.dot3(this.grad3[ae], U, I, W));
    let N = 0.6 - fe * fe - q * q - G * G;
    return N < 0 ? l = 0 : (N *= N, l = N * N * this.dot3(this.grad3[de], fe, q, G)), 32 * (o + a + r + l);
  }
  // 4D simplex noise
  noise4d(e, n, i, o) {
    const a = this.grad4, r = this.simplex, l = this.perm, c = (Math.sqrt(5) - 1) / 4, u = (5 - Math.sqrt(5)) / 20;
    let d, h, p, f, m;
    const y = (e + n + i + o) * c, g = Math.floor(e + y), x = Math.floor(n + y), w = Math.floor(i + y), M = Math.floor(o + y), _ = (g + x + w + M) * u, C = g - _, T = x - _, P = w - _, E = M - _, b = e - C, S = n - T, A = i - P, R = o - E, k = b > S ? 32 : 0, U = b > A ? 16 : 0, I = S > A ? 8 : 0, W = b > R ? 4 : 0, fe = S > R ? 2 : 0, q = A > R ? 1 : 0, G = k + U + I + W + fe + q, Q = r[G][0] >= 3 ? 1 : 0, K = r[G][1] >= 3 ? 1 : 0, Y = r[G][2] >= 3 ? 1 : 0, ee = r[G][3] >= 3 ? 1 : 0, ce = r[G][0] >= 2 ? 1 : 0, ae = r[G][1] >= 2 ? 1 : 0, de = r[G][2] >= 2 ? 1 : 0, ie = r[G][3] >= 2 ? 1 : 0, he = r[G][0] >= 1 ? 1 : 0, ne = r[G][1] >= 1 ? 1 : 0, N = r[G][2] >= 1 ? 1 : 0, te = r[G][3] >= 1 ? 1 : 0, F = b - Q + u, B = S - K + u, L = A - Y + u, D = R - ee + u, j = b - ce + 2 * u, Z = S - ae + 2 * u, z = A - de + 2 * u, $ = R - ie + 2 * u, oe = b - he + 3 * u, O = S - ne + 3 * u, V = A - N + 3 * u, H = R - te + 3 * u, X = b - 1 + 4 * u, ue = S - 1 + 4 * u, me = A - 1 + 4 * u, _e = R - 1 + 4 * u, we = g & 255, Ae = x & 255, Ve = w & 255, Fe = M & 255, $e = l[we + l[Ae + l[Ve + l[Fe]]]] % 32, Ze = l[we + Q + l[Ae + K + l[Ve + Y + l[Fe + ee]]]] % 32, je = l[we + ce + l[Ae + ae + l[Ve + de + l[Fe + ie]]]] % 32, Ue = l[we + he + l[Ae + ne + l[Ve + N + l[Fe + te]]]] % 32, rt = l[we + 1 + l[Ae + 1 + l[Ve + 1 + l[Fe + 1]]]] % 32;
    let Qe = 0.6 - b * b - S * S - A * A - R * R;
    Qe < 0 ? d = 0 : (Qe *= Qe, d = Qe * Qe * this.dot4(a[$e], b, S, A, R));
    let yt = 0.6 - F * F - B * B - L * L - D * D;
    yt < 0 ? h = 0 : (yt *= yt, h = yt * yt * this.dot4(a[Ze], F, B, L, D));
    let Ce = 0.6 - j * j - Z * Z - z * z - $ * $;
    Ce < 0 ? p = 0 : (Ce *= Ce, p = Ce * Ce * this.dot4(a[je], j, Z, z, $));
    let Be = 0.6 - oe * oe - O * O - V * V - H * H;
    Be < 0 ? f = 0 : (Be *= Be, f = Be * Be * this.dot4(a[Ue], oe, O, V, H));
    let ke = 0.6 - X * X - ue * ue - me * me - _e * _e;
    return ke < 0 ? m = 0 : (ke *= ke, m = ke * ke * this.dot4(a[rt], X, ue, me, _e)), 27 * (d + h + p + f + m);
  }
}
const jl = {
  defines: {
    PERSPECTIVE_CAMERA: 1,
    KERNEL_SIZE: 32
  },
  uniforms: {
    tNormal: { value: null },
    tDepth: { value: null },
    tNoise: { value: null },
    kernel: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null },
    resolution: { value: new qe() },
    cameraProjectionMatrix: { value: new jt() },
    cameraInverseProjectionMatrix: { value: new jt() },
    kernelRadius: { value: 8 },
    minDistance: { value: 5e-3 },
    maxDistance: { value: 0.05 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform highp sampler2D tNormal;
		uniform highp sampler2D tDepth;
		uniform sampler2D tNoise;

		uniform vec3 kernel[ KERNEL_SIZE ];

		uniform vec2 resolution;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float kernelRadius;
		uniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference
		uniform float maxDistance; // avoid the influence of fragments which are too far away

		varying vec2 vUv;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {

			return texture2D( tDepth, screenPosition ).x;

		}

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		float getViewZ( const in float depth ) {

			#if PERSPECTIVE_CAMERA == 1

				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );

			#else

				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );

			#endif

		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {

			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];

			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );

			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;

		}

		vec3 getViewNormal( const in vec2 screenPosition ) {

			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );

		}

		void main() {

			float depth = getDepth( vUv );

			if ( depth == 1.0 ) {

				gl_FragColor = vec4( 1.0 ); // don't influence background
				
			} else {

				float viewZ = getViewZ( depth );

				vec3 viewPosition = getViewPosition( vUv, depth, viewZ );
				vec3 viewNormal = getViewNormal( vUv );

				vec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );
				vec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );

				// compute matrix used to reorient a kernel vector

				vec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );
				vec3 bitangent = cross( viewNormal, tangent );
				mat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );

				float occlusion = 0.0;

				for ( int i = 0; i < KERNEL_SIZE; i ++ ) {

					vec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space
					vec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point

					vec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC
					samplePointNDC /= samplePointNDC.w;

					vec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates

					float realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture
					float sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value
					float delta = sampleDepth - realDepth;

					if ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion

						occlusion += 1.0;

					}

				}

				occlusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );

				gl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );

			}

		}`
  )
}, Xl = {
  defines: {
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null }
  },
  vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;

		varying vec2 vUv;

		#include <packing>

		float getLinearDepth( const in vec2 screenPosition ) {

			#if PERSPECTIVE_CAMERA == 1

				float fragCoordZ = texture2D( tDepth, screenPosition ).x;
				float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
				return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );

			#else

				return texture2D( tDepth, screenPosition ).x;

			#endif

		}

		void main() {

			float depth = getLinearDepth( vUv );
			gl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );

		}`
}, Yl = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new qe() }
  },
  vertexShader: `varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
  fragmentShader: `uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		void main() {

			vec2 texelSize = ( 1.0 / resolution );
			float result = 0.0;

			for ( int i = - 2; i <= 2; i ++ ) {

				for ( int j = - 2; j <= 2; j ++ ) {

					vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;
					result += texture2D( tDiffuse, vUv + offset ).r;

				}

			}

			gl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );

		}`
};
class Fi extends U0 {
  constructor(e, n, i, o, a = 32) {
    super(), this.width = i !== void 0 ? i : 512, this.height = o !== void 0 ? o : 512, this.clear = !0, this.needsSwap = !1, this.camera = n, this.scene = e, this.kernelRadius = 8, this.kernel = [], this.noiseTexture = null, this.output = 0, this.minDistance = 5e-3, this.maxDistance = 0.1, this._visibilityCache = /* @__PURE__ */ new Map(), this.generateSampleKernel(a), this.generateRandomKernelRotations();
    const r = new hu();
    r.format = go, r.type = vo, this.normalRenderTarget = new Xn(this.width, this.height, {
      minFilter: xn,
      magFilter: xn,
      type: gi,
      depthTexture: r
    }), this.ssaoRenderTarget = new Xn(this.width, this.height, { type: gi }), this.blurRenderTarget = this.ssaoRenderTarget.clone(), this.ssaoMaterial = new dn({
      defines: Object.assign({}, jl.defines),
      uniforms: ls.clone(jl.uniforms),
      vertexShader: jl.vertexShader,
      fragmentShader: jl.fragmentShader,
      blending: si
    }), this.ssaoMaterial.defines.KERNEL_SIZE = a, this.ssaoMaterial.uniforms.tNormal.value = this.normalRenderTarget.texture, this.ssaoMaterial.uniforms.tDepth.value = this.normalRenderTarget.depthTexture, this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture, this.ssaoMaterial.uniforms.kernel.value = this.kernel, this.ssaoMaterial.uniforms.cameraNear.value = this.camera.near, this.ssaoMaterial.uniforms.cameraFar.value = this.camera.far, this.ssaoMaterial.uniforms.resolution.value.set(this.width, this.height), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.normalMaterial = new Bm(), this.normalMaterial.blending = si, this.blurMaterial = new dn({
      defines: Object.assign({}, Yl.defines),
      uniforms: ls.clone(Yl.uniforms),
      vertexShader: Yl.vertexShader,
      fragmentShader: Yl.fragmentShader
    }), this.blurMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.blurMaterial.uniforms.resolution.value.set(this.width, this.height), this.depthRenderMaterial = new dn({
      defines: Object.assign({}, Xl.defines),
      uniforms: ls.clone(Xl.uniforms),
      vertexShader: Xl.vertexShader,
      fragmentShader: Xl.fragmentShader,
      blending: si
    }), this.depthRenderMaterial.uniforms.tDepth.value = this.normalRenderTarget.depthTexture, this.depthRenderMaterial.uniforms.cameraNear.value = this.camera.near, this.depthRenderMaterial.uniforms.cameraFar.value = this.camera.far, this.copyMaterial = new dn({
      uniforms: ls.clone(Mr.uniforms),
      vertexShader: Mr.vertexShader,
      fragmentShader: Mr.fragmentShader,
      transparent: !0,
      depthTest: !1,
      depthWrite: !1,
      blendSrc: J3,
      blendDst: sd,
      blendEquation: Oi,
      blendSrcAlpha: K3,
      blendDstAlpha: sd,
      blendEquationAlpha: Oi
    }), this.fsQuad = new Qr(null), this.originalClearColor = new Mt();
  }
  dispose() {
    this.normalRenderTarget.dispose(), this.ssaoRenderTarget.dispose(), this.blurRenderTarget.dispose(), this.normalMaterial.dispose(), this.blurMaterial.dispose(), this.copyMaterial.dispose(), this.depthRenderMaterial.dispose(), this.fsQuad.dispose();
  }
  render(e, n, i) {
    switch (this.overrideVisibility(), this.renderOverride(e, this.normalMaterial, this.normalRenderTarget, 7829503, 1), this.restoreVisibility(), this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius, this.ssaoMaterial.uniforms.minDistance.value = this.minDistance, this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance, this.renderPass(e, this.ssaoMaterial, this.ssaoRenderTarget), this.renderPass(e, this.blurMaterial, this.blurRenderTarget), this.output) {
      case Fi.OUTPUT.SSAO:
        this.copyMaterial.uniforms.tDiffuse.value = this.ssaoRenderTarget.texture, this.copyMaterial.blending = si, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      case Fi.OUTPUT.Blur:
        this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = si, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      case Fi.OUTPUT.Depth:
        this.renderPass(e, this.depthRenderMaterial, this.renderToScreen ? null : i);
        break;
      case Fi.OUTPUT.Normal:
        this.copyMaterial.uniforms.tDiffuse.value = this.normalRenderTarget.texture, this.copyMaterial.blending = si, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      case Fi.OUTPUT.Default:
        this.copyMaterial.uniforms.tDiffuse.value = this.blurRenderTarget.texture, this.copyMaterial.blending = E0, this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : i);
        break;
      default:
        console.warn("THREE.SSAOPass: Unknown output type.");
    }
  }
  renderPass(e, n, i, o, a) {
    e.getClearColor(this.originalClearColor);
    const r = e.getClearAlpha(), l = e.autoClear;
    e.setRenderTarget(i), e.autoClear = !1, o != null && (e.setClearColor(o), e.setClearAlpha(a || 0), e.clear()), this.fsQuad.material = n, this.fsQuad.render(e), e.autoClear = l, e.setClearColor(this.originalClearColor), e.setClearAlpha(r);
  }
  renderOverride(e, n, i, o, a) {
    e.getClearColor(this.originalClearColor);
    const r = e.getClearAlpha(), l = e.autoClear;
    e.setRenderTarget(i), e.autoClear = !1, o = n.clearColor || o, a = n.clearAlpha || a, o != null && (e.setClearColor(o), e.setClearAlpha(a || 0), e.clear()), this.scene.overrideMaterial = n, e.render(this.scene, this.camera), this.scene.overrideMaterial = null, e.autoClear = l, e.setClearColor(this.originalClearColor), e.setClearAlpha(r);
  }
  setSize(e, n) {
    this.width = e, this.height = n, this.ssaoRenderTarget.setSize(e, n), this.normalRenderTarget.setSize(e, n), this.blurRenderTarget.setSize(e, n), this.ssaoMaterial.uniforms.resolution.value.set(e, n), this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix), this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse), this.blurMaterial.uniforms.resolution.value.set(e, n);
  }
  generateSampleKernel(e) {
    const n = this.kernel;
    for (let i = 0; i < e; i++) {
      const o = new pe();
      o.x = Math.random() * 2 - 1, o.y = Math.random() * 2 - 1, o.z = Math.random(), o.normalize();
      let a = i / e;
      a = ln.lerp(0.1, 1, a * a), o.multiplyScalar(a), n.push(o);
    }
  }
  generateRandomKernelRotations() {
    const i = new CB(), o = 4 * 4, a = new Float32Array(o);
    for (let r = 0; r < o; r++) {
      const l = Math.random() * 2 - 1, c = Math.random() * 2 - 1, u = 0;
      a[r] = i.noise3d(l, c, u);
    }
    this.noiseTexture = new cs(a, 4, 4, Br, Vn), this.noiseTexture.wrapS = Ur, this.noiseTexture.wrapT = Ur, this.noiseTexture.needsUpdate = !0;
  }
  overrideVisibility() {
    const e = this.scene, n = this._visibilityCache;
    e.traverse(function(i) {
      n.set(i, i.visible), (i.isPoints || i.isLine) && (i.visible = !1);
    });
  }
  restoreVisibility() {
    const e = this.scene, n = this._visibilityCache;
    e.traverse(function(i) {
      const o = n.get(i);
      i.visible = o;
    }), n.clear();
  }
}
Fi.OUTPUT = {
  Default: 0,
  SSAO: 1,
  Blur: 2,
  Depth: 3,
  Normal: 4
};
const TB = {
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new Mt(0) },
    defaultOpacity: { value: 0 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
  )
};
class xa extends U0 {
  constructor(e, n, i, o) {
    super(), this.strength = n !== void 0 ? n : 1, this.radius = i, this.threshold = o, this.resolution = e !== void 0 ? new qe(e.x, e.y) : new qe(256, 256), this.clearColor = new Mt(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let a = Math.round(this.resolution.x / 2), r = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new Xn(a, r, { type: gi }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
    for (let h = 0; h < this.nMips; h++) {
      const p = new Xn(a, r, { type: gi });
      p.texture.name = "UnrealBloomPass.h" + h, p.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(p);
      const f = new Xn(a, r, { type: gi });
      f.texture.name = "UnrealBloomPass.v" + h, f.texture.generateMipmaps = !1, this.renderTargetsVertical.push(f), a = Math.round(a / 2), r = Math.round(r / 2);
    }
    const l = TB;
    this.highPassUniforms = ls.clone(l.uniforms), this.highPassUniforms.luminosityThreshold.value = o, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new dn({
      uniforms: this.highPassUniforms,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader
    }), this.separableBlurMaterials = [];
    const c = [3, 5, 7, 9, 11];
    a = Math.round(this.resolution.x / 2), r = Math.round(this.resolution.y / 2);
    for (let h = 0; h < this.nMips; h++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(c[h])), this.separableBlurMaterials[h].uniforms.invSize.value = new qe(1 / a, 1 / r), a = Math.round(a / 2), r = Math.round(r / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = n, this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
    const u = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms.bloomFactors.value = u, this.bloomTintColors = [new pe(1, 1, 1), new pe(1, 1, 1), new pe(1, 1, 1), new pe(1, 1, 1), new pe(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
    const d = Mr;
    this.copyUniforms = ls.clone(d.uniforms), this.blendMaterial = new dn({
      uniforms: this.copyUniforms,
      vertexShader: d.vertexShader,
      fragmentShader: d.fragmentShader,
      blending: ha,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new Mt(), this.oldClearAlpha = 1, this.basic = new _n(), this.fsQuad = new Qr(null);
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
    for (let e = 0; e < this.separableBlurMaterials.length; e++)
      this.separableBlurMaterials[e].dispose();
    this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
  }
  setSize(e, n) {
    let i = Math.round(e / 2), o = Math.round(n / 2);
    this.renderTargetBright.setSize(i, o);
    for (let a = 0; a < this.nMips; a++)
      this.renderTargetsHorizontal[a].setSize(i, o), this.renderTargetsVertical[a].setSize(i, o), this.separableBlurMaterials[a].uniforms.invSize.value = new qe(1 / i, 1 / o), i = Math.round(i / 2), o = Math.round(o / 2);
  }
  render(e, n, i, o, a) {
    e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const r = e.autoClear;
    e.autoClear = !1, e.setClearColor(this.clearColor, 0), a && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
    let l = this.renderTargetBright;
    for (let c = 0; c < this.nMips; c++)
      this.fsQuad.material = this.separableBlurMaterials[c], this.separableBlurMaterials[c].uniforms.colorTexture.value = l.texture, this.separableBlurMaterials[c].uniforms.direction.value = xa.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[c]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[c].uniforms.colorTexture.value = this.renderTargetsHorizontal[c].texture, this.separableBlurMaterials[c].uniforms.direction.value = xa.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[c]), e.clear(), this.fsQuad.render(e), l = this.renderTargetsVertical[c];
    this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, a && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = r;
  }
  getSeperableBlurMaterial(e) {
    const n = [];
    for (let i = 0; i < e; i++)
      n.push(0.39894 * Math.exp(-0.5 * i * i / (e * e)) / e);
    return new dn({
      defines: {
        KERNEL_RADIUS: e
      },
      uniforms: {
        colorTexture: { value: null },
        invSize: { value: new qe(0.5, 0.5) },
        // inverse texture size
        direction: { value: new qe(0.5, 0.5) },
        gaussianCoefficients: { value: n }
        // precomputed Gaussian coefficients
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
    });
  }
  getCompositeMaterial(e) {
    return new dn({
      defines: {
        NUM_MIPS: e
      },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
}
xa.BlurDirectionX = new qe(1, 0);
xa.BlurDirectionY = new qe(0, 1);
function EB() {
  return {
    enabled: !1,
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16,
    pixelBlurLength: 50,
    vectorDetail: 50,
    direction: 0,
    blurLength: 10,
    radialMode: "zoom",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    adaptiveThreshold: 2,
    motionBlurQuality: "normal",
    useGPU: !0
  };
}
class AB {
  constructor(e, n, i) {
    le(this, "settings");
    le(this, "frameBuffer", []);
    le(this, "maxBufferSize", 5);
    // Cached canvases for compositing
    le(this, "workCanvas");
    le(this, "workCtx");
    le(this, "outputCanvas");
    le(this, "outputCtx");
    this.settings = { ...EB(), ...i }, this.workCanvas = new OffscreenCanvas(e, n), this.workCtx = this.workCanvas.getContext("2d"), this.outputCanvas = new OffscreenCanvas(e, n), this.outputCtx = this.outputCanvas.getContext("2d");
  }
  // ============================================================================
  // SETTINGS
  // ============================================================================
  setSettings(e) {
    this.settings = { ...this.settings, ...e };
  }
  getSettings() {
    return { ...this.settings };
  }
  resize(e, n) {
    this.workCanvas = new OffscreenCanvas(e, n), this.workCtx = this.workCanvas.getContext("2d"), this.outputCanvas = new OffscreenCanvas(e, n), this.outputCtx = this.outputCanvas.getContext("2d"), this.frameBuffer = [];
  }
  // ============================================================================
  // VELOCITY CALCULATION
  // ============================================================================
  /**
   * Calculate velocity from transform changes between frames
   */
  calculateVelocity(e, n, i = 1) {
    return {
      x: (n.x - e.x) / i,
      y: (n.y - e.y) / i,
      rotation: (n.rotation - e.rotation) / i,
      scale: (n.scaleX - e.scaleX + (n.scaleY - e.scaleY)) / 2 / i
    };
  }
  /**
   * Get velocity magnitude
   */
  getVelocityMagnitude(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }
  // ============================================================================
  // BLUR APPLICATION
  // ============================================================================
  /**
   * Apply motion blur to a canvas based on current settings
   */
  applyMotionBlur(e, n, i) {
    if (!this.settings.enabled || this.settings.type === "none")
      return this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height), this.outputCtx.drawImage(e, 0, 0), this.outputCanvas;
    switch (this.addFrameToBuffer(e, n, i), this.settings.type) {
      case "standard":
        return this.applyStandardBlur(e, n);
      case "pixel":
        return this.applyPixelMotionBlur(e);
      case "directional":
        return this.applyDirectionalBlur(e);
      case "radial":
        return this.applyRadialBlur(e);
      case "vector":
        return this.applyVectorBlur(e, n);
      case "adaptive":
        return this.applyAdaptiveBlur(e, n);
      default:
        return this.outputCtx.drawImage(e, 0, 0), this.outputCanvas;
    }
  }
  /**
   * Add frame to circular buffer
   */
  addFrameToBuffer(e, n, i) {
    const o = new OffscreenCanvas(e.width, e.height);
    for (o.getContext("2d").drawImage(e, 0, 0), this.frameBuffer.push({
      canvas: o,
      velocity: n,
      timestamp: i
    }); this.frameBuffer.length > this.maxBufferSize; )
      this.frameBuffer.shift();
  }
  // ============================================================================
  // STANDARD MOTION BLUR (Shutter-based)
  // ============================================================================
  /**
   * Standard After Effects motion blur using shutter angle
   * Simulates camera shutter open during frame exposure
   */
  applyStandardBlur(e, n) {
    const { shutterAngle: i, shutterPhase: o, samplesPerFrame: a } = this.settings, r = i / 360, l = o / 360, c = n.x * r, u = n.y * r;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const d = this.getSampleCount(), h = 1 / d;
    this.outputCtx.globalAlpha = h;
    for (let p = 0; p < d; p++) {
      const f = p / (d - 1) - 0.5 + l, m = c * f, y = u * f;
      this.outputCtx.drawImage(e, m, y);
    }
    return this.outputCtx.globalAlpha = 1, this.outputCanvas;
  }
  // ============================================================================
  // PIXEL MOTION BLUR
  // ============================================================================
  /**
   * Pixel Motion Blur - analyzes motion between frames
   * Creates blur based on pixel movement vectors
   */
  applyPixelMotionBlur(e) {
    if (this.frameBuffer.length < 2)
      return this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height), this.outputCtx.drawImage(e, 0, 0), this.outputCanvas;
    const { pixelBlurLength: n, vectorDetail: i } = this.settings, o = n / 100;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const a = Math.min(this.frameBuffer.length, Math.ceil(i / 20) + 2), r = 1 / a;
    this.outputCtx.globalAlpha = r;
    for (let l = this.frameBuffer.length - a; l < this.frameBuffer.length; l++)
      if (l >= 0) {
        const c = this.frameBuffer[l], u = (this.frameBuffer.length - 1 - l) * o;
        this.outputCtx.save(), this.outputCtx.translate(
          -c.velocity.x * u * 0.5,
          -c.velocity.y * u * 0.5
        ), this.outputCtx.drawImage(c.canvas, 0, 0), this.outputCtx.restore();
      }
    return this.outputCtx.globalAlpha = 0.5, this.outputCtx.drawImage(e, 0, 0), this.outputCtx.globalAlpha = 1, this.outputCanvas;
  }
  // ============================================================================
  // DIRECTIONAL BLUR
  // ============================================================================
  /**
   * Directional blur - blur in a specific direction
   * Independent of actual motion
   */
  applyDirectionalBlur(e) {
    const { direction: n, blurLength: i } = this.settings, o = n * Math.PI / 180, a = Math.cos(o) * i, r = Math.sin(o) * i;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const l = this.getSampleCount(), c = 1 / l;
    this.outputCtx.globalAlpha = c;
    for (let u = 0; u < l; u++) {
      const d = u / (l - 1) - 0.5, h = a * d, p = r * d;
      this.outputCtx.drawImage(e, h, p);
    }
    return this.outputCtx.globalAlpha = 1, this.outputCanvas;
  }
  // ============================================================================
  // RADIAL BLUR
  // ============================================================================
  /**
   * Radial blur - zoom or spin blur from center point
   */
  applyRadialBlur(e) {
    const { radialMode: n, radialAmount: i, radialCenterX: o, radialCenterY: a } = this.settings, r = this.outputCanvas.width * o, l = this.outputCanvas.height * a;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const c = this.getSampleCount(), u = 1 / c, d = i / 100;
    this.outputCtx.globalAlpha = u;
    for (let h = 0; h < c; h++) {
      const p = h / (c - 1) - 0.5;
      if (this.outputCtx.save(), this.outputCtx.translate(r, l), n === "spin") {
        const f = p * d * 0.2;
        this.outputCtx.rotate(f);
      } else {
        const f = 1 + p * d * 0.1;
        this.outputCtx.scale(f, f);
      }
      this.outputCtx.translate(-r, -l), this.outputCtx.drawImage(e, 0, 0), this.outputCtx.restore();
    }
    return this.outputCtx.globalAlpha = 1, this.outputCanvas;
  }
  // ============================================================================
  // VECTOR MOTION BLUR
  // ============================================================================
  /**
   * Vector-based motion blur using velocity data
   * More accurate than pixel-based for known motion
   */
  applyVectorBlur(e, n) {
    const { shutterAngle: i, vectorDetail: o } = this.settings, a = i / 360, r = n.x * a, l = n.y * a, c = n.rotation * a * 0.01, u = n.scale * a * 1e-3;
    this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);
    const d = Math.ceil(o / 100 * this.getSampleCount()), h = 1 / d, p = this.outputCanvas.width / 2, f = this.outputCanvas.height / 2;
    this.outputCtx.globalAlpha = h;
    for (let m = 0; m < d; m++) {
      const y = m / (d - 1) - 0.5;
      this.outputCtx.save(), this.outputCtx.translate(p, f), this.outputCtx.translate(r * y, l * y), this.outputCtx.rotate(c * y), this.outputCtx.scale(1 + u * y, 1 + u * y), this.outputCtx.translate(-p, -f), this.outputCtx.drawImage(e, 0, 0), this.outputCtx.restore();
    }
    return this.outputCtx.globalAlpha = 1, this.outputCanvas;
  }
  // ============================================================================
  // ADAPTIVE BLUR
  // ============================================================================
  /**
   * Adaptive blur - automatically selects blur type based on motion
   */
  applyAdaptiveBlur(e, n) {
    const i = this.getVelocityMagnitude(n);
    if (i < this.settings.adaptiveThreshold)
      return this.outputCtx.clearRect(0, 0, this.outputCanvas.width, this.outputCanvas.height), this.outputCtx.drawImage(e, 0, 0), this.outputCanvas;
    if (Math.abs(n.rotation) > i * 0.5) {
      const o = this.settings.radialMode;
      this.settings.radialMode = "spin", this.settings.radialAmount = Math.min(100, Math.abs(n.rotation) * 2);
      const a = this.applyRadialBlur(e);
      return this.settings.radialMode = o, a;
    }
    if (Math.abs(n.scale) > 0.1) {
      const o = this.settings.radialMode;
      this.settings.radialMode = "zoom", this.settings.radialAmount = Math.min(100, Math.abs(n.scale) * 500);
      const a = this.applyRadialBlur(e);
      return this.settings.radialMode = o, a;
    }
    return this.applyVectorBlur(e, n);
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  /**
   * Get sample count based on quality setting
   */
  getSampleCount() {
    const e = this.settings.samplesPerFrame;
    switch (this.settings.motionBlurQuality) {
      case "draft":
        return Math.max(4, Math.floor(e / 2));
      case "high":
        return Math.min(64, e * 2);
      default:
        return e;
    }
  }
  /**
   * Clear frame buffer (call when seeking or starting new playback)
   */
  clearBuffer() {
    this.frameBuffer = [];
  }
  /**
   * Get motion blur intensity suggestion based on frame rate
   */
  static suggestSettings(e) {
    const i = 24 / e;
    return {
      shutterAngle: Math.min(360, 180 * i),
      samplesPerFrame: e >= 60 ? 8 : e >= 30 ? 12 : 16
    };
  }
}
const PB = {
  // Film Standards
  film_24fps: {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  film_cinematic: {
    type: "standard",
    shutterAngle: 172.8,
    // 1/48s at 24fps
    shutterPhase: -90,
    samplesPerFrame: 16
  },
  film_smooth: {
    type: "standard",
    shutterAngle: 270,
    shutterPhase: -90,
    samplesPerFrame: 24
  },
  // Video Standards
  video_30fps: {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 12
  },
  video_60fps: {
    type: "standard",
    shutterAngle: 180,
    shutterPhase: -90,
    samplesPerFrame: 8
  },
  // Stylized
  action_crisp: {
    type: "standard",
    shutterAngle: 90,
    shutterPhase: -45,
    samplesPerFrame: 8
  },
  dreamy: {
    type: "standard",
    shutterAngle: 360,
    shutterPhase: -180,
    samplesPerFrame: 32
  },
  staccato: {
    type: "standard",
    shutterAngle: 45,
    shutterPhase: -22.5,
    samplesPerFrame: 4
  },
  // Directional Effects
  speed_horizontal: {
    type: "directional",
    direction: 0,
    blurLength: 20,
    samplesPerFrame: 16
  },
  speed_vertical: {
    type: "directional",
    direction: 90,
    blurLength: 20,
    samplesPerFrame: 16
  },
  diagonal_streak: {
    type: "directional",
    direction: 45,
    blurLength: 30,
    samplesPerFrame: 24
  },
  // Radial Effects
  zoom_impact: {
    type: "radial",
    radialMode: "zoom",
    radialAmount: 75,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  spin_vortex: {
    type: "radial",
    radialMode: "spin",
    radialAmount: 50,
    radialCenterX: 0.5,
    radialCenterY: 0.5,
    samplesPerFrame: 24
  },
  // Advanced
  pixel_smooth: {
    type: "pixel",
    pixelBlurLength: 60,
    vectorDetail: 70,
    samplesPerFrame: 16
  },
  vector_accurate: {
    type: "vector",
    shutterAngle: 180,
    vectorDetail: 90,
    samplesPerFrame: 24
  },
  adaptive_auto: {
    type: "adaptive",
    shutterAngle: 180,
    adaptiveThreshold: 3,
    samplesPerFrame: 16
  }
};
class kB {
  constructor(e, n, i) {
    le(this, "renderer");
    le(this, "composer");
    le(this, "scene");
    le(this, "camera");
    // Render targets
    le(this, "colorTarget");
    le(this, "depthTarget");
    // Frame capture
    le(this, "captureCanvas");
    le(this, "captureCtx");
    // Depth capture material
    le(this, "depthMaterial");
    // Normal material for normal pass
    le(this, "normalMaterial");
    // Dimensions
    le(this, "width");
    le(this, "height");
    le(this, "pixelRatio");
    // Render mode
    le(this, "renderMode", "color");
    // DOF pass
    le(this, "bokehPass", null);
    le(this, "dofConfig", {
      enabled: !1,
      focusDistance: 500,
      aperture: 0.025,
      maxBlur: 0.01
    });
    // SSAO pass
    le(this, "ssaoPass", null);
    le(this, "ssaoConfig", {
      enabled: !1,
      kernelRadius: 8,
      minDistance: 5e-3,
      maxDistance: 0.1,
      intensity: 1,
      output: "default"
    });
    // Bloom pass (for emissive objects and lights)
    le(this, "bloomPass", null);
    le(this, "bloomConfig", {
      enabled: !1,
      strength: 1.5,
      radius: 0.4,
      threshold: 0.85
    });
    // Motion blur processor (canvas-based, applied post-render)
    le(this, "motionBlurProcessor");
    le(this, "motionBlurConfig", {
      enabled: !1,
      type: "standard",
      shutterAngle: 180,
      shutterPhase: -90,
      samplesPerFrame: 16
    });
    le(this, "previousFrameTransform", {
      x: 0,
      y: 0,
      rotation: 0,
      scaleX: 1,
      scaleY: 1
    });
    // ============================================================================
    // PRECOMP RENDER-TO-TEXTURE
    // ============================================================================
    /** Cache of render targets for precomps (keyed by compositionId) */
    le(this, "precompTargets", /* @__PURE__ */ new Map());
    this.scene = n, this.camera = i, this.width = e.width, this.height = e.height, this.pixelRatio = e.pixelRatio ?? Math.min(window.devicePixelRatio, 2), this.renderer = new A_({
      canvas: e.canvas,
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      preserveDrawingBuffer: !0,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: !1,
      depth: !0
    }), this.renderer.setPixelRatio(this.pixelRatio), this.renderer.setSize(this.width, this.height), this.renderer.outputColorSpace = pn, this.renderer.toneMapping = xh, this.renderer.toneMappingExposure = 1, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = X3;
    const o = Math.floor(this.width * this.pixelRatio), a = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(o, a), this.depthTarget = this.createDepthTarget(o, a), this.composer = new xB(this.renderer, this.colorTarget), this.setupDefaultPasses(), this.captureCanvas = new OffscreenCanvas(o, a), this.captureCtx = this.captureCanvas.getContext("2d"), this.depthMaterial = this.createDepthMaterial(), this.normalMaterial = new Bm(), this.motionBlurProcessor = new AB(o, a);
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(e, n) {
    return new Xn(e, n, {
      minFilter: Dt,
      magFilter: Dt,
      format: Sn,
      type: gi,
      colorSpace: pn,
      depthBuffer: !0,
      stencilBuffer: !1,
      samples: 4
      // MSAA
    });
  }
  createDepthTarget(e, n) {
    const i = new Xn(e, n, {
      minFilter: xn,
      magFilter: xn,
      format: Sn,
      type: Vn,
      depthBuffer: !0,
      stencilBuffer: !1
    });
    return i.depthTexture = new hu(e, n), i.depthTexture.format = ho, i.depthTexture.type = Vn, i;
  }
  createDepthMaterial() {
    return new dn({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: !1,
      depthTest: !1
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const e = new bB(this.scene.scene, this.camera.camera);
    this.composer.addPass(e);
    const n = new wB();
    this.composer.addPass(n);
  }
  /**
   * Add a post-processing pass
   */
  addPass(e) {
    const n = this.composer.passes.findIndex(
      (i) => i.constructor.name === "OutputPass"
    );
    n > -1 ? this.composer.insertPass(e, n) : this.composer.addPass(e);
  }
  /**
   * Remove a post-processing pass
   */
  removePass(e) {
    this.composer.removePass(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(e) {
    this.dofConfig = { ...this.dofConfig, ...e }, this.dofConfig.enabled ? (this.bokehPass || this.createBokehPass(), this.updateBokehPass()) : this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    Math.floor(this.width * this.pixelRatio), Math.floor(this.height * this.pixelRatio), this.bokehPass = new SB(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    ), this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const e = this.bokehPass.uniforms;
    e && (e.focus.value = this.dofConfig.focusDistance, e.aperture.value = this.dofConfig.aperture, e.maxblur.value = this.dofConfig.maxBlur);
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(e) {
    this.setDOF({ focusDistance: e });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(e) {
    this.setDOF({ aperture: e });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(e) {
    this.setDOF({ enabled: e });
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   */
  setSSAO(e) {
    this.ssaoConfig = { ...this.ssaoConfig, ...e }, this.ssaoConfig.enabled ? (this.ssaoPass || this.createSSAOPass(), this.updateSSAOPass()) : this.ssaoPass && (this.composer.removePass(this.ssaoPass), this.ssaoPass = null);
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return { ...this.ssaoConfig };
  }
  /**
   * Create the SSAO pass
   */
  createSSAOPass() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio);
    this.ssaoPass = new Fi(
      this.scene.scene,
      this.camera.camera,
      e,
      n
    );
    const i = this.composer.passes.findIndex(
      (o) => o.constructor.name === "RenderPass"
    );
    i > -1 ? this.composer.insertPass(this.ssaoPass, i + 1) : this.addPass(this.ssaoPass);
  }
  /**
   * Update SSAO pass parameters
   */
  updateSSAOPass() {
    if (!this.ssaoPass) return;
    this.ssaoPass.kernelRadius = this.ssaoConfig.kernelRadius, this.ssaoPass.minDistance = this.ssaoConfig.minDistance, this.ssaoPass.maxDistance = this.ssaoConfig.maxDistance;
    const e = {
      default: Fi.OUTPUT.Default,
      ssao: Fi.OUTPUT.SSAO,
      blur: Fi.OUTPUT.Blur,
      depth: Fi.OUTPUT.Depth,
      normal: Fi.OUTPUT.Normal
    };
    this.ssaoPass.output = e[this.ssaoConfig.output];
  }
  /**
   * Enable/disable SSAO (convenience method)
   */
  setSSAOEnabled(e) {
    this.setSSAO({ enabled: e });
  }
  /**
   * Set SSAO intensity (convenience method)
   */
  setSSAOIntensity(e) {
    this.setSSAO({ intensity: e });
  }
  /**
   * Set SSAO kernel radius (convenience method)
   */
  setSSAORadius(e) {
    this.setSSAO({ kernelRadius: e });
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, particles) glow
   */
  setBloom(e) {
    this.bloomConfig = { ...this.bloomConfig, ...e }, this.bloomConfig.enabled ? (this.bloomPass || this.createBloomPass(), this.updateBloomPass()) : this.bloomPass && (this.composer.removePass(this.bloomPass), this.bloomPass = null);
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return { ...this.bloomConfig };
  }
  /**
   * Create the bloom pass
   */
  createBloomPass() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio);
    this.bloomPass = new xa(
      new qe(e, n),
      this.bloomConfig.strength,
      this.bloomConfig.radius,
      this.bloomConfig.threshold
    );
    const i = this.composer.passes.findIndex(
      (o) => o.constructor.name === "SSAOPass"
    );
    if (i > -1)
      this.composer.insertPass(this.bloomPass, i + 1);
    else {
      const o = this.composer.passes.findIndex(
        (a) => a.constructor.name === "RenderPass"
      );
      o > -1 ? this.composer.insertPass(this.bloomPass, o + 1) : this.addPass(this.bloomPass);
    }
  }
  /**
   * Update bloom pass parameters
   */
  updateBloomPass() {
    this.bloomPass && (this.bloomPass.strength = this.bloomConfig.strength, this.bloomPass.radius = this.bloomConfig.radius, this.bloomPass.threshold = this.bloomConfig.threshold);
  }
  /**
   * Enable/disable bloom (convenience method)
   */
  setBloomEnabled(e) {
    this.setBloom({ enabled: e });
  }
  /**
   * Set bloom intensity (convenience method)
   */
  setBloomStrength(e) {
    this.setBloom({ strength: e });
  }
  /**
   * Set bloom threshold (convenience method)
   */
  setBloomThreshold(e) {
    this.setBloom({ threshold: e });
  }
  // ============================================================================
  // MOTION BLUR CONFIGURATION
  // ============================================================================
  /**
   * Configure motion blur
   */
  setMotionBlur(e) {
    this.motionBlurConfig = { ...this.motionBlurConfig, ...e }, this.motionBlurProcessor.setSettings({
      enabled: this.motionBlurConfig.enabled,
      type: this.motionBlurConfig.type,
      shutterAngle: this.motionBlurConfig.shutterAngle,
      shutterPhase: this.motionBlurConfig.shutterPhase,
      samplesPerFrame: this.motionBlurConfig.samplesPerFrame
    });
  }
  /**
   * Enable/disable motion blur
   */
  setMotionBlurEnabled(e) {
    this.setMotionBlur({ enabled: e });
  }
  /**
   * Set motion blur type
   */
  setMotionBlurType(e) {
    this.setMotionBlur({ type: e });
  }
  /**
   * Set shutter angle (0-720, 180 = standard film)
   */
  setMotionBlurShutterAngle(e) {
    this.setMotionBlur({ shutterAngle: e });
  }
  /**
   * Apply a motion blur preset by name
   */
  setMotionBlurPreset(e) {
    const n = PB[e];
    n && this.setMotionBlur({
      enabled: !0,
      type: n.type || "standard",
      shutterAngle: n.shutterAngle || 180,
      shutterPhase: n.shutterPhase || -90,
      samplesPerFrame: n.samplesPerFrame || 16,
      preset: e
    });
  }
  /**
   * Get current motion blur configuration
   */
  getMotionBlurConfig() {
    return { ...this.motionBlurConfig };
  }
  /**
   * Get the motion blur processor (for advanced use)
   */
  getMotionBlurProcessor() {
    return this.motionBlurProcessor;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ(), this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(e) {
    const n = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(e), this.renderer.render(this.scene.scene, this.camera.camera), this.renderer.setRenderTarget(n);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, e === "depth" || e === "normal" ? this.scene.scene.overrideMaterial = e === "depth" ? this.depthMaterial : this.normalMaterial : this.scene.scene.overrideMaterial = null;
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio), i = new Uint8Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      e,
      n,
      i
    );
    const o = new Uint8ClampedArray(i.length), a = e * 4;
    for (let r = 0; r < n; r++) {
      const l = (n - 1 - r) * a, c = r * a;
      o.set(i.subarray(l, l + a), c);
    }
    return new ImageData(o, e, n);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const i = new Float32Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      e,
      n,
      i
    );
    const o = new Float32Array(e * n);
    for (let r = 0; r < e * n; r++)
      o[r] = i[r * 4];
    const a = new Float32Array(e * n);
    for (let r = 0; r < n; r++) {
      const l = (n - 1 - r) * e, c = r * e;
      a.set(o.subarray(l, l + e), c);
    }
    return a;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(e, n) {
    this.width = e, this.height = n;
    const i = Math.floor(e * this.pixelRatio), o = Math.floor(n * this.pixelRatio);
    this.renderer.setSize(e, n), this.composer.setSize(i, o), this.colorTarget.dispose(), this.depthTarget.dispose(), this.colorTarget = this.createColorTarget(i, o), this.depthTarget = this.createDepthTarget(i, o), this.composer.renderTarget1.dispose(), this.composer.renderTarget2.dispose(), this.composer.renderTarget1 = this.colorTarget.clone(), this.composer.renderTarget2 = this.colorTarget.clone(), this.captureCanvas.width = i, this.captureCanvas.height = o, this.bokehPass && this.dofConfig.enabled && (this.composer.removePass(this.bokehPass), this.bokehPass = null, this.createBokehPass()), this.ssaoPass && this.ssaoConfig.enabled && (this.composer.removePass(this.ssaoPass), this.ssaoPass = null, this.createSSAOPass(), this.updateSSAOPass()), this.bloomPass && this.bloomConfig.enabled && (this.composer.removePass(this.bloomPass), this.bloomPass.dispose(), this.bloomPass = null, this.createBloomPass(), this.updateBloomPass());
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  /**
   * Create or get a render target for a precomp composition
   */
  getPrecompRenderTarget(e, n, i) {
    const o = `${e}_${n}_${i}`;
    let a = this.precompTargets.get(o);
    return a || (a = new Xn(n, i, {
      minFilter: Dt,
      magFilter: Dt,
      format: Sn,
      type: ps,
      colorSpace: pn,
      depthBuffer: !0,
      stencilBuffer: !1
    }), this.precompTargets.set(o, a)), a;
  }
  /**
   * Render a scene to an offscreen target and return the texture
   * Used for precomp rendering
   */
  renderSceneToTexture(e, n, i) {
    const o = this.renderer.getRenderTarget();
    return this.renderer.setRenderTarget(i), this.renderer.clear(), this.renderer.render(e, n), this.renderer.setRenderTarget(o), i.texture;
  }
  /**
   * Dispose a precomp render target
   */
  disposePrecompTarget(e) {
    for (const [n, i] of this.precompTargets.entries())
      n.startsWith(e + "_") && (i.dispose(), this.precompTargets.delete(n));
  }
  /**
   * Dispose all precomp render targets
   */
  disposeAllPrecompTargets() {
    for (const e of this.precompTargets.values())
      e.dispose();
    this.precompTargets.clear();
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null), this.ssaoPass && (this.composer.removePass(this.ssaoPass), this.ssaoPass = null), this.bloomPass && (this.composer.removePass(this.bloomPass), this.bloomPass.dispose(), this.bloomPass = null), this.disposeAllPrecompTargets(), this.colorTarget.dispose(), this.depthTarget.dispose(), this.depthMaterial.dispose(), this.normalMaterial.dispose(), this.composer.dispose(), this.renderer.dispose();
  }
}
class DB extends $i {
  constructor(n, i) {
    super(n);
    le(this, "mesh");
    le(this, "geometry");
    le(this, "material");
    le(this, "texture", null);
    /** Resource manager for texture loading */
    le(this, "resources");
    /** Image dimensions */
    le(this, "imageWidth", 100);
    le(this, "imageHeight", 100);
    /** Source URL or asset ID */
    le(this, "sourceUrl", null);
    /** Original (unprocessed) texture for effects source */
    le(this, "originalTexture", null);
    /** Canvas for rendering texture to 2D for effect processing */
    le(this, "textureCanvas", null);
    le(this, "textureCanvasCtx", null);
    this.resources = i, this.geometry = new nn(1, 1), this.material = new _n({
      color: 16777215,
      transparent: !0,
      side: mn,
      depthWrite: !1
    }), this.mesh = new Ke(this.geometry, this.material), this.mesh.name = `image_${this.id}`, this.group.add(this.mesh);
    const o = this.extractImageData(n);
    o.source && this.loadImage(o.source), this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(n) {
    const i = n.data;
    return {
      source: (i == null ? void 0 : i.source) ?? (i == null ? void 0 : i.url) ?? (i == null ? void 0 : i.assetId) ?? null,
      width: (i == null ? void 0 : i.width) ?? 100,
      height: (i == null ? void 0 : i.height) ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(n) {
    this.sourceUrl = n;
    try {
      const i = await this.resources.loadTexture(n, {
        minFilter: Dt,
        magFilter: Dt,
        generateMipmaps: !1,
        colorSpace: pn
      });
      this.setTexture(i);
    } catch (i) {
      fi.error(`ImageLayer: Failed to load image: ${n}`, i);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(n) {
    this.texture = n, this.originalTexture = n, this.material.map = n, this.material.needsUpdate = !0, n.image && (this.imageWidth = n.image.width || n.image.videoWidth || 100, this.imageHeight = n.image.height || n.image.videoHeight || 100, this.updateMeshSize(), this.textureCanvas = null, this.textureCanvasCtx = null, this.effectsDirty = !0);
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(n) {
    const i = this.resources.createTextureFromImageData(
      n,
      `layer_${this.id}_imagedata`,
      {
        minFilter: Dt,
        magFilter: Dt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.setTexture(i);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_canvas`,
      {
        minFilter: Dt,
        magFilter: Dt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.setTexture(i);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose(), this.geometry = new nn(this.imageWidth, this.imageHeight), this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(n, i) {
    this.imageWidth = n, this.imageHeight = i, this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(n) {
    this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215), this.material.needsUpdate = !0;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    var i;
    if (!((i = this.originalTexture) != null && i.image))
      return null;
    const n = this.originalTexture.image;
    return (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) && (this.textureCanvas = document.createElement("canvas"), this.textureCanvas.width = this.imageWidth, this.textureCanvas.height = this.imageHeight, this.textureCanvasCtx = this.textureCanvas.getContext("2d")), this.textureCanvasCtx ? (this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight), this.textureCanvasCtx.drawImage(n, 0, 0, this.imageWidth, this.imageHeight), this.textureCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Dt,
        magFilter: Dt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.texture = i, this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.evaluateEffects(n);
  }
  onApplyEvaluatedState(n) {
    n.properties.tint !== void 0 && this.setTint(n.properties.tint), n.effects.length > 0 && this.applyEvaluatedEffects(n.effects);
  }
  onUpdate(n) {
    const i = n.data;
    if (i != null && i.source || i != null && i.url || i != null && i.assetId) {
      const o = i.source ?? i.url ?? i.assetId;
      o !== this.sourceUrl && this.loadImage(o);
    }
    ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      i.width ?? this.imageWidth,
      i.height ?? this.imageHeight
    );
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class IB extends $i {
  constructor(n) {
    super(n);
    le(this, "mesh");
    le(this, "geometry");
    le(this, "material");
    /** Solid color */
    le(this, "color");
    /** Solid dimensions */
    le(this, "width");
    le(this, "height");
    /** Animated color property */
    le(this, "animatedColor");
    const i = this.extractSolidData(n);
    this.color = i.color, this.width = i.width, this.height = i.height, this.animatedColor = i.animatedColor, this.geometry = new nn(this.width, this.height), this.material = new _n({
      color: this.color,
      transparent: !0,
      side: mn,
      depthWrite: !1
    }), this.mesh = new Ke(this.geometry, this.material), this.mesh.name = `solid_${this.id}`, this.group.add(this.mesh), this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(n) {
    const i = n.data;
    return {
      color: (i == null ? void 0 : i.color) ?? "#808080",
      width: (i == null ? void 0 : i.width) ?? 1920,
      height: (i == null ? void 0 : i.height) ?? 1080,
      animatedColor: i == null ? void 0 : i.animatedColor
    };
  }
  /**
   * Set solid color
   */
  setColor(n) {
    this.color = n, this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new nn(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    var i;
    if ((i = this.animatedColor) != null && i.animated) {
      const o = this.evaluator.evaluate(this.animatedColor, n);
      this.material.color.set(o), this.material.needsUpdate = !0;
    }
  }
  onApplyEvaluatedState(n) {
    n.properties.color !== void 0 && (this.material.color.set(n.properties.color), this.material.needsUpdate = !0);
  }
  onUpdate(n) {
    const i = n.data;
    (i == null ? void 0 : i.color) !== void 0 && this.setColor(i.color), ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      (i == null ? void 0 : i.width) ?? this.width,
      (i == null ? void 0 : i.height) ?? this.height
    ), (i == null ? void 0 : i.animatedColor) !== void 0 && (this.animatedColor = i.animatedColor), i === void 0 && n.labelColor !== void 0 && this.setColor(n.labelColor);
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class V2 extends $i {
  constructor(n, i = !0) {
    super(n);
    /** Visual indicator (crosshair) for editor visibility */
    le(this, "indicator", null);
    /** Whether to show the null indicator */
    le(this, "showIndicator");
    /** Indicator size */
    le(this, "indicatorSize");
    this.showIndicator = i, this.indicatorSize = 50, this.showIndicator && this.createIndicator();
  }
  /**
   * Create visual indicator (crosshair) for the null object
   */
  createIndicator() {
    this.indicator = new Bi(), this.indicator.name = `null_indicator_${this.id}`;
    const n = this.indicatorSize, i = 16737792, o = new Gi({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), a = [
      new pe(-n / 2, 0, 0),
      new pe(n / 2, 0, 0)
    ], r = new Ut().setFromPoints(a), l = new cn(r, o);
    this.indicator.add(l);
    const c = [
      new pe(0, -n / 2, 0),
      new pe(0, n / 2, 0)
    ], u = new Ut().setFromPoints(c), d = new cn(u, o);
    if (this.indicator.add(d), this.threeD) {
      const m = [
        new pe(0, 0, -n / 2),
        new pe(0, 0, n / 2)
      ], y = new Ut().setFromPoints(m), g = new cn(y, o);
      this.indicator.add(g);
    }
    const h = new pu(3, 16), p = new _n({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1,
      side: mn
    }), f = new Ke(h, p);
    this.indicator.add(f), this.group.add(this.indicator), this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(n) {
    this.indicator && (this.indicator.visible = n);
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(n) {
    n !== this.indicatorSize && (this.indicatorSize = n, this.indicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    this.indicator && (this.indicator.traverse((n) => {
      n instanceof cn && (n.geometry.dispose(), n.material.dispose()), n instanceof Ke && (n.geometry.dispose(), n.material.dispose());
    }), this.indicator.clear(), this.indicator = null);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onApplyEvaluatedState(n) {
  }
  onUpdate(n) {
    n.threeD !== void 0 && n.threeD !== this.threeD && (this.threeD = n.threeD, this.indicator && this.showIndicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  onDispose() {
    this.disposeIndicator();
  }
}
function RB() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(o, a) {
    var r = o.id, l = o.name, c = o.dependencies;
    c === void 0 && (c = []);
    var u = o.init;
    u === void 0 && (u = function() {
    });
    var d = o.getTransferables;
    if (d === void 0 && (d = null), !s[r])
      try {
        c = c.map(function(p) {
          return p && p.isWorkerModule && (e(p, function(f) {
            if (f instanceof Error)
              throw f;
          }), p = s[p.id].value), p;
        }), u = i("<" + l + ">.init", u), d && (d = i("<" + l + ">.getTransferables", d));
        var h = null;
        typeof u == "function" ? h = u.apply(void 0, c) : console.error("worker module init function failed to rehydrate"), s[r] = {
          id: r,
          value: h,
          getTransferables: d
        }, a(h);
      } catch (p) {
        p && p.noLog || console.error(p), a(p);
      }
  }
  function n(o, a) {
    var r, l = o.id, c = o.args;
    (!s[l] || typeof s[l].value != "function") && a(new Error("Worker module " + l + ": not found or its 'init' did not return a function"));
    try {
      var u = (r = s[l]).value.apply(r, c);
      u && typeof u.then == "function" ? u.then(d, function(h) {
        return a(h instanceof Error ? h : new Error("" + h));
      }) : d(u);
    } catch (h) {
      a(h);
    }
    function d(h) {
      try {
        var p = s[l].getTransferables && s[l].getTransferables(h);
        (!p || !Array.isArray(p) || !p.length) && (p = void 0), a(h, p);
      } catch (f) {
        console.error(f), a(f);
      }
    }
  }
  function i(o, a) {
    var r = void 0;
    self.troikaDefine = function(c) {
      return r = c;
    };
    var l = URL.createObjectURL(
      new Blob(
        ["/** " + o.replace(/\*/g, "") + ` **/

troikaDefine(
` + a + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(l);
    } catch (c) {
      console.error(c);
    }
    return URL.revokeObjectURL(l), delete self.troikaDefine, r;
  }
  self.addEventListener("message", function(o) {
    var a = o.data, r = a.messageId, l = a.action, c = a.data;
    try {
      l === "registerModule" && e(c, function(u) {
        u instanceof Error ? postMessage({
          messageId: r,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: r,
          success: !0,
          result: { isCallable: typeof u == "function" }
        });
      }), l === "callModule" && n(c, function(u, d) {
        u instanceof Error ? postMessage({
          messageId: r,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: r,
          success: !0,
          result: u
        }, d || void 0);
      });
    } catch (u) {
      postMessage({
        messageId: r,
        success: !1,
        error: u.stack
      });
    }
  });
}
function LB(s) {
  var e = function() {
    for (var n = [], i = arguments.length; i--; ) n[i] = arguments[i];
    return e._getInitResult().then(function(o) {
      if (typeof o == "function")
        return o.apply(void 0, n);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var n = s.dependencies, i = s.init;
    n = Array.isArray(n) ? n.map(function(a) {
      return a && (a = a.onMainThread || a, a._getInitResult && (a = a._getInitResult())), a;
    }) : [];
    var o = Promise.all(n).then(function(a) {
      return i.apply(null, a);
    });
    return e._getInitResult = function() {
      return o;
    }, o;
  }, e;
}
var e5 = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (n) {
      console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + n.message + "]"
      );
    }
  return e5 = function() {
    return s;
  }, s;
}, FB = 0, OB = 0, L1 = !1, Sr = /* @__PURE__ */ Object.create(null), Cr = /* @__PURE__ */ Object.create(null), Yd = /* @__PURE__ */ Object.create(null);
function Ea(s) {
  if ((!s || typeof s.init != "function") && !L1)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, n = s.init, i = s.getTransferables, o = s.workerId, a = LB(s);
  o == null && (o = "#default");
  var r = "workerModule" + ++FB, l = s.name || r, c = null;
  e = e && e.map(function(d) {
    return typeof d == "function" && !d.workerModuleData && (L1 = !0, d = Ea({
      workerId: o,
      name: "<" + l + "> function dependency: " + d.name,
      init: `function(){return (
` + bc(d) + `
)}`
    }), L1 = !1), d && d.workerModuleData && (d = d.workerModuleData), d;
  });
  function u() {
    for (var d = [], h = arguments.length; h--; ) d[h] = arguments[h];
    if (!e5())
      return a.apply(void 0, d);
    if (!c) {
      c = H2(o, "registerModule", u.workerModuleData);
      var p = function() {
        c = null, Cr[o].delete(p);
      };
      (Cr[o] || (Cr[o] = /* @__PURE__ */ new Set())).add(p);
    }
    return c.then(function(f) {
      var m = f.isCallable;
      if (m)
        return H2(o, "callModule", { id: r, args: d });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return u.workerModuleData = {
    isWorkerModule: !0,
    id: r,
    name: l,
    dependencies: e,
    init: bc(n),
    getTransferables: i && bc(i)
  }, u.onMainThread = a, u;
}
function UB(s) {
  Cr[s] && Cr[s].forEach(function(e) {
    e();
  }), Sr[s] && (Sr[s].terminate(), delete Sr[s]);
}
function bc(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function zB(s) {
  var e = Sr[s];
  if (!e) {
    var n = bc(RB);
    e = Sr[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + n + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var o = i.data, a = o.messageId, r = Yd[a];
      if (!r)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete Yd[a], r(o);
    };
  }
  return e;
}
function H2(s, e, n) {
  return new Promise(function(i, o) {
    var a = ++OB;
    Yd[a] = function(r) {
      r.success ? i(r.result) : o(new Error("Error in worker " + e + " call: " + r.error));
    }, zB(s).postMessage({
      messageId: a,
      action: e,
      data: n
    });
  });
}
function t5() {
  var s = function(e) {
    function n(G, Q, K, Y, ee, ce, ae, de) {
      var ie = 1 - ae;
      de.x = ie * ie * G + 2 * ie * ae * K + ae * ae * ee, de.y = ie * ie * Q + 2 * ie * ae * Y + ae * ae * ce;
    }
    function i(G, Q, K, Y, ee, ce, ae, de, ie, he) {
      var ne = 1 - ie;
      he.x = ne * ne * ne * G + 3 * ne * ne * ie * K + 3 * ne * ie * ie * ee + ie * ie * ie * ae, he.y = ne * ne * ne * Q + 3 * ne * ne * ie * Y + 3 * ne * ie * ie * ce + ie * ie * ie * de;
    }
    function o(G, Q) {
      for (var K = /([MLQCZ])([^MLQCZ]*)/g, Y, ee, ce, ae, de; Y = K.exec(G); ) {
        var ie = Y[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(he) {
          return parseFloat(he);
        });
        switch (Y[1]) {
          case "M":
            ae = ee = ie[0], de = ce = ie[1];
            break;
          case "L":
            (ie[0] !== ae || ie[1] !== de) && Q("L", ae, de, ae = ie[0], de = ie[1]);
            break;
          case "Q": {
            Q("Q", ae, de, ae = ie[2], de = ie[3], ie[0], ie[1]);
            break;
          }
          case "C": {
            Q("C", ae, de, ae = ie[4], de = ie[5], ie[0], ie[1], ie[2], ie[3]);
            break;
          }
          case "Z":
            (ae !== ee || de !== ce) && Q("L", ae, de, ee, ce);
            break;
        }
      }
    }
    function a(G, Q, K) {
      K === void 0 && (K = 16);
      var Y = { x: 0, y: 0 };
      o(G, function(ee, ce, ae, de, ie, he, ne, N, te) {
        switch (ee) {
          case "L":
            Q(ce, ae, de, ie);
            break;
          case "Q": {
            for (var F = ce, B = ae, L = 1; L < K; L++)
              n(
                ce,
                ae,
                he,
                ne,
                de,
                ie,
                L / (K - 1),
                Y
              ), Q(F, B, Y.x, Y.y), F = Y.x, B = Y.y;
            break;
          }
          case "C": {
            for (var D = ce, j = ae, Z = 1; Z < K; Z++)
              i(
                ce,
                ae,
                he,
                ne,
                N,
                te,
                de,
                ie,
                Z / (K - 1),
                Y
              ), Q(D, j, Y.x, Y.y), D = Y.x, j = Y.y;
            break;
          }
        }
      });
    }
    var r = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", l = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", c = /* @__PURE__ */ new WeakMap(), u = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function d(G, Q) {
      var K = G.getContext ? G.getContext("webgl", u) : G, Y = c.get(K);
      if (!Y) {
        let ne = function(D) {
          var j = ce[D];
          if (!j && (j = ce[D] = K.getExtension(D), !j))
            throw new Error(D + " not supported");
          return j;
        }, N = function(D, j) {
          var Z = K.createShader(j);
          return K.shaderSource(Z, D), K.compileShader(Z), Z;
        }, te = function(D, j, Z, z) {
          if (!ae[D]) {
            var $ = {}, oe = {}, O = K.createProgram();
            K.attachShader(O, N(j, K.VERTEX_SHADER)), K.attachShader(O, N(Z, K.FRAGMENT_SHADER)), K.linkProgram(O), ae[D] = {
              program: O,
              transaction: function(H) {
                K.useProgram(O), H({
                  setUniform: function(ue, me) {
                    for (var _e = [], we = arguments.length - 2; we-- > 0; ) _e[we] = arguments[we + 2];
                    var Ae = oe[me] || (oe[me] = K.getUniformLocation(O, me));
                    K["uniform" + ue].apply(K, [Ae].concat(_e));
                  },
                  setAttribute: function(ue, me, _e, we, Ae) {
                    var Ve = $[ue];
                    Ve || (Ve = $[ue] = {
                      buf: K.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: K.getAttribLocation(O, ue),
                      data: null
                    }), K.bindBuffer(K.ARRAY_BUFFER, Ve.buf), K.vertexAttribPointer(Ve.loc, me, K.FLOAT, !1, 0, 0), K.enableVertexAttribArray(Ve.loc), ee ? K.vertexAttribDivisor(Ve.loc, we) : ne("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Ve.loc, we), Ae !== Ve.data && (K.bufferData(K.ARRAY_BUFFER, Ae, _e), Ve.data = Ae);
                  }
                });
              }
            };
          }
          ae[D].transaction(z);
        }, F = function(D, j) {
          ie++;
          try {
            K.activeTexture(K.TEXTURE0 + ie);
            var Z = de[D];
            Z || (Z = de[D] = K.createTexture(), K.bindTexture(K.TEXTURE_2D, Z), K.texParameteri(K.TEXTURE_2D, K.TEXTURE_MIN_FILTER, K.NEAREST), K.texParameteri(K.TEXTURE_2D, K.TEXTURE_MAG_FILTER, K.NEAREST)), K.bindTexture(K.TEXTURE_2D, Z), j(Z, ie);
          } finally {
            ie--;
          }
        }, B = function(D, j, Z) {
          var z = K.createFramebuffer();
          he.push(z), K.bindFramebuffer(K.FRAMEBUFFER, z), K.activeTexture(K.TEXTURE0 + j), K.bindTexture(K.TEXTURE_2D, D), K.framebufferTexture2D(K.FRAMEBUFFER, K.COLOR_ATTACHMENT0, K.TEXTURE_2D, D, 0);
          try {
            Z(z);
          } finally {
            K.deleteFramebuffer(z), K.bindFramebuffer(K.FRAMEBUFFER, he[--he.length - 1] || null);
          }
        }, L = function() {
          ce = {}, ae = {}, de = {}, ie = -1, he.length = 0;
        };
        var ee = typeof WebGL2RenderingContext < "u" && K instanceof WebGL2RenderingContext, ce = {}, ae = {}, de = {}, ie = -1, he = [];
        K.canvas.addEventListener("webglcontextlost", function(D) {
          L(), D.preventDefault();
        }, !1), c.set(K, Y = {
          gl: K,
          isWebGL2: ee,
          getExtension: ne,
          withProgram: te,
          withTexture: F,
          withTextureFramebuffer: B,
          handleContextLoss: L
        });
      }
      Q(Y);
    }
    function h(G, Q, K, Y, ee, ce, ae, de) {
      ae === void 0 && (ae = 15), de === void 0 && (de = null), d(G, function(ie) {
        var he = ie.gl, ne = ie.withProgram, N = ie.withTexture;
        N("copy", function(te, F) {
          he.texImage2D(he.TEXTURE_2D, 0, he.RGBA, ee, ce, 0, he.RGBA, he.UNSIGNED_BYTE, Q), ne("copy", r, l, function(B) {
            var L = B.setUniform, D = B.setAttribute;
            D("aUV", 2, he.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), L("1i", "image", F), he.bindFramebuffer(he.FRAMEBUFFER, de || null), he.disable(he.BLEND), he.colorMask(ae & 8, ae & 4, ae & 2, ae & 1), he.viewport(K, Y, ee, ce), he.scissor(K, Y, ee, ce), he.drawArrays(he.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function p(G, Q, K) {
      var Y = G.width, ee = G.height;
      d(G, function(ce) {
        var ae = ce.gl, de = new Uint8Array(Y * ee * 4);
        ae.readPixels(0, 0, Y, ee, ae.RGBA, ae.UNSIGNED_BYTE, de), G.width = Q, G.height = K, h(ae, de, 0, 0, Y, ee);
      });
    }
    var f = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: d,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: p
    });
    function m(G, Q, K, Y, ee, ce) {
      ce === void 0 && (ce = 1);
      var ae = new Uint8Array(G * Q), de = Y[2] - Y[0], ie = Y[3] - Y[1], he = [];
      a(K, function(D, j, Z, z) {
        he.push({
          x1: D,
          y1: j,
          x2: Z,
          y2: z,
          minX: Math.min(D, Z),
          minY: Math.min(j, z),
          maxX: Math.max(D, Z),
          maxY: Math.max(j, z)
        });
      }), he.sort(function(D, j) {
        return D.maxX - j.maxX;
      });
      for (var ne = 0; ne < G; ne++)
        for (var N = 0; N < Q; N++) {
          var te = B(
            Y[0] + de * (ne + 0.5) / G,
            Y[1] + ie * (N + 0.5) / Q
          ), F = Math.pow(1 - Math.abs(te) / ee, ce) / 2;
          te < 0 && (F = 1 - F), F = Math.max(0, Math.min(255, Math.round(F * 255))), ae[N * G + ne] = F;
        }
      return ae;
      function B(D, j) {
        for (var Z = 1 / 0, z = 1 / 0, $ = he.length; $--; ) {
          var oe = he[$];
          if (oe.maxX + z <= D)
            break;
          if (D + z > oe.minX && j - z < oe.maxY && j + z > oe.minY) {
            var O = x(D, j, oe.x1, oe.y1, oe.x2, oe.y2);
            O < Z && (Z = O, z = Math.sqrt(Z));
          }
        }
        return L(D, j) && (z = -z), z;
      }
      function L(D, j) {
        for (var Z = 0, z = he.length; z--; ) {
          var $ = he[z];
          if ($.maxX <= D)
            break;
          var oe = $.y1 > j != $.y2 > j && D < ($.x2 - $.x1) * (j - $.y1) / ($.y2 - $.y1) + $.x1;
          oe && (Z += $.y1 < $.y2 ? 1 : -1);
        }
        return Z !== 0;
      }
    }
    function y(G, Q, K, Y, ee, ce, ae, de, ie, he) {
      ce === void 0 && (ce = 1), de === void 0 && (de = 0), ie === void 0 && (ie = 0), he === void 0 && (he = 0), g(G, Q, K, Y, ee, ce, ae, null, de, ie, he);
    }
    function g(G, Q, K, Y, ee, ce, ae, de, ie, he, ne) {
      ce === void 0 && (ce = 1), ie === void 0 && (ie = 0), he === void 0 && (he = 0), ne === void 0 && (ne = 0);
      for (var N = m(G, Q, K, Y, ee, ce), te = new Uint8Array(N.length * 4), F = 0; F < N.length; F++)
        te[F * 4 + ne] = N[F];
      h(ae, te, ie, he, G, Q, 1 << 3 - ne, de);
    }
    function x(G, Q, K, Y, ee, ce) {
      var ae = ee - K, de = ce - Y, ie = ae * ae + de * de, he = ie ? Math.max(0, Math.min(1, ((G - K) * ae + (Q - Y) * de) / ie)) : 0, ne = G - (K + he * ae), N = Q - (Y + he * de);
      return ne * ne + N * N;
    }
    var w = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: m,
      generateIntoCanvas: y,
      generateIntoFramebuffer: g
    }), M = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", _ = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", C = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", T = new Float32Array([0, 0, 2, 0, 0, 2]), P = null, E = !1, b = {}, S = /* @__PURE__ */ new WeakMap();
    function A(G) {
      if (!E && !I(G))
        throw new Error("WebGL generation not supported");
    }
    function R(G, Q, K, Y, ee, ce, ae) {
      if (ce === void 0 && (ce = 1), ae === void 0 && (ae = null), !ae && (ae = P, !ae)) {
        var de = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!de)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        ae = P = de.getContext("webgl", { depth: !1 });
      }
      A(ae);
      var ie = new Uint8Array(G * Q * 4);
      d(ae, function(te) {
        var F = te.gl, B = te.withTexture, L = te.withTextureFramebuffer;
        B("readable", function(D, j) {
          F.texImage2D(F.TEXTURE_2D, 0, F.RGBA, G, Q, 0, F.RGBA, F.UNSIGNED_BYTE, null), L(D, j, function(Z) {
            U(
              G,
              Q,
              K,
              Y,
              ee,
              ce,
              F,
              Z,
              0,
              0,
              0
              // red channel
            ), F.readPixels(0, 0, G, Q, F.RGBA, F.UNSIGNED_BYTE, ie);
          });
        });
      });
      for (var he = new Uint8Array(G * Q), ne = 0, N = 0; ne < ie.length; ne += 4)
        he[N++] = ie[ne];
      return he;
    }
    function k(G, Q, K, Y, ee, ce, ae, de, ie, he) {
      ce === void 0 && (ce = 1), de === void 0 && (de = 0), ie === void 0 && (ie = 0), he === void 0 && (he = 0), U(G, Q, K, Y, ee, ce, ae, null, de, ie, he);
    }
    function U(G, Q, K, Y, ee, ce, ae, de, ie, he, ne) {
      ce === void 0 && (ce = 1), ie === void 0 && (ie = 0), he === void 0 && (he = 0), ne === void 0 && (ne = 0), A(ae);
      var N = [];
      a(K, function(te, F, B, L) {
        N.push(te, F, B, L);
      }), N = new Float32Array(N), d(ae, function(te) {
        var F = te.gl, B = te.isWebGL2, L = te.getExtension, D = te.withProgram, j = te.withTexture, Z = te.withTextureFramebuffer, z = te.handleContextLoss;
        if (j("rawDistances", function($, oe) {
          (G !== $._lastWidth || Q !== $._lastHeight) && F.texImage2D(
            F.TEXTURE_2D,
            0,
            F.RGBA,
            $._lastWidth = G,
            $._lastHeight = Q,
            0,
            F.RGBA,
            F.UNSIGNED_BYTE,
            null
          ), D("main", M, _, function(O) {
            var V = O.setAttribute, H = O.setUniform, X = !B && L("ANGLE_instanced_arrays"), ue = !B && L("EXT_blend_minmax");
            V("aUV", 2, F.STATIC_DRAW, 0, T), V("aLineSegment", 4, F.DYNAMIC_DRAW, 1, N), H.apply(void 0, ["4f", "uGlyphBounds"].concat(Y)), H("1f", "uMaxDistance", ee), H("1f", "uExponent", ce), Z($, oe, function(me) {
              F.enable(F.BLEND), F.colorMask(!0, !0, !0, !0), F.viewport(0, 0, G, Q), F.scissor(0, 0, G, Q), F.blendFunc(F.ONE, F.ONE), F.blendEquationSeparate(F.FUNC_ADD, B ? F.MAX : ue.MAX_EXT), F.clear(F.COLOR_BUFFER_BIT), B ? F.drawArraysInstanced(F.TRIANGLES, 0, 3, N.length / 4) : X.drawArraysInstancedANGLE(F.TRIANGLES, 0, 3, N.length / 4);
            });
          }), D("post", r, C, function(O) {
            O.setAttribute("aUV", 2, F.STATIC_DRAW, 0, T), O.setUniform("1i", "tex", oe), F.bindFramebuffer(F.FRAMEBUFFER, de), F.disable(F.BLEND), F.colorMask(ne === 0, ne === 1, ne === 2, ne === 3), F.viewport(ie, he, G, Q), F.scissor(ie, he, G, Q), F.drawArrays(F.TRIANGLES, 0, 3);
          });
        }), F.isContextLost())
          throw z(), new Error("webgl context lost");
      });
    }
    function I(G) {
      var Q = !G || G === P ? b : G.canvas || G, K = S.get(Q);
      if (K === void 0) {
        E = !0;
        var Y = null;
        try {
          var ee = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], ce = R(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            G
          );
          K = ce && ee.length === ce.length && ce.every(function(ae, de) {
            return ae === ee[de];
          }), K || (Y = "bad trial run results", console.info(ee, ce));
        } catch (ae) {
          K = !1, Y = ae.message;
        }
        Y && console.warn("WebGL SDF generation not supported:", Y), E = !1, S.set(Q, K);
      }
      return K;
    }
    var W = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: R,
      generateIntoCanvas: k,
      generateIntoFramebuffer: U,
      isSupported: I
    });
    function fe(G, Q, K, Y, ee, ce) {
      ee === void 0 && (ee = Math.max(Y[2] - Y[0], Y[3] - Y[1]) / 2), ce === void 0 && (ce = 1);
      try {
        return R.apply(W, arguments);
      } catch (ae) {
        return console.info("WebGL SDF generation failed, falling back to JS", ae), m.apply(w, arguments);
      }
    }
    function q(G, Q, K, Y, ee, ce, ae, de, ie, he) {
      ee === void 0 && (ee = Math.max(Y[2] - Y[0], Y[3] - Y[1]) / 2), ce === void 0 && (ce = 1), de === void 0 && (de = 0), ie === void 0 && (ie = 0), he === void 0 && (he = 0);
      try {
        return k.apply(W, arguments);
      } catch (ne) {
        return console.info("WebGL SDF generation failed, falling back to JS", ne), y.apply(w, arguments);
      }
    }
    return e.forEachPathCommand = o, e.generate = fe, e.generateIntoCanvas = q, e.javascript = w, e.pathToLineSegments = a, e.webgl = W, e.webglUtils = f, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
function BB() {
  var s = function(e) {
    var n = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, i = {}, o = {};
    i.L = 1, o[1] = "L", Object.keys(n).forEach(function(z, $) {
      i[z] = 1 << $ + 1, o[i[z]] = z;
    }), Object.freeze(i);
    var a = i.LRI | i.RLI | i.FSI, r = i.L | i.R | i.AL, l = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, c = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, u = i.S | i.WS | i.B | a | i.PDI | c, d = null;
    function h() {
      if (!d) {
        d = /* @__PURE__ */ new Map();
        var z = function(oe) {
          if (n.hasOwnProperty(oe)) {
            var O = 0;
            n[oe].split(",").forEach(function(V) {
              var H = V.split("+"), X = H[0], ue = H[1];
              X = parseInt(X, 36), ue = ue ? parseInt(ue, 36) : 0, d.set(O += X, i[oe]);
              for (var me = 0; me < ue; me++)
                d.set(++O, i[oe]);
            });
          }
        };
        for (var $ in n) z($);
      }
    }
    function p(z) {
      return h(), d.get(z.codePointAt(0)) || i.L;
    }
    function f(z) {
      return o[p(z)];
    }
    var m = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function y(z, $) {
      var oe = 36, O = 0, V = /* @__PURE__ */ new Map(), H = $ && /* @__PURE__ */ new Map(), X;
      return z.split(",").forEach(function ue(me) {
        if (me.indexOf("+") !== -1)
          for (var _e = +me; _e--; )
            ue(X);
        else {
          X = me;
          var we = me.split(">"), Ae = we[0], Ve = we[1];
          Ae = String.fromCodePoint(O += parseInt(Ae, oe)), Ve = String.fromCodePoint(O += parseInt(Ve, oe)), V.set(Ae, Ve), $ && H.set(Ve, Ae);
        }
      }), { map: V, reverseMap: H };
    }
    var g, x, w;
    function M() {
      if (!g) {
        var z = y(m.pairs, !0), $ = z.map, oe = z.reverseMap;
        g = $, x = oe, w = y(m.canonical, !1).map;
      }
    }
    function _(z) {
      return M(), g.get(z) || null;
    }
    function C(z) {
      return M(), x.get(z) || null;
    }
    function T(z) {
      return M(), w.get(z) || null;
    }
    var P = i.L, E = i.R, b = i.EN, S = i.ES, A = i.ET, R = i.AN, k = i.CS, U = i.B, I = i.S, W = i.ON, fe = i.BN, q = i.NSM, G = i.AL, Q = i.LRO, K = i.RLO, Y = i.LRE, ee = i.RLE, ce = i.PDF, ae = i.LRI, de = i.RLI, ie = i.FSI, he = i.PDI;
    function ne(z, $) {
      for (var oe = 125, O = new Uint32Array(z.length), V = 0; V < z.length; V++)
        O[V] = p(z[V]);
      var H = /* @__PURE__ */ new Map();
      function X(wi, Qi) {
        var Mi = O[wi];
        O[wi] = Qi, H.set(Mi, H.get(Mi) - 1), Mi & l && H.set(l, H.get(l) - 1), H.set(Qi, (H.get(Qi) || 0) + 1), Qi & l && H.set(l, (H.get(l) || 0) + 1);
      }
      for (var ue = new Uint8Array(z.length), me = /* @__PURE__ */ new Map(), _e = [], we = null, Ae = 0; Ae < z.length; Ae++)
        we || _e.push(we = {
          start: Ae,
          end: z.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: $ === "rtl" ? 1 : $ === "ltr" ? 0 : uf(Ae, !1)
        }), O[Ae] & U && (we.end = Ae, we = null);
      for (var Ve = ee | Y | K | Q | a | he | ce | U, Fe = function(wi) {
        return wi + (wi & 1 ? 1 : 2);
      }, $e = function(wi) {
        return wi + (wi & 1 ? 2 : 1);
      }, Ze = 0; Ze < _e.length; Ze++) {
        we = _e[Ze];
        var je = [{
          _level: we.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], Ue = void 0, rt = 0, Qe = 0, yt = 0;
        H.clear();
        for (var Ce = we.start; Ce <= we.end; Ce++) {
          var Be = O[Ce];
          if (Ue = je[je.length - 1], H.set(Be, (H.get(Be) || 0) + 1), Be & l && H.set(l, (H.get(l) || 0) + 1), Be & Ve)
            if (Be & (ee | Y)) {
              ue[Ce] = Ue._level;
              var ke = (Be === ee ? $e : Fe)(Ue._level);
              ke <= oe && !rt && !Qe ? je.push({
                _level: ke,
                _override: 0,
                _isolate: 0
              }) : rt || Qe++;
            } else if (Be & (K | Q)) {
              ue[Ce] = Ue._level;
              var Ge = (Be === K ? $e : Fe)(Ue._level);
              Ge <= oe && !rt && !Qe ? je.push({
                _level: Ge,
                _override: Be & K ? E : P,
                _isolate: 0
              }) : rt || Qe++;
            } else if (Be & a) {
              Be & ie && (Be = uf(Ce + 1, !0) === 1 ? de : ae), ue[Ce] = Ue._level, Ue._override && X(Ce, Ue._override);
              var Ye = (Be === de ? $e : Fe)(Ue._level);
              Ye <= oe && rt === 0 && Qe === 0 ? (yt++, je.push({
                _level: Ye,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: Ce
              })) : rt++;
            } else if (Be & he) {
              if (rt > 0)
                rt--;
              else if (yt > 0) {
                for (Qe = 0; !je[je.length - 1]._isolate; )
                  je.pop();
                var We = je[je.length - 1]._isolInitIndex;
                We != null && (me.set(We, Ce), me.set(Ce, We)), je.pop(), yt--;
              }
              Ue = je[je.length - 1], ue[Ce] = Ue._level, Ue._override && X(Ce, Ue._override);
            } else Be & ce ? (rt === 0 && (Qe > 0 ? Qe-- : !Ue._isolate && je.length > 1 && (je.pop(), Ue = je[je.length - 1])), ue[Ce] = Ue._level) : Be & U && (ue[Ce] = we.level);
          else
            ue[Ce] = Ue._level, Ue._override && Be !== fe && X(Ce, Ue._override);
        }
        for (var ht = [], ut = null, ft = we.start; ft <= we.end; ft++) {
          var vt = O[ft];
          if (!(vt & c)) {
            var Gt = ue[ft], en = vt & a, hn = vt === he;
            ut && Gt === ut._level ? (ut._end = ft, ut._endsWithIsolInit = en) : ht.push(ut = {
              _start: ft,
              _end: ft,
              _level: Gt,
              _startsWithPDI: hn,
              _endsWithIsolInit: en
            });
          }
        }
        for (var Yn = [], Pn = 0; Pn < ht.length; Pn++) {
          var li = ht[Pn];
          if (!li._startsWithPDI || li._startsWithPDI && !me.has(li._start)) {
            for (var Ei = [ut = li], Ai = void 0; ut && ut._endsWithIsolInit && (Ai = me.get(ut._end)) != null; )
              for (var qn = Pn + 1; qn < ht.length; qn++)
                if (ht[qn]._start === Ai) {
                  Ei.push(ut = ht[qn]);
                  break;
                }
            for (var kn = [], yi = 0; yi < Ei.length; yi++)
              for (var Ki = Ei[yi], ve = Ki._start; ve <= Ki._end; ve++)
                kn.push(ve);
            for (var Me = ue[kn[0]], Pe = we.level, ze = kn[0] - 1; ze >= 0; ze--)
              if (!(O[ze] & c)) {
                Pe = ue[ze];
                break;
              }
            var J = kn[kn.length - 1], ge = ue[J], be = we.level;
            if (!(O[J] & a)) {
              for (var Ee = J + 1; Ee <= we.end; Ee++)
                if (!(O[Ee] & c)) {
                  be = ue[Ee];
                  break;
                }
            }
            Yn.push({
              _seqIndices: kn,
              _sosType: Math.max(Pe, Me) % 2 ? E : P,
              _eosType: Math.max(be, ge) % 2 ? E : P
            });
          }
        }
        for (var Se = 0; Se < Yn.length; Se++) {
          var Oe = Yn[Se], De = Oe._seqIndices, et = Oe._sosType, lt = Oe._eosType, gt = ue[De[0]] & 1 ? E : P;
          if (H.get(q))
            for (var wt = 0; wt < De.length; wt++) {
              var dt = De[wt];
              if (O[dt] & q) {
                for (var Rt = et, Wt = wt - 1; Wt >= 0; Wt--)
                  if (!(O[De[Wt]] & c)) {
                    Rt = O[De[Wt]];
                    break;
                  }
                X(dt, Rt & (a | he) ? W : Rt);
              }
            }
          if (H.get(b))
            for (var Xt = 0; Xt < De.length; Xt++) {
              var Hn = De[Xt];
              if (O[Hn] & b)
                for (var zt = Xt - 1; zt >= -1; zt--) {
                  var pt = zt === -1 ? et : O[De[zt]];
                  if (pt & r) {
                    pt === G && X(Hn, R);
                    break;
                  }
                }
            }
          if (H.get(G))
            for (var Pi = 0; Pi < De.length; Pi++) {
              var Ht = De[Pi];
              O[Ht] & G && X(Ht, E);
            }
          if (H.get(S) || H.get(k))
            for (var Gn = 1; Gn < De.length - 1; Gn++) {
              var ms = De[Gn];
              if (O[ms] & (S | k)) {
                for (var Dn = 0, ks = 0, Jt = Gn - 1; Jt >= 0 && (Dn = O[De[Jt]], !!(Dn & c)); Jt--)
                  ;
                for (var xi = Gn + 1; xi < De.length && (ks = O[De[xi]], !!(ks & c)); xi++)
                  ;
                Dn === ks && (O[ms] === S ? Dn === b : Dn & (b | R)) && X(ms, Dn);
              }
            }
          if (H.get(b))
            for (var Zn = 0; Zn < De.length; Zn++) {
              var bi = De[Zn];
              if (O[bi] & b) {
                for (var ki = Zn - 1; ki >= 0 && O[De[ki]] & (A | c); ki--)
                  X(De[ki], b);
                for (Zn++; Zn < De.length && O[De[Zn]] & (A | c | b); Zn++)
                  O[De[Zn]] !== b && X(De[Zn], b);
              }
            }
          if (H.get(A) || H.get(S) || H.get(k))
            for (var _i = 0; _i < De.length; _i++) {
              var ka = De[_i];
              if (O[ka] & (A | S | k)) {
                X(ka, W);
                for (var el = _i - 1; el >= 0 && O[De[el]] & c; el--)
                  X(De[el], W);
                for (var tl = _i + 1; tl < De.length && O[De[tl]] & c; tl++)
                  X(De[tl], W);
              }
            }
          if (H.get(b))
            for (var Cu = 0, Kh = et; Cu < De.length; Cu++) {
              var Jh = De[Cu], Tu = O[Jh];
              Tu & b ? Kh === P && X(Jh, P) : Tu & r && (Kh = Tu);
            }
          if (H.get(l)) {
            var Da = E | b | R, Qh = Da | P, nl = [];
            {
              for (var wo = [], Mo = 0; Mo < De.length; Mo++)
                if (O[De[Mo]] & l) {
                  var Ia = z[De[Mo]], ef = void 0;
                  if (_(Ia) !== null)
                    if (wo.length < 63)
                      wo.push({ char: Ia, seqIndex: Mo });
                    else
                      break;
                  else if ((ef = C(Ia)) !== null)
                    for (var Ra = wo.length - 1; Ra >= 0; Ra--) {
                      var Eu = wo[Ra].char;
                      if (Eu === ef || Eu === C(T(Ia)) || _(T(Eu)) === Ia) {
                        nl.push([wo[Ra].seqIndex, Mo]), wo.length = Ra;
                        break;
                      }
                    }
                }
              nl.sort(function(wi, Qi) {
                return wi[0] - Qi[0];
              });
            }
            for (var Au = 0; Au < nl.length; Au++) {
              for (var tf = nl[Au], il = tf[0], Pu = tf[1], nf = !1, Ji = 0, ku = il + 1; ku < Pu; ku++) {
                var sf = De[ku];
                if (O[sf] & Qh) {
                  nf = !0;
                  var of = O[sf] & Da ? E : P;
                  if (of === gt) {
                    Ji = of;
                    break;
                  }
                }
              }
              if (nf && !Ji) {
                Ji = et;
                for (var Du = il - 1; Du >= 0; Du--) {
                  var af = De[Du];
                  if (O[af] & Qh) {
                    var rf = O[af] & Da ? E : P;
                    rf !== gt ? Ji = rf : Ji = gt;
                    break;
                  }
                }
              }
              if (Ji) {
                if (O[De[il]] = O[De[Pu]] = Ji, Ji !== gt) {
                  for (var La = il + 1; La < De.length; La++)
                    if (!(O[De[La]] & c)) {
                      p(z[De[La]]) & q && (O[De[La]] = Ji);
                      break;
                    }
                }
                if (Ji !== gt) {
                  for (var Fa = Pu + 1; Fa < De.length; Fa++)
                    if (!(O[De[Fa]] & c)) {
                      p(z[De[Fa]]) & q && (O[De[Fa]] = Ji);
                      break;
                    }
                }
              }
            }
            for (var l0 = 0; l0 < De.length; l0++)
              if (O[De[l0]] & l) {
                for (var lf = l0, Iu = l0, Ru = et, Oa = l0 - 1; Oa >= 0; Oa--)
                  if (O[De[Oa]] & c)
                    lf = Oa;
                  else {
                    Ru = O[De[Oa]] & Da ? E : P;
                    break;
                  }
                for (var cf = lt, Ua = l0 + 1; Ua < De.length; Ua++)
                  if (O[De[Ua]] & (l | c))
                    Iu = Ua;
                  else {
                    cf = O[De[Ua]] & Da ? E : P;
                    break;
                  }
                for (var Lu = lf; Lu <= Iu; Lu++)
                  O[De[Lu]] = Ru === cf ? Ru : gt;
                l0 = Iu;
              }
          }
        }
        for (var Di = we.start; Di <= we.end; Di++) {
          var N5 = ue[Di], sl = O[Di];
          if (N5 & 1 ? sl & (P | b | R) && ue[Di]++ : sl & E ? ue[Di]++ : sl & (R | b) && (ue[Di] += 2), sl & c && (ue[Di] = Di === 0 ? we.level : ue[Di - 1]), Di === we.end || p(z[Di]) & (I | U))
            for (var ol = Di; ol >= 0 && p(z[ol]) & u; ol--)
              ue[ol] = we.level;
        }
      }
      return {
        levels: ue,
        paragraphs: _e
      };
      function uf(wi, Qi) {
        for (var Mi = wi; Mi < z.length; Mi++) {
          var c0 = O[Mi];
          if (c0 & (E | G))
            return 1;
          if (c0 & (U | P) || Qi && c0 === he)
            return 0;
          if (c0 & a) {
            var df = V5(Mi);
            Mi = df === -1 ? z.length : df;
          }
        }
        return 0;
      }
      function V5(wi) {
        for (var Qi = 1, Mi = wi + 1; Mi < z.length; Mi++) {
          var c0 = O[Mi];
          if (c0 & U)
            break;
          if (c0 & he) {
            if (--Qi === 0)
              return Mi;
          } else c0 & a && Qi++;
        }
        return -1;
      }
    }
    var N = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", te;
    function F() {
      if (!te) {
        var z = y(N, !0), $ = z.map, oe = z.reverseMap;
        oe.forEach(function(O, V) {
          $.set(V, O);
        }), te = $;
      }
    }
    function B(z) {
      return F(), te.get(z) || null;
    }
    function L(z, $, oe, O) {
      var V = z.length;
      oe = Math.max(0, oe == null ? 0 : +oe), O = Math.min(V - 1, O == null ? V - 1 : +O);
      for (var H = /* @__PURE__ */ new Map(), X = oe; X <= O; X++)
        if ($[X] & 1) {
          var ue = B(z[X]);
          ue !== null && H.set(X, ue);
        }
      return H;
    }
    function D(z, $, oe, O) {
      var V = z.length;
      oe = Math.max(0, oe == null ? 0 : +oe), O = Math.min(V - 1, O == null ? V - 1 : +O);
      var H = [];
      return $.paragraphs.forEach(function(X) {
        var ue = Math.max(oe, X.start), me = Math.min(O, X.end);
        if (ue < me) {
          for (var _e = $.levels.slice(ue, me + 1), we = me; we >= ue && p(z[we]) & u; we--)
            _e[we] = X.level;
          for (var Ae = X.level, Ve = 1 / 0, Fe = 0; Fe < _e.length; Fe++) {
            var $e = _e[Fe];
            $e > Ae && (Ae = $e), $e < Ve && (Ve = $e | 1);
          }
          for (var Ze = Ae; Ze >= Ve; Ze--)
            for (var je = 0; je < _e.length; je++)
              if (_e[je] >= Ze) {
                for (var Ue = je; je + 1 < _e.length && _e[je + 1] >= Ze; )
                  je++;
                je > Ue && H.push([Ue + ue, je + ue]);
              }
        }
      }), H;
    }
    function j(z, $, oe, O) {
      var V = Z(z, $, oe, O), H = [].concat(z);
      return V.forEach(function(X, ue) {
        H[ue] = ($.levels[X] & 1 ? B(z[X]) : null) || z[X];
      }), H.join("");
    }
    function Z(z, $, oe, O) {
      for (var V = D(z, $, oe, O), H = [], X = 0; X < z.length; X++)
        H[X] = X;
      return V.forEach(function(ue) {
        for (var me = ue[0], _e = ue[1], we = H.slice(me, _e + 1), Ae = we.length; Ae--; )
          H[_e - Ae] = we[Ae];
      }), H;
    }
    return e.closingToOpeningBracket = C, e.getBidiCharType = p, e.getBidiCharTypeName = f, e.getCanonicalBracket = T, e.getEmbeddingLevels = ne, e.getMirroredCharacter = B, e.getMirroredCharactersMap = L, e.getReorderSegments = D, e.getReorderedIndices = Z, e.getReorderedString = j, e.openingToClosingBracket = _, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
const n5 = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function qd(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function n(i, o) {
    let a = kt[o];
    return a ? qd(a) : i;
  }
  return s.replace(e, n);
}
const $n = [];
for (let s = 0; s < 256; s++)
  $n[s] = (s < 16 ? "0" : "") + s.toString(16);
function NB() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return ($n[s & 255] + $n[s >> 8 & 255] + $n[s >> 16 & 255] + $n[s >> 24 & 255] + "-" + $n[e & 255] + $n[e >> 8 & 255] + "-" + $n[e >> 16 & 15 | 64] + $n[e >> 24 & 255] + "-" + $n[n & 63 | 128] + $n[n >> 8 & 255] + "-" + $n[n >> 16 & 255] + $n[n >> 24 & 255] + $n[i & 255] + $n[i >> 8 & 255] + $n[i >> 16 & 255] + $n[i >> 24 & 255]).toUpperCase();
}
const q0 = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, n = arguments.length; e < n; e++) {
    let i = arguments[e];
    if (i)
      for (let o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (s[o] = i[o]);
  }
  return s;
}, VB = Date.now(), G2 = /* @__PURE__ */ new WeakMap(), $2 = /* @__PURE__ */ new Map();
let HB = 1e10;
function Zd(s, e) {
  const n = jB(e);
  let i = G2.get(s);
  if (i || G2.set(s, i = /* @__PURE__ */ Object.create(null)), i[n])
    return new i[n]();
  const o = `_onBeforeCompile${n}`, a = function(u, d) {
    s.onBeforeCompile.call(this, u, d);
    const h = this.customProgramCacheKey() + "|" + u.vertexShader + "|" + u.fragmentShader;
    let p = $2[h];
    if (!p) {
      const f = GB(this, u, e, n);
      p = $2[h] = f;
    }
    u.vertexShader = p.vertexShader, u.fragmentShader = p.fragmentShader, q0(u.uniforms, this.uniforms), e.timeUniform && (u.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - VB;
      }
    }), this[o] && this[o](u);
  }, r = function() {
    return l(e.chained ? s : s.clone());
  }, l = function(u) {
    const d = Object.create(u, c);
    return Object.defineProperty(d, "baseMaterial", { value: s }), Object.defineProperty(d, "id", { value: HB++ }), d.uuid = NB(), d.uniforms = q0({}, u.uniforms, e.uniforms), d.defines = q0({}, u.defines, e.defines), d.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = "", d.extensions = q0({}, u.extensions, e.extensions), d._listeners = void 0, d;
  }, c = {
    constructor: { value: r },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => s.type,
      set: (u) => {
        s.type = u;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        const d = this.baseMaterial;
        return u === d || d.isDerivedMaterial && d.isDerivedFrom(u) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + n;
      }
    },
    onBeforeCompile: {
      get() {
        return a;
      },
      set(u) {
        this[o] = u;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        return s.copy.call(this, u), !s.isShaderMaterial && !s.isDerivedMaterial && (q0(this.extensions, u.extensions), q0(this.defines, u.defines), q0(this.uniforms, ls.clone(u.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const u = new s.constructor();
        return l(u).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._depthMaterial;
        return u || (u = this._depthMaterial = Zd(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Rh({ depthPacking: Th }),
          e
        ), u.defines.IS_DEPTH_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._distanceMaterial;
        return u || (u = this._distanceMaterial = Zd(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new km(),
          e
        ), u.defines.IS_DISTANCE_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: u, _distanceMaterial: d } = this;
        u && u.dispose(), d && d.dispose(), s.dispose.call(this);
      }
    }
  };
  return i[n] = r, new r();
}
function GB(s, { vertexShader: e, fragmentShader: n }, i, o) {
  let {
    vertexDefs: a,
    vertexMainIntro: r,
    vertexMainOutro: l,
    vertexTransform: c,
    fragmentDefs: u,
    fragmentMainIntro: d,
    fragmentMainOutro: h,
    fragmentColorTransform: p,
    customRewriter: f,
    timeUniform: m
  } = i;
  if (a = a || "", r = r || "", l = l || "", u = u || "", d = d || "", h = h || "", (c || f) && (e = qd(e)), (p || f) && (n = n.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), n = qd(n)), f) {
    let y = f({ vertexShader: e, fragmentShader: n });
    e = y.vertexShader, n = y.fragmentShader;
  }
  if (p) {
    let y = [];
    n = n.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (g) => (y.push(g), "")
    ), h = `${p}
${y.join(`
`)}
${h}`;
  }
  if (m) {
    const y = `
uniform float ${m};
`;
    a = y + a, u = y + u;
  }
  return c && (e = `vec3 troika_position_${o};
vec3 troika_normal_${o};
vec2 troika_uv_${o};
${e}
`, a = `${a}
void troikaVertexTransform${o}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${c}
}
`, r = `
troika_position_${o} = vec3(position);
troika_normal_${o} = vec3(normal);
troika_uv_${o} = vec2(uv);
troikaVertexTransform${o}(troika_position_${o}, troika_normal_${o}, troika_uv_${o});
${r}
`, e = e.replace(/\b(position|normal|uv)\b/g, (y, g, x, w) => /\battribute\s+vec[23]\s+$/.test(w.substr(0, x)) ? g : `troika_${g}_${o}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${o}`))), e = W2(e, o, a, r, l), n = W2(n, o, u, d, h), {
    vertexShader: e,
    fragmentShader: n
  };
}
function W2(s, e, n, i, o) {
  return (i || o || n) && (s = s.replace(
    n5,
    `
${n}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${o}
}`), s;
}
function $B(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let WB = 0;
const j2 = /* @__PURE__ */ new Map();
function jB(s) {
  const e = JSON.stringify(s, $B);
  let n = j2.get(e);
  return n == null && j2.set(e, n = ++WB), n;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function XB() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(o) {
      var a = e._bin, r = new Uint8Array(o);
      if (a.readASCII(r, 0, 4) == "ttcf") {
        var l = 4;
        a.readUshort(r, l), l += 2, a.readUshort(r, l), l += 2;
        var c = a.readUint(r, l);
        l += 4;
        for (var u = [], d = 0; d < c; d++) {
          var h = a.readUint(r, l);
          l += 4, u.push(e._readFont(r, h));
        }
        return u;
      }
      return [e._readFont(r, 0)];
    }, _readFont: function(o, a) {
      var r = e._bin, l = a;
      r.readFixed(o, a), a += 4;
      var c = r.readUshort(o, a);
      a += 2, r.readUshort(o, a), a += 2, r.readUshort(o, a), a += 2, r.readUshort(o, a), a += 2;
      for (var u = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], d = { _data: o, _offset: l }, h = {}, p = 0; p < c; p++) {
        var f = r.readASCII(o, a, 4);
        a += 4, r.readUint(o, a), a += 4;
        var m = r.readUint(o, a);
        a += 4;
        var y = r.readUint(o, a);
        a += 4, h[f] = { offset: m, length: y };
      }
      for (p = 0; p < u.length; p++) {
        var g = u[p];
        h[g] && (d[g.trim()] = e[g.trim()].parse(o, h[g].offset, h[g].length, d));
      }
      return d;
    }, _tabOffset: function(o, a, r) {
      for (var l = e._bin, c = l.readUshort(o, r + 4), u = r + 12, d = 0; d < c; d++) {
        var h = l.readASCII(o, u, 4);
        u += 4, l.readUint(o, u), u += 4;
        var p = l.readUint(o, u);
        if (u += 4, l.readUint(o, u), u += 4, h == a) return p;
      }
      return 0;
    } };
    e._bin = { readFixed: function(o, a) {
      return (o[a] << 8 | o[a + 1]) + (o[a + 2] << 8 | o[a + 3]) / 65540;
    }, readF2dot14: function(o, a) {
      return e._bin.readShort(o, a) / 16384;
    }, readInt: function(o, a) {
      return e._bin._view(o).getInt32(a);
    }, readInt8: function(o, a) {
      return e._bin._view(o).getInt8(a);
    }, readShort: function(o, a) {
      return e._bin._view(o).getInt16(a);
    }, readUshort: function(o, a) {
      return e._bin._view(o).getUint16(a);
    }, readUshorts: function(o, a, r) {
      for (var l = [], c = 0; c < r; c++) l.push(e._bin.readUshort(o, a + 2 * c));
      return l;
    }, readUint: function(o, a) {
      return e._bin._view(o).getUint32(a);
    }, readUint64: function(o, a) {
      return 4294967296 * e._bin.readUint(o, a) + e._bin.readUint(o, a + 4);
    }, readASCII: function(o, a, r) {
      for (var l = "", c = 0; c < r; c++) l += String.fromCharCode(o[a + c]);
      return l;
    }, readUnicode: function(o, a, r) {
      for (var l = "", c = 0; c < r; c++) {
        var u = o[a++] << 8 | o[a++];
        l += String.fromCharCode(u);
      }
      return l;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(o, a, r) {
      var l = e._bin._tdec;
      return l && a == 0 && r == o.length ? l.decode(o) : e._bin.readASCII(o, a, r);
    }, readBytes: function(o, a, r) {
      for (var l = [], c = 0; c < r; c++) l.push(o[a + c]);
      return l;
    }, readASCIIArray: function(o, a, r) {
      for (var l = [], c = 0; c < r; c++) l.push(String.fromCharCode(o[a + c]));
      return l;
    }, _view: function(o) {
      return o._dataView || (o._dataView = o.buffer ? new DataView(o.buffer, o.byteOffset, o.byteLength) : new DataView(new Uint8Array(o).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(o, a, r, l, c) {
      var u = e._bin, d = {}, h = a;
      u.readFixed(o, a), a += 4;
      var p = u.readUshort(o, a);
      a += 2;
      var f = u.readUshort(o, a);
      a += 2;
      var m = u.readUshort(o, a);
      return a += 2, d.scriptList = e._lctf.readScriptList(o, h + p), d.featureList = e._lctf.readFeatureList(o, h + f), d.lookupList = e._lctf.readLookupList(o, h + m, c), d;
    }, e._lctf.readLookupList = function(o, a, r) {
      var l = e._bin, c = a, u = [], d = l.readUshort(o, a);
      a += 2;
      for (var h = 0; h < d; h++) {
        var p = l.readUshort(o, a);
        a += 2;
        var f = e._lctf.readLookupTable(o, c + p, r);
        u.push(f);
      }
      return u;
    }, e._lctf.readLookupTable = function(o, a, r) {
      var l = e._bin, c = a, u = { tabs: [] };
      u.ltype = l.readUshort(o, a), a += 2, u.flag = l.readUshort(o, a), a += 2;
      var d = l.readUshort(o, a);
      a += 2;
      for (var h = u.ltype, p = 0; p < d; p++) {
        var f = l.readUshort(o, a);
        a += 2;
        var m = r(o, h, c + f, u);
        u.tabs.push(m);
      }
      return u;
    }, e._lctf.numOfOnes = function(o) {
      for (var a = 0, r = 0; r < 32; r++) o >>> r & 1 && a++;
      return a;
    }, e._lctf.readClassDef = function(o, a) {
      var r = e._bin, l = [], c = r.readUshort(o, a);
      if (a += 2, c == 1) {
        var u = r.readUshort(o, a);
        a += 2;
        var d = r.readUshort(o, a);
        a += 2;
        for (var h = 0; h < d; h++) l.push(u + h), l.push(u + h), l.push(r.readUshort(o, a)), a += 2;
      }
      if (c == 2) {
        var p = r.readUshort(o, a);
        for (a += 2, h = 0; h < p; h++) l.push(r.readUshort(o, a)), a += 2, l.push(r.readUshort(o, a)), a += 2, l.push(r.readUshort(o, a)), a += 2;
      }
      return l;
    }, e._lctf.getInterval = function(o, a) {
      for (var r = 0; r < o.length; r += 3) {
        var l = o[r], c = o[r + 1];
        if (o[r + 2], l <= a && a <= c) return r;
      }
      return -1;
    }, e._lctf.readCoverage = function(o, a) {
      var r = e._bin, l = {};
      l.fmt = r.readUshort(o, a), a += 2;
      var c = r.readUshort(o, a);
      return a += 2, l.fmt == 1 && (l.tab = r.readUshorts(o, a, c)), l.fmt == 2 && (l.tab = r.readUshorts(o, a, 3 * c)), l;
    }, e._lctf.coverageIndex = function(o, a) {
      var r = o.tab;
      if (o.fmt == 1) return r.indexOf(a);
      if (o.fmt == 2) {
        var l = e._lctf.getInterval(r, a);
        if (l != -1) return r[l + 2] + (a - r[l]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(o, a) {
      var r = e._bin, l = a, c = [], u = r.readUshort(o, a);
      a += 2;
      for (var d = 0; d < u; d++) {
        var h = r.readASCII(o, a, 4);
        a += 4;
        var p = r.readUshort(o, a);
        a += 2;
        var f = e._lctf.readFeatureTable(o, l + p);
        f.tag = h.trim(), c.push(f);
      }
      return c;
    }, e._lctf.readFeatureTable = function(o, a) {
      var r = e._bin, l = a, c = {}, u = r.readUshort(o, a);
      a += 2, u > 0 && (c.featureParams = l + u);
      var d = r.readUshort(o, a);
      a += 2, c.tab = [];
      for (var h = 0; h < d; h++) c.tab.push(r.readUshort(o, a + 2 * h));
      return c;
    }, e._lctf.readScriptList = function(o, a) {
      var r = e._bin, l = a, c = {}, u = r.readUshort(o, a);
      a += 2;
      for (var d = 0; d < u; d++) {
        var h = r.readASCII(o, a, 4);
        a += 4;
        var p = r.readUshort(o, a);
        a += 2, c[h.trim()] = e._lctf.readScriptTable(o, l + p);
      }
      return c;
    }, e._lctf.readScriptTable = function(o, a) {
      var r = e._bin, l = a, c = {}, u = r.readUshort(o, a);
      a += 2, u > 0 && (c.default = e._lctf.readLangSysTable(o, l + u));
      var d = r.readUshort(o, a);
      a += 2;
      for (var h = 0; h < d; h++) {
        var p = r.readASCII(o, a, 4);
        a += 4;
        var f = r.readUshort(o, a);
        a += 2, c[p.trim()] = e._lctf.readLangSysTable(o, l + f);
      }
      return c;
    }, e._lctf.readLangSysTable = function(o, a) {
      var r = e._bin, l = {};
      r.readUshort(o, a), a += 2, l.reqFeature = r.readUshort(o, a), a += 2;
      var c = r.readUshort(o, a);
      return a += 2, l.features = r.readUshorts(o, a, c), l;
    }, e.CFF = {}, e.CFF.parse = function(o, a, r) {
      var l = e._bin;
      (o = new Uint8Array(o.buffer, a, r))[a = 0], o[++a], o[++a], o[++a], a++;
      var c = [];
      a = e.CFF.readIndex(o, a, c);
      for (var u = [], d = 0; d < c.length - 1; d++) u.push(l.readASCII(o, a + c[d], c[d + 1] - c[d]));
      a += c[c.length - 1];
      var h = [];
      a = e.CFF.readIndex(o, a, h);
      var p = [];
      for (d = 0; d < h.length - 1; d++) p.push(e.CFF.readDict(o, a + h[d], a + h[d + 1]));
      a += h[h.length - 1];
      var f = p[0], m = [];
      a = e.CFF.readIndex(o, a, m);
      var y = [];
      for (d = 0; d < m.length - 1; d++) y.push(l.readASCII(o, a + m[d], m[d + 1] - m[d]));
      if (a += m[m.length - 1], e.CFF.readSubrs(o, a, f), f.CharStrings) {
        a = f.CharStrings, m = [], a = e.CFF.readIndex(o, a, m);
        var g = [];
        for (d = 0; d < m.length - 1; d++) g.push(l.readBytes(o, a + m[d], m[d + 1] - m[d]));
        f.CharStrings = g;
      }
      if (f.ROS) {
        a = f.FDArray;
        var x = [];
        for (a = e.CFF.readIndex(o, a, x), f.FDArray = [], d = 0; d < x.length - 1; d++) {
          var w = e.CFF.readDict(o, a + x[d], a + x[d + 1]);
          e.CFF._readFDict(o, w, y), f.FDArray.push(w);
        }
        a += x[x.length - 1], a = f.FDSelect, f.FDSelect = [];
        var M = o[a];
        if (a++, M != 3) throw M;
        var _ = l.readUshort(o, a);
        for (a += 2, d = 0; d < _ + 1; d++) f.FDSelect.push(l.readUshort(o, a), o[a + 2]), a += 3;
      }
      return f.Encoding && (f.Encoding = e.CFF.readEncoding(o, f.Encoding, f.CharStrings.length)), f.charset && (f.charset = e.CFF.readCharset(o, f.charset, f.CharStrings.length)), e.CFF._readFDict(o, f, y), f;
    }, e.CFF._readFDict = function(o, a, r) {
      var l;
      for (var c in a.Private && (l = a.Private[1], a.Private = e.CFF.readDict(o, l, l + a.Private[0]), a.Private.Subrs && e.CFF.readSubrs(o, l + a.Private.Subrs, a.Private)), a) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(c) != -1 && (a[c] = r[a[c] - 426 + 35]);
    }, e.CFF.readSubrs = function(o, a, r) {
      var l = e._bin, c = [];
      a = e.CFF.readIndex(o, a, c);
      var u, d = c.length;
      u = d < 1240 ? 107 : d < 33900 ? 1131 : 32768, r.Bias = u, r.Subrs = [];
      for (var h = 0; h < c.length - 1; h++) r.Subrs.push(l.readBytes(o, a + c[h], c[h + 1] - c[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(o, a) {
      for (var r = 0; r < o.charset.length; r++) if (o.charset[r] == a) return r;
      return -1;
    }, e.CFF.glyphBySE = function(o, a) {
      return a < 0 || a > 255 ? -1 : e.CFF.glyphByUnicode(o, e.CFF.tableSE[a]);
    }, e.CFF.readEncoding = function(o, a, r) {
      e._bin;
      var l = [".notdef"], c = o[a];
      if (a++, c != 0) throw "error: unknown encoding format: " + c;
      var u = o[a];
      a++;
      for (var d = 0; d < u; d++) l.push(o[a + d]);
      return l;
    }, e.CFF.readCharset = function(o, a, r) {
      var l = e._bin, c = [".notdef"], u = o[a];
      if (a++, u == 0) for (var d = 0; d < r; d++) {
        var h = l.readUshort(o, a);
        a += 2, c.push(h);
      }
      else {
        if (u != 1 && u != 2) throw "error: format: " + u;
        for (; c.length < r; ) {
          h = l.readUshort(o, a), a += 2;
          var p = 0;
          for (u == 1 ? (p = o[a], a++) : (p = l.readUshort(o, a), a += 2), d = 0; d <= p; d++) c.push(h), h++;
        }
      }
      return c;
    }, e.CFF.readIndex = function(o, a, r) {
      var l = e._bin, c = l.readUshort(o, a) + 1, u = o[a += 2];
      if (a++, u == 1) for (var d = 0; d < c; d++) r.push(o[a + d]);
      else if (u == 2) for (d = 0; d < c; d++) r.push(l.readUshort(o, a + 2 * d));
      else if (u == 3) for (d = 0; d < c; d++) r.push(16777215 & l.readUint(o, a + 3 * d - 1));
      else if (c != 1) throw "unsupported offset size: " + u + ", count: " + c;
      return (a += c * u) - 1;
    }, e.CFF.getCharString = function(o, a, r) {
      var l = e._bin, c = o[a], u = o[a + 1];
      o[a + 2], o[a + 3], o[a + 4];
      var d = 1, h = null, p = null;
      c <= 20 && (h = c, d = 1), c == 12 && (h = 100 * c + u, d = 2), 21 <= c && c <= 27 && (h = c, d = 1), c == 28 && (p = l.readShort(o, a + 1), d = 3), 29 <= c && c <= 31 && (h = c, d = 1), 32 <= c && c <= 246 && (p = c - 139, d = 1), 247 <= c && c <= 250 && (p = 256 * (c - 247) + u + 108, d = 2), 251 <= c && c <= 254 && (p = 256 * -(c - 251) - u - 108, d = 2), c == 255 && (p = l.readInt(o, a + 1) / 65535, d = 5), r.val = p ?? "o" + h, r.size = d;
    }, e.CFF.readCharString = function(o, a, r) {
      for (var l = a + r, c = e._bin, u = []; a < l; ) {
        var d = o[a], h = o[a + 1];
        o[a + 2], o[a + 3], o[a + 4];
        var p = 1, f = null, m = null;
        d <= 20 && (f = d, p = 1), d == 12 && (f = 100 * d + h, p = 2), d != 19 && d != 20 || (f = d, p = 2), 21 <= d && d <= 27 && (f = d, p = 1), d == 28 && (m = c.readShort(o, a + 1), p = 3), 29 <= d && d <= 31 && (f = d, p = 1), 32 <= d && d <= 246 && (m = d - 139, p = 1), 247 <= d && d <= 250 && (m = 256 * (d - 247) + h + 108, p = 2), 251 <= d && d <= 254 && (m = 256 * -(d - 251) - h - 108, p = 2), d == 255 && (m = c.readInt(o, a + 1) / 65535, p = 5), u.push(m ?? "o" + f), a += p;
      }
      return u;
    }, e.CFF.readDict = function(o, a, r) {
      for (var l = e._bin, c = {}, u = []; a < r; ) {
        var d = o[a], h = o[a + 1];
        o[a + 2], o[a + 3], o[a + 4];
        var p = 1, f = null, m = null;
        if (d == 28 && (m = l.readShort(o, a + 1), p = 3), d == 29 && (m = l.readInt(o, a + 1), p = 5), 32 <= d && d <= 246 && (m = d - 139, p = 1), 247 <= d && d <= 250 && (m = 256 * (d - 247) + h + 108, p = 2), 251 <= d && d <= 254 && (m = 256 * -(d - 251) - h - 108, p = 2), d == 255) throw m = l.readInt(o, a + 1) / 65535, p = 5, "unknown number";
        if (d == 30) {
          var y = [];
          for (p = 1; ; ) {
            var g = o[a + p];
            p++;
            var x = g >> 4, w = 15 & g;
            if (x != 15 && y.push(x), w != 15 && y.push(w), w == 15) break;
          }
          for (var M = "", _ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], C = 0; C < y.length; C++) M += _[y[C]];
          m = parseFloat(M);
        }
        d <= 21 && (f = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][d], p = 1, d == 12 && (f = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], p = 2)), f != null ? (c[f] = u.length == 1 ? u[0] : u, u = []) : u.push(m), a += p;
      }
      return c;
    }, e.cmap = {}, e.cmap.parse = function(o, a, r) {
      o = new Uint8Array(o.buffer, a, r), a = 0;
      var l = e._bin, c = {};
      l.readUshort(o, a), a += 2;
      var u = l.readUshort(o, a);
      a += 2;
      var d = [];
      c.tables = [];
      for (var h = 0; h < u; h++) {
        var p = l.readUshort(o, a);
        a += 2;
        var f = l.readUshort(o, a);
        a += 2;
        var m = l.readUint(o, a);
        a += 4;
        var y = "p" + p + "e" + f, g = d.indexOf(m);
        if (g == -1) {
          var x;
          g = c.tables.length, d.push(m);
          var w = l.readUshort(o, m);
          w == 0 ? x = e.cmap.parse0(o, m) : w == 4 ? x = e.cmap.parse4(o, m) : w == 6 ? x = e.cmap.parse6(o, m) : w == 12 ? x = e.cmap.parse12(o, m) : console.debug("unknown format: " + w, p, f, m), c.tables.push(x);
        }
        if (c[y] != null) throw "multiple tables for one platform+encoding";
        c[y] = g;
      }
      return c;
    }, e.cmap.parse0 = function(o, a) {
      var r = e._bin, l = {};
      l.format = r.readUshort(o, a), a += 2;
      var c = r.readUshort(o, a);
      a += 2, r.readUshort(o, a), a += 2, l.map = [];
      for (var u = 0; u < c - 6; u++) l.map.push(o[a + u]);
      return l;
    }, e.cmap.parse4 = function(o, a) {
      var r = e._bin, l = a, c = {};
      c.format = r.readUshort(o, a), a += 2;
      var u = r.readUshort(o, a);
      a += 2, r.readUshort(o, a), a += 2;
      var d = r.readUshort(o, a);
      a += 2;
      var h = d / 2;
      c.searchRange = r.readUshort(o, a), a += 2, c.entrySelector = r.readUshort(o, a), a += 2, c.rangeShift = r.readUshort(o, a), a += 2, c.endCount = r.readUshorts(o, a, h), a += 2 * h, a += 2, c.startCount = r.readUshorts(o, a, h), a += 2 * h, c.idDelta = [];
      for (var p = 0; p < h; p++) c.idDelta.push(r.readShort(o, a)), a += 2;
      for (c.idRangeOffset = r.readUshorts(o, a, h), a += 2 * h, c.glyphIdArray = []; a < l + u; ) c.glyphIdArray.push(r.readUshort(o, a)), a += 2;
      return c;
    }, e.cmap.parse6 = function(o, a) {
      var r = e._bin, l = {};
      l.format = r.readUshort(o, a), a += 2, r.readUshort(o, a), a += 2, r.readUshort(o, a), a += 2, l.firstCode = r.readUshort(o, a), a += 2;
      var c = r.readUshort(o, a);
      a += 2, l.glyphIdArray = [];
      for (var u = 0; u < c; u++) l.glyphIdArray.push(r.readUshort(o, a)), a += 2;
      return l;
    }, e.cmap.parse12 = function(o, a) {
      var r = e._bin, l = {};
      l.format = r.readUshort(o, a), a += 2, a += 2, r.readUint(o, a), a += 4, r.readUint(o, a), a += 4;
      var c = r.readUint(o, a);
      a += 4, l.groups = [];
      for (var u = 0; u < c; u++) {
        var d = a + 12 * u, h = r.readUint(o, d + 0), p = r.readUint(o, d + 4), f = r.readUint(o, d + 8);
        l.groups.push([h, p, f]);
      }
      return l;
    }, e.glyf = {}, e.glyf.parse = function(o, a, r, l) {
      for (var c = [], u = 0; u < l.maxp.numGlyphs; u++) c.push(null);
      return c;
    }, e.glyf._parseGlyf = function(o, a) {
      var r = e._bin, l = o._data, c = e._tabOffset(l, "glyf", o._offset) + o.loca[a];
      if (o.loca[a] == o.loca[a + 1]) return null;
      var u = {};
      if (u.noc = r.readShort(l, c), c += 2, u.xMin = r.readShort(l, c), c += 2, u.yMin = r.readShort(l, c), c += 2, u.xMax = r.readShort(l, c), c += 2, u.yMax = r.readShort(l, c), c += 2, u.xMin >= u.xMax || u.yMin >= u.yMax) return null;
      if (u.noc > 0) {
        u.endPts = [];
        for (var d = 0; d < u.noc; d++) u.endPts.push(r.readUshort(l, c)), c += 2;
        var h = r.readUshort(l, c);
        if (c += 2, l.length - c < h) return null;
        u.instructions = r.readBytes(l, c, h), c += h;
        var p = u.endPts[u.noc - 1] + 1;
        for (u.flags = [], d = 0; d < p; d++) {
          var f = l[c];
          if (c++, u.flags.push(f), (8 & f) != 0) {
            var m = l[c];
            c++;
            for (var y = 0; y < m; y++) u.flags.push(f), d++;
          }
        }
        for (u.xs = [], d = 0; d < p; d++) {
          var g = (2 & u.flags[d]) != 0, x = (16 & u.flags[d]) != 0;
          g ? (u.xs.push(x ? l[c] : -l[c]), c++) : x ? u.xs.push(0) : (u.xs.push(r.readShort(l, c)), c += 2);
        }
        for (u.ys = [], d = 0; d < p; d++)
          g = (4 & u.flags[d]) != 0, x = (32 & u.flags[d]) != 0, g ? (u.ys.push(x ? l[c] : -l[c]), c++) : x ? u.ys.push(0) : (u.ys.push(r.readShort(l, c)), c += 2);
        var w = 0, M = 0;
        for (d = 0; d < p; d++) w += u.xs[d], M += u.ys[d], u.xs[d] = w, u.ys[d] = M;
      } else {
        var _;
        u.parts = [];
        do {
          _ = r.readUshort(l, c), c += 2;
          var C = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (u.parts.push(C), C.glyphIndex = r.readUshort(l, c), c += 2, 1 & _) {
            var T = r.readShort(l, c);
            c += 2;
            var P = r.readShort(l, c);
            c += 2;
          } else
            T = r.readInt8(l, c), c++, P = r.readInt8(l, c), c++;
          2 & _ ? (C.m.tx = T, C.m.ty = P) : (C.p1 = T, C.p2 = P), 8 & _ ? (C.m.a = C.m.d = r.readF2dot14(l, c), c += 2) : 64 & _ ? (C.m.a = r.readF2dot14(l, c), c += 2, C.m.d = r.readF2dot14(l, c), c += 2) : 128 & _ && (C.m.a = r.readF2dot14(l, c), c += 2, C.m.b = r.readF2dot14(l, c), c += 2, C.m.c = r.readF2dot14(l, c), c += 2, C.m.d = r.readF2dot14(l, c), c += 2);
        } while (32 & _);
        if (256 & _) {
          var E = r.readUshort(l, c);
          for (c += 2, u.instr = [], d = 0; d < E; d++) u.instr.push(l[c]), c++;
        }
      }
      return u;
    }, e.GDEF = {}, e.GDEF.parse = function(o, a, r, l) {
      var c = a;
      a += 4;
      var u = e._bin.readUshort(o, a);
      return { glyphClassDef: u === 0 ? null : e._lctf.readClassDef(o, c + u) };
    }, e.GPOS = {}, e.GPOS.parse = function(o, a, r, l) {
      return e._lctf.parse(o, a, r, l, e.GPOS.subt);
    }, e.GPOS.subt = function(o, a, r, l) {
      var c = e._bin, u = r, d = {};
      if (d.fmt = c.readUshort(o, r), r += 2, a == 1 || a == 2 || a == 3 || a == 7 || a == 8 && d.fmt <= 2) {
        var h = c.readUshort(o, r);
        r += 2, d.coverage = e._lctf.readCoverage(o, h + u);
      }
      if (a == 1 && d.fmt == 1) {
        var p = c.readUshort(o, r);
        r += 2, p != 0 && (d.pos = e.GPOS.readValueRecord(o, r, p));
      } else if (a == 2 && d.fmt >= 1 && d.fmt <= 2) {
        p = c.readUshort(o, r), r += 2;
        var f = c.readUshort(o, r);
        r += 2;
        var m = e._lctf.numOfOnes(p), y = e._lctf.numOfOnes(f);
        if (d.fmt == 1) {
          d.pairsets = [];
          var g = c.readUshort(o, r);
          r += 2;
          for (var x = 0; x < g; x++) {
            var w = u + c.readUshort(o, r);
            r += 2;
            var M = c.readUshort(o, w);
            w += 2;
            for (var _ = [], C = 0; C < M; C++) {
              var T = c.readUshort(o, w);
              w += 2, p != 0 && (R = e.GPOS.readValueRecord(o, w, p), w += 2 * m), f != 0 && (k = e.GPOS.readValueRecord(o, w, f), w += 2 * y), _.push({ gid2: T, val1: R, val2: k });
            }
            d.pairsets.push(_);
          }
        }
        if (d.fmt == 2) {
          var P = c.readUshort(o, r);
          r += 2;
          var E = c.readUshort(o, r);
          r += 2;
          var b = c.readUshort(o, r);
          r += 2;
          var S = c.readUshort(o, r);
          for (r += 2, d.classDef1 = e._lctf.readClassDef(o, u + P), d.classDef2 = e._lctf.readClassDef(o, u + E), d.matrix = [], x = 0; x < b; x++) {
            var A = [];
            for (C = 0; C < S; C++) {
              var R = null, k = null;
              p != 0 && (R = e.GPOS.readValueRecord(o, r, p), r += 2 * m), f != 0 && (k = e.GPOS.readValueRecord(o, r, f), r += 2 * y), A.push({ val1: R, val2: k });
            }
            d.matrix.push(A);
          }
        }
      } else if (a == 4 && d.fmt == 1) d.markCoverage = e._lctf.readCoverage(o, c.readUshort(o, r) + u), d.baseCoverage = e._lctf.readCoverage(o, c.readUshort(o, r + 2) + u), d.markClassCount = c.readUshort(o, r + 4), d.markArray = e.GPOS.readMarkArray(o, c.readUshort(o, r + 6) + u), d.baseArray = e.GPOS.readBaseArray(o, c.readUshort(o, r + 8) + u, d.markClassCount);
      else if (a == 6 && d.fmt == 1) d.mark1Coverage = e._lctf.readCoverage(o, c.readUshort(o, r) + u), d.mark2Coverage = e._lctf.readCoverage(o, c.readUshort(o, r + 2) + u), d.markClassCount = c.readUshort(o, r + 4), d.mark1Array = e.GPOS.readMarkArray(o, c.readUshort(o, r + 6) + u), d.mark2Array = e.GPOS.readBaseArray(o, c.readUshort(o, r + 8) + u, d.markClassCount);
      else {
        if (a == 9 && d.fmt == 1) {
          var U = c.readUshort(o, r);
          r += 2;
          var I = c.readUint(o, r);
          if (r += 4, l.ltype == 9) l.ltype = U;
          else if (l.ltype != U) throw "invalid extension substitution";
          return e.GPOS.subt(o, l.ltype, u + I);
        }
        console.debug("unsupported GPOS table LookupType", a, "format", d.fmt);
      }
      return d;
    }, e.GPOS.readValueRecord = function(o, a, r) {
      var l = e._bin, c = [];
      return c.push(1 & r ? l.readShort(o, a) : 0), a += 1 & r ? 2 : 0, c.push(2 & r ? l.readShort(o, a) : 0), a += 2 & r ? 2 : 0, c.push(4 & r ? l.readShort(o, a) : 0), a += 4 & r ? 2 : 0, c.push(8 & r ? l.readShort(o, a) : 0), a += 8 & r ? 2 : 0, c;
    }, e.GPOS.readBaseArray = function(o, a, r) {
      var l = e._bin, c = [], u = a, d = l.readUshort(o, a);
      a += 2;
      for (var h = 0; h < d; h++) {
        for (var p = [], f = 0; f < r; f++) p.push(e.GPOS.readAnchorRecord(o, u + l.readUshort(o, a))), a += 2;
        c.push(p);
      }
      return c;
    }, e.GPOS.readMarkArray = function(o, a) {
      var r = e._bin, l = [], c = a, u = r.readUshort(o, a);
      a += 2;
      for (var d = 0; d < u; d++) {
        var h = e.GPOS.readAnchorRecord(o, r.readUshort(o, a + 2) + c);
        h.markClass = r.readUshort(o, a), l.push(h), a += 4;
      }
      return l;
    }, e.GPOS.readAnchorRecord = function(o, a) {
      var r = e._bin, l = {};
      return l.fmt = r.readUshort(o, a), l.x = r.readShort(o, a + 2), l.y = r.readShort(o, a + 4), l;
    }, e.GSUB = {}, e.GSUB.parse = function(o, a, r, l) {
      return e._lctf.parse(o, a, r, l, e.GSUB.subt);
    }, e.GSUB.subt = function(o, a, r, l) {
      var c = e._bin, u = r, d = {};
      if (d.fmt = c.readUshort(o, r), r += 2, a != 1 && a != 2 && a != 4 && a != 5 && a != 6) return null;
      if (a == 1 || a == 2 || a == 4 || a == 5 && d.fmt <= 2 || a == 6 && d.fmt <= 2) {
        var h = c.readUshort(o, r);
        r += 2, d.coverage = e._lctf.readCoverage(o, u + h);
      }
      if (a == 1 && d.fmt >= 1 && d.fmt <= 2) {
        if (d.fmt == 1) d.delta = c.readShort(o, r), r += 2;
        else if (d.fmt == 2) {
          var p = c.readUshort(o, r);
          r += 2, d.newg = c.readUshorts(o, r, p), r += 2 * d.newg.length;
        }
      } else if (a == 2 && d.fmt == 1) {
        p = c.readUshort(o, r), r += 2, d.seqs = [];
        for (var f = 0; f < p; f++) {
          var m = c.readUshort(o, r) + u;
          r += 2;
          var y = c.readUshort(o, m);
          d.seqs.push(c.readUshorts(o, m + 2, y));
        }
      } else if (a == 4)
        for (d.vals = [], p = c.readUshort(o, r), r += 2, f = 0; f < p; f++) {
          var g = c.readUshort(o, r);
          r += 2, d.vals.push(e.GSUB.readLigatureSet(o, u + g));
        }
      else if (a == 5 && d.fmt == 2) {
        if (d.fmt == 2) {
          var x = c.readUshort(o, r);
          r += 2, d.cDef = e._lctf.readClassDef(o, u + x), d.scset = [];
          var w = c.readUshort(o, r);
          for (r += 2, f = 0; f < w; f++) {
            var M = c.readUshort(o, r);
            r += 2, d.scset.push(M == 0 ? null : e.GSUB.readSubClassSet(o, u + M));
          }
        }
      } else if (a == 6 && d.fmt == 3) {
        if (d.fmt == 3) {
          for (f = 0; f < 3; f++) {
            p = c.readUshort(o, r), r += 2;
            for (var _ = [], C = 0; C < p; C++) _.push(e._lctf.readCoverage(o, u + c.readUshort(o, r + 2 * C)));
            r += 2 * p, f == 0 && (d.backCvg = _), f == 1 && (d.inptCvg = _), f == 2 && (d.ahedCvg = _);
          }
          p = c.readUshort(o, r), r += 2, d.lookupRec = e.GSUB.readSubstLookupRecords(o, r, p);
        }
      } else {
        if (a == 7 && d.fmt == 1) {
          var T = c.readUshort(o, r);
          r += 2;
          var P = c.readUint(o, r);
          if (r += 4, l.ltype == 9) l.ltype = T;
          else if (l.ltype != T) throw "invalid extension substitution";
          return e.GSUB.subt(o, l.ltype, u + P);
        }
        console.debug("unsupported GSUB table LookupType", a, "format", d.fmt);
      }
      return d;
    }, e.GSUB.readSubClassSet = function(o, a) {
      var r = e._bin.readUshort, l = a, c = [], u = r(o, a);
      a += 2;
      for (var d = 0; d < u; d++) {
        var h = r(o, a);
        a += 2, c.push(e.GSUB.readSubClassRule(o, l + h));
      }
      return c;
    }, e.GSUB.readSubClassRule = function(o, a) {
      var r = e._bin.readUshort, l = {}, c = r(o, a), u = r(o, a += 2);
      a += 2, l.input = [];
      for (var d = 0; d < c - 1; d++) l.input.push(r(o, a)), a += 2;
      return l.substLookupRecords = e.GSUB.readSubstLookupRecords(o, a, u), l;
    }, e.GSUB.readSubstLookupRecords = function(o, a, r) {
      for (var l = e._bin.readUshort, c = [], u = 0; u < r; u++) c.push(l(o, a), l(o, a + 2)), a += 4;
      return c;
    }, e.GSUB.readChainSubClassSet = function(o, a) {
      var r = e._bin, l = a, c = [], u = r.readUshort(o, a);
      a += 2;
      for (var d = 0; d < u; d++) {
        var h = r.readUshort(o, a);
        a += 2, c.push(e.GSUB.readChainSubClassRule(o, l + h));
      }
      return c;
    }, e.GSUB.readChainSubClassRule = function(o, a) {
      for (var r = e._bin, l = {}, c = ["backtrack", "input", "lookahead"], u = 0; u < c.length; u++) {
        var d = r.readUshort(o, a);
        a += 2, u == 1 && d--, l[c[u]] = r.readUshorts(o, a, d), a += 2 * l[c[u]].length;
      }
      return d = r.readUshort(o, a), a += 2, l.subst = r.readUshorts(o, a, 2 * d), a += 2 * l.subst.length, l;
    }, e.GSUB.readLigatureSet = function(o, a) {
      var r = e._bin, l = a, c = [], u = r.readUshort(o, a);
      a += 2;
      for (var d = 0; d < u; d++) {
        var h = r.readUshort(o, a);
        a += 2, c.push(e.GSUB.readLigature(o, l + h));
      }
      return c;
    }, e.GSUB.readLigature = function(o, a) {
      var r = e._bin, l = { chain: [] };
      l.nglyph = r.readUshort(o, a), a += 2;
      var c = r.readUshort(o, a);
      a += 2;
      for (var u = 0; u < c - 1; u++) l.chain.push(r.readUshort(o, a)), a += 2;
      return l;
    }, e.head = {}, e.head.parse = function(o, a, r) {
      var l = e._bin, c = {};
      return l.readFixed(o, a), a += 4, c.fontRevision = l.readFixed(o, a), a += 4, l.readUint(o, a), a += 4, l.readUint(o, a), a += 4, c.flags = l.readUshort(o, a), a += 2, c.unitsPerEm = l.readUshort(o, a), a += 2, c.created = l.readUint64(o, a), a += 8, c.modified = l.readUint64(o, a), a += 8, c.xMin = l.readShort(o, a), a += 2, c.yMin = l.readShort(o, a), a += 2, c.xMax = l.readShort(o, a), a += 2, c.yMax = l.readShort(o, a), a += 2, c.macStyle = l.readUshort(o, a), a += 2, c.lowestRecPPEM = l.readUshort(o, a), a += 2, c.fontDirectionHint = l.readShort(o, a), a += 2, c.indexToLocFormat = l.readShort(o, a), a += 2, c.glyphDataFormat = l.readShort(o, a), a += 2, c;
    }, e.hhea = {}, e.hhea.parse = function(o, a, r) {
      var l = e._bin, c = {};
      return l.readFixed(o, a), a += 4, c.ascender = l.readShort(o, a), a += 2, c.descender = l.readShort(o, a), a += 2, c.lineGap = l.readShort(o, a), a += 2, c.advanceWidthMax = l.readUshort(o, a), a += 2, c.minLeftSideBearing = l.readShort(o, a), a += 2, c.minRightSideBearing = l.readShort(o, a), a += 2, c.xMaxExtent = l.readShort(o, a), a += 2, c.caretSlopeRise = l.readShort(o, a), a += 2, c.caretSlopeRun = l.readShort(o, a), a += 2, c.caretOffset = l.readShort(o, a), a += 2, a += 8, c.metricDataFormat = l.readShort(o, a), a += 2, c.numberOfHMetrics = l.readUshort(o, a), a += 2, c;
    }, e.hmtx = {}, e.hmtx.parse = function(o, a, r, l) {
      for (var c = e._bin, u = { aWidth: [], lsBearing: [] }, d = 0, h = 0, p = 0; p < l.maxp.numGlyphs; p++) p < l.hhea.numberOfHMetrics && (d = c.readUshort(o, a), a += 2, h = c.readShort(o, a), a += 2), u.aWidth.push(d), u.lsBearing.push(h);
      return u;
    }, e.kern = {}, e.kern.parse = function(o, a, r, l) {
      var c = e._bin, u = c.readUshort(o, a);
      if (a += 2, u == 1) return e.kern.parseV1(o, a - 2, r, l);
      var d = c.readUshort(o, a);
      a += 2;
      for (var h = { glyph1: [], rval: [] }, p = 0; p < d; p++) {
        a += 2, r = c.readUshort(o, a), a += 2;
        var f = c.readUshort(o, a);
        a += 2;
        var m = f >>> 8;
        if ((m &= 15) != 0) throw "unknown kern table format: " + m;
        a = e.kern.readFormat0(o, a, h);
      }
      return h;
    }, e.kern.parseV1 = function(o, a, r, l) {
      var c = e._bin;
      c.readFixed(o, a), a += 4;
      var u = c.readUint(o, a);
      a += 4;
      for (var d = { glyph1: [], rval: [] }, h = 0; h < u; h++) {
        c.readUint(o, a), a += 4;
        var p = c.readUshort(o, a);
        a += 2, c.readUshort(o, a), a += 2;
        var f = p >>> 8;
        if ((f &= 15) != 0) throw "unknown kern table format: " + f;
        a = e.kern.readFormat0(o, a, d);
      }
      return d;
    }, e.kern.readFormat0 = function(o, a, r) {
      var l = e._bin, c = -1, u = l.readUshort(o, a);
      a += 2, l.readUshort(o, a), a += 2, l.readUshort(o, a), a += 2, l.readUshort(o, a), a += 2;
      for (var d = 0; d < u; d++) {
        var h = l.readUshort(o, a);
        a += 2;
        var p = l.readUshort(o, a);
        a += 2;
        var f = l.readShort(o, a);
        a += 2, h != c && (r.glyph1.push(h), r.rval.push({ glyph2: [], vals: [] }));
        var m = r.rval[r.rval.length - 1];
        m.glyph2.push(p), m.vals.push(f), c = h;
      }
      return a;
    }, e.loca = {}, e.loca.parse = function(o, a, r, l) {
      var c = e._bin, u = [], d = l.head.indexToLocFormat, h = l.maxp.numGlyphs + 1;
      if (d == 0) for (var p = 0; p < h; p++) u.push(c.readUshort(o, a + (p << 1)) << 1);
      if (d == 1) for (p = 0; p < h; p++) u.push(c.readUint(o, a + (p << 2)));
      return u;
    }, e.maxp = {}, e.maxp.parse = function(o, a, r) {
      var l = e._bin, c = {}, u = l.readUint(o, a);
      return a += 4, c.numGlyphs = l.readUshort(o, a), a += 2, u == 65536 && (c.maxPoints = l.readUshort(o, a), a += 2, c.maxContours = l.readUshort(o, a), a += 2, c.maxCompositePoints = l.readUshort(o, a), a += 2, c.maxCompositeContours = l.readUshort(o, a), a += 2, c.maxZones = l.readUshort(o, a), a += 2, c.maxTwilightPoints = l.readUshort(o, a), a += 2, c.maxStorage = l.readUshort(o, a), a += 2, c.maxFunctionDefs = l.readUshort(o, a), a += 2, c.maxInstructionDefs = l.readUshort(o, a), a += 2, c.maxStackElements = l.readUshort(o, a), a += 2, c.maxSizeOfInstructions = l.readUshort(o, a), a += 2, c.maxComponentElements = l.readUshort(o, a), a += 2, c.maxComponentDepth = l.readUshort(o, a), a += 2), c;
    }, e.name = {}, e.name.parse = function(o, a, r) {
      var l = e._bin, c = {};
      l.readUshort(o, a), a += 2;
      var u = l.readUshort(o, a);
      a += 2, l.readUshort(o, a);
      for (var d, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], p = a += 2, f = 0; f < u; f++) {
        var m = l.readUshort(o, a);
        a += 2;
        var y = l.readUshort(o, a);
        a += 2;
        var g = l.readUshort(o, a);
        a += 2;
        var x = l.readUshort(o, a);
        a += 2;
        var w = l.readUshort(o, a);
        a += 2;
        var M = l.readUshort(o, a);
        a += 2;
        var _, C = h[x], T = p + 12 * u + M;
        if (m == 0) _ = l.readUnicode(o, T, w / 2);
        else if (m == 3 && y == 0) _ = l.readUnicode(o, T, w / 2);
        else if (y == 0) _ = l.readASCII(o, T, w);
        else if (y == 1) _ = l.readUnicode(o, T, w / 2);
        else if (y == 3) _ = l.readUnicode(o, T, w / 2);
        else {
          if (m != 1) throw "unknown encoding " + y + ", platformID: " + m;
          _ = l.readASCII(o, T, w), console.debug("reading unknown MAC encoding " + y + " as ASCII");
        }
        var P = "p" + m + "," + g.toString(16);
        c[P] == null && (c[P] = {}), c[P][C !== void 0 ? C : x] = _, c[P]._lang = g;
      }
      for (var E in c) if (c[E].postScriptName != null && c[E]._lang == 1033) return c[E];
      for (var E in c) if (c[E].postScriptName != null && c[E]._lang == 0) return c[E];
      for (var E in c) if (c[E].postScriptName != null && c[E]._lang == 3084) return c[E];
      for (var E in c) if (c[E].postScriptName != null) return c[E];
      for (var E in c) {
        d = E;
        break;
      }
      return console.debug("returning name table with languageID " + c[d]._lang), c[d];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(o, a, r) {
      var l = e._bin.readUshort(o, a);
      a += 2;
      var c = {};
      if (l == 0) e["OS/2"].version0(o, a, c);
      else if (l == 1) e["OS/2"].version1(o, a, c);
      else if (l == 2 || l == 3 || l == 4) e["OS/2"].version2(o, a, c);
      else {
        if (l != 5) throw "unknown OS/2 table version: " + l;
        e["OS/2"].version5(o, a, c);
      }
      return c;
    }, e["OS/2"].version0 = function(o, a, r) {
      var l = e._bin;
      return r.xAvgCharWidth = l.readShort(o, a), a += 2, r.usWeightClass = l.readUshort(o, a), a += 2, r.usWidthClass = l.readUshort(o, a), a += 2, r.fsType = l.readUshort(o, a), a += 2, r.ySubscriptXSize = l.readShort(o, a), a += 2, r.ySubscriptYSize = l.readShort(o, a), a += 2, r.ySubscriptXOffset = l.readShort(o, a), a += 2, r.ySubscriptYOffset = l.readShort(o, a), a += 2, r.ySuperscriptXSize = l.readShort(o, a), a += 2, r.ySuperscriptYSize = l.readShort(o, a), a += 2, r.ySuperscriptXOffset = l.readShort(o, a), a += 2, r.ySuperscriptYOffset = l.readShort(o, a), a += 2, r.yStrikeoutSize = l.readShort(o, a), a += 2, r.yStrikeoutPosition = l.readShort(o, a), a += 2, r.sFamilyClass = l.readShort(o, a), a += 2, r.panose = l.readBytes(o, a, 10), a += 10, r.ulUnicodeRange1 = l.readUint(o, a), a += 4, r.ulUnicodeRange2 = l.readUint(o, a), a += 4, r.ulUnicodeRange3 = l.readUint(o, a), a += 4, r.ulUnicodeRange4 = l.readUint(o, a), a += 4, r.achVendID = [l.readInt8(o, a), l.readInt8(o, a + 1), l.readInt8(o, a + 2), l.readInt8(o, a + 3)], a += 4, r.fsSelection = l.readUshort(o, a), a += 2, r.usFirstCharIndex = l.readUshort(o, a), a += 2, r.usLastCharIndex = l.readUshort(o, a), a += 2, r.sTypoAscender = l.readShort(o, a), a += 2, r.sTypoDescender = l.readShort(o, a), a += 2, r.sTypoLineGap = l.readShort(o, a), a += 2, r.usWinAscent = l.readUshort(o, a), a += 2, r.usWinDescent = l.readUshort(o, a), a += 2;
    }, e["OS/2"].version1 = function(o, a, r) {
      var l = e._bin;
      return a = e["OS/2"].version0(o, a, r), r.ulCodePageRange1 = l.readUint(o, a), a += 4, r.ulCodePageRange2 = l.readUint(o, a), a += 4;
    }, e["OS/2"].version2 = function(o, a, r) {
      var l = e._bin;
      return a = e["OS/2"].version1(o, a, r), r.sxHeight = l.readShort(o, a), a += 2, r.sCapHeight = l.readShort(o, a), a += 2, r.usDefault = l.readUshort(o, a), a += 2, r.usBreak = l.readUshort(o, a), a += 2, r.usMaxContext = l.readUshort(o, a), a += 2;
    }, e["OS/2"].version5 = function(o, a, r) {
      var l = e._bin;
      return a = e["OS/2"].version2(o, a, r), r.usLowerOpticalPointSize = l.readUshort(o, a), a += 2, r.usUpperOpticalPointSize = l.readUshort(o, a), a += 2;
    }, e.post = {}, e.post.parse = function(o, a, r) {
      var l = e._bin, c = {};
      return c.version = l.readFixed(o, a), a += 4, c.italicAngle = l.readFixed(o, a), a += 4, c.underlinePosition = l.readShort(o, a), a += 2, c.underlineThickness = l.readShort(o, a), a += 2, c;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(o, a) {
      var r = o.cmap, l = -1;
      if (r.p0e4 != null ? l = r.p0e4 : r.p3e1 != null ? l = r.p3e1 : r.p1e0 != null ? l = r.p1e0 : r.p0e3 != null && (l = r.p0e3), l == -1) throw "no familiar platform and encoding!";
      var c = r.tables[l];
      if (c.format == 0) return a >= c.map.length ? 0 : c.map[a];
      if (c.format == 4) {
        for (var u = -1, d = 0; d < c.endCount.length; d++) if (a <= c.endCount[d]) {
          u = d;
          break;
        }
        return u == -1 || c.startCount[u] > a ? 0 : 65535 & (c.idRangeOffset[u] != 0 ? c.glyphIdArray[a - c.startCount[u] + (c.idRangeOffset[u] >> 1) - (c.idRangeOffset.length - u)] : a + c.idDelta[u]);
      }
      if (c.format == 12) {
        if (a > c.groups[c.groups.length - 1][1]) return 0;
        for (d = 0; d < c.groups.length; d++) {
          var h = c.groups[d];
          if (h[0] <= a && a <= h[1]) return h[2] + (a - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + c.format;
    }, e.U.glyphToPath = function(o, a) {
      var r = { cmds: [], crds: [] };
      if (o.SVG && o.SVG.entries[a]) {
        var l = o.SVG.entries[a];
        return l == null ? r : (typeof l == "string" && (l = e.SVG.toPath(l), o.SVG.entries[a] = l), l);
      }
      if (o.CFF) {
        var c = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: o.CFF.Private ? o.CFF.Private.defaultWidthX : 0, open: !1 }, u = o.CFF, d = o.CFF.Private;
        if (u.ROS) {
          for (var h = 0; u.FDSelect[h + 2] <= a; ) h += 2;
          d = u.FDArray[u.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(o.CFF.CharStrings[a], c, u, d, r);
      } else o.glyf && e.U._drawGlyf(a, o, r);
      return r;
    }, e.U._drawGlyf = function(o, a, r) {
      var l = a.glyf[o];
      l == null && (l = a.glyf[o] = e.glyf._parseGlyf(a, o)), l != null && (l.noc > -1 ? e.U._simpleGlyph(l, r) : e.U._compoGlyph(l, a, r));
    }, e.U._simpleGlyph = function(o, a) {
      for (var r = 0; r < o.noc; r++) {
        for (var l = r == 0 ? 0 : o.endPts[r - 1] + 1, c = o.endPts[r], u = l; u <= c; u++) {
          var d = u == l ? c : u - 1, h = u == c ? l : u + 1, p = 1 & o.flags[u], f = 1 & o.flags[d], m = 1 & o.flags[h], y = o.xs[u], g = o.ys[u];
          if (u == l) if (p) {
            if (!f) {
              e.U.P.moveTo(a, y, g);
              continue;
            }
            e.U.P.moveTo(a, o.xs[d], o.ys[d]);
          } else f ? e.U.P.moveTo(a, o.xs[d], o.ys[d]) : e.U.P.moveTo(a, (o.xs[d] + y) / 2, (o.ys[d] + g) / 2);
          p ? f && e.U.P.lineTo(a, y, g) : m ? e.U.P.qcurveTo(a, y, g, o.xs[h], o.ys[h]) : e.U.P.qcurveTo(a, y, g, (y + o.xs[h]) / 2, (g + o.ys[h]) / 2);
        }
        e.U.P.closePath(a);
      }
    }, e.U._compoGlyph = function(o, a, r) {
      for (var l = 0; l < o.parts.length; l++) {
        var c = { cmds: [], crds: [] }, u = o.parts[l];
        e.U._drawGlyf(u.glyphIndex, a, c);
        for (var d = u.m, h = 0; h < c.crds.length; h += 2) {
          var p = c.crds[h], f = c.crds[h + 1];
          r.crds.push(p * d.a + f * d.b + d.tx), r.crds.push(p * d.c + f * d.d + d.ty);
        }
        for (h = 0; h < c.cmds.length; h++) r.cmds.push(c.cmds[h]);
      }
    }, e.U._getGlyphClass = function(o, a) {
      var r = e._lctf.getInterval(a, o);
      return r == -1 ? 0 : a[r + 2];
    }, e.U._applySubs = function(o, a, r, l) {
      for (var c = o.length - a - 1, u = 0; u < r.tabs.length; u++) if (r.tabs[u] != null) {
        var d, h = r.tabs[u];
        if (!h.coverage || (d = e._lctf.coverageIndex(h.coverage, o[a])) != -1) {
          if (r.ltype == 1) o[a], h.fmt == 1 ? o[a] = o[a] + h.delta : o[a] = h.newg[d];
          else if (r.ltype == 4) for (var p = h.vals[d], f = 0; f < p.length; f++) {
            var m = p[f], y = m.chain.length;
            if (!(y > c)) {
              for (var g = !0, x = 0, w = 0; w < y; w++) {
                for (; o[a + x + (1 + w)] == -1; ) x++;
                m.chain[w] != o[a + x + (1 + w)] && (g = !1);
              }
              if (g) {
                for (o[a] = m.nglyph, w = 0; w < y + x; w++) o[a + w + 1] = -1;
                break;
              }
            }
          }
          else if (r.ltype == 5 && h.fmt == 2) for (var M = e._lctf.getInterval(h.cDef, o[a]), _ = h.cDef[M + 2], C = h.scset[_], T = 0; T < C.length; T++) {
            var P = C[T], E = P.input;
            if (!(E.length > c)) {
              for (g = !0, w = 0; w < E.length; w++) {
                var b = e._lctf.getInterval(h.cDef, o[a + 1 + w]);
                if (M == -1 && h.cDef[b + 2] != E[w]) {
                  g = !1;
                  break;
                }
              }
              if (g) {
                var S = P.substLookupRecords;
                for (f = 0; f < S.length; f += 2) S[f], S[f + 1];
              }
            }
          }
          else if (r.ltype == 6 && h.fmt == 3) {
            if (!e.U._glsCovered(o, h.backCvg, a - h.backCvg.length) || !e.U._glsCovered(o, h.inptCvg, a) || !e.U._glsCovered(o, h.ahedCvg, a + h.inptCvg.length)) continue;
            var A = h.lookupRec;
            for (T = 0; T < A.length; T += 2) {
              M = A[T];
              var R = l[A[T + 1]];
              e.U._applySubs(o, a + M, R, l);
            }
          }
        }
      }
    }, e.U._glsCovered = function(o, a, r) {
      for (var l = 0; l < a.length; l++)
        if (e._lctf.coverageIndex(a[l], o[r + l]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(o, a, r) {
      for (var l = { cmds: [], crds: [] }, c = 0, u = 0; u < a.length; u++) {
        var d = a[u];
        if (d != -1) {
          for (var h = u < a.length - 1 && a[u + 1] != -1 ? a[u + 1] : 0, p = e.U.glyphToPath(o, d), f = 0; f < p.crds.length; f += 2) l.crds.push(p.crds[f] + c), l.crds.push(p.crds[f + 1]);
          for (r && l.cmds.push(r), f = 0; f < p.cmds.length; f++) l.cmds.push(p.cmds[f]);
          r && l.cmds.push("X"), c += o.hmtx.aWidth[d], u < a.length - 1 && (c += e.U.getPairAdjustment(o, d, h));
        }
      }
      return l;
    }, e.U.P = {}, e.U.P.moveTo = function(o, a, r) {
      o.cmds.push("M"), o.crds.push(a, r);
    }, e.U.P.lineTo = function(o, a, r) {
      o.cmds.push("L"), o.crds.push(a, r);
    }, e.U.P.curveTo = function(o, a, r, l, c, u, d) {
      o.cmds.push("C"), o.crds.push(a, r, l, c, u, d);
    }, e.U.P.qcurveTo = function(o, a, r, l, c) {
      o.cmds.push("Q"), o.crds.push(a, r, l, c);
    }, e.U.P.closePath = function(o) {
      o.cmds.push("Z");
    }, e.U._drawCFF = function(o, a, r, l, c) {
      for (var u = a.stack, d = a.nStems, h = a.haveWidth, p = a.width, f = a.open, m = 0, y = a.x, g = a.y, x = 0, w = 0, M = 0, _ = 0, C = 0, T = 0, P = 0, E = 0, b = 0, S = 0, A = { val: 0, size: 0 }; m < o.length; ) {
        e.CFF.getCharString(o, m, A);
        var R = A.val;
        if (m += A.size, R == "o1" || R == "o18") u.length % 2 != 0 && !h && (p = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (R == "o3" || R == "o23")
          u.length % 2 != 0 && !h && (p = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (R == "o4") u.length > 1 && !h && (p = u.shift() + l.nominalWidthX, h = !0), f && e.U.P.closePath(c), g += u.pop(), e.U.P.moveTo(c, y, g), f = !0;
        else if (R == "o5") for (; u.length > 0; ) y += u.shift(), g += u.shift(), e.U.P.lineTo(c, y, g);
        else if (R == "o6" || R == "o7") for (var k = u.length, U = R == "o6", I = 0; I < k; I++) {
          var W = u.shift();
          U ? y += W : g += W, U = !U, e.U.P.lineTo(c, y, g);
        }
        else if (R == "o8" || R == "o24") {
          k = u.length;
          for (var fe = 0; fe + 6 <= k; ) x = y + u.shift(), w = g + u.shift(), M = x + u.shift(), _ = w + u.shift(), y = M + u.shift(), g = _ + u.shift(), e.U.P.curveTo(c, x, w, M, _, y, g), fe += 6;
          R == "o24" && (y += u.shift(), g += u.shift(), e.U.P.lineTo(c, y, g));
        } else {
          if (R == "o11") break;
          if (R == "o1234" || R == "o1235" || R == "o1236" || R == "o1237") R == "o1234" && (w = g, M = (x = y + u.shift()) + u.shift(), S = _ = w + u.shift(), T = _, E = g, y = (P = (C = (b = M + u.shift()) + u.shift()) + u.shift()) + u.shift(), e.U.P.curveTo(c, x, w, M, _, b, S), e.U.P.curveTo(c, C, T, P, E, y, g)), R == "o1235" && (x = y + u.shift(), w = g + u.shift(), M = x + u.shift(), _ = w + u.shift(), b = M + u.shift(), S = _ + u.shift(), C = b + u.shift(), T = S + u.shift(), P = C + u.shift(), E = T + u.shift(), y = P + u.shift(), g = E + u.shift(), u.shift(), e.U.P.curveTo(c, x, w, M, _, b, S), e.U.P.curveTo(c, C, T, P, E, y, g)), R == "o1236" && (x = y + u.shift(), w = g + u.shift(), M = x + u.shift(), S = _ = w + u.shift(), T = _, P = (C = (b = M + u.shift()) + u.shift()) + u.shift(), E = T + u.shift(), y = P + u.shift(), e.U.P.curveTo(c, x, w, M, _, b, S), e.U.P.curveTo(c, C, T, P, E, y, g)), R == "o1237" && (x = y + u.shift(), w = g + u.shift(), M = x + u.shift(), _ = w + u.shift(), b = M + u.shift(), S = _ + u.shift(), C = b + u.shift(), T = S + u.shift(), P = C + u.shift(), E = T + u.shift(), Math.abs(P - y) > Math.abs(E - g) ? y = P + u.shift() : g = E + u.shift(), e.U.P.curveTo(c, x, w, M, _, b, S), e.U.P.curveTo(c, C, T, P, E, y, g));
          else if (R == "o14") {
            if (u.length > 0 && !h && (p = u.shift() + r.nominalWidthX, h = !0), u.length == 4) {
              var q = u.shift(), G = u.shift(), Q = u.shift(), K = u.shift(), Y = e.CFF.glyphBySE(r, Q), ee = e.CFF.glyphBySE(r, K);
              e.U._drawCFF(r.CharStrings[Y], a, r, l, c), a.x = q, a.y = G, e.U._drawCFF(r.CharStrings[ee], a, r, l, c);
            }
            f && (e.U.P.closePath(c), f = !1);
          } else if (R == "o19" || R == "o20")
            u.length % 2 != 0 && !h && (p = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0, m += d + 7 >> 3;
          else if (R == "o21") u.length > 2 && !h && (p = u.shift() + l.nominalWidthX, h = !0), g += u.pop(), y += u.pop(), f && e.U.P.closePath(c), e.U.P.moveTo(c, y, g), f = !0;
          else if (R == "o22") u.length > 1 && !h && (p = u.shift() + l.nominalWidthX, h = !0), y += u.pop(), f && e.U.P.closePath(c), e.U.P.moveTo(c, y, g), f = !0;
          else if (R == "o25") {
            for (; u.length > 6; ) y += u.shift(), g += u.shift(), e.U.P.lineTo(c, y, g);
            x = y + u.shift(), w = g + u.shift(), M = x + u.shift(), _ = w + u.shift(), y = M + u.shift(), g = _ + u.shift(), e.U.P.curveTo(c, x, w, M, _, y, g);
          } else if (R == "o26") for (u.length % 2 && (y += u.shift()); u.length > 0; ) x = y, w = g + u.shift(), y = M = x + u.shift(), g = (_ = w + u.shift()) + u.shift(), e.U.P.curveTo(c, x, w, M, _, y, g);
          else if (R == "o27") for (u.length % 2 && (g += u.shift()); u.length > 0; ) w = g, M = (x = y + u.shift()) + u.shift(), _ = w + u.shift(), y = M + u.shift(), g = _, e.U.P.curveTo(c, x, w, M, _, y, g);
          else if (R == "o10" || R == "o29") {
            var ce = R == "o10" ? l : r;
            if (u.length == 0) console.debug("error: empty stack");
            else {
              var ae = u.pop(), de = ce.Subrs[ae + ce.Bias];
              a.x = y, a.y = g, a.nStems = d, a.haveWidth = h, a.width = p, a.open = f, e.U._drawCFF(de, a, r, l, c), y = a.x, g = a.y, d = a.nStems, h = a.haveWidth, p = a.width, f = a.open;
            }
          } else if (R == "o30" || R == "o31") {
            var ie = u.length, he = (fe = 0, R == "o31");
            for (fe += ie - (k = -3 & ie); fe < k; ) he ? (w = g, M = (x = y + u.shift()) + u.shift(), g = (_ = w + u.shift()) + u.shift(), k - fe == 5 ? (y = M + u.shift(), fe++) : y = M, he = !1) : (x = y, w = g + u.shift(), M = x + u.shift(), _ = w + u.shift(), y = M + u.shift(), k - fe == 5 ? (g = _ + u.shift(), fe++) : g = _, he = !0), e.U.P.curveTo(c, x, w, M, _, y, g), fe += 4;
          } else {
            if ((R + "").charAt(0) == "o") throw console.debug("Unknown operation: " + R, o), R;
            u.push(R);
          }
        }
      }
      a.x = y, a.y = g, a.nStems = d, a.haveWidth = h, a.width = p, a.open = f;
    };
    var n = e, i = { Typr: n };
    return s.Typr = n, s.default = i, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function YB() {
  return function(s) {
    var e = Uint8Array, n = Uint16Array, i = Uint32Array, o = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), a = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), r = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), l = function(R, k) {
      for (var U = new n(31), I = 0; I < 31; ++I) U[I] = k += 1 << R[I - 1];
      var W = new i(U[30]);
      for (I = 1; I < 30; ++I) for (var fe = U[I]; fe < U[I + 1]; ++fe) W[fe] = fe - U[I] << 5 | I;
      return [U, W];
    }, c = l(o, 2), u = c[0], d = c[1];
    u[28] = 258, d[258] = 28;
    for (var h = l(a, 0)[0], p = new n(32768), f = 0; f < 32768; ++f) {
      var m = (43690 & f) >>> 1 | (21845 & f) << 1;
      m = (61680 & (m = (52428 & m) >>> 2 | (13107 & m) << 2)) >>> 4 | (3855 & m) << 4, p[f] = ((65280 & m) >>> 8 | (255 & m) << 8) >>> 1;
    }
    var y = function(R, k, U) {
      for (var I = R.length, W = 0, fe = new n(k); W < I; ++W) ++fe[R[W] - 1];
      var q, G = new n(k);
      for (W = 0; W < k; ++W) G[W] = G[W - 1] + fe[W - 1] << 1;
      {
        q = new n(1 << k);
        var Q = 15 - k;
        for (W = 0; W < I; ++W) if (R[W]) for (var K = W << 4 | R[W], Y = k - R[W], ee = G[R[W] - 1]++ << Y, ce = ee | (1 << Y) - 1; ee <= ce; ++ee) q[p[ee] >>> Q] = K;
      }
      return q;
    }, g = new e(288);
    for (f = 0; f < 144; ++f) g[f] = 8;
    for (f = 144; f < 256; ++f) g[f] = 9;
    for (f = 256; f < 280; ++f) g[f] = 7;
    for (f = 280; f < 288; ++f) g[f] = 8;
    var x = new e(32);
    for (f = 0; f < 32; ++f) x[f] = 5;
    var w = y(g, 9), M = y(x, 5), _ = function(R) {
      for (var k = R[0], U = 1; U < R.length; ++U) R[U] > k && (k = R[U]);
      return k;
    }, C = function(R, k, U) {
      var I = k / 8 | 0;
      return (R[I] | R[I + 1] << 8) >> (7 & k) & U;
    }, T = function(R, k) {
      var U = k / 8 | 0;
      return (R[U] | R[U + 1] << 8 | R[U + 2] << 16) >> (7 & k);
    }, P = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], E = function(R, k, U) {
      var I = new Error(k || P[R]);
      if (I.code = R, Error.captureStackTrace && Error.captureStackTrace(I, E), !U) throw I;
      return I;
    }, b = function(R, k, U) {
      var I = R.length;
      if (!I || U && !U.l && I < 5) return k || new e(0);
      var W = !k || U, fe = !U || U.i;
      U || (U = {}), k || (k = new e(3 * I));
      var q, G = function(Ue) {
        var rt = k.length;
        if (Ue > rt) {
          var Qe = new e(Math.max(2 * rt, Ue));
          Qe.set(k), k = Qe;
        }
      }, Q = U.f || 0, K = U.p || 0, Y = U.b || 0, ee = U.l, ce = U.d, ae = U.m, de = U.n, ie = 8 * I;
      do {
        if (!ee) {
          U.f = Q = C(R, K, 1);
          var he = C(R, K + 1, 3);
          if (K += 3, !he) {
            var ne = R[(oe = ((q = K) / 8 | 0) + (7 & q && 1) + 4) - 4] | R[oe - 3] << 8, N = oe + ne;
            if (N > I) {
              fe && E(0);
              break;
            }
            W && G(Y + ne), k.set(R.subarray(oe, N), Y), U.b = Y += ne, U.p = K = 8 * N;
            continue;
          }
          if (he == 1) ee = w, ce = M, ae = 9, de = 5;
          else if (he == 2) {
            var te = C(R, K, 31) + 257, F = C(R, K + 10, 15) + 4, B = te + C(R, K + 5, 31) + 1;
            K += 14;
            for (var L = new e(B), D = new e(19), j = 0; j < F; ++j) D[r[j]] = C(R, K + 3 * j, 7);
            K += 3 * F;
            var Z = _(D), z = (1 << Z) - 1, $ = y(D, Z);
            for (j = 0; j < B; ) {
              var oe, O = $[C(R, K, z)];
              if (K += 15 & O, (oe = O >>> 4) < 16) L[j++] = oe;
              else {
                var V = 0, H = 0;
                for (oe == 16 ? (H = 3 + C(R, K, 3), K += 2, V = L[j - 1]) : oe == 17 ? (H = 3 + C(R, K, 7), K += 3) : oe == 18 && (H = 11 + C(R, K, 127), K += 7); H--; ) L[j++] = V;
              }
            }
            var X = L.subarray(0, te), ue = L.subarray(te);
            ae = _(X), de = _(ue), ee = y(X, ae), ce = y(ue, de);
          } else E(1);
          if (K > ie) {
            fe && E(0);
            break;
          }
        }
        W && G(Y + 131072);
        for (var me = (1 << ae) - 1, _e = (1 << de) - 1, we = K; ; we = K) {
          var Ae = (V = ee[T(R, K) & me]) >>> 4;
          if ((K += 15 & V) > ie) {
            fe && E(0);
            break;
          }
          if (V || E(2), Ae < 256) k[Y++] = Ae;
          else {
            if (Ae == 256) {
              we = K, ee = null;
              break;
            }
            var Ve = Ae - 254;
            if (Ae > 264) {
              var Fe = o[j = Ae - 257];
              Ve = C(R, K, (1 << Fe) - 1) + u[j], K += Fe;
            }
            var $e = ce[T(R, K) & _e], Ze = $e >>> 4;
            if ($e || E(3), K += 15 & $e, ue = h[Ze], Ze > 3 && (Fe = a[Ze], ue += T(R, K) & (1 << Fe) - 1, K += Fe), K > ie) {
              fe && E(0);
              break;
            }
            W && G(Y + 131072);
            for (var je = Y + Ve; Y < je; Y += 4) k[Y] = k[Y - ue], k[Y + 1] = k[Y + 1 - ue], k[Y + 2] = k[Y + 2 - ue], k[Y + 3] = k[Y + 3 - ue];
            Y = je;
          }
        }
        U.l = ee, U.p = we, U.b = Y, ee && (Q = 1, U.m = ae, U.d = ce, U.n = de);
      } while (!Q);
      return Y == k.length ? k : function(Ue, rt, Qe) {
        (Qe == null || Qe > Ue.length) && (Qe = Ue.length);
        var yt = new (Ue instanceof n ? n : Ue instanceof i ? i : e)(Qe - rt);
        return yt.set(Ue.subarray(rt, Qe)), yt;
      }(k, 0, Y);
    }, S = new e(0), A = typeof TextDecoder < "u" && new TextDecoder();
    try {
      A.decode(S, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(R) {
      var k = new DataView(R), U = 0;
      function I() {
        var te = k.getUint16(U);
        return U += 2, te;
      }
      function W() {
        var te = k.getUint32(U);
        return U += 4, te;
      }
      function fe(te) {
        ne.setUint16(N, te), N += 2;
      }
      function q(te) {
        ne.setUint32(N, te), N += 4;
      }
      for (var G = { signature: W(), flavor: W(), length: W(), numTables: I(), reserved: I(), totalSfntSize: W(), majorVersion: I(), minorVersion: I(), metaOffset: W(), metaLength: W(), metaOrigLength: W(), privOffset: W(), privLength: W() }, Q = 0; Math.pow(2, Q) <= G.numTables; ) Q++;
      Q--;
      for (var K = 16 * Math.pow(2, Q), Y = 16 * G.numTables - K, ee = 12, ce = [], ae = 0; ae < G.numTables; ae++) ce.push({ tag: W(), offset: W(), compLength: W(), origLength: W(), origChecksum: W() }), ee += 16;
      var de, ie = new Uint8Array(12 + 16 * ce.length + ce.reduce(function(te, F) {
        return te + F.origLength + 4;
      }, 0)), he = ie.buffer, ne = new DataView(he), N = 0;
      return q(G.flavor), fe(G.numTables), fe(K), fe(Q), fe(Y), ce.forEach(function(te) {
        q(te.tag), q(te.origChecksum), q(ee), q(te.origLength), te.outOffset = ee, (ee += te.origLength) % 4 != 0 && (ee += 4 - ee % 4);
      }), ce.forEach(function(te) {
        var F, B = R.slice(te.offset, te.offset + te.compLength);
        if (te.compLength != te.origLength) {
          var L = new Uint8Array(te.origLength);
          F = new Uint8Array(B, 2), b(F, L);
        } else L = new Uint8Array(B);
        ie.set(L, te.outOffset);
        var D = 0;
        (ee = te.outOffset + te.origLength) % 4 != 0 && (D = 4 - ee % 4), ie.set(new Uint8Array(D).buffer, te.outOffset + te.origLength), de = ee + D;
      }), he.slice(0, de);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function qB(s, e) {
  const n = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, o = 1, a = 2, r = 4, l = 8, c = 16, u = 32;
  let d;
  function h(P) {
    if (!d) {
      const E = {
        R: a,
        L: o,
        D: r,
        C: c,
        U: u,
        T: l
      };
      d = /* @__PURE__ */ new Map();
      for (let b in i) {
        let S = 0;
        i[b].split(",").forEach((A) => {
          let [R, k] = A.split("+");
          R = parseInt(R, 36), k = k ? parseInt(k, 36) : 0, d.set(S += R, E[b]);
          for (let U = k; U--; )
            d.set(++S, E[b]);
        });
      }
    }
    return d.get(P) || u;
  }
  const p = 1, f = 2, m = 3, y = 4, g = [null, "isol", "init", "fina", "medi"];
  function x(P) {
    const E = new Uint8Array(P.length);
    let b = u, S = p, A = -1;
    for (let R = 0; R < P.length; R++) {
      const k = P.codePointAt(R);
      let U = h(k) | 0, I = p;
      U & l || (b & (o | r | c) ? U & (a | r | c) ? (I = m, (S === p || S === m) && E[A]++) : U & (o | u) && (S === f || S === y) && E[A]-- : b & (a | u) && (S === f || S === y) && E[A]--, S = E[R] = I, b = U, A = R, k > 65535 && R++);
    }
    return E;
  }
  function w(P, E) {
    const b = [];
    for (let A = 0; A < E.length; A++) {
      const R = E.codePointAt(A);
      R > 65535 && A++, b.push(s.U.codeToGlyph(P, R));
    }
    const S = P.GSUB;
    if (S) {
      const { lookupList: A, featureList: R } = S;
      let k;
      const U = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, I = [];
      R.forEach((W) => {
        if (U.test(W.tag))
          for (let fe = 0; fe < W.tab.length; fe++) {
            if (I[W.tab[fe]]) continue;
            I[W.tab[fe]] = !0;
            const q = A[W.tab[fe]], G = /^(isol|init|fina|medi)$/.test(W.tag);
            G && !k && (k = x(E));
            for (let Q = 0; Q < b.length; Q++)
              (!k || !G || g[k[Q]] === W.tag) && s.U._applySubs(b, Q, q, A);
          }
      });
    }
    return b;
  }
  function M(P, E) {
    const b = new Int16Array(E.length * 3);
    let S = 0;
    for (; S < E.length; S++) {
      const U = E[S];
      if (U === -1) continue;
      b[S * 3 + 2] = P.hmtx.aWidth[U];
      const I = P.GPOS;
      if (I) {
        const W = I.lookupList;
        for (let fe = 0; fe < W.length; fe++) {
          const q = W[fe];
          for (let G = 0; G < q.tabs.length; G++) {
            const Q = q.tabs[G];
            if (q.ltype === 1) {
              if (s._lctf.coverageIndex(Q.coverage, U) !== -1 && Q.pos) {
                k(Q.pos, S);
                break;
              }
            } else if (q.ltype === 2) {
              let K = null, Y = A();
              if (Y !== -1) {
                const ee = s._lctf.coverageIndex(Q.coverage, E[Y]);
                if (ee !== -1) {
                  if (Q.fmt === 1) {
                    const ce = Q.pairsets[ee];
                    for (let ae = 0; ae < ce.length; ae++)
                      ce[ae].gid2 === U && (K = ce[ae]);
                  } else if (Q.fmt === 2) {
                    const ce = s.U._getGlyphClass(E[Y], Q.classDef1), ae = s.U._getGlyphClass(U, Q.classDef2);
                    K = Q.matrix[ce][ae];
                  }
                  if (K) {
                    K.val1 && k(K.val1, Y), K.val2 && k(K.val2, S);
                    break;
                  }
                }
              }
            } else if (q.ltype === 4) {
              const K = s._lctf.coverageIndex(Q.markCoverage, U);
              if (K !== -1) {
                const Y = A(R), ee = Y === -1 ? -1 : s._lctf.coverageIndex(Q.baseCoverage, E[Y]);
                if (ee !== -1) {
                  const ce = Q.markArray[K], ae = Q.baseArray[ee][ce.markClass];
                  b[S * 3] = ae.x - ce.x + b[Y * 3] - b[Y * 3 + 2], b[S * 3 + 1] = ae.y - ce.y + b[Y * 3 + 1];
                  break;
                }
              }
            } else if (q.ltype === 6) {
              const K = s._lctf.coverageIndex(Q.mark1Coverage, U);
              if (K !== -1) {
                const Y = A();
                if (Y !== -1) {
                  const ee = E[Y];
                  if (_(P, ee) === 3) {
                    const ce = s._lctf.coverageIndex(Q.mark2Coverage, ee);
                    if (ce !== -1) {
                      const ae = Q.mark1Array[K], de = Q.mark2Array[ce][ae.markClass];
                      b[S * 3] = de.x - ae.x + b[Y * 3] - b[Y * 3 + 2], b[S * 3 + 1] = de.y - ae.y + b[Y * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (P.kern && !P.cff) {
        const W = A();
        if (W !== -1) {
          const fe = P.kern.glyph1.indexOf(E[W]);
          if (fe !== -1) {
            const q = P.kern.rval[fe].glyph2.indexOf(U);
            q !== -1 && (b[W * 3 + 2] += P.kern.rval[fe].vals[q]);
          }
        }
      }
    }
    return b;
    function A(U) {
      for (let I = S - 1; I >= 0; I--)
        if (E[I] !== -1 && (!U || U(E[I])))
          return I;
      return -1;
    }
    function R(U) {
      return _(P, U) === 1;
    }
    function k(U, I) {
      for (let W = 0; W < 3; W++)
        b[I * 3 + W] += U[W] || 0;
    }
  }
  function _(P, E) {
    const b = P.GDEF && P.GDEF.glyphClassDef;
    return b ? s.U._getGlyphClass(E, b) : 0;
  }
  function C(...P) {
    for (let E = 0; E < P.length; E++)
      if (typeof P[E] == "number")
        return P[E];
  }
  function T(P) {
    const E = /* @__PURE__ */ Object.create(null), b = P["OS/2"], S = P.hhea, A = P.head.unitsPerEm, R = C(b && b.sTypoAscender, S && S.ascender, A), k = {
      unitsPerEm: A,
      ascender: R,
      descender: C(b && b.sTypoDescender, S && S.descender, 0),
      capHeight: C(b && b.sCapHeight, R),
      xHeight: C(b && b.sxHeight, R),
      lineGap: C(b && b.sTypoLineGap, S && S.lineGap),
      supportsCodePoint(U) {
        return s.U.codeToGlyph(P, U) > 0;
      },
      forEachGlyph(U, I, W, fe) {
        let q = 0;
        const G = 1 / k.unitsPerEm * I, Q = w(P, U);
        let K = 0;
        const Y = M(P, Q);
        return Q.forEach((ee, ce) => {
          if (ee !== -1) {
            let ae = E[ee];
            if (!ae) {
              const { cmds: de, crds: ie } = s.U.glyphToPath(P, ee);
              let he = "", ne = 0;
              for (let L = 0, D = de.length; L < D; L++) {
                const j = n[de[L]];
                he += de[L];
                for (let Z = 1; Z <= j; Z++)
                  he += (Z > 1 ? "," : "") + ie[ne++];
              }
              let N, te, F, B;
              if (ie.length) {
                N = te = 1 / 0, F = B = -1 / 0;
                for (let L = 0, D = ie.length; L < D; L += 2) {
                  let j = ie[L], Z = ie[L + 1];
                  j < N && (N = j), Z < te && (te = Z), j > F && (F = j), Z > B && (B = Z);
                }
              } else
                N = F = te = B = 0;
              ae = E[ee] = {
                index: ee,
                advanceWidth: P.hmtx.aWidth[ee],
                xMin: N,
                yMin: te,
                xMax: F,
                yMax: B,
                path: he
              };
            }
            fe.call(
              null,
              ae,
              q + Y[ce * 3] * G,
              Y[ce * 3 + 1] * G,
              K
            ), q += Y[ce * 3 + 2] * G, W && (q += W * I);
          }
          K += U.codePointAt(K) > 65535 ? 2 : 1;
        }), q;
      }
    };
    return k;
  }
  return function(E) {
    const b = new Uint8Array(E, 0, 4), S = s._bin.readASCII(b, 0, 4);
    if (S === "wOFF")
      E = e(E);
    else if (S === "wOF2")
      throw new Error("woff2 fonts not supported");
    return T(s.parse(E)[0]);
  };
}
const ZB = /* @__PURE__ */ Ea({
  name: "Typr Font Parser",
  dependencies: [XB, YB, qB],
  init(s, e, n) {
    const i = s(), o = e();
    return n(i, o);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function KB() {
  return function(s) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(M) {
      var _ = M >> 5;
      this.buckets.set(_, (this.buckets.get(_) || 0) | 1 << (31 & M));
    }, e.prototype.has = function(M) {
      var _ = this.buckets.get(M >> 5);
      return _ !== void 0 && (_ & 1 << (31 & M)) != 0;
    }, e.prototype.serialize = function() {
      var M = [];
      return this.buckets.forEach(function(_, C) {
        M.push((+C).toString(36) + ":" + _.toString(36));
      }), M.join(",");
    }, e.prototype.deserialize = function(M) {
      var _ = this;
      this.buckets.clear(), M.split(",").forEach(function(C) {
        var T = C.split(":");
        _.buckets.set(parseInt(T[0], 36), parseInt(T[1], 36));
      });
    };
    var n = Math.pow(2, 8), i = n - 1, o = ~i;
    function a(M) {
      var _ = function(T) {
        return T & o;
      }(M).toString(16), C = function(T) {
        return (T & o) + n - 1;
      }(M).toString(16);
      return "codepoint-index/plane" + (M >> 16) + "/" + _ + "-" + C + ".json";
    }
    function r(M, _) {
      var C = M & i, T = _.codePointAt(C / 6 | 0);
      return ((T = (T || 48) - 48) & 1 << C % 6) != 0;
    }
    function l(M, _) {
      var C;
      (C = M, C.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(T) {
        return T.split("-").map(function(P) {
          return parseInt(P.trim(), 16);
        });
      })).forEach(function(T) {
        var P = T[0], E = T[1];
        E === void 0 && (E = P), _(P, E);
      });
    }
    function c(M, _) {
      l(M, function(C, T) {
        for (var P = C; P <= T; P++) _(P);
      });
    }
    var u = {}, d = {}, h = /* @__PURE__ */ new WeakMap(), p = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function f(M) {
      var _ = h.get(M);
      return _ || (_ = new e(), c(M.ranges, function(C) {
        return _.add(C);
      }), h.set(M, _)), _;
    }
    var m, y = /* @__PURE__ */ new Map();
    function g(M, _, C) {
      return M[_] ? _ : M[C] ? C : function(T) {
        for (var P in T) return P;
      }(M);
    }
    function x(M, _) {
      var C = _;
      if (!M.includes(C)) {
        C = 1 / 0;
        for (var T = 0; T < M.length; T++) Math.abs(M[T] - _) < Math.abs(C - _) && (C = M[T]);
      }
      return C;
    }
    function w(M) {
      return m || (m = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(_) {
        m.add(_);
      })), m.has(M);
    }
    return s.CodePointSet = e, s.clearCache = function() {
      u = {}, d = {};
    }, s.getFontsForString = function(M, _) {
      _ === void 0 && (_ = {});
      var C, T = _.lang;
      T === void 0 && (T = new RegExp("\\p{Script=Hangul}", "u").test(C = M) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(C) ? "ja" : "en");
      var P = _.category;
      P === void 0 && (P = "sans-serif");
      var E = _.style;
      E === void 0 && (E = "normal");
      var b = _.weight;
      b === void 0 && (b = 400);
      var S = (_.dataUrl || p).replace(/\/$/g, ""), A = /* @__PURE__ */ new Map(), R = new Uint8Array(M.length), k = {}, U = {}, I = new Array(M.length), W = /* @__PURE__ */ new Map(), fe = !1;
      function q(K) {
        var Y = y.get(K);
        return Y || (Y = fetch(S + "/" + K).then(function(ee) {
          if (!ee.ok) throw new Error(ee.statusText);
          return ee.json().then(function(ce) {
            if (!Array.isArray(ce) || ce[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + ce[0]);
            return ce[1];
          });
        }).catch(function(ee) {
          if (S !== p) return fe || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + S + '", trying default CDN. ' + ee.message), fe = !0), S = p, y.delete(K), q(K);
          throw ee;
        }), y.set(K, Y)), Y;
      }
      for (var G = function(K) {
        var Y = M.codePointAt(K), ee = a(Y);
        I[K] = ee, u[ee] || W.has(ee) || W.set(ee, q(ee).then(function(ce) {
          u[ee] = ce;
        })), Y > 65535 && (K++, Q = K);
      }, Q = 0; Q < M.length; Q++) G(Q);
      return Promise.all(W.values()).then(function() {
        W.clear();
        for (var K = function(ee) {
          var ce = M.codePointAt(ee), ae = null, de = u[I[ee]], ie = void 0;
          for (var he in de) {
            var ne = U[he];
            if (ne === void 0 && (ne = U[he] = new RegExp(he).test(T || "en")), ne) {
              for (var N in ie = he, de[he]) if (r(ce, de[he][N])) {
                ae = N;
                break;
              }
              break;
            }
          }
          if (!ae) {
            e: for (var te in de) if (te !== ie) {
              for (var F in de[te]) if (r(ce, de[te][F])) {
                ae = F;
                break e;
              }
            }
          }
          ae || (console.debug("No font coverage for U+" + ce.toString(16)), ae = "latin"), I[ee] = ae, d[ae] || W.has(ae) || W.set(ae, q("font-meta/" + ae + ".json").then(function(B) {
            d[ae] = B;
          })), ce > 65535 && (ee++, Y = ee);
        }, Y = 0; Y < M.length; Y++) K(Y);
        return Promise.all(W.values());
      }).then(function() {
        for (var K, Y = null, ee = 0; ee < M.length; ee++) {
          var ce = M.codePointAt(ee);
          if (Y && (w(ce) || f(Y).has(ce))) R[ee] = R[ee - 1];
          else {
            Y = d[I[ee]];
            var ae = k[Y.id];
            if (!ae) {
              var de = Y.typeforms, ie = g(de, P, "sans-serif"), he = g(de[ie], E, "normal"), ne = x((K = de[ie]) === null || K === void 0 ? void 0 : K[he], b);
              ae = k[Y.id] = S + "/font-files/" + Y.id + "/" + ie + "." + he + "." + ne + ".woff";
            }
            var N = A.get(ae);
            N == null && (N = A.size, A.set(ae, N)), R[ee] = N;
          }
          ce > 65535 && (ee++, R[ee] = R[ee - 1]);
        }
        return { fontUrls: Array.from(A.keys()), chars: R };
      });
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({});
}
function JB(s, e) {
  const n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function o(r, l) {
    const c = (u) => {
      console.error(`Failure loading font ${r}`, u);
    };
    try {
      const u = new XMLHttpRequest();
      u.open("get", r, !0), u.responseType = "arraybuffer", u.onload = function() {
        if (u.status >= 400)
          c(new Error(u.statusText));
        else if (u.status > 0)
          try {
            const d = s(u.response);
            d.src = r, l(d);
          } catch (d) {
            c(d);
          }
      }, u.onerror = c, u.send();
    } catch (u) {
      c(u);
    }
  }
  function a(r, l) {
    let c = n[r];
    c ? l(c) : i[r] ? i[r].push(l) : (i[r] = [l], o(r, (u) => {
      u.src = r, n[r] = u, i[r].forEach((d) => d(u)), delete i[r];
    }));
  }
  return function(r, l, {
    lang: c,
    fonts: u = [],
    style: d = "normal",
    weight: h = "normal",
    unicodeFontsURL: p
  } = {}) {
    const f = new Uint8Array(r.length), m = [];
    r.length || w();
    const y = /* @__PURE__ */ new Map(), g = [];
    if (d !== "italic" && (d = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), u && !Array.isArray(u) && (u = [u]), u = u.slice().filter((_) => !_.lang || _.lang.test(c)).reverse(), u.length) {
      let P = 0;
      (function E(b = 0) {
        for (let S = b, A = r.length; S < A; S++) {
          const R = r.codePointAt(S);
          if (P === 1 && m[f[S - 1]].supportsCodePoint(R) || S > 0 && /\s/.test(r[S]))
            f[S] = f[S - 1], P === 2 && (g[g.length - 1][1] = S);
          else
            for (let k = f[S], U = u.length; k <= U; k++)
              if (k === U) {
                const I = P === 2 ? g[g.length - 1] : g[g.length] = [S, S];
                I[1] = S, P = 2;
              } else {
                f[S] = k;
                const { src: I, unicodeRange: W } = u[k];
                if (!W || M(R, W)) {
                  const fe = n[I];
                  if (!fe) {
                    a(I, () => {
                      E(S);
                    });
                    return;
                  }
                  if (fe.supportsCodePoint(R)) {
                    let q = y.get(fe);
                    typeof q != "number" && (q = m.length, m.push(fe), y.set(fe, q)), f[S] = q, P = 1;
                    break;
                  }
                }
              }
          R > 65535 && S + 1 < A && (f[S + 1] = f[S], S++, P === 2 && (g[g.length - 1][1] = S));
        }
        x();
      })();
    } else
      g.push([0, r.length - 1]), x();
    function x() {
      if (g.length) {
        const _ = g.map((C) => r.substring(C[0], C[1] + 1)).join(`
`);
        e.getFontsForString(_, {
          lang: c || void 0,
          style: d,
          weight: h,
          dataUrl: p
        }).then(({ fontUrls: C, chars: T }) => {
          const P = m.length;
          let E = 0;
          g.forEach((S) => {
            for (let A = 0, R = S[1] - S[0]; A <= R; A++)
              f[S[0] + A] = T[E++] + P;
            E++;
          });
          let b = 0;
          C.forEach((S, A) => {
            a(S, (R) => {
              m[A + P] = R, ++b === C.length && w();
            });
          });
        });
      } else
        w();
    }
    function w() {
      l({
        chars: f,
        fonts: m
      });
    }
    function M(_, C) {
      for (let T = 0; T < C.length; T++) {
        const [P, E = P] = C[T];
        if (P <= _ && _ <= E)
          return !0;
      }
      return !1;
    }
  };
}
const QB = /* @__PURE__ */ Ea({
  name: "FontResolver",
  dependencies: [
    JB,
    ZB,
    KB
  ],
  init(s, e, n) {
    return s(e, n());
  }
});
function eN(s, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, o = "[^\\S\\u00A0]", a = new RegExp(`${o}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function r({ text: m, lang: y, fonts: g, style: x, weight: w, preResolvedFonts: M, unicodeFontsURL: _ }, C) {
    const T = ({ chars: P, fonts: E }) => {
      let b, S;
      const A = [];
      for (let R = 0; R < P.length; R++)
        P[R] !== S ? (S = P[R], A.push(b = { start: R, end: R, fontObj: E[P[R]] })) : b.end = R;
      C(A);
    };
    M ? T(M) : s(
      m,
      T,
      { lang: y, fonts: g, style: x, weight: w, unicodeFontsURL: _ }
    );
  }
  function l({
    text: m = "",
    font: y,
    lang: g,
    sdfGlyphSize: x = 64,
    fontSize: w = 400,
    fontWeight: M = 1,
    fontStyle: _ = "normal",
    letterSpacing: C = 0,
    lineHeight: T = "normal",
    maxWidth: P = 1 / 0,
    direction: E,
    textAlign: b = "left",
    textIndent: S = 0,
    whiteSpace: A = "normal",
    overflowWrap: R = "normal",
    anchorX: k = 0,
    anchorY: U = 0,
    metricsOnly: I = !1,
    unicodeFontsURL: W,
    preResolvedFonts: fe = null,
    includeCaretPositions: q = !1,
    chunkedBoundsSize: G = 8192,
    colorRanges: Q = null
  }, K) {
    const Y = h(), ee = { fontLoad: 0, typesetting: 0 };
    m.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), m = m.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), w = +w, C = +C, P = +P, T = T || "normal", S = +S, r({
      text: m,
      lang: g,
      style: _,
      weight: M,
      fonts: typeof y == "string" ? [{ src: y }] : y,
      unicodeFontsURL: W,
      preResolvedFonts: fe
    }, (ce) => {
      ee.fontLoad = h() - Y;
      const ae = isFinite(P);
      let de = null, ie = null, he = null, ne = null, N = null, te = null, F = null, B = null, L = 0, D = 0, j = A !== "nowrap";
      const Z = /* @__PURE__ */ new Map(), z = h();
      let $ = S, oe = 0, O = new p();
      const V = [O];
      ce.forEach((_e) => {
        const { fontObj: we } = _e, { ascender: Ae, descender: Ve, unitsPerEm: Fe, lineGap: $e, capHeight: Ze, xHeight: je } = we;
        let Ue = Z.get(we);
        if (!Ue) {
          const Be = w / Fe, ke = T === "normal" ? (Ae - Ve + $e) * Be : T * w, Ge = (ke - (Ae - Ve) * Be) / 2, Ye = Math.min(ke, (Ae - Ve) * Be), We = (Ae + Ve) / 2 * Be + Ye / 2;
          Ue = {
            index: Z.size,
            src: we.src,
            fontObj: we,
            fontSizeMult: Be,
            unitsPerEm: Fe,
            ascender: Ae * Be,
            descender: Ve * Be,
            capHeight: Ze * Be,
            xHeight: je * Be,
            lineHeight: ke,
            baseline: -Ge - Ae * Be,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: We,
            caretBottom: We - Ye
          }, Z.set(we, Ue);
        }
        const { fontSizeMult: rt } = Ue, Qe = m.slice(_e.start, _e.end + 1);
        let yt, Ce;
        we.forEachGlyph(Qe, w, C, (Be, ke, Ge, Ye) => {
          ke += oe, Ye += _e.start, yt = ke, Ce = Be;
          const We = m.charAt(Ye), ht = Be.advanceWidth * rt, ut = O.count;
          let ft;
          if ("isEmpty" in Be || (Be.isWhitespace = !!We && new RegExp(o).test(We), Be.canBreakAfter = !!We && a.test(We), Be.isEmpty = Be.xMin === Be.xMax || Be.yMin === Be.yMax || i.test(We)), !Be.isWhitespace && !Be.isEmpty && D++, j && ae && !Be.isWhitespace && ke + ht + $ > P && ut) {
            if (O.glyphAt(ut - 1).glyphObj.canBreakAfter)
              ft = new p(), $ = -ke;
            else
              for (let Gt = ut; Gt--; )
                if (Gt === 0 && R === "break-word") {
                  ft = new p(), $ = -ke;
                  break;
                } else if (O.glyphAt(Gt).glyphObj.canBreakAfter) {
                  ft = O.splitAt(Gt + 1);
                  const en = ft.glyphAt(0).x;
                  $ -= en;
                  for (let hn = ft.count; hn--; )
                    ft.glyphAt(hn).x -= en;
                  break;
                }
            ft && (O.isSoftWrapped = !0, O = ft, V.push(O), L = P);
          }
          let vt = O.glyphAt(O.count);
          vt.glyphObj = Be, vt.x = ke + $, vt.y = Ge, vt.width = ht, vt.charIndex = Ye, vt.fontData = Ue, We === `
` && (O = new p(), V.push(O), $ = -(ke + ht + C * w) + S);
        }), oe = yt + Ce.advanceWidth * rt + C * w;
      });
      let H = 0;
      V.forEach((_e) => {
        let we = !0;
        for (let Ae = _e.count; Ae--; ) {
          const Ve = _e.glyphAt(Ae);
          we && !Ve.glyphObj.isWhitespace && (_e.width = Ve.x + Ve.width, _e.width > L && (L = _e.width), we = !1);
          let { lineHeight: Fe, capHeight: $e, xHeight: Ze, baseline: je } = Ve.fontData;
          Fe > _e.lineHeight && (_e.lineHeight = Fe);
          const Ue = je - _e.baseline;
          Ue < 0 && (_e.baseline += Ue, _e.cap += Ue, _e.ex += Ue), _e.cap = Math.max(_e.cap, _e.baseline + $e), _e.ex = Math.max(_e.ex, _e.baseline + Ze);
        }
        _e.baseline -= H, _e.cap -= H, _e.ex -= H, H += _e.lineHeight;
      });
      let X = 0, ue = 0;
      if (k && (typeof k == "number" ? X = -k : typeof k == "string" && (X = -L * (k === "left" ? 0 : k === "center" ? 0.5 : k === "right" ? 1 : u(k)))), U && (typeof U == "number" ? ue = -U : typeof U == "string" && (ue = U === "top" ? 0 : U === "top-baseline" ? -V[0].baseline : U === "top-cap" ? -V[0].cap : U === "top-ex" ? -V[0].ex : U === "middle" ? H / 2 : U === "bottom" ? H : U === "bottom-baseline" ? -V[V.length - 1].baseline : u(U) * H)), !I) {
        const _e = e.getEmbeddingLevels(m, E);
        de = new Uint16Array(D), ie = new Uint8Array(D), he = new Float32Array(D * 2), ne = {}, F = [1 / 0, 1 / 0, -1 / 0, -1 / 0], B = [], q && (te = new Float32Array(m.length * 4)), Q && (N = new Uint8Array(D * 3));
        let we = 0, Ae = -1, Ve = -1, Fe, $e;
        if (V.forEach((Ze, je) => {
          let { count: Ue, width: rt } = Ze;
          if (Ue > 0) {
            let Qe = 0;
            for (let Ye = Ue; Ye-- && Ze.glyphAt(Ye).glyphObj.isWhitespace; )
              Qe++;
            let yt = 0, Ce = 0;
            if (b === "center")
              yt = (L - rt) / 2;
            else if (b === "right")
              yt = L - rt;
            else if (b === "justify" && Ze.isSoftWrapped) {
              let Ye = 0;
              for (let We = Ue - Qe; We--; )
                Ze.glyphAt(We).glyphObj.isWhitespace && Ye++;
              Ce = (L - rt) / Ye;
            }
            if (Ce || yt) {
              let Ye = 0;
              for (let We = 0; We < Ue; We++) {
                let ht = Ze.glyphAt(We);
                const ut = ht.glyphObj;
                ht.x += yt + Ye, Ce !== 0 && ut.isWhitespace && We < Ue - Qe && (Ye += Ce, ht.width += Ce);
              }
            }
            const Be = e.getReorderSegments(
              m,
              _e,
              Ze.glyphAt(0).charIndex,
              Ze.glyphAt(Ze.count - 1).charIndex
            );
            for (let Ye = 0; Ye < Be.length; Ye++) {
              const [We, ht] = Be[Ye];
              let ut = 1 / 0, ft = -1 / 0;
              for (let vt = 0; vt < Ue; vt++)
                if (Ze.glyphAt(vt).charIndex >= We) {
                  let Gt = vt, en = vt;
                  for (; en < Ue; en++) {
                    let hn = Ze.glyphAt(en);
                    if (hn.charIndex > ht)
                      break;
                    en < Ue - Qe && (ut = Math.min(ut, hn.x), ft = Math.max(ft, hn.x + hn.width));
                  }
                  for (let hn = Gt; hn < en; hn++) {
                    const Yn = Ze.glyphAt(hn);
                    Yn.x = ft - (Yn.x + Yn.width - ut);
                  }
                  break;
                }
            }
            let ke;
            const Ge = (Ye) => ke = Ye;
            for (let Ye = 0; Ye < Ue; Ye++) {
              const We = Ze.glyphAt(Ye);
              ke = We.glyphObj;
              const ht = ke.index, ut = _e.levels[We.charIndex] & 1;
              if (ut) {
                const ft = e.getMirroredCharacter(m[We.charIndex]);
                ft && We.fontData.fontObj.forEachGlyph(ft, 0, 0, Ge);
              }
              if (q) {
                const { charIndex: ft, fontData: vt } = We, Gt = We.x + X, en = We.x + We.width + X;
                te[ft * 4] = ut ? en : Gt, te[ft * 4 + 1] = ut ? Gt : en, te[ft * 4 + 2] = Ze.baseline + vt.caretBottom + ue, te[ft * 4 + 3] = Ze.baseline + vt.caretTop + ue;
                const hn = ft - Ae;
                hn > 1 && d(te, Ae, hn), Ae = ft;
              }
              if (Q) {
                const { charIndex: ft } = We;
                for (; ft > Ve; )
                  Ve++, Q.hasOwnProperty(Ve) && ($e = Q[Ve]);
              }
              if (!ke.isWhitespace && !ke.isEmpty) {
                const ft = we++, { fontSizeMult: vt, src: Gt, index: en } = We.fontData, hn = ne[Gt] || (ne[Gt] = {});
                hn[ht] || (hn[ht] = {
                  path: ke.path,
                  pathBounds: [ke.xMin, ke.yMin, ke.xMax, ke.yMax]
                });
                const Yn = We.x + X, Pn = We.y + Ze.baseline + ue;
                he[ft * 2] = Yn, he[ft * 2 + 1] = Pn;
                const li = Yn + ke.xMin * vt, Ei = Pn + ke.yMin * vt, Ai = Yn + ke.xMax * vt, qn = Pn + ke.yMax * vt;
                li < F[0] && (F[0] = li), Ei < F[1] && (F[1] = Ei), Ai > F[2] && (F[2] = Ai), qn > F[3] && (F[3] = qn), ft % G === 0 && (Fe = { start: ft, end: ft, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, B.push(Fe)), Fe.end++;
                const kn = Fe.rect;
                if (li < kn[0] && (kn[0] = li), Ei < kn[1] && (kn[1] = Ei), Ai > kn[2] && (kn[2] = Ai), qn > kn[3] && (kn[3] = qn), de[ft] = ht, ie[ft] = en, Q) {
                  const yi = ft * 3;
                  N[yi] = $e >> 16 & 255, N[yi + 1] = $e >> 8 & 255, N[yi + 2] = $e & 255;
                }
              }
            }
          }
        }), te) {
          const Ze = m.length - Ae;
          Ze > 1 && d(te, Ae, Ze);
        }
      }
      const me = [];
      Z.forEach(({ index: _e, src: we, unitsPerEm: Ae, ascender: Ve, descender: Fe, lineHeight: $e, capHeight: Ze, xHeight: je }) => {
        me[_e] = { src: we, unitsPerEm: Ae, ascender: Ve, descender: Fe, lineHeight: $e, capHeight: Ze, xHeight: je };
      }), ee.typesetting = h() - z, K({
        glyphIds: de,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: ie,
        //index into fontData for each glyph
        glyphPositions: he,
        //x,y of each glyph's origin in layout
        glyphData: ne,
        //dict holding data about each glyph appearing in the text
        fontData: me,
        //data about each font used in the text
        caretPositions: te,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: N,
        //color for each glyph, if color ranges supplied
        chunkedBounds: B,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: w,
        //calculated em height
        topBaseline: ue + V[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          X,
          ue - H,
          X + L,
          ue
        ],
        visibleBounds: F,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: ee
      });
    });
  }
  function c(m, y) {
    l({ ...m, metricsOnly: !0 }, (g) => {
      const [x, w, M, _] = g.blockBounds;
      y({
        width: M - x,
        height: _ - w
      });
    });
  }
  function u(m) {
    let y = m.match(/^([\d.]+)%$/), g = y ? parseFloat(y[1]) : NaN;
    return isNaN(g) ? 0 : g / 100;
  }
  function d(m, y, g) {
    const x = m[y * 4], w = m[y * 4 + 1], M = m[y * 4 + 2], _ = m[y * 4 + 3], C = (w - x) / g;
    for (let T = 0; T < g; T++) {
      const P = (y + T) * 4;
      m[P] = x + C * T, m[P + 1] = x + C * (T + 1), m[P + 2] = M, m[P + 3] = _;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function p() {
    this.data = [];
  }
  const f = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return p.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / f.length);
    },
    glyphAt(m) {
      let y = p.flyweight;
      return y.data = this.data, y.index = m, y;
    },
    splitAt(m) {
      let y = new p();
      return y.data = this.data.splice(m * f.length), y;
    }
  }, p.flyweight = f.reduce((m, y, g, x) => (Object.defineProperty(m, y, {
    get() {
      return this.data[this.index * f.length + g];
    },
    set(w) {
      this.data[this.index * f.length + g] = w;
    }
  }), m), { data: null, index: 0 }), {
    typeset: l,
    measure: c
  };
}
const fo = () => (self.performance || Date).now(), bu = /* @__PURE__ */ t5();
let X2;
function tN(s, e, n, i, o, a, r, l, c, u, d = !0) {
  return d ? iN(s, e, n, i, o, a, r, l, c, u).then(
    null,
    (h) => (X2 || (console.warn("WebGL SDF generation failed, falling back to JS", h), X2 = !0), q2(s, e, n, i, o, a, r, l, c, u))
  ) : q2(s, e, n, i, o, a, r, l, c, u);
}
const _c = [], nN = 5;
let Kd = 0;
function i5() {
  const s = fo();
  for (; _c.length && fo() - s < nN; )
    _c.shift()();
  Kd = _c.length ? setTimeout(i5, 0) : 0;
}
const iN = (...s) => new Promise((e, n) => {
  _c.push(() => {
    const i = fo();
    try {
      bu.webgl.generateIntoCanvas(...s), e({ timing: fo() - i });
    } catch (o) {
      n(o);
    }
  }), Kd || (Kd = setTimeout(i5, 0));
}), sN = 4, oN = 2e3, Y2 = {};
let aN = 0;
function q2(s, e, n, i, o, a, r, l, c, u) {
  const d = "TroikaTextSDFGenerator_JS_" + aN++ % sN;
  let h = Y2[d];
  return h || (h = Y2[d] = {
    workerModule: Ea({
      name: d,
      workerId: d,
      dependencies: [
        t5,
        fo
      ],
      init(p, f) {
        const m = p().javascript.generate;
        return function(...y) {
          const g = f();
          return {
            textureData: m(...y),
            timing: f() - g
          };
        };
      },
      getTransferables(p) {
        return [p.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(s, e, n, i, o, a).then(({ textureData: p, timing: f }) => {
    const m = fo(), y = new Uint8Array(p.length * 4);
    for (let g = 0; g < p.length; g++)
      y[g * 4 + u] = p[g];
    return bu.webglUtils.renderImageData(r, y, l, c, s, e, 1 << 3 - u), f += fo() - m, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      UB(d);
    }, oN)), { timing: f };
  });
}
function rN(s) {
  s._warm || (bu.webgl.isSupported(s), s._warm = !0);
}
const lN = bu.webglUtils.resizeWebGLCanvasWithoutClearing, cr = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, cN = /* @__PURE__ */ new Mt();
function Wo() {
  return (self.performance || Date).now();
}
const Z2 = /* @__PURE__ */ Object.create(null);
function uN(s, e) {
  s = hN({}, s);
  const n = Wo(), i = [];
  if (s.font && i.push({ label: "user", src: fN(s.font) }), s.font = i, s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || cr.sdfGlyphSize, s.unicodeFontsURL = s.unicodeFontsURL || cr.unicodeFontsURL, s.colorRanges != null) {
    let p = {};
    for (let f in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(f)) {
        let m = s.colorRanges[f];
        typeof m != "number" && (m = cN.set(m).getHex()), p[f] = m;
      }
    s.colorRanges = p;
  }
  Object.freeze(s);
  const { textureWidth: o, sdfExponent: a } = cr, { sdfGlyphSize: r } = s, l = o / r * 4;
  let c = Z2[r];
  if (!c) {
    const p = document.createElement("canvas");
    p.width = o, p.height = r * 256 / l, c = Z2[r] = {
      glyphCount: 0,
      sdfGlyphSize: r,
      sdfCanvas: p,
      sdfTexture: new An(
        p,
        void 0,
        void 0,
        void 0,
        Dt,
        Dt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, dN(c);
  }
  const { sdfTexture: u, sdfCanvas: d } = c;
  a5(s).then((p) => {
    const { glyphIds: f, glyphFontIndices: m, fontData: y, glyphPositions: g, fontSize: x, timings: w } = p, M = [], _ = new Float32Array(f.length * 4);
    let C = 0, T = 0;
    const P = Wo(), E = y.map((k) => {
      let U = c.glyphsByFont.get(k.src);
      return U || c.glyphsByFont.set(k.src, U = /* @__PURE__ */ new Map()), U;
    });
    f.forEach((k, U) => {
      const I = m[U], { src: W, unitsPerEm: fe } = y[I];
      let q = E[I].get(k);
      if (!q) {
        const { path: ee, pathBounds: ce } = p.glyphData[W][k], ae = Math.max(ce[2] - ce[0], ce[3] - ce[1]) / r * (cr.sdfMargin * r + 0.5), de = c.glyphCount++, ie = [
          ce[0] - ae,
          ce[1] - ae,
          ce[2] + ae,
          ce[3] + ae
        ];
        E[I].set(k, q = { path: ee, atlasIndex: de, sdfViewBox: ie }), M.push(q);
      }
      const { sdfViewBox: G } = q, Q = g[T++], K = g[T++], Y = x / fe;
      _[C++] = Q + G[0] * Y, _[C++] = K + G[1] * Y, _[C++] = Q + G[2] * Y, _[C++] = K + G[3] * Y, f[U] = q.atlasIndex;
    }), w.quads = (w.quads || 0) + (Wo() - P);
    const b = Wo();
    w.sdf = {};
    const S = d.height, A = Math.ceil(c.glyphCount / l), R = Math.pow(2, Math.ceil(Math.log2(A * r)));
    R > S && (console.info(`Increasing SDF texture size ${S}->${R}`), lN(d, o, R), u.dispose()), Promise.all(M.map(
      (k) => s5(k, c, s.gpuAccelerateSDF).then(({ timing: U }) => {
        w.sdf[k.atlasIndex] = U;
      })
    )).then(() => {
      M.length && !c.contextLost && (o5(c), u.needsUpdate = !0), w.sdfTotal = Wo() - b, w.total = Wo() - n, e(Object.freeze({
        parameters: s,
        sdfTexture: u,
        sdfGlyphSize: r,
        sdfExponent: a,
        glyphBounds: _,
        glyphAtlasIndices: f,
        glyphColors: p.glyphColors,
        caretPositions: p.caretPositions,
        chunkedBounds: p.chunkedBounds,
        ascender: p.ascender,
        descender: p.descender,
        lineHeight: p.lineHeight,
        capHeight: p.capHeight,
        xHeight: p.xHeight,
        topBaseline: p.topBaseline,
        blockBounds: p.blockBounds,
        visibleBounds: p.visibleBounds,
        timings: p.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || rN(d);
  });
}
function s5({ path: s, atlasIndex: e, sdfViewBox: n }, { sdfGlyphSize: i, sdfCanvas: o, contextLost: a }, r) {
  if (a)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: l, sdfExponent: c } = cr, u = Math.max(n[2] - n[0], n[3] - n[1]), d = Math.floor(e / 4), h = d % (l / i) * i, p = Math.floor(d / (l / i)) * i, f = e % 4;
  return tN(i, i, s, n, u, c, o, h, p, f, r);
}
function dN(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (n) => {
    console.log("Context Lost", n), n.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (n) => {
    console.log("Context Restored", n), s.contextLost = !1;
    const i = [];
    s.glyphsByFont.forEach((o) => {
      o.forEach((a) => {
        i.push(s5(a, s, !0));
      });
    }), Promise.all(i).then(() => {
      o5(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function hN(s, e) {
  for (let n in e)
    e.hasOwnProperty(n) && (s[n] = e[n]);
  return s;
}
let ql;
function fN(s) {
  return ql || (ql = typeof document > "u" ? {} : document.createElement("a")), ql.href = s, ql.href;
}
function o5(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: n } = s, { width: i, height: o } = e, a = s.sdfCanvas.getContext("webgl");
    let r = n.image.data;
    (!r || r.length !== i * o * 4) && (r = new Uint8Array(i * o * 4), n.image = { width: i, height: o, data: r }, n.flipY = !1, n.isDataTexture = !0), a.readPixels(0, 0, i, o, a.RGBA, a.UNSIGNED_BYTE, r);
  }
}
const pN = /* @__PURE__ */ Ea({
  name: "Typesetter",
  dependencies: [
    eN,
    QB,
    BB
  ],
  init(s, e, n) {
    return s(e, n());
  }
}), a5 = /* @__PURE__ */ Ea({
  name: "Typesetter",
  dependencies: [
    pN
  ],
  init(s) {
    return function(e) {
      return new Promise((n) => {
        s.typeset(e, n);
      });
    };
  },
  getTransferables(s) {
    const e = [];
    for (let n in s)
      s[n] && s[n].buffer && e.push(s[n].buffer);
    return e;
  }
});
a5.onMainThread;
const K2 = {};
function mN(s) {
  let e = K2[s];
  return e || (e = K2[s] = new nn(1, 1, s, s).translate(0.5, 0.5, 0)), e;
}
const vN = "aTroikaGlyphBounds", J2 = "aTroikaGlyphIndex", gN = "aTroikaGlyphColor";
class yN extends Vm {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new Zr(), this.boundingBox = new O0();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let n = mN(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = n.attributes[i].clone();
      }), this.setIndex(n.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, n, i, o, a) {
    this.updateAttributeData(vN, e, 4), this.updateAttributeData(J2, n, 1), this.updateAttributeData(gN, a, 3), this._blockBounds = i, this._chunkedBounds = o, this.instanceCount = n.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: n, boundingBox: i } = this;
      if (n) {
        const { PI: o, floor: a, min: r, max: l, sin: c, cos: u } = Math, d = o / 2, h = o * 2, p = Math.abs(n), f = e[0] / p, m = e[2] / p, y = a((f + d) / h) !== a((m + d) / h) ? -p : r(c(f) * p, c(m) * p), g = a((f - d) / h) !== a((m - d) / h) ? p : l(c(f) * p, c(m) * p), x = a((f + o) / h) !== a((m + o) / h) ? p * 2 : l(p - u(f) * p, p - u(m) * p);
        i.min.set(y, e[1], n < 0 ? -x : 0), i.max.set(g, e[3], n < 0 ? 0 : x);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let n = this.getAttribute(J2).count, i = this._chunkedBounds;
    if (i)
      for (let o = i.length; o--; ) {
        n = i[o].end;
        let a = i[o].rect;
        if (a[1] < e.w && a[3] > e.y && a[0] < e.z && a[2] > e.x)
          break;
      }
    this.instanceCount = n;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(e, n, i) {
    const o = this.getAttribute(e);
    n ? o && o.array.length === n.length ? (o.array.set(n), o.needsUpdate = !0) : (this.setAttribute(e, new eo(n, i)), delete this._maxInstanceCount, this.dispose()) : o && this.deleteAttribute(e);
  }
}
const xN = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, bN = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, _N = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, wN = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function MN(s) {
  const e = Zd(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new qe() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new Kt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new Kt(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new qe() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Mt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new At() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: xN,
    vertexTransform: bN,
    fragmentDefs: _N,
    fragmentColorTransform: wN,
    customRewriter({ vertexShader: n, fragmentShader: i }) {
      let o = /\buniform\s+vec3\s+diffuse\b/;
      return o.test(i) && (i = i.replace(o, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), o.test(n) || (n = n.replace(
        n5,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: n, fragmentShader: i };
    }
  });
  return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const Xh = /* @__PURE__ */ new _n({
  color: 16777215,
  side: mn,
  transparent: !0
}), Q2 = 8421504, e9 = /* @__PURE__ */ new jt(), Zl = /* @__PURE__ */ new pe(), F1 = /* @__PURE__ */ new pe(), Ka = [], SN = /* @__PURE__ */ new pe(), O1 = "+x+y";
function t9(s) {
  return Array.isArray(s) ? s[0] : s;
}
let r5 = () => {
  const s = new Ke(
    new nn(1, 1),
    Xh
  );
  return r5 = () => s, s;
}, l5 = () => {
  const s = new Ke(
    new nn(1, 1, 32, 1),
    Xh
  );
  return l5 = () => s, s;
};
const CN = { type: "syncstart" }, TN = { type: "synccomplete" }, c5 = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], EN = c5.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class Jd extends Ke {
  constructor() {
    const e = new yN();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Q2, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = O1, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(CN), uN({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (n) => {
      this._isSyncing = !1, this._textRenderInfo = n, this.geometry.updateGlyphs(
        n.glyphBounds,
        n.glyphAtlasIndices,
        n.blockBounds,
        n.chunkedBounds,
        n.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((o) => o && o());
      })), this.dispatchEvent(TN), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, n, i, o, a, r) {
    this.sync(), a.isTroikaTextMaterial && this._prepareForRender(a);
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(e) {
    return MN(e);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const n = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Xh.clone());
    if ((!e || !e.isDerivedFrom(n)) && (e = this._derivedMaterial = this.createDerivedMaterial(n), n.addEventListener("dispose", function i() {
      n.removeEventListener("dispose", i), e.dispose();
    })), this.hasOutline()) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function o() {
        e.removeEventListener("dispose", o), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return t9(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {
  }
  get customDistanceMaterial() {
    return t9(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {
  }
  _prepareForRender(e) {
    const n = e.isTextOutlineMaterial, i = e.uniforms, o = this.textRenderInfo;
    if (o) {
      const { sdfTexture: l, blockBounds: c } = o;
      i.uTroikaSDFTexture.value = l, i.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height), i.uTroikaSDFGlyphSize.value = o.sdfGlyphSize, i.uTroikaSDFExponent.value = o.sdfExponent, i.uTroikaTotalBounds.value.fromArray(c), i.uTroikaUseGlyphColors.value = !n && !!o.glyphColors;
      let u = 0, d = 0, h = 0, p, f, m, y = 0, g = 0;
      if (n) {
        let { outlineWidth: w, outlineOffsetX: M, outlineOffsetY: _, outlineBlur: C, outlineOpacity: T } = this;
        u = this._parsePercent(w) || 0, d = Math.max(0, this._parsePercent(C) || 0), p = T, y = this._parsePercent(M) || 0, g = this._parsePercent(_) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (m = this.strokeColor, i.uTroikaStrokeColor.value.set(m ?? Q2), f = this.strokeOpacity, f == null && (f = 1)), p = this.fillOpacity;
      i.uTroikaEdgeOffset.value = u, i.uTroikaPositionOffset.value.set(y, g), i.uTroikaBlurRadius.value = d, i.uTroikaStrokeWidth.value = h, i.uTroikaStrokeOpacity.value = f, i.uTroikaFillOpacity.value = p ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let x = this.clipRect;
      if (x && Array.isArray(x) && x.length === 4)
        i.uTroikaClipRect.value.fromArray(x);
      else {
        const w = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          c[0] - w,
          c[1] - w,
          c[2] + w,
          c[3] + w
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const a = n ? this.outlineColor || 0 : this.color;
    if (a == null)
      delete e.color;
    else {
      const l = e.hasOwnProperty("color") ? e.color : e.color = new Mt();
      (a !== l._input || typeof a == "object") && l.set(l._input = a);
    }
    let r = this.orientation || O1;
    if (r !== e._orientation) {
      let l = i.uTroikaOrient.value;
      r = r.replace(/[^-+xyz]/g, "");
      let c = r !== O1 && r.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (c) {
        let [, u, d, h, p] = c;
        Zl.set(0, 0, 0)[d] = u === "-" ? 1 : -1, F1.set(0, 0, 0)[p] = h === "-" ? -1 : 1, e9.lookAt(SN, Zl.cross(F1), F1), l.setFromMatrix4(e9);
      } else
        l.identity();
      e._orientation = r;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let n = e.match(/^(-?[\d.]+)%$/), i = n ? parseFloat(n[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, n = new qe()) {
    n.copy(e);
    const i = this.curveRadius;
    return i && (n.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), n;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, n = new qe()) {
    return Zl.copy(e), this.localPositionToTextCoords(this.worldToLocal(Zl), n);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, n) {
    const { textRenderInfo: i, curveRadius: o } = this;
    if (i) {
      const a = i.blockBounds, r = o ? l5() : r5(), l = r.geometry, { position: c, uv: u } = l.attributes;
      for (let d = 0; d < u.count; d++) {
        let h = a[0] + u.getX(d) * (a[2] - a[0]);
        const p = a[1] + u.getY(d) * (a[3] - a[1]);
        let f = 0;
        o && (f = o - Math.cos(h / o) * o, h = Math.sin(h / o) * o), c.setXYZ(d, h, p, f);
      }
      l.boundingSphere = this.geometry.boundingSphere, l.boundingBox = this.geometry.boundingBox, r.matrixWorld = this.matrixWorld, r.material.side = this.material.side, Ka.length = 0, r.raycast(e, Ka);
      for (let d = 0; d < Ka.length; d++)
        Ka[d].object = this, n.push(Ka[d]);
    }
  }
  copy(e) {
    const n = this.geometry;
    return super.copy(e), this.geometry = n, EN.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
c5.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(Jd.prototype, s, {
    get() {
      return this[e];
    },
    set(n) {
      n !== this[e] && (this[e] = n, this._needsSync = !0);
    }
  });
});
new O0();
new Mt();
class n9 {
  constructor(e, n = 500) {
    le(this, "entries", []);
    le(this, "totalLength", 0);
    this.curve = e, this.build(n);
  }
  build(e) {
    this.entries = [];
    let n = 0, i = this.curve.getPointAt(0);
    for (let o = 0; o <= e; o++) {
      const a = o / e, r = this.curve.getPointAt(a), l = this.curve.getTangentAt(a);
      o > 0 && (n += r.distanceTo(i)), this.entries.push({
        t: a,
        distance: n,
        position: r.clone(),
        tangent: l.clone().normalize()
      }), i = r;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.entries.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.entries[l].distance < e ? n = l + 1 : i = l;
    }
    const o = this.entries[n], a = this.entries[Math.max(0, n - 1)];
    if (o.distance === a.distance)
      return o.t;
    const r = (e - a.distance) / (o.distance - a.distance);
    return a.t + r * (o.t - a.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e), i = this.curve.getPointAt(n), o = this.curve.getTangentAt(n).normalize(), a = new pe(-o.y, o.x, 0).normalize();
    return {
      position: i,
      tangent: o,
      normal: a,
      t: n,
      distance: e
    };
  }
}
class AN {
  constructor() {
    le(this, "arcLengthTable", null);
    le(this, "curve", null);
  }
  /**
   * Set the path from control points
   */
  setPath(e, n = !1) {
    var i, o, a, r, l, c, u, d;
    if (e.length < 2) {
      this.curve = null, this.arcLengthTable = null;
      return;
    }
    this.curve = new Hc();
    for (let h = 0; h < e.length - 1; h++) {
      const p = e[h], f = e[h + 1], m = p.depth ?? 0, y = f.depth ?? 0, g = new ro(
        new pe(p.x, -p.y, m),
        new pe(
          p.x + (((i = p.handleOut) == null ? void 0 : i.x) ?? 0),
          -(p.y + (((o = p.handleOut) == null ? void 0 : o.y) ?? 0)),
          m
        ),
        new pe(
          f.x + (((a = f.handleIn) == null ? void 0 : a.x) ?? 0),
          -(f.y + (((r = f.handleIn) == null ? void 0 : r.y) ?? 0)),
          y
        ),
        new pe(f.x, -f.y, y)
      );
      this.curve.add(g);
    }
    if (n && e.length > 2) {
      const h = e[e.length - 1], p = e[0], f = h.depth ?? 0, m = p.depth ?? 0, y = new ro(
        new pe(h.x, -h.y, f),
        new pe(
          h.x + (((l = h.handleOut) == null ? void 0 : l.x) ?? 0),
          -(h.y + (((c = h.handleOut) == null ? void 0 : c.y) ?? 0)),
          f
        ),
        new pe(
          p.x + (((u = p.handleIn) == null ? void 0 : u.x) ?? 0),
          -(p.y + (((d = p.handleIn) == null ? void 0 : d.y) ?? 0)),
          m
        ),
        new pe(p.x, -p.y, m)
      );
      this.curve.add(y);
    }
    this.arcLengthTable = new n9(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(e) {
    this.curve = e, this.arcLengthTable = new n9(e);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    var e;
    return ((e = this.arcLengthTable) == null ? void 0 : e.totalLength) ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(e, n, i = 0, o = 72) {
    if (!this.arcLengthTable || e.length === 0)
      return [];
    const a = this.arcLengthTable.totalLength, r = [], l = i / 1e3 * o;
    let c = 0;
    for (let f = 0; f < e.length; f++)
      c += e[f], f < e.length - 1 && (c += l);
    const u = a - n.firstMargin - n.lastMargin;
    let d;
    switch (n.align) {
      case "center":
        d = n.firstMargin + (u - c) / 2;
        break;
      case "right":
        d = n.firstMargin + u - c;
        break;
      default:
        d = n.firstMargin;
    }
    const h = n.offset / 100 * u;
    d += h, n.reversed && (d = a - d - c);
    let p = d;
    for (let f = 0; f < e.length; f++) {
      const m = e[f];
      let g = p + m / 2, x = !0;
      (g < 0 || g > a) && (n.forceAlignment ? g = (g % a + a) % a : (x = g >= -m && g <= a + m, g = Math.max(0, Math.min(a, g))));
      const w = this.arcLengthTable.getPointAtDistance(g);
      let M;
      if (n.perpendicularToPath) {
        const _ = Math.atan2(w.tangent.y, w.tangent.x);
        M = new Hi(0, 0, n.reversed ? _ + Math.PI : _);
      } else
        M = new Hi(0, 0, 0);
      r.push({
        index: f,
        position: w.position.clone(),
        rotation: M,
        scale: 1,
        pathDistance: g,
        pathT: w.t,
        visible: x
      }), p += m + l;
    }
    return r;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(e) {
    if (!this.arcLengthTable) return null;
    const n = e / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(n);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(e) {
    if (!this.arcLengthTable || e < 2) return [];
    const n = [], i = this.arcLengthTable.totalLength / (e - 1);
    for (let o = 0; o < e; o++) {
      const a = o * i;
      n.push(this.arcLengthTable.getPointAtDistance(a));
    }
    return n;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null, this.arcLengthTable = null;
  }
}
function PN() {
  return {
    pathLayerId: null,
    reversed: !1,
    perpendicularToPath: !0,
    forceAlignment: !1,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}
class kN extends $i {
  constructor(n, i) {
    super(n);
    le(this, "resources");
    // Text rendering
    le(this, "textMesh");
    le(this, "perCharacterGroup", null);
    le(this, "characterMeshes", []);
    // Text data from layer
    le(this, "textData");
    // Animatable text properties (from layer.properties)
    le(this, "fontSizeProp");
    le(this, "trackingProp");
    le(this, "lineSpacingProp");
    le(this, "fillColorProp");
    le(this, "strokeColorProp");
    le(this, "strokeWidthProp");
    le(this, "pathOffsetProp");
    le(this, "firstMarginProp");
    le(this, "lastMarginProp");
    le(this, "characterOffsetProp");
    // Per-character animation
    le(this, "characterTransforms");
    // Path following service
    le(this, "textOnPath");
    le(this, "pathConfig");
    le(this, "pathControlPoints", []);
    le(this, "pathClosed", !1);
    // Character width cache (recalculated when text/font changes)
    le(this, "characterWidths", []);
    le(this, "characterWidthsDirty", !0);
    // Additional evaluator for text-specific properties
    le(this, "textEvaluator");
    this.resources = i, this.textEvaluator = new Ta(), this.textOnPath = new AN(), this.pathConfig = PN(), this.textData = this.extractTextData(n), this.extractAnimatableProperties(n), this.textMesh = this.createTextMesh(), this.group.add(this.textMesh), (this.textData.perCharacter3D || this.textData.pathLayerId) && this.enablePerCharacter3D(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(n) {
    const i = n.data;
    return {
      text: (i == null ? void 0 : i.text) ?? "Text",
      fontFamily: (i == null ? void 0 : i.fontFamily) ?? "Impact",
      fontSize: (i == null ? void 0 : i.fontSize) ?? 72,
      fontWeight: (i == null ? void 0 : i.fontWeight) ?? "400",
      fontStyle: (i == null ? void 0 : i.fontStyle) ?? "normal",
      fill: (i == null ? void 0 : i.fill) ?? "#ffffff",
      stroke: (i == null ? void 0 : i.stroke) ?? "",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 0,
      // Character properties
      tracking: (i == null ? void 0 : i.tracking) ?? 0,
      lineSpacing: (i == null ? void 0 : i.lineSpacing) ?? 0,
      lineAnchor: (i == null ? void 0 : i.lineAnchor) ?? 50,
      characterOffset: (i == null ? void 0 : i.characterOffset) ?? 0,
      characterValue: (i == null ? void 0 : i.characterValue) ?? 0,
      blur: (i == null ? void 0 : i.blur) ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: (i == null ? void 0 : i.letterSpacing) ?? (i == null ? void 0 : i.tracking) ?? 0,
      lineHeight: (i == null ? void 0 : i.lineHeight) ?? (i == null ? void 0 : i.lineSpacing) ?? 1.2,
      textAlign: (i == null ? void 0 : i.textAlign) ?? "left",
      // Path options (full AE parity)
      pathLayerId: (i == null ? void 0 : i.pathLayerId) ?? null,
      pathReversed: (i == null ? void 0 : i.pathReversed) ?? !1,
      pathPerpendicularToPath: (i == null ? void 0 : i.pathPerpendicularToPath) ?? !0,
      pathForceAlignment: (i == null ? void 0 : i.pathForceAlignment) ?? !1,
      pathFirstMargin: (i == null ? void 0 : i.pathFirstMargin) ?? 0,
      pathLastMargin: (i == null ? void 0 : i.pathLastMargin) ?? 0,
      pathOffset: (i == null ? void 0 : i.pathOffset) ?? 0,
      pathAlign: (i == null ? void 0 : i.pathAlign) ?? "left",
      // More Options
      anchorPointGrouping: (i == null ? void 0 : i.anchorPointGrouping) ?? "character",
      groupingAlignment: (i == null ? void 0 : i.groupingAlignment) ?? { x: 0, y: 0 },
      fillAndStroke: (i == null ? void 0 : i.fillAndStroke) ?? "fill-over-stroke",
      interCharacterBlending: (i == null ? void 0 : i.interCharacterBlending) ?? "normal",
      // 3D
      perCharacter3D: (i == null ? void 0 : i.perCharacter3D) ?? !1
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(n) {
    if (n.properties) {
      for (const i of n.properties)
        switch (i.name) {
          case "Font Size":
            this.fontSizeProp = i;
            break;
          case "Tracking":
            this.trackingProp = i;
            break;
          case "Line Spacing":
            this.lineSpacingProp = i;
            break;
          case "Fill Color":
            this.fillColorProp = i;
            break;
          case "Stroke Color":
            this.strokeColorProp = i;
            break;
          case "Stroke Width":
            this.strokeWidthProp = i;
            break;
          case "Path Offset":
            this.pathOffsetProp = i;
            break;
          case "First Margin":
            this.firstMarginProp = i;
            break;
          case "Last Margin":
            this.lastMarginProp = i;
            break;
          case "Character Offset":
            this.characterOffsetProp = i;
            break;
        }
      this.syncPathConfig();
    }
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId, this.pathConfig.reversed = this.textData.pathReversed, this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath, this.pathConfig.forceAlignment = this.textData.pathForceAlignment, this.pathConfig.firstMargin = this.textData.pathFirstMargin, this.pathConfig.lastMargin = this.textData.pathLastMargin, this.pathConfig.offset = this.textData.pathOffset, this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const n = new Jd();
    return n.text = this.textData.text, n.font = this.getFontUrl(this.textData.fontFamily) ?? null, n.fontSize = this.textData.fontSize, n.color = this.textData.fill, this.textData.stroke && this.textData.strokeWidth > 0 && (n.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, n.outlineColor = this.textData.stroke), n.letterSpacing = (this.textData.tracking || 0) / 1e3, n.lineHeight = this.textData.lineHeight || 1.2, n.textAlign = this.textData.textAlign, n.anchorX = this.getAnchorX(), n.anchorY = "middle", n.depthOffset = 0, n.renderOrder = 0, n.sync(), n;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(n) {
    return [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ].includes(n) ? void 0 : {
      Roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      Lato: "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      Montserrat: "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      Oswald: "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      Poppins: "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    }[n];
  }
  /**
   * Get anchor X based on text alignment
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "left";
      case "right":
        return "right";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(n, i = !1) {
    this.pathControlPoints = n, this.pathClosed = i, n.length >= 2 ? (this.textOnPath.setPath(n, i), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout()) : (this.textOnPath.dispose(), this.resetPathLayout());
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(n) {
    this.textOnPath.setCurve(n), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null, this.pathConfig.pathLayerId = null, this.textOnPath.dispose(), this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup)
      return;
    this.ensureCharacterWidths();
    const n = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(n);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(n) {
    for (let i = 0; i < this.characterMeshes.length && i < n.length; i++) {
      const o = this.characterMeshes[i], a = n[i];
      o.position.copy(a.position), o.rotation.copy(a.rotation), o.scale.setScalar(a.scale), o.visible = a.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    this.textData.perCharacter3D ? this.createCharacterMeshes() : this.disablePerCharacter3D();
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const n = this.textData.text, i = this.textData.fontSize * 0.6;
    for (let o = 0; o < n.length; o++) {
      const a = n[o];
      `iIl1|!.,;:'"`.includes(a) ? this.characterWidths.push(i * 0.4) : "mwMW".includes(a) ? this.characterWidths.push(i * 1.3) : a === " " ? this.characterWidths.push(i * 0.5) : this.characterWidths.push(i);
    }
    this.characterWidthsDirty = !1;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    this.perCharacterGroup || (this.textMesh.visible = !1, this.perCharacterGroup = new Bi(), this.perCharacterGroup.name = `text_chars_${this.id}`, this.group.add(this.perCharacterGroup), this.createCharacterMeshes());
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    this.perCharacterGroup && (this.textMesh.visible = !0, this.disposeCharacterMeshes(), this.group.remove(this.perCharacterGroup), this.perCharacterGroup = null);
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes(), this.characterWidthsDirty = !0;
    const n = this.textData.text;
    let i = 0;
    this.ensureCharacterWidths();
    const o = this.characterWidths.reduce((r, l) => r + l, 0) + (n.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let a = 0;
    switch (this.textData.textAlign) {
      case "center":
        a = -o / 2;
        break;
      case "right":
        a = -o;
        break;
      default:
        a = 0;
    }
    i = a;
    for (let r = 0; r < n.length; r++) {
      const l = n[r], c = new Jd();
      c.text = l, c.font = this.getFontUrl(this.textData.fontFamily) ?? null, c.fontSize = this.textData.fontSize, c.color = this.textData.fill, c.anchorX = "center", c.anchorY = "middle", this.textData.stroke && this.textData.strokeWidth > 0 && (c.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, c.outlineColor = this.textData.stroke);
      const u = this.characterWidths[r];
      c.position.x = i + u / 2, c.position.y = 0, c.position.z = 0, i += u + this.textData.tracking / 1e3 * this.textData.fontSize, c.sync(), this.characterMeshes.push(c), this.perCharacterGroup.add(c);
    }
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    var n;
    for (const i of this.characterMeshes)
      i.dispose(), (n = this.perCharacterGroup) == null || n.remove(i);
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(n) {
    this.textData.text = n, this.textMesh.text = n, this.textMesh.sync(), this.characterWidthsDirty = !0, this.perCharacterGroup && this.createCharacterMeshes();
  }
  setFontFamily(n) {
    this.textData.fontFamily = n;
    const i = this.getFontUrl(n) ?? null;
    this.textMesh.font = i, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const o of this.characterMeshes)
      o.font = i, o.sync();
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setFontSize(n) {
    this.textData.fontSize = n, this.textMesh.fontSize = n, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const i of this.characterMeshes)
      i.fontSize = n, i.sync();
    this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setFillColor(n) {
    this.textData.fill = n, this.textMesh.color = n;
    for (const i of this.characterMeshes)
      i.color = n;
  }
  setStroke(n, i) {
    this.textData.stroke = n, this.textData.strokeWidth = i;
    const o = i / this.textData.fontSize;
    this.textMesh.outlineWidth = o, this.textMesh.outlineColor = n;
    for (const a of this.characterMeshes)
      a.outlineWidth = o, a.outlineColor = n;
  }
  setTracking(n) {
    this.textData.tracking = n, this.textMesh.letterSpacing = n / 1e3, this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setTextAlign(n) {
    this.textData.textAlign = n, this.textMesh.textAlign = n, this.textMesh.anchorX = this.getAnchorX(), this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? (this.pathConfig.align = n, this.updatePathLayout()) : this.createCharacterMeshes());
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(n) {
    this.textData.pathOffset = n, this.pathConfig.offset = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(n) {
    this.textData.pathFirstMargin = n, this.pathConfig.firstMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(n) {
    this.textData.pathLastMargin = n, this.pathConfig.lastMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set path reversed
   */
  setPathReversed(n) {
    this.textData.pathReversed = n, this.pathConfig.reversed = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(n) {
    this.textData.pathPerpendicularToPath = n, this.pathConfig.perpendicularToPath = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set force alignment
   */
  setForceAlignment(n) {
    this.textData.pathForceAlignment = n, this.pathConfig.forceAlignment = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setAnchorPointGrouping(n) {
    this.textData.anchorPointGrouping = n;
  }
  setFillAndStroke(n) {
    this.textData.fillAndStroke = n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    var i, o, a, r, l, c, u;
    if ((i = this.fontSizeProp) != null && i.animated) {
      const d = this.textEvaluator.evaluate(this.fontSizeProp, n);
      this.setFontSize(d);
    }
    if ((o = this.trackingProp) != null && o.animated) {
      const d = this.textEvaluator.evaluate(this.trackingProp, n);
      this.setTracking(d);
    }
    if ((a = this.fillColorProp) != null && a.animated) {
      const d = this.textEvaluator.evaluate(this.fillColorProp, n);
      this.setFillColor(d);
    }
    if ((r = this.strokeColorProp) != null && r.animated && this.strokeWidthProp) {
      const d = this.textEvaluator.evaluate(this.strokeColorProp, n), h = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, n) : this.textData.strokeWidth;
      this.setStroke(d, h);
    }
    if (this.pathOffsetProp) {
      const d = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, n) : this.textData.pathOffset;
      this.setPathOffset(d);
    }
    if ((l = this.firstMarginProp) != null && l.animated) {
      const d = this.textEvaluator.evaluate(this.firstMarginProp, n);
      this.setFirstMargin(d);
    }
    if ((c = this.lastMarginProp) != null && c.animated) {
      const d = this.textEvaluator.evaluate(this.lastMarginProp, n);
      this.setLastMargin(d);
    }
    (u = this.characterTransforms) != null && u.animated && this.perCharacterGroup && this.applyCharacterTransforms(n);
  }
  onApplyEvaluatedState(n) {
    const i = n.properties;
    i.fontSize !== void 0 && this.setFontSize(i.fontSize), i.tracking !== void 0 && this.setTracking(i.tracking), i.fillColor !== void 0 && this.setFillColor(i.fillColor), (i.strokeColor !== void 0 || i.strokeWidth !== void 0) && this.setStroke(
      i.strokeColor ?? this.textData.stroke,
      i.strokeWidth ?? this.textData.strokeWidth
    ), i.pathOffset !== void 0 && this.setPathOffset(i.pathOffset), i.firstMargin !== void 0 && this.setFirstMargin(i.firstMargin), i.lastMargin !== void 0 && this.setLastMargin(i.lastMargin), n.effects.length > 0 && this.applyEvaluatedEffects(n.effects);
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(n) {
    if (!this.characterTransforms) return;
    const i = this.textEvaluator.evaluate(this.characterTransforms, n);
    for (let o = 0; o < this.characterMeshes.length && o < i.length; o++) {
      const a = this.characterMeshes[o], r = i[o];
      a.position.x += r.position.x, a.position.y += r.position.y, a.position.z += r.position.z, a.rotation.x += ln.degToRad(r.rotation.x), a.rotation.y += ln.degToRad(r.rotation.y), a.rotation.z += ln.degToRad(r.rotation.z), a.scale.x *= r.scale.x, a.scale.y *= r.scale.y, a.material && (a.material.opacity *= r.opacity);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.text !== void 0 && this.setText(i.text), i.fontFamily !== void 0 && this.setFontFamily(i.fontFamily), i.fontSize !== void 0 && this.setFontSize(i.fontSize), i.fill !== void 0 && this.setFillColor(i.fill), (i.stroke !== void 0 || i.strokeWidth !== void 0) && this.setStroke(
      i.stroke ?? this.textData.stroke,
      i.strokeWidth ?? this.textData.strokeWidth
    ), i.tracking !== void 0 && this.setTracking(i.tracking), i.textAlign !== void 0 && this.setTextAlign(i.textAlign), i.pathLayerId !== void 0 && (this.textData.pathLayerId = i.pathLayerId, this.pathConfig.pathLayerId = i.pathLayerId), i.pathOffset !== void 0 && this.setPathOffset(i.pathOffset), i.pathFirstMargin !== void 0 && this.setFirstMargin(i.pathFirstMargin), i.pathLastMargin !== void 0 && this.setLastMargin(i.pathLastMargin), i.pathReversed !== void 0 && this.setPathReversed(i.pathReversed), i.pathPerpendicularToPath !== void 0 && this.setPerpendicularToPath(i.pathPerpendicularToPath), i.pathForceAlignment !== void 0 && this.setForceAlignment(i.pathForceAlignment), i.perCharacter3D !== void 0 && (i.perCharacter3D && !this.perCharacterGroup ? this.enablePerCharacter3D() : !i.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup && this.disablePerCharacter3D()), i.anchorPointGrouping !== void 0 && this.setAnchorPointGrouping(i.anchorPointGrouping), i.fillAndStroke !== void 0 && this.setFillAndStroke(i.fillAndStroke)), n.properties && this.extractAnimatableProperties(n);
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    var i;
    const n = (i = this.textMesh.textRenderInfo) == null ? void 0 : i.blockBounds;
    return n ? {
      width: n[2] - n[0],
      height: n[3] - n[1]
    } : { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose(), this.disposeCharacterMeshes(), this.textOnPath.dispose(), this.perCharacterGroup && this.group.remove(this.perCharacterGroup);
  }
}
class DN extends $i {
  constructor(n) {
    super(n);
    /** The line mesh for the spline */
    le(this, "lineMesh", null);
    /** The fill mesh (if closed path with fill) */
    le(this, "fillMesh", null);
    /** Spline data */
    le(this, "splineData");
    /** Cached curve for path calculations */
    le(this, "curve", null);
    /** Animated control points (if spline is animated) */
    le(this, "animatedPoints", null);
    /** Last evaluated frame for cache invalidation */
    le(this, "lastEvaluatedFrame", -1);
    /** Cached evaluated points for the current frame */
    le(this, "cachedEvaluatedPoints", null);
    /** Hash of last evaluated points for change detection */
    le(this, "lastPointsHash", "");
    this.splineData = this.extractSplineData(n), this.splineData.animated && this.splineData.animatedControlPoints && (this.animatedPoints = this.splineData.animatedControlPoints), this.buildSpline(), this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(n) {
    const i = n.data;
    return {
      controlPoints: (i == null ? void 0 : i.controlPoints) ?? [],
      closed: (i == null ? void 0 : i.closed) ?? !1,
      stroke: (i == null ? void 0 : i.stroke) ?? "#00ff00",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 2,
      fill: (i == null ? void 0 : i.fill) ?? "",
      pathData: (i == null ? void 0 : i.pathData) ?? ""
    };
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    var r, l, c, u, d, h, p, f;
    this.clearMeshes();
    const n = this.splineData.controlPoints;
    if (n.length < 2) return;
    this.curve = new Hc();
    for (let m = 0; m < n.length - 1; m++) {
      const y = n[m], g = n[m + 1], x = y.depth ?? 0, w = g.depth ?? 0, M = new ro(
        new pe(y.x, -y.y, x),
        new pe(
          y.x + (((r = y.handleOut) == null ? void 0 : r.x) ?? 0),
          -(y.y + (((l = y.handleOut) == null ? void 0 : l.y) ?? 0)),
          x
        ),
        new pe(
          g.x + (((c = g.handleIn) == null ? void 0 : c.x) ?? 0),
          -(g.y + (((u = g.handleIn) == null ? void 0 : u.y) ?? 0)),
          w
        ),
        new pe(g.x, -g.y, w)
      );
      this.curve.add(M);
    }
    if (this.splineData.closed && n.length > 2) {
      const m = n[n.length - 1], y = n[0], g = m.depth ?? 0, x = y.depth ?? 0, w = new ro(
        new pe(m.x, -m.y, g),
        new pe(
          m.x + (((d = m.handleOut) == null ? void 0 : d.x) ?? 0),
          -(m.y + (((h = m.handleOut) == null ? void 0 : h.y) ?? 0)),
          g
        ),
        new pe(
          y.x + (((p = y.handleIn) == null ? void 0 : p.x) ?? 0),
          -(y.y + (((f = y.handleIn) == null ? void 0 : f.y) ?? 0)),
          x
        ),
        new pe(y.x, -y.y, x)
      );
      this.curve.add(w);
    }
    const i = this.curve.getPoints(n.length * 20), o = new Ut().setFromPoints(i), a = new Gi({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: !0
    });
    this.lineMesh = new cn(o, a), this.lineMesh.name = `spline_line_${this.id}`, this.group.add(this.lineMesh), this.splineData.fill && this.splineData.closed && this.createFill(i);
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(n) {
    if (n.length < 3) return;
    const i = new mu();
    i.moveTo(n[0].x, n[0].y);
    for (let r = 1; r < n.length; r++)
      i.lineTo(n[r].x, n[r].y);
    i.closePath();
    const o = new Nh(i), a = new _n({
      color: this.splineData.fill,
      transparent: !0,
      side: mn,
      depthWrite: !1
    });
    this.fillMesh = new Ke(o, a), this.fillMesh.name = `spline_fill_${this.id}`, this.fillMesh.position.z = -0.1, this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    this.lineMesh && (this.group.remove(this.lineMesh), this.lineMesh.geometry.dispose(), this.lineMesh.material.dispose(), this.lineMesh = null), this.fillMesh && (this.group.remove(this.fillMesh), this.fillMesh.geometry.dispose(), this.fillMesh.material.dispose(), this.fillMesh = null), this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(n) {
    return this.curve ? this.curve.getPointAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(n) {
    return this.curve ? this.curve.getTangentAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    return this.curve ? this.curve.getLength() : 0;
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(n) {
    const i = this.getPointAt(n), o = this.getTangentAt(n);
    if (!i || !o) return null;
    const a = Math.atan2(o.y, o.x) * (180 / Math.PI);
    return { position: i, rotation: a };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(n) {
    this.splineData.stroke = n, this.lineMesh && this.lineMesh.material.color.set(n);
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(n) {
    this.splineData.strokeWidth = n, this.lineMesh && (this.lineMesh.material.linewidth = n);
  }
  /**
   * Set fill color
   */
  setFill(n) {
    if (this.splineData.fill = n, this.fillMesh)
      this.fillMesh.material.color.set(n);
    else if (n && this.splineData.closed && this.curve) {
      const i = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(i);
    }
  }
  /**
   * Update control points (static)
   */
  setControlPoints(n) {
    this.splineData.controlPoints = n, this.animatedPoints = null, this.splineData.animated = !1, this.buildSpline();
  }
  /**
   * Set animated control points
   * Enables animation mode for this spline
   */
  setAnimatedControlPoints(n) {
    this.animatedPoints = n, this.splineData.animatedControlPoints = n, this.splineData.animated = !0, this.lastEvaluatedFrame = -1, this.cachedEvaluatedPoints = null, this.lastPointsHash = "";
  }
  /**
   * Enable animation on this spline by converting static control points
   * to AnimatableControlPoint format
   */
  enableAnimation() {
    if (this.animatedPoints)
      return this.animatedPoints;
    const { controlPointToAnimatable: n } = require("@/types/project"), i = this.splineData.controlPoints.map(
      (o) => n(o)
    );
    return this.setAnimatedControlPoints(i), i;
  }
  /**
   * Disable animation and convert back to static control points
   */
  disableAnimation() {
    if (!this.animatedPoints) return;
    const { animatableToControlPoint: n } = require("@/types/project");
    this.splineData.controlPoints = this.animatedPoints.map(
      (i) => n(i)
    ), this.animatedPoints = null, this.splineData.animatedControlPoints = void 0, this.splineData.animated = !1, this.lastEvaluatedFrame = -1, this.cachedEvaluatedPoints = null, this.lastPointsHash = "", this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(n) {
    this.splineData.closed !== n && (this.splineData.closed = n, this.buildSpline());
  }
  /**
   * Check if the spline path is closed
   */
  isClosed() {
    return this.splineData.closed;
  }
  // ============================================================================
  // ANIMATED SPLINE EVALUATION
  // ============================================================================
  /**
   * Check if this spline has animated control points
   */
  isAnimated() {
    return this.animatedPoints !== null && this.animatedPoints.length > 0;
  }
  /**
   * Evaluate a single animated control point at a specific frame
   * Uses interpolateProperty from interpolation.ts
   * Driven values override interpolated values
   */
  evaluateControlPointAtFrame(n, i, o) {
    const a = mt(n.x, i), r = mt(n.y, i), l = n.depth ? mt(n.depth, i) : 0;
    return {
      id: n.id,
      x: this.getDrivenControlPointValue(o, "x", a),
      y: this.getDrivenControlPointValue(o, "y", r),
      depth: this.getDrivenControlPointValue(o, "depth", l),
      handleIn: n.handleIn ? {
        x: mt(n.handleIn.x, i),
        y: mt(n.handleIn.y, i)
      } : null,
      handleOut: n.handleOut ? {
        x: mt(n.handleOut.x, i),
        y: mt(n.handleOut.y, i)
      } : null,
      type: n.type
    };
  }
  /**
   * Get evaluated control points at a specific frame
   * PUBLIC API for TextLayer and other consumers
   *
   * For static splines, returns the static control points converted to EvaluatedControlPoint
   * For animated splines, interpolates all control points at the given frame
   * Driven values (from PropertyDriverSystem) override interpolated values
   *
   * DETERMINISM: Same frame + same drivers = same output (pure function)
   */
  getEvaluatedControlPoints(n) {
    const i = this.hasSplineDrivers();
    if (n === this.lastEvaluatedFrame && this.cachedEvaluatedPoints && !i)
      return this.cachedEvaluatedPoints;
    let o;
    return this.animatedPoints && this.animatedPoints.length > 0 ? o = this.animatedPoints.map(
      (a, r) => this.evaluateControlPointAtFrame(a, n, r)
    ) : o = this.splineData.controlPoints.map((a, r) => ({
      id: a.id,
      x: this.getDrivenControlPointValue(r, "x", a.x),
      y: this.getDrivenControlPointValue(r, "y", a.y),
      depth: this.getDrivenControlPointValue(r, "depth", a.depth ?? 0),
      handleIn: a.handleIn,
      handleOut: a.handleOut,
      type: a.type
    })), this.lastEvaluatedFrame = n, i || (this.cachedEvaluatedPoints = o), o;
  }
  /**
   * Check if any spline control point drivers are active
   */
  hasSplineDrivers() {
    for (const n of this.drivenValues.keys())
      if (vM(n))
        return !0;
    return !1;
  }
  /**
   * Get a driven control point value, falling back to base value
   */
  getDrivenControlPointValue(n, i, o) {
    const a = gM(n, i);
    return this.getDrivenOrBase(a, o);
  }
  /**
   * Compute a hash of control point positions for change detection
   * Used to avoid rebuilding geometry when positions haven't changed
   */
  computePointsHash(n) {
    return n.map(
      (i) => `${i.x.toFixed(2)},${i.y.toFixed(2)},${i.depth.toFixed(2)}`
    ).join("|");
  }
  /**
   * Build spline geometry from evaluated control points
   * Called when control points change during animation
   */
  buildSplineFromEvaluatedPoints(n) {
    var r, l, c, u, d, h, p, f;
    if (this.clearMeshes(), n.length < 2) return;
    this.curve = new Hc();
    for (let m = 0; m < n.length - 1; m++) {
      const y = n[m], g = n[m + 1], x = y.depth, w = g.depth, M = new ro(
        new pe(y.x, -y.y, x),
        new pe(
          y.x + (((r = y.handleOut) == null ? void 0 : r.x) ?? 0),
          -(y.y + (((l = y.handleOut) == null ? void 0 : l.y) ?? 0)),
          x
        ),
        new pe(
          g.x + (((c = g.handleIn) == null ? void 0 : c.x) ?? 0),
          -(g.y + (((u = g.handleIn) == null ? void 0 : u.y) ?? 0)),
          w
        ),
        new pe(g.x, -g.y, w)
      );
      this.curve.add(M);
    }
    if (this.splineData.closed && n.length > 2) {
      const m = n[n.length - 1], y = n[0], g = m.depth, x = y.depth, w = new ro(
        new pe(m.x, -m.y, g),
        new pe(
          m.x + (((d = m.handleOut) == null ? void 0 : d.x) ?? 0),
          -(m.y + (((h = m.handleOut) == null ? void 0 : h.y) ?? 0)),
          g
        ),
        new pe(
          y.x + (((p = y.handleIn) == null ? void 0 : p.x) ?? 0),
          -(y.y + (((f = y.handleIn) == null ? void 0 : f.y) ?? 0)),
          x
        ),
        new pe(y.x, -y.y, x)
      );
      this.curve.add(w);
    }
    const i = this.curve.getPoints(n.length * 20), o = new Ut().setFromPoints(i), a = new Gi({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: !0
    });
    this.lineMesh = new cn(o, a), this.lineMesh.name = `spline_line_${this.id}`, this.group.add(this.lineMesh), this.splineData.fill && this.splineData.closed && this.createFill(i);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    if (!this.isAnimated())
      return;
    const i = this.getEvaluatedControlPoints(n), o = this.computePointsHash(i);
    o !== this.lastPointsHash && (this.buildSplineFromEvaluatedPoints(i), this.lastPointsHash = o);
  }
  onApplyEvaluatedState(n) {
    const i = n.properties;
    if (i.controlPoints !== void 0) {
      const o = i.controlPoints, a = this.computePointsHash(o);
      a !== this.lastPointsHash && (this.buildSplineFromEvaluatedPoints(o), this.lastPointsHash = a);
    }
    i.strokeWidth !== void 0 && this.setStrokeWidth(i.strokeWidth), i.strokeColor !== void 0 && this.setStroke(i.strokeColor);
  }
  onUpdate(n) {
    const i = n.data;
    if (i) {
      let o = !1;
      i.animatedControlPoints !== void 0 ? (this.setAnimatedControlPoints(i.animatedControlPoints), o = !1) : i.controlPoints !== void 0 && (this.splineData.controlPoints = i.controlPoints, i.animated || (this.animatedPoints = null, this.splineData.animated = !1), o = !0), i.animated !== void 0 && (i.animated && !this.animatedPoints ? (this.enableAnimation(), o = !1) : !i.animated && this.animatedPoints && (this.disableAnimation(), o = !1)), i.closed !== void 0 && i.closed !== this.splineData.closed && (this.splineData.closed = i.closed, o = !0), i.stroke !== void 0 && this.setStroke(i.stroke), i.strokeWidth !== void 0 && this.setStrokeWidth(i.strokeWidth), i.fill !== void 0 && this.setFill(i.fill), o && this.buildSpline();
    }
  }
  onDispose() {
    this.clearMeshes();
  }
}
const is = 16, Kl = 16, IN = 50, RN = [
  "tf_position",
  "tf_velocity",
  "tf_life",
  "tf_physical",
  "tf_rotation",
  "tf_color"
];
function i9(s) {
  return {
    id: s || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: !0,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: !1,
    beatEmissionMultiplier: 5
  };
}
function LN(s, e) {
  const n = {
    id: e || `force_${Date.now()}`,
    name: s.charAt(0).toUpperCase() + s.slice(1),
    type: s,
    enabled: !0,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (s) {
    case "gravity":
      n.direction = { x: 0, y: 1, z: 0 }, n.strength = 98;
      break;
    case "vortex":
      n.vortexAxis = { x: 0, y: 0, z: 1 }, n.inwardForce = 20;
      break;
    case "turbulence":
      n.noiseScale = 5e-3, n.noiseSpeed = 0.5, n.noiseOctaves = 3, n.noiseLacunarity = 2, n.noiseGain = 0.5;
      break;
    case "drag":
      n.linearDrag = 0.1, n.quadraticDrag = 0.01;
      break;
    case "wind":
      n.windDirection = { x: 1, y: 0, z: 0 }, n.gustStrength = 50, n.gustFrequency = 0.1;
      break;
    case "lorenz":
      n.lorenzSigma = 10, n.lorenzRho = 28, n.lorenzBeta = 2.667;
      break;
  }
  return n;
}
function u5() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: !0,
      depthWrite: !1,
      depthTest: !0,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: !1,
        receiveShadows: !1,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: !1,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: !1,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: !1,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: !1,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: !1,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: IN,
    updateFrequency: 1,
    cullOffscreen: !0
  };
}
class s9 {
  constructor(e = {}) {
    le(this, "config");
    le(this, "gl", null);
    le(this, "renderer", null);
    // Double-buffered particle data
    le(this, "particleBufferA");
    le(this, "particleBufferB");
    le(this, "currentBuffer", "A");
    // WebGL resources
    le(this, "transformFeedbackProgram", null);
    le(this, "renderProgram", null);
    le(this, "vaoA", null);
    le(this, "vaoB", null);
    le(this, "particleVboA", null);
    le(this, "particleVboB", null);
    le(this, "transformFeedbackA", null);
    le(this, "transformFeedbackB", null);
    // Three.js integration
    le(this, "particleMesh", null);
    le(this, "instancedGeometry", null);
    le(this, "material", null);
    // Textures for modulation curves
    le(this, "sizeOverLifetimeTexture", null);
    le(this, "opacityOverLifetimeTexture", null);
    le(this, "colorOverLifetimeTexture", null);
    // Emitter state
    le(this, "emitters", /* @__PURE__ */ new Map());
    le(this, "forceFields", /* @__PURE__ */ new Map());
    le(this, "subEmitters", /* @__PURE__ */ new Map());
    // Runtime state
    le(this, "state", {
      particleCount: 0,
      activeEmitters: 0,
      simulationTime: 0,
      frameCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0,
      gpuMemoryBytes: 0,
      currentAudioFeatures: /* @__PURE__ */ new Map()
    });
    // Audio reactivity
    le(this, "audioFeatures", /* @__PURE__ */ new Map());
    // Spatial hash for neighbor queries (flocking)
    le(this, "spatialHash", /* @__PURE__ */ new Map());
    // Event system
    le(this, "eventHandlers", /* @__PURE__ */ new Map());
    // Pool of free particle indices
    le(this, "freeIndices", []);
    le(this, "nextParticleIndex", 0);
    // Random number generator with seed
    le(this, "rng");
    // ============================================================================
    // Initialization
    // ============================================================================
    // GPU physics mode flag
    le(this, "useGPUPhysics", !1);
    le(this, "gpuPhysicsInitialized", !1);
    // Force field uniform buffer for GPU physics
    le(this, "forceFieldBuffer", null);
    le(this, "forceFieldTexture", null);
    this.config = { ...u5(), ...e };
    const n = this.config.maxParticles * is;
    this.particleBufferA = new Float32Array(n), this.particleBufferB = new Float32Array(n);
    for (let i = this.config.maxParticles - 1; i >= 0; i--)
      this.freeIndices.push(i);
    this.rng = this.createSeededRandom(this.config.randomSeed ?? Date.now()), this.config.emitters.forEach((i) => this.addEmitter(i)), this.config.forceFields.forEach((i) => this.addForceField(i)), this.config.subEmitters.forEach((i) => this.addSubEmitter(i));
  }
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(e) {
    if (this.renderer = e, this.gl = e.getContext(), !this.gl)
      throw new Error("WebGL2 context required for GPU particle system");
    this.createModulationTextures(), this.createParticleMesh(), this.initializeGPUPhysics(), this.state.gpuMemoryBytes = this.config.maxParticles * is * 4 * 2;
  }
  /**
   * Initialize WebGL2 Transform Feedback for GPU-accelerated physics
   * This allows physics simulation to run entirely on the GPU for 100k+ particles
   */
  initializeGPUPhysics() {
    if (!this.gl) return;
    const e = this.gl;
    if (!e.getExtension("EXT_color_buffer_float")) {
      console.warn("EXT_color_buffer_float not available, using CPU physics fallback"), this.useGPUPhysics = !1;
      return;
    }
    try {
      if (this.transformFeedbackProgram = this.createTransformFeedbackProgram(e), !this.transformFeedbackProgram) {
        console.warn("Failed to create transform feedback program, using CPU physics"), this.useGPUPhysics = !1;
        return;
      }
      if (this.particleVboA = e.createBuffer(), this.particleVboB = e.createBuffer(), !this.particleVboA || !this.particleVboB)
        throw new Error("Failed to create particle VBOs");
      if (e.bindBuffer(e.ARRAY_BUFFER, this.particleVboA), e.bufferData(e.ARRAY_BUFFER, this.particleBufferA, e.DYNAMIC_COPY), e.bindBuffer(e.ARRAY_BUFFER, this.particleVboB), e.bufferData(e.ARRAY_BUFFER, this.particleBufferB, e.DYNAMIC_COPY), this.vaoA = e.createVertexArray(), this.vaoB = e.createVertexArray(), !this.vaoA || !this.vaoB)
        throw new Error("Failed to create VAOs");
      if (this.setupParticleVAO(e, this.vaoA, this.particleVboA), this.setupParticleVAO(e, this.vaoB, this.particleVboB), this.transformFeedbackA = e.createTransformFeedback(), this.transformFeedbackB = e.createTransformFeedback(), !this.transformFeedbackA || !this.transformFeedbackB)
        throw new Error("Failed to create transform feedback objects");
      e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, this.transformFeedbackA), e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboB), e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, this.transformFeedbackB), e.bindBufferBase(e.TRANSFORM_FEEDBACK_BUFFER, 0, this.particleVboA), e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null), this.forceFieldBuffer = new Float32Array(Kl * 16), this.forceFieldTexture = new cs(
        this.forceFieldBuffer,
        Kl,
        4,
        // 4 rows of 4 floats = 16 floats per force field
        Sn,
        Vn
      ), this.useGPUPhysics = !0, this.gpuPhysicsInitialized = !0, console.log("GPU physics initialized with Transform Feedback");
    } catch (i) {
      console.warn("GPU physics initialization failed:", i), this.useGPUPhysics = !1, this.cleanupGPUPhysics();
    }
  }
  /**
   * Set up vertex attribute pointers for particle VAO
   */
  setupParticleVAO(e, n, i) {
    e.bindVertexArray(n), e.bindBuffer(e.ARRAY_BUFFER, i);
    const o = is * 4;
    e.enableVertexAttribArray(0), e.vertexAttribPointer(0, 3, e.FLOAT, !1, o, 0), e.enableVertexAttribArray(1), e.vertexAttribPointer(1, 3, e.FLOAT, !1, o, 12), e.enableVertexAttribArray(2), e.vertexAttribPointer(2, 2, e.FLOAT, !1, o, 24), e.enableVertexAttribArray(3), e.vertexAttribPointer(3, 2, e.FLOAT, !1, o, 32), e.enableVertexAttribArray(4), e.vertexAttribPointer(4, 2, e.FLOAT, !1, o, 40), e.enableVertexAttribArray(5), e.vertexAttribPointer(5, 4, e.FLOAT, !1, o, 48), e.bindVertexArray(null);
  }
  /**
   * Create the transform feedback shader program for GPU physics
   */
  createTransformFeedbackProgram(e) {
    const n = this.getTransformFeedbackVertexShader(), i = this.getTransformFeedbackFragmentShader(), o = e.createShader(e.VERTEX_SHADER), a = e.createShader(e.FRAGMENT_SHADER);
    if (!o || !a) return null;
    if (e.shaderSource(o, n), e.compileShader(o), !e.getShaderParameter(o, e.COMPILE_STATUS))
      return console.error("Transform feedback vertex shader error:", e.getShaderInfoLog(o)), e.deleteShader(o), e.deleteShader(a), null;
    if (e.shaderSource(a, i), e.compileShader(a), !e.getShaderParameter(a, e.COMPILE_STATUS))
      return console.error("Transform feedback fragment shader error:", e.getShaderInfoLog(a)), e.deleteShader(o), e.deleteShader(a), null;
    const r = e.createProgram();
    return r ? (e.attachShader(r, o), e.attachShader(r, a), e.transformFeedbackVaryings(r, RN, e.INTERLEAVED_ATTRIBS), e.linkProgram(r), e.getProgramParameter(r, e.LINK_STATUS) ? (e.deleteShader(o), e.deleteShader(a), r) : (console.error("Transform feedback program link error:", e.getProgramInfoLog(r)), e.deleteProgram(r), e.deleteShader(o), e.deleteShader(a), null)) : (e.deleteShader(o), e.deleteShader(a), null);
  }
  /**
   * Get the vertex shader for transform feedback GPU physics
   */
  getTransformFeedbackVertexShader() {
    return `#version 300 es
      precision highp float;

      // Input particle attributes
      layout(location = 0) in vec3 a_position;
      layout(location = 1) in vec3 a_velocity;
      layout(location = 2) in vec2 a_life;      // age, lifetime
      layout(location = 3) in vec2 a_physical;  // mass, size
      layout(location = 4) in vec2 a_rotation;  // rotation, angularVelocity
      layout(location = 5) in vec4 a_color;

      // Output (transform feedback)
      out vec3 tf_position;
      out vec3 tf_velocity;
      out vec2 tf_life;
      out vec2 tf_physical;
      out vec2 tf_rotation;
      out vec4 tf_color;

      // Uniforms
      uniform float u_deltaTime;
      uniform float u_time;
      uniform int u_forceFieldCount;
      uniform sampler2D u_forceFields;

      // Noise functions for turbulence
      vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
      vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
      vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

      float snoise(vec3 v) {
        const vec2 C = vec2(1.0/6.0, 1.0/3.0);
        const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

        vec3 i = floor(v + dot(v, C.yyy));
        vec3 x0 = v - i + dot(i, C.xxx);

        vec3 g = step(x0.yzx, x0.xyz);
        vec3 l = 1.0 - g;
        vec3 i1 = min(g.xyz, l.zxy);
        vec3 i2 = max(g.xyz, l.zxy);

        vec3 x1 = x0 - i1 + C.xxx;
        vec3 x2 = x0 - i2 + C.yyy;
        vec3 x3 = x0 - D.yyy;

        i = mod289(i);
        vec4 p = permute(permute(permute(
          i.z + vec4(0.0, i1.z, i2.z, 1.0))
          + i.y + vec4(0.0, i1.y, i2.y, 1.0))
          + i.x + vec4(0.0, i1.x, i2.x, 1.0));

        float n_ = 0.142857142857;
        vec3 ns = n_ * D.wyz - D.xzx;

        vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

        vec4 x_ = floor(j * ns.z);
        vec4 y_ = floor(j - 7.0 * x_);

        vec4 x = x_ * ns.x + ns.yyyy;
        vec4 y = y_ * ns.x + ns.yyyy;
        vec4 h = 1.0 - abs(x) - abs(y);

        vec4 b0 = vec4(x.xy, y.xy);
        vec4 b1 = vec4(x.zw, y.zw);

        vec4 s0 = floor(b0) * 2.0 + 1.0;
        vec4 s1 = floor(b1) * 2.0 + 1.0;
        vec4 sh = -step(h, vec4(0.0));

        vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
        vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

        vec3 p0 = vec3(a0.xy, h.x);
        vec3 p1 = vec3(a0.zw, h.y);
        vec3 p2 = vec3(a1.xy, h.z);
        vec3 p3 = vec3(a1.zw, h.w);

        vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
        p0 *= norm.x;
        p1 *= norm.y;
        p2 *= norm.z;
        p3 *= norm.w;

        vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
        m = m * m;
        return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
      }

      // Calculate force from a single force field
      vec3 calculateForce(int fieldIndex, vec3 pos, vec3 vel, float mass) {
        // Read force field data from texture
        // Row 0: position.xyz, type
        // Row 1: strength, falloffStart, falloffEnd, falloffType
        // Row 2: direction/axis.xyz, extra param
        // Row 3: extra params (noise scale, speed, etc)

        vec4 row0 = texelFetch(u_forceFields, ivec2(fieldIndex, 0), 0);
        vec4 row1 = texelFetch(u_forceFields, ivec2(fieldIndex, 1), 0);
        vec4 row2 = texelFetch(u_forceFields, ivec2(fieldIndex, 2), 0);
        vec4 row3 = texelFetch(u_forceFields, ivec2(fieldIndex, 3), 0);

        vec3 fieldPos = row0.xyz;
        int fieldType = int(row0.w);
        float strength = row1.x;
        float falloffStart = row1.y;
        float falloffEnd = row1.z;
        int falloffType = int(row1.w);

        // Calculate distance and falloff
        vec3 toField = fieldPos - pos;
        float dist = length(toField);

        float falloff = 1.0;
        if (dist > falloffStart && falloffEnd > falloffStart) {
          float t = clamp((dist - falloffStart) / (falloffEnd - falloffStart), 0.0, 1.0);
          if (falloffType == 1) falloff = 1.0 - t; // Linear
          else if (falloffType == 2) falloff = 1.0 - t * t; // Quadratic
          else if (falloffType == 3) falloff = exp(-t * 3.0); // Exponential
          else if (falloffType == 4) falloff = 1.0 - (3.0 * t * t - 2.0 * t * t * t); // Smoothstep
        }

        vec3 force = vec3(0.0);
        float effectiveStrength = strength * falloff;

        // Force field types
        if (fieldType == 0) {
          // Gravity - directional
          force = row2.xyz * effectiveStrength;
        }
        else if (fieldType == 1) {
          // Point attractor
          if (dist > 0.001) {
            vec3 dir = normalize(toField);
            force = dir * effectiveStrength / max(mass, 0.1);
          }
        }
        else if (fieldType == 2) {
          // Vortex
          if (dist > 0.001) {
            vec3 axis = normalize(row2.xyz);
            vec3 tangent = normalize(cross(axis, toField));
            float inward = row2.w;
            force = tangent * effectiveStrength + normalize(toField) * inward;
          }
        }
        else if (fieldType == 3) {
          // Turbulence
          float noiseScale = row3.x;
          float noiseSpeed = row3.y;
          vec3 noisePos = pos * noiseScale + vec3(u_time * noiseSpeed);
          force.x = snoise(noisePos) * effectiveStrength;
          force.y = snoise(noisePos + vec3(100.0)) * effectiveStrength;
          force.z = snoise(noisePos + vec3(200.0)) * effectiveStrength;
        }
        else if (fieldType == 4) {
          // Drag
          float linearDrag = row3.x;
          float quadDrag = row3.y;
          float speed = length(vel);
          if (speed > 0.001) {
            float dragMag = linearDrag * speed + quadDrag * speed * speed;
            force = -normalize(vel) * dragMag * effectiveStrength;
          }
        }
        else if (fieldType == 5) {
          // Wind
          vec3 windDir = normalize(row2.xyz);
          float gustStrength = row3.x;
          float gustFreq = row3.y;
          float gust = sin(u_time * gustFreq) * gustStrength;
          force = windDir * (effectiveStrength + gust);
        }

        return force;
      }

      void main() {
        // Pass through dead particles unchanged
        if (a_life.y <= 0.0 || a_life.x >= a_life.y) {
          tf_position = a_position;
          tf_velocity = a_velocity;
          tf_life = a_life;
          tf_physical = a_physical;
          tf_rotation = a_rotation;
          tf_color = a_color;
          return;
        }

        // Read particle state
        vec3 pos = a_position;
        vec3 vel = a_velocity;
        float age = a_life.x;
        float lifetime = a_life.y;
        float mass = a_physical.x;
        float size = a_physical.y;
        float rotation = a_rotation.x;
        float angularVel = a_rotation.y;

        // Accumulate forces
        vec3 totalForce = vec3(0.0);
        for (int i = 0; i < u_forceFieldCount; i++) {
          totalForce += calculateForce(i, pos, vel, mass);
        }

        // Apply acceleration (F = ma)
        vec3 acceleration = totalForce / max(mass, 0.1);
        vel += acceleration * u_deltaTime;

        // Integrate position
        pos += vel * u_deltaTime;

        // Update rotation
        rotation += angularVel * u_deltaTime;

        // Update age
        age += u_deltaTime;

        // Life ratio for modulation
        float lifeRatio = age / lifetime;

        // Apply size over lifetime (simple linear fade for now)
        // More complex curves should be done via texture lookup
        float sizeMod = 1.0 - lifeRatio * 0.5;
        size = a_physical.y * sizeMod;

        // Apply opacity over lifetime
        float opacityMod = 1.0 - lifeRatio;

        // Output
        tf_position = pos;
        tf_velocity = vel;
        tf_life = vec2(age, lifetime);
        tf_physical = vec2(mass, size);
        tf_rotation = vec2(rotation, angularVel);
        tf_color = vec4(a_color.rgb, a_color.a * opacityMod);
      }
    `;
  }
  /**
   * Get the fragment shader for transform feedback (must exist but won't output)
   */
  getTransformFeedbackFragmentShader() {
    return `#version 300 es
      precision highp float;
      out vec4 fragColor;
      void main() {
        fragColor = vec4(0.0);
      }
    `;
  }
  /**
   * Clean up GPU physics resources
   */
  cleanupGPUPhysics() {
    var n;
    if (!this.gl) return;
    const e = this.gl;
    this.transformFeedbackProgram && (e.deleteProgram(this.transformFeedbackProgram), this.transformFeedbackProgram = null), this.particleVboA && (e.deleteBuffer(this.particleVboA), this.particleVboA = null), this.particleVboB && (e.deleteBuffer(this.particleVboB), this.particleVboB = null), this.vaoA && (e.deleteVertexArray(this.vaoA), this.vaoA = null), this.vaoB && (e.deleteVertexArray(this.vaoB), this.vaoB = null), this.transformFeedbackA && (e.deleteTransformFeedback(this.transformFeedbackA), this.transformFeedbackA = null), this.transformFeedbackB && (e.deleteTransformFeedback(this.transformFeedbackB), this.transformFeedbackB = null), (n = this.forceFieldTexture) == null || n.dispose(), this.forceFieldTexture = null;
  }
  /**
   * Enable or disable GPU physics
   */
  setGPUPhysicsEnabled(e) {
    e && !this.gpuPhysicsInitialized && this.initializeGPUPhysics(), this.useGPUPhysics = e && this.gpuPhysicsInitialized;
  }
  /**
   * Check if GPU physics is currently enabled
   */
  isGPUPhysicsEnabled() {
    return this.useGPUPhysics;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const n = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, n), this.sizeOverLifetimeTexture = new cs(
      n,
      256,
      1,
      Br,
      Vn
    ), this.sizeOverLifetimeTexture.needsUpdate = !0;
    const i = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, i), this.opacityOverLifetimeTexture = new cs(
      i,
      256,
      1,
      Br,
      Vn
    ), this.opacityOverLifetimeTexture.needsUpdate = !0;
    const o = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ], a = new Float32Array(256 * 4);
    for (let r = 0; r < 256; r++) {
      const l = r / 255, c = this.sampleColorGradient(o, l);
      a[r * 4] = c[0], a[r * 4 + 1] = c[1], a[r * 4 + 2] = c[2], a[r * 4 + 3] = c[3];
    }
    this.colorOverLifetimeTexture = new cs(
      a,
      256,
      1,
      Sn,
      Vn
    ), this.colorOverLifetimeTexture.needsUpdate = !0;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(e, n) {
    const i = n.length;
    if (!e) {
      n.fill(1);
      return;
    }
    for (let o = 0; o < i; o++) {
      const a = o / (i - 1);
      n[o] = this.evaluateModulationCurve(e, a);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(e, n) {
    switch (e.type) {
      case "constant":
        return e.value;
      case "linear":
        return e.start + (e.end - e.start) * n;
      case "curve": {
        const i = e.points;
        if (i.length === 0) return 1;
        if (i.length === 1) return i[0].value;
        let o = i[0], a = i[i.length - 1];
        for (let f = 0; f < i.length - 1; f++)
          if (n >= i[f].time && n <= i[f + 1].time) {
            o = i[f], a = i[f + 1];
            break;
          }
        const r = (n - o.time) / (a.time - o.time), l = r * r, c = l * r, u = 2 * c - 3 * l + 1, d = -2 * c + 3 * l, h = c - 2 * l + r, p = c - l;
        return u * o.value + d * a.value + h * (o.outTangent ?? 0) + p * (a.inTangent ?? 0);
      }
      case "random":
        return e.min + this.rng() * (e.max - e.min);
      case "randomCurve": {
        const i = this.evaluateModulationCurve(e.minCurve, n), o = this.evaluateModulationCurve(e.maxCurve, n);
        return i + this.rng() * (o - i);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(e, n) {
    if (e.length === 0) return [1, 1, 1, 1];
    if (e.length === 1) return e[0].color;
    let i = e[0], o = e[e.length - 1];
    for (let r = 0; r < e.length - 1; r++)
      if (n >= e[r].time && n <= e[r + 1].time) {
        i = e[r], o = e[r + 1];
        break;
      }
    const a = (n - i.time) / (o.time - i.time);
    return [
      i.color[0] + (o.color[0] - i.color[0]) * a,
      i.color[1] + (o.color[1] - i.color[1]) * a,
      i.color[2] + (o.color[2] - i.color[2]) * a,
      i.color[3] + (o.color[3] - i.color[3]) * a
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const e = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]), n = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new Vm(), this.instancedGeometry.setAttribute("position", new Vi(e, 2)), this.instancedGeometry.setAttribute("uv", new Vi(n, 2));
    const i = new eo(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), o = new eo(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), a = new eo(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), r = new eo(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), l = new eo(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), c = new eo(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    i.setUsage(Ao), o.setUsage(Ao), a.setUsage(Ao), r.setUsage(Ao), l.setUsage(Ao), c.setUsage(Ao), this.instancedGeometry.setAttribute("i_position", i), this.instancedGeometry.setAttribute("i_velocity", o), this.instancedGeometry.setAttribute("i_life", a), this.instancedGeometry.setAttribute("i_physical", r), this.instancedGeometry.setAttribute("i_rotation", l), this.instancedGeometry.setAttribute("i_color", c), this.material = new dn({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: this.createUniforms(),
      transparent: !0,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    }), this.particleMesh = new Ke(this.instancedGeometry, this.material), this.particleMesh.frustumCulled = !1;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    this.emitters.set(e.id, {
      ...e,
      accumulator: 0,
      velocity: new pe()
    }), this.state.activeEmitters = this.emitters.size;
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.state.activeEmitters = this.emitters.size;
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(e) {
    this.forceFields.set(e.id, e);
  }
  updateForceField(e, n) {
    const i = this.forceFields.get(e);
    i && Object.assign(i, n);
  }
  removeForceField(e) {
    this.forceFields.delete(e);
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(e) {
    this.subEmitters.set(e.id, e);
  }
  removeSubEmitter(e) {
    this.subEmitters.delete(e);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(e) {
    var o;
    const n = performance.now(), i = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : e * this.config.timeScale;
    this.emitParticles(i), this.useGPUPhysics && this.gl ? this.updatePhysicsGPU(i) : this.updatePhysics(i), this.processSubEmitters(), (o = this.config.flocking) != null && o.enabled && (this.updateSpatialHash(), this.applyFlocking(i)), this.applyAudioModulation(), this.updateInstanceBuffers(), this.state.simulationTime += i, this.state.frameCount++, this.state.updateTimeMs = performance.now() - n;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(e) {
    for (const n of this.emitters.values()) {
      if (!n.enabled) continue;
      let i = n.emissionRate;
      const o = this.getAudioModulation("emitter", n.id, "emissionRate");
      if (o !== void 0 && (i *= o), n.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const a = Math.floor(n.burstCount * n.beatEmissionMultiplier);
        for (let r = 0; r < a; r++)
          this.spawnParticle(n);
      }
      for (n.accumulator += i * e; n.accumulator >= 1; )
        this.spawnParticle(n), n.accumulator -= 1;
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(e) {
    if (this.freeIndices.length === 0) {
      let d = 0, h = 0;
      const p = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let f = 0; f < this.config.maxParticles; f++) {
        const m = p[f * is + 6];
        m > h && (h = m, d = f);
      }
      this.freeIndices.push(d);
    }
    const n = this.freeIndices.pop(), i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, o = n * is, a = this.getEmitterPosition(e), r = this.getEmissionDirection(e), l = e.initialSpeed + (this.rng() - 0.5) * 2 * e.speedVariance, c = e.velocity.clone().multiplyScalar(e.inheritEmitterVelocity);
    i[o + 0] = a.x, i[o + 1] = a.y, i[o + 2] = a.z, i[o + 3] = r.x * l + c.x, i[o + 4] = r.y * l + c.y, i[o + 5] = r.z * l + c.z, i[o + 6] = 0, i[o + 7] = e.lifetime + (this.rng() - 0.5) * 2 * e.lifetimeVariance, i[o + 8] = e.initialMass + (this.rng() - 0.5) * 2 * e.massVariance, i[o + 9] = e.initialSize + (this.rng() - 0.5) * 2 * e.sizeVariance, i[o + 10] = e.initialRotation + this.rng() * e.rotationVariance, i[o + 11] = e.initialAngularVelocity + (this.rng() - 0.5) * 2 * e.angularVelocityVariance;
    const u = this.rng() * e.colorVariance;
    return i[o + 12] = e.colorStart[0] + (e.colorEnd[0] - e.colorStart[0]) * u, i[o + 13] = e.colorStart[1] + (e.colorEnd[1] - e.colorStart[1]) * u, i[o + 14] = e.colorStart[2] + (e.colorEnd[2] - e.colorStart[2]) * u, i[o + 15] = e.colorStart[3], this.state.particleCount++, this.emit("particleBirth", { index: n, emitterId: e.id }), n;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(e) {
    const n = e.shape, i = new pe(e.position.x, e.position.y, e.position.z);
    switch (n.type) {
      case "point":
        return i;
      case "circle": {
        const o = this.rng() * Math.PI * 2;
        let a = n.radius ?? 50;
        return n.emitFromEdge || (a *= Math.sqrt(this.rng())), i.add(new pe(
          Math.cos(o) * a,
          Math.sin(o) * a,
          0
        ));
      }
      case "sphere": {
        const o = this.rng() * Math.PI * 2, a = Math.acos(2 * this.rng() - 1);
        let r = n.radius ?? 50;
        return n.emitFromEdge || (r *= Math.cbrt(this.rng())), i.add(new pe(
          Math.sin(a) * Math.cos(o) * r,
          Math.sin(a) * Math.sin(o) * r,
          Math.cos(a) * r
        ));
      }
      case "box": {
        const o = n.boxSize ?? { x: 100, y: 100, z: 100 };
        return i.add(new pe(
          (this.rng() - 0.5) * o.x,
          (this.rng() - 0.5) * o.y,
          (this.rng() - 0.5) * o.z
        ));
      }
      case "line": {
        const o = n.lineStart ?? { x: -50, y: 0, z: 0 }, a = n.lineEnd ?? { x: 50, y: 0, z: 0 }, r = this.rng();
        return i.add(new pe(
          o.x + (a.x - o.x) * r,
          o.y + (a.y - o.y) * r,
          o.z + (a.z - o.z) * r
        ));
      }
      case "cone": {
        const o = this.rng() * Math.PI * 2, a = this.rng(), r = a * (n.coneRadius ?? 50), l = a * (n.coneLength ?? 100);
        return i.add(new pe(
          Math.cos(o) * r,
          l,
          Math.sin(o) * r
        ));
      }
      case "image": {
        if (!n.imageData) return i;
        const { width: o, height: a, data: r } = n.imageData, l = n.emissionThreshold ?? 0.1;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * o), d = Math.floor(this.rng() * a), h = (d * o + u) * 4;
          if (r[h + 3] / 255 > l)
            return i.add(new pe(
              u - o / 2,
              -(d - a / 2),
              // Flip Y for screen coords
              0
            ));
        }
        return i;
      }
      case "depthEdge": {
        if (!n.depthData || !n.imageData) return i;
        const { width: o, height: a } = n.imageData, r = n.depthData, l = n.emissionThreshold ?? 0.05;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * (o - 2)) + 1, d = Math.floor(this.rng() * (a - 2)) + 1, h = d * o + u, p = r[h], f = r[h - 1], m = r[h + 1], y = r[h - o], g = r[h + o], x = Math.abs(m - f), w = Math.abs(g - y);
          if (Math.sqrt(x * x + w * w) > l) {
            const _ = p * 500;
            return i.add(new pe(
              u - o / 2,
              -(d - a / 2),
              // Flip Y for screen coords
              _
            ));
          }
        }
        return i;
      }
      default:
        return i;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(e) {
    const n = new pe(
      e.emissionDirection.x,
      e.emissionDirection.y,
      e.emissionDirection.z
    ).normalize();
    if (e.emissionSpread <= 0)
      return n;
    const i = e.emissionSpread * Math.PI / 180, o = this.rng() * Math.PI * 2, a = Math.acos(1 - this.rng() * (1 - Math.cos(i))), r = Math.abs(n.y) < 0.99 ? new pe(0, 1, 0) : new pe(1, 0, 0), l = new pe().crossVectors(r, n).normalize(), c = new pe().crossVectors(n, l);
    return new pe().addScaledVector(n, Math.cos(a)).addScaledVector(l, Math.sin(a) * Math.cos(o)).addScaledVector(c, Math.sin(a) * Math.sin(o)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(e) {
    const n = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const o = i * is, a = n[o + 6], r = n[o + 7];
      if (r <= 0 || a >= r) continue;
      let l = n[o + 0], c = n[o + 1], u = n[o + 2], d = n[o + 3], h = n[o + 4], p = n[o + 5];
      const f = n[o + 8];
      let m = 0, y = 0, g = 0;
      for (const E of this.forceFields.values()) {
        if (!E.enabled) continue;
        const b = this.calculateForceField(E, l, c, u, d, h, p, f);
        m += b.x, y += b.y, g += b.z;
      }
      const x = m / Math.max(f, 0.1), w = y / Math.max(f, 0.1), M = g / Math.max(f, 0.1);
      d += x * e, h += w * e, p += M * e, l += d * e, c += h * e, u += p * e;
      const _ = a / r, C = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        _
      ), T = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        _
      ), P = n[o + 10] + n[o + 11] * e;
      n[o + 0] = l, n[o + 1] = c, n[o + 2] = u, n[o + 3] = d, n[o + 4] = h, n[o + 5] = p, n[o + 6] = a + e, n[o + 9] *= C, n[o + 10] = P, n[o + 15] *= T, a + e >= r && (this.freeIndices.push(i), this.state.particleCount--, this.emit("particleDeath", { index: i }));
    }
  }
  /**
   * Update particle physics using GPU Transform Feedback
   * This runs the entire physics simulation on the GPU for maximum performance
   */
  updatePhysicsGPU(e) {
    var d;
    if (!this.gl || !this.transformFeedbackProgram) return;
    const n = this.gl;
    this.updateForceFieldTexture(), n.useProgram(this.transformFeedbackProgram);
    const i = n.getUniformLocation(this.transformFeedbackProgram, "u_deltaTime"), o = n.getUniformLocation(this.transformFeedbackProgram, "u_time"), a = n.getUniformLocation(this.transformFeedbackProgram, "u_forceFieldCount"), r = n.getUniformLocation(this.transformFeedbackProgram, "u_forceFields");
    if (n.uniform1f(i, e), n.uniform1f(o, this.state.simulationTime), n.uniform1i(a, Math.min(this.forceFields.size, Kl)), this.forceFieldTexture) {
      n.activeTexture(n.TEXTURE0);
      const h = (d = this.renderer) == null ? void 0 : d.properties.get(this.forceFieldTexture), p = h == null ? void 0 : h.__webglTexture;
      p && (n.bindTexture(n.TEXTURE_2D, p), n.uniform1i(r, 0));
    }
    const l = this.currentBuffer === "A" ? this.vaoA : this.vaoB, c = this.currentBuffer === "A" ? this.transformFeedbackA : this.transformFeedbackB, u = this.currentBuffer === "A" ? this.particleVboB : this.particleVboA;
    n.bindVertexArray(l), n.enable(n.RASTERIZER_DISCARD), n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, c), n.beginTransformFeedback(n.POINTS), n.drawArrays(n.POINTS, 0, this.config.maxParticles), n.endTransformFeedback(), n.bindTransformFeedback(n.TRANSFORM_FEEDBACK, null), n.disable(n.RASTERIZER_DISCARD), n.bindVertexArray(null), this.currentBuffer = this.currentBuffer === "A" ? "B" : "A", this.state.frameCount % 10 === 0 && this.readBackParticleData(u);
  }
  /**
   * Update the force field texture with current force field data
   */
  updateForceFieldTexture() {
    var n, i, o, a, r, l, c, u, d;
    if (!this.forceFieldBuffer || !this.forceFieldTexture) return;
    let e = 0;
    for (const h of this.forceFields.values()) {
      if (e >= Kl) break;
      if (!h.enabled) continue;
      const p = e * 16;
      this.forceFieldBuffer[p + 0] = h.position.x, this.forceFieldBuffer[p + 1] = h.position.y, this.forceFieldBuffer[p + 2] = h.position.z, this.forceFieldBuffer[p + 3] = this.getForceFieldTypeIndex(h.type), this.forceFieldBuffer[p + 4] = h.strength, this.forceFieldBuffer[p + 5] = h.falloffStart, this.forceFieldBuffer[p + 6] = h.falloffEnd, this.forceFieldBuffer[p + 7] = this.getFalloffTypeIndex(h.falloffType), this.forceFieldBuffer[p + 8] = ((n = h.direction) == null ? void 0 : n.x) ?? ((i = h.vortexAxis) == null ? void 0 : i.x) ?? ((o = h.windDirection) == null ? void 0 : o.x) ?? 0, this.forceFieldBuffer[p + 9] = ((a = h.direction) == null ? void 0 : a.y) ?? ((r = h.vortexAxis) == null ? void 0 : r.y) ?? ((l = h.windDirection) == null ? void 0 : l.y) ?? 0, this.forceFieldBuffer[p + 10] = ((c = h.direction) == null ? void 0 : c.z) ?? ((u = h.vortexAxis) == null ? void 0 : u.z) ?? ((d = h.windDirection) == null ? void 0 : d.z) ?? 0, this.forceFieldBuffer[p + 11] = h.inwardForce ?? 0, this.forceFieldBuffer[p + 12] = h.noiseScale ?? h.linearDrag ?? h.gustStrength ?? 0, this.forceFieldBuffer[p + 13] = h.noiseSpeed ?? h.quadraticDrag ?? h.gustFrequency ?? 0, this.forceFieldBuffer[p + 14] = 0, this.forceFieldBuffer[p + 15] = 0, e++;
    }
    this.forceFieldTexture.needsUpdate = !0;
  }
  /**
   * Get numeric index for force field type (for GPU shader)
   */
  getForceFieldTypeIndex(e) {
    switch (e) {
      case "gravity":
        return 0;
      case "point":
        return 1;
      case "vortex":
        return 2;
      case "turbulence":
        return 3;
      case "drag":
        return 4;
      case "wind":
        return 5;
      case "curl":
        return 6;
      case "magnetic":
        return 7;
      case "lorenz":
        return 8;
      default:
        return 0;
    }
  }
  /**
   * Get numeric index for falloff type (for GPU shader)
   */
  getFalloffTypeIndex(e) {
    switch (e) {
      case "none":
        return 0;
      case "linear":
        return 1;
      case "quadratic":
        return 2;
      case "exponential":
        return 3;
      case "smoothstep":
        return 4;
      default:
        return 0;
    }
  }
  /**
   * Read back particle data from GPU to CPU for death handling
   */
  readBackParticleData(e) {
    if (!this.gl || !e) return;
    const n = this.gl, i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    n.bindBuffer(n.ARRAY_BUFFER, e), n.getBufferSubData(n.ARRAY_BUFFER, 0, i), n.bindBuffer(n.ARRAY_BUFFER, null);
    let o = 0;
    for (let a = 0; a < this.config.maxParticles; a++) {
      const r = a * is, l = i[r + 6], c = i[r + 7];
      c > 0 && l < c ? o++ : c > 0 && l >= c && (this.freeIndices.includes(a) || (this.freeIndices.push(a), this.emit("particleDeath", { index: a })));
    }
    this.state.particleCount = o;
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(e, n, i, o, a, r, l, c) {
    var g, x, w, M, _, C, T, P, E;
    const u = new pe(), d = n - e.position.x, h = i - e.position.y, p = o - e.position.z, f = Math.sqrt(d * d + h * h + p * p);
    let m = 1;
    if (f > e.falloffStart) {
      const b = Math.min((f - e.falloffStart) / (e.falloffEnd - e.falloffStart), 1);
      switch (e.falloffType) {
        case "linear":
          m = 1 - b;
          break;
        case "quadratic":
          m = 1 - b * b;
          break;
        case "exponential":
          m = Math.exp(-b * 3);
          break;
        case "smoothstep":
          m = 1 - (3 * b * b - 2 * b * b * b);
          break;
      }
    }
    const y = e.strength * m;
    switch (e.type) {
      case "gravity":
        u.set(
          (((g = e.direction) == null ? void 0 : g.x) ?? 0) * y,
          (((x = e.direction) == null ? void 0 : x.y) ?? 1) * y,
          (((w = e.direction) == null ? void 0 : w.z) ?? 0) * y
        );
        break;
      case "point":
        if (f > 1e-3) {
          const b = new pe(-d, -h, -p).normalize();
          u.copy(b).multiplyScalar(y / c);
        }
        break;
      case "vortex":
        if (f > 1e-3) {
          const b = new pe(
            ((M = e.vortexAxis) == null ? void 0 : M.x) ?? 0,
            ((_ = e.vortexAxis) == null ? void 0 : _.y) ?? 0,
            ((C = e.vortexAxis) == null ? void 0 : C.z) ?? 1
          ).normalize(), S = new pe(d, h, p), A = new pe().crossVectors(b, S).normalize(), R = S.normalize().multiplyScalar(-(e.inwardForce ?? 0));
          u.copy(A).multiplyScalar(y).add(R);
        }
        break;
      case "turbulence": {
        const b = e.noiseScale ?? 0.01, S = e.noiseSpeed ?? 0.5, A = this.state.simulationTime * S, R = Math.sin(n * b + A) * Math.cos(i * b * 1.3) * y, k = Math.sin(i * b + A * 1.1) * Math.cos(o * b * 1.2) * y, U = Math.sin(o * b + A * 0.9) * Math.cos(n * b * 1.1) * y;
        u.set(R, k, U);
        break;
      }
      case "drag": {
        const b = Math.sqrt(a * a + r * r + l * l);
        if (b > 1e-3) {
          const S = (e.linearDrag ?? 0.1) * b + (e.quadraticDrag ?? 0.01) * b * b;
          u.set(-a, -r, -l).normalize().multiplyScalar(-S * y);
        }
        break;
      }
      case "wind": {
        const b = new pe(
          ((T = e.windDirection) == null ? void 0 : T.x) ?? 1,
          ((P = e.windDirection) == null ? void 0 : P.y) ?? 0,
          ((E = e.windDirection) == null ? void 0 : E.z) ?? 0
        ).normalize(), S = Math.sin(this.state.simulationTime * (e.gustFrequency ?? 0.5)) * (e.gustStrength ?? 0);
        u.copy(b).multiplyScalar(y + S);
        break;
      }
      case "lorenz": {
        const b = e.lorenzSigma ?? 10, S = e.lorenzRho ?? 28, A = e.lorenzBeta ?? 2.667;
        u.set(
          b * (h - d),
          d * (S - p) - h,
          d * h - A * p
        ).multiplyScalar(y * 0.01);
        break;
      }
    }
    return u;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const o = i * is;
      if (e[o + 7] <= 0) continue;
      const r = e[o + 0], l = e[o + 1], c = e[o + 2], u = Math.floor(r / n), d = Math.floor(l / n), h = Math.floor(c / n), p = `${u},${d},${h}`;
      this.spatialHash.has(p) || this.spatialHash.set(p, []), this.spatialHash.get(p).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(e) {
    const n = this.config.flocking;
    if (!(n != null && n.enabled)) return;
    const i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, o = this.config.spatialHashCellSize;
    for (let a = 0; a < this.config.maxParticles; a++) {
      const r = a * is;
      if (i[r + 7] <= 0) continue;
      const c = i[r + 0], u = i[r + 1], d = i[r + 2], h = Math.floor(c / o), p = Math.floor(u / o), f = Math.floor(d / o), m = new pe(), y = new pe(), g = new pe();
      let x = 0, w = 0, M = 0;
      for (let T = h - 1; T <= h + 1; T++)
        for (let P = p - 1; P <= p + 1; P++)
          for (let E = f - 1; E <= f + 1; E++) {
            const b = this.spatialHash.get(`${T},${P},${E}`);
            if (b)
              for (const S of b) {
                if (S === a) continue;
                const A = S * is, R = i[A + 0], k = i[A + 1], U = i[A + 2], I = c - R, W = u - k, fe = d - U, q = Math.sqrt(I * I + W * W + fe * fe);
                q < n.separationRadius && q > 0 && (m.add(new pe(I, W, fe).divideScalar(q)), x++), q < n.alignmentRadius && (y.add(new pe(
                  i[A + 3],
                  i[A + 4],
                  i[A + 5]
                )), w++), q < n.cohesionRadius && (g.add(new pe(R, k, U)), M++);
              }
          }
      x > 0 && m.divideScalar(x).normalize().multiplyScalar(n.separationWeight), w > 0 && y.divideScalar(w).normalize().multiplyScalar(n.alignmentWeight), M > 0 && (g.divideScalar(M), g.sub(new pe(c, u, d)).normalize().multiplyScalar(n.cohesionWeight));
      const _ = m.add(y).add(g);
      _.length() > n.maxForce && _.normalize().multiplyScalar(n.maxForce), i[r + 3] += _.x * e, i[r + 4] += _.y * e, i[r + 5] += _.z * e;
      const C = Math.sqrt(
        i[r + 3] ** 2 + i[r + 4] ** 2 + i[r + 5] ** 2
      );
      if (C > n.maxSpeed) {
        const T = n.maxSpeed / C;
        i[r + 3] *= T, i[r + 4] *= T, i[r + 5] *= T;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const e of this.config.audioBindings) {
      const o = ((this.audioFeatures.get(e.feature) ?? 0) - e.min) / (e.max - e.min);
      let a = e.outputMin + o * (e.outputMax - e.outputMin);
      if (e.curve === "exponential" ? a = e.outputMin + Math.pow(o, 2) * (e.outputMax - e.outputMin) : e.curve === "logarithmic" && (a = e.outputMin + Math.sqrt(o) * (e.outputMax - e.outputMin)), e.target === "emitter") {
        const r = this.emitters.get(e.targetId);
        r && (r[e.parameter] = a);
      } else if (e.target === "forceField") {
        const r = this.forceFields.get(e.targetId);
        r && (r[e.parameter] = a);
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(e, n, i) {
    for (const o of this.config.audioBindings)
      if (o.target === e && o.targetId === n && o.parameter === i) {
        const r = ((this.audioFeatures.get(o.feature) ?? 0) - o.min) / (o.max - o.min);
        return o.outputMin + r * (o.outputMax - o.outputMin);
      }
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.instancedGeometry.getAttribute("i_position"), i = this.instancedGeometry.getAttribute("i_velocity"), o = this.instancedGeometry.getAttribute("i_life"), a = this.instancedGeometry.getAttribute("i_physical"), r = this.instancedGeometry.getAttribute("i_rotation"), l = this.instancedGeometry.getAttribute("i_color");
    for (let c = 0; c < this.config.maxParticles; c++) {
      const u = c * is;
      n.setXYZ(c, e[u + 0], e[u + 1], e[u + 2]), i.setXYZ(c, e[u + 3], e[u + 4], e[u + 5]), o.setXY(c, e[u + 6], e[u + 7]), a.setXY(c, e[u + 8], e[u + 9]), r.setXY(c, e[u + 10], e[u + 11]), l.setXYZW(c, e[u + 12], e[u + 13], e[u + 14], e[u + 15]);
    }
    n.needsUpdate = !0, i.needsUpdate = !0, o.needsUpdate = !0, a.needsUpdate = !0, r.needsUpdate = !0, l.needsUpdate = !0;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(e, n) {
    this.audioFeatures.set(e, n), this.state.currentAudioFeatures.set(e, n);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1), requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(e) {
    if (e) {
      const n = this.emitters.get(e);
      if (n)
        for (let i = 0; i < n.burstCount; i++)
          this.spawnParticle(n);
    } else
      for (const n of this.emitters.values())
        if (n.burstOnBeat && n.enabled)
          for (let i = 0; i < n.burstCount; i++)
            this.spawnParticle(n);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Get vertex shader code
   */
  getVertexShader() {
    return `
      precision highp float;

      attribute vec2 position;
      attribute vec2 uv;

      attribute vec3 i_position;
      attribute vec3 i_velocity;
      attribute vec2 i_life;
      attribute vec2 i_physical;
      attribute vec2 i_rotation;
      attribute vec4 i_color;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform vec3 cameraPosition;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      void main() {
        // Skip dead particles
        if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
          gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
          return;
        }

        float size = i_physical.y;
        float rotation = i_rotation.x;
        float lifeRatio = i_life.x / i_life.y;

        // Billboard facing camera
        vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
        vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

        // Apply rotation
        float cosR = cos(rotation);
        float sinR = sin(rotation);
        vec2 rotatedPos = vec2(
          position.x * cosR - position.y * sinR,
          position.x * sinR + position.y * cosR
        );

        vec3 vertexPos = i_position
          + cameraRight * rotatedPos.x * size
          + cameraUp * rotatedPos.y * size;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);

        vUv = uv;
        vColor = i_color;
        vLifeRatio = lifeRatio;
      }
    `;
  }
  /**
   * Get fragment shader code
   */
  getFragmentShader() {
    return `
      precision highp float;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      uniform sampler2D diffuseMap;
      uniform int hasDiffuseMap;
      uniform int proceduralShape;

      float proceduralAlpha(vec2 uv, int shape) {
        vec2 centered = uv * 2.0 - 1.0;
        float dist = length(centered);

        if (shape == 1) {
          return 1.0 - smoothstep(0.8, 1.0, dist);
        } else if (shape == 2) {
          return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
        }

        return 1.0;
      }

      void main() {
        vec4 texColor = vec4(1.0);

        if (hasDiffuseMap == 1) {
          texColor = texture2D(diffuseMap, vUv);
        } else if (proceduralShape > 0) {
          float alpha = proceduralAlpha(vUv, proceduralShape);
          texColor = vec4(1.0, 1.0, 1.0, alpha);
        }

        vec4 finalColor = texColor * vColor;

        if (finalColor.a < 0.01) discard;

        gl_FragColor = finalColor;
      }
    `;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return ha;
      case "multiply":
        return ra;
      case "screen":
        return E0;
      default:
        return rs;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var o;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (o = this.eventHandlers.get(e)) == null || o.forEach((a) => a(i));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   */
  createSeededRandom(e) {
    let n = e;
    return () => (n = n * 1103515245 + 12345 & 2147483647, n / 2147483647);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Get current configuration (emitters and force fields)
   */
  getConfig() {
    return {
      emitters: Array.from(this.emitters.values()).map((n) => {
        const { accumulator: i, velocity: o, ...a } = n;
        return a;
      }),
      forceFields: Array.from(this.forceFields.values())
    };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets RNG to initial seed for reproducible simulation
   */
  reset() {
    this.particleBufferA.fill(0), this.particleBufferB.fill(0), this.freeIndices = [];
    for (let e = this.config.maxParticles - 1; e >= 0; e--)
      this.freeIndices.push(e);
    this.state.particleCount = 0, this.state.simulationTime = 0, this.state.frameCount = 0, this.spatialHash.clear(), this.rng = this.createSeededRandom(this.config.randomSeed ?? 12345);
  }
  /**
   * Get the current seed
   */
  getSeed() {
    return this.config.randomSeed ?? 12345;
  }
  /**
   * Set a new seed and reset the system
   * DETERMINISM: Used to ensure layer-specific reproducible seeds
   */
  setSeed(e) {
    this.config.randomSeed = e, this.reset();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    var e, n, i, o, a;
    (e = this.instancedGeometry) == null || e.dispose(), (n = this.material) == null || n.dispose(), (i = this.sizeOverLifetimeTexture) == null || i.dispose(), (o = this.opacityOverLifetimeTexture) == null || o.dispose(), (a = this.colorOverLifetimeTexture) == null || a.dispose(), this.cleanupGPUPhysics(), this.emitters.clear(), this.forceFields.clear(), this.subEmitters.clear(), this.eventHandlers.clear();
  }
}
class FN extends $i {
  constructor(n) {
    super(n);
    /** The GPU particle system instance */
    le(this, "particleSystem");
    /** Particle system configuration */
    le(this, "systemConfig");
    /** Whether the system has been initialized with a renderer */
    le(this, "initialized", !1);
    /** Stored renderer reference for reinitialization */
    le(this, "rendererRef", null);
    /** Composition FPS for time calculation */
    le(this, "fps", 60);
    /** Deterministic seed derived from layer ID */
    le(this, "layerSeed");
    /** Last evaluated frame (for scrub detection) */
    le(this, "lastEvaluatedFrame", -1);
    /** Performance stats */
    le(this, "stats", {
      particleCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0
    });
    this.layerSeed = this.generateSeedFromId(n.id), this.systemConfig = this.buildSystemConfig(n), this.systemConfig.randomSeed = this.layerSeed, this.particleSystem = new s9(this.systemConfig), this.initializeBlendMode();
  }
  /**
   * Generate deterministic seed from layer ID
   * DETERMINISM: Same layer ID always produces identical seed
   */
  generateSeedFromId(n) {
    let i = 0;
    for (let o = 0; o < n.length; o++) {
      const a = n.charCodeAt(o);
      i = (i << 5) - i + a, i = i & i;
    }
    return Math.abs(i) || 12345;
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(n) {
    const i = n.data, o = u5();
    if (!i)
      return o.emitters = [i9("default")], o;
    if (i.systemConfig) {
      if (o.maxParticles = i.systemConfig.maxParticles ?? 1e5, o.timeScale = 1, i.systemConfig.gravity !== 0 && o.forceFields.push({
        id: "global_gravity",
        name: "Gravity",
        type: "gravity",
        enabled: !0,
        strength: i.systemConfig.gravity * 10,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        direction: { x: 0, y: 1, z: 0 }
      }), i.systemConfig.windStrength !== 0) {
        const a = (i.systemConfig.windDirection ?? 0) * Math.PI / 180;
        o.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: !0,
          strength: i.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(a),
            y: Math.sin(a),
            z: 0
          },
          gustStrength: i.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (i.systemConfig.friction > 0 && o.forceFields.push({
        id: "global_drag",
        name: "Friction",
        type: "drag",
        enabled: !0,
        strength: 1,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        linearDrag: i.systemConfig.friction,
        quadraticDrag: i.systemConfig.friction * 0.1
      }), i.systemConfig.turbulenceFields)
        for (const a of i.systemConfig.turbulenceFields)
          a.enabled && o.forceFields.push({
            id: a.id,
            name: "Turbulence",
            type: "turbulence",
            enabled: !0,
            strength: a.strength,
            position: { x: 0, y: 0, z: 0 },
            falloffStart: 0,
            falloffEnd: 1e4,
            falloffType: "none",
            noiseScale: a.scale,
            noiseSpeed: a.evolutionSpeed,
            noiseOctaves: 3,
            noiseLacunarity: 2,
            noiseGain: 0.5
          });
    }
    if (i.emitters)
      for (const a of i.emitters) {
        if (!a.enabled) continue;
        const r = (a.direction ?? 0) * Math.PI / 180, l = {
          id: a.id,
          name: a.name,
          enabled: !0,
          position: { x: a.x, y: a.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: a.emissionRate,
          emissionRateVariance: 0,
          burstCount: a.burstCount,
          burstInterval: 0,
          initialSpeed: a.speed,
          speedVariance: a.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: a.size,
          sizeVariance: a.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: a.particleLifetime,
          lifetimeVariance: a.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            a.color[0] / 255,
            a.color[1] / 255,
            a.color[2] / 255,
            1
          ],
          colorEnd: [
            a.color[0] / 255,
            a.color[1] / 255,
            a.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(r),
            y: Math.sin(r),
            z: 0
          },
          emissionSpread: a.spread,
          burstOnBeat: a.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        o.emitters.push(l);
      }
    if (i.gravityWells)
      for (const a of i.gravityWells)
        a.enabled && o.forceFields.push({
          id: a.id,
          name: a.name,
          type: "point",
          enabled: !0,
          strength: a.strength,
          position: { x: a.x, y: a.y, z: 0 },
          falloffStart: 0,
          falloffEnd: a.radius,
          falloffType: a.falloff === "linear" ? "linear" : a.falloff === "quadratic" ? "quadratic" : "none"
        });
    if (i.vortices)
      for (const a of i.vortices)
        a.enabled && o.forceFields.push({
          id: a.id,
          name: a.name,
          type: "vortex",
          enabled: !0,
          strength: a.strength * a.rotationSpeed,
          position: { x: a.x, y: a.y, z: 0 },
          falloffStart: 0,
          falloffEnd: a.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: a.inwardPull
        });
    if (i.modulations) {
      const a = i.modulations.filter((l) => l.property === "size");
      if (a.length > 0) {
        const l = a[0];
        o.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
      const r = i.modulations.filter((l) => l.property === "opacity");
      if (r.length > 0) {
        const l = r[0];
        o.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
    }
    return i.renderOptions && (o.render.blendMode = i.renderOptions.blendMode ?? "normal", o.render.motionBlur = i.renderOptions.motionBlur ?? !1, o.render.motionBlurStrength = i.renderOptions.motionBlurStrength ?? 0.5, o.render.motionBlurSamples = i.renderOptions.motionBlurSamples ?? 4, i.renderOptions.renderTrails && (o.render.mode = "trail", o.render.trailLength = i.renderOptions.trailLength, o.render.trailWidthEnd = 1 - (i.renderOptions.trailOpacityFalloff ?? 0.8)), o.render.texture.proceduralType = i.renderOptions.particleShape === "star" ? "star" : i.renderOptions.particleShape === "square" ? "square" : "circle"), o;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(n) {
    if (this.initialized) return;
    this.rendererRef = n, this.particleSystem.initialize(n), this.initialized = !0;
    const i = this.particleSystem.getMesh();
    i && this.group.add(i);
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(n) {
    this.rendererRef = n, this.initialized || this.initializeWithRenderer(n);
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.fps = n;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(n) {
    const i = i9();
    return n && Object.assign(i, n), this.particleSystem.addEmitter(i), i.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(n, i) {
    this.particleSystem.updateEmitter(n, i);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(n) {
    this.particleSystem.removeEmitter(n);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(n, i) {
    const o = LN(n);
    return i && Object.assign(o, i), this.particleSystem.addForceField(o), o.id;
  }
  /**
   * Update a force field
   */
  updateForceField(n, i) {
    this.particleSystem.updateForceField(n, i);
  }
  /**
   * Remove a force field
   */
  removeForceField(n) {
    this.particleSystem.removeForceField(n);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(n, i) {
    this.particleSystem.setAudioFeature(n, i);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(n) {
    this.particleSystem.triggerBurst(n);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(n) {
    if (!this.initialized) return;
    this.particleSystem.step(n);
    const i = this.particleSystem.getState();
    this.stats.particleCount = i.particleCount, this.stats.updateTimeMs = i.updateTimeMs, this.stats.renderTimeMs = i.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   * DETERMINISM: Resets to initial state with original seed
   */
  reset() {
    this.particleSystem.reset(), this.lastEvaluatedFrame = -1;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    const i = n === this.lastEvaluatedFrame + 1;
    if (!i && n !== this.lastEvaluatedFrame) {
      this.particleSystem.reset();
      const r = 1 / this.fps;
      for (let l = 0; l < n; l++)
        this.particleSystem.step(r);
    } else if (i) {
      const r = 1 / this.fps;
      this.particleSystem.step(r);
    }
    this.lastEvaluatedFrame = n, this.applyAudioReactivity();
    const a = this.particleSystem.getState();
    this.stats.particleCount = a.particleCount, this.stats.updateTimeMs = a.updateTimeMs, this.stats.renderTimeMs = a.renderTimeMs;
  }
  onApplyEvaluatedState(n) {
    this.applyAudioReactivity();
  }
  /**
   * Evaluate particles at a specific frame (scrub-safe)
   * DETERMINISM: Returns identical results regardless of evaluation order
   */
  evaluateAtFrame(n) {
    this.particleSystem.reset();
    const i = 1 / this.fps;
    for (let o = 0; o < n; o++)
      this.particleSystem.step(i);
    this.lastEvaluatedFrame = n;
  }
  /**
   * Apply audio-reactive values to particle system emitters and force fields
   */
  applyAudioReactivity() {
    const n = this.getAudioReactiveValue("particle.emissionRate"), i = this.getAudioReactiveValue("particle.speed"), o = this.getAudioReactiveValue("particle.size"), a = this.getAudioReactiveValue("particle.gravity"), r = this.getAudioReactiveValue("particle.windStrength");
    if (n !== 0 && this.particleSystem.setAudioFeature("amplitude", n), i !== 0 || o !== 0 || n !== 0) {
      const l = this.particleSystem.getConfig().emitters;
      for (const c of l)
        i !== 0 && this.particleSystem.updateEmitter(c.id, {
          initialSpeed: c.initialSpeed * (0.5 + i)
        }), o !== 0 && this.particleSystem.updateEmitter(c.id, {
          initialSize: c.initialSize * (0.5 + o)
        });
    }
    if (a !== 0 || r !== 0) {
      const l = this.particleSystem.getConfig().forceFields;
      for (const c of l)
        c.type === "gravity" && a !== 0 && this.particleSystem.updateForceField(c.id, {
          strength: c.strength * (0.5 + a)
        }), c.type === "wind" && r !== 0 && this.particleSystem.updateForceField(c.id, {
          strength: c.strength * (0.5 + r)
        });
    }
  }
  onUpdate(n) {
    if (n.data) {
      const o = this.particleSystem.getMesh();
      o && this.group.remove(o), this.systemConfig = this.buildSystemConfig({
        ...n,
        id: this.id,
        type: "particles"
      }), this.systemConfig.randomSeed = this.layerSeed, this.particleSystem.dispose(), this.particleSystem = new s9(this.systemConfig), this.lastEvaluatedFrame = -1, this.rendererRef && (this.initialized = !1, this.initializeWithRenderer(this.rendererRef));
    }
  }
  onDispose() {
    this.particleSystem.dispose();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}
class ON extends $i {
  constructor(n) {
    super(n);
    // Precomp data
    le(this, "precompData");
    // Render context (provided by LayerManager)
    le(this, "renderContext", null);
    // Display mesh
    le(this, "mesh", null);
    le(this, "material", null);
    // Cached render texture
    le(this, "renderTexture", null);
    // Animation evaluator for time remap
    le(this, "precompEvaluator");
    // Cached composition reference
    le(this, "cachedComposition", null);
    // Parent composition FPS for frame rate conversion
    le(this, "parentFPS", 30);
    this.precompEvaluator = new Ta(), this.precompData = this.extractPrecompData(n), this.createMesh(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract precomp data with defaults
   */
  extractPrecompData(n) {
    const i = n.data;
    return {
      compositionId: (i == null ? void 0 : i.compositionId) ?? "",
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      collapseTransformations: (i == null ? void 0 : i.collapseTransformations) ?? !1,
      overrideFrameRate: (i == null ? void 0 : i.overrideFrameRate) ?? !1,
      frameRate: i == null ? void 0 : i.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const n = new nn(1, 1);
    this.material = new _n({
      color: 4473924,
      transparent: !0,
      side: mn
    }), this.mesh = new Ke(n, this.material), this.mesh.name = `precomp_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for precomp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(n) {
    this.renderContext = n, this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(n) {
    this.parentFPS = n;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    !this.renderContext || !this.precompData.compositionId || (this.cachedComposition = this.renderContext.getComposition(
      this.precompData.compositionId
    ), this.cachedComposition && this.resizeMesh(
      this.cachedComposition.settings.width,
      this.cachedComposition.settings.height
    ));
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new nn(n, i));
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(n) {
    if (!this.cachedComposition) return 0;
    if (this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      const i = this.precompData.timeRemap.animated ? this.precompEvaluator.evaluate(this.precompData.timeRemap, n) : this.precompData.timeRemap.value, o = this.precompData.overrideFrameRate && this.precompData.frameRate ? this.precompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(i * o);
    }
    if (this.precompData.overrideFrameRate && this.precompData.frameRate) {
      const i = this.parentFPS, o = this.precompData.frameRate;
      return Math.floor(n * (o / i));
    }
    return n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    if (!this.renderContext || !this.cachedComposition)
      return;
    const i = this.calculateNestedFrame(n), o = Math.max(
      0,
      Math.min(i, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.precompData.compositionId,
      o
    ), this.material && (this.renderTexture ? (this.material.map = this.renderTexture, this.material.color.setHex(16777215)) : (this.material.map = null, this.material.color.setHex(4473924)), this.material.needsUpdate = !0);
  }
  onApplyEvaluatedState(n) {
    const i = n.properties;
    i.timeRemap !== void 0 && this.precompData.timeRemapEnabled && this.precompData.timeRemap && (this.precompData.timeRemap.value = i.timeRemap);
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(n) {
    this.precompData.compositionId = n, this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(n) {
    this.precompData.timeRemapEnabled = n;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(n) {
    this.precompData.timeRemap = n;
  }
  /**
   * Enable/disable collapse transformations
   */
  setCollapseTransformations(n) {
    this.precompData.collapseTransformations = n;
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(n, i) {
    this.precompData.overrideFrameRate = n, this.precompData.frameRate = i;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.compositionId !== void 0 && this.setComposition(i.compositionId), i.timeRemapEnabled !== void 0 && this.setTimeRemapEnabled(i.timeRemapEnabled), i.timeRemap !== void 0 && this.setTimeRemap(i.timeRemap), i.collapseTransformations !== void 0 && this.setCollapseTransformations(i.collapseTransformations), (i.overrideFrameRate !== void 0 || i.frameRate !== void 0) && this.setFrameRateOverride(
      i.overrideFrameRate ?? this.precompData.overrideFrameRate,
      i.frameRate ?? this.precompData.frameRate
    ));
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get precomp data
   */
  getPrecompData() {
    return { ...this.precompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.precompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh)), this.renderTexture = null, this.cachedComposition = null;
  }
}
class UN extends $i {
  constructor(n) {
    super(n);
    // Camera data reference
    le(this, "cameraData");
    // Callbacks to store
    le(this, "cameraGetter");
    le(this, "cameraAtFrameGetter");
    le(this, "cameraUpdater");
    // Track current frame for interpolation
    le(this, "currentFrame", 0);
    // Visual wireframe (shown in editor)
    le(this, "wireframe", null);
    le(this, "wireframeVisible", !0);
    // Frustum visualization
    le(this, "frustumHelper", null);
    le(this, "showFrustum", !0);
    // Track last camera state for frustum updates
    le(this, "lastFrustumState", null);
    // Spline provider for path following
    le(this, "splineProvider", null);
    // Auto-advance parameter (for autoAdvance mode)
    le(this, "autoAdvanceT", 0);
    this.threeD = !0, this.cameraData = this.extractCameraData(n), this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(n) {
    const i = n.data;
    return {
      cameraId: (i == null ? void 0 : i.cameraId) ?? "",
      isActiveCamera: (i == null ? void 0 : i.isActiveCamera) ?? !1,
      pathFollowing: i == null ? void 0 : i.pathFollowing
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(n, i, o) {
    this.cameraGetter = n, this.cameraUpdater = i, this.cameraAtFrameGetter = o;
  }
  /**
   * Set the spline provider for path following
   */
  setSplineProvider(n) {
    this.splineProvider = n;
  }
  /**
   * Get path following configuration
   */
  getPathFollowing() {
    return this.cameraData.pathFollowing;
  }
  /**
   * Check if path following is active
   */
  isFollowingPath() {
    var n;
    return ((n = this.cameraData.pathFollowing) == null ? void 0 : n.enabled) ?? !1;
  }
  /**
   * Reset auto-advance parameter (for deterministic scrubbing)
   */
  resetAutoAdvance() {
    this.autoAdvanceT = 0;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Bi(), this.wireframe.name = `camera_wireframe_${this.id}`;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200, i = 40, o = new Mn(i, i * 0.6, i * 0.8), a = new _n({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), r = new Ke(o, a);
    this.wireframe.add(r);
    const l = new Uh(i * 0.3, i * 0.6, 8), c = new _n({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.6,
      depthTest: !1
    }), u = new Ke(l, c);
    u.rotation.x = Math.PI / 2, u.position.z = i * 0.7, this.wireframe.add(u);
    const d = new nn(i * 0.8, i * 0.5), h = new _n({
      color: n,
      transparent: !0,
      opacity: 0.2,
      side: mn,
      depthTest: !1
    }), p = new Ke(d, h);
    p.position.z = -i * 0.4, this.wireframe.add(p);
    const f = [
      new pe(0, i * 0.4, 0),
      new pe(0, i * 0.7, 0),
      new pe(-i * 0.1, i * 0.55, 0),
      new pe(0, i * 0.7, 0),
      new pe(i * 0.1, i * 0.55, 0)
    ], m = new Ut().setFromPoints(f), y = new Gi({
      color: 65280,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), g = new cn(m, y);
    this.wireframe.add(g), this.group.add(this.wireframe), this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const n = this.getCamera();
    if (!n) return;
    this.frustumHelper = new Bi(), this.frustumHelper.name = `camera_frustum_${this.id}`;
    const i = this.cameraData.isActiveCamera ? 43775 : 16755200, o = n.nearClip, a = Math.min(n.farClip, 2e3), r = n.angleOfView * (Math.PI / 180), l = 16 / 9, c = 2 * Math.tan(r / 2) * o, u = c * l, d = 2 * Math.tan(r / 2) * a, h = d * l, p = new Gi({
      color: i,
      transparent: !0,
      opacity: 0.3,
      depthTest: !1
    }), f = new pe(-u / 2, c / 2, o), m = new pe(u / 2, c / 2, o), y = new pe(-u / 2, -c / 2, o), g = new pe(u / 2, -c / 2, o), x = new pe(-h / 2, d / 2, a), w = new pe(h / 2, d / 2, a), M = new pe(-h / 2, -d / 2, a), _ = new pe(h / 2, -d / 2, a), C = new Ut().setFromPoints([
      f,
      m,
      g,
      y,
      f
    ]);
    this.frustumHelper.add(new cn(C, p));
    const T = new Ut().setFromPoints([
      x,
      w,
      _,
      M,
      x
    ]);
    this.frustumHelper.add(new cn(T, p));
    const P = [
      [f, x],
      [m, w],
      [y, M],
      [g, _]
    ];
    for (const [E, b] of P) {
      const S = new Ut().setFromPoints([E, b]);
      this.frustumHelper.add(new cn(S, p));
    }
    this.group.add(this.frustumHelper), this.frustumHelper.renderOrder = 997, this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((i) => {
      if (i instanceof Ke || i instanceof cn) {
        const o = i.material;
        if (o.color.getHex() === 65280) return;
        o.color.setHex(n);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    return !this.cameraGetter || !this.cameraData.cameraId ? null : this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    return this.cameraData.cameraId ? this.cameraAtFrameGetter ? this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame) : this.getCamera() : null;
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(n) {
    this.cameraData.isActiveCamera = n, this.updateWireframeColor(), this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum(), this.createFrustum());
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(n) {
    this.wireframeVisible = n, this.wireframe && (this.wireframe.visible = n);
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(n) {
    this.showFrustum = n, this.frustumHelper && (this.frustumHelper.visible = n);
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    this.currentFrame = n;
    const i = this.getCameraAtCurrentFrame();
    if (!i) return;
    const o = Math.PI / 180, a = this.cameraData.pathFollowing;
    if ((a == null ? void 0 : a.enabled) && a.pathLayerId && this.splineProvider && a)
      this.applyPathFollowing(n, a, i);
    else if (this.group.position.set(
      i.position.x,
      i.position.y,
      i.position.z
    ), i.type === "two-node" && i.pointOfInterest) {
      const u = new pe(
        i.pointOfInterest.x,
        i.pointOfInterest.y,
        i.pointOfInterest.z
      );
      this.group.lookAt(u), this.group.rotation.z += i.zRotation * o;
    } else
      this.group.rotation.set(
        (i.orientation.x + i.xRotation) * o,
        (i.orientation.y + i.yRotation) * o,
        (i.orientation.z + i.zRotation) * o,
        "YXZ"
        // Standard After Effects rotation order
      );
    const l = {
      fov: i.angleOfView,
      near: i.nearClip,
      far: i.farClip
    };
    (!this.lastFrustumState || this.lastFrustumState.fov !== l.fov || this.lastFrustumState.near !== l.near || this.lastFrustumState.far !== l.far) && (this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum(), this.lastFrustumState = l);
  }
  onApplyEvaluatedState(n) {
    var o;
    const i = n.properties;
    i.pathParameter !== void 0 && ((o = this.cameraData.pathFollowing) != null && o.enabled) && (this.cameraData.pathFollowing.parameter.value = i.pathParameter);
  }
  /**
   * Apply path following to camera position and orientation
   * DETERMINISM: Uses interpolateProperty for animated parameter
   */
  applyPathFollowing(n, i, o) {
    if (!this.splineProvider) return;
    let a;
    i.autoAdvance ? a = n * i.autoAdvanceSpeed % 1 : a = mt(i.parameter, n), a = Math.max(0, Math.min(1, a));
    const r = this.splineProvider(i.pathLayerId, a, n);
    if (!r) {
      this.group.position.set(o.position.x, o.position.y, o.position.z);
      return;
    }
    let l = null;
    if (i.alignToPath && i.lookAhead > 0) {
      const u = Math.min(1, a + i.lookAhead);
      l = this.splineProvider(i.pathLayerId, u, n);
    }
    const c = new pe(
      r.point.x,
      r.point.y + i.offsetY,
      r.point.z
    );
    if (this.group.position.copy(c), i.alignToPath) {
      if (l) {
        const u = new pe(
          l.point.x,
          l.point.y + i.offsetY,
          l.point.z
        );
        this.group.lookAt(u);
      } else {
        const u = new pe(
          r.tangent.x,
          r.tangent.y,
          0
        ).normalize(), d = new pe(0, 0, 1), h = new ni();
        h.setFromUnitVectors(d, u), this.group.quaternion.copy(h);
      }
      if (i.bankingStrength > 0) {
        const d = Math.max(0, a - 0.01), h = Math.min(1, a + 0.01), p = this.splineProvider(i.pathLayerId, d, n), f = this.splineProvider(i.pathLayerId, h, n);
        if (p && f) {
          const m = new qe(p.tangent.x, p.tangent.y).normalize(), y = new qe(f.tangent.x, f.tangent.y).normalize(), x = (m.x * y.y - m.y * y.x) * i.bankingStrength * Math.PI / 4;
          this.group.rotateZ(x);
        }
      }
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    var o;
    const i = n.data;
    i && (i.cameraId !== void 0 && (this.cameraData.cameraId = i.cameraId, this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum()), i.isActiveCamera !== void 0 && this.setActiveCamera(i.isActiveCamera), i.pathFollowing !== void 0 && (this.cameraData.pathFollowing = i.pathFollowing, (o = i.pathFollowing) != null && o.autoAdvance && (this.autoAdvanceT = 0)));
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const n = this.getCameraAtCurrentFrame();
    return n ? {
      position: { ...n.position },
      rotation: {
        x: n.orientation.x + n.xRotation,
        y: n.orientation.y + n.yRotation,
        z: n.orientation.z + n.zRotation
      },
      fov: n.angleOfView,
      focalLength: n.focalLength,
      nearClip: n.nearClip,
      farClip: n.farClip
    } : null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    this.wireframe && (this.wireframe.traverse((n) => {
      (n instanceof Ke || n instanceof cn) && (n.geometry.dispose(), n.material.dispose());
    }), this.wireframe.clear(), this.wireframe = null);
  }
  disposeFrustum() {
    this.frustumHelper && (this.frustumHelper.traverse((n) => {
      n instanceof cn && (n.geometry.dispose(), n.material.dispose());
    }), this.frustumHelper.clear(), this.frustumHelper = null);
  }
  onDispose() {
    this.disposeWireframe(), this.disposeFrustum();
  }
}
class zN extends cn {
  constructor(e, n) {
    const i = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Ut();
    o.setAttribute("position", new Pt(i, 3)), o.computeBoundingSphere();
    const a = new Gi({ fog: !1 });
    super(o, a), this.light = e, this.color = n, this.type = "RectAreaLightHelper";
    const r = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Ut();
    l.setAttribute("position", new Pt(r, 3)), l.computeBoundingSphere(), this.add(new Ke(l, new _n({ side: vi, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const e = this.material.color, n = Math.max(e.r, e.g, e.b);
      n > 1 && e.multiplyScalar(1 / n), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
class ba {
  static init() {
    const e = [1, 0, 0, 2e-5, 1, 0, 0, 503905e-9, 1, 0, 0, 201562e-8, 1, 0, 0, 453516e-8, 1, 0, 0, 806253e-8, 1, 0, 0, 0.0125978, 1, 0, 0, 0.018141, 1, 0, 0, 0.0246924, 1, 0, 0, 0.0322525, 1, 0, 0, 0.0408213, 1, 0, 0, 0.0503999, 1, 0, 0, 0.0609894, 1, 0, 0, 0.0725906, 1, 0, 0, 0.0852058, 1, 0, 0, 0.0988363, 1, 0, 0, 0.113484, 1, 0, 0, 0.129153, 1, 0, 0, 0.145839, 1, 0, 0, 0.163548, 1, 0, 0, 0.182266, 1, 0, 0, 0.201942, 1, 0, 0, 0.222314, 1, 0, 0, 0.241906, 1, 0, 0, 0.262314, 1, 0, 0, 0.285754, 1, 0, 0, 0.310159, 1, 0, 0, 0.335426, 1, 0, 0, 0.361341, 1, 0, 0, 0.387445, 1, 0, 0, 0.412784, 1, 0, 0, 0.438197, 1, 0, 0, 0.466966, 1, 0, 0, 0.49559, 1, 0, 0, 0.523448, 1, 0, 0, 0.549938, 1, 0, 0, 0.57979, 1, 0, 0, 0.608746, 1, 0, 0, 0.636185, 1, 0, 0, 0.664748, 1, 0, 0, 0.69313, 1, 0, 0, 0.71966, 1, 0, 0, 0.747662, 1, 0, 0, 0.774023, 1, 0, 0, 0.799775, 1, 0, 0, 0.825274, 1, 0, 0, 0.849156, 1, 0, 0, 0.873248, 1, 0, 0, 0.89532, 1, 0, 0, 0.917565, 1, 0, 0, 0.937863, 1, 0, 0, 0.958139, 1, 0, 0, 0.976563, 1, 0, 0, 0.994658, 1, 0, 0, 1.0112, 1, 0, 0, 1.02712, 1, 0, 0, 1.04189, 1, 0, 0, 1.05568, 1, 0, 0, 1.06877, 1, 0, 0, 1.08058, 1, 0, 0, 1.09194, 1, 0, 0, 1.10191, 1, 0, 0, 1.11161, 1, 0, 0, 1.1199, 1, 0, 0, 1.12813, 0.999547, -448815e-12, 0.0224417, 199902e-10, 0.999495, -113079e-10, 0.0224406, 503651e-9, 0.999496, -452317e-10, 0.0224406, 201461e-8, 0.999496, -101772e-9, 0.0224406, 453287e-8, 0.999495, -180928e-9, 0.0224406, 805845e-8, 0.999497, -282702e-9, 0.0224406, 0.0125914, 0.999496, -407096e-9, 0.0224406, 0.0181319, 0.999498, -554114e-9, 0.0224406, 0.02468, 0.999499, -723768e-9, 0.0224406, 0.0322363, 0.999495, -916058e-9, 0.0224405, 0.0408009, 0.999499, -113101e-8, 0.0224408, 0.050375, 0.999494, -136863e-8, 0.0224405, 0.0609586, 0.999489, -162896e-8, 0.0224401, 0.0725537, 0.999489, -191201e-8, 0.0224414, 0.0851619, 0.999498, -221787e-8, 0.0224413, 0.0987867, 0.999492, -254642e-8, 0.0224409, 0.113426, 0.999507, -289779e-8, 0.0224417, 0.129088, 0.999494, -32716e-7, 0.0224386, 0.145767, 0.999546, -36673e-7, 0.0224424, 0.163472, 0.999543, -408166e-8, 0.0224387, 0.182182, 0.999499, -450056e-8, 0.0224338, 0.201843, 0.999503, -483661e-8, 0.0224203, 0.222198, 0.999546, -452928e-8, 0.022315, 0.241714, 0.999508, -587403e-8, 0.0224329, 0.262184, 0.999509, -638806e-8, 0.0224271, 0.285609, 0.999501, -691028e-8, 0.0224166, 0.309998, 0.999539, -741979e-8, 0.0223989, 0.335262, 0.999454, -786282e-8, 0.0223675, 0.361154, 0.999529, -811928e-8, 0.0222828, 0.387224, 0.999503, -799941e-8, 0.0221063, 0.41252, 0.999561, -952753e-8, 0.0223057, 0.438006, 0.999557, -99134e-7, 0.0222065, 0.466735, 0.999541, -0.0100935, 0.0220402, 0.495332, 0.999562, -996821e-8, 0.0218067, 0.523197, 0.999556, -0.0105031, 0.0217096, 0.550223, 0.999561, -0.0114191, 0.0217215, 0.579498, 0.999588, -0.0111818, 0.0213357, 0.608416, 0.999633, -0.0107725, 0.0208689, 0.635965, 0.999527, -0.0121671, 0.0210149, 0.664476, 0.999508, -0.0116005, 0.020431, 0.692786, 0.999568, -0.0115604, 0.0199791, 0.719709, 0.999671, -0.0121117, 0.0197415, 0.74737, 0.999688, -0.0110769, 0.0188846, 0.773692, 0.99962, -0.0122368, 0.0188452, 0.799534, 0.999823, -0.0110325, 0.0178001, 0.825046, 0.999599, -0.0114923, 0.0174221, 0.849075, 0.999619, -0.0105923, 0.0164345, 0.872999, 0.999613, -0.0105988, 0.0158227, 0.895371, 0.99964, -979861e-8, 0.0148131, 0.917364, 0.99977, -967238e-8, 0.0140721, 0.938002, 0.999726, -869175e-8, 0.0129543, 0.957917, 0.99973, -866872e-8, 0.0122329, 0.976557, 0.999773, -731956e-8, 0.0108958, 0.994459, 0.999811, -756027e-8, 0.0102715, 1.01118, 0.999862, -583732e-8, 878781e-8, 1.02701, 0.999835, -631438e-8, 827529e-8, 1.04186, 0.999871, -450785e-8, 674583e-8, 1.05569, 0.999867, -486079e-8, 621041e-8, 1.06861, 0.999939, -322072e-8, 478301e-8, 1.08064, 0.999918, -318199e-8, 406395e-8, 1.09181, 1.00003, -193348e-8, 280682e-8, 1.10207, 0.999928, -153729e-8, 198741e-8, 1.11152, 0.999933, -623666e-9, 917714e-9, 1.12009, 1, -102387e-11, 907581e-12, 1.12813, 0.997866, -896716e-12, 0.0448334, 199584e-10, 0.997987, -225945e-10, 0.0448389, 502891e-9, 0.997987, -903781e-10, 0.0448388, 201156e-8, 0.997985, -203351e-9, 0.0448388, 452602e-8, 0.997986, -361514e-9, 0.0448388, 804629e-8, 0.997987, -56487e-8, 0.0448389, 0.0125724, 0.997988, -813423e-9, 0.0448389, 0.0181045, 0.997984, -110718e-8, 0.0448387, 0.0246427, 0.997985, -144616e-8, 0.0448388, 0.0321875, 0.997987, -183038e-8, 0.044839, 0.0407392, 0.997983, -225987e-8, 0.0448387, 0.0502986, 0.997991, -273467e-8, 0.0448389, 0.0608667, 0.997984, -325481e-8, 0.0448384, 0.0724444, 0.998002, -382043e-8, 0.044839, 0.0850348, 0.997997, -443145e-8, 0.0448396, 0.0986372, 0.998007, -508796e-8, 0.0448397, 0.113255, 0.998008, -578985e-8, 0.04484, 0.128891, 0.998003, -653683e-8, 0.0448384, 0.145548, 0.997983, -732713e-8, 0.0448358, 0.163221, 0.997985, -815454e-8, 0.0448358, 0.181899, 0.998005, -898985e-8, 0.0448286, 0.201533, 0.998026, -964404e-8, 0.0447934, 0.221821, 0.998055, -922677e-8, 0.044611, 0.241282, 0.99804, -0.0117361, 0.0448245, 0.261791, 0.998048, -0.0127628, 0.0448159, 0.285181, 0.998088, -0.0138055, 0.0447996, 0.30954, 0.998058, -0.0148206, 0.0447669, 0.334751, 0.998099, -0.0156998, 0.044697, 0.36061, 0.998116, -0.0161976, 0.0445122, 0.386603, 0.998195, -0.015945, 0.0441711, 0.411844, 0.998168, -0.0183947, 0.0444255, 0.43773, 0.998184, -0.0197913, 0.0443809, 0.466009, 0.998251, -0.0201426, 0.0440689, 0.494574, 0.998305, -0.0198847, 0.0435632, 0.522405, 0.998273, -0.0210577, 0.043414, 0.549967, 0.998254, -0.0227901, 0.0433943, 0.578655, 0.998349, -0.0223108, 0.0426529, 0.60758, 0.99843, -0.0223088, 0.042, 0.635524, 0.998373, -0.0241141, 0.0418987, 0.663621, 0.998425, -0.0231446, 0.0408118, 0.691906, 0.998504, -0.0233684, 0.0400565, 0.719339, 0.998443, -0.0241652, 0.0394634, 0.74643, 0.99848, -0.0228715, 0.0380002, 0.773086, 0.998569, -0.023519, 0.0372322, 0.798988, 0.998619, -0.0223108, 0.0356468, 0.824249, 0.998594, -0.0223105, 0.034523, 0.848808, 0.998622, -0.0213426, 0.0328887, 0.87227, 0.998669, -0.0207912, 0.0314374, 0.895157, 0.998705, -0.0198416, 0.0296925, 0.916769, 0.998786, -0.0189168, 0.0279634, 0.937773, 0.998888, -0.0178811, 0.0261597, 0.957431, 0.99906, -0.0166845, 0.0242159, 0.976495, 0.999038, -0.0155464, 0.0222638, 0.994169, 0.999237, -0.0141349, 0.0201967, 1.01112, 0.999378, -0.0129324, 0.0181744, 1.02692, 0.999433, -0.0113192, 0.0159898, 1.04174, 0.999439, -0.0101244, 0.0140385, 1.05559, 0.999614, -837456e-8, 0.0117826, 1.06852, 0.999722, -721769e-8, 983745e-8, 1.08069, 0.999817, -554067e-8, 769002e-8, 1.09176, 0.99983, -426961e-8, 5782e-6, 1.10211, 0.999964, -273904e-8, 374503e-8, 1.11152, 1.00001, -136739e-8, 187176e-8, 1.12031, 0.999946, 393227e-10, -28919e-9, 1.12804, 0.995847, -13435e-10, 0.0671785, 19916e-9, 0.995464, -338387e-10, 0.0671527, 501622e-9, 0.99547, -135355e-9, 0.0671531, 200649e-8, 0.995471, -30455e-8, 0.0671532, 451461e-8, 0.99547, -541423e-9, 0.0671531, 8026e-6, 0.995471, -84598e-8, 0.0671531, 0.0125407, 0.99547, -121823e-8, 0.0671531, 0.0180589, 0.99547, -165817e-8, 0.0671531, 0.0245806, 0.995463, -216583e-8, 0.0671526, 0.0321062, 0.995468, -274127e-8, 0.0671527, 0.0406366, 0.995474, -338447e-8, 0.0671534, 0.0501717, 0.995473, -409554e-8, 0.0671533, 0.0607131, 0.995478, -487451e-8, 0.0671531, 0.0722618, 0.995476, -572148e-8, 0.0671532, 0.0848191, 0.995477, -663658e-8, 0.0671539, 0.0983882, 0.995498, -761986e-8, 0.0671541, 0.112972, 0.995509, -867094e-8, 0.0671542, 0.128568, 0.995509, -978951e-8, 0.0671531, 0.145183, 0.995503, -0.0109725, 0.0671491, 0.162808, 0.995501, -0.012211, 0.0671465, 0.181441, 0.99553, -0.0134565, 0.0671371, 0.201015, 0.99555, -0.014391, 0.0670831, 0.221206, 0.99558, -0.014351, 0.0668883, 0.240813, 0.995577, -0.0173997, 0.0671055, 0.261257, 0.995602, -0.0191111, 0.0671178, 0.284467, 0.995623, -0.0206705, 0.0670946, 0.308765, 0.995658, -0.022184, 0.0670472, 0.333905, 0.995705, -0.0234832, 0.0669417, 0.359677, 0.995719, -0.0241933, 0.0666714, 0.385554, 0.995786, -0.0243539, 0.066266, 0.410951, 0.995887, -0.0271866, 0.0664367, 0.437163, 0.995944, -0.0296012, 0.0664931, 0.464842, 0.996004, -0.0301045, 0.0660105, 0.49332, 0.996128, -0.0298311, 0.0652694, 0.521131, 0.996253, -0.0316426, 0.0650739, 0.549167, 0.996244, -0.0339043, 0.0649433, 0.57737, 0.996309, -0.033329, 0.0638926, 0.606073, 0.996417, -0.0338935, 0.0630849, 0.634527, 0.996372, -0.0353104, 0.0625083, 0.66256, 0.996542, -0.0348942, 0.0611986, 0.690516, 0.996568, -0.0351614, 0.060069, 0.718317, 0.996711, -0.0354317, 0.0588522, 0.74528, 0.996671, -0.0349513, 0.0571902, 0.772061, 0.996865, -0.0345622, 0.0555321, 0.798089, 0.996802, -0.0342566, 0.0537816, 0.823178, 0.996992, -0.0330862, 0.0516095, 0.847949, 0.996944, -0.0324666, 0.0495537, 0.871431, 0.997146, -0.0309544, 0.0470302, 0.894357, 0.997189, -0.0299372, 0.0446043, 0.916142, 0.997471, -0.0281389, 0.0418812, 0.937193, 0.997515, -0.0268702, 0.0391823, 0.957, 0.997812, -0.0247166, 0.0361338, 0.975936, 0.998027, -0.0233525, 0.0333945, 0.99391, 0.998233, -0.0209839, 0.0301917, 1.01075, 0.998481, -0.0194309, 0.027271, 1.02669, 0.998859, -0.0169728, 0.0240162, 1.04173, 0.99894, -0.0152322, 0.0210517, 1.05551, 0.999132, -0.0127497, 0.0178632, 1.06856, 0.999369, -0.0108282, 0.014787, 1.08054, 0.999549, -845886e-8, 0.0116185, 1.09185, 0.999805, -63937e-7, 867209e-8, 1.10207, 0.99985, -414582e-8, 566823e-8, 1.1117, 0.999912, -207443e-8, 277562e-8, 1.12022, 1.00001, 870226e-10, -53766e-9, 1.12832, 0.991943, -178672e-11, 0.0893382, 198384e-10, 0.991952, -450183e-10, 0.089339, 499849e-9, 0.991956, -180074e-9, 0.0893394, 19994e-7, 0.991955, -405167e-9, 0.0893393, 449867e-8, 0.991953, -720298e-9, 0.0893391, 799764e-8, 0.991955, -112548e-8, 0.0893393, 0.0124964, 0.991957, -16207e-7, 0.0893395, 0.0179951, 0.991958, -220601e-8, 0.0893396, 0.0244939, 0.991947, -288137e-8, 0.0893385, 0.0319929, 0.991962, -364693e-8, 0.0893399, 0.0404933, 0.991965, -450264e-8, 0.0893399, 0.049995, 0.99198, -544862e-8, 0.0893411, 0.0604995, 0.99197, -648491e-8, 0.0893397, 0.0720074, 0.991976, -761164e-8, 0.089341, 0.0845207, 0.99198, -882891e-8, 0.0893405, 0.0980413, 0.991982, -0.0101367, 0.0893396, 0.112571, 0.992008, -0.011535, 0.0893415, 0.128115, 0.992026, -0.0130228, 0.0893414, 0.144672, 0.992064, -0.0145966, 0.0893418, 0.162241, 0.992041, -0.0162421, 0.0893359, 0.180801, 0.992086, -0.0178888, 0.0893214, 0.200302, 0.992157, -0.0190368, 0.0892401, 0.220332, 0.992181, -0.0195584, 0.0890525, 0.240144, 0.992175, -0.0227257, 0.0892153, 0.260728, 0.99221, -0.0254195, 0.089304, 0.283473, 0.99222, -0.0274883, 0.0892703, 0.307673, 0.992317, -0.0294905, 0.0892027, 0.332729, 0.992374, -0.0311861, 0.0890577, 0.358387, 0.992505, -0.0320656, 0.0886994, 0.384102, 0.992568, -0.0329715, 0.0883198, 0.409767, 0.992675, -0.036006, 0.0883602, 0.436145, 0.992746, -0.0392897, 0.0884591, 0.463217, 0.992873, -0.0399337, 0.0878287, 0.491557, 0.992934, -0.040231, 0.0870108, 0.519516, 0.993091, -0.0422013, 0.0865857, 0.547741, 0.993259, -0.0443503, 0.0861937, 0.575792, 0.993455, -0.0446368, 0.0851187, 0.604233, 0.993497, -0.0454299, 0.0840576, 0.632925, 0.993694, -0.0463296, 0.0829671, 0.660985, 0.993718, -0.0470619, 0.0817185, 0.688714, 0.993973, -0.0468838, 0.0800294, 0.716743, 0.994207, -0.046705, 0.0781286, 0.74377, 0.994168, -0.0469698, 0.0763337, 0.77042, 0.9945, -0.0456816, 0.0738184, 0.796659, 0.994356, -0.0455518, 0.0715545, 0.821868, 0.994747, -0.0439488, 0.0686085, 0.846572, 0.994937, -0.0430056, 0.065869, 0.870435, 0.995142, -0.0413414, 0.0626446, 0.893272, 0.995451, -0.0396521, 0.05929, 0.915376, 0.995445, -0.0378453, 0.0558503, 0.936196, 0.995967, -0.0355219, 0.0520949, 0.956376, 0.996094, -0.0335146, 0.048377, 0.975327, 0.996622, -0.030682, 0.0442575, 0.993471, 0.996938, -0.0285504, 0.0404693, 1.01052, 0.997383, -0.0253399, 0.0360903, 1.02637, 0.997714, -0.0231651, 0.0322176, 1.04139, 0.998249, -0.0198138, 0.0278433, 1.05542, 0.998596, -0.0174337, 0.0238759, 1.06846, 0.998946, -0.0141349, 0.0195944, 1.08056, 0.99928, -0.0115603, 0.0156279, 1.09181, 0.999507, -839065e-8, 0.0114607, 1.10213, 0.999697, -5666e-6, 763325e-8, 1.11169, 0.999869, -269902e-8, 364946e-8, 1.12042, 1.00001, 623836e-10, -319288e-10, 1.12832, 0.987221, -222675e-11, 0.111332, 197456e-10, 0.98739, -561116e-10, 0.111351, 497563e-9, 0.987448, -224453e-9, 0.111357, 199031e-8, 0.987441, -505019e-9, 0.111357, 44782e-7, 0.987442, -897816e-9, 0.111357, 796129e-8, 0.987442, -140284e-8, 0.111357, 0.0124396, 0.987444, -202012e-8, 0.111357, 0.0179132, 0.987442, -274964e-8, 0.111357, 0.0243824, 0.987446, -359147e-8, 0.111357, 0.0318474, 0.987435, -454562e-8, 0.111356, 0.0403086, 0.987461, -561225e-8, 0.111358, 0.0497678, 0.987458, -679125e-8, 0.111358, 0.0602239, 0.987443, -80828e-7, 0.111356, 0.0716792, 0.987476, -94872e-7, 0.111358, 0.0841364, 0.98749, -0.0110044, 0.111361, 0.097597, 0.987508, -0.0126344, 0.111362, 0.112062, 0.987494, -0.0143767, 0.111357, 0.127533, 0.987526, -0.0162307, 0.111359, 0.144015, 0.987558, -0.0181912, 0.111361, 0.161502, 0.987602, -0.0202393, 0.111355, 0.179979, 0.987692, -0.022273, 0.111346, 0.199386, 0.987702, -0.0235306, 0.111215, 0.219183, 0.987789, -0.0247628, 0.111061, 0.239202, 0.987776, -0.0280668, 0.111171, 0.259957, 0.987856, -0.0316751, 0.111327, 0.282198, 0.987912, -0.0342468, 0.111282, 0.306294, 0.988, -0.0367205, 0.111198, 0.331219, 0.988055, -0.0387766, 0.110994, 0.356708, 0.988241, -0.0397722, 0.110547, 0.382234, 0.988399, -0.0416076, 0.110198, 0.408227, 0.988539, -0.0448192, 0.110137, 0.434662, 0.988661, -0.0483793, 0.110143, 0.461442, 0.988967, -0.0495895, 0.109453, 0.489318, 0.989073, -0.0506797, 0.108628, 0.517516, 0.989274, -0.0526953, 0.108003, 0.545844, 0.989528, -0.054578, 0.107255, 0.573823, 0.989709, -0.0561503, 0.106294, 0.601944, 0.989991, -0.056866, 0.104896, 0.630855, 0.990392, -0.0572914, 0.103336, 0.658925, 0.990374, -0.0586224, 0.10189, 0.686661, 0.990747, -0.0584764, 0.099783, 0.714548, 0.991041, -0.0582662, 0.0974309, 0.74186, 0.991236, -0.0584118, 0.0951678, 0.768422, 0.991585, -0.0573055, 0.0921581, 0.794817, 0.991984, -0.0564241, 0.0891167, 0.820336, 0.9921, -0.0553608, 0.085805, 0.84493, 0.992749, -0.0533816, 0.0820354, 0.868961, 0.99288, -0.0518661, 0.0782181, 0.891931, 0.993511, -0.0492492, 0.0738935, 0.914186, 0.993617, -0.0471956, 0.0696402, 0.93532, 0.99411, -0.044216, 0.0649659, 0.95543, 0.994595, -0.0416654, 0.0603177, 0.974685, 0.994976, -0.0384314, 0.0553493, 0.992807, 0.995579, -0.0353491, 0.0503942, 1.00996, 0.996069, -0.0319787, 0.0452123, 1.02606, 0.996718, -0.028472, 0.0400112, 1.04114, 0.997173, -0.0250789, 0.0349456, 1.05517, 0.997818, -0.0213326, 0.029653, 1.0683, 0.998318, -0.0178509, 0.024549, 1.0805, 0.998853, -0.0141118, 0.0194197, 1.09177, 0.999218, -0.0105914, 0.0143869, 1.1022, 0.999594, -693474e-8, 943517e-8, 1.11175, 0.99975, -340478e-8, 464051e-8, 1.12056, 1.00001, 109172e-9, -112821e-9, 1.12853, 0.983383, -266524e-11, 0.133358, 196534e-10, 0.981942, -671009e-10, 0.133162, 494804e-9, 0.981946, -268405e-9, 0.133163, 197923e-8, 0.981944, -603912e-9, 0.133163, 445326e-8, 0.981941, -107362e-8, 0.133162, 791693e-8, 0.981946, -167755e-8, 0.133163, 0.0123703, 0.981944, -241569e-8, 0.133162, 0.0178135, 0.981945, -328807e-8, 0.133163, 0.0242466, 0.981945, -429472e-8, 0.133162, 0.03167, 0.981955, -543573e-8, 0.133164, 0.0400846, 0.981951, -671105e-8, 0.133163, 0.0494901, 0.981968, -812092e-8, 0.133165, 0.0598886, 0.981979, -966541e-8, 0.133166, 0.0712811, 0.981996, -0.0113446, 0.133168, 0.083669, 0.982014, -0.0131585, 0.133169, 0.0970533, 0.982011, -0.0151073, 0.133167, 0.111438, 0.982062, -0.0171906, 0.133172, 0.126826, 0.9821, -0.0194067, 0.133175, 0.143215, 0.982149, -0.0217502, 0.133176, 0.160609, 0.982163, -0.0241945, 0.133173, 0.178981, 0.982247, -0.0265907, 0.133148, 0.198249, 0.982291, -0.027916, 0.132974, 0.217795, 0.982396, -0.0299663, 0.132868, 0.238042, 0.982456, -0.0334544, 0.132934, 0.258901, 0.982499, -0.0378636, 0.133137, 0.280639, 0.982617, -0.0409274, 0.133085, 0.304604, 0.98274, -0.0438523, 0.132985, 0.329376, 0.982944, -0.0462288, 0.132728, 0.354697, 0.98308, -0.0475995, 0.132228, 0.380102, 0.983391, -0.0501901, 0.131924, 0.406256, 0.983514, -0.0535899, 0.131737, 0.432735, 0.98373, -0.0571858, 0.131567, 0.459359, 0.984056, -0.0592353, 0.130932, 0.486637, 0.984234, -0.0610488, 0.130092, 0.51509, 0.984748, -0.0630758, 0.12923, 0.543461, 0.985073, -0.0647398, 0.128174, 0.571376, 0.985195, -0.0671941, 0.127133, 0.599414, 0.985734, -0.0681345, 0.125576, 0.628134, 0.986241, -0.0686089, 0.123639, 0.656399, 0.986356, -0.0698511, 0.121834, 0.684258, 0.986894, -0.0700931, 0.119454, 0.711818, 0.987382, -0.0698321, 0.116718, 0.739511, 0.988109, -0.0693975, 0.113699, 0.766267, 0.988363, -0.0689584, 0.110454, 0.792456, 0.989112, -0.0672353, 0.106602, 0.81813, 0.989241, -0.0662034, 0.10267, 0.842889, 0.990333, -0.0638938, 0.0981381, 0.867204, 0.990591, -0.0618534, 0.0935388, 0.89038, 0.991106, -0.0593117, 0.088553, 0.912576, 0.991919, -0.0562676, 0.0832187, 0.934118, 0.992111, -0.0534085, 0.0778302, 0.954254, 0.992997, -0.0495459, 0.0720453, 0.973722, 0.993317, -0.0463707, 0.0663458, 0.991949, 0.994133, -0.0421245, 0.0601883, 1.00936, 0.994705, -0.0384977, 0.0542501, 1.02559, 0.995495, -0.0340956, 0.0479862, 1.04083, 0.996206, -0.030105, 0.041887, 1.05497, 0.996971, -0.0256095, 0.0355355, 1.06824, 0.997796, -0.0213932, 0.0293655, 1.08056, 0.998272, -0.0169612, 0.0232926, 1.09182, 0.998857, -0.0126756, 0.0172786, 1.10219, 0.99939, -832486e-8, 0.0113156, 1.11192, 0.999752, -410826e-8, 557892e-8, 1.12075, 1, 150957e-9, -119101e-9, 1.12885, 0.975169, -309397e-11, 0.154669, 195073e-10, 0.975439, -779608e-10, 0.154712, 491534e-9, 0.975464, -311847e-9, 0.154716, 196617e-8, 0.975464, -701656e-9, 0.154716, 442387e-8, 0.975462, -12474e-7, 0.154715, 78647e-7, 0.975461, -194906e-8, 0.154715, 0.0122886, 0.975464, -280667e-8, 0.154715, 0.0176959, 0.975468, -382025e-8, 0.154716, 0.0240867, 0.975471, -498985e-8, 0.154716, 0.0314612, 0.975472, -631541e-8, 0.154717, 0.0398199, 0.975486, -779719e-8, 0.154718, 0.0491639, 0.975489, -943505e-8, 0.154718, 0.0594932, 0.975509, -0.0112295, 0.154721, 0.0708113, 0.97554, -0.0131802, 0.154724, 0.0831176, 0.975557, -0.0152876, 0.154726, 0.096415, 0.975585, -0.0175512, 0.154728, 0.110705, 0.975605, -0.0199713, 0.154729, 0.125992, 0.975645, -0.0225447, 0.154729, 0.142272, 0.975711, -0.0252649, 0.154735, 0.159549, 0.975788, -0.0280986, 0.154736, 0.177805, 0.975872, -0.0308232, 0.154704, 0.196911, 0.975968, -0.0324841, 0.154525, 0.216324, 0.976063, -0.0351281, 0.154432, 0.236628, 0.976157, -0.0388618, 0.15446, 0.257539, 0.976204, -0.0437704, 0.154665, 0.278975, 0.976358, -0.047514, 0.154652, 0.302606, 0.976571, -0.0508638, 0.154535, 0.327204, 0.976725, -0.0534995, 0.154221, 0.352276, 0.977013, -0.0555547, 0.153737, 0.377696, 0.977294, -0.0586728, 0.153403, 0.403855, 0.977602, -0.0622715, 0.15312, 0.430333, 0.977932, -0.0658166, 0.152755, 0.456855, 0.978241, -0.0689877, 0.152233, 0.483668, 0.978602, -0.0712805, 0.15132, 0.512097, 0.979234, -0.0732775, 0.150235, 0.540455, 0.97977, -0.075163, 0.148978, 0.568486, 0.979995, -0.0778026, 0.147755, 0.596524, 0.98078, -0.0791854, 0.146019, 0.624825, 0.981628, -0.0799666, 0.143906, 0.653403, 0.982067, -0.0808532, 0.141561, 0.681445, 0.98271, -0.0816024, 0.139025, 0.708918, 0.983734, -0.0812511, 0.135764, 0.736594, 0.98431, -0.0806201, 0.132152, 0.763576, 0.985071, -0.0801605, 0.12846, 0.789797, 0.98618, -0.0784208, 0.124084, 0.815804, 0.986886, -0.0766643, 0.1193, 0.840869, 0.987485, -0.0747744, 0.114236, 0.864952, 0.988431, -0.0716701, 0.108654, 0.888431, 0.988886, -0.0691609, 0.102994, 0.910963, 0.990024, -0.0654048, 0.0967278, 0.932629, 0.990401, -0.0619765, 0.090384, 0.95313, 0.991093, -0.0579296, 0.0837885, 0.972587, 0.992018, -0.0536576, 0.0770171, 0.991184, 0.992536, -0.0493719, 0.0701486, 1.00863, 0.993421, -0.0444813, 0.062953, 1.02494, 0.993928, -0.040008, 0.0560455, 1.04017, 0.994994, -0.0347982, 0.04856, 1.05463, 0.995866, -0.0301017, 0.0416152, 1.06807, 0.996916, -0.0248225, 0.0342597, 1.08039, 0.997766, -0.0199229, 0.0271668, 1.09177, 0.998479, -0.0147422, 0.0201387, 1.10235, 0.99921, -980173e-8, 0.0131944, 1.11206, 0.999652, -47426e-7, 640712e-8, 1.12104, 0.999998, 891673e-10, -10379e-8, 1.12906, 0.967868, -351885e-11, 0.175947, 193569e-10, 0.968001, -886733e-10, 0.175972, 487782e-9, 0.96801, -354697e-9, 0.175973, 195115e-8, 0.968012, -798063e-9, 0.175974, 439006e-8, 0.968011, -141879e-8, 0.175973, 780461e-8, 0.968011, -221686e-8, 0.175973, 0.0121948, 0.968016, -319231e-8, 0.175974, 0.0175607, 0.968019, -434515e-8, 0.175974, 0.0239027, 0.968018, -567538e-8, 0.175974, 0.0312208, 0.968033, -718308e-8, 0.175977, 0.0395158, 0.968049, -886836e-8, 0.175979, 0.0487885, 0.968047, -0.0107312, 0.175978, 0.0590394, 0.968072, -0.0127719, 0.175981, 0.0702705, 0.968108, -0.0149905, 0.175986, 0.0824836, 0.968112, -0.0173866, 0.175985, 0.0956783, 0.968173, -0.0199611, 0.175993, 0.109862, 0.96827, -0.0227128, 0.176008, 0.125033, 0.968292, -0.025639, 0.17601, 0.141193, 0.968339, -0.0287299, 0.176007, 0.158336, 0.968389, -0.0319399, 0.176001, 0.176441, 0.968501, -0.034941, 0.175962, 0.195359, 0.968646, -0.0370812, 0.175793, 0.214686, 0.968789, -0.0402329, 0.175708, 0.234973, 0.96886, -0.0442601, 0.1757, 0.255871, 0.969013, -0.049398, 0.175876, 0.277238, 0.969242, -0.0539932, 0.17594, 0.300326, 0.969419, -0.0577299, 0.175781, 0.324702, 0.969763, -0.0605643, 0.175432, 0.349527, 0.970093, -0.0634488, 0.174992, 0.374976, 0.970361, -0.0670589, 0.174611, 0.401097, 0.970825, -0.0708246, 0.174226, 0.427496, 0.971214, -0.0742871, 0.173684, 0.453858, 0.971622, -0.0782608, 0.173186, 0.480637, 0.972175, -0.0813151, 0.172288, 0.508655, 0.972944, -0.0832678, 0.170979, 0.536973, 0.973595, -0.0855964, 0.169573, 0.565138, 0.974345, -0.0882163, 0.168152, 0.593222, 0.975233, -0.0901671, 0.166314, 0.621201, 0.976239, -0.0912111, 0.163931, 0.649919, 0.977289, -0.0916959, 0.161106, 0.678011, 0.978076, -0.0927061, 0.158272, 0.705717, 0.979533, -0.0925562, 0.15475, 0.733228, 0.980335, -0.0918159, 0.150638, 0.760454, 0.981808, -0.0908508, 0.146201, 0.786918, 0.983061, -0.0896172, 0.141386, 0.812953, 0.984148, -0.0871588, 0.135837, 0.838281, 0.985047, -0.0850624, 0.130135, 0.862594, 0.986219, -0.0818541, 0.123882, 0.88633, 0.987043, -0.0784523, 0.117126, 0.908952, 0.988107, -0.0749601, 0.110341, 0.930744, 0.988955, -0.0703548, 0.102885, 0.951728, 0.989426, -0.0662798, 0.0954167, 0.971166, 0.990421, -0.0610834, 0.0876331, 0.989984, 0.991032, -0.0562936, 0.0797785, 1.00765, 0.992041, -0.0508154, 0.0718166, 1.02434, 0.992794, -0.0454045, 0.0637125, 1.03976, 0.993691, -0.0398194, 0.0555338, 1.05418, 0.994778, -0.0341482, 0.0473388, 1.06772, 0.995915, -0.028428, 0.0391016, 1.08028, 0.997109, -0.022642, 0.0309953, 1.09185, 0.998095, -0.0168738, 0.0230288, 1.10247, 0.998985, -0.0111274, 0.0150722, 1.11229, 0.999581, -543881e-8, 740605e-8, 1.12131, 1.00003, 162239e-9, -105549e-9, 1.12946, 0.959505, -393734e-11, 0.196876, 191893e-10, 0.959599, -992157e-10, 0.196895, 483544e-9, 0.959641, -396868e-9, 0.196903, 19342e-7, 0.959599, -892948e-9, 0.196895, 435193e-8, 0.959603, -158747e-8, 0.196896, 77368e-7, 0.959604, -248042e-8, 0.196896, 0.0120888, 0.959605, -357184e-8, 0.196896, 0.0174082, 0.959605, -486169e-8, 0.196896, 0.0236949, 0.959613, -635008e-8, 0.196897, 0.0309497, 0.959619, -803696e-8, 0.196898, 0.0391725, 0.959636, -992255e-8, 0.196901, 0.0483649, 0.959634, -0.0120067, 0.1969, 0.0585266, 0.959675, -0.0142898, 0.196906, 0.0696609, 0.959712, -0.0167717, 0.196911, 0.0817678, 0.959752, -0.0194524, 0.196918, 0.0948494, 0.959807, -0.0223321, 0.196925, 0.10891, 0.959828, -0.0254091, 0.196924, 0.123947, 0.959906, -0.0286815, 0.196934, 0.139968, 0.960005, -0.0321371, 0.196944, 0.156968, 0.960071, -0.0357114, 0.196936, 0.17491, 0.960237, -0.0389064, 0.196882, 0.193597, 0.960367, -0.041623, 0.196731, 0.21285, 0.960562, -0.0452655, 0.196654, 0.233075, 0.960735, -0.0496207, 0.196643, 0.253941, 0.960913, -0.0549379, 0.196774, 0.275278, 0.961121, -0.0603414, 0.196893, 0.297733, 0.96139, -0.0644244, 0.196717, 0.321877, 0.961818, -0.067556, 0.196314, 0.346476, 0.962175, -0.0712709, 0.195917, 0.371907, 0.96255, -0.0752848, 0.1955, 0.397916, 0.963164, -0.0792073, 0.195026, 0.424229, 0.963782, -0.0828225, 0.194424, 0.450637, 0.964306, -0.0873119, 0.193831, 0.477288, 0.964923, -0.0911051, 0.192973, 0.504716, 0.966048, -0.093251, 0.19151, 0.533053, 0.967024, -0.0958983, 0.190013, 0.561366, 0.968038, -0.09835, 0.188253, 0.589464, 0.969152, -0.100754, 0.186257, 0.617433, 0.970557, -0.102239, 0.183775, 0.645801, 0.972104, -0.102767, 0.180645, 0.674278, 0.973203, -0.103492, 0.177242, 0.702004, 0.975123, -0.103793, 0.17345, 0.729529, 0.97641, -0.102839, 0.168886, 0.756712, 0.978313, -0.101687, 0.163892, 0.783801, 0.980036, -0.100314, 0.158439, 0.809671, 0.981339, -0.097836, 0.152211, 0.835402, 0.982794, -0.0950006, 0.145679, 0.860081, 0.984123, -0.0920994, 0.138949, 0.883757, 0.984918, -0.0878641, 0.131283, 0.90685, 0.985999, -0.083939, 0.123464, 0.928786, 0.987151, -0.0791234, 0.115324, 0.94983, 0.987827, -0.0739332, 0.106854, 0.96962, 0.988806, -0.0688088, 0.0982691, 0.98861, 0.989588, -0.0628962, 0.0893456, 1.00667, 0.990438, -0.0573146, 0.0805392, 1.02344, 0.991506, -0.0509433, 0.0713725, 1.03933, 0.992492, -0.0448724, 0.0623732, 1.05378, 0.993663, -0.0383497, 0.0530838, 1.06747, 0.994956, -0.0319593, 0.0439512, 1.08007, 0.99634, -0.025401, 0.0347803, 1.09182, 0.99761, -0.0189687, 0.0257954, 1.1025, 0.99863, -0.0124441, 0.0169893, 1.11247, 0.99947, -614003e-8, 829498e-8, 1.12151, 1.00008, 216624e-9, -146107e-9, 1.12993, 0.950129, -434955e-11, 0.217413, 190081e-10, 0.950264, -10957e-8, 0.217444, 47884e-8, 0.9503, -438299e-9, 0.217451, 191543e-8, 0.950246, -986124e-9, 0.21744, 430951e-8, 0.950246, -175311e-8, 0.21744, 766137e-8, 0.950245, -273923e-8, 0.21744, 0.011971, 0.950253, -394453e-8, 0.217441, 0.0172385, 0.950258, -536897e-8, 0.217442, 0.0234641, 0.950267, -701262e-8, 0.217444, 0.030648, 0.950277, -887551e-8, 0.217446, 0.038791, 0.950284, -0.0109576, 0.217446, 0.0478931, 0.950312, -0.0132591, 0.217451, 0.0579568, 0.950334, -0.01578, 0.217454, 0.0689821, 0.950378, -0.0185204, 0.217462, 0.0809714, 0.950417, -0.0214803, 0.217467, 0.0939265, 0.950488, -0.0246594, 0.217479, 0.10785, 0.950534, -0.0280565, 0.217483, 0.122743, 0.950633, -0.0316685, 0.217498, 0.138611, 0.950698, -0.0354787, 0.217499, 0.155442, 0.950844, -0.0394003, 0.217507, 0.173208, 0.950999, -0.0426812, 0.217419, 0.191605, 0.951221, -0.0461302, 0.217317, 0.21084, 0.951412, -0.0502131, 0.217238, 0.230945, 0.951623, -0.0549183, 0.21722, 0.251745, 0.951867, -0.0604493, 0.217306, 0.273001, 0.952069, -0.0665189, 0.217466, 0.294874, 0.952459, -0.0709179, 0.217266, 0.318732, 0.952996, -0.0746112, 0.216891, 0.34318, 0.953425, -0.0789252, 0.216503, 0.36849, 0.953885, -0.0833293, 0.216042, 0.394373, 0.954617, -0.087371, 0.215469, 0.420505, 0.955429, -0.0914054, 0.214802, 0.446907, 0.956068, -0.0961671, 0.214146, 0.473522, 0.957094, -0.10048, 0.213286, 0.50052, 0.958372, -0.103248, 0.211796, 0.528715, 0.959654, -0.106033, 0.21016, 0.557065, 0.961305, -0.108384, 0.208149, 0.585286, 0.962785, -0.111122, 0.206024, 0.613334, 0.964848, -0.112981, 0.203442, 0.641334, 0.966498, -0.113717, 0.19996, 0.669955, 0.968678, -0.114121, 0.196105, 0.698094, 0.970489, -0.114524, 0.191906, 0.725643, 0.972903, -0.113792, 0.186963, 0.752856, 0.974701, -0.112406, 0.181343, 0.780013, 0.976718, -0.110685, 0.175185, 0.806268, 0.978905, -0.108468, 0.168535, 0.832073, 0.980267, -0.105061, 0.161106, 0.857149, 0.981967, -0.101675, 0.153387, 0.881145, 0.983063, -0.0974492, 0.145199, 0.904255, 0.984432, -0.0925815, 0.136527, 0.926686, 0.985734, -0.0877983, 0.127584, 0.947901, 0.986228, -0.081884, 0.118125, 0.968111, 0.98719, -0.0761208, 0.108594, 0.98719, 0.988228, -0.0698196, 0.0989996, 1.00559, 0.989046, -0.0632739, 0.0890074, 1.02246, 0.990242, -0.056522, 0.0790832, 1.03841, 0.991252, -0.0495272, 0.0689182, 1.05347, 0.992542, -0.0425373, 0.0588592, 1.06724, 0.994096, -0.0353198, 0.0486833, 1.08009, 0.995593, -0.028235, 0.0385977, 1.09177, 0.99711, -0.0209511, 0.0286457, 1.10274, 0.998263, -0.0139289, 0.0188497, 1.11262, 0.999254, -67359e-7, 9208e-6, 1.12191, 0.999967, 141846e-9, -657764e-10, 1.13024, 0.935608, -474692e-11, 0.236466, 187817e-10, 0.93996, -11971e-8, 0.237568, 473646e-9, 0.939959, -478845e-9, 0.237567, 18946e-7, 0.939954, -10774e-7, 0.237566, 426284e-8, 0.939956, -191538e-8, 0.237566, 757842e-8, 0.939954, -299277e-8, 0.237566, 0.0118413, 0.93996, -430961e-8, 0.237567, 0.0170518, 0.939969, -586589e-8, 0.237569, 0.02321, 0.939982, -766166e-8, 0.237572, 0.0303164, 0.939987, -969686e-8, 0.237572, 0.0383711, 0.939997, -0.0119715, 0.237574, 0.0473751, 0.940031, -0.0144858, 0.237581, 0.0573298, 0.940073, -0.0172399, 0.237589, 0.0682366, 0.94012, -0.0202335, 0.237598, 0.080097, 0.940162, -0.0234663, 0.237604, 0.0929116, 0.940237, -0.0269387, 0.237615, 0.106686, 0.940328, -0.0306489, 0.237632, 0.121421, 0.940419, -0.0345917, 0.237645, 0.137115, 0.940522, -0.0387481, 0.237654, 0.153766, 0.940702, -0.0429906, 0.237661, 0.17133, 0.940871, -0.0465089, 0.237561, 0.189502, 0.941103, -0.050531, 0.23748, 0.208616, 0.941369, -0.0550657, 0.237423, 0.228595, 0.941641, -0.0601337, 0.237399, 0.249287, 0.941903, -0.0658804, 0.237443, 0.270467, 0.942224, -0.0722674, 0.237597, 0.292024, 0.942633, -0.0771788, 0.237419, 0.315272, 0.943172, -0.0815623, 0.237068, 0.339579, 0.943691, -0.0863973, 0.236682, 0.364717, 0.944382, -0.0911536, 0.236213, 0.390435, 0.945392, -0.0952967, 0.235562, 0.416425, 0.946185, -0.0998948, 0.234832, 0.442772, 0.947212, -0.104796, 0.234114, 0.469347, 0.948778, -0.10928, 0.233222, 0.496162, 0.950149, -0.113081, 0.231845, 0.523978, 0.951989, -0.115893, 0.230005, 0.552295, 0.953921, -0.11846, 0.227862, 0.580569, 0.955624, -0.12115, 0.225439, 0.608698, 0.958234, -0.123373, 0.222635, 0.636696, 0.960593, -0.124519, 0.219093, 0.665208, 0.963201, -0.124736, 0.214749, 0.693557, 0.965642, -0.125012, 0.210059, 0.721334, 0.968765, -0.124661, 0.204935, 0.748613, 0.971753, -0.122996, 0.198661, 0.776224, 0.973751, -0.120998, 0.191823, 0.802461, 0.976709, -0.118583, 0.184359, 0.828399, 0.977956, -0.115102, 0.176437, 0.853693, 0.979672, -0.111077, 0.167681, 0.877962, 0.981816, -0.10688, 0.158872, 0.901564, 0.98238, -0.101469, 0.149398, 0.924057, 0.983964, -0.0960013, 0.139436, 0.945751, 0.984933, -0.0899626, 0.12943, 0.966272, 0.985694, -0.0832973, 0.11894, 0.985741, 0.986822, -0.0767082, 0.108349, 1.00407, 0.987725, -0.0693614, 0.0976026, 1.02154, 0.98877, -0.06211, 0.086652, 1.03757, 0.990129, -0.0544143, 0.0756182, 1.05296, 0.991337, -0.046744, 0.0645753, 1.06683, 0.992978, -0.0387931, 0.0534683, 1.0798, 0.994676, -0.030973, 0.0424137, 1.09181, 0.99645, -0.0230311, 0.0314035, 1.10286, 0.997967, -0.0152065, 0.0206869, 1.11291, 0.99922, -744837e-8, 0.010155, 1.12237, 1.00002, 240209e-9, -752767e-10, 1.13089, 0.922948, -515351e-11, 0.255626, 186069e-10, 0.928785, -129623e-9, 0.257244, 468009e-9, 0.928761, -51849e-8, 0.257237, 187202e-8, 0.928751, -11666e-7, 0.257235, 421204e-8, 0.928751, -207395e-8, 0.257234, 74881e-7, 0.928754, -324055e-8, 0.257235, 0.0117002, 0.92876, -466639e-8, 0.257236, 0.0168486, 0.928763, -635149e-8, 0.257237, 0.0229334, 0.928774, -829584e-8, 0.257239, 0.029955, 0.928791, -0.0104995, 0.257243, 0.0379139, 0.928804, -0.0129623, 0.257245, 0.0468108, 0.928847, -0.0156846, 0.257255, 0.0566473, 0.92889, -0.0186661, 0.257263, 0.0674246, 0.928924, -0.0219067, 0.257268, 0.0791433, 0.928989, -0.0254066, 0.257282, 0.0918076, 0.92909, -0.0291651, 0.257301, 0.105419, 0.92918, -0.0331801, 0.257316, 0.119978, 0.92929, -0.0374469, 0.257332, 0.135491, 0.929453, -0.041939, 0.257357, 0.151948, 0.929586, -0.0464612, 0.257347, 0.169275, 0.929858, -0.0503426, 0.257269, 0.187257, 0.930125, -0.0548409, 0.257199, 0.206204, 0.930403, -0.0598063, 0.257149, 0.22601, 0.930726, -0.0652437, 0.257122, 0.246561, 0.931098, -0.0712376, 0.257153, 0.267618, 0.931396, -0.0777506, 0.257237, 0.288993, 0.931947, -0.0832374, 0.257124, 0.311527, 0.932579, -0.0883955, 0.25683, 0.335697, 0.933194, -0.0937037, 0.256444, 0.360634, 0.934013, -0.0987292, 0.255939, 0.386126, 0.935307, -0.103215, 0.255282, 0.412018, 0.936374, -0.108234, 0.254538, 0.438292, 0.93776, -0.113234, 0.253728, 0.464805, 0.939599, -0.118013, 0.25275, 0.491464, 0.941036, -0.122661, 0.251404, 0.518751, 0.94337, -0.125477, 0.249435, 0.547133, 0.945318, -0.128374, 0.247113, 0.575456, 0.947995, -0.130996, 0.244441, 0.60372, 0.950818, -0.133438, 0.241352, 0.63174, 0.954378, -0.135004, 0.237849, 0.659971, 0.957151, -0.135313, 0.233188, 0.688478, 0.960743, -0.13521, 0.228001, 0.716767, 0.964352, -0.135007, 0.222249, 0.744349, 0.967273, -0.133523, 0.21542, 0.771786, 0.969767, -0.131155, 0.208039, 0.798639, 0.973195, -0.128492, 0.200076, 0.824774, 0.975557, -0.125094, 0.191451, 0.850222, 0.977692, -0.120578, 0.18184, 0.874761, 0.98026, -0.115882, 0.172102, 0.898497, 0.981394, -0.110372, 0.161859, 0.921636, 0.982386, -0.10415, 0.15108, 0.943467, 0.983783, -0.0978128, 0.140407, 0.964045, 0.98422, -0.0906171, 0.129058, 0.98398, 0.985447, -0.0832921, 0.117614, 1.00276, 0.986682, -0.0754412, 0.10585, 1.02047, 0.987326, -0.0673885, 0.0940943, 1.03678, 0.988707, -0.0592565, 0.0822093, 1.05218, 0.990185, -0.050717, 0.070192, 1.06652, 0.991866, -0.0423486, 0.0582081, 1.07965, 0.993897, -0.0336118, 0.0460985, 1.09188, 0.995841, -0.0252178, 0.0342737, 1.10307, 0.997605, -0.0164893, 0.0224829, 1.11324, 0.999037, -817112e-8, 0.0110647, 1.12262, 1.00003, 291686e-9, -168673e-9, 1.13139, 0.915304, -552675e-11, 0.275999, 183285e-10, 0.91668, -139285e-9, 0.276414, 461914e-9, 0.916664, -55713e-8, 0.276409, 184763e-8, 0.916653, -125354e-8, 0.276406, 415715e-8, 0.916651, -222851e-8, 0.276405, 739053e-8, 0.916655, -348205e-8, 0.276406, 0.0115478, 0.916653, -501414e-8, 0.276405, 0.0166291, 0.916667, -682478e-8, 0.276409, 0.0226346, 0.91668, -891398e-8, 0.276412, 0.0295648, 0.91669, -0.0112817, 0.276413, 0.0374199, 0.916727, -0.013928, 0.276422, 0.0462016, 0.916759, -0.0168528, 0.276429, 0.0559101, 0.916793, -0.0200558, 0.276436, 0.0665466, 0.916849, -0.0235373, 0.276448, 0.0781139, 0.916964, -0.0272973, 0.276474, 0.0906156, 0.917047, -0.0313344, 0.276491, 0.104051, 0.917152, -0.0356465, 0.276511, 0.118424, 0.917286, -0.0402271, 0.276533, 0.133736, 0.917469, -0.0450408, 0.276564, 0.149978, 0.917686, -0.0497872, 0.276563, 0.167057, 0.917953, -0.0540937, 0.276493, 0.184846, 0.918228, -0.0590709, 0.276437, 0.203614, 0.918572, -0.0644277, 0.276398, 0.223212, 0.918918, -0.0702326, 0.276362, 0.243584, 0.919356, -0.076484, 0.276383, 0.264465, 0.919842, -0.0830808, 0.276434, 0.285701, 0.920451, -0.0892972, 0.276407, 0.307559, 0.921113, -0.095016, 0.276128, 0.331501, 0.921881, -0.100771, 0.275754, 0.356207, 0.923027, -0.106029, 0.275254, 0.381477, 0.924364, -0.111029, 0.274595, 0.40722, 0.925818, -0.116345, 0.273841, 0.433385, 0.92746, -0.121424, 0.272913, 0.459848, 0.929167, -0.12657, 0.271837, 0.486493, 0.931426, -0.131581, 0.270575, 0.513432, 0.934001, -0.135038, 0.268512, 0.541502, 0.936296, -0.138039, 0.266135, 0.569658, 0.939985, -0.140687, 0.263271, 0.598375, 0.943516, -0.143247, 0.260058, 0.626563, 0.94782, -0.145135, 0.256138, 0.654711, 0.951023, -0.145733, 0.251154, 0.683285, 0.955338, -0.145554, 0.245562, 0.711831, 0.959629, -0.145008, 0.239265, 0.739573, 0.963123, -0.144003, 0.232064, 0.767027, 0.966742, -0.141289, 0.224036, 0.794359, 0.969991, -0.138247, 0.215305, 0.820361, 0.973403, -0.134786, 0.206051, 0.846548, 0.975317, -0.129966, 0.195914, 0.871541, 0.977647, -0.12471, 0.185184, 0.895313, 0.980137, -0.119086, 0.174161, 0.918398, 0.981031, -0.112297, 0.162792, 0.940679, 0.982037, -0.105372, 0.150952, 0.961991, 0.983164, -0.097821, 0.138921, 0.981913, 0.983757, -0.0897245, 0.126611, 1.00109, 0.985036, -0.0815974, 0.114228, 1.01902, 0.986289, -0.0727725, 0.101389, 1.03604, 0.987329, -0.0639323, 0.0886476, 1.05149, 0.989193, -0.0548109, 0.0756837, 1.06619, 0.990716, -0.045687, 0.0627581, 1.07948, 0.992769, -0.0364315, 0.0498337, 1.09172, 0.99524, -0.0271761, 0.0370305, 1.1033, 0.997154, -0.0179609, 0.0243959, 1.11353, 0.998845, -878063e-8, 0.0119567, 1.12319, 1.00002, 259038e-9, -108146e-9, 1.13177, 0.903945, -591681e-11, 0.295126, 181226e-10, 0.903668, -148672e-9, 0.295037, 455367e-9, 0.903677, -594683e-9, 0.29504, 182145e-8, 0.903673, -133805e-8, 0.295039, 409831e-8, 0.903666, -237872e-8, 0.295036, 728584e-8, 0.903668, -371676e-8, 0.295037, 0.0113842, 0.903679, -535212e-8, 0.29504, 0.0163936, 0.903684, -728479e-8, 0.295041, 0.0223141, 0.903698, -951473e-8, 0.295044, 0.0291462, 0.903718, -0.0120419, 0.295049, 0.0368904, 0.903754, -0.0148664, 0.295058, 0.0455477, 0.903801, -0.017988, 0.29507, 0.0551194, 0.903851, -0.0214064, 0.295082, 0.0656058, 0.903921, -0.0251219, 0.295097, 0.0770109, 0.904002, -0.0291337, 0.295116, 0.0893354, 0.904111, -0.033441, 0.29514, 0.102583, 0.904246, -0.0380415, 0.295169, 0.116755, 0.904408, -0.0429258, 0.295202, 0.131853, 0.904637, -0.0480468, 0.295245, 0.147869, 0.904821, -0.0529208, 0.295214, 0.164658, 0.905163, -0.0577748, 0.295185, 0.182274, 0.905469, -0.0631763, 0.295143, 0.200828, 0.905851, -0.068917, 0.295112, 0.2202, 0.906322, -0.0750861, 0.295104, 0.240372, 0.906761, -0.0815855, 0.295086, 0.261082, 0.90735, -0.0882138, 0.295095, 0.282123, 0.908087, -0.095082, 0.295139, 0.303563, 0.908826, -0.101488, 0.29492, 0.327028, 0.909832, -0.107577, 0.294577, 0.351464, 0.911393, -0.113033, 0.294115, 0.376497, 0.912804, -0.118629, 0.293446, 0.402115, 0.914081, -0.124232, 0.292581, 0.428111, 0.91637, -0.129399, 0.29166, 0.454442, 0.91814, -0.134892, 0.290422, 0.481024, 0.921179, -0.140069, 0.289194, 0.507924, 0.924544, -0.144431, 0.287421, 0.535557, 0.927995, -0.147498, 0.284867, 0.563984, 0.931556, -0.150197, 0.281722, 0.5923, 0.935777, -0.152711, 0.278207, 0.620832, 0.940869, -0.154836, 0.274148, 0.649069, 0.945994, -0.155912, 0.269057, 0.677746, 0.949634, -0.155641, 0.262799, 0.706293, 0.955032, -0.154809, 0.256097, 0.734278, 0.95917, -0.153678, 0.248618, 0.761751, 0.962931, -0.151253, 0.239794, 0.789032, 0.966045, -0.147625, 0.230281, 0.815422, 0.96971, -0.143964, 0.220382, 0.841787, 0.972747, -0.139464, 0.209846, 0.867446, 0.975545, -0.133459, 0.198189, 0.892004, 0.978381, -0.127424, 0.186362, 0.915458, 0.979935, -0.120506, 0.173964, 0.937948, 0.980948, -0.11282, 0.161429, 0.959732, 0.982234, -0.104941, 0.148557, 0.980118, 0.982767, -0.0962905, 0.135508, 0.999463, 0.983544, -0.0873625, 0.122338, 1.01756, 0.984965, -0.0783447, 0.108669, 1.03492, 0.986233, -0.0684798, 0.0949911, 1.05087, 0.987796, -0.0590867, 0.0811386, 1.0656, 0.989885, -0.0489145, 0.0673099, 1.0794, 0.991821, -0.0391, 0.0535665, 1.09174, 0.99448, -0.029087, 0.0397529, 1.10341, 0.996769, -0.019114, 0.0261463, 1.11383, 0.998641, -947007e-8, 0.0128731, 1.1237, 0.999978, 446316e-9, -169093e-9, 1.13253, 0.888362, -627064e-11, 0.312578, 178215e-10, 0.889988, -157791e-9, 0.313148, 448451e-9, 0.889825, -631076e-9, 0.313092, 179356e-8, 0.88984, -141994e-8, 0.313097, 403554e-8, 0.889828, -25243e-7, 0.313092, 717429e-8, 0.889831, -394421e-8, 0.313093, 0.0112099, 0.889831, -567962e-8, 0.313093, 0.0161425, 0.889844, -773051e-8, 0.313096, 0.0219724, 0.889858, -0.0100968, 0.3131, 0.0286999, 0.889882, -0.0127786, 0.313106, 0.0363256, 0.889918, -0.0157757, 0.313116, 0.0448509, 0.889967, -0.0190878, 0.313129, 0.0542758, 0.89003, -0.022715, 0.313145, 0.0646032, 0.890108, -0.0266566, 0.313165, 0.0758339, 0.890218, -0.0309131, 0.313193, 0.0879729, 0.890351, -0.0354819, 0.313226, 0.101019, 0.89051, -0.0403613, 0.313263, 0.114979, 0.890672, -0.0455385, 0.313294, 0.129848, 0.890882, -0.0509444, 0.313333, 0.145616, 0.891189, -0.0559657, 0.313324, 0.162122, 0.891457, -0.0613123, 0.313281, 0.179524, 0.891856, -0.0671488, 0.313281, 0.197855, 0.892312, -0.0732732, 0.313268, 0.216991, 0.892819, -0.0797865, 0.313263, 0.236924, 0.893369, -0.0865269, 0.313247, 0.257433, 0.894045, -0.0931592, 0.313205, 0.278215, 0.894884, -0.100532, 0.313276, 0.299467, 0.895832, -0.107716, 0.313205, 0.322276, 0.897043, -0.114099, 0.312873, 0.34642, 0.898515, -0.119941, 0.312331, 0.371187, 0.900191, -0.126044, 0.311731, 0.396656, 0.90188, -0.131808, 0.310859, 0.422488, 0.904359, -0.137289, 0.309857, 0.448744, 0.906923, -0.142991, 0.308714, 0.475239, 0.910634, -0.148253, 0.307465, 0.501983, 0.914502, -0.153332, 0.305774, 0.529254, 0.919046, -0.156646, 0.303156, 0.557709, 0.923194, -0.159612, 0.299928, 0.586267, 0.928858, -0.162027, 0.296245, 0.614925, 0.934464, -0.164203, 0.291832, 0.643187, 0.939824, -0.165602, 0.286565, 0.671601, 0.944582, -0.165383, 0.280073, 0.700213, 0.949257, -0.164439, 0.272891, 0.728432, 0.954389, -0.162953, 0.264771, 0.756082, 0.958595, -0.161007, 0.255927, 0.78369, 0.962138, -0.157243, 0.245769, 0.810769, 0.966979, -0.152872, 0.235127, 0.836999, 0.969566, -0.148209, 0.22347, 0.862684, 0.972372, -0.142211, 0.211147, 0.887847, 0.975916, -0.135458, 0.198606, 0.911843, 0.978026, -0.128398, 0.185498, 0.934795, 0.979686, -0.120313, 0.17171, 0.956787, 0.980748, -0.11166, 0.158159, 0.978046, 0.981622, -0.103035, 0.144399, 0.997693, 0.982356, -0.0930328, 0.13001, 1.01642, 0.983308, -0.0834627, 0.115778, 1.03366, 0.985037, -0.0732249, 0.101327, 1.05014, 0.986493, -0.0628145, 0.086554, 1.06507, 0.988484, -0.0526556, 0.0720413, 1.07907, 0.991051, -0.0415744, 0.0571151, 1.09189, 0.993523, -0.0314275, 0.0426643, 1.10369, 0.99628, -0.0203603, 0.0279325, 1.11423, 0.998344, -0.0102446, 0.0138182, 1.12421, 0.999997, 42612e-8, -193628e-9, 1.1333, 0.871555, -660007e-11, 0.329176, 174749e-10, 0.875255, -166579e-9, 0.330571, 441051e-9, 0.875644, -666394e-9, 0.330718, 176441e-8, 0.875159, -149903e-8, 0.330536, 396899e-8, 0.87516, -266493e-8, 0.330536, 7056e-6, 0.875158, -416393e-8, 0.330535, 0.0110251, 0.87516, -599598e-8, 0.330535, 0.0158764, 0.875163, -816108e-8, 0.330536, 0.0216101, 0.875174, -0.0106591, 0.330538, 0.0282266, 0.875199, -0.0134899, 0.330545, 0.0357266, 0.875257, -0.0166538, 0.330563, 0.0441117, 0.875304, -0.0201501, 0.330575, 0.0533821, 0.875373, -0.0239785, 0.330595, 0.0635395, 0.875464, -0.0281389, 0.330619, 0.0745872, 0.875565, -0.0326301, 0.330645, 0.0865255, 0.875691, -0.0374516, 0.330676, 0.0993599, 0.875897, -0.0425993, 0.330733, 0.113093, 0.876091, -0.0480576, 0.330776, 0.127722, 0.876353, -0.0537216, 0.330826, 0.143227, 0.876649, -0.0589807, 0.330809, 0.159462, 0.877034, -0.0647865, 0.330819, 0.176642, 0.877443, -0.0709789, 0.330817, 0.194702, 0.877956, -0.0774782, 0.330832, 0.213577, 0.878499, -0.0843175, 0.330822, 0.233246, 0.879144, -0.0912714, 0.330804, 0.253512, 0.879982, -0.0980824, 0.330766, 0.274137, 0.88097, -0.105823, 0.330864, 0.295209, 0.882051, -0.113671, 0.330896, 0.317226, 0.883397, -0.120303, 0.330545, 0.341068, 0.884987, -0.12667, 0.330068, 0.365613, 0.886789, -0.133118, 0.329418, 0.390807, 0.889311, -0.139024, 0.328683, 0.416494, 0.891995, -0.144971, 0.327729, 0.442618, 0.895106, -0.150747, 0.326521, 0.469131, 0.899527, -0.156283, 0.325229, 0.495921, 0.90504, -0.161707, 0.32378, 0.523162, 0.909875, -0.165661, 0.32122, 0.55092, 0.91561, -0.168755, 0.317942, 0.579928, 0.921225, -0.171193, 0.313983, 0.608539, 0.927308, -0.17319, 0.309636, 0.636854, 0.933077, -0.174819, 0.304262, 0.66523, 0.938766, -0.175002, 0.297563, 0.693609, 0.943667, -0.173946, 0.289613, 0.722157, 0.949033, -0.172221, 0.281227, 0.750021, 0.953765, -0.169869, 0.271545, 0.777466, 0.95804, -0.166578, 0.261034, 0.804853, 0.962302, -0.161761, 0.249434, 0.831569, 0.966544, -0.156636, 0.237484, 0.857779, 0.969372, -0.150784, 0.224395, 0.883051, 0.972486, -0.143672, 0.210786, 0.907864, 0.975853, -0.135772, 0.196556, 0.931223, 0.977975, -0.127942, 0.182307, 0.954061, 0.979122, -0.118347, 0.167607, 0.97531, 0.980719, -0.109112, 0.152739, 0.995666, 0.981223, -0.0991789, 0.137932, 1.01475, 0.98216, -0.0883553, 0.122692, 1.03253, 0.983379, -0.0780825, 0.107493, 1.04917, 0.985434, -0.0665646, 0.0917791, 1.06464, 0.987332, -0.0557714, 0.0764949, 1.07896, 0.990004, -0.0442805, 0.060721, 1.09199, 0.992975, -0.0331676, 0.0452284, 1.10393, 0.995811, -0.0219547, 0.0297934, 1.11476, 0.9982, -0.0107613, 0.0146415, 1.12484, 1.00002, 248678e-9, -14555e-8, 1.13413, 0.859519, -693595e-11, 0.347264, 171673e-10, 0.859843, -17503e-8, 0.347394, 433219e-9, 0.859656, -700076e-9, 0.347319, 173277e-8, 0.859671, -157517e-8, 0.347325, 389875e-8, 0.859669, -280028e-8, 0.347324, 693112e-8, 0.85967, -43754e-7, 0.347324, 0.01083, 0.859665, -630049e-8, 0.347321, 0.0155954, 0.859685, -85755e-7, 0.347328, 0.0212278, 0.859694, -0.0112003, 0.347329, 0.0277273, 0.859718, -0.0141747, 0.347336, 0.0350946, 0.85976, -0.0174988, 0.347348, 0.0433314, 0.85982, -0.0211722, 0.347366, 0.0524384, 0.859892, -0.0251941, 0.347387, 0.0624168, 0.860006, -0.0295649, 0.347422, 0.0732708, 0.860122, -0.0342825, 0.347453, 0.0849999, 0.860282, -0.0393462, 0.347499, 0.0976102, 0.860482, -0.0447513, 0.347554, 0.111104, 0.860719, -0.0504775, 0.347614, 0.125479, 0.860998, -0.0563577, 0.347666, 0.140703, 0.861322, -0.0619473, 0.347662, 0.156681, 0.861724, -0.0681277, 0.347684, 0.173597, 0.862198, -0.0746567, 0.347709, 0.191371, 0.862733, -0.0815234, 0.347727, 0.209976, 0.863371, -0.0886643, 0.347744, 0.229351, 0.86414, -0.0957908, 0.347734, 0.24934, 0.865138, -0.102912, 0.34772, 0.269797, 0.866182, -0.110924, 0.3478, 0.290654, 0.867436, -0.119223, 0.347911, 0.312074, 0.869087, -0.126197, 0.347649, 0.335438, 0.870859, -0.133145, 0.347222, 0.359732, 0.872997, -0.139869, 0.346645, 0.38467, 0.875939, -0.146089, 0.345935, 0.41019, 0.879012, -0.152334, 0.345012, 0.436218, 0.883353, -0.15821, 0.343924, 0.462641, 0.888362, -0.164097, 0.342636, 0.489449, 0.895026, -0.169528, 0.341351, 0.516629, 0.900753, -0.174408, 0.339115, 0.544109, 0.906814, -0.17751, 0.335809, 0.572857, 0.912855, -0.180101, 0.331597, 0.601554, 0.919438, -0.182116, 0.32698, 0.630198, 0.925962, -0.183494, 0.321449, 0.658404, 0.931734, -0.184159, 0.314595, 0.686625, 0.93762, -0.18304, 0.306462, 0.71531, 0.943858, -0.181323, 0.297514, 0.744272, 0.948662, -0.178683, 0.287447, 0.771462, 0.953299, -0.175379, 0.276166, 0.798593, 0.957346, -0.170395, 0.263758, 0.8256, 0.962565, -0.165042, 0.251019, 0.852575, 0.966075, -0.158655, 0.237011, 0.878316, 0.969048, -0.151707, 0.222518, 0.90329, 0.972423, -0.143271, 0.207848, 0.927745, 0.975833, -0.134824, 0.192463, 0.950859, 0.977629, -0.125444, 0.1768, 0.972947, 0.978995, -0.114949, 0.161033, 0.993263, 0.980533, -0.104936, 0.145523, 1.01337, 0.980745, -0.0935577, 0.129799, 1.03128, 0.981814, -0.0822956, 0.113486, 1.04825, 0.983943, -0.0710082, 0.0972925, 1.06405, 0.986141, -0.0587931, 0.0808138, 1.0785, 0.988878, -0.0472755, 0.0644915, 1.09204, 0.992132, -0.0349128, 0.0478128, 1.10413, 0.9953, -0.0232407, 0.031621, 1.11527, 0.998117, -0.0112713, 0.0154935, 1.12551, 1.00003, 339743e-9, -195763e-9, 1.13504, 0.845441, -729126e-11, 0.364305, 169208e-10, 0.843588, -183164e-9, 0.363506, 425067e-9, 0.843412, -73253e-8, 0.36343, 169999e-8, 0.843401, -164818e-8, 0.363426, 382495e-8, 0.843399, -293008e-8, 0.363425, 679993e-8, 0.843401, -457822e-8, 0.363425, 0.010625, 0.843394, -659249e-8, 0.363421, 0.0153002, 0.843398, -897282e-8, 0.363421, 0.0208258, 0.843415, -0.0117191, 0.363426, 0.0272024, 0.843438, -0.0148312, 0.363432, 0.0344305, 0.843483, -0.018309, 0.363447, 0.0425116, 0.84356, -0.0221521, 0.363472, 0.0514471, 0.843646, -0.0263597, 0.363499, 0.061238, 0.843743, -0.0309315, 0.363527, 0.0718873, 0.84388, -0.0358658, 0.363569, 0.0833969, 0.844079, -0.0411624, 0.363631, 0.0957742, 0.844279, -0.0468128, 0.363688, 0.109015, 0.844549, -0.0527923, 0.363761, 0.123124, 0.844858, -0.0588204, 0.363817, 0.138044, 0.84522, -0.0647573, 0.36383, 0.153755, 0.845669, -0.0713181, 0.363879, 0.170394, 0.846155, -0.0781697, 0.363908, 0.187861, 0.846789, -0.0853913, 0.363969, 0.206176, 0.847502, -0.0928086, 0.363999, 0.225244, 0.8484, -0.10005, 0.363997, 0.244926, 0.849461, -0.107615, 0.364008, 0.265188, 0.850562, -0.115814, 0.364055, 0.28587, 0.851962, -0.124334, 0.364179, 0.306926, 0.854326, -0.131995, 0.364233, 0.329605, 0.856295, -0.139338, 0.363856, 0.35359, 0.858857, -0.146346, 0.363347, 0.37831, 0.862428, -0.152994, 0.362807, 0.403722, 0.866203, -0.159463, 0.361963, 0.429537, 0.871629, -0.165623, 0.36112, 0.456, 0.877365, -0.171649, 0.359917, 0.482773, 0.883744, -0.177151, 0.35848, 0.509705, 0.890693, -0.182381, 0.356523, 0.537215, 0.897278, -0.186076, 0.3533, 0.565493, 0.903958, -0.188602, 0.349095, 0.594293, 0.910908, -0.190755, 0.344215, 0.623165, 0.918117, -0.192063, 0.338606, 0.651573, 0.924644, -0.192758, 0.331544, 0.679869, 0.931054, -0.192238, 0.323163, 0.708668, 0.937303, -0.190035, 0.313529, 0.737201, 0.943387, -0.187162, 0.303152, 0.764977, 0.948494, -0.183876, 0.29146, 0.792683, 0.952546, -0.178901, 0.277917, 0.819228, 0.958077, -0.173173, 0.264753, 0.846559, 0.962462, -0.16645, 0.25002, 0.872962, 0.966569, -0.159452, 0.234873, 0.898729, 0.969108, -0.15074, 0.218752, 0.923126, 0.973072, -0.141523, 0.202673, 0.947278, 0.975452, -0.132075, 0.186326, 0.969938, 0.977784, -0.121257, 0.169396, 0.991325, 0.97899, -0.110182, 0.153044, 1.01123, 0.979777, -0.0989634, 0.136485, 1.0299, 0.980865, -0.0865894, 0.119343, 1.04727, 0.982432, -0.0746115, 0.102452, 1.06341, 0.984935, -0.0621822, 0.0852423, 1.07834, 0.987776, -0.0495694, 0.0678546, 1.092, 0.99103, -0.0372386, 0.0506917, 1.1043, 0.99474, -0.0244353, 0.0333316, 1.11576, 0.997768, -0.0121448, 0.0164348, 1.12617, 1.00003, 31774e-8, -169504e-9, 1.13598, 0.825551, -756799e-11, 0.378425, 165099e-10, 0.82664, -190922e-9, 0.378923, 416504e-9, 0.826323, -763495e-9, 0.378779, 16656e-7, 0.826359, -171789e-8, 0.378795, 374768e-8, 0.82636, -305402e-8, 0.378795, 666259e-8, 0.826368, -477185e-8, 0.378798, 0.0104104, 0.826364, -687131e-8, 0.378795, 0.0149912, 0.826368, -935232e-8, 0.378795, 0.0204054, 0.826376, -0.0122146, 0.378797, 0.0266532, 0.826399, -0.0154581, 0.378803, 0.0337355, 0.82646, -0.0190825, 0.378824, 0.0416537, 0.826525, -0.0230873, 0.378846, 0.0504091, 0.826614, -0.0274719, 0.378876, 0.0600032, 0.82674, -0.0322355, 0.378917, 0.0704393, 0.826888, -0.0373766, 0.378964, 0.0817195, 0.827078, -0.0428936, 0.379024, 0.0938492, 0.827318, -0.0487778, 0.379099, 0.106828, 0.82764, -0.0549935, 0.379199, 0.120659, 0.827926, -0.0611058, 0.379227, 0.13526, 0.828325, -0.0675054, 0.379275, 0.150713, 0.828801, -0.0743455, 0.379332, 0.167034, 0.8294, -0.0815523, 0.379415, 0.184209, 0.830094, -0.0890779, 0.379495, 0.202203, 0.8309, -0.096736, 0.379555, 0.220945, 0.831943, -0.104135, 0.379577, 0.240306, 0.833037, -0.112106, 0.379604, 0.260317, 0.834278, -0.120554, 0.379668, 0.2808, 0.836192, -0.129128, 0.3799, 0.301654, 0.838671, -0.137541, 0.380109, 0.323502, 0.840939, -0.14523, 0.379809, 0.347176, 0.844575, -0.15248, 0.379593, 0.371706, 0.848379, -0.159607, 0.37909, 0.39688, 0.853616, -0.166267, 0.378617, 0.422702, 0.858921, -0.172698, 0.377746, 0.448919, 0.865324, -0.178823, 0.376749, 0.475661, 0.872207, -0.184542, 0.375363, 0.502599, 0.880018, -0.189836, 0.373657, 0.529914, 0.88694, -0.194294, 0.370673, 0.557683, 0.894779, -0.197022, 0.36662, 0.586848, 0.902242, -0.199108, 0.36138, 0.615831, 0.909914, -0.200398, 0.355434, 0.644478, 0.917088, -0.20094, 0.348173, 0.672905, 0.923888, -0.200671, 0.339482, 0.701327, 0.930495, -0.198773, 0.32956, 0.730101, 0.937247, -0.195394, 0.318363, 0.758383, 0.943108, -0.191956, 0.306323, 0.786539, 0.948296, -0.187227, 0.292576, 0.813637, 0.953472, -0.181165, 0.278234, 0.840793, 0.958485, -0.174119, 0.263054, 0.867712, 0.962714, -0.166564, 0.246756, 0.893635, 0.966185, -0.158181, 0.229945, 0.919028, 0.970146, -0.148275, 0.212633, 0.943413, 0.973491, -0.138157, 0.195229, 0.966627, 0.975741, -0.127574, 0.178048, 0.988817, 0.977238, -0.11554, 0.160312, 1.00924, 0.978411, -0.10364, 0.142857, 1.02845, 0.979811, -0.0913122, 0.125317, 1.04648, 0.98116, -0.0782558, 0.107627, 1.06284, 0.983543, -0.0655957, 0.0895862, 1.07798, 0.986789, -0.0520411, 0.0713756, 1.092, 0.990292, -0.0389727, 0.053228, 1.10484, 0.994187, -0.025808, 0.0351945, 1.11642, 0.997499, -0.0126071, 0.0173198, 1.12703, 0.999999, 275604e-9, -148602e-9, 1.13674, 0.81075, -78735e-10, 0.394456, 161829e-10, 0.808692, -198293e-9, 0.393453, 407564e-9, 0.80846, -792877e-9, 0.39334, 162965e-8, 0.808595, -178416e-8, 0.393407, 366711e-8, 0.808597, -317182e-8, 0.393408, 651934e-8, 0.808598, -495589e-8, 0.393408, 0.0101866, 0.808591, -713627e-8, 0.393403, 0.0146689, 0.808592, -971285e-8, 0.393402, 0.0199667, 0.80861, -0.0126855, 0.393407, 0.0260803, 0.808633, -0.0160538, 0.393413, 0.0330107, 0.80868, -0.0198175, 0.393429, 0.0407589, 0.808748, -0.0239758, 0.393453, 0.0493264, 0.808854, -0.0285286, 0.39349, 0.0587161, 0.808992, -0.0334748, 0.39354, 0.0689304, 0.809141, -0.0388116, 0.393588, 0.0799707, 0.809352, -0.0445375, 0.39366, 0.0918432, 0.809608, -0.0506427, 0.393742, 0.104549, 0.809915, -0.0570708, 0.393834, 0.118085, 0.810253, -0.0633526, 0.393885, 0.132377, 0.810687, -0.0700966, 0.393953, 0.147537, 0.811233, -0.0772274, 0.394047, 0.163543, 0.811865, -0.0847629, 0.394148, 0.180394, 0.812648, -0.0925663, 0.394265, 0.198051, 0.813583, -0.100416, 0.394363, 0.216443, 0.814683, -0.108119, 0.394402, 0.235502, 0.815948, -0.11644, 0.394489, 0.255242, 0.817278, -0.125036, 0.394542, 0.275441, 0.819605, -0.133655, 0.39486, 0.296094, 0.822256, -0.142682, 0.395248, 0.317309, 0.825349, -0.150756, 0.395241, 0.340516, 0.829605, -0.158392, 0.395285, 0.364819, 0.83391, -0.165801, 0.394922, 0.389736, 0.839808, -0.172677, 0.394691, 0.415409, 0.845708, -0.179448, 0.394006, 0.441546, 0.853025, -0.185746, 0.393279, 0.46832, 0.859666, -0.191684, 0.391655, 0.495302, 0.86789, -0.197146, 0.390068, 0.52262, 0.875845, -0.201904, 0.38727, 0.550336, 0.882634, -0.205023, 0.382688, 0.578825, 0.891076, -0.207098, 0.377543, 0.608103, 0.900589, -0.208474, 0.371752, 0.63723, 0.90791, -0.209068, 0.364016, 0.665769, 0.915971, -0.208655, 0.355593, 0.694428, 0.923455, -0.20729, 0.345439, 0.723224, 0.931514, -0.203821, 0.334099, 0.751925, 0.937885, -0.19986, 0.321069, 0.780249, 0.943136, -0.194993, 0.306571, 0.8077, 0.948818, -0.189132, 0.291556, 0.83497, 0.954433, -0.181617, 0.275745, 0.86188, 0.959078, -0.173595, 0.258695, 0.888562, 0.962705, -0.164855, 0.240825, 0.914008, 0.966753, -0.155129, 0.22268, 0.939145, 0.970704, -0.144241, 0.204542, 0.963393, 0.973367, -0.133188, 0.185927, 0.985983, 0.975984, -0.121146, 0.167743, 1.00704, 0.976994, -0.108366, 0.149218, 1.02715, 0.978485, -0.0956746, 0.13131, 1.0455, 0.980074, -0.0820733, 0.112513, 1.06221, 0.98225, -0.0684061, 0.0938323, 1.07782, 0.98553, -0.0549503, 0.0749508, 1.09199, 0.989529, -0.0407857, 0.055848, 1.10508, 0.993536, -0.0271978, 0.0368581, 1.11684, 0.997247, -0.0132716, 0.0181845, 1.12789, 1, 431817e-9, -198809e-9, 1.13792, 0.785886, -812608e-11, 0.405036, 157669e-10, 0.790388, -205278e-9, 0.407355, 398297e-9, 0.790145, -820824e-9, 0.407231, 159263e-8, 0.790135, -184681e-8, 0.407226, 358336e-8, 0.790119, -328316e-8, 0.407218, 637039e-8, 0.790126, -512988e-8, 0.40722, 99539e-7, 0.79013, -738684e-8, 0.407221, 0.0143339, 0.790135, -0.0100538, 0.407221, 0.0195107, 0.790134, -0.0131306, 0.407217, 0.0254848, 0.79016, -0.0166169, 0.407224, 0.0322572, 0.790197, -0.020512, 0.407236, 0.0398284, 0.790273, -0.0248157, 0.407263, 0.0482014, 0.790381, -0.029527, 0.407304, 0.0573777, 0.790521, -0.0346446, 0.407355, 0.0673602, 0.790704, -0.0401665, 0.40742, 0.0781522, 0.790925, -0.0460896, 0.407499, 0.0897582, 0.791195, -0.0524017, 0.407589, 0.10218, 0.791522, -0.0590121, 0.407691, 0.11541, 0.791878, -0.0654876, 0.407748, 0.12939, 0.792361, -0.0725207, 0.407849, 0.144237, 0.792942, -0.0799844, 0.407963, 0.159924, 0.79362, -0.0877896, 0.408087, 0.176425, 0.794529, -0.0958451, 0.408259, 0.193733, 0.795521, -0.103827, 0.408362, 0.211756, 0.796778, -0.111937, 0.408482, 0.230524, 0.798027, -0.120521, 0.408547, 0.249967, 0.799813, -0.129242, 0.408721, 0.269926, 0.802387, -0.138048, 0.409148, 0.290338, 0.805279, -0.147301, 0.409641, 0.311193, 0.809251, -0.155895, 0.410154, 0.333611, 0.813733, -0.163942, 0.410297, 0.357615, 0.819081, -0.171666, 0.410373, 0.382339, 0.825427, -0.178905, 0.410348, 0.407828, 0.83172, -0.185812, 0.409486, 0.434034, 0.83877, -0.192318, 0.408776, 0.460493, 0.845817, -0.198249, 0.407176, 0.487346, 0.854664, -0.204034, 0.405719, 0.514832, 0.863495, -0.208908, 0.403282, 0.542401, 0.871883, -0.212765, 0.399293, 0.570683, 0.88065, -0.214911, 0.393803, 0.599947, 0.89004, -0.216214, 0.387536, 0.62932, 0.898476, -0.216745, 0.379846, 0.658319, 0.906738, -0.216387, 0.370625, 0.687138, 0.914844, -0.215053, 0.360139, 0.71601, 0.923877, -0.212007, 0.348849, 0.745124, 0.931925, -0.207481, 0.335639, 0.773366, 0.938054, -0.202418, 0.320798, 0.801636, 0.943895, -0.196507, 0.304772, 0.829055, 0.949468, -0.189009, 0.288033, 0.856097, 0.955152, -0.180539, 0.270532, 0.88301, 0.959403, -0.171437, 0.251639, 0.909296, 0.963309, -0.161661, 0.232563, 0.934868, 0.967399, -0.150425, 0.213231, 0.959662, 0.972009, -0.138659, 0.194247, 0.98302, 0.97433, -0.126595, 0.174718, 1.00517, 0.975823, -0.113205, 0.155518, 1.02566, 0.976371, -0.0996096, 0.136709, 1.04418, 0.978705, -0.0860754, 0.117571, 1.06146, 0.981477, -0.0714438, 0.0980046, 1.07777, 0.984263, -0.0572304, 0.0782181, 1.09214, 0.988423, -0.0428875, 0.0584052, 1.10553, 0.993, -0.0282442, 0.038522, 1.11758, 0.99704, -0.0140183, 0.0190148, 1.12864, 0.999913, 369494e-9, -145203e-9, 1.13901, 0.777662, -84153e-10, 0.423844, 154403e-10, 0.770458, -211714e-9, 0.419915, 38845e-8, 0.770716, -846888e-9, 0.420055, 155386e-8, 0.770982, -190567e-8, 0.420202, 349653e-8, 0.770981, -338782e-8, 0.420201, 621606e-8, 0.77098, -529338e-8, 0.4202, 971274e-8, 0.770983, -762223e-8, 0.4202, 0.0139867, 0.770985, -0.0103741, 0.420198, 0.0190381, 0.770996, -0.0135489, 0.4202, 0.0248677, 0.771029, -0.0171461, 0.420212, 0.0314764, 0.771052, -0.0211647, 0.420215, 0.0388648, 0.771131, -0.0256048, 0.420245, 0.047036, 0.771235, -0.0304647, 0.420284, 0.0559911, 0.771383, -0.0357436, 0.420341, 0.0657346, 0.771591, -0.0414392, 0.420423, 0.0762694, 0.771819, -0.0475462, 0.420506, 0.0875984, 0.772123, -0.0540506, 0.420617, 0.099727, 0.772464, -0.060797, 0.42072, 0.112637, 0.772855, -0.0675393, 0.420799, 0.126313, 0.773317, -0.0748323, 0.420893, 0.140824, 0.773981, -0.0825681, 0.421058, 0.15617, 0.774746, -0.0906307, 0.421226, 0.172322, 0.77566, -0.0988982, 0.421397, 0.189253, 0.776837, -0.106994, 0.421569, 0.206912, 0.778097, -0.115528, 0.421704, 0.225359, 0.779588, -0.124317, 0.421849, 0.24447, 0.781574, -0.133139, 0.422097, 0.264156, 0.784451, -0.142179, 0.422615, 0.284318, 0.787682, -0.15165, 0.423269, 0.304902, 0.792433, -0.160771, 0.424396, 0.3265, 0.797359, -0.169166, 0.424772, 0.35014, 0.803986, -0.177149, 0.425475, 0.374768, 0.809504, -0.184745, 0.424996, 0.399928, 0.815885, -0.19173, 0.424247, 0.425796, 0.823513, -0.198525, 0.423515, 0.452287, 0.832549, -0.204709, 0.422787, 0.479321, 0.841653, -0.210447, 0.421187, 0.506718, 0.850401, -0.215501, 0.418519, 0.53432, 0.859854, -0.219752, 0.414715, 0.56242, 0.869364, -0.222305, 0.409462, 0.591558, 0.878837, -0.223744, 0.402926, 0.621074, 0.888636, -0.224065, 0.395043, 0.650538, 0.898132, -0.223742, 0.38564, 0.679538, 0.907181, -0.222308, 0.375378, 0.708674, 0.915621, -0.219837, 0.363212, 0.737714, 0.9239, -0.215233, 0.349313, 0.767014, 0.931644, -0.209592, 0.334162, 0.795133, 0.938887, -0.203644, 0.317943, 0.823228, 0.945282, -0.196349, 0.300581, 0.850822, 0.950758, -0.18742, 0.282195, 0.877594, 0.956146, -0.177879, 0.262481, 0.904564, 0.960355, -0.167643, 0.242487, 0.930741, 0.965256, -0.156671, 0.222668, 0.955868, 0.968029, -0.144123, 0.201907, 0.979869, 0.97251, -0.131305, 0.18202, 1.00291, 0.974925, -0.118335, 0.161909, 1.02392, 0.975402, -0.103714, 0.142129, 1.0433, 0.976987, -0.089415, 0.122447, 1.06089, 0.979677, -0.0748858, 0.102248, 1.07713, 0.983184, -0.0596086, 0.0814851, 1.09218, 0.987466, -0.0447671, 0.0609484, 1.10585, 0.992348, -0.0295217, 0.0401835, 1.11829, 0.996674, -0.0143917, 0.0198163, 1.12966, 1.00003, 321364e-9, -149983e-9, 1.1402, 0.757901, -869074e-11, 0.436176, 151011e-10, 0.751195, -217848e-9, 0.432317, 378533e-9, 0.751178, -871373e-9, 0.432307, 15141e-7, 0.751195, -196061e-8, 0.432317, 34068e-7, 0.751198, -348552e-8, 0.432318, 605659e-8, 0.751195, -544599e-8, 0.432315, 946353e-8, 0.751207, -784203e-8, 0.43232, 0.013628, 0.751213, -0.0106732, 0.43232, 0.0185499, 0.751221, -0.0139393, 0.432319, 0.0242302, 0.751244, -0.0176398, 0.432325, 0.0306694, 0.7513, -0.0217743, 0.432348, 0.0378698, 0.751358, -0.0263412, 0.432367, 0.0458321, 0.751458, -0.0313396, 0.432404, 0.0545587, 0.751608, -0.0367682, 0.432464, 0.0640543, 0.7518, -0.0426246, 0.43254, 0.0743222, 0.752065, -0.0489031, 0.432645, 0.0853668, 0.752376, -0.0555828, 0.432762, 0.0971911, 0.752715, -0.0623861, 0.432859, 0.109768, 0.753137, -0.069415, 0.432958, 0.123126, 0.753676, -0.0770039, 0.433099, 0.137308, 0.754345, -0.084971, 0.433272, 0.15229, 0.755235, -0.0932681, 0.433504, 0.168075, 0.756186, -0.10171, 0.433693, 0.184625, 0.757363, -0.110019, 0.433857, 0.201897, 0.75884, -0.11887, 0.434102, 0.220014, 0.760467, -0.127881, 0.434306, 0.238778, 0.762969, -0.136766, 0.434751, 0.258172, 0.765823, -0.14612, 0.43529, 0.278062, 0.769676, -0.15566, 0.436236, 0.298437, 0.774909, -0.165177, 0.437754, 0.319532, 0.77994, -0.17402, 0.438343, 0.342505, 0.785757, -0.182201, 0.438609, 0.366693, 0.792487, -0.190104, 0.438762, 0.391668, 0.80038, -0.197438, 0.438795, 0.417494, 0.808494, -0.204365, 0.438226, 0.443933, 0.817695, -0.210714, 0.437283, 0.470929, 0.828111, -0.216651, 0.436087, 0.498569, 0.837901, -0.221804, 0.433717, 0.526165, 0.847813, -0.226318, 0.430133, 0.554155, 0.858314, -0.229297, 0.425213, 0.582822, 0.868891, -0.230999, 0.418576, 0.612847, 0.878941, -0.231155, 0.410405, 0.642445, 0.888809, -0.230935, 0.400544, 0.672024, 0.898089, -0.229343, 0.389613, 0.701366, 0.908081, -0.226886, 0.377197, 0.730763, 0.916819, -0.222676, 0.363397, 0.759642, 0.924968, -0.216835, 0.347437, 0.788775, 0.932906, -0.210245, 0.32995, 0.817135, 0.940025, -0.202992, 0.312262, 0.844912, 0.946101, -0.19436, 0.293313, 0.872164, 0.952835, -0.184125, 0.273638, 0.899443, 0.957347, -0.173657, 0.252385, 0.926389, 0.961434, -0.162204, 0.231038, 0.951947, 0.965522, -0.14979, 0.209834, 0.976751, 0.969412, -0.136307, 0.188821, 1.00022, 0.973902, -0.122527, 0.168013, 1.02229, 0.974045, -0.108213, 0.147634, 1.04199, 0.975775, -0.0927397, 0.12705, 1.06019, 0.978383, -0.0778212, 0.106309, 1.07711, 0.98211, -0.0621216, 0.0849279, 1.09245, 0.986517, -0.0463847, 0.0633519, 1.10651, 0.991696, -0.0309353, 0.0419698, 1.11903, 0.996349, -0.0150914, 0.0206272, 1.13073, 1.00003, 442449e-9, -231396e-9, 1.14146, 0.727498, -885074e-11, 0.441528, 145832e-10, 0.730897, -223525e-9, 0.443589, 368298e-9, 0.730796, -893996e-9, 0.443528, 147303e-8, 0.730805, -201149e-8, 0.443533, 331433e-8, 0.730814, -357596e-8, 0.443538, 589222e-8, 0.730815, -558734e-8, 0.443538, 920678e-8, 0.730822, -804544e-8, 0.44354, 0.0132582, 0.730836, -0.0109501, 0.443545, 0.0180468, 0.730848, -0.0143008, 0.443546, 0.0235732, 0.730871, -0.0180969, 0.443552, 0.0298382, 0.730915, -0.022338, 0.443567, 0.0368438, 0.730982, -0.0270225, 0.443591, 0.044591, 0.731076, -0.0321491, 0.443627, 0.0530831, 0.731245, -0.0377166, 0.443699, 0.0623243, 0.73144, -0.0437216, 0.443777, 0.0723181, 0.7317, -0.0501576, 0.443881, 0.0830691, 0.732034, -0.0569942, 0.444014, 0.0945809, 0.732388, -0.0638756, 0.444113, 0.106825, 0.732853, -0.071203, 0.444247, 0.119859, 0.733473, -0.0790076, 0.444442, 0.13369, 0.734195, -0.0871937, 0.444645, 0.148304, 0.735069, -0.095696, 0.444877, 0.163702, 0.736169, -0.10426, 0.445133, 0.179861, 0.73747, -0.112853, 0.44537, 0.196778, 0.738991, -0.12199, 0.445651, 0.214496, 0.740865, -0.131153, 0.445958, 0.232913, 0.743637, -0.140245, 0.446548, 0.251977, 0.746797, -0.149722, 0.447246, 0.271551, 0.751517, -0.159341, 0.448656, 0.291774, 0.756156, -0.169106, 0.449866, 0.312455, 0.761519, -0.178436, 0.450919, 0.334552, 0.768295, -0.186904, 0.451776, 0.358491, 0.776613, -0.195117, 0.452832, 0.383446, 0.783966, -0.202695, 0.45249, 0.408945, 0.793542, -0.20985, 0.452587, 0.435364, 0.803192, -0.216403, 0.451852, 0.462336, 0.813892, -0.22251, 0.450708, 0.48987, 0.824968, -0.227676, 0.4486, 0.517697, 0.835859, -0.232443, 0.445156, 0.545975, 0.846825, -0.235775, 0.440351, 0.574483, 0.858085, -0.237897, 0.433641, 0.604246, 0.868825, -0.238074, 0.425354, 0.634101, 0.879638, -0.237661, 0.415383, 0.664201, 0.889966, -0.236186, 0.404136, 0.693918, 0.899479, -0.233599, 0.390917, 0.723481, 0.908769, -0.229737, 0.376352, 0.75258, 0.917966, -0.223836, 0.360372, 0.781764, 0.926304, -0.217067, 0.342551, 0.811139, 0.934626, -0.209309, 0.324238, 0.839585, 0.941841, -0.20071, 0.304484, 0.867044, 0.94789, -0.190602, 0.283607, 0.894579, 0.954196, -0.179253, 0.262205, 0.921743, 0.958383, -0.167646, 0.239847, 0.948026, 0.963119, -0.155073, 0.218078, 0.973296, 0.966941, -0.141426, 0.195899, 0.998135, 0.970836, -0.126849, 0.174121, 1.02021, 0.973301, -0.112296, 0.153052, 1.04085, 0.97448, -0.0964965, 0.131733, 1.05946, 0.977045, -0.080489, 0.10997, 1.07693, 0.980751, -0.064844, 0.0881657, 1.09254, 0.985475, -0.0481938, 0.0657987, 1.10697, 0.991089, -0.0319185, 0.0435215, 1.12004, 0.996122, -0.0158088, 0.0214779, 1.13173, 1.00001, 372455e-9, -200295e-9, 1.14291, 0.708622, -907597e-11, 0.45304, 141962e-10, 0.711162, -228911e-9, 0.454662, 358052e-9, 0.709812, -914446e-9, 0.453797, 143034e-8, 0.709865, -205819e-8, 0.453834, 321935e-8, 0.709864, -365894e-8, 0.453833, 572331e-8, 0.709855, -571692e-8, 0.453826, 894278e-8, 0.709862, -823201e-8, 0.453828, 0.012878, 0.709875, -0.011204, 0.453832, 0.0175295, 0.709896, -0.0146323, 0.453839, 0.0228978, 0.709925, -0.0185163, 0.453847, 0.0289839, 0.709974, -0.0228551, 0.453866, 0.0357894, 0.710045, -0.0276473, 0.453892, 0.0433161, 0.710133, -0.032891, 0.453924, 0.0515665, 0.710292, -0.0385851, 0.453992, 0.0605458, 0.710485, -0.0447254, 0.45407, 0.0702574, 0.710769, -0.0513051, 0.454192, 0.0807077, 0.711106, -0.0582733, 0.454329, 0.091896, 0.711516, -0.0652866, 0.45446, 0.103814, 0.712071, -0.0728426, 0.454653, 0.116508, 0.712676, -0.0808307, 0.45484, 0.129968, 0.713476, -0.0892216, 0.455096, 0.144206, 0.714377, -0.0979047, 0.455346, 0.159212, 0.715579, -0.106531, 0.455647, 0.174973, 0.716977, -0.115492, 0.455961, 0.191504, 0.71862, -0.124821, 0.456315, 0.208835, 0.72084, -0.134079, 0.4568, 0.226869, 0.723786, -0.143427, 0.457521, 0.245582, 0.727464, -0.153061, 0.458475, 0.264957, 0.732771, -0.162768, 0.460239, 0.284948, 0.736515, -0.172627, 0.460899, 0.30522, 0.743519, -0.182487, 0.463225, 0.326717, 0.750041, -0.191295, 0.464027, 0.350113, 0.758589, -0.199746, 0.465227, 0.374782, 0.767703, -0.207584, 0.465877, 0.400226, 0.777484, -0.214973, 0.465996, 0.426442, 0.788792, -0.221796, 0.466019, 0.453688, 0.800194, -0.228038, 0.465083, 0.481246, 0.811234, -0.233346, 0.462506, 0.509086, 0.822859, -0.238073, 0.459257, 0.537338, 0.835082, -0.241764, 0.454863, 0.566108, 0.846332, -0.244241, 0.448163, 0.595126, 0.858355, -0.244736, 0.439709, 0.625574, 0.87034, -0.244278, 0.429837, 0.65617, 0.881027, -0.24255, 0.418002, 0.686029, 0.891007, -0.239912, 0.404325, 0.716039, 0.900874, -0.236133, 0.389222, 0.745518, 0.911072, -0.230672, 0.373269, 0.775026, 0.920359, -0.22356, 0.355083, 0.804521, 0.928604, -0.215591, 0.335533, 0.834045, 0.937175, -0.206503, 0.315278, 0.861612, 0.942825, -0.196684, 0.293653, 0.889131, 0.949805, -0.185116, 0.271503, 0.916853, 0.955535, -0.172703, 0.248821, 0.943541, 0.959843, -0.159978, 0.225591, 0.970132, 0.964393, -0.146375, 0.202719, 0.994709, 0.968008, -0.131269, 0.179928, 1.0186, 0.971013, -0.11569, 0.158007, 1.03928, 0.973334, -0.1003, 0.13624, 1.05887, 0.975775, -0.0833352, 0.1138, 1.07652, 0.979579, -0.0668981, 0.0913141, 1.09297, 0.984323, -0.0500902, 0.0683051, 1.10734, 0.990351, -0.0332377, 0.0451771, 1.12084, 0.995823, -0.0161491, 0.0221705, 1.13296, 1.0001, 234083e-9, -108712e-9, 1.14441, 0.683895, -924677e-11, 0.46015, 137429e-10, 0.68833, -233383e-9, 0.463134, 346865e-9, 0.688368, -933547e-9, 0.463159, 138748e-8, 0.688367, -210049e-8, 0.463159, 312187e-8, 0.688369, -373415e-8, 0.463159, 555004e-8, 0.688377, -583449e-8, 0.463163, 867216e-8, 0.688386, -840128e-8, 0.463166, 0.0124884, 0.688398, -0.0114343, 0.463169, 0.0169993, 0.688418, -0.0149329, 0.463175, 0.0222054, 0.688453, -0.0188964, 0.463188, 0.028108, 0.688515, -0.0233239, 0.463214, 0.0347085, 0.68857, -0.0282136, 0.463231, 0.0420091, 0.688679, -0.033564, 0.463276, 0.0500132, 0.688854, -0.0393733, 0.463356, 0.0587255, 0.689038, -0.0456354, 0.46343, 0.0681476, 0.689321, -0.0523433, 0.463553, 0.0782897, 0.689662, -0.059412, 0.463693, 0.0891501, 0.690188, -0.0665736, 0.4639, 0.100735, 0.690755, -0.0743106, 0.464107, 0.113074, 0.691405, -0.0824722, 0.464329, 0.126161, 0.692198, -0.0910484, 0.464585, 0.140007, 0.693196, -0.0998778, 0.464893, 0.154612, 0.69454, -0.108651, 0.465285, 0.169984, 0.695921, -0.117855, 0.465596, 0.186106, 0.697749, -0.12734, 0.466056, 0.203034, 0.700375, -0.136714, 0.466771, 0.220703, 0.703395, -0.146386, 0.467579, 0.239062, 0.707904, -0.156096, 0.469067, 0.258188, 0.711673, -0.165904, 0.469851, 0.277759, 0.717489, -0.175812, 0.471815, 0.297935, 0.724051, -0.185931, 0.47389, 0.318916, 0.731965, -0.195238, 0.47587, 0.341591, 0.741151, -0.204021, 0.477523, 0.366062, 0.751416, -0.212113, 0.478881, 0.391396, 0.761848, -0.21979, 0.479226, 0.417599, 0.771886, -0.2267, 0.478495, 0.444401, 0.783998, -0.232991, 0.477622, 0.472084, 0.796523, -0.238645, 0.475833, 0.500193, 0.808851, -0.243396, 0.472568, 0.52865, 0.821191, -0.247226, 0.467857, 0.557362, 0.834261, -0.250102, 0.461871, 0.586768, 0.846762, -0.251056, 0.453543, 0.617085, 0.859867, -0.250604, 0.443494, 0.647659, 0.871948, -0.248783, 0.431711, 0.678119, 0.882967, -0.245855, 0.417911, 0.708399, 0.892826, -0.242168, 0.401993, 0.738256, 0.90332, -0.237062, 0.385371, 0.767999, 0.913633, -0.22997, 0.366837, 0.798191, 0.922774, -0.221687, 0.346372, 0.827756, 0.931371, -0.212345, 0.325682, 0.856425, 0.938929, -0.20206, 0.303665, 0.884299, 0.944821, -0.190981, 0.280786, 0.912023, 0.951792, -0.178065, 0.2573, 0.939669, 0.957712, -0.164634, 0.233448, 0.96655, 0.961912, -0.150863, 0.209504, 0.992366, 0.966382, -0.13577, 0.18597, 1.01633, 0.969588, -0.119593, 0.162905, 1.03843, 0.971777, -0.103203, 0.14053, 1.05841, 0.97433, -0.0865888, 0.117909, 1.07632, 0.978686, -0.0690829, 0.0944101, 1.09326, 0.983281, -0.0516568, 0.0705671, 1.10796, 0.989562, -0.034558, 0.0468592, 1.12182, 0.995465, -0.0167808, 0.0229846, 1.1342, 0.999991, 373016e-9, -235606e-9, 1.1459, 0.662251, -939016e-11, 0.468575, 132714e-10, 0.666634, -237624e-9, 0.471675, 335842e-9, 0.666411, -950385e-9, 0.471516, 134321e-8, 0.666399, -213833e-8, 0.471509, 302221e-8, 0.666386, -38014e-7, 0.471499, 537283e-8, 0.666405, -593958e-8, 0.471511, 839533e-8, 0.666406, -855253e-8, 0.471508, 0.0120898, 0.666428, -0.0116401, 0.471519, 0.0164569, 0.666444, -0.0152015, 0.471522, 0.0214971, 0.66649, -0.0192362, 0.471543, 0.027212, 0.666537, -0.0237428, 0.471558, 0.033603, 0.666617, -0.0287198, 0.471591, 0.0406728, 0.666718, -0.0341647, 0.471631, 0.0484238, 0.666889, -0.0400759, 0.47171, 0.0568621, 0.667104, -0.0464479, 0.471805, 0.0659915, 0.667374, -0.0532677, 0.471923, 0.0758178, 0.667772, -0.0603805, 0.472098, 0.0863425, 0.668371, -0.0677392, 0.472363, 0.0975917, 0.668971, -0.0756028, 0.472596, 0.109567, 0.669696, -0.0839293, 0.472869, 0.122272, 0.670481, -0.0926683, 0.473126, 0.135718, 0.6715, -0.1016, 0.473442, 0.149914, 0.672911, -0.110566, 0.47389, 0.164882, 0.674512, -0.119984, 0.474354, 0.180602, 0.67651, -0.129574, 0.474922, 0.19711, 0.679292, -0.139106, 0.475764, 0.214371, 0.682798, -0.148993, 0.476886, 0.232405, 0.686955, -0.158737, 0.478179, 0.251153, 0.691406, -0.168754, 0.479432, 0.270436, 0.697438, -0.178703, 0.481481, 0.290374, 0.704761, -0.188955, 0.484143, 0.311044, 0.713599, -0.198814, 0.487007, 0.333003, 0.723194, -0.207869, 0.488962, 0.357144, 0.732601, -0.216189, 0.489815, 0.382169, 0.744193, -0.22398, 0.490888, 0.408227, 0.754907, -0.231156, 0.490355, 0.434928, 0.767403, -0.23747, 0.489548, 0.462599, 0.78107, -0.243503, 0.488274, 0.490908, 0.793893, -0.248114, 0.484843, 0.519421, 0.807296, -0.25222, 0.4803, 0.548561, 0.820529, -0.255265, 0.474097, 0.577772, 0.833716, -0.256741, 0.466041, 0.607782, 0.848403, -0.25637, 0.456547, 0.638807, 0.860755, -0.254804, 0.443946, 0.670058, 0.874012, -0.251834, 0.430852, 0.700749, 0.885619, -0.247867, 0.414903, 0.731446, 0.896069, -0.242634, 0.397276, 0.761191, 0.906266, -0.236093, 0.378535, 0.791053, 0.916759, -0.227543, 0.358038, 0.821298, 0.92523, -0.21783, 0.335705, 0.850747, 0.93436, -0.207534, 0.313797, 0.879258, 0.941631, -0.195983, 0.289671, 0.907734, 0.947564, -0.183567, 0.265319, 0.935206, 0.953681, -0.169345, 0.240815, 0.962739, 0.960008, -0.154909, 0.216119, 0.989227, 0.964145, -0.140161, 0.192096, 1.01465, 0.968171, -0.123411, 0.167855, 1.03737, 0.969859, -0.106525, 0.144817, 1.05767, 0.972666, -0.0891023, 0.12149, 1.0761, 0.977055, -0.0718094, 0.0975306, 1.09336, 0.982527, -0.0534213, 0.0730217, 1.10878, 0.989001, -0.0355579, 0.0483366, 1.12285, 0.99512, -0.0176383, 0.023938, 1.13548, 1.00007, 368831e-9, -211581e-9, 1.14744, 0.651047, -960845e-11, 0.484101, 12922e-9, 0.644145, -241347e-9, 0.478968, 324578e-9, 0.64396, -965142e-9, 0.478831, 129798e-8, 0.64396, -217154e-8, 0.47883, 292046e-8, 0.643968, -386049e-8, 0.478835, 519202e-8, 0.643974, -603186e-8, 0.478838, 81128e-7, 0.643977, -86854e-7, 0.478836, 0.011683, 0.643982, -0.0118207, 0.478834, 0.0159031, 0.644024, -0.0154374, 0.478856, 0.0207743, 0.644059, -0.0195343, 0.478868, 0.0262975, 0.644122, -0.0241103, 0.478896, 0.0324747, 0.644207, -0.0291638, 0.478933, 0.039309, 0.64432, -0.0346919, 0.478981, 0.0468029, 0.644481, -0.0406919, 0.479053, 0.0549614, 0.644722, -0.047159, 0.479169, 0.0637909, 0.645013, -0.0540748, 0.479302, 0.0732974, 0.645503, -0.0612001, 0.479541, 0.0834898, 0.646117, -0.0687303, 0.479829, 0.0943873, 0.646707, -0.0767846, 0.480061, 0.105991, 0.647431, -0.0852465, 0.480343, 0.11831, 0.64831, -0.0940719, 0.48066, 0.131348, 0.649486, -0.103056, 0.481083, 0.14514, 0.650864, -0.112261, 0.481528, 0.159676, 0.652604, -0.121852, 0.482102, 0.174979, 0.654825, -0.131505, 0.482813, 0.191079, 0.657876, -0.141189, 0.483876, 0.207927, 0.661339, -0.151239, 0.48499, 0.225586, 0.665463, -0.161091, 0.486279, 0.243947, 0.670542, -0.171235, 0.487968, 0.262957, 0.677361, -0.181347, 0.49053, 0.282781, 0.685672, -0.191679, 0.493862, 0.303311, 0.694551, -0.201781, 0.49699, 0.324607, 0.703753, -0.211164, 0.498884, 0.347916, 0.713703, -0.219675, 0.500086, 0.372628, 0.725911, -0.227836, 0.501554, 0.398694, 0.73862, -0.23533, 0.502193, 0.425529, 0.752118, -0.241786, 0.501811, 0.453209, 0.76579, -0.247865, 0.500185, 0.481381, 0.779568, -0.252696, 0.497159, 0.51011, 0.793991, -0.256802, 0.492765, 0.539322, 0.808182, -0.259942, 0.486827, 0.569078, 0.821698, -0.261703, 0.478386, 0.598818, 0.836009, -0.262006, 0.468772, 0.629762, 0.849824, -0.260333, 0.456352, 0.661366, 0.863888, -0.257398, 0.442533, 0.69295, 0.876585, -0.253264, 0.426573, 0.723608, 0.888665, -0.248026, 0.408964, 0.754378, 0.899537, -0.241487, 0.389677, 0.784761, 0.9094, -0.233463, 0.368516, 0.814688, 0.920166, -0.223397, 0.346624, 0.845009, 0.928899, -0.21255, 0.322717, 0.874431, 0.937156, -0.200869, 0.298698, 0.902922, 0.943861, -0.188387, 0.273491, 0.931356, 0.949557, -0.174341, 0.247866, 0.958854, 0.955862, -0.158994, 0.222496, 0.986098, 0.961721, -0.143664, 0.197522, 1.01229, 0.965976, -0.127412, 0.17302, 1.03571, 0.968652, -0.109798, 0.148954, 1.05699, 0.971084, -0.0916787, 0.125044, 1.07587, 0.975584, -0.0739634, 0.100577, 1.09372, 0.98122, -0.055322, 0.0753666, 1.10948, 0.988253, -0.0366825, 0.0498899, 1.12394, 0.99482, -0.0180389, 0.024611, 1.13694, 1.00001, 229839e-9, -188283e-9, 1.14919, 0.613867, -964198e-11, 0.479449, 123452e-10, 0.621485, -244534e-9, 0.485399, 313091e-9, 0.621429, -978202e-9, 0.485353, 125245e-8, 0.62112, -220004e-8, 0.485114, 281687e-8, 0.621119, -39111e-7, 0.485112, 500783e-8, 0.621122, -611091e-8, 0.485112, 782498e-8, 0.621133, -879922e-8, 0.485117, 0.0112687, 0.621152, -0.0119756, 0.485125, 0.0153394, 0.621183, -0.0156396, 0.485139, 0.0200382, 0.621227, -0.0197898, 0.485158, 0.0253663, 0.621298, -0.0244253, 0.485192, 0.0313261, 0.621388, -0.0295441, 0.485233, 0.0379204, 0.621507, -0.0351432, 0.485286, 0.0451523, 0.621693, -0.0412198, 0.485378, 0.0530277, 0.621933, -0.0477673, 0.485495, 0.0615522, 0.622232, -0.0547574, 0.485635, 0.0707316, 0.622809, -0.0619417, 0.485943, 0.0805883, 0.623407, -0.069625, 0.486232, 0.0911267, 0.62406, -0.077796, 0.486516, 0.102354, 0.624835, -0.0863731, 0.486838, 0.114279, 0.625758, -0.095251, 0.487188, 0.126902, 0.627043, -0.104299, 0.487695, 0.140285, 0.628438, -0.113724, 0.488163, 0.154397, 0.630325, -0.123417, 0.488858, 0.169267, 0.632801, -0.133137, 0.489754, 0.184941, 0.635784, -0.143052, 0.490815, 0.20136, 0.639406, -0.153132, 0.492048, 0.218643, 0.643872, -0.163143, 0.49363, 0.236615, 0.6499, -0.17333, 0.496009, 0.255449, 0.657201, -0.183622, 0.498994, 0.275006, 0.666221, -0.194019, 0.502888, 0.295354, 0.674419, -0.204192, 0.505459, 0.316244, 0.683729, -0.21406, 0.507771, 0.33849, 0.695584, -0.222854, 0.510245, 0.363166, 0.708583, -0.231315, 0.512293, 0.389071, 0.721233, -0.238911, 0.512747, 0.415737, 0.735134, -0.245657, 0.512482, 0.443331, 0.750179, -0.251879, 0.511526, 0.471891, 0.765073, -0.256911, 0.508935, 0.500892, 0.779794, -0.261144, 0.504341, 0.530294, 0.794801, -0.264316, 0.498515, 0.560144, 0.810339, -0.266276, 0.491015, 0.590213, 0.824818, -0.266981, 0.481126, 0.620865, 0.839375, -0.265778, 0.468685, 0.652687, 0.853043, -0.262748, 0.453925, 0.684759, 0.867335, -0.258474, 0.437912, 0.716209, 0.88037, -0.253187, 0.419648, 0.747508, 0.891711, -0.246476, 0.39982, 0.77797, 0.902896, -0.238735, 0.37879, 0.808586, 0.913601, -0.22885, 0.355891, 0.838843, 0.923019, -0.217656, 0.331773, 0.869014, 0.933432, -0.205539, 0.307356, 0.898512, 0.939691, -0.192595, 0.281321, 0.9269, 0.946938, -0.178945, 0.255441, 0.955297, 0.952372, -0.163587, 0.229013, 0.983231, 0.95909, -0.147214, 0.203179, 1.00971, 0.963675, -0.13064, 0.17792, 1.03438, 0.968247, -0.113121, 0.152898, 1.05625, 0.97001, -0.0945824, 0.128712, 1.07598, 0.974458, -0.0755648, 0.103349, 1.094, 0.980168, -0.0571998, 0.0776731, 1.1104, 0.987295, -0.0377994, 0.0514445, 1.12491, 0.994432, -0.0186417, 0.025429, 1.13851, 0.999975, 542714e-9, -282356e-9, 1.15108, 0.592656, -980249e-11, 0.486018, 119532e-10, 0.598467, -247275e-9, 0.490781, 301531e-9, 0.597934, -988317e-9, 0.490343, 120517e-8, 0.597903, -222366e-8, 0.490319, 27116e-7, 0.597913, -395315e-8, 0.490327, 482077e-8, 0.597919, -617653e-8, 0.490329, 753264e-8, 0.597936, -889375e-8, 0.490339, 0.0108478, 0.597956, -0.0121043, 0.490347, 0.0147668, 0.597992, -0.0158073, 0.490365, 0.0192905, 0.598032, -0.0200017, 0.490382, 0.0244204, 0.598109, -0.0246865, 0.49042, 0.0301593, 0.598215, -0.0298594, 0.490474, 0.03651, 0.59833, -0.0355167, 0.490524, 0.0434757, 0.598525, -0.0416559, 0.490624, 0.0510629, 0.598778, -0.0482692, 0.490753, 0.0592781, 0.599135, -0.0553114, 0.49094, 0.0681304, 0.599802, -0.062542, 0.491328, 0.0776467, 0.600361, -0.0703638, 0.491598, 0.0878184, 0.60101, -0.0786256, 0.491882, 0.0986573, 0.601811, -0.0872962, 0.492232, 0.11018, 0.602861, -0.0962284, 0.492684, 0.1224, 0.604167, -0.10538, 0.493213, 0.135354, 0.605693, -0.114896, 0.493799, 0.149034, 0.607682, -0.124654, 0.494576, 0.163469, 0.610672, -0.13456, 0.4959, 0.178747, 0.613313, -0.144581, 0.496713, 0.194723, 0.617603, -0.154703, 0.498499, 0.211617, 0.622174, -0.16489, 0.500188, 0.229183, 0.628855, -0.175164, 0.503072, 0.247786, 0.636963, -0.185565, 0.506798, 0.267116, 0.644866, -0.195911, 0.509719, 0.28702, 0.653741, -0.206104, 0.512776, 0.307763, 0.664942, -0.216447, 0.516812, 0.329631, 0.67633, -0.22552, 0.519181, 0.353515, 0.690012, -0.234316, 0.521681, 0.379226, 0.704243, -0.242032, 0.523129, 0.405901, 0.719396, -0.249172, 0.523768, 0.433585, 0.734471, -0.255543, 0.522541, 0.462085, 0.750539, -0.260697, 0.520217, 0.491233, 0.766365, -0.26501, 0.516293, 0.521094, 0.781677, -0.268409, 0.509708, 0.551014, 0.797132, -0.270399, 0.501944, 0.581463, 0.812655, -0.271247, 0.492025, 0.612402, 0.828592, -0.270708, 0.480424, 0.643798, 0.844044, -0.268085, 0.465955, 0.67682, 0.857305, -0.263459, 0.448425, 0.708496, 0.87114, -0.258151, 0.430243, 0.74046, 0.884936, -0.251171, 0.410578, 0.771583, 0.895772, -0.243305, 0.38862, 0.802234, 0.906961, -0.234037, 0.365214, 0.833179, 0.917775, -0.222714, 0.34116, 0.86353, 0.927883, -0.210175, 0.31572, 0.893557, 0.936617, -0.196925, 0.289159, 0.922976, 0.943384, -0.182788, 0.261996, 0.951606, 0.949713, -0.167965, 0.235324, 0.979958, 0.955818, -0.151109, 0.208408, 1.00765, 0.961344, -0.133834, 0.182591, 1.03329, 0.965469, -0.115987, 0.156958, 1.0557, 0.968693, -0.09746, 0.132239, 1.07583, 0.973165, -0.0778514, 0.106195, 1.09451, 0.979387, -0.0585067, 0.0797669, 1.11137, 0.98671, -0.0390409, 0.0530263, 1.12643, 0.994093, -0.019408, 0.0263163, 1.14016, 1.00002, 540029e-9, -194487e-9, 1.15299, 0.574483, -989066e-11, 0.494533, 114896e-10, 0.574478, -249127e-9, 0.494528, 289403e-9, 0.574607, -996811e-9, 0.494637, 115797e-8, 0.574396, -224241e-8, 0.494458, 260498e-8, 0.574377, -398632e-8, 0.49444, 463102e-8, 0.574386, -622836e-8, 0.494445, 723623e-8, 0.574401, -89683e-7, 0.494453, 0.010421, 0.574419, -0.0122056, 0.49446, 0.0141859, 0.574459, -0.0159396, 0.494481, 0.0185322, 0.574525, -0.0201692, 0.49452, 0.0234617, 0.574587, -0.0248924, 0.494547, 0.0289762, 0.574697, -0.0301074, 0.494604, 0.0350797, 0.574853, -0.0358114, 0.494688, 0.0417767, 0.575027, -0.041999, 0.494772, 0.0490718, 0.575294, -0.0486618, 0.494915, 0.0569728, 0.575733, -0.0557148, 0.495173, 0.0654955, 0.576356, -0.0630489, 0.495537, 0.0746612, 0.576944, -0.0709285, 0.495836, 0.0844615, 0.57765, -0.0792723, 0.496177, 0.0949142, 0.578491, -0.0880167, 0.496563, 0.10603, 0.579639, -0.0969462, 0.497096, 0.117841, 0.580989, -0.10622, 0.497684, 0.130367, 0.582587, -0.115861, 0.498337, 0.143609, 0.584951, -0.125605, 0.499414, 0.157625, 0.587602, -0.135608, 0.500518, 0.172413, 0.59076, -0.145742, 0.501767, 0.187999, 0.594992, -0.155934, 0.503542, 0.20445, 0.600656, -0.166303, 0.506135, 0.221764, 0.607816, -0.176681, 0.509542, 0.24002, 0.61522, -0.187071, 0.51263, 0.258992, 0.623702, -0.197465, 0.516021, 0.278773, 0.634192, -0.207816, 0.520422, 0.299377, 0.644936, -0.218183, 0.524073, 0.320802, 0.657888, -0.2278, 0.528049, 0.34384, 0.670666, -0.236747, 0.52986, 0.36916, 0.685626, -0.24484, 0.531892, 0.395867, 0.701304, -0.252071, 0.532727, 0.423488, 0.717727, -0.258714, 0.532146, 0.452201, 0.733914, -0.264211, 0.529883, 0.481579, 0.750529, -0.26859, 0.5259, 0.511558, 0.76747, -0.272046, 0.51999, 0.542042, 0.785189, -0.274225, 0.513083, 0.572799, 0.800954, -0.275189, 0.502936, 0.603816, 0.816962, -0.274946, 0.490921, 0.635461, 0.83336, -0.272695, 0.47684, 0.6676, 0.848143, -0.268223, 0.459405, 0.70051, 0.861818, -0.262768, 0.440319, 0.732902, 0.876828, -0.255872, 0.420123, 0.765084, 0.889312, -0.247703, 0.398379, 0.796391, 0.900412, -0.238381, 0.374496, 0.827333, 0.912251, -0.227783, 0.349874, 0.858385, 0.921792, -0.214832, 0.323181, 0.888652, 0.931273, -0.200949, 0.296624, 0.917763, 0.940295, -0.186537, 0.269211, 0.947878, 0.946812, -0.171538, 0.241447, 0.977016, 0.953588, -0.155254, 0.213829, 1.00501, 0.958841, -0.137156, 0.186807, 1.03179, 0.963746, -0.118699, 0.160706, 1.05502, 0.966468, -0.0998358, 0.135504, 1.07568, 0.971178, -0.0805186, 0.109131, 1.09479, 0.97831, -0.0599348, 0.0818293, 1.1123, 0.985886, -0.0399661, 0.0545872, 1.12771, 0.994021, -0.0198682, 0.0269405, 1.14186, 1.00009, 271022e-9, -12989e-8, 1.15514, 0.538716, -990918e-11, 0.486732, 109675e-10, 0.550656, -250642e-9, 0.497518, 277412e-9, 0.55057, -100265e-8, 0.497441, 110974e-8, 0.550903, -225672e-8, 0.497733, 249779e-8, 0.550568, -401046e-8, 0.497438, 443906e-8, 0.550574, -626613e-8, 0.49744, 693637e-8, 0.550591, -90226e-7, 0.497449, 998921e-8, 0.550623, -0.0122795, 0.497469, 0.0135984, 0.550667, -0.0160361, 0.497495, 0.0177654, 0.550724, -0.0202908, 0.497526, 0.0224915, 0.550792, -0.0250421, 0.497557, 0.0277795, 0.550918, -0.0302878, 0.49763, 0.0336334, 0.551058, -0.0360241, 0.497701, 0.0400573, 0.551276, -0.0422473, 0.497824, 0.0470585, 0.551551, -0.0489441, 0.497977, 0.0546433, 0.552074, -0.0559596, 0.498312, 0.0628367, 0.552681, -0.0633978, 0.498679, 0.071646, 0.553324, -0.0713176, 0.499031, 0.0810746, 0.554011, -0.0797268, 0.499365, 0.091129, 0.55488, -0.0885238, 0.499779, 0.101837, 0.556171, -0.0974417, 0.500444, 0.113239, 0.557498, -0.106841, 0.501025, 0.125316, 0.559299, -0.116533, 0.501864, 0.138128, 0.561647, -0.126298, 0.502967, 0.151695, 0.564347, -0.136388, 0.504129, 0.16604, 0.567863, -0.146576, 0.505713, 0.181207, 0.572569, -0.156832, 0.507953, 0.197259, 0.578919, -0.167323, 0.511186, 0.214258, 0.585387, -0.177712, 0.514042, 0.232038, 0.593134, -0.188184, 0.517484, 0.250733, 0.603295, -0.198717, 0.522345, 0.270454, 0.613854, -0.209177, 0.526751, 0.290807, 0.626092, -0.219644, 0.531595, 0.312202, 0.637868, -0.229494, 0.534721, 0.334435, 0.652458, -0.238718, 0.538304, 0.359184, 0.666985, -0.247061, 0.539875, 0.385637, 0.683301, -0.254652, 0.541042, 0.41328, 0.69998, -0.261376, 0.540735, 0.441903, 0.717824, -0.267085, 0.539139, 0.471609, 0.734617, -0.271465, 0.534958, 0.501446, 0.753663, -0.27528, 0.53032, 0.532571, 0.770512, -0.277617, 0.522134, 0.563641, 0.787356, -0.278525, 0.51206, 0.595067, 0.806252, -0.278512, 0.50119, 0.627226, 0.822061, -0.277023, 0.486791, 0.659402, 0.838959, -0.273175, 0.470467, 0.692874, 0.85379, -0.267238, 0.450688, 0.725702, 0.868268, -0.260327, 0.429741, 0.75832, 0.881994, -0.251946, 0.407223, 0.790189, 0.893885, -0.242432, 0.383214, 0.821625, 0.905118, -0.231904, 0.357297, 0.853011, 0.916045, -0.219545, 0.330733, 0.883773, 0.927614, -0.205378, 0.303916, 0.914435, 0.936005, -0.190388, 0.275941, 0.944502, 0.944533, -0.1749, 0.247493, 0.974439, 0.950758, -0.158588, 0.218996, 1.00286, 0.957078, -0.141027, 0.191559, 1.0304, 0.962448, -0.121507, 0.164457, 1.05466, 0.964993, -0.102068, 0.138636, 1.0761, 0.970017, -0.0822598, 0.111861, 1.09541, 0.97661, -0.062033, 0.0843438, 1.11317, 0.985073, -0.0409832, 0.0558496, 1.12911, 0.993515, -0.020146, 0.0275331, 1.1438, 1.00006, 27329e-8, -107883e-9, 1.15736, 0.525324, -999341e-11, 0.498153, 105385e-10, 0.526513, -251605e-9, 0.499277, 265329e-9, 0.526517, -100641e-8, 0.499282, 10613e-7, 0.526588, -226466e-8, 0.499337, 238823e-8, 0.526539, -40255e-7, 0.499302, 424535e-8, 0.526547, -628954e-8, 0.499306, 663364e-8, 0.526561, -905628e-8, 0.499313, 955337e-8, 0.526593, -0.0123253, 0.499334, 0.0130054, 0.526642, -0.0160957, 0.499365, 0.0169911, 0.5267, -0.0203661, 0.499396, 0.0215122, 0.526792, -0.0251347, 0.499451, 0.0265718, 0.526904, -0.0303985, 0.499511, 0.0321732, 0.527079, -0.0361554, 0.499617, 0.0383231, 0.527285, -0.0423982, 0.499731, 0.045026, 0.527602, -0.0491121, 0.499924, 0.0522936, 0.528166, -0.0561127, 0.500306, 0.0601528, 0.52879, -0.0635988, 0.5007, 0.0686059, 0.529421, -0.071581, 0.501048, 0.0776518, 0.530144, -0.0799854, 0.501421, 0.0873148, 0.531062, -0.0888032, 0.501884, 0.0976084, 0.532374, -0.0977643, 0.50259, 0.108588, 0.533828, -0.107197, 0.50329, 0.120234, 0.53581, -0.116887, 0.504312, 0.132602, 0.538063, -0.126755, 0.505365, 0.145721, 0.5409, -0.136819, 0.506668, 0.159617, 0.544882, -0.147117, 0.508731, 0.174369, 0.550238, -0.157446, 0.511601, 0.190028, 0.556038, -0.167988, 0.514431, 0.206587, 0.563031, -0.178364, 0.517808, 0.224046, 0.571543, -0.189007, 0.521937, 0.242503, 0.582255, -0.199546, 0.527415, 0.261977, 0.59272, -0.210084, 0.531682, 0.282162, 0.605648, -0.220448, 0.537123, 0.303426, 0.61785, -0.230593, 0.540664, 0.325323, 0.632223, -0.240238, 0.544467, 0.348993, 0.648819, -0.24887, 0.547594, 0.375462, 0.665825, -0.256657, 0.54912, 0.403024, 0.683389, -0.263711, 0.549294, 0.431773, 0.701495, -0.269666, 0.547649, 0.461494, 0.719197, -0.274169, 0.543786, 0.491623, 0.737906, -0.278124, 0.538644, 0.522994, 0.756652, -0.280632, 0.531057, 0.554775, 0.775279, -0.281741, 0.521972, 0.586441, 0.792688, -0.281652, 0.509613, 0.618596, 0.811894, -0.280345, 0.496497, 0.651462, 0.827938, -0.277128, 0.47968, 0.684023, 0.844837, -0.271646, 0.460688, 0.718024, 0.859239, -0.264397, 0.438872, 0.751207, 0.874088, -0.256144, 0.41577, 0.784232, 0.887693, -0.246311, 0.391369, 0.816191, 0.899402, -0.235497, 0.365872, 0.847828, 0.910973, -0.223631, 0.338618, 0.87934, 0.92204, -0.209874, 0.310803, 0.910325, 0.930987, -0.194265, 0.281802, 0.940695, 0.94, -0.178125, 0.252836, 0.970958, 0.948018, -0.161479, 0.224239, 1.00078, 0.955141, -0.144038, 0.195857, 1.0288, 0.960513, -0.124915, 0.168487, 1.05371, 0.963964, -0.104284, 0.141495, 1.07596, 0.968713, -0.0838732, 0.114437, 1.09628, 0.975524, -0.0635579, 0.0863105, 1.11448, 0.98431, -0.042291, 0.0574774, 1.13069, 0.992916, -0.0209131, 0.0284343, 1.14568, 0.999926, 743097e-9, -379265e-9, 1.15955, 0.501042, -998428e-11, 0.498726, 100306e-10, 0.502992, -252112e-9, 0.500665, 253283e-9, 0.502417, -100791e-8, 0.500092, 101259e-8, 0.502965, -226919e-8, 0.500621, 227978e-8, 0.502318, -403109e-8, 0.499994, 405011e-8, 0.502333, -629832e-8, 0.500005, 632868e-8, 0.502362, -906907e-8, 0.500027, 911446e-8, 0.502369, -0.0123423, 0.500023, 0.0124078, 0.50243, -0.0161178, 0.500066, 0.016211, 0.502493, -0.0203937, 0.500103, 0.0205256, 0.502592, -0.0251684, 0.500166, 0.0253548, 0.502707, -0.0304389, 0.50023, 0.0307029, 0.502881, -0.0362015, 0.500335, 0.0365753, 0.503124, -0.0424507, 0.500488, 0.0429798, 0.503443, -0.0491582, 0.500686, 0.0499268, 0.504083, -0.0561476, 0.501155, 0.0574541, 0.504668, -0.0636846, 0.501524, 0.0655408, 0.505319, -0.0716834, 0.501904, 0.0742072, 0.50609, -0.0800925, 0.502321, 0.0834699, 0.507122, -0.0888425, 0.502896, 0.0933603, 0.508414, -0.097855, 0.503603, 0.10391, 0.509955, -0.107304, 0.504416, 0.115113, 0.512061, -0.116921, 0.505565, 0.127054, 0.514419, -0.12689, 0.506732, 0.139709, 0.517529, -0.136934, 0.508338, 0.153173, 0.522085, -0.147327, 0.510987, 0.167528, 0.526986, -0.157612, 0.513527, 0.182708, 0.533122, -0.168213, 0.516717, 0.198881, 0.540807, -0.178688, 0.520832, 0.215986, 0.550687, -0.189511, 0.52632, 0.234335, 0.560567, -0.199998, 0.531009, 0.253375, 0.571698, -0.210652, 0.535839, 0.273499, 0.584364, -0.220917, 0.541091, 0.294355, 0.599066, -0.23137, 0.546875, 0.316525, 0.614148, -0.241206, 0.551306, 0.339671, 0.631157, -0.250379, 0.555187, 0.36531, 0.647919, -0.258397, 0.556595, 0.392767, 0.666112, -0.265528, 0.556949, 0.421397, 0.686158, -0.271827, 0.556617, 0.451433, 0.704838, -0.27674, 0.552975, 0.482131, 0.723957, -0.280733, 0.547814, 0.513458, 0.74262, -0.283359, 0.53997, 0.545446, 0.762009, -0.284541, 0.530422, 0.57775, 0.781314, -0.284507, 0.518546, 0.610434, 0.799116, -0.283309, 0.504178, 0.643178, 0.817604, -0.280378, 0.48843, 0.676248, 0.83459, -0.275619, 0.469457, 0.709698, 0.850974, -0.26856, 0.447698, 0.744245, 0.866747, -0.260094, 0.424791, 0.777695, 0.881412, -0.249929, 0.399913, 0.810392, 0.8936, -0.239137, 0.37308, 0.842872, 0.905943, -0.226818, 0.345705, 0.874677, 0.916408, -0.213699, 0.31706, 0.906257, 0.927215, -0.198428, 0.288444, 0.936881, 0.935625, -0.181643, 0.258329, 0.96795, 0.944076, -0.164386, 0.228488, 0.998216, 0.951229, -0.146339, 0.199763, 1.02689, 0.958793, -0.127709, 0.172153, 1.0535, 0.963219, -0.107244, 0.144989, 1.07646, 0.967562, -0.0857764, 0.11685, 1.09675, 0.974866, -0.0645377, 0.0880571, 1.11576, 0.983353, -0.0431732, 0.0587352, 1.13227, 0.992503, -0.0218356, 0.0294181, 1.1478, 1.00003, 605203e-9, -231013e-9, 1.16207, 0.482935, -101177e-10, 0.504695, 968142e-11, 0.477554, -251521e-9, 0.499071, 240676e-9, 0.477904, -100683e-8, 0.499436, 96342e-8, 0.478368, -226636e-8, 0.499899, 21687e-7, 0.477977, -402719e-8, 0.499513, 385384e-8, 0.477993, -629226e-8, 0.499525, 60221e-7, 0.478011, -906011e-8, 0.499536, 867289e-8, 0.478051, -0.0123305, 0.499566, 0.0118074, 0.478089, -0.016102, 0.499587, 0.0154269, 0.478171, -0.0203736, 0.499645, 0.0195341, 0.478254, -0.025143, 0.499692, 0.0241318, 0.47839, -0.0304071, 0.499779, 0.0292247, 0.478588, -0.0361631, 0.499911, 0.0348196, 0.478812, -0.0424023, 0.500046, 0.0409231, 0.479208, -0.0490724, 0.500326, 0.047552, 0.479841, -0.0560722, 0.500805, 0.0547377, 0.480392, -0.0636125, 0.501152, 0.0624607, 0.481068, -0.0716134, 0.501561, 0.0707473, 0.481898, -0.0800062, 0.502054, 0.0796118, 0.483022, -0.0886568, 0.502728, 0.0890974, 0.484332, -0.0977553, 0.503479, 0.0992099, 0.486126, -0.107173, 0.504546, 0.10999, 0.488066, -0.11677, 0.50557, 0.121476, 0.490521, -0.126725, 0.506849, 0.133672, 0.494232, -0.136793, 0.50911, 0.146731, 0.498302, -0.147116, 0.511345, 0.160577, 0.503565, -0.157446, 0.514344, 0.175335, 0.510902, -0.168121, 0.518824, 0.191207, 0.519263, -0.178799, 0.523666, 0.208058, 0.528204, -0.189407, 0.528296, 0.225875, 0.538854, -0.200145, 0.533724, 0.244782, 0.551278, -0.210701, 0.539833, 0.264753, 0.565222, -0.221303, 0.546131, 0.285745, 0.579403, -0.231688, 0.551496, 0.307592, 0.595469, -0.241718, 0.556809, 0.330582, 0.610929, -0.250992, 0.559641, 0.354995, 0.629433, -0.259602, 0.562379, 0.382471, 0.648504, -0.267038, 0.563676, 0.411126, 0.66756, -0.273388, 0.562092, 0.440924, 0.689143, -0.278788, 0.560807, 0.472118, 0.709056, -0.282783, 0.555701, 0.503774, 0.729855, -0.285836, 0.548698, 0.536364, 0.748954, -0.287078, 0.538544, 0.56895, 0.768373, -0.287133, 0.526711, 0.601991, 0.78827, -0.285839, 0.512511, 0.635403, 0.807465, -0.283238, 0.496323, 0.668797, 0.825194, -0.27906, 0.477638, 0.702584, 0.842203, -0.272286, 0.456253, 0.736393, 0.857749, -0.263854, 0.432412, 0.77096, 0.874799, -0.253943, 0.407806, 0.80489, 0.887497, -0.24237, 0.38033, 0.83771, 0.89966, -0.230278, 0.352446, 0.870376, 0.911753, -0.21646, 0.323268, 0.902256, 0.923011, -0.202071, 0.294314, 0.933306, 0.932375, -0.185519, 0.264104, 0.965177, 0.940537, -0.167604, 0.234035, 0.996303, 0.948904, -0.149068, 0.20412, 1.0261, 0.955263, -0.129539, 0.175431, 1.05304, 0.960303, -0.109932, 0.148116, 1.07617, 0.965512, -0.0880572, 0.119693, 1.09742, 0.973466, -0.0660548, 0.0901619, 1.11721, 0.98284, -0.0439228, 0.0599875, 1.13436, 0.992216, -0.0219588, 0.0298975, 1.15006, 0.999946, 119402e-9, -208547e-10, 1.16471, 0.447827, -100414e-10, 0.491543, 914833e-11, 0.454778, -251257e-9, 0.499172, 22891e-8, 0.453519, -100342e-8, 0.497787, 914184e-9, 0.45357, -225776e-8, 0.497847, 205701e-8, 0.453578, -401371e-8, 0.497855, 365705e-8, 0.45357, -627107e-8, 0.497841, 571453e-8, 0.453598, -902968e-8, 0.497864, 823019e-8, 0.453627, -0.0122888, 0.497882, 0.0112049, 0.453684, -0.0160475, 0.497923, 0.0146405, 0.453764, -0.0203044, 0.49798, 0.0185394, 0.453866, -0.0250576, 0.498049, 0.0229054, 0.453996, -0.0303028, 0.49813, 0.0277424, 0.454196, -0.0360379, 0.498267, 0.0330587, 0.454457, -0.0422521, 0.498445, 0.0388613, 0.454926, -0.0488393, 0.498812, 0.0451767, 0.455525, -0.0558653, 0.499272, 0.0520153, 0.456074, -0.0633772, 0.499625, 0.0593754, 0.456752, -0.0713606, 0.500049, 0.0672751, 0.457648, -0.07971, 0.500615, 0.0757447, 0.458849, -0.0883032, 0.501399, 0.0848231, 0.46029, -0.0974095, 0.502293, 0.0945135, 0.462, -0.106729, 0.503301, 0.104848, 0.464121, -0.116354, 0.504533, 0.115884, 0.466889, -0.126214, 0.506172, 0.127652, 0.470744, -0.136324, 0.508667, 0.14024, 0.47488, -0.146595, 0.510995, 0.153673, 0.480845, -0.157027, 0.514832, 0.168053, 0.488262, -0.167658, 0.519506, 0.183508, 0.496547, -0.178343, 0.524347, 0.199948, 0.506254, -0.188916, 0.52983, 0.217503, 0.517961, -0.199975, 0.536357, 0.236272, 0.531484, -0.210624, 0.543641, 0.256096, 0.545496, -0.221227, 0.550048, 0.277085, 0.559497, -0.231568, 0.555076, 0.298615, 0.575752, -0.241698, 0.560541, 0.321547, 0.591999, -0.251172, 0.564156, 0.345602, 0.610654, -0.260178, 0.567607, 0.371851, 0.630484, -0.268094, 0.56923, 0.40076, 0.651807, -0.274661, 0.569779, 0.430801, 0.67239, -0.280331, 0.566791, 0.461939, 0.693024, -0.284501, 0.562007, 0.493854, 0.715473, -0.287852, 0.555791, 0.526992, 0.736323, -0.28929, 0.546345, 0.560102, 0.755771, -0.289405, 0.534, 0.593543, 0.775424, -0.2881, 0.519114, 0.627256, 0.795447, -0.285562, 0.502543, 0.661464, 0.815319, -0.281416, 0.484773, 0.695206, 0.831769, -0.275523, 0.463445, 0.729044, 0.849464, -0.267516, 0.440269, 0.764069, 0.866775, -0.257584, 0.415049, 0.799089, 0.881252, -0.245817, 0.388049, 0.831948, 0.894209, -0.233127, 0.35889, 0.865526, 0.906922, -0.219579, 0.329915, 0.89818, 0.919686, -0.204491, 0.300441, 0.930013, 0.929044, -0.188962, 0.269445, 0.962061, 0.938393, -0.171079, 0.238402, 0.994214, 0.94661, -0.15199, 0.208204, 1.02533, 0.953095, -0.131953, 0.178653, 1.0529, 0.958644, -0.111233, 0.150684, 1.0771, 0.963925, -0.0903098, 0.122359, 1.09855, 0.971995, -0.0680505, 0.0923342, 1.11874, 0.981658, -0.0448512, 0.0614195, 1.13635, 0.991649, -0.0221931, 0.0303582, 1.15238, 0.999985, 393403e-9, -111086e-9, 1.16772, 0.396806, -971563e-11, 0.457671, 842355e-11, 0.429186, -249421e-9, 0.495017, 21625e-8, 0.429324, -998052e-9, 0.495173, 865322e-9, 0.429175, -224487e-8, 0.494999, 194637e-8, 0.429129, -399041e-8, 0.494952, 346004e-8, 0.429153, -623476e-8, 0.494974, 540684e-8, 0.429168, -89773e-7, 0.494983, 778714e-8, 0.429207, -0.0122175, 0.495012, 0.0106022, 0.429257, -0.0159542, 0.495047, 0.0138535, 0.429338, -0.0201864, 0.495106, 0.0175443, 0.429431, -0.0249104, 0.495165, 0.0216774, 0.429587, -0.0301252, 0.495279, 0.0262594, 0.429796, -0.0358249, 0.495432, 0.0312968, 0.430065, -0.0419972, 0.495621, 0.0367985, 0.430588, -0.0485144, 0.496061, 0.042798, 0.43113, -0.0555028, 0.496472, 0.0492914, 0.431743, -0.0629852, 0.496904, 0.0562907, 0.432448, -0.0709256, 0.497369, 0.0638056, 0.433414, -0.0791942, 0.498032, 0.071885, 0.434638, -0.0877346, 0.498854, 0.0805517, 0.43611, -0.0968056, 0.499812, 0.0898047, 0.437859, -0.106002, 0.500891, 0.0997142, 0.440017, -0.115648, 0.502198, 0.110289, 0.443236, -0.125427, 0.504389, 0.121644, 0.44697, -0.135492, 0.506809, 0.133769, 0.451689, -0.145746, 0.509858, 0.146787, 0.45811, -0.156219, 0.514247, 0.160793, 0.465305, -0.166834, 0.518816, 0.175791, 0.474085, -0.177546, 0.524331, 0.191906, 0.484808, -0.188262, 0.53104, 0.209199, 0.49732, -0.199346, 0.538511, 0.227825, 0.509693, -0.209951, 0.544554, 0.247269, 0.524367, -0.220533, 0.551616, 0.267978, 0.539228, -0.231082, 0.557368, 0.289672, 0.55644, -0.241342, 0.563782, 0.31268, 0.574204, -0.250964, 0.568851, 0.33651, 0.593388, -0.260306, 0.57312, 0.362219, 0.613358, -0.268667, 0.574916, 0.390322, 0.634512, -0.275591, 0.575053, 0.420478, 0.65563, -0.281328, 0.572404, 0.451614, 0.678265, -0.285948, 0.568893, 0.484112, 0.70011, -0.289408, 0.561878, 0.517348, 0.723005, -0.291328, 0.55359, 0.551355, 0.743744, -0.291418, 0.541099, 0.585109, 0.763949, -0.290252, 0.526489, 0.619487, 0.784186, -0.287648, 0.509496, 0.65404, 0.804304, -0.283782, 0.491484, 0.688649, 0.823629, -0.278067, 0.470517, 0.723133, 0.84094, -0.270588, 0.44705, 0.757163, 0.857852, -0.261188, 0.421252, 0.792816, 0.874934, -0.249313, 0.394191, 0.827248, 0.888709, -0.236492, 0.365359, 0.861074, 0.902589, -0.222185, 0.336016, 0.894417, 0.914201, -0.207314, 0.30527, 0.926825, 0.925978, -0.191146, 0.274532, 0.9595, 0.93512, -0.174135, 0.243393, 0.991583, 0.943656, -0.155231, 0.212414, 1.02356, 0.951719, -0.134403, 0.182005, 1.05239, 0.957164, -0.113023, 0.153043, 1.07754, 0.962656, -0.0914493, 0.124186, 1.09984, 0.970695, -0.0694179, 0.0941654, 1.12, 0.980749, -0.0466199, 0.0629671, 1.13849, 0.991205, -0.0227032, 0.0311146, 1.15494, 0.999884, 632388e-9, -254483e-9, 1.1706, 0.379821, -957289e-11, 0.460637, 789337e-11, 0.405188, -247483e-9, 0.491396, 204064e-9, 0.404796, -989434e-9, 0.490914, 815853e-9, 0.40483, -222607e-8, 0.490949, 183559e-8, 0.40473, -395723e-8, 0.49084, 326332e-8, 0.404731, -618287e-8, 0.490836, 509945e-8, 0.404768, -890258e-8, 0.490871, 734463e-8, 0.404791, -0.0121156, 0.490883, 999992e-8, 0.404857, -0.0158214, 0.490938, 0.0130676, 0.404943, -0.0200178, 0.491004, 0.0165503, 0.405059, -0.0247027, 0.491093, 0.0204521, 0.405213, -0.0298729, 0.491205, 0.0247788, 0.405399, -0.0355226, 0.491333, 0.0295373, 0.405731, -0.0416352, 0.491604, 0.034741, 0.406303, -0.0480807, 0.492116, 0.0404255, 0.406814, -0.0550458, 0.492506, 0.0465732, 0.407404, -0.0624652, 0.492926, 0.0532058, 0.408149, -0.0702958, 0.493442, 0.0603442, 0.409128, -0.0784623, 0.494136, 0.0680297, 0.410408, -0.087007, 0.495054, 0.0762786, 0.411813, -0.0959639, 0.495962, 0.0851046, 0.413735, -0.105075, 0.497257, 0.0945878, 0.416137, -0.114646, 0.498882, 0.104725, 0.41934, -0.124394, 0.501132, 0.11563, 0.423326, -0.134328, 0.503883, 0.127325, 0.428419, -0.14458, 0.50747, 0.139911, 0.43484, -0.154979, 0.511964, 0.153481, 0.442641, -0.165628, 0.517328, 0.168114, 0.452511, -0.176365, 0.524258, 0.183995, 0.463473, -0.187298, 0.531248, 0.200953, 0.475564, -0.198244, 0.538367, 0.219176, 0.488664, -0.208938, 0.545175, 0.238514, 0.504073, -0.219599, 0.553227, 0.259129, 0.520832, -0.230378, 0.560653, 0.280997, 0.538455, -0.240703, 0.567523, 0.303821, 0.55709, -0.250548, 0.573287, 0.327948, 0.576646, -0.259964, 0.577795, 0.353362, 0.596705, -0.268721, 0.580077, 0.380336, 0.618053, -0.276054, 0.58018, 0.4101, 0.640303, -0.282176, 0.578747, 0.44161, 0.662365, -0.286931, 0.574294, 0.474106, 0.684542, -0.290521, 0.567035, 0.507549, 0.707984, -0.292672, 0.558687, 0.541853, 0.730913, -0.293189, 0.547606, 0.576581, 0.752948, -0.292199, 0.533471, 0.61172, 0.773452, -0.289508, 0.516395, 0.646339, 0.794715, -0.285716, 0.497873, 0.682131, 0.814251, -0.280051, 0.476845, 0.716396, 0.833057, -0.272873, 0.453449, 0.751503, 0.84959, -0.263982, 0.427857, 0.786085, 0.867022, -0.252745, 0.400335, 0.821355, 0.882277, -0.239655, 0.371304, 0.85646, 0.895375, -0.225386, 0.340397, 0.890828, 0.909347, -0.209587, 0.310005, 0.923532, 0.921885, -0.193433, 0.2796, 0.956419, 0.932127, -0.176135, 0.247276, 0.989445, 0.941869, -0.157872, 0.216186, 1.02221, 0.949735, -0.137577, 0.185602, 1.05195, 0.956617, -0.115285, 0.155767, 1.07822, 0.961974, -0.0928418, 0.126103, 1.10149, 0.96972, -0.0700592, 0.0956758, 1.12207, 0.98012, -0.0474671, 0.0643269, 1.1408, 0.990825, -0.0238113, 0.0320863, 1.1577, 0.999876, 381574e-9, -812203e-10, 1.17403, 0.367636, -961342e-11, 0.469176, 753287e-11, 0.380377, -244772e-9, 0.485434, 191797e-9, 0.380416, -978857e-9, 0.485475, 767015e-9, 0.380376, -220165e-8, 0.485435, 172522e-8, 0.380419, -391408e-8, 0.485487, 306734e-8, 0.380438, -611549e-8, 0.485505, 479332e-8, 0.380462, -880558e-8, 0.485525, 690391e-8, 0.380496, -0.0119837, 0.485551, 940039e-8, 0.38056, -0.0156487, 0.485605, 0.0122848, 0.38064, -0.0197988, 0.485666, 0.0155601, 0.380767, -0.0244324, 0.48577, 0.0192313, 0.380909, -0.0295444, 0.485871, 0.0233032, 0.381142, -0.0351321, 0.48606, 0.0277861, 0.381472, -0.0411535, 0.486336, 0.0326939, 0.382015, -0.0475408, 0.486833, 0.0380565, 0.382523, -0.0544395, 0.487231, 0.0438615, 0.383129, -0.061784, 0.487683, 0.0501332, 0.383952, -0.0695085, 0.488313, 0.0568996, 0.38498, -0.0775819, 0.489077, 0.0641952, 0.386331, -0.0860443, 0.490113, 0.0720324, 0.387788, -0.0948406, 0.491099, 0.0804379, 0.389808, -0.103899, 0.492566, 0.0894899, 0.39252, -0.113313, 0.494601, 0.0992098, 0.395493, -0.123007, 0.496619, 0.109641, 0.399826, -0.132859, 0.499912, 0.120919, 0.405341, -0.143077, 0.504061, 0.133107, 0.411932, -0.153465, 0.508905, 0.146263, 0.420591, -0.164108, 0.515482, 0.160544, 0.43101, -0.174893, 0.523191, 0.176123, 0.441881, -0.185839, 0.53026, 0.192757, 0.453919, -0.196633, 0.537295, 0.210535, 0.468715, -0.207611, 0.546156, 0.229886, 0.485182, -0.218517, 0.555173, 0.250543, 0.501926, -0.229249, 0.562728, 0.27221, 0.51785, -0.239481, 0.567494, 0.294892, 0.536947, -0.249395, 0.573889, 0.318987, 0.557115, -0.259, 0.578831, 0.344348, 0.577966, -0.268075, 0.582055, 0.371223, 0.599489, -0.276115, 0.583307, 0.399834, 0.62479, -0.282523, 0.583902, 0.431415, 0.647504, -0.287663, 0.57953, 0.464301, 0.670601, -0.291538, 0.573103, 0.498123, 0.693539, -0.293842, 0.563731, 0.532662, 0.717385, -0.294681, 0.553169, 0.567925, 0.741533, -0.293717, 0.539908, 0.603502, 0.762142, -0.291156, 0.521902, 0.639074, 0.783014, -0.28719, 0.502815, 0.674439, 0.805158, -0.281773, 0.482598, 0.710497, 0.823646, -0.274682, 0.458949, 0.7456, 0.841879, -0.266184, 0.433129, 0.781085, 0.859515, -0.255682, 0.406064, 0.816, 0.875335, -0.242849, 0.376509, 0.851074, 0.890147, -0.228329, 0.345502, 0.886473, 0.903144, -0.212491, 0.31428, 0.920751, 0.916618, -0.195695, 0.282994, 0.954606, 0.927953, -0.178267, 0.251091, 0.988402, 0.937414, -0.159549, 0.219107, 1.02141, 0.946823, -0.140022, 0.18896, 1.05167, 0.954651, -0.118154, 0.158667, 1.07819, 0.959955, -0.0946636, 0.128808, 1.1025, 0.96858, -0.0711792, 0.0973787, 1.12391, 0.97938, -0.0475046, 0.0650965, 1.14322, 0.990498, -0.024059, 0.0326267, 1.16077, 0.999844, -512408e-10, 112444e-9, 1.17727, 0.316912, -934977e-11, 0.425996, 695559e-11, 0.356423, -241372e-9, 0.479108, 179562e-9, 0.356272, -965292e-9, 0.478897, 71811e-8, 0.356262, -217182e-8, 0.478894, 161574e-8, 0.356265, -386092e-8, 0.478895, 287261e-8, 0.356278, -60324e-7, 0.478905, 448907e-8, 0.356293, -868565e-8, 0.478914, 646572e-8, 0.356346, -0.0118207, 0.478965, 880438e-8, 0.356395, -0.0154355, 0.479001, 0.0115066, 0.356484, -0.019529, 0.479075, 0.0145762, 0.356609, -0.0240991, 0.47918, 0.018018, 0.356766, -0.0291413, 0.479305, 0.0218379, 0.357009, -0.0346498, 0.479512, 0.0260454, 0.357424, -0.0405462, 0.479909, 0.0306657, 0.357899, -0.0468825, 0.480337, 0.0357054, 0.358424, -0.0536887, 0.480771, 0.0411728, 0.359041, -0.0609416, 0.481242, 0.0470841, 0.359903, -0.0685239, 0.481943, 0.0534831, 0.360932, -0.0764883, 0.482741, 0.0603795, 0.362196, -0.0848364, 0.483688, 0.0678028, 0.363847, -0.0935002, 0.484947, 0.0758086, 0.365972, -0.102471, 0.486588, 0.0844173, 0.368741, -0.111751, 0.488787, 0.0937199, 0.372146, -0.121334, 0.491405, 0.103732, 0.377114, -0.131147, 0.495604, 0.114608, 0.38226, -0.141213, 0.499436, 0.126345, 0.389609, -0.151632, 0.505334, 0.139116, 0.397925, -0.162073, 0.51168, 0.152995, 0.407824, -0.172819, 0.518876, 0.168071, 0.420014, -0.183929, 0.527639, 0.184495, 0.434266, -0.195032, 0.537588, 0.20232, 0.447352, -0.205792, 0.544379, 0.221189, 0.463726, -0.216704, 0.553422, 0.241616, 0.481406, -0.227531, 0.562074, 0.263298, 0.498707, -0.238017, 0.568227, 0.286116, 0.518039, -0.247936, 0.574473, 0.3101, 0.538277, -0.257437, 0.579191, 0.335401, 0.561166, -0.266829, 0.584807, 0.362246, 0.583189, -0.275329, 0.586476, 0.390609, 0.606024, -0.28234, 0.585578, 0.420998, 0.632419, -0.287924, 0.584496, 0.454357, 0.656128, -0.291972, 0.577766, 0.488233, 0.679953, -0.29456, 0.56875, 0.523248, 0.704654, -0.295816, 0.558388, 0.559168, 0.729016, -0.295157, 0.544826, 0.595326, 0.752062, -0.292779, 0.528273, 0.631864, 0.773138, -0.288681, 0.508482, 0.667793, 0.794869, -0.283358, 0.487341, 0.704035, 0.815101, -0.27608, 0.46354, 0.739925, 0.834212, -0.26767, 0.438672, 0.775539, 0.852368, -0.257397, 0.411239, 0.810895, 0.870207, -0.245689, 0.3829, 0.846472, 0.884063, -0.231452, 0.351496, 0.881788, 0.898284, -0.215561, 0.31895, 0.917438, 0.912964, -0.198208, 0.287367, 0.952422, 0.924666, -0.180426, 0.254487, 0.987551, 0.934429, -0.161525, 0.222226, 1.02142, 0.943485, -0.141197, 0.191143, 1.05218, 0.9521, -0.120085, 0.161112, 1.07937, 0.957876, -0.0975881, 0.130982, 1.10403, 0.966943, -0.0726842, 0.0990553, 1.12616, 0.978313, -0.0483705, 0.0662818, 1.14619, 0.990048, -0.0239072, 0.0329243, 1.16413, 0.999984, 461885e-9, -772859e-10, 1.18099, 0.321287, -935049e-11, 0.455413, 659662e-11, 0.332595, -237513e-9, 0.471437, 167562e-9, 0.332729, -949964e-9, 0.471618, 670192e-9, 0.332305, -213618e-8, 0.471028, 150712e-8, 0.332326, -379765e-8, 0.471055, 267959e-8, 0.332344, -593353e-8, 0.471072, 418751e-8, 0.332356, -854349e-8, 0.471077, 603172e-8, 0.332403, -0.0116268, 0.471121, 821362e-8, 0.332461, -0.0151824, 0.47117, 0.0107357, 0.332552, -0.0192088, 0.471251, 0.0136014, 0.332657, -0.0237024, 0.47133, 0.0168152, 0.332835, -0.0286615, 0.471487, 0.0203853, 0.333083, -0.0340765, 0.471708, 0.0243212, 0.333547, -0.0398563, 0.47219, 0.0286518, 0.333989, -0.0460916, 0.472587, 0.0333763, 0.334532, -0.0527897, 0.473054, 0.0385084, 0.335167, -0.0599284, 0.473568, 0.0440638, 0.33608, -0.0673514, 0.474362, 0.0500962, 0.337146, -0.0752237, 0.475231, 0.0566022, 0.338462, -0.083418, 0.476282, 0.0636272, 0.34014, -0.0919382, 0.477615, 0.0712153, 0.342341, -0.100741, 0.479404, 0.079417, 0.345088, -0.109905, 0.481618, 0.0882631, 0.349049, -0.119369, 0.485081, 0.0978851, 0.353939, -0.129033, 0.489317, 0.108336, 0.359893, -0.139038, 0.494309, 0.119698, 0.366945, -0.149411, 0.499983, 0.132024, 0.375814, -0.159843, 0.507185, 0.145558, 0.387112, -0.170664, 0.516392, 0.160433, 0.40023, -0.181897, 0.526519, 0.176648, 0.412555, -0.192785, 0.53423, 0.193922, 0.427023, -0.203663, 0.542741, 0.212662, 0.443685, -0.214695, 0.552066, 0.232944, 0.461499, -0.225561, 0.560762, 0.254495, 0.480975, -0.236257, 0.569421, 0.277531, 0.501, -0.24639, 0.576101, 0.301724, 0.521691, -0.256101, 0.581493, 0.327112, 0.543478, -0.265289, 0.585221, 0.353917, 0.566094, -0.273938, 0.587614, 0.381941, 0.589578, -0.281679, 0.587991, 0.41172, 0.614583, -0.287655, 0.585928, 0.444148, 0.641813, -0.292228, 0.582092, 0.478617, 0.666189, -0.295172, 0.57398, 0.51397, 0.690475, -0.29648, 0.561676, 0.550118, 0.715543, -0.296203, 0.548758, 0.586933, 0.740405, -0.293999, 0.532792, 0.62384, 0.762183, -0.28998, 0.512735, 0.660723, 0.786069, -0.28478, 0.492402, 0.69807, 0.806812, -0.277568, 0.469058, 0.734422, 0.826987, -0.268951, 0.443017, 0.770946, 0.844588, -0.259049, 0.415501, 0.80699, 0.863725, -0.2471, 0.387328, 0.842107, 0.879137, -0.234157, 0.356108, 0.878078, 0.894634, -0.218719, 0.324315, 0.914058, 0.909162, -0.201293, 0.291813, 0.949922, 0.92072, -0.18267, 0.258474, 0.985337, 0.93158, -0.163212, 0.225593, 1.0205, 0.941238, -0.142771, 0.193986, 1.05273, 0.949293, -0.120956, 0.163392, 1.08075, 0.956226, -0.0985743, 0.132934, 1.10559, 0.96546, -0.075118, 0.101255, 1.12823, 0.977403, -0.0497921, 0.0675441, 1.149, 0.989648, -0.0241574, 0.0334681, 1.16765, 1.00001, 5762e-7, -184807e-9, 1.18519, 0.303474, -916603e-11, 0.4542, 61243e-10, 0.308894, -232869e-9, 0.462306, 155592e-9, 0.309426, -931661e-9, 0.463093, 622499e-9, 0.308643, -20949e-7, 0.461933, 139979e-8, 0.308651, -37242e-7, 0.461941, 248874e-8, 0.308662, -581873e-8, 0.46195, 388933e-8, 0.308687, -837818e-8, 0.461974, 560247e-8, 0.308728, -0.0114016, 0.462011, 762948e-8, 0.308789, -0.0148884, 0.462067, 997326e-8, 0.308882, -0.0188369, 0.462151, 0.0126375, 0.309007, -0.0232436, 0.462263, 0.0156271, 0.30918, -0.0281054, 0.462417, 0.0189498, 0.309442, -0.0334065, 0.462667, 0.0226167, 0.309901, -0.0390589, 0.463162, 0.0266614, 0.310331, -0.0452042, 0.463555, 0.0310715, 0.310858, -0.0517735, 0.464019, 0.0358698, 0.311576, -0.0587359, 0.464669, 0.0410848, 0.312436, -0.0660383, 0.465406, 0.0467453, 0.313526, -0.0737266, 0.466339, 0.0528718, 0.314903, -0.0817574, 0.467504, 0.0595039, 0.316814, -0.090167, 0.469226, 0.0666888, 0.318965, -0.0987555, 0.470981, 0.0744658, 0.322077, -0.107792, 0.473814, 0.082912, 0.325947, -0.117098, 0.477241, 0.0920846, 0.331008, -0.126602, 0.48184, 0.102137, 0.337893, -0.136619, 0.488334, 0.113135, 0.345106, -0.146838, 0.494415, 0.12511, 0.355111, -0.157357, 0.503275, 0.138356, 0.365095, -0.167955, 0.510966, 0.152686, 0.378344, -0.179157, 0.521508, 0.16856, 0.391599, -0.190143, 0.530455, 0.18561, 0.407786, -0.20123, 0.541275, 0.204308, 0.425294, -0.212456, 0.551784, 0.224623, 0.444021, -0.223568, 0.561493, 0.246172, 0.463418, -0.234154, 0.569886, 0.268979, 0.484077, -0.244546, 0.577116, 0.293411, 0.505513, -0.254301, 0.582914, 0.318936, 0.527672, -0.263564, 0.587208, 0.345856, 0.550565, -0.272332, 0.589277, 0.374054, 0.573656, -0.280011, 0.588426, 0.403276, 0.59827, -0.286924, 0.587504, 0.43474, 0.624731, -0.291994, 0.583401, 0.468767, 0.652396, -0.295159, 0.576997, 0.504411, 0.67732, -0.296954, 0.565863, 0.54114, 0.703147, -0.296877, 0.552316, 0.57816, 0.728715, -0.295147, 0.536773, 0.616124, 0.752448, -0.291275, 0.51771, 0.653885, 0.775169, -0.285905, 0.496087, 0.691537, 0.799307, -0.279064, 0.474232, 0.729251, 0.819482, -0.270294, 0.447676, 0.766267, 0.837659, -0.260032, 0.419656, 0.802616, 0.856903, -0.248497, 0.391328, 0.838583, 0.873325, -0.235252, 0.360285, 0.874711, 0.889788, -0.221126, 0.329215, 0.91077, 0.904486, -0.204304, 0.296392, 0.94653, 0.917711, -0.185562, 0.262159, 0.983828, 0.928969, -0.165635, 0.229142, 1.01955, 0.939707, -0.14442, 0.19673, 1.05317, 0.948167, -0.122147, 0.165095, 1.0823, 0.955222, -0.099098, 0.13451, 1.10791, 0.964401, -0.0755332, 0.102476, 1.1312, 0.976605, -0.0513817, 0.0689667, 1.15218, 0.989085, -0.0258499, 0.034506, 1.17129, 0.999908, 617773e-9, -271268e-9, 1.18961, 0.285803, -905752e-11, 0.452348, 572272e-11, 0.284689, -22732e-8, 0.450581, 143626e-9, 0.285263, -910214e-9, 0.451482, 575099e-9, 0.285302, -204784e-8, 0.451553, 129395e-8, 0.285318, -364057e-8, 0.451574, 23006e-7, 0.28533, -568813e-8, 0.451585, 359547e-8, 0.285361, -819001e-8, 0.451618, 517934e-8, 0.285397, -0.0111458, 0.45165, 7054e-6, 0.285447, -0.0145536, 0.451688, 922167e-8, 0.285527, -0.0184127, 0.451758, 0.0116869, 0.285688, -0.0227207, 0.451929, 0.0144555, 0.28584, -0.0274712, 0.452055, 0.0175341, 0.286136, -0.0326278, 0.452369, 0.0209406, 0.286574, -0.0381792, 0.452853, 0.0246965, 0.287012, -0.0441879, 0.453272, 0.0287996, 0.287542, -0.0506096, 0.453752, 0.033268, 0.288299, -0.0573634, 0.454488, 0.0381504, 0.289186, -0.0645458, 0.455294, 0.0434447, 0.290302, -0.0720405, 0.456301, 0.0491973, 0.291776, -0.0799046, 0.457648, 0.0554453, 0.29372, -0.088117, 0.459483, 0.0622311, 0.296052, -0.0965328, 0.461571, 0.0695992, 0.299563, -0.105409, 0.465085, 0.077658, 0.30335, -0.114553, 0.468506, 0.0864176, 0.309167, -0.123917, 0.474423, 0.0961078, 0.31529, -0.13381, 0.47995, 0.106643, 0.324163, -0.144021, 0.488592, 0.118322, 0.333272, -0.154382, 0.496461, 0.131133, 0.344224, -0.165015, 0.50562, 0.145208, 0.357733, -0.176168, 0.516719, 0.16073, 0.373046, -0.187468, 0.528513, 0.177807, 0.38788, -0.198488, 0.537713, 0.196072, 0.405133, -0.209545, 0.547999, 0.21605, 0.423845, -0.220724, 0.55759, 0.237484, 0.443777, -0.231518, 0.566246, 0.26039, 0.464824, -0.242035, 0.574326, 0.284835, 0.486635, -0.251898, 0.58037, 0.310518, 0.51012, -0.261304, 0.58568, 0.337678, 0.535301, -0.270384, 0.590197, 0.366242, 0.559193, -0.27841, 0.590569, 0.395873, 0.583544, -0.285325, 0.588161, 0.426857, 0.608834, -0.291113, 0.584249, 0.459477, 0.635753, -0.294882, 0.57763, 0.494734, 0.664367, -0.297088, 0.569479, 0.532023, 0.689688, -0.297364, 0.555064, 0.569629, 0.715732, -0.295949, 0.539522, 0.608124, 0.741307, -0.292259, 0.521613, 0.646231, 0.764949, -0.287063, 0.49969, 0.684938, 0.788599, -0.28012, 0.476747, 0.723548, 0.81048, -0.27153, 0.45116, 0.761135, 0.831372, -0.261289, 0.424101, 0.798916, 0.850092, -0.249559, 0.39443, 0.835952, 0.867777, -0.236348, 0.363849, 0.871606, 0.884632, -0.221569, 0.332477, 0.907843, 0.90047, -0.20618, 0.300667, 0.944187, 0.914524, -0.188771, 0.266552, 0.981371, 0.926892, -0.168362, 0.232349, 1.01841, 0.937951, -0.146761, 0.199359, 1.05308, 0.947236, -0.123813, 0.1675, 1.0839, 0.954367, -0.099984, 0.136166, 1.11047, 0.963907, -0.0759278, 0.103808, 1.13414, 0.976218, -0.0511367, 0.0697061, 1.15575, 0.988772, -0.0267415, 0.0352529, 1.17531, 0.999888, -520778e-9, 289926e-9, 1.19389, 0.263546, -883274e-11, 0.441896, 526783e-11, 0.262352, -221849e-9, 0.439889, 132311e-9, 0.262325, -886683e-9, 0.439848, 528824e-9, 0.26228, -199476e-8, 0.439765, 118975e-8, 0.262372, -354671e-8, 0.439922, 211568e-8, 0.26239, -554141e-8, 0.439941, 330652e-8, 0.262412, -797888e-8, 0.439961, 476346e-8, 0.262453, -0.0108584, 0.440002, 648818e-8, 0.262528, -0.0141788, 0.440085, 84835e-7, 0.262615, -0.017938, 0.440166, 0.0107533, 0.262744, -0.0221346, 0.440291, 0.0133044, 0.262939, -0.026762, 0.440493, 0.0161445, 0.263277, -0.0317573, 0.440889, 0.0192974, 0.26368, -0.0371832, 0.441338, 0.0227699, 0.264106, -0.0430371, 0.441753, 0.0265698, 0.264624, -0.0493035, 0.442227, 0.0307178, 0.265378, -0.0558669, 0.442985, 0.0352616, 0.266253, -0.0628718, 0.443795, 0.0401968, 0.267478, -0.0701569, 0.445008, 0.04559, 0.269062, -0.077845, 0.446599, 0.0514539, 0.270926, -0.0857941, 0.448349, 0.0578382, 0.273693, -0.0940773, 0.451221, 0.0648363, 0.276746, -0.102704, 0.454097, 0.0724389, 0.281693, -0.111735, 0.459517, 0.0808744, 0.287335, -0.121004, 0.46531, 0.0901551, 0.29448, -0.130734, 0.472605, 0.100371, 0.30257, -0.140777, 0.480251, 0.111644, 0.312465, -0.15111, 0.489444, 0.124111, 0.324856, -0.16189, 0.500919, 0.137979, 0.33774, -0.172946, 0.511317, 0.153163, 0.35255, -0.184152, 0.522684, 0.169817, 0.367786, -0.19522, 0.53248, 0.187886, 0.385474, -0.20632, 0.543326, 0.207634, 0.404976, -0.217744, 0.554109, 0.229165, 0.425203, -0.228691, 0.563395, 0.252068, 0.446704, -0.239299, 0.571565, 0.276471, 0.468951, -0.249348, 0.577935, 0.302323, 0.493487, -0.258933, 0.584309, 0.329882, 0.517861, -0.268009, 0.58773, 0.358525, 0.543309, -0.276238, 0.589612, 0.388585, 0.569704, -0.28356, 0.589294, 0.419787, 0.594871, -0.289497, 0.585137, 0.452114, 0.622555, -0.294452, 0.580356, 0.486466, 0.651167, -0.296918, 0.57185, 0.523079, 0.677332, -0.297647, 0.558428, 0.5611, 0.703718, -0.296321, 0.542232, 0.599592, 0.730262, -0.293339, 0.524541, 0.639138, 0.754304, -0.288036, 0.502691, 0.677978, 0.778051, -0.281018, 0.479212, 0.716537, 0.801557, -0.272414, 0.454071, 0.75586, 0.822559, -0.262419, 0.425952, 0.794477, 0.843051, -0.250702, 0.397313, 0.832664, 0.86232, -0.237264, 0.366534, 0.869876, 0.879044, -0.222716, 0.334816, 0.906973, 0.896362, -0.206827, 0.303143, 0.943558, 0.910342, -0.189659, 0.269699, 0.979759, 0.924119, -0.171108, 0.236411, 1.01718, 0.935374, -0.149579, 0.202224, 1.05289, 0.944295, -0.126295, 0.16989, 1.08496, 0.952227, -0.101511, 0.138089, 1.11256, 0.962041, -0.0766392, 0.105053, 1.1375, 0.97528, -0.0511967, 0.070329, 1.15983, 0.988476, -0.025463, 0.0351268, 1.17987, 0.999962, 286808e-10, 145564e-10, 1.19901, 0.227089, -841413e-11, 0.404216, 472707e-11, 0.239725, -215083e-9, 0.426708, 120833e-9, 0.239904, -860718e-9, 0.427028, 483555e-9, 0.239911, -193661e-8, 0.427039, 108806e-8, 0.239914, -344276e-8, 0.42704, 193457e-8, 0.239933, -537907e-8, 0.427064, 302363e-8, 0.239944, -774482e-8, 0.427065, 435604e-8, 0.239993, -0.01054, 0.427122, 593398e-8, 0.240052, -0.0137626, 0.427179, 775987e-8, 0.240148, -0.0174115, 0.427279, 983854e-8, 0.240278, -0.021484, 0.42741, 0.0121763, 0.240472, -0.0259729, 0.427618, 0.0147827, 0.240839, -0.0308131, 0.428086, 0.0176837, 0.241201, -0.0360893, 0.428482, 0.0208775, 0.241626, -0.0417723, 0.428907, 0.0243821, 0.242207, -0.0478337, 0.42952, 0.0282228, 0.24298, -0.0542199, 0.430332, 0.0324333, 0.243881, -0.0610015, 0.431222, 0.0370252, 0.245123, -0.0680874, 0.432512, 0.0420535, 0.24667, -0.0755482, 0.434088, 0.0475414, 0.248779, -0.0832873, 0.436323, 0.0535542, 0.251665, -0.0913546, 0.439509, 0.0601716, 0.255305, -0.0998489, 0.443478, 0.0674282, 0.260049, -0.108576, 0.448713, 0.0754673, 0.266192, -0.117754, 0.455524, 0.084339, 0.273158, -0.127294, 0.4627, 0.0941683, 0.282131, -0.137311, 0.472068, 0.10515, 0.293332, -0.147736, 0.483565, 0.117402, 0.304667, -0.158357, 0.493702, 0.130824, 0.317785, -0.169274, 0.504708, 0.145724, 0.333245, -0.180595, 0.517107, 0.16215, 0.349843, -0.191892, 0.528849, 0.180149, 0.367944, -0.203168, 0.540301, 0.199746, 0.387579, -0.214443, 0.551514, 0.221047, 0.408247, -0.225624, 0.560906, 0.243981, 0.43014, -0.236422, 0.56959, 0.268513, 0.452669, -0.24654, 0.576098, 0.294409, 0.476196, -0.256157, 0.580925, 0.322002, 0.501157, -0.265289, 0.584839, 0.351052, 0.527632, -0.273671, 0.587614, 0.3812, 0.555754, -0.281254, 0.589119, 0.412994, 0.581682, -0.287448, 0.585204, 0.445498, 0.608196, -0.292614, 0.579006, 0.479505, 0.635661, -0.296068, 0.571297, 0.514643, 0.664999, -0.297395, 0.560855, 0.552213, 0.691039, -0.296645, 0.544525, 0.591365, 0.7179, -0.293785, 0.526535, 0.630883, 0.744059, -0.289089, 0.50545, 0.670932, 0.76863, -0.282239, 0.482514, 0.710904, 0.793273, -0.273688, 0.457246, 0.750259, 0.814731, -0.26328, 0.428872, 0.78948, 0.835603, -0.251526, 0.399384, 0.828597, 0.85489, -0.238339, 0.368811, 0.866892, 0.872828, -0.223607, 0.336617, 0.90563, 0.889462, -0.207538, 0.303997, 0.943538, 0.904929, -0.190297, 0.270812, 0.980591, 0.919101, -0.172034, 0.237453, 1.01935, 0.930536, -0.152058, 0.204431, 1.05498, 0.941223, -0.129515, 0.172495, 1.08717, 0.94982, -0.104263, 0.140175, 1.11551, 0.960592, -0.0781944, 0.106465, 1.14098, 0.974629, -0.051688, 0.0711592, 1.16418, 0.98811, -0.0253929, 0.0354432, 1.18465, 1.00004, 804378e-9, -330876e-9, 1.20462, 0.214668, -821282e-11, 0.406619, 433582e-11, 0.218053, -208144e-9, 0.413025, 109887e-9, 0.217987, -832212e-9, 0.412901, 439362e-9, 0.217971, -187246e-8, 0.412876, 988623e-9, 0.217968, -332855e-8, 0.41286, 175772e-8, 0.217985, -520055e-8, 0.412882, 274729e-8, 0.218014, -748814e-8, 0.412916, 395842e-8, 0.218054, -0.0101901, 0.412957, 539274e-8, 0.218106, -0.0133057, 0.413005, 705348e-8, 0.218217, -0.0168342, 0.413139, 894581e-8, 0.218338, -0.0207707, 0.413258, 0.0110754, 0.21855, -0.0251001, 0.413509, 0.0134551, 0.218913, -0.0297861, 0.413992, 0.0161081, 0.219265, -0.0348956, 0.414383, 0.0190307, 0.219696, -0.0403909, 0.414839, 0.0222458, 0.220329, -0.0462003, 0.415567, 0.025792, 0.220989, -0.0524208, 0.41621, 0.0296637, 0.222027, -0.058948, 0.417385, 0.0339323, 0.223301, -0.0658208, 0.418779, 0.0386055, 0.224988, -0.0730347, 0.420665, 0.0437355, 0.227211, -0.0805274, 0.423198, 0.0493844, 0.230131, -0.088395, 0.426566, 0.0556135, 0.233908, -0.0966208, 0.43091, 0.0624829, 0.239092, -0.105223, 0.437148, 0.0701636, 0.245315, -0.11424, 0.444302, 0.0786949, 0.253166, -0.12368, 0.453262, 0.0882382, 0.262374, -0.133569, 0.463211, 0.0988682, 0.273145, -0.143836, 0.474271, 0.110727, 0.285512, -0.154577, 0.4863, 0.123945, 0.299512, -0.165501, 0.498817, 0.138581, 0.314287, -0.176698, 0.510341, 0.154676, 0.331083, -0.188066, 0.522583, 0.172459, 0.349615, -0.199597, 0.534879, 0.191979, 0.369318, -0.210843, 0.546083, 0.21309, 0.390377, -0.222068, 0.5562, 0.235998, 0.412411, -0.233059, 0.564704, 0.260518, 0.435715, -0.24357, 0.572314, 0.286795, 0.461196, -0.253356, 0.579395, 0.314559, 0.485587, -0.262362, 0.581985, 0.343581, 0.511908, -0.270895, 0.584347, 0.374367, 0.539798, -0.278452, 0.58505, 0.406015, 0.567974, -0.284877, 0.583344, 0.439168, 0.594303, -0.290124, 0.577348, 0.473005, 0.622951, -0.294183, 0.570751, 0.508534, 0.652404, -0.296389, 0.561541, 0.544764, 0.679291, -0.296605, 0.546426, 0.582927, 0.706437, -0.294095, 0.528599, 0.622681, 0.734485, -0.28978, 0.508676, 0.663567, 0.758841, -0.283363, 0.484768, 0.704092, 0.78537, -0.275015, 0.460434, 0.745101, 0.807315, -0.264689, 0.432166, 0.784712, 0.8271, -0.252597, 0.401807, 0.824241, 0.849191, -0.239154, 0.371458, 0.863803, 0.867046, -0.224451, 0.338873, 0.903063, 0.8852, -0.208342, 0.306175, 0.942763, 0.901771, -0.190684, 0.272759, 0.981559, 0.915958, -0.172105, 0.239306, 1.02048, 0.928046, -0.152214, 0.206071, 1.05765, 0.939961, -0.130247, 0.17367, 1.08999, 0.948711, -0.10672, 0.142201, 1.11829, 0.959305, -0.0808688, 0.108454, 1.14467, 0.973009, -0.0539145, 0.0728109, 1.16839, 0.987631, -0.0262947, 0.0360625, 1.19004, 0.999978, 132758e-8, -559424e-9, 1.21058, 0.193925, -793421e-11, 0.391974, 392537e-11, 0.196746, -200315e-9, 0.397675, 991033e-10, 0.19667, -801099e-9, 0.397521, 396342e-9, 0.196633, -180246e-8, 0.397445, 891829e-9, 0.196654, -320443e-8, 0.397482, 158582e-8, 0.196659, -500647e-8, 0.39748, 247867e-8, 0.196683, -72086e-7, 0.397506, 357167e-8, 0.196728, -981001e-8, 0.397562, 486675e-8, 0.196792, -0.0128096, 0.397633, 636707e-8, 0.19689, -0.0162055, 0.397746, 807752e-8, 0.197017, -0.0199943, 0.397884, 0.0100052, 0.19729, -0.024139, 0.39827, 0.0121691, 0.197583, -0.0286671, 0.398639, 0.0145755, 0.197927, -0.0335858, 0.399034, 0.0172355, 0.198383, -0.0388806, 0.399554, 0.0201718, 0.199002, -0.0444736, 0.400289, 0.0234194, 0.199739, -0.0504583, 0.401111, 0.026984, 0.200784, -0.056729, 0.402349, 0.0309217, 0.202075, -0.0633643, 0.403841, 0.0352496, 0.203898, -0.0703247, 0.406076, 0.0400313, 0.206199, -0.0775565, 0.408841, 0.0453282, 0.209252, -0.085184, 0.41259, 0.0511794, 0.213638, -0.0931994, 0.418288, 0.0577459, 0.21881, -0.101617, 0.424681, 0.0650508, 0.225642, -0.11052, 0.433429, 0.0732759, 0.233717, -0.119772, 0.442897, 0.0824683, 0.242823, -0.129505, 0.452888, 0.0927484, 0.254772, -0.139906, 0.466407, 0.104417, 0.266603, -0.150402, 0.477413, 0.117211, 0.28073, -0.161395, 0.490519, 0.131598, 0.295399, -0.172465, 0.50201, 0.147407, 0.312705, -0.183982, 0.515311, 0.165031, 0.331335, -0.195532, 0.52786, 0.184336, 0.351037, -0.206971, 0.5392, 0.205361, 0.372175, -0.218117, 0.54941, 0.228043, 0.394548, -0.229327, 0.558642, 0.25267, 0.419598, -0.240052, 0.567861, 0.279071, 0.443922, -0.249937, 0.573332, 0.306882, 0.471495, -0.259407, 0.58013, 0.33661, 0.496769, -0.267749, 0.580564, 0.367328, 0.524951, -0.275524, 0.581696, 0.399753, 0.55318, -0.282148, 0.579885, 0.433134, 0.581577, -0.287533, 0.575471, 0.467534, 0.609231, -0.291612, 0.567445, 0.502943, 0.637478, -0.293911, 0.557657, 0.53871, 0.667795, -0.295096, 0.546535, 0.576568, 0.694272, -0.294073, 0.529561, 0.614929, 0.722937, -0.290386, 0.510561, 0.655909, 0.749682, -0.284481, 0.487846, 0.697663, 0.774754, -0.276188, 0.462487, 0.738515, 0.799301, -0.266215, 0.43481, 0.779802, 0.820762, -0.254116, 0.404879, 0.820045, 0.843231, -0.240393, 0.374559, 0.860294, 0.861857, -0.225503, 0.341582, 0.900965, 0.880815, -0.209382, 0.308778, 0.941727, 0.89766, -0.19155, 0.275232, 0.980916, 0.912926, -0.172346, 0.240938, 1.02162, 0.926391, -0.151799, 0.207223, 1.0597, 0.938429, -0.129968, 0.17484, 1.09291, 0.947834, -0.10651, 0.142984, 1.12248, 0.958432, -0.0824098, 0.109902, 1.149, 0.972402, -0.0565242, 0.0744454, 1.1733, 0.987191, -0.028427, 0.0373794, 1.19538, 0.999975, 385685e-10, -4203e-8, 1.21676, 0.178114, -766075e-11, 0.385418, 354027e-11, 0.176074, -191966e-9, 0.381002, 887135e-10, 0.17601, -767549e-9, 0.380861, 354715e-9, 0.17598, -172696e-8, 0.380798, 798168e-9, 0.175994, -307012e-8, 0.380824, 141928e-8, 0.176017, -479684e-8, 0.380858, 221859e-8, 0.176019, -690648e-8, 0.380839, 319714e-8, 0.176072, -939888e-8, 0.380913, 43572e-7, 0.176131, -0.0122726, 0.380979, 5702e-6, 0.176239, -0.0155264, 0.38112, 723689e-8, 0.176371, -0.0191551, 0.381272, 896907e-8, 0.176638, -0.023117, 0.381669, 0.0109194, 0.176912, -0.0274633, 0.382015, 0.0130903, 0.177279, -0.032173, 0.382476, 0.0154949, 0.17774, -0.0372219, 0.383041, 0.0181669, 0.178344, -0.0426132, 0.38378, 0.0211209, 0.179153, -0.0483309, 0.384773, 0.0243899, 0.180197, -0.0543447, 0.386076, 0.0280062, 0.181581, -0.0607122, 0.387809, 0.032004, 0.18344, -0.0673855, 0.390205, 0.036453, 0.186139, -0.0743989, 0.393944, 0.0414162, 0.189432, -0.0817731, 0.39832, 0.0469394, 0.193795, -0.0895464, 0.404188, 0.0531442, 0.199641, -0.0978264, 0.4121, 0.0601374, 0.206679, -0.106499, 0.421425, 0.0680078, 0.214865, -0.115654, 0.431504, 0.076919, 0.224406, -0.125268, 0.442526, 0.0868835, 0.235876, -0.135475, 0.455465, 0.0981875, 0.248335, -0.146023, 0.4681, 0.110759, 0.262868, -0.157016, 0.482069, 0.124885, 0.278962, -0.168245, 0.496182, 0.140645, 0.295082, -0.17958, 0.507401, 0.157838, 0.313738, -0.191227, 0.520252, 0.17695, 0.333573, -0.202718, 0.531708, 0.197817, 0.356433, -0.214424, 0.544509, 0.220785, 0.378853, -0.225492, 0.55373, 0.245306, 0.402717, -0.236236, 0.561348, 0.271593, 0.428375, -0.246568, 0.568538, 0.299776, 0.454724, -0.255941, 0.573462, 0.329433, 0.482291, -0.264511, 0.576356, 0.360598, 0.509706, -0.272129, 0.576446, 0.393204, 0.538805, -0.278979, 0.575298, 0.427227, 0.568919, -0.284528, 0.572154, 0.462157, 0.596804, -0.288801, 0.564691, 0.497997, 0.625987, -0.291334, 0.555134, 0.534467, 0.656414, -0.292722, 0.545051, 0.571736, 0.683916, -0.292185, 0.528813, 0.610158, 0.711809, -0.290043, 0.51106, 0.649061, 0.739547, -0.285246, 0.490103, 0.690081, 0.766914, -0.277647, 0.465523, 0.732554, 0.791375, -0.267603, 0.437718, 0.773982, 0.814772, -0.256109, 0.40882, 0.81609, 0.836691, -0.242281, 0.377823, 0.856849, 0.856984, -0.227155, 0.34496, 0.898363, 0.876332, -0.210395, 0.311335, 0.939471, 0.894988, -0.192612, 0.277703, 0.980799, 0.911113, -0.173236, 0.243019, 1.02215, 0.924092, -0.152258, 0.209037, 1.06139, 0.936828, -0.129575, 0.175909, 1.09635, 0.946869, -0.10594, 0.143852, 1.12707, 0.958284, -0.081318, 0.110289, 1.15419, 0.972325, -0.0556133, 0.0747232, 1.17909, 0.986878, -0.0297899, 0.0383149, 1.20163, 0.999936, -197169e-8, 912402e-9, 1.22338, 0.151174, -720365e-11, 0.351531, 309789e-11, 0.155594, -18279e-8, 0.361806, 78608e-9, 0.156099, -731569e-9, 0.362982, 314615e-9, 0.156053, -164578e-8, 0.362869, 707845e-9, 0.156093, -29261e-7, 0.362961, 125884e-8, 0.156099, -457155e-8, 0.362959, 196783e-8, 0.15612, -658224e-8, 0.362982, 283622e-8, 0.156168, -895774e-8, 0.363048, 386625e-8, 0.156221, -0.0116962, 0.363101, 506109e-8, 0.156324, -0.0147973, 0.363241, 642675e-8, 0.156476, -0.0182503, 0.363448, 797175e-8, 0.156731, -0.0220266, 0.36384, 971484e-8, 0.156994, -0.026176, 0.364179, 0.0116575, 0.157341, -0.0306701, 0.36462, 0.0138207, 0.157867, -0.0354591, 0.365364, 0.0162356, 0.15846, -0.0406141, 0.366111, 0.0189092, 0.159308, -0.0460519, 0.367248, 0.021885, 0.160426, -0.0518096, 0.368767, 0.0252004, 0.161877, -0.0578906, 0.370745, 0.0288825, 0.163995, -0.0642812, 0.373831, 0.0330139, 0.16655, -0.0710067, 0.377366, 0.0376283, 0.170237, -0.0781522, 0.382799, 0.0428493, 0.175096, -0.0857172, 0.389915, 0.0487324, 0.181069, -0.0938025, 0.398487, 0.0554214, 0.188487, -0.102363, 0.408799, 0.0630189, 0.197029, -0.111343, 0.419991, 0.071634, 0.206684, -0.120812, 0.431455, 0.0812797, 0.218698, -0.131033, 0.445746, 0.0923651, 0.230726, -0.141373, 0.457471, 0.104545, 0.245516, -0.152387, 0.472388, 0.118449, 0.261551, -0.163628, 0.486671, 0.133923, 0.277437, -0.174814, 0.49762, 0.150849, 0.296662, -0.186713, 0.51162, 0.169924, 0.31795, -0.198513, 0.525435, 0.190848, 0.339422, -0.210119, 0.536267, 0.213504, 0.362143, -0.221354, 0.545982, 0.237947, 0.387198, -0.23224, 0.555364, 0.264427, 0.412349, -0.24257, 0.561489, 0.292519, 0.439274, -0.252284, 0.566903, 0.322561, 0.466779, -0.261023, 0.569614, 0.353952, 0.496011, -0.26899, 0.571589, 0.387278, 0.524964, -0.275498, 0.570325, 0.421356, 0.556518, -0.281449, 0.568792, 0.457314, 0.584363, -0.285526, 0.560268, 0.493199, 0.614214, -0.28844, 0.55205, 0.530276, 0.645684, -0.289777, 0.541906, 0.56855, 0.673446, -0.289722, 0.526464, 0.606927, 0.701924, -0.287792, 0.509872, 0.645945, 0.73037, -0.284315, 0.490649, 0.685564, 0.757405, -0.278804, 0.467964, 0.726511, 0.784025, -0.269543, 0.441468, 0.768601, 0.808255, -0.258117, 0.41216, 0.811321, 0.830739, -0.244728, 0.380606, 0.853496, 0.851914, -0.229428, 0.348111, 0.895374, 0.872586, -0.212508, 0.314732, 0.937674, 0.891581, -0.194025, 0.280338, 0.979869, 0.907641, -0.174711, 0.245203, 1.02253, 0.922233, -0.153509, 0.21077, 1.06371, 0.935878, -0.130418, 0.177399, 1.09972, 0.946338, -0.105558, 0.144507, 1.13124, 0.957265, -0.080059, 0.110508, 1.15973, 0.971668, -0.0539766, 0.0742311, 1.18515, 0.9866, -0.0277101, 0.0375224, 1.20858, 1.00021, -515531e-9, 135226e-9, 1.23135, 0.137468, -686011e-11, 0.345041, 273315e-11, 0.13703, -173378e-9, 0.343936, 690761e-10, 0.136986, -693048e-9, 0.34383, 276126e-9, 0.136964, -155931e-8, 0.343761, 621337e-9, 0.137003, -277211e-8, 0.343863, 110494e-8, 0.137012, -433103e-8, 0.343868, 172744e-8, 0.137043, -623606e-8, 0.343916, 249022e-8, 0.13709, -84868e-7, 0.343986, 339559e-8, 0.137145, -0.0110814, 0.344045, 444687e-8, 0.137242, -0.0140187, 0.344177, 565007e-8, 0.137431, -0.0172713, 0.344491, 701868e-8, 0.137644, -0.0208605, 0.344805, 856042e-8, 0.13791, -0.024792, 0.345172, 0.0102863, 0.138295, -0.0290461, 0.345734, 0.0122185, 0.138764, -0.0335957, 0.346371, 0.0143771, 0.139415, -0.038467, 0.347298, 0.0167894, 0.140272, -0.0436176, 0.348527, 0.0194895, 0.141457, -0.0491016, 0.350276, 0.0225043, 0.14303, -0.0548764, 0.352646, 0.0258962, 0.145289, -0.0610096, 0.356206, 0.0297168, 0.148502, -0.0674777, 0.361488, 0.0340562, 0.152188, -0.074345, 0.367103, 0.0389534, 0.157359, -0.0817442, 0.375247, 0.0445541, 0.16379, -0.0896334, 0.385064, 0.0509535, 0.171376, -0.098005, 0.396082, 0.0582611, 0.179901, -0.106817, 0.407418, 0.06654, 0.189892, -0.116239, 0.420031, 0.075994, 0.201838, -0.12627, 0.434321, 0.0867239, 0.214311, -0.136701, 0.447631, 0.0987517, 0.228902, -0.147616, 0.462046, 0.112353, 0.245107, -0.158871, 0.476942, 0.127605, 0.262292, -0.170261, 0.490285, 0.144469, 0.281215, -0.182017, 0.503783, 0.163282, 0.301058, -0.193729, 0.515505, 0.183873, 0.322752, -0.205512, 0.52682, 0.206466, 0.347547, -0.217214, 0.539473, 0.231194, 0.370969, -0.227966, 0.546625, 0.257288, 0.397533, -0.238555, 0.55472, 0.285789, 0.42398, -0.248278, 0.559468, 0.315746, 0.452928, -0.257422, 0.564095, 0.347724, 0.482121, -0.265306, 0.565426, 0.380922, 0.510438, -0.272043, 0.563205, 0.415639, 0.541188, -0.277614, 0.561087, 0.451702, 0.571667, -0.281927, 0.554922, 0.48845, 0.602432, -0.285015, 0.546838, 0.526442, 0.634126, -0.286512, 0.537415, 0.564896, 0.662816, -0.286388, 0.522906, 0.604037, 0.692411, -0.284734, 0.507003, 0.643795, 0.720946, -0.281297, 0.488398, 0.68298, 0.748293, -0.276262, 0.466353, 0.723466, 0.776931, -0.269978, 0.443573, 0.764565, 0.801065, -0.260305, 0.415279, 0.805838, 0.825843, -0.247426, 0.384773, 0.849985, 0.84807, -0.232437, 0.352555, 0.893174, 0.869122, -0.215806, 0.318642, 0.936564, 0.888963, -0.197307, 0.28381, 0.980253, 0.905547, -0.177203, 0.247888, 1.02463, 0.918554, -0.155542, 0.212904, 1.06714, 0.931395, -0.131948, 0.1787, 1.10451, 0.941749, -0.106723, 0.145902, 1.13694, 0.954551, -0.0804939, 0.111193, 1.1666, 0.970279, -0.0534239, 0.0744697, 1.19249, 0.986117, -0.0257452, 0.0368788, 1.21665, 0.999938, 190634e-8, -10291e-7, 1.23981, 0.118493, -647439e-11, 0.32272, 23772e-10, 0.118765, -163023e-9, 0.323456, 598573e-10, 0.118772, -65212e-8, 0.323477, 239447e-9, 0.118843, -146741e-8, 0.323657, 538881e-9, 0.118804, -260846e-8, 0.323553, 95826e-8, 0.118826, -407576e-8, 0.323595, 149845e-8, 0.118846, -586826e-8, 0.323617, 216047e-8, 0.118886, -798578e-8, 0.32367, 294679e-8, 0.118947, -0.0104273, 0.323753, 386124e-8, 0.119055, -0.0131909, 0.323922, 490999e-8, 0.119241, -0.0162444, 0.324251, 610804e-8, 0.11944, -0.0196339, 0.324544, 745805e-8, 0.119739, -0.0233378, 0.325026, 897805e-8, 0.12011, -0.0273179, 0.325586, 0.0106895, 0.120571, -0.0316143, 0.326231, 0.0126073, 0.12124, -0.0361939, 0.327264, 0.0147654, 0.122162, -0.0410511, 0.328733, 0.0172001, 0.123378, -0.0462233, 0.330659, 0.0199375, 0.125183, -0.0517109, 0.333754, 0.0230498, 0.127832, -0.0575652, 0.338507, 0.026597, 0.130909, -0.0637441, 0.343666, 0.0306345, 0.135221, -0.0704302, 0.351063, 0.035273, 0.14082, -0.0776364, 0.360604, 0.0406137, 0.146781, -0.0852293, 0.369638, 0.0466788, 0.155121, -0.0935351, 0.3827, 0.0537628, 0.16398, -0.102234, 0.39522, 0.0617985, 0.173926, -0.111465, 0.40793, 0.07097, 0.185137, -0.121296, 0.42105, 0.0813426, 0.19826, -0.13169, 0.435735, 0.0931596, 0.212938, -0.142614, 0.450932, 0.106547, 0.229046, -0.153884, 0.465726, 0.121575, 0.246246, -0.165382, 0.479461, 0.138286, 0.264637, -0.176806, 0.492106, 0.15666, 0.284959, -0.188793, 0.504774, 0.17728, 0.308157, -0.200763, 0.518805, 0.19988, 0.330951, -0.21239, 0.528231, 0.224293, 0.3549, -0.223521, 0.536376, 0.250541, 0.381502, -0.234169, 0.544846, 0.278902, 0.409529, -0.244077, 0.551717, 0.309227, 0.437523, -0.253363, 0.55517, 0.341426, 0.467624, -0.261659, 0.557772, 0.37518, 0.497268, -0.268498, 0.556442, 0.41007, 0.528294, -0.274018, 0.553915, 0.446445, 0.559053, -0.278169, 0.549153, 0.483779, 0.589329, -0.281229, 0.539878, 0.522249, 0.622503, -0.282902, 0.53162, 0.561754, 0.652382, -0.282815, 0.518119, 0.601544, 0.681847, -0.281247, 0.502187, 0.641574, 0.712285, -0.277986, 0.484824, 0.682633, 0.740094, -0.273017, 0.463483, 0.723426, 0.768478, -0.266692, 0.441299, 0.763747, 0.794556, -0.258358, 0.415238, 0.805565, 0.819408, -0.248807, 0.386912, 0.847254, 0.843411, -0.236214, 0.356165, 0.891091, 0.862397, -0.219794, 0.320562, 0.936174, 0.883113, -0.201768, 0.285322, 0.982562, 0.90023, -0.181672, 0.249713, 1.02862, 0.915192, -0.159279, 0.214546, 1.07163, 0.928458, -0.134725, 0.180285, 1.10995, 0.94069, -0.10913, 0.147119, 1.14354, 0.953409, -0.0821315, 0.112492, 1.17372, 0.969537, -0.0542677, 0.0752014, 1.20043, 0.985612, -0.0259096, 0.0370361, 1.22528, 0.999835, 298198e-8, -151801e-8, 1.24959, 0.10097, -602574e-11, 0.300277, 202619e-11, 0.101577, -152164e-9, 0.302077, 511662e-10, 0.101572, -608889e-9, 0.302066, 204751e-9, 0.101566, -136997e-8, 0.302047, 460753e-9, 0.101592, -243557e-8, 0.302114, 819497e-9, 0.101608, -38053e-7, 0.30214, 128154e-8, 0.101627, -547906e-8, 0.30216, 18483e-7, 0.101669, -745647e-8, 0.302224, 252223e-8, 0.101732, -973615e-8, 0.302318, 330716e-8, 0.101844, -0.0123097, 0.302513, 421061e-8, 0.102025, -0.0151681, 0.30285, 524481e-8, 0.102224, -0.0183334, 0.303166, 64154e-7, 0.102515, -0.0217819, 0.303654, 774063e-8, 0.102886, -0.0255067, 0.304243, 92398e-7, 0.103395, -0.029514, 0.305089, 0.0109339, 0.104109, -0.0337912, 0.306301, 0.0128561, 0.105074, -0.0383565, 0.30798, 0.0150338, 0.10654, -0.0432132, 0.310726, 0.0175228, 0.108478, -0.0484244, 0.314351, 0.0203648, 0.111015, -0.0539339, 0.319032, 0.0236325, 0.114682, -0.0598885, 0.32605, 0.0274188, 0.11911, -0.0663375, 0.334109, 0.0317905, 0.124736, -0.0733011, 0.344013, 0.0368502, 0.131479, -0.0807744, 0.355358, 0.0427104, 0.139283, -0.0888204, 0.367614, 0.0494788, 0.148054, -0.0973394, 0.380072, 0.0572367, 0.159037, -0.10665, 0.395678, 0.0662704, 0.169794, -0.116221, 0.40795, 0.0763192, 0.18314, -0.126632, 0.423546, 0.087956, 0.197515, -0.137383, 0.438213, 0.101042, 0.213514, -0.148641, 0.453248, 0.115827, 0.23065, -0.160117, 0.46688, 0.132283, 0.249148, -0.171807, 0.479962, 0.150644, 0.270219, -0.183695, 0.494618, 0.171073, 0.292338, -0.195574, 0.506937, 0.193378, 0.314999, -0.207205, 0.516463, 0.217585, 0.340991, -0.218955, 0.528123, 0.24428, 0.367982, -0.229917, 0.537025, 0.272784, 0.39432, -0.239737, 0.541627, 0.302742, 0.423364, -0.249048, 0.546466, 0.335112, 0.453751, -0.257329, 0.549466, 0.369032, 0.48416, -0.264623, 0.549503, 0.404577, 0.515262, -0.270411, 0.547008, 0.441337, 0.547036, -0.274581, 0.542249, 0.479162, 0.576614, -0.277266, 0.533015, 0.517904, 0.611143, -0.279144, 0.525512, 0.558508, 0.640989, -0.279001, 0.51154, 0.598995, 0.671182, -0.277324, 0.495641, 0.639935, 0.700848, -0.273908, 0.477526, 0.681017, 0.729862, -0.269063, 0.457955, 0.722764, 0.758273, -0.262282, 0.434846, 0.764349, 0.784121, -0.254281, 0.409203, 0.806206, 0.809798, -0.24505, 0.382694, 0.848617, 0.834953, -0.233861, 0.354034, 0.892445, 0.856817, -0.221308, 0.321764, 0.936263, 0.877609, -0.205996, 0.288118, 0.982401, 0.897489, -0.186702, 0.253277, 1.02975, 0.913792, -0.164618, 0.217963, 1.07488, 0.92785, -0.140023, 0.183221, 1.11487, 0.940378, -0.11328, 0.149385, 1.14947, 0.95273, -0.0853958, 0.114152, 1.1807, 0.969059, -0.0568698, 0.0769845, 1.20912, 0.985574, -0.0276502, 0.0381186, 1.23498, 0.999943, 239052e-8, -126861e-8, 1.25987, 0.0852715, -560067e-11, 0.279021, 171162e-11, 0.0854143, -140871e-9, 0.279483, 430516e-10, 0.0854191, -563385e-9, 0.2795, 172184e-9, 0.0854188, -126753e-8, 0.279493, 387464e-9, 0.0854229, -225337e-8, 0.279501, 68918e-8, 0.0854443, -352086e-8, 0.279549, 107803e-8, 0.0854697, -506962e-8, 0.279591, 155536e-8, 0.0855093, -689873e-8, 0.279652, 212354e-8, 0.0855724, -900821e-8, 0.279752, 278703e-8, 0.0856991, -0.0113799, 0.280011, 35551e-7, 0.085855, -0.0140314, 0.280297, 443449e-8, 0.0860682, -0.016963, 0.280682, 543636e-8, 0.086344, -0.0201438, 0.281159, 65788e-7, 0.0867426, -0.0235999, 0.281886, 787977e-8, 0.087239, -0.0273069, 0.282745, 93606e-7, 0.0879815, -0.031269, 0.284139, 0.011056, 0.0891258, -0.035531, 0.28647, 0.0130065, 0.0906909, -0.0400947, 0.289708, 0.0152495, 0.0927624, -0.0449638, 0.293904, 0.0178454, 0.0958376, -0.0502427, 0.300471, 0.0208915, 0.0995827, -0.0559514, 0.30806, 0.0244247, 0.104526, -0.0622152, 0.317874, 0.0285721, 0.110532, -0.0690046, 0.329332, 0.0334227, 0.117385, -0.0763068, 0.341217, 0.0390466, 0.12522, -0.084184, 0.353968, 0.0455786, 0.134037, -0.0925248, 0.366797, 0.0530773, 0.144014, -0.101487, 0.380209, 0.0617424, 0.156013, -0.111273, 0.395956, 0.071777, 0.168872, -0.121431, 0.41053, 0.0830905, 0.183089, -0.132105, 0.425073, 0.0959341, 0.198763, -0.143286, 0.439833, 0.110448, 0.216159, -0.154841, 0.454507, 0.126769, 0.234859, -0.166588, 0.468368, 0.14495, 0.255879, -0.178626, 0.482846, 0.165233, 0.27677, -0.190218, 0.493489, 0.187217, 0.301184, -0.202227, 0.506549, 0.211659, 0.325852, -0.213764, 0.5158, 0.237922, 0.352824, -0.22487, 0.525442, 0.26632, 0.380882, -0.235246, 0.532487, 0.296691, 0.410137, -0.244847, 0.537703, 0.329179, 0.439787, -0.253122, 0.540361, 0.363135, 0.472291, -0.260517, 0.542734, 0.399222, 0.501856, -0.266519, 0.538826, 0.436352, 0.534816, -0.270905, 0.535152, 0.474505, 0.565069, -0.273826, 0.525979, 0.513988, 0.597154, -0.275333, 0.516394, 0.554852, 0.630473, -0.275314, 0.506206, 0.596592, 0.660574, -0.273323, 0.489769, 0.638117, 0.692015, -0.270008, 0.472578, 0.680457, 0.720647, -0.265001, 0.452134, 0.723008, 0.750528, -0.258311, 0.430344, 0.765954, 0.777568, -0.250046, 0.405624, 0.809012, 0.80387, -0.240114, 0.378339, 0.852425, 0.828439, -0.228737, 0.349877, 0.895346, 0.851472, -0.216632, 0.318968, 0.940695, 0.873906, -0.202782, 0.287489, 0.987235, 0.89467, -0.187059, 0.254394, 1.03348, 0.912281, -0.168818, 0.221294, 1.07812, 0.927358, -0.146494, 0.18675, 1.11928, 0.940385, -0.120009, 0.152322, 1.15609, 0.952672, -0.0917183, 0.117514, 1.18875, 0.968496, -0.0620321, 0.0797405, 1.21821, 0.985236, -0.0314945, 0.0402383, 1.24523, 0.99998, -575153e-9, 110644e-9, 1.27133, 0.0702429, -512222e-11, 0.255273, 140947e-11, 0.0702981, -128826e-9, 0.255469, 354488e-10, 0.0703691, -515562e-9, 0.255727, 141874e-9, 0.0703805, -116e-5, 0.255754, 31929e-8, 0.0703961, -206224e-8, 0.255813, 567999e-9, 0.0704102, -322223e-8, 0.255839, 88871e-8, 0.0704298, -463928e-8, 0.255863, 128272e-8, 0.0704759, -631375e-8, 0.255953, 175283e-8, 0.0705434, -824317e-8, 0.256079, 230342e-8, 0.0706693, -0.010412, 0.25636, 29443e-7, 0.0708189, -0.0128439, 0.256647, 368031e-8, 0.0710364, -0.0155177, 0.257084, 452614e-8, 0.0713223, -0.0184374, 0.257637, 549706e-8, 0.0717182, -0.0216002, 0.258416, 661246e-8, 0.072321, -0.0249966, 0.259699, 790147e-8, 0.0731446, -0.0286566, 0.261475, 93884e-7, 0.0743352, -0.0325888, 0.264132, 0.0111186, 0.0760676, -0.036843, 0.26815, 0.013145, 0.078454, -0.0414292, 0.273636, 0.0155251, 0.0818618, -0.0464634, 0.281653, 0.0183525, 0.0857382, -0.0519478, 0.289992, 0.0216642, 0.0908131, -0.0579836, 0.30066, 0.0255956, 0.0967512, -0.0645124, 0.312204, 0.0301954, 0.103717, -0.0716505, 0.325001, 0.0356017, 0.111596, -0.0793232, 0.338129, 0.041896, 0.120933, -0.087645, 0.352853, 0.0492447, 0.130787, -0.096492, 0.366192, 0.0576749, 0.142311, -0.105973, 0.380864, 0.0673969, 0.155344, -0.116182, 0.396575, 0.0785899, 0.169535, -0.126815, 0.411443, 0.0912377, 0.185173, -0.138015, 0.426256, 0.105607, 0.201755, -0.149325, 0.439607, 0.121551, 0.221334, -0.161207, 0.455467, 0.139608, 0.241461, -0.173162, 0.469096, 0.159591, 0.26294, -0.18504, 0.481014, 0.18156, 0.286776, -0.196881, 0.493291, 0.205781, 0.311596, -0.208311, 0.503556, 0.231819, 0.338667, -0.219671, 0.513268, 0.260274, 0.366021, -0.230451, 0.519414, 0.290862, 0.395875, -0.240131, 0.526766, 0.323196, 0.425564, -0.248566, 0.52905, 0.357071, 0.457094, -0.256195, 0.530796, 0.393262, 0.488286, -0.262331, 0.528703, 0.430797, 0.522291, -0.267141, 0.52727, 0.470231, 0.554172, -0.270411, 0.519848, 0.510477, 0.586427, -0.271986, 0.510307, 0.551594, 0.619638, -0.27192, 0.499158, 0.593849, 0.650656, -0.269817, 0.483852, 0.636314, 0.68284, -0.266267, 0.467515, 0.679679, 0.714356, -0.26113, 0.44931, 0.723884, 0.742717, -0.254067, 0.425789, 0.767245, 0.770894, -0.245652, 0.401144, 0.811819, 0.797358, -0.235554, 0.374224, 0.856315, 0.823377, -0.223896, 0.346167, 0.901077, 0.847456, -0.210865, 0.316056, 0.946502, 0.870697, -0.196574, 0.284503, 0.993711, 0.891068, -0.180814, 0.251628, 1.04134, 0.909267, -0.163314, 0.219065, 1.08609, 0.925653, -0.143304, 0.186446, 1.12702, 0.940017, -0.121322, 0.153416, 1.16371, 0.952398, -0.0973872, 0.120334, 1.19712, 0.967568, -0.0698785, 0.08352, 1.22791, 0.984772, -0.0390031, 0.0439209, 1.25672, 1.00026, -70087e-7, 315668e-8, 1.28428, 0.0556653, -459654e-11, 0.227325, 112556e-11, 0.0565238, -116382e-9, 0.230826, 284985e-10, 0.0565717, -465666e-9, 0.231026, 114036e-9, 0.0565859, -104773e-8, 0.231079, 256656e-9, 0.0565761, -186255e-8, 0.231025, 45663e-8, 0.0565913, -291002e-8, 0.231058, 714664e-9, 0.0566108, -418998e-8, 0.231085, 103224e-8, 0.0566532, -570206e-8, 0.231169, 141202e-8, 0.0567473, -743666e-8, 0.231417, 186018e-8, 0.0568567, -940298e-8, 0.231661, 238264e-8, 0.0569859, -0.0115991, 0.231895, 298699e-8, 0.0572221, -0.0140096, 0.232456, 368957e-8, 0.057519, -0.0166508, 0.233096, 450303e-8, 0.0579534, -0.01951, 0.234094, 544945e-8, 0.0585922, -0.0225991, 0.235629, 655564e-8, 0.0595647, -0.0259416, 0.238106, 785724e-8, 0.0609109, -0.0295661, 0.241557, 939127e-8, 0.0628751, -0.0335126, 0.246652, 0.0112198, 0.0656908, -0.0378604, 0.254091, 0.0134168, 0.0691347, -0.0426543, 0.262666, 0.0160374, 0.0732165, -0.0478967, 0.272029, 0.0191514, 0.0782863, -0.0536716, 0.283007, 0.0228597, 0.0843973, -0.0600683, 0.295732, 0.0272829, 0.0913598, -0.0670095, 0.308779, 0.032484, 0.0994407, -0.0745516, 0.322886, 0.0385886, 0.108189, -0.082712, 0.336408, 0.0457133, 0.118574, -0.0914927, 0.351692, 0.0539832, 0.129989, -0.100854, 0.366502, 0.0635162, 0.142722, -0.110837, 0.381675, 0.0744386, 0.156654, -0.121353, 0.3963, 0.0868483, 0.172151, -0.132414, 0.411477, 0.100963, 0.188712, -0.143809, 0.42508, 0.116795, 0.208093, -0.155765, 0.441328, 0.134715, 0.227936, -0.167608, 0.454328, 0.154396, 0.249495, -0.179579, 0.467235, 0.176179, 0.27362, -0.191488, 0.480248, 0.200193, 0.296371, -0.202618, 0.487886, 0.225775, 0.324234, -0.214133, 0.499632, 0.25441, 0.353049, -0.225212, 0.509532, 0.285077, 0.381785, -0.234875, 0.514265, 0.317047, 0.414038, -0.244205, 0.521282, 0.351874, 0.445251, -0.252145, 0.522931, 0.388279, 0.476819, -0.258433, 0.520947, 0.425825, 0.509209, -0.263411, 0.517669, 0.465104, 0.542759, -0.266732, 0.512841, 0.505741, 0.574822, -0.268263, 0.503317, 0.547611, 0.609324, -0.268489, 0.493035, 0.590953, 0.641772, -0.266941, 0.478816, 0.63488, 0.674049, -0.263297, 0.462863, 0.679072, 0.705071, -0.257618, 0.442931, 0.723487, 0.734709, -0.250625, 0.421299, 0.768708, 0.763704, -0.24179, 0.397085, 0.814375, 0.791818, -0.231115, 0.370577, 0.859907, 0.817439, -0.21922, 0.34232, 0.906715, 0.843202, -0.205658, 0.312627, 0.953943, 0.866639, -0.190563, 0.280933, 1.00185, 0.888129, -0.173978, 0.248393, 1.05105, 0.907239, -0.155485, 0.216007, 1.09704, 0.923893, -0.134782, 0.183233, 1.13857, 0.938882, -0.11249, 0.150376, 1.17539, 0.952464, -0.0890706, 0.117177, 1.20924, 0.968529, -0.0646523, 0.0813095, 1.24055, 0.984763, -0.038606, 0.0439378, 1.27018, 1.00053, -0.01238, 598668e-8, 1.29873, 0.0437928, -409594e-11, 0.204012, 879224e-12, 0.0440166, -103395e-9, 0.205049, 221946e-10, 0.0440529, -413633e-9, 0.205225, 887981e-10, 0.0440493, -930594e-9, 0.2052, 199858e-9, 0.0439884, -165352e-8, 0.204901, 355495e-9, 0.0440716, -25849e-7, 0.205255, 556983e-9, 0.0440968, -372222e-8, 0.205311, 805326e-9, 0.0441359, -506478e-8, 0.205391, 110333e-8, 0.0442231, -660384e-8, 0.205638, 145768e-8, 0.0443254, -835246e-8, 0.205877, 187275e-8, 0.0444832, -0.0102992, 0.20627, 235938e-8, 0.0447001, -0.0124449, 0.206796, 29299e-7, 0.0450168, -0.0147935, 0.207593, 36005e-7, 0.0454816, -0.017336, 0.208819, 439246e-8, 0.0462446, -0.0201156, 0.211036, 533864e-8, 0.0473694, -0.0231568, 0.214388, 646984e-8, 0.0490191, -0.0264941, 0.219357, 783856e-8, 0.0512776, -0.030184, 0.226061, 950182e-8, 0.0541279, -0.0342661, 0.234094, 0.0115156, 0.0578989, -0.0388539, 0.244297, 0.0139687, 0.0620835, -0.0438735, 0.254457, 0.0169015, 0.0673497, -0.04951, 0.266706, 0.0204554, 0.0731759, -0.0556263, 0.278753, 0.0246606, 0.0803937, -0.0624585, 0.29309, 0.0297126, 0.0879287, -0.0697556, 0.305856, 0.0355868, 0.0970669, -0.0778795, 0.321059, 0.0425768, 0.106508, -0.0863541, 0.333873, 0.05056, 0.11776, -0.0955935, 0.349008, 0.0598972, 0.130081, -0.105438, 0.363776, 0.0706314, 0.144454, -0.115899, 0.380112, 0.0828822, 0.1596, -0.126827, 0.394843, 0.0967611, 0.176097, -0.138161, 0.409033, 0.112381, 0.194726, -0.149904, 0.424257, 0.129952, 0.213944, -0.161675, 0.436945, 0.149333, 0.235516, -0.173659, 0.450176, 0.170892, 0.260564, -0.185963, 0.466305, 0.194984, 0.285183, -0.197582, 0.477328, 0.220805, 0.311095, -0.208697, 0.486566, 0.248694, 0.338924, -0.219519, 0.494811, 0.279015, 0.369757, -0.229766, 0.504065, 0.311725, 0.3996, -0.238879, 0.507909, 0.345844, 0.430484, -0.246802, 0.509805, 0.381749, 0.46413, -0.253924, 0.511436, 0.420251, 0.497077, -0.259319, 0.508787, 0.459957, 0.530434, -0.263297, 0.50394, 0.501356, 0.565725, -0.265619, 0.49804, 0.544252, 0.599254, -0.265842, 0.487346, 0.587856, 0.631251, -0.263978, 0.472975, 0.631969, 0.663972, -0.26043, 0.457135, 0.677471, 0.697724, -0.255358, 0.439844, 0.723744, 0.727725, -0.248308, 0.417872, 0.770653, 0.756417, -0.239181, 0.39273, 0.817357, 0.785419, -0.22814, 0.367839, 0.864221, 0.81266, -0.215681, 0.339449, 0.912701, 0.839391, -0.201623, 0.309279, 0.962419, 0.86366, -0.185624, 0.278029, 1.0122, 0.885028, -0.16797, 0.245294, 1.06186, 0.904639, -0.148336, 0.212689, 1.10934, 0.922048, -0.12637, 0.179616, 1.15063, 0.936952, -0.102928, 0.146749, 1.18885, 0.951895, -0.0785268, 0.112733, 1.22352, 0.967198, -0.0530153, 0.0760056, 1.25681, 0.984405, -0.02649, 0.0383183, 1.28762, 1.00021, 70019e-8, -20039e-8, 1.31656, 0.0325964, -355447e-11, 0.176706, 655682e-12, 0.0329333, -899174e-10, 0.178527, 165869e-10, 0.0329181, -359637e-9, 0.178453, 663498e-10, 0.0329085, -808991e-9, 0.178383, 149332e-9, 0.0329181, -143826e-8, 0.178394, 265873e-9, 0.0329425, -224678e-8, 0.178517, 416597e-9, 0.0329511, -323575e-8, 0.17849, 603299e-9, 0.033011, -439875e-8, 0.178695, 829422e-9, 0.0330733, -574059e-8, 0.178843, 109908e-8, 0.0331857, -725896e-8, 0.179176, 141933e-8, 0.0333445, -895289e-8, 0.179618, 17999e-7, 0.0335674, -0.0108219, 0.180238, 225316e-8, 0.033939, -0.0128687, 0.181417, 279765e-8, 0.0345239, -0.015114, 0.183395, 34564e-7, 0.0354458, -0.017596, 0.186616, 425864e-8, 0.0368313, -0.0203524, 0.191547, 524936e-8, 0.0386115, -0.0234105, 0.197508, 647033e-8, 0.0410303, -0.0268509, 0.205395, 798121e-8, 0.0442245, -0.0307481, 0.215365, 98557e-7, 0.0478659, -0.0350863, 0.225595, 0.0121417, 0.0522416, -0.0399506, 0.236946, 0.0149385, 0.0574513, -0.045357, 0.249442, 0.0183189, 0.0631208, -0.0512863, 0.261222, 0.0223644, 0.0701124, -0.0579273, 0.275418, 0.0272418, 0.0777331, -0.0650652, 0.288989, 0.0329458, 0.0862709, -0.0728813, 0.302546, 0.0396819, 0.096103, -0.081363, 0.317164, 0.04757, 0.106976, -0.0904463, 0.331733, 0.0567012, 0.119175, -0.100105, 0.34661, 0.067202, 0.132919, -0.110375, 0.362249, 0.0792588, 0.147727, -0.121115, 0.376978, 0.0928672, 0.163618, -0.132299, 0.390681, 0.108228, 0.182234, -0.143887, 0.406571, 0.125502, 0.201809, -0.155827, 0.42042, 0.144836, 0.225041, -0.168357, 0.438411, 0.166706, 0.247621, -0.18004, 0.450368, 0.189909, 0.27097, -0.191536, 0.460083, 0.215251, 0.296658, -0.203024, 0.469765, 0.243164, 0.325892, -0.214056, 0.481837, 0.273388, 0.35406, -0.224104, 0.487474, 0.305344, 0.384372, -0.233489, 0.492773, 0.339741, 0.41749, -0.241874, 0.498451, 0.376287, 0.45013, -0.248834, 0.499632, 0.414195, 0.481285, -0.254658, 0.495233, 0.454077, 0.519183, -0.259367, 0.496401, 0.496352, 0.551544, -0.261818, 0.487686, 0.538798, 0.587349, -0.262964, 0.479453, 0.583626, 0.621679, -0.262128, 0.467709, 0.629451, 0.654991, -0.258998, 0.452123, 0.67566, 0.686873, -0.254119, 0.433495, 0.723248, 0.719801, -0.246946, 0.413657, 0.771156, 0.750355, -0.237709, 0.390366, 0.81989, 0.780033, -0.226549, 0.364947, 0.868601, 0.809254, -0.214186, 0.337256, 0.920034, 0.836576, -0.199639, 0.307395, 0.971706, 0.861774, -0.183169, 0.275431, 1.02479, 0.885707, -0.165111, 0.243431, 1.07837, 0.904742, -0.144363, 0.210921, 1.12783, 0.915604, -0.121305, 0.17647, 1.17254, 0.930959, -0.0962119, 0.143106, 1.21012, 0.948404, -0.069969, 0.108112, 1.24474, 0.967012, -0.0427586, 0.0708478, 1.27718, 0.984183, -0.0147043, 0.032335, 1.3083, 0.999577, 0.0142165, -726867e-8, 1.3382, 0.0229227, -299799e-11, 0.148623, 462391e-12, 0.0232194, -758796e-10, 0.15054, 117033e-10, 0.0232315, -303636e-9, 0.15063, 468397e-10, 0.0232354, -683189e-9, 0.150624, 105472e-9, 0.0232092, -12136e-7, 0.150445, 187744e-9, 0.0232523, -189765e-8, 0.150679, 294847e-9, 0.0232828, -273247e-8, 0.150789, 428013e-9, 0.0233371, -371287e-8, 0.150995, 591134e-9, 0.0234015, -484794e-8, 0.15118, 787642e-9, 0.023514, -612877e-8, 0.151562, 102547e-8, 0.023679, -756125e-8, 0.152116, 131351e-8, 0.0239559, -914651e-8, 0.153162, 166594e-8, 0.0244334, -0.010904, 0.155133, 210182e-8, 0.025139, -0.0128615, 0.158035, 264406e-8, 0.0262598, -0.0150628, 0.162751, 332923e-8, 0.0277875, -0.0175532, 0.168944, 419773e-8, 0.0298472, -0.0203981, 0.176835, 530034e-8, 0.0325444, -0.023655, 0.186686, 669777e-8, 0.0355581, -0.0272982, 0.196248, 842661e-8, 0.0392841, -0.0314457, 0.207352, 0.0105854, 0.0436815, -0.0361157, 0.219279, 0.0132458, 0.0485272, -0.0412932, 0.230728, 0.0164736, 0.0541574, -0.0470337, 0.242994, 0.0203715, 0.0609479, -0.0535002, 0.257042, 0.0250953, 0.0685228, -0.0605409, 0.27102, 0.0306856, 0.0768042, -0.0680553, 0.28406, 0.037193, 0.0864844, -0.0765011, 0.299186, 0.0449795, 0.0969415, -0.0852674, 0.3132, 0.0538316, 0.108478, -0.0947333, 0.327138, 0.0641149, 0.121705, -0.10481, 0.342345, 0.0759185, 0.136743, -0.115474, 0.358472, 0.0894116, 0.152986, -0.126536, 0.374067, 0.104562, 0.170397, -0.138061, 0.388267, 0.121632, 0.191392, -0.150203, 0.406467, 0.140996, 0.211566, -0.161751, 0.418641, 0.161696, 0.233567, -0.173407, 0.430418, 0.184557, 0.257769, -0.185397, 0.44277, 0.210092, 0.28531, -0.197048, 0.457191, 0.237827, 0.311726, -0.20784, 0.464712, 0.267253, 0.340537, -0.218345, 0.472539, 0.299332, 0.372921, -0.228306, 0.482331, 0.333988, 0.402924, -0.236665, 0.484378, 0.369722, 0.434475, -0.244097, 0.484717, 0.407836, 0.469736, -0.250547, 0.487093, 0.448465, 0.505045, -0.25511, 0.485575, 0.490263, 0.540262, -0.258444, 0.481225, 0.534495, 0.576347, -0.259903, 0.473481, 0.579451, 0.608656, -0.259572, 0.4603, 0.625604, 0.646679, -0.257908, 0.450341, 0.674511, 0.679902, -0.253663, 0.431561, 0.723269, 0.714159, -0.247419, 0.412684, 0.773263, 0.745345, -0.239122, 0.389388, 0.824182, 0.778248, -0.228837, 0.365361, 0.876634, 0.807208, -0.216197, 0.337667, 0.92945, 0.835019, -0.201772, 0.307197, 0.985261, 0.860261, -0.185291, 0.274205, 1.04299, 0.877601, -0.165809, 0.240178, 1.09816, 0.898211, -0.143897, 0.207571, 1.14694, 0.915789, -0.119513, 0.174904, 1.19008, 0.931831, -0.0932919, 0.141423, 1.2297, 0.949244, -0.0656528, 0.105603, 1.26553, 0.967527, -0.0370262, 0.0679551, 1.29986, 0.984139, -730117e-8, 0.0283133, 1.33252, 0.999713, 0.0234648, -0.0121785, 1.36397, 0.0152135, -245447e-11, 0.122795, 304092e-12, 0.0151652, -615778e-10, 0.122399, 76292e-10, 0.0151181, -245948e-9, 0.122023, 304802e-10, 0.0151203, -553394e-9, 0.12203, 686634e-10, 0.015125, -983841e-9, 0.122037, 122463e-9, 0.0151427, -153774e-8, 0.12214, 192706e-9, 0.0151708, -22103e-7, 0.122237, 281219e-9, 0.0152115, -300741e-8, 0.12238, 390804e-9, 0.0152877, -392494e-8, 0.1227, 526317e-9, 0.015412, -496597e-8, 0.123244, 69443e-8, 0.0156201, -613314e-8, 0.124228, 90547e-8, 0.0159658, -744113e-8, 0.125945, 11732e-7, 0.0165674, -892546e-8, 0.129098, 151888e-8, 0.017487, -0.010627, 0.133865, 197007e-8, 0.018839, -0.0126043, 0.140682, 25637e-7, 0.020554, -0.0148814, 0.148534, 333637e-8, 0.0226727, -0.0175123, 0.157381, 433738e-8, 0.0251879, -0.0205266, 0.166685, 561664e-8, 0.0283635, -0.0240319, 0.177796, 725563e-8, 0.0318694, -0.0279432, 0.188251, 928811e-8, 0.0361044, -0.0324313, 0.200038, 0.011835, 0.0406656, -0.0373527, 0.210685, 0.0149146, 0.0463846, -0.0430132, 0.224182, 0.0187254, 0.0525696, -0.0491013, 0.23634, 0.0232283, 0.0598083, -0.0559175, 0.250013, 0.0286521, 0.0679437, -0.0633657, 0.263981, 0.0350634, 0.0771181, -0.0714602, 0.278072, 0.0425882, 0.0881273, -0.0803502, 0.29511, 0.0514487, 0.0996628, -0.0896903, 0.309976, 0.0615766, 0.112702, -0.099644, 0.325611, 0.0732139, 0.126488, -0.109829, 0.339321, 0.0862324, 0.142625, -0.120859, 0.35574, 0.101275, 0.15953, -0.131956, 0.369845, 0.117892, 0.176991, -0.143145, 0.38146, 0.136205, 0.199715, -0.155292, 0.40052, 0.157252, 0.220787, -0.167066, 0.412055, 0.179966, 0.243697, -0.178396, 0.423133, 0.204418, 0.272106, -0.190433, 0.439524, 0.232141, 0.297637, -0.201265, 0.447041, 0.261109, 0.325273, -0.211834, 0.454488, 0.292627, 0.357219, -0.221889, 0.465004, 0.326669, 0.387362, -0.230729, 0.468527, 0.362426, 0.423131, -0.23924, 0.475836, 0.401533, 0.45543, -0.246067, 0.475017, 0.441902, 0.493393, -0.251557, 0.478017, 0.484239, 0.526253, -0.255571, 0.4709, 0.528586, 0.560554, -0.257752, 0.463167, 0.574346, 0.599306, -0.258076, 0.456452, 0.621655, 0.634541, -0.256471, 0.443725, 0.670492, 0.668907, -0.253283, 0.428719, 0.721943, 0.705619, -0.247562, 0.411348, 0.772477, 0.739034, -0.240626, 0.388939, 0.8264, 0.771408, -0.231493, 0.36425, 0.881702, 0.803312, -0.220125, 0.337321, 0.9385, 0.828457, -0.206645, 0.305364, 0.997437, 0.854819, -0.190664, 0.273715, 1.05693, 0.878666, -0.171429, 0.242218, 1.11251, 0.898404, -0.149235, 0.209556, 1.16398, 0.917416, -0.12435, 0.176863, 1.21014, 0.933133, -0.0972703, 0.142775, 1.25178, 0.95066, -0.0683607, 0.106735, 1.29028, 0.968589, -0.0378724, 0.0681609, 1.32703, 0.984776, -605712e-8, 0.0273966, 1.36158, 0.99994, 0.0263276, -0.0138124, 1.3943, 867437e-8, -186005e-11, 0.0928979, 173682e-12, 864003e-8, -466389e-10, 0.0925237, 435505e-11, 864593e-8, -186594e-9, 0.0925806, 174322e-10, 864095e-8, -419639e-9, 0.0924903, 392862e-10, 863851e-8, -746272e-9, 0.0924589, 702598e-10, 868531e-8, -116456e-8, 0.0929, 111188e-9, 869667e-8, -167711e-8, 0.0928529, 163867e-9, 874332e-8, -228051e-8, 0.0930914, 23104e-8, 882709e-8, -297864e-8, 0.0935679, 31741e-8, 898874e-8, -377557e-8, 0.0946165, 430186e-9, 929346e-8, -469247e-8, 0.0967406, 580383e-9, 978271e-8, -575491e-8, 0.100084, 783529e-9, 0.0105746, -701514e-8, 0.105447, 106304e-8, 0.0116949, -851797e-8, 0.112494, 144685e-8, 0.0130419, -0.0102757, 0.119876, 196439e-8, 0.0148375, -0.012381, 0.129034, 266433e-8, 0.0168725, -0.01482, 0.137812, 358364e-8, 0.0193689, -0.0176563, 0.147696, 478132e-8, 0.0222691, -0.0209211, 0.157795, 631721e-8, 0.0256891, -0.0246655, 0.168431, 826346e-8, 0.0294686, -0.0288597, 0.178587, 0.0106714, 0.0340412, -0.0336441, 0.190251, 0.0136629, 0.0393918, -0.039033, 0.202999, 0.0173272, 0.0453947, -0.0450087, 0.215655, 0.0217448, 0.0521936, -0.0515461, 0.228686, 0.0269941, 0.0600279, -0.058817, 0.242838, 0.033272, 0.0692398, -0.0667228, 0.258145, 0.0406457, 0.0793832, -0.0752401, 0.273565, 0.0492239, 0.0902297, -0.0841851, 0.287735, 0.0590105, 0.102014, -0.0936479, 0.301161, 0.0702021, 0.116054, -0.103967, 0.317438, 0.0832001, 0.13191, -0.114622, 0.334166, 0.0977951, 0.148239, -0.125452, 0.348192, 0.113985, 0.165809, -0.136453, 0.361094, 0.131928, 0.184616, -0.147648, 0.373534, 0.151811, 0.207491, -0.159607, 0.39101, 0.174476, 0.230106, -0.171119, 0.402504, 0.198798, 0.257036, -0.182906, 0.418032, 0.225796, 0.281172, -0.193605, 0.425468, 0.254027, 0.312034, -0.204771, 0.440379, 0.285713, 0.340402, -0.214988, 0.445406, 0.319196, 0.370231, -0.224711, 0.44968, 0.35537, 0.407105, -0.233516, 0.460747, 0.393838, 0.439037, -0.240801, 0.460624, 0.433747, 0.47781, -0.24762, 0.465957, 0.477234, 0.510655, -0.251823, 0.460054, 0.52044, 0.550584, -0.255552, 0.459172, 0.567853, 0.585872, -0.257036, 0.450311, 0.615943, 0.620466, -0.257535, 0.437763, 0.667693, 0.660496, -0.255248, 0.426639, 0.718988, 0.695578, -0.251141, 0.409185, 0.772503, 0.732176, -0.244718, 0.39015, 0.827023, 0.760782, -0.236782, 0.362594, 0.885651, 0.79422, -0.225923, 0.33711, 0.943756, 0.824521, -0.213855, 0.308272, 1.00874, 0.854964, -0.197723, 0.278529, 1.06764, 0.878065, -0.179209, 0.246208, 1.12836, 0.899834, -0.157569, 0.21329, 1.18318, 0.918815, -0.133206, 0.181038, 1.23161, 0.934934, -0.106545, 0.146993, 1.27644, 0.952115, -0.0780574, 0.111175, 1.31842, 0.96906, -0.0478279, 0.0728553, 1.35839, 0.985178, -0.0160014, 0.032579, 1.39697, 1.00039, 0.0173126, -95256e-7, 1.43312, 384146e-8, -124311e-11, 0.0613583, 778271e-13, 390023e-8, -314043e-10, 0.0622919, 196626e-11, 389971e-8, -125622e-9, 0.0622632, 787379e-11, 389491e-8, -282352e-9, 0.0620659, 1778e-8, 391618e-8, -502512e-9, 0.0624687, 320918e-10, 392662e-8, -784458e-9, 0.0625113, 515573e-10, 396053e-8, -112907e-8, 0.0628175, 778668e-10, 401911e-8, -153821e-8, 0.0633286, 113811e-9, 414994e-8, -20208e-7, 0.0646443, 16445e-8, 441223e-8, -260007e-8, 0.0673886, 237734e-9, 484427e-8, -33097e-7, 0.0716528, 345929e-9, 549109e-8, -418966e-8, 0.0774998, 505987e-9, 636293e-8, -527331e-8, 0.0844758, 739208e-9, 746566e-8, -660428e-8, 0.0921325, 107347e-8, 876625e-8, -818826e-8, 0.0997067, 153691e-8, 0.0103125, -0.0100811, 0.107433, 217153e-8, 0.0123309, -0.0123643, 0.117088, 303427e-8, 0.0146274, -0.0150007, 0.126438, 416018e-8, 0.0172295, -0.0180531, 0.135672, 561513e-8, 0.0204248, -0.0215962, 0.146244, 7478e-6, 0.0241597, -0.0256234, 0.157481, 981046e-8, 0.0284693, -0.0302209, 0.169125, 0.0127148, 0.033445, -0.0353333, 0.181659, 0.0162453, 0.0391251, -0.0410845, 0.1944, 0.0205417, 0.0454721, -0.0473451, 0.207082, 0.0256333, 0.0530983, -0.0542858, 0.221656, 0.0317036, 0.0615356, -0.0618384, 0.236036, 0.0388319, 0.0703363, -0.0697631, 0.248398, 0.046974, 0.0810391, -0.0784757, 0.263611, 0.0565246, 0.0920144, -0.0873488, 0.275857, 0.0671724, 0.105584, -0.0973652, 0.292555, 0.0798105, 0.119506, -0.107271, 0.306333, 0.0935945, 0.134434, -0.117608, 0.318888, 0.109106, 0.153399, -0.128938, 0.337552, 0.127074, 0.171258, -0.139944, 0.349955, 0.14643, 0.191059, -0.151288, 0.361545, 0.168, 0.215069, -0.163018, 0.378421, 0.192082, 0.237838, -0.174226, 0.38879, 0.217838, 0.266965, -0.186063, 0.405857, 0.246931, 0.292827, -0.196909, 0.414146, 0.277505, 0.324352, -0.207473, 0.426955, 0.310711, 0.354427, -0.217713, 0.433429, 0.346794, 0.389854, -0.227183, 0.443966, 0.385237, 0.420749, -0.235131, 0.44471, 0.424955, 0.459597, -0.242786, 0.451729, 0.468446, 0.495316, -0.248767, 0.45072, 0.513422, 0.534903, -0.253351, 0.450924, 0.560618, 0.572369, -0.256277, 0.445266, 0.609677, 0.612383, -0.2576, 0.438798, 0.660995, 0.644037, -0.256931, 0.421693, 0.713807, 0.686749, -0.254036, 0.4109, 0.767616, 0.719814, -0.249785, 0.390151, 0.82533, 0.754719, -0.244283, 0.367847, 0.888311, 0.792022, -0.235076, 0.345013, 0.948177, 0.822404, -0.225061, 0.316193, 1.01661, 0.853084, -0.211113, 0.287013, 1.08075, 0.879871, -0.19449, 0.255424, 1.14501, 0.901655, -0.174023, 0.222879, 1.20203, 0.919957, -0.1509, 0.18989, 1.25698, 0.938412, -0.124923, 0.15606, 1.30588, 0.953471, -0.0968139, 0.120512, 1.3529, 0.970451, -0.066734, 0.0828515, 1.3986, 0.985522, -0.034734, 0.0424458, 1.44148, 1.00099, -102222e-8, 678929e-9, 1.48398, 965494e-9, -627338e-12, 0.0306409, 197672e-13, 99168e-8, -158573e-10, 0.0314638, 499803e-12, 991068e-9, -634012e-10, 0.031363, 200682e-11, 974567e-9, -14144e-8, 0.03036, 457312e-11, 998079e-9, -252812e-9, 0.031496, 860131e-11, 102243e-8, -396506e-9, 0.0319955, 148288e-10, 107877e-8, -577593e-9, 0.0331376, 249141e-10, 121622e-8, -816816e-9, 0.0359396, 423011e-10, 14455e-7, -113761e-8, 0.0399652, 724613e-10, 178791e-8, -156959e-8, 0.0450556, 123929e-9, 225668e-8, -214064e-8, 0.0508025, 208531e-9, 285627e-8, -287655e-8, 0.0568443, 341969e-9, 35991e-7, -380271e-8, 0.0630892, 544158e-9, 455524e-8, -496264e-8, 0.0702204, 842423e-9, 569143e-8, -63793e-7, 0.0773426, 126704e-8, 716928e-8, -813531e-8, 0.0860839, 186642e-8, 885307e-8, -0.0101946, 0.0944079, 267014e-8, 0.0109316, -0.0126386, 0.103951, 374033e-8, 0.0133704, -0.0154876, 0.113786, 51304e-7, 0.0161525, -0.0187317, 0.123477, 688858e-8, 0.0194267, -0.0224652, 0.133986, 910557e-8, 0.0230967, -0.0265976, 0.143979, 0.0118074, 0.0273627, -0.0312848, 0.154645, 0.0151266, 0.0323898, -0.0365949, 0.166765, 0.0191791, 0.0379225, -0.0422914, 0.177932, 0.0239236, 0.0447501, -0.0487469, 0.19167, 0.0296568, 0.0519391, -0.0556398, 0.203224, 0.0362924, 0.0599464, -0.0631646, 0.215652, 0.0440585, 0.0702427, -0.0714308, 0.232089, 0.0531619, 0.0806902, -0.0800605, 0.245258, 0.0634564, 0.0923194, -0.0892815, 0.258609, 0.0752481, 0.106938, -0.09931, 0.276654, 0.0888914, 0.121238, -0.109575, 0.289847, 0.104055, 0.138817, -0.120461, 0.307566, 0.121266, 0.15595, -0.131209, 0.320117, 0.139944, 0.178418, -0.143049, 0.339677, 0.161591, 0.197875, -0.154074, 0.349886, 0.184303, 0.224368, -0.166307, 0.369352, 0.210669, 0.252213, -0.178051, 0.386242, 0.238895, 0.277321, -0.189335, 0.395294, 0.269182, 0.310332, -0.200683, 0.412148, 0.302508, 0.338809, -0.210856, 0.418266, 0.337264, 0.372678, -0.220655, 0.428723, 0.374881, 0.405632, -0.230053, 0.433887, 0.415656, 0.442293, -0.237993, 0.439911, 0.457982, 0.477256, -0.244897, 0.440175, 0.502831, 0.515592, -0.250657, 0.441079, 0.550277, 0.550969, -0.255459, 0.435219, 0.601102, 0.592883, -0.257696, 0.432882, 0.651785, 0.629092, -0.259894, 0.421054, 0.708961, 0.672033, -0.258592, 0.41177, 0.763806, 0.709147, -0.256525, 0.395267, 0.824249, 0.745367, -0.254677, 0.375013, 0.8951, 0.784715, -0.247892, 0.353906, 0.959317, 0.818107, -0.240162, 0.327801, 1.03153, 0.847895, -0.229741, 0.298821, 1.10601, 0.879603, -0.213084, 0.269115, 1.164, 0.902605, -0.195242, 0.236606, 1.22854, 0.922788, -0.174505, 0.203442, 1.29017, 0.944831, -0.150169, 0.169594, 1.34157, 0.959656, -0.124099, 0.135909, 1.3956, 0.972399, -0.0960626, 0.0990563, 1.45128, 0.986549, -0.0657097, 0.0602348, 1.50312, 1.00013, -0.0333558, 0.0186694, 1.55364, 619747e-11, -1e-7, 778326e-8, 796756e-16, 237499e-13, -999999e-13, 282592e-10, 114596e-15, 100292e-11, -166369e-11, 250354e-9, 677492e-14, 350752e-11, -637769e-11, 357289e-9, 631655e-13, 826445e-11, -174689e-10, 516179e-9, 31851e-11, 242481e-10, -450868e-10, 10223e-7, 130577e-11, 455631e-10, -89044e-9, 144302e-8, 374587e-11, 971222e-10, -178311e-9, 241912e-8, 102584e-10, 171403e-9, -313976e-9, 354938e-8, 236481e-10, 292747e-9, -520026e-9, 513765e-8, 496014e-10, 789827e-9, -118187e-8, 0.0238621, 139056e-9, 114093e-8, -171827e-8, 0.0286691, 244093e-9, 176119e-8, -249667e-8, 0.0368565, 420623e-9, 22233e-7, -333742e-8, 0.0400469, 65673e-8, 343382e-8, -481976e-8, 0.0535751, 109323e-8, 427602e-8, -600755e-8, 0.057099, 155268e-8, 461435e-8, -737637e-8, 0.0551084, 215031e-8, 695698e-8, -971401e-8, 0.0715767, 316529e-8, 867619e-8, -0.0120943, 0.0793314, 436995e-8, 0.0106694, -0.0148202, 0.0869391, 58959e-7, 0.0140351, -0.0183501, 0.101572, 798757e-8, 0.0168939, -0.022006, 0.11018, 0.0104233, 0.020197, -0.0261568, 0.119041, 0.0134167, 0.0254702, -0.0312778, 0.135404, 0.0173009, 0.0298384, -0.0362469, 0.1437, 0.0215428, 0.035159, -0.042237, 0.15512, 0.0268882, 0.0427685, -0.0488711, 0.17128, 0.033235, 0.0494848, -0.0557997, 0.181813, 0.0404443, 0.0592394, -0.0635578, 0.198745, 0.0490043, 0.0681463, -0.071838, 0.210497, 0.0588239, 0.0804753, -0.0809297, 0.228864, 0.0702835, 0.0942205, -0.0906488, 0.247008, 0.0834012, 0.106777, -0.100216, 0.258812, 0.0975952, 0.124471, -0.110827, 0.278617, 0.114162, 0.138389, -0.121193, 0.287049, 0.131983, 0.159543, -0.13253, 0.307151, 0.152541, 0.176432, -0.143611, 0.31564, 0.174673, 0.201723, -0.15548, 0.33538, 0.199842, 0.229721, -0.167166, 0.355256, 0.227097, 0.250206, -0.178238, 0.360047, 0.256014, 0.282118, -0.189905, 0.378761, 0.28855, 0.312821, -0.201033, 0.39181, 0.323348, 0.341482, -0.211584, 0.397716, 0.360564, 0.377368, -0.221314, 0.410141, 0.400004, 0.418229, -0.230474, 0.423485, 0.442371, 0.444881, -0.239443, 0.418874, 0.488796, 0.488899, -0.245987, 0.427545, 0.535012, 0.520317, -0.253948, 0.422147, 0.589678, 0.568566, -0.256616, 0.42719, 0.637683, 0.599607, -0.26376, 0.415114, 0.703363, 0.64222, -0.268687, 0.408715, 0.771363, 0.685698, -0.2694, 0.399722, 0.83574, 0.732327, -0.266642, 0.388651, 0.897764, 0.769873, -0.267712, 0.369198, 0.983312, 0.806733, -0.263479, 0.346802, 1.06222, 0.843466, -0.254575, 0.321368, 1.13477, 0.873008, -0.242749, 0.29211, 1.20712, 0.908438, -0.22725, 0.262143, 1.27465, 0.936321, -0.207621, 0.228876, 1.33203, 0.950353, -0.187932, 0.19484, 1.40439, 0.96442, -0.165154, 0.163178, 1.4732, 0.979856, -0.139302, 0.127531, 1.53574, 0.982561, -0.11134, 0.0903457, 1.59982, 0.996389, -0.0808124, 0.0489007, 1.6577], n = [1, 0, 0, 0, 1, 791421e-36, 0, 0, 1, 104392e-29, 0, 0, 1, 349405e-26, 0, 0, 1, 109923e-23, 0, 0, 1, 947414e-22, 0, 0, 1, 359627e-20, 0, 0, 1, 772053e-19, 0, 0, 1, 108799e-17, 0, 0, 1, 110655e-16, 0, 0, 1, 865818e-16, 0, 0, 0.999998, 545037e-15, 0, 0, 0.999994, 285095e-14, 0, 0, 0.999989, 126931e-13, 0, 0, 0.999973, 489938e-13, 0, 0, 0.999947, 166347e-12, 0, 0, 0.999894, 502694e-12, 0, 0, 0.999798, 136532e-11, 0, 0, 0.999617, 335898e-11, 0, 0, 0.999234, 752126e-11, 0, 0, 0.998258, 152586e-10, 0, 0, 0.99504, 266207e-10, 0, 0, 0.980816, 236802e-10, 0, 0, 0.967553, 207684e-11, 0, 0, 0.966877, 403733e-11, 0, 0, 0.965752, 741174e-11, 0, 0, 0.96382, 127746e-10, 0, 0, 0.960306, 202792e-10, 0, 0, 0.953619, 280232e-10, 0, 0, 0.941103, 278816e-10, 0, 0, 0.926619, 160221e-10, 0, 0, 0.920983, 235164e-10, 0, 0, 0.912293, 311924e-10, 0, 0.0158731, 0.899277, 348118e-10, 0, 0.0476191, 0.880884, 26041e-9, 0, 0.0793651, 0.870399, 338726e-10, 0, 0.111111, 0.856138, 392906e-10, 0, 0.142857, 0.837436, 372874e-10, 0, 0.174603, 0.820973, 392558e-10, 0, 0.206349, 0.803583, 434658e-10, 0, 0.238095, 0.782168, 40256e-9, 0, 0.269841, 0.764107, 448159e-10, 0, 0.301587, 0.743092, 457627e-10, 0, 0.333333, 0.721626, 455314e-10, 0, 0.365079, 0.700375, 477335e-10, 0, 0.396825, 0.677334, 461072e-10, 0, 0.428571, 0.655702, 484393e-10, 0, 0.460317, 0.632059, 464583e-10, 0, 0.492064, 0.610125, 483923e-10, 0, 0.52381, 0.58653, 464342e-10, 0, 0.555556, 0.564508, 477033e-10, 0, 0.587302, 0.541405, 459263e-10, 0, 0.619048, 0.519556, 46412e-9, 0, 0.650794, 0.497292, 448913e-10, 0, 0.68254, 0.475898, 445789e-10, 0, 0.714286, 0.454722, 433496e-10, 0, 0.746032, 0.434042, 423054e-10, 0, 0.777778, 0.414126, 413737e-10, 0, 0.809524, 0.394387, 397265e-10, 0, 0.84127, 0.375841, 390709e-10, 0, 0.873016, 0.357219, 369938e-10, 0, 0.904762, 0.340084, 365618e-10, 0, 0.936508, 0.322714, 342533e-10, 0, 0.968254, 0.306974, 339596e-10, 0, 1, 1, 101524e-23, 0, 0, 1, 10292e-22, 0, 0, 1, 130908e-23, 0, 0, 1, 473331e-23, 0, 0, 1, 625319e-22, 0, 0, 1, 107932e-20, 0, 0, 1, 163779e-19, 0, 0, 1, 203198e-18, 0, 0, 1, 204717e-17, 0, 0, 0.999999, 168995e-16, 0, 0, 0.999998, 115855e-15, 0, 0, 0.999996, 66947e-14, 0, 0, 0.999991, 330863e-14, 0, 0, 0.999983, 141737e-13, 0, 0, 0.999968, 532626e-13, 0, 0, 0.99994, 177431e-12, 0, 0, 0.999891, 528835e-12, 0, 0, 0.999797, 142169e-11, 0, 0, 0.999617, 347057e-11, 0, 0, 0.999227, 77231e-10, 0, 0, 0.998239, 155753e-10, 0, 0, 0.994937, 268495e-10, 0, 0, 0.980225, 213742e-10, 0, 0, 0.967549, 21631e-10, 0, 0, 0.966865, 417989e-11, 0, 0, 0.965739, 763341e-11, 0, 0, 0.963794, 130892e-10, 0, 0, 0.960244, 206456e-10, 0, 0, 0.953495, 282016e-10, 0, 148105e-9, 0.940876, 271581e-10, 0, 2454e-6, 0.926569, 164159e-10, 0, 867491e-8, 0.920905, 239521e-10, 0, 0.01956, 0.912169, 315127e-10, 0, 0.035433, 0.899095, 346626e-10, 0, 0.056294, 0.882209, 290223e-10, 0, 0.0818191, 0.870272, 342992e-10, 0, 0.111259, 0.855977, 394164e-10, 0, 0.142857, 0.837431, 372343e-10, 0, 0.174603, 0.820826, 396691e-10, 0, 0.206349, 0.803408, 435395e-10, 0, 0.238095, 0.782838, 419579e-10, 0, 0.269841, 0.763941, 450953e-10, 0, 0.301587, 0.742904, 455847e-10, 0, 0.333333, 0.721463, 458833e-10, 0, 0.365079, 0.700197, 477159e-10, 0, 0.396825, 0.677501, 470641e-10, 0, 0.428571, 0.655527, 484732e-10, 0, 0.460317, 0.6324, 476834e-10, 0, 0.492064, 0.609964, 484213e-10, 0, 0.52381, 0.586839, 475541e-10, 0, 0.555556, 0.564353, 476951e-10, 0, 0.587302, 0.541589, 467611e-10, 0, 0.619048, 0.519413, 463493e-10, 0, 0.650794, 0.497337, 453994e-10, 0, 0.68254, 0.475797, 445308e-10, 0, 0.714286, 0.454659, 435787e-10, 0, 0.746032, 0.434065, 424839e-10, 0, 0.777778, 0.414018, 41436e-9, 0, 0.809524, 0.39455, 401902e-10, 0, 0.84127, 0.375742, 390813e-10, 0, 0.873016, 0.357501, 377116e-10, 0, 0.904762, 0.339996, 36535e-9, 0, 0.936508, 0.323069, 351265e-10, 0, 0.968254, 0.306897, 339112e-10, 0, 1, 1, 10396e-19, 0, 0, 1, 104326e-20, 0, 0, 1, 110153e-20, 0, 0, 1, 144668e-20, 0, 0, 1, 34528e-19, 0, 0, 1, 175958e-19, 0, 0, 1, 12627e-17, 0, 0, 1, 936074e-18, 0, 0, 1, 645742e-17, 0, 0, 0.999998, 401228e-16, 0, 0, 0.999997, 222338e-15, 0, 0, 0.999995, 10967e-13, 0, 0, 0.999991, 482132e-14, 0, 0, 0.999981, 189434e-13, 0, 0, 0.999967, 667716e-13, 0, 0, 0.999938, 212066e-12, 0, 0, 0.999886, 60977e-11, 0, 0, 0.999792, 159504e-11, 0, 0, 0.999608, 381191e-11, 0, 0, 0.999209, 833727e-11, 0, 0, 0.998179, 165288e-10, 0, 0, 0.994605, 274387e-10, 0, 0, 0.979468, 167316e-10, 0, 0, 0.967529, 242877e-11, 0, 0, 0.966836, 461696e-11, 0, 0, 0.96569, 830977e-11, 0, 0, 0.963706, 140427e-10, 0, 244659e-11, 0.960063, 217353e-10, 0, 760774e-9, 0.953113, 286606e-10, 0, 367261e-8, 0.940192, 247691e-10, 0, 940263e-8, 0.927731, 195814e-10, 0, 0.018333, 0.920669, 252531e-10, 0, 0.0306825, 0.911799, 324277e-10, 0, 0.0465556, 0.89857, 340982e-10, 0, 0.0659521, 0.883283, 319622e-10, 0, 0.0887677, 0.86989, 35548e-9, 0, 0.114784, 0.855483, 397143e-10, 0, 0.143618, 0.837987, 391665e-10, 0, 0.174606, 0.820546, 411306e-10, 0, 0.206349, 0.802878, 436753e-10, 0, 0.238095, 0.783402, 444e-7, 0, 0.269841, 0.763439, 458726e-10, 0, 0.301587, 0.742925, 467097e-10, 0, 0.333333, 0.721633, 478887e-10, 0, 0.365079, 0.69985, 481251e-10, 0, 0.396825, 0.67783, 491811e-10, 0, 0.428571, 0.655126, 488199e-10, 0, 0.460318, 0.632697, 496025e-10, 0, 0.492064, 0.609613, 48829e-9, 0, 0.52381, 0.587098, 492754e-10, 0, 0.555556, 0.564119, 482625e-10, 0, 0.587302, 0.541813, 482807e-10, 0, 0.619048, 0.519342, 471552e-10, 0, 0.650794, 0.497514, 466765e-10, 0, 0.68254, 0.475879, 455582e-10, 0, 0.714286, 0.454789, 446007e-10, 0, 0.746032, 0.434217, 435382e-10, 0, 0.777778, 0.414086, 421753e-10, 0, 0.809524, 0.394744, 412093e-10, 0, 0.84127, 0.375782, 396634e-10, 0, 0.873016, 0.357707, 386419e-10, 0, 0.904762, 0.340038, 370345e-10, 0, 0.936508, 0.323284, 359725e-10, 0, 0.968254, 0.306954, 3436e-8, 0, 1, 1, 599567e-19, 0, 0, 1, 600497e-19, 0, 0, 1, 614839e-19, 0, 0, 1, 686641e-19, 0, 0, 1, 972658e-19, 0, 0, 1, 221271e-18, 0, 0, 1, 833195e-18, 0, 0, 1, 403601e-17, 0, 0, 0.999999, 206001e-16, 0, 0, 0.999998, 101739e-15, 0, 0, 0.999997, 470132e-15, 0, 0, 0.999993, 200436e-14, 0, 0, 0.999988, 783682e-14, 0, 0, 0.999979, 280338e-13, 0, 0, 0.999962, 917033e-13, 0, 0, 0.999933, 274514e-12, 0, 0, 0.999881, 753201e-12, 0, 0, 0.999783, 189826e-11, 0, 0, 0.999594, 440279e-11, 0, 0, 0.999178, 93898e-10, 0, 0, 0.998073, 181265e-10, 0, 0, 0.993993, 280487e-10, 0, 0, 0.979982, 149422e-10, 0, 0, 0.968145, 378481e-11, 0, 0, 0.966786, 53771e-10, 0, 0, 0.965611, 947508e-11, 0, 388934e-10, 0.963557, 156616e-10, 0, 9693e-7, 0.959752, 235144e-10, 0, 370329e-8, 0.952461, 291568e-10, 0, 868428e-8, 0.940193, 240102e-10, 0, 0.0161889, 0.929042, 231235e-10, 0, 0.0263948, 0.920266, 273968e-10, 0, 0.0394088, 0.911178, 337915e-10, 0, 0.0552818, 0.897873, 333629e-10, 0, 0.0740138, 0.884053, 351405e-10, 0, 0.0955539, 0.869455, 378034e-10, 0, 0.119795, 0.854655, 399378e-10, 0, 0.14656, 0.838347, 419108e-10, 0, 0.175573, 0.820693, 440831e-10, 0, 0.206388, 0.802277, 445599e-10, 0, 0.238095, 0.783634, 472691e-10, 0, 0.269841, 0.763159, 476984e-10, 0, 0.301587, 0.742914, 491487e-10, 0, 0.333333, 0.721662, 502312e-10, 0, 0.365079, 0.699668, 502817e-10, 0, 0.396825, 0.677839, 51406e-9, 0, 0.428571, 0.655091, 511095e-10, 0, 0.460317, 0.632665, 516067e-10, 0, 0.492064, 0.609734, 512255e-10, 0, 0.52381, 0.587043, 510263e-10, 0, 0.555556, 0.564298, 50565e-9, 0, 0.587302, 0.541769, 497951e-10, 0, 0.619048, 0.519529, 492698e-10, 0, 0.650794, 0.497574, 482066e-10, 0, 0.68254, 0.476028, 473689e-10, 0, 0.714286, 0.454961, 461941e-10, 0, 0.746032, 0.434341, 450618e-10, 0, 0.777778, 0.414364, 438355e-10, 0, 0.809524, 0.394832, 424196e-10, 0, 0.84127, 0.376109, 412563e-10, 0, 0.873016, 0.35779, 396226e-10, 0, 0.904762, 0.340379, 384886e-10, 0, 0.936508, 0.323385, 368214e-10, 0, 0.968254, 0.307295, 356636e-10, 0, 1, 1, 106465e-17, 0, 0, 1, 106555e-17, 0, 0, 1, 107966e-17, 0, 0, 1, 114601e-17, 0, 0, 1, 137123e-17, 0, 0, 1, 21243e-16, 0, 0, 0.999999, 489653e-17, 0, 0, 0.999999, 160283e-16, 0, 0, 0.999998, 62269e-15, 0, 0, 0.999997, 251859e-15, 0, 0, 0.999996, 996192e-15, 0, 0, 0.999992, 374531e-14, 0, 0, 0.999986, 132022e-13, 0, 0, 0.999975, 433315e-13, 0, 0, 0.999959, 131956e-12, 0, 0, 0.999927, 372249e-12, 0, 0, 0.999871, 972461e-12, 0, 0, 0.999771, 235343e-11, 0, 0, 0.999572, 52768e-10, 0, 0, 0.999133, 109237e-10, 0, 0, 0.997912, 203675e-10, 0, 0, 0.993008, 279396e-10, 0, 0, 0.980645, 139604e-10, 0, 0, 0.970057, 646596e-11, 0, 0, 0.966717, 65089e-10, 0, 474145e-10, 0.965497, 111863e-10, 0, 89544e-8, 0.96334, 179857e-10, 0, 32647e-7, 0.959294, 259045e-10, 0, 75144e-7, 0.951519, 292327e-10, 0, 0.0138734, 0.940517, 249769e-10, 0, 0.0224952, 0.93014, 26803e-9, 0, 0.0334828, 0.91972, 303656e-10, 0, 0.0468973, 0.910294, 353323e-10, 0, 0.0627703, 0.897701, 351002e-10, 0, 0.0811019, 0.884522, 388104e-10, 0, 0.10186, 0.869489, 412932e-10, 0, 0.124985, 0.853983, 415781e-10, 0, 0.150372, 0.838425, 454066e-10, 0, 0.177868, 0.820656, 471624e-10, 0, 0.207245, 0.801875, 475243e-10, 0, 0.238143, 0.783521, 505621e-10, 0, 0.269841, 0.763131, 50721e-9, 0, 0.301587, 0.74261, 523293e-10, 0, 0.333333, 0.72148, 528699e-10, 0, 0.365079, 0.699696, 538677e-10, 0, 0.396825, 0.677592, 539255e-10, 0, 0.428571, 0.65525, 546367e-10, 0, 0.460317, 0.632452, 541348e-10, 0, 0.492064, 0.609903, 544976e-10, 0, 0.52381, 0.586928, 536201e-10, 0, 0.555556, 0.564464, 535185e-10, 0, 0.587302, 0.541801, 524949e-10, 0, 0.619048, 0.519681, 51812e-9, 0, 0.650794, 0.497685, 507687e-10, 0, 0.68254, 0.47622, 496243e-10, 0, 0.714286, 0.455135, 485714e-10, 0, 0.746032, 0.4346, 471847e-10, 0, 0.777778, 0.414564, 459294e-10, 0, 0.809524, 0.395165, 444705e-10, 0, 0.84127, 0.376333, 430772e-10, 0, 0.873016, 0.358197, 416229e-10, 0, 0.904762, 0.34064, 401019e-10, 0, 0.936508, 0.323816, 386623e-10, 0, 0.968254, 0.307581, 370933e-10, 0, 1, 1, 991541e-17, 0, 0, 1, 992077e-17, 0, 0, 1, 100041e-16, 0, 0, 1, 10385e-15, 0, 0, 1, 115777e-16, 0, 0, 1, 150215e-16, 0, 0, 0.999999, 254738e-16, 0, 0, 0.999999, 598822e-16, 0, 0, 0.999998, 179597e-15, 0, 0, 0.999997, 602367e-15, 0, 0, 0.999994, 206835e-14, 0, 0, 0.99999, 694952e-14, 0, 0, 0.999984, 223363e-13, 0, 0, 0.999972, 678578e-13, 0, 0, 0.999952, 193571e-12, 0, 0, 0.999919, 516594e-12, 0, 0, 0.99986, 128739e-11, 0, 0, 0.999753, 299298e-11, 0, 0, 0.999546, 648258e-11, 0, 0, 0.999074, 129985e-10, 0, 0, 0.997671, 232176e-10, 0, 0, 0.991504, 256701e-10, 0, 0, 0.981148, 131141e-10, 0, 0, 0.971965, 869048e-11, 0, 280182e-10, 0.966624, 808301e-11, 0, 695475e-9, 0.965344, 135235e-10, 0, 265522e-8, 0.963048, 210592e-10, 0, 622975e-8, 0.958673, 287473e-10, 0, 0.0116234, 0.950262, 281379e-10, 0, 0.018976, 0.940836, 271089e-10, 0, 0.0283844, 0.930996, 30926e-9, 0, 0.0399151, 0.919848, 348359e-10, 0, 0.0536063, 0.909136, 366092e-10, 0, 0.0694793, 0.897554, 384162e-10, 0, 0.0875342, 0.884691, 430971e-10, 0, 0.107749, 0.869414, 447803e-10, 0, 0.130087, 0.853462, 452858e-10, 0, 0.154481, 0.838187, 495769e-10, 0, 0.180833, 0.820381, 502709e-10, 0, 0.209005, 0.801844, 522713e-10, 0, 0.238791, 0.783061, 541505e-10, 0, 0.269869, 0.763205, 553712e-10, 0, 0.301587, 0.742362, 564909e-10, 0, 0.333333, 0.721393, 572646e-10, 0, 0.365079, 0.699676, 581012e-10, 0, 0.396825, 0.677395, 58096e-9, 0, 0.428571, 0.655208, 585766e-10, 0, 0.460317, 0.632451, 583602e-10, 0, 0.492064, 0.609839, 580234e-10, 0, 0.52381, 0.587093, 577161e-10, 0, 0.555556, 0.564467, 568447e-10, 0, 0.587302, 0.542043, 563166e-10, 0, 0.619048, 0.519826, 55156e-9, 0, 0.650794, 0.497952, 541682e-10, 0, 0.68254, 0.476477, 528971e-10, 0, 0.714286, 0.455412, 514952e-10, 0, 0.746032, 0.434926, 502222e-10, 0, 0.777778, 0.4149, 485779e-10, 0, 0.809524, 0.395552, 472242e-10, 0, 0.84127, 0.376712, 454891e-10, 0, 0.873016, 0.358622, 440924e-10, 0, 0.904762, 0.341048, 422984e-10, 0, 0.936508, 0.324262, 408582e-10, 0, 0.968254, 0.308013, 390839e-10, 0, 1, 1, 613913e-16, 0, 0, 1, 614145e-16, 0, 0, 1, 617708e-16, 0, 0, 1, 633717e-16, 0, 0, 1, 681648e-16, 0, 0, 1, 808291e-16, 0, 0, 1, 114608e-15, 0, 0, 0.999998, 210507e-15, 0, 0, 0.999997, 499595e-15, 0, 0, 0.999995, 139897e-14, 0, 0, 0.999994, 419818e-14, 0, 0, 0.999988, 127042e-13, 0, 0, 0.999979, 375153e-13, 0, 0, 0.999965, 106206e-12, 0, 0, 0.999945, 285381e-12, 0, 0, 0.999908, 723611e-12, 0, 0, 0.999846, 17255e-10, 0, 0, 0.999733, 386104e-11, 0, 0, 0.999511, 808493e-11, 0, 0, 0.998993, 156884e-10, 0, 0, 0.997326, 265538e-10, 0, 0, 0.989706, 206466e-10, 0, 0, 0.981713, 130756e-10, 0, 70005e-10, 0.973636, 106473e-10, 0, 464797e-9, 0.966509, 10194e-9, 0, 201743e-8, 0.965149, 165881e-10, 0, 497549e-8, 0.962669, 249147e-10, 0, 953262e-8, 0.95786, 317449e-10, 0, 0.0158211, 0.949334, 281045e-10, 0, 0.0239343, 0.941041, 303263e-10, 0, 0.0339372, 0.931575, 356754e-10, 0, 0.0458738, 0.920102, 397075e-10, 0, 0.059772, 0.908002, 384886e-10, 0, 0.075645, 0.897269, 43027e-9, 0, 0.0934929, 0.884559, 479925e-10, 0, 0.113302, 0.869161, 48246e-9, 0, 0.135045, 0.853342, 509505e-10, 0, 0.158678, 0.837633, 542846e-10, 0, 0.184136, 0.820252, 554139e-10, 0, 0.211325, 0.801872, 581412e-10, 0, 0.240113, 0.782418, 585535e-10, 0, 0.270306, 0.7631, 610923e-10, 0, 0.301594, 0.742183, 613678e-10, 0, 0.333333, 0.721098, 627275e-10, 0, 0.365079, 0.699512, 629413e-10, 0, 0.396825, 0.677372, 636351e-10, 0, 0.428571, 0.655059, 633555e-10, 0, 0.460317, 0.632567, 636513e-10, 0, 0.492064, 0.609784, 628965e-10, 0, 0.52381, 0.587237, 625546e-10, 0, 0.555556, 0.564525, 615825e-10, 0, 0.587302, 0.542181, 605048e-10, 0, 0.619048, 0.520017, 596329e-10, 0, 0.650794, 0.498204, 581516e-10, 0, 0.68254, 0.476742, 569186e-10, 0, 0.714286, 0.455803, 553833e-10, 0, 0.746032, 0.435251, 537807e-10, 0, 0.777778, 0.415374, 522025e-10, 0, 0.809524, 0.395921, 503421e-10, 0, 0.84127, 0.377253, 488211e-10, 0, 0.873016, 0.359021, 468234e-10, 0, 0.904762, 0.341637, 453269e-10, 0, 0.936508, 0.3247, 433014e-10, 0, 0.968254, 0.308625, 418007e-10, 0, 1, 1, 286798e-15, 0, 0, 1, 286877e-15, 0, 0, 1, 288094e-15, 0, 0, 1, 293506e-15, 0, 0, 1, 309262e-15, 0, 0, 0.999999, 348593e-15, 0, 0, 0.999999, 444582e-15, 0, 0, 0.999998, 688591e-15, 0, 0, 0.999996, 134391e-14, 0, 0, 0.999993, 317438e-14, 0, 0, 0.999989, 835609e-14, 0, 0, 0.999983, 228677e-13, 0, 0, 0.999974, 623361e-13, 0, 0, 0.999959, 165225e-12, 0, 0, 0.999936, 419983e-12, 0, 0, 0.999896, 101546e-11, 0, 0, 0.99983, 232376e-11, 0, 0, 0.999709, 50156e-10, 0, 0, 0.999469, 10167e-9, 0, 0, 0.998886, 190775e-10, 0, 0, 0.996819, 300511e-10, 0, 0, 0.988837, 185092e-10, 0, 168222e-12, 0.982178, 134622e-10, 0, 259622e-9, 0.975017, 125961e-10, 0, 142595e-8, 0.967101, 13507e-9, 0, 382273e-8, 0.964905, 205003e-10, 0, 764164e-8, 0.96218, 29546e-9, 0, 0.0130121, 0.956821, 343738e-10, 0, 0.0200253, 0.948829, 305063e-10, 0, 0.0287452, 0.941092, 346487e-10, 0, 0.039218, 0.931883, 412061e-10, 0, 0.0514748, 0.920211, 444651e-10, 0, 0.0655351, 0.907307, 431252e-10, 0, 0.0814082, 0.89684, 490382e-10, 0, 0.0990939, 0.884119, 53334e-9, 0, 0.118583, 0.869148, 54114e-9, 0, 0.139856, 0.853377, 578536e-10, 0, 0.162882, 0.836753, 592285e-10, 0, 0.187615, 0.820063, 622787e-10, 0, 0.213991, 0.801694, 645492e-10, 0, 0.241918, 0.782116, 65353e-9, 0, 0.271267, 0.762673, 674344e-10, 0, 0.301847, 0.742133, 682788e-10, 0, 0.333333, 0.720779, 691959e-10, 0, 0.365079, 0.699386, 696817e-10, 0, 0.396826, 0.67732, 699583e-10, 0, 0.428572, 0.654888, 698447e-10, 0, 0.460318, 0.632499, 694063e-10, 0, 0.492064, 0.609825, 691612e-10, 0, 0.52381, 0.587287, 681576e-10, 0, 0.555556, 0.564743, 674138e-10, 0, 0.587302, 0.542409, 661617e-10, 0, 0.619048, 0.520282, 647785e-10, 0, 0.650794, 0.498506, 633836e-10, 0, 0.68254, 0.477102, 615905e-10, 0, 0.714286, 0.456167, 601013e-10, 0, 0.746032, 0.435728, 581457e-10, 0, 0.777778, 0.415809, 564215e-10, 0, 0.809524, 0.396517, 544997e-10, 0, 0.84127, 0.377737, 525061e-10, 0, 0.873016, 0.359698, 506831e-10, 0, 0.904762, 0.342164, 48568e-9, 0, 0.936508, 0.325417, 467826e-10, 0, 0.968254, 0.309186, 446736e-10, 0, 1, 1, 109018e-14, 0, 0, 1, 10904e-13, 0, 0, 1, 109393e-14, 0, 0, 1, 11095e-13, 0, 0, 1, 1154e-12, 0, 0, 1, 126089e-14, 0, 0, 0.999999, 15059e-13, 0, 0, 0.999997, 207899e-14, 0, 0, 0.999994, 348164e-14, 0, 0, 0.999993, 705728e-14, 0, 0, 0.999987, 163692e-13, 0, 0, 0.999981, 406033e-13, 0, 0, 0.999969, 10245e-11, 0, 0, 0.999953, 255023e-12, 0, 0, 0.999925, 61511e-11, 0, 0, 0.999881, 142218e-11, 0, 0, 0.99981, 313086e-11, 0, 0, 0.99968, 653119e-11, 0, 0, 0.999418, 12832e-9, 0, 0, 0.998748, 232497e-10, 0, 0, 0.996066, 329522e-10, 0, 0, 0.988379, 179613e-10, 0, 108799e-9, 0.982567, 143715e-10, 0, 921302e-9, 0.976097, 148096e-10, 0, 280738e-8, 0.968475, 178905e-10, 0, 596622e-8, 0.964606, 253921e-10, 0, 0.0105284, 0.961564, 348623e-10, 0, 0.0165848, 0.955517, 357612e-10, 0, 0.0242, 0.948381, 343493e-10, 0, 0.03342, 0.941095, 405849e-10, 0, 0.0442777, 0.931923, 475394e-10, 0, 0.0567958, 0.91996, 484328e-10, 0, 0.0709879, 0.907419, 502146e-10, 0, 0.086861, 0.89618, 561654e-10, 0, 0.104415, 0.88337, 587612e-10, 0, 0.123643, 0.869046, 618057e-10, 0, 0.144531, 0.853278, 657392e-10, 0, 0.167057, 0.836091, 66303e-9, 0, 0.191188, 0.819644, 704445e-10, 0, 0.216878, 0.801246, 714071e-10, 0, 0.244062, 0.782031, 740093e-10, 0, 0.272649, 0.762066, 74685e-9, 0, 0.302509, 0.741964, 766647e-10, 0, 0.333442, 0.720554, 766328e-10, 0, 0.365079, 0.699098, 777857e-10, 0, 0.396826, 0.677189, 774633e-10, 0, 0.428572, 0.65484, 776235e-10, 0, 0.460318, 0.632496, 770316e-10, 0, 0.492064, 0.609908, 762669e-10, 0, 0.52381, 0.587312, 753972e-10, 0, 0.555556, 0.564938, 739994e-10, 0, 0.587302, 0.542577, 728382e-10, 0, 0.619048, 0.52062, 71112e-9, 0, 0.650794, 0.498819, 694004e-10, 0, 0.68254, 0.477555, 675575e-10, 0, 0.714286, 0.456568, 653449e-10, 0, 0.746032, 0.436278, 636068e-10, 0, 0.777778, 0.41637, 613466e-10, 0, 0.809524, 0.397144, 594177e-10, 0, 0.84127, 0.378412, 570987e-10, 0, 0.873016, 0.360376, 550419e-10, 0, 0.904762, 0.342906, 527422e-10, 0, 0.936508, 0.326136, 506544e-10, 0, 0.968254, 0.30997, 484307e-10, 0, 1, 1, 354014e-14, 0, 0, 1, 354073e-14, 0, 0, 1, 354972e-14, 0, 0, 1, 358929e-14, 0, 0, 1, 370093e-14, 0, 0, 0.999999, 396194e-14, 0, 0, 0.999998, 453352e-14, 0, 0, 0.999997, 578828e-14, 0, 0, 0.999994, 863812e-14, 0, 0, 0.999991, 153622e-13, 0, 0, 0.999985, 316356e-13, 0, 0, 0.999977, 712781e-13, 0, 0, 0.999964, 166725e-12, 0, 0, 0.999945, 390501e-12, 0, 0, 0.999912, 895622e-12, 0, 0, 0.999866, 198428e-11, 0, 0, 0.999786, 421038e-11, 0, 0, 0.999647, 850239e-11, 0, 0, 0.999356, 162059e-10, 0, 0, 0.998563, 282652e-10, 0, 0, 0.994928, 336309e-10, 0, 244244e-10, 0.987999, 178458e-10, 0, 523891e-9, 0.982893, 159162e-10, 0, 194729e-8, 0.977044, 178056e-10, 0, 451099e-8, 0.969972, 230624e-10, 0, 835132e-8, 0.964237, 313922e-10, 0, 0.013561, 0.960791, 406145e-10, 0, 0.0202056, 0.954292, 372796e-10, 0, 0.0283321, 0.948052, 403199e-10, 0, 0.0379739, 0.940938, 479537e-10, 0, 0.0491551, 0.931689, 545292e-10, 0, 0.0618918, 0.91987, 54038e-9, 0, 0.0761941, 0.907665, 589909e-10, 0, 0.0920672, 0.895281, 642651e-10, 0, 0.109511, 0.882621, 659707e-10, 0, 0.12852, 0.86873, 709973e-10, 0, 0.149085, 0.853008, 742221e-10, 0, 0.171189, 0.835944, 761754e-10, 0, 0.194809, 0.818949, 797052e-10, 0, 0.21991, 0.800951, 812434e-10, 0, 0.246447, 0.781847, 838075e-10, 0, 0.274352, 0.761649, 84501e-9, 0, 0.303535, 0.74152, 860258e-10, 0, 0.333857, 0.720495, 866233e-10, 0, 0.365104, 0.698742, 868326e-10, 0, 0.396826, 0.677096, 87133e-9, 0, 0.428572, 0.654782, 863497e-10, 0, 0.460318, 0.632335, 860206e-10, 0, 0.492064, 0.610031, 849337e-10, 0, 0.52381, 0.587457, 838279e-10, 0, 0.555556, 0.56513, 82309e-9, 0, 0.587302, 0.542877, 803542e-10, 0, 0.619048, 0.5209, 786928e-10, 0, 0.650794, 0.499291, 765171e-10, 0, 0.68254, 0.477971, 744753e-10, 0, 0.714286, 0.457221, 72209e-9, 0, 0.746032, 0.436803, 697448e-10, 0, 0.777778, 0.417083, 675333e-10, 0, 0.809524, 0.397749, 648058e-10, 0, 0.84127, 0.379177, 625759e-10, 0, 0.873016, 0.361061, 598584e-10, 0, 0.904762, 0.343713, 575797e-10, 0, 0.936508, 0.326894, 549999e-10, 0, 0.968254, 0.310816, 527482e-10, 0, 1, 1, 10153e-12, 0, 0, 1, 101544e-13, 0, 0, 1, 101751e-13, 0, 0, 1, 102662e-13, 0, 0, 1, 10521e-12, 0, 0, 0.999999, 111049e-13, 0, 0, 0.999999, 123408e-13, 0, 0, 0.999996, 14924e-12, 0, 0, 0.999992, 204471e-13, 0, 0, 0.999989, 326539e-13, 0, 0, 0.99998, 603559e-13, 0, 0, 0.999971, 123936e-12, 0, 0, 0.999955, 269058e-12, 0, 0, 0.999933, 593604e-12, 0, 0, 0.999901, 129633e-11, 0, 0, 0.999847, 275621e-11, 0, 0, 0.999761, 564494e-11, 0, 0, 0.999607, 110485e-10, 0, 0, 0.999282, 204388e-10, 0, 0, 0.99831, 341084e-10, 0, 22038e-11, 0.993288, 294949e-10, 0, 242388e-9, 0.987855, 192736e-10, 0, 12503e-7, 0.983167, 182383e-10, 0, 32745e-7, 0.977908, 218633e-10, 0, 646321e-8, 0.971194, 290662e-10, 0, 0.0109133, 0.963867, 386401e-10, 0, 0.0166927, 0.95982, 462827e-10, 0, 0.0238494, 0.953497, 420705e-10, 0, 0.0324178, 0.947621, 477743e-10, 0, 0.0424225, 0.940611, 568258e-10, 0, 0.0538808, 0.931174, 618061e-10, 0, 0.0668047, 0.919919, 627098e-10, 0, 0.0812014, 0.907856, 694714e-10, 0, 0.0970745, 0.894509, 735008e-10, 0, 0.114424, 0.881954, 763369e-10, 0, 0.133246, 0.868309, 821896e-10, 0, 0.153534, 0.852511, 83769e-9, 0, 0.175275, 0.835821, 881615e-10, 0, 0.198453, 0.817981, 896368e-10, 0, 0.223042, 0.800504, 930906e-10, 0, 0.249009, 0.78141, 945056e-10, 0, 0.276304, 0.761427, 963605e-10, 0, 0.304862, 0.74094, 968088e-10, 0, 0.334584, 0.720233, 981481e-10, 0, 0.365322, 0.698592, 979122e-10, 0, 0.396826, 0.676763, 981057e-10, 0, 0.428571, 0.654808, 973956e-10, 0, 0.460318, 0.632326, 962619e-10, 0, 0.492064, 0.610049, 952996e-10, 0, 0.52381, 0.58763, 933334e-10, 0, 0.555556, 0.565261, 917573e-10, 0, 0.587302, 0.543244, 896636e-10, 0, 0.619048, 0.521273, 873304e-10, 0, 0.650794, 0.499818, 852648e-10, 0, 0.68254, 0.478536, 823961e-10, 0, 0.714286, 0.457826, 79939e-9, 0, 0.746032, 0.437549, 77126e-9, 0, 0.777778, 0.41776, 743043e-10, 0, 0.809524, 0.39863, 716426e-10, 0, 0.84127, 0.379954, 686456e-10, 0, 0.873016, 0.362025, 660514e-10, 0, 0.904762, 0.344581, 630755e-10, 0, 0.936508, 0.327909, 605439e-10, 0, 0.968254, 0.311736, 576345e-10, 0, 1, 1, 263344e-13, 0, 0, 1, 263373e-13, 0, 0, 1, 263815e-13, 0, 0, 1, 265753e-13, 0, 0, 1, 271132e-13, 0, 0, 0.999999, 283279e-13, 0, 0, 0.999997, 30833e-12, 0, 0, 0.999995, 358711e-13, 0, 0, 0.999992, 461266e-13, 0, 0, 0.999985, 67574e-12, 0, 0, 0.999977, 11358e-11, 0, 0, 0.999966, 213657e-12, 0, 0, 0.999948, 431151e-12, 0, 0, 0.999923, 896656e-12, 0, 0, 0.999884, 186603e-11, 0, 0, 0.999826, 381115e-11, 0, 0, 0.999732, 754184e-11, 0, 0, 0.999561, 143192e-10, 0, 0, 0.999191, 257061e-10, 0, 0, 0.997955, 405724e-10, 0, 744132e-10, 0.992228, 276537e-10, 0, 716477e-9, 0.987638, 208885e-10, 0, 22524e-7, 0.983395, 215226e-10, 0, 484816e-8, 0.978614, 270795e-10, 0, 860962e-8, 0.972389, 365282e-10, 0, 0.0136083, 0.964392, 474747e-10, 0, 0.0198941, 0.95861, 509141e-10, 0, 0.0275023, 0.952806, 48963e-9, 0, 0.0364584, 0.94712, 571119e-10, 0, 0.04678, 0.940104, 671704e-10, 0, 0.0584799, 0.930398, 687586e-10, 0, 0.0715665, 0.919866, 738161e-10, 0, 0.086045, 0.907853, 813235e-10, 0, 0.101918, 0.894078, 834582e-10, 0, 0.119186, 0.881177, 892093e-10, 0, 0.137845, 0.867575, 944548e-10, 0, 0.157891, 0.852107, 969607e-10, 0, 0.179316, 0.835502, 101456e-9, 0, 0.202106, 0.81756, 103256e-9, 0, 0.226243, 0.79984, 106954e-9, 0, 0.251704, 0.780998, 108066e-9, 0, 0.278451, 0.761132, 110111e-9, 0, 0.306436, 0.740429, 110459e-9, 0, 0.335586, 0.719836, 111219e-9, 0, 0.365796, 0.698467, 11145e-8, 0, 0.3969, 0.676446, 110393e-9, 0, 0.428571, 0.654635, 110035e-9, 0, 0.460318, 0.632411, 108548e-9, 0, 0.492064, 0.609986, 106963e-9, 0, 0.52381, 0.587872, 105238e-9, 0, 0.555556, 0.565528, 102665e-9, 0, 0.587302, 0.543563, 100543e-9, 0, 0.619048, 0.52176, 976182e-10, 0, 0.650794, 0.500188, 947099e-10, 0, 0.68254, 0.479204, 919929e-10, 0, 0.714286, 0.458413, 886139e-10, 0, 0.746032, 0.438314, 857839e-10, 0, 0.777778, 0.418573, 82411e-9, 0, 0.809524, 0.39947, 792211e-10, 0, 0.84127, 0.380892, 759546e-10, 0, 0.873016, 0.362953, 727571e-10, 0, 0.904762, 0.345601, 695738e-10, 0, 0.936508, 0.328895, 664907e-10, 0, 0.968254, 0.312808, 634277e-10, 0, 1, 1, 628647e-13, 0, 0, 1, 628705e-13, 0, 0, 1, 629587e-13, 0, 0, 1, 633441e-13, 0, 0, 0.999999, 644087e-13, 0, 0, 0.999998, 667856e-13, 0, 0, 0.999997, 715889e-13, 0, 0, 0.999995, 809577e-13, 0, 0, 0.999989, 992764e-13, 0, 0, 0.999983, 135834e-12, 0, 0, 0.999974, 210482e-12, 0, 0, 0.999959, 365215e-12, 0, 0, 0.999939, 686693e-12, 0, 0, 0.999911, 13472e-10, 0, 0, 0.999868, 26731e-10, 0, 0, 0.999804, 524756e-11, 0, 0, 0.9997, 100403e-10, 0, 0, 0.99951, 185019e-10, 0, 0, 0.999078, 322036e-10, 0, 620676e-11, 0.997428, 470002e-10, 0, 341552e-9, 0.99162, 287123e-10, 0, 143727e-8, 0.987479, 234706e-10, 0, 349201e-8, 0.983582, 260083e-10, 0, 66242e-7, 0.979186, 337927e-10, 0, 0.0109113, 0.97325, 454689e-10, 0, 0.0164064, 0.965221, 573759e-10, 0, 0.0231463, 0.957262, 544114e-10, 0, 0.0311571, 0.952211, 587006e-10, 0, 0.0404572, 0.946631, 692256e-10, 0, 0.0510592, 0.939391, 787819e-10, 0, 0.0629723, 0.929795, 792368e-10, 0, 0.0762025, 0.91965, 875075e-10, 0, 0.090753, 0.907737, 950903e-10, 0, 0.106626, 0.893899, 972963e-10, 0, 0.123822, 0.880239, 10459e-8, 0, 0.142337, 0.866562, 107689e-9, 0, 0.16217, 0.85164, 113081e-9, 0, 0.183314, 0.835021, 116636e-9, 0, 0.20576, 0.817311, 120074e-9, 0, 0.229496, 0.798845, 121921e-9, 0, 0.254502, 0.780479, 12475e-8, 0, 0.280753, 0.760694, 125255e-9, 0, 0.308212, 0.740142, 126719e-9, 0, 0.336825, 0.719248, 12636e-8, 0, 0.366517, 0.698209, 126712e-9, 0, 0.397167, 0.676398, 125769e-9, 0, 0.428578, 0.654378, 124432e-9, 0, 0.460318, 0.632484, 123272e-9, 0, 0.492064, 0.610113, 12085e-8, 0, 0.52381, 0.587931, 118411e-9, 0, 0.555556, 0.565872, 11569e-8, 0, 0.587302, 0.543814, 112521e-9, 0, 0.619048, 0.522265, 109737e-9, 0, 0.650794, 0.500835, 106228e-9, 0, 0.68254, 0.479818, 102591e-9, 0, 0.714286, 0.459258, 991288e-10, 0, 0.746032, 0.439061, 952325e-10, 0, 0.777778, 0.419552, 91895e-9, 0, 0.809524, 0.400399, 879051e-10, 0, 0.84127, 0.381976, 844775e-10, 0, 0.873016, 0.364009, 806316e-10, 0, 0.904762, 0.346761, 771848e-10, 0, 0.936508, 0.330049, 735429e-10, 0, 0.968254, 0.314018, 702103e-10, 0, 1, 1, 139968e-12, 0, 0, 1, 139979e-12, 0, 0, 1, 140145e-12, 0, 0, 1, 14087e-11, 0, 0, 0.999999, 142865e-12, 0, 0, 0.999998, 147279e-12, 0, 0, 0.999997, 156057e-12, 0, 0, 0.999992, 17276e-11, 0, 0, 0.999989, 204352e-12, 0, 0, 0.99998, 26494e-11, 0, 0, 0.999969, 383435e-12, 0, 0, 0.999953, 618641e-12, 0, 0, 0.999929, 108755e-11, 0, 0, 0.999898, 201497e-11, 0, 0, 0.999849, 381346e-11, 0, 0, 0.999778, 719815e-11, 0, 0, 0.999661, 133215e-10, 0, 0, 0.999451, 238313e-10, 0, 0, 0.998936, 401343e-10, 0, 113724e-9, 0.99662, 517346e-10, 0, 820171e-9, 0.991094, 304323e-10, 0, 238143e-8, 0.987487, 281757e-10, 0, 493527e-8, 0.983731, 320048e-10, 0, 856859e-8, 0.979647, 423905e-10, 0, 0.0133393, 0.973837, 562935e-10, 0, 0.0192863, 0.96584, 677442e-10, 0, 0.0264369, 0.956309, 623073e-10, 0, 0.03481, 0.951523, 704131e-10, 0, 0.0444184, 0.946003, 836594e-10, 0, 0.0552713, 0.938454, 911736e-10, 0, 0.0673749, 0.929279, 938264e-10, 0, 0.0807329, 0.919239, 103754e-9, 0, 0.0953479, 0.907293, 109928e-9, 0, 0.111221, 0.893936, 115257e-9, 0, 0.128352, 0.879674, 122265e-9, 0, 0.14674, 0.865668, 125733e-9, 0, 0.166382, 0.850998, 132305e-9, 0, 0.187276, 0.834498, 134844e-9, 0, 0.209413, 0.816903, 139276e-9, 0, 0.232786, 0.798235, 140984e-9, 0, 0.257382, 0.779724, 14378e-8, 0, 0.283181, 0.760251, 144623e-9, 0, 0.310156, 0.739808, 145228e-9, 0, 0.338269, 0.718762, 14539e-8, 0, 0.367461, 0.697815, 144432e-9, 0, 0.397646, 0.67631, 143893e-9, 0, 0.428685, 0.654278, 141846e-9, 0, 0.460318, 0.632347, 13935e-8, 0, 0.492064, 0.610296, 137138e-9, 0, 0.52381, 0.588039, 133806e-9, 0, 0.555556, 0.566218, 130755e-9, 0, 0.587302, 0.544346, 127128e-9, 0, 0.619048, 0.522701, 123002e-9, 0, 0.650794, 0.501542, 119443e-9, 0, 0.68254, 0.480508, 115055e-9, 0, 0.714286, 0.460092, 111032e-9, 0, 0.746032, 0.440021, 106635e-9, 0, 0.777778, 0.420446, 102162e-9, 0, 0.809524, 0.401512, 98184e-9, 0, 0.84127, 0.38299, 936497e-10, 0, 0.873016, 0.365232, 89813e-9, 0, 0.904762, 0.347865, 853073e-10, 0, 0.936508, 0.331342, 817068e-10, 0, 0.968254, 0.315202, 773818e-10, 0, 1, 1, 29368e-11, 0, 0, 1, 2937e-10, 0, 0, 1, 293998e-12, 0, 0, 1, 295298e-12, 0, 0, 0.999999, 298865e-12, 0, 0, 0.999998, 3067e-10, 0, 0, 0.999995, 322082e-12, 0, 0, 0.999992, 350767e-12, 0, 0, 0.999986, 403538e-12, 0, 0, 0.999976, 501372e-12, 0, 0, 0.999964, 68562e-11, 0, 0, 0.999945, 10374e-10, 0, 0, 0.999919, 171269e-11, 0, 0, 0.999882, 300175e-11, 0, 0, 0.999829, 542144e-11, 0, 0, 0.999749, 984182e-11, 0, 0, 0.99962, 176213e-10, 0, 0, 0.999382, 305995e-10, 0, 138418e-10, 0.998751, 496686e-10, 0, 389844e-9, 0.995344, 510733e-10, 0, 150343e-8, 0.990768, 345829e-10, 0, 352451e-8, 0.987464, 342841e-10, 0, 655379e-8, 0.983846, 399072e-10, 0, 0.0106554, 0.980007, 533219e-10, 0, 0.0158723, 0.974494, 696992e-10, 0, 0.0222333, 0.96622, 776754e-10, 0, 0.029758, 0.956273, 747718e-10, 0, 0.0384596, 0.950952, 864611e-10, 0, 0.0483473, 0.945215, 100464e-9, 0, 0.0594266, 0.937287, 103729e-9, 0, 0.0717019, 0.928649, 111665e-9, 0, 0.0851752, 0.918791, 12353e-8, 0, 0.0998479, 0.906685, 127115e-9, 0, 0.115721, 0.893706, 13628e-8, 0, 0.132794, 0.879248, 142427e-9, 0, 0.151067, 0.864685, 148091e-9, 0, 0.170538, 0.850032, 153517e-9, 0, 0.191204, 0.833853, 157322e-9, 0, 0.213063, 0.816353, 161086e-9, 0, 0.236107, 0.797834, 164111e-9, 0, 0.260329, 0.778831, 165446e-9, 0, 0.285714, 0.759756, 167492e-9, 0, 0.312243, 0.739419, 166928e-9, 0, 0.339887, 0.718491, 167e-6, 0, 0.368604, 0.697392, 165674e-9, 0, 0.398329, 0.676102, 163815e-9, 0, 0.428961, 0.654243, 162003e-9, 0, 0.460331, 0.632176, 158831e-9, 0, 0.492064, 0.610407, 155463e-9, 0, 0.52381, 0.588394, 152062e-9, 0, 0.555556, 0.56645, 147665e-9, 0, 0.587302, 0.5449, 14375e-8, 0, 0.619048, 0.523276, 138905e-9, 0, 0.650794, 0.502179, 134189e-9, 0, 0.68254, 0.481359, 129392e-9, 0, 0.714286, 0.46092, 124556e-9, 0, 0.746032, 0.441084, 11957e-8, 0, 0.777778, 0.421517, 114652e-9, 0, 0.809524, 0.402721, 109688e-9, 0, 0.84127, 0.384222, 104667e-9, 0, 0.873016, 0.366534, 999633e-10, 0, 0.904762, 0.349205, 950177e-10, 0, 0.936508, 0.332702, 907301e-10, 0, 0.968254, 0.316599, 859769e-10, 0, 1, 1, 585473e-12, 0, 0, 1, 585507e-12, 0, 0, 1, 58602e-11, 0, 0, 0.999999, 588259e-12, 0, 0, 0.999999, 594381e-12, 0, 0, 0.999998, 607754e-12, 0, 0, 0.999995, 633729e-12, 0, 0, 0.99999, 68137e-11, 0, 0, 0.999984, 767003e-12, 0, 0, 0.999973, 921212e-12, 0, 0, 0.999959, 120218e-11, 0, 0, 0.999936, 172024e-11, 0, 0, 0.999907, 268088e-11, 0, 0, 0.999866, 445512e-11, 0, 0, 0.999806, 768481e-11, 0, 0, 0.999716, 1342e-8, 0, 0, 0.999576, 232473e-10, 0, 0, 0.9993, 391694e-10, 0, 129917e-9, 0.998498, 608429e-10, 0, 845035e-9, 0.994132, 489743e-10, 0, 237616e-8, 0.99031, 384644e-10, 0, 484456e-8, 0.987409, 421768e-10, 0, 832472e-8, 0.983981, 504854e-10, 0, 0.0128643, 0.980268, 671028e-10, 0, 0.0184947, 0.974875, 852749e-10, 0, 0.025237, 0.966063, 85531e-9, 0, 0.0331046, 0.956779, 900588e-10, 0, 0.0421067, 0.950259, 10577e-8, 0, 0.0522487, 0.944239, 119458e-9, 0, 0.0635343, 0.936341, 122164e-9, 0, 0.0759654, 0.928047, 134929e-9, 0, 0.0895434, 0.918065, 145544e-9, 0, 0.104269, 0.906267, 150531e-9, 0, 0.120142, 0.893419, 161652e-9, 0, 0.137163, 0.878758, 16593e-8, 0, 0.15533, 0.863699, 174014e-9, 0, 0.174645, 0.848876, 177877e-9, 0, 0.195106, 0.833032, 184049e-9, 0, 0.21671, 0.815557, 186088e-9, 0, 0.239454, 0.797323, 19054e-8, 0, 0.263332, 0.778124, 191765e-9, 0, 0.288336, 0.758929, 192535e-9, 0, 0.314451, 0.738979, 192688e-9, 0, 0.341658, 0.718213, 191522e-9, 0, 0.369924, 0.696947, 190491e-9, 0, 0.399202, 0.675807, 187913e-9, 0, 0.429416, 0.654147, 184451e-9, 0, 0.460447, 0.63229, 181442e-9, 0, 0.492064, 0.610499, 177139e-9, 0, 0.523809, 0.588747, 172596e-9, 0, 0.555555, 0.566783, 167457e-9, 0, 0.587301, 0.545359, 162518e-9, 0, 0.619048, 0.523984, 156818e-9, 0, 0.650794, 0.502917, 151884e-9, 0, 0.68254, 0.482294, 145514e-9, 0, 0.714286, 0.461945, 140199e-9, 0, 0.746032, 0.442133, 134101e-9, 0, 0.777778, 0.422705, 128374e-9, 0, 0.809524, 0.403916, 122996e-9, 0, 0.84127, 0.38554, 116808e-9, 0, 0.873016, 0.367909, 111973e-9, 0, 0.904762, 0.350651, 105938e-9, 0, 0.936508, 0.334208, 101355e-9, 0, 0.968254, 0.318123, 957629e-10, 0, 1, 1, 111633e-11, 0, 0, 1, 111639e-11, 0, 0, 1, 111725e-11, 0, 0, 1, 112096e-11, 0, 0, 0.999999, 11311e-10, 0, 0, 0.999997, 115315e-11, 0, 0, 0.999995, 11956e-10, 0, 0, 0.999989, 127239e-11, 0, 0, 0.999981, 140772e-11, 0, 0, 0.999969, 164541e-11, 0, 0, 0.999952, 206607e-11, 0, 0, 0.999928, 281783e-11, 0, 0, 0.999895, 416835e-11, 0, 0, 0.999848, 658728e-11, 0, 0, 0.999781, 108648e-10, 0, 0, 0.999682, 182579e-10, 0, 0, 0.999523, 306003e-10, 0, 159122e-10, 0.999205, 499862e-10, 0, 391184e-9, 0.998131, 73306e-9, 0, 147534e-8, 0.993334, 513229e-10, 0, 34227e-7, 0.99016, 467783e-10, 0, 632232e-8, 0.987321, 523413e-10, 0, 0.0102295, 0.984099, 64267e-9, 0, 0.0151794, 0.980432, 843042e-10, 0, 0.0211947, 0.974976, 102819e-9, 0, 0.0282899, 0.966429, 996234e-10, 0, 0.0364739, 0.957633, 111074e-9, 0, 0.0457522, 0.949422, 128644e-9, 0, 0.0561278, 0.943045, 140076e-9, 0, 0.0676023, 0.935448, 146349e-9, 0, 0.0801762, 0.927225, 161854e-9, 0, 0.0938499, 0.917033, 169135e-9, 0, 0.108623, 0.905762, 179987e-9, 0, 0.124496, 0.892879, 189832e-9, 0, 0.141469, 0.878435, 195881e-9, 0, 0.159541, 0.863114, 20466e-8, 0, 0.178713, 0.84776, 209473e-9, 0, 0.198985, 0.832084, 214861e-9, 0, 0.220355, 0.814915, 217695e-9, 0, 0.242823, 0.796711, 220313e-9, 0, 0.266385, 0.777603, 22313e-8, 0, 0.291036, 0.757991, 222471e-9, 0, 0.316767, 0.738371, 222869e-9, 0, 0.343563, 0.717872, 221243e-9, 0, 0.371402, 0.696619, 218089e-9, 0, 0.400248, 0.675379, 21562e-8, 0, 0.430047, 0.65411, 21169e-8, 0, 0.460709, 0.63241, 206947e-9, 0, 0.492079, 0.61046, 201709e-9, 0, 0.52381, 0.58903, 196753e-9, 0, 0.555556, 0.567267, 189637e-9, 0, 0.587302, 0.545886, 184735e-9, 0, 0.619048, 0.524714, 177257e-9, 0, 0.650794, 0.503789, 171424e-9, 0, 0.68254, 0.483204, 164688e-9, 0, 0.714286, 0.462976, 157172e-9, 0, 0.746032, 0.443294, 151341e-9, 0, 0.777778, 0.423988, 143737e-9, 0, 0.809524, 0.405325, 138098e-9, 0, 0.84127, 0.386981, 130698e-9, 0, 0.873016, 0.369436, 125276e-9, 0, 0.904762, 0.35219, 118349e-9, 0, 0.936508, 0.335804, 11312e-8, 0, 0.968254, 0.319749, 106687e-9, 0, 1, 1, 204685e-11, 0, 0, 1, 204694e-11, 0, 0, 1, 204831e-11, 0, 0, 0.999999, 205428e-11, 0, 0, 0.999999, 207056e-11, 0, 0, 0.999997, 210581e-11, 0, 0, 0.999993, 21732e-10, 0, 0, 0.999987, 229365e-11, 0, 0, 0.999979, 250243e-11, 0, 0, 0.999965, 286127e-11, 0, 0, 0.999947, 348028e-11, 0, 0, 0.999918, 455588e-11, 0, 0, 0.999881, 643303e-11, 0, 0, 0.999828, 970064e-11, 0, 0, 0.999753, 153233e-10, 0, 0, 0.999642, 24793e-9, 0, 0, 0.999464, 402032e-10, 0, 122947e-9, 0.999089, 635852e-10, 0, 807414e-9, 0.997567, 857026e-10, 0, 227206e-8, 0.992903, 594912e-10, 0, 462812e-8, 0.990011, 578515e-10, 0, 794162e-8, 0.987192, 65399e-9, 0, 0.0122534, 0.98418, 819675e-10, 0, 0.0175888, 0.980491, 105514e-9, 0, 0.0239635, 0.974779, 121532e-9, 0, 0.031387, 0.96675, 119144e-9, 0, 0.0398644, 0.958248, 136125e-9, 0, 0.0493982, 0.948884, 155408e-9, 0, 0.0599896, 0.941673, 162281e-9, 0, 0.0716382, 0.934521, 176754e-9, 0, 0.0843437, 0.926205, 192873e-9, 0, 0.0981056, 0.916089, 200038e-9, 0, 0.112923, 0.904963, 213624e-9, 0, 0.128796, 0.892089, 221834e-9, 0, 0.145725, 0.878028, 232619e-9, 0, 0.163709, 0.86249, 238632e-9, 0, 0.182749, 0.846587, 247002e-9, 0, 0.202847, 0.830988, 250702e-9, 0, 0.224001, 0.814165, 255562e-9, 0, 0.246214, 0.796135, 257505e-9, 0, 0.269482, 0.777052, 258625e-9, 0, 0.293805, 0.757201, 258398e-9, 0, 0.319176, 0.737655, 256714e-9, 0, 0.345587, 0.717477, 255187e-9, 0, 0.373021, 0.696433, 251792e-9, 0, 0.401454, 0.675084, 247223e-9, 0, 0.430844, 0.653907, 242213e-9, 0, 0.461125, 0.632561, 237397e-9, 0, 0.492187, 0.610658, 229313e-9, 0, 0.52381, 0.589322, 224402e-9, 0, 0.555556, 0.567857, 216116e-9, 0, 0.587302, 0.54652, 209124e-9, 0, 0.619048, 0.525433, 201601e-9, 0, 0.650794, 0.504679, 192957e-9, 0, 0.68254, 0.484203, 186052e-9, 0, 0.714286, 0.464203, 177672e-9, 0, 0.746032, 0.444549, 170005e-9, 0, 0.777778, 0.425346, 162401e-9, 0, 0.809524, 0.406706, 1544e-7, 0, 0.84127, 0.388576, 147437e-9, 0, 0.873016, 0.37094, 139493e-9, 0, 0.904762, 0.353996, 133219e-9, 0, 0.936508, 0.337391, 125573e-9, 0, 0.968254, 0.321648, 119867e-9, 0, 1, 1, 362511e-11, 0, 0, 1, 362525e-11, 0, 0, 1, 362739e-11, 0, 0, 0.999999, 363673e-11, 0, 0, 0.999998, 366214e-11, 0, 0, 0.999996, 371698e-11, 0, 0, 0.999992, 382116e-11, 0, 0, 0.999986, 400554e-11, 0, 0, 0.999976, 432058e-11, 0, 0, 0.999961, 485194e-11, 0, 0, 0.999938, 574808e-11, 0, 0, 0.999908, 726643e-11, 0, 0, 0.999865, 984707e-11, 0, 0, 0.999807, 142217e-10, 0, 0, 0.999723, 215581e-10, 0, 0, 0.999602, 336114e-10, 0, 119113e-10, 0.999398, 527353e-10, 0, 355813e-9, 0.998946, 805809e-10, 0, 137768e-8, 0.996647, 942908e-10, 0, 322469e-8, 0.992298, 668733e-10, 0, 597897e-8, 0.989802, 716564e-10, 0, 968903e-8, 0.987019, 821355e-10, 0, 0.0143845, 0.984219, 104555e-9, 0, 0.0200831, 0.980425, 131245e-9, 0, 0.0267948, 0.974241, 139613e-9, 0, 0.034525, 0.967006, 145931e-9, 0, 0.0432757, 0.95893, 167153e-9, 0, 0.0530471, 0.949157, 188146e-9, 0, 0.0638386, 0.94062, 194625e-9, 0, 0.0756487, 0.933509, 213721e-9, 0, 0.0884762, 0.925088, 229616e-9, 0, 0.10232, 0.915178, 239638e-9, 0, 0.117178, 0.904093, 254814e-9, 0, 0.133051, 0.891337, 263685e-9, 0, 0.149939, 0.877326, 274789e-9, 0, 0.167841, 0.861794, 280534e-9, 0, 0.18676, 0.845758, 289534e-9, 0, 0.206696, 0.829792, 294446e-9, 0, 0.22765, 0.813037, 296877e-9, 0, 0.249625, 0.795285, 300217e-9, 0, 0.27262, 0.776323, 299826e-9, 0, 0.296636, 0.756673, 299787e-9, 0, 0.321671, 0.736856, 297867e-9, 0, 0.347718, 0.716883, 294052e-9, 0, 0.374768, 0.696089, 289462e-9, 0, 0.402804, 0.67505, 285212e-9, 0, 0.431796, 0.653509, 27653e-8, 0, 0.461695, 0.63258, 271759e-9, 0, 0.49242, 0.61104, 262811e-9, 0, 0.523822, 0.589567, 255151e-9, 0, 0.555556, 0.568322, 246434e-9, 0, 0.587302, 0.547235, 237061e-9, 0, 0.619048, 0.52616, 228343e-9, 0, 0.650794, 0.505716, 219236e-9, 0, 0.68254, 0.485274, 209595e-9, 0, 0.714286, 0.465411, 201011e-9, 0, 0.746032, 0.445854, 19109e-8, 0, 0.777778, 0.426911, 182897e-9, 0, 0.809524, 0.408222, 173569e-9, 0, 0.84127, 0.390307, 165496e-9, 0, 0.873016, 0.372624, 156799e-9, 0, 0.904762, 0.355804, 14917e-8, 0, 0.936508, 0.33924, 140907e-9, 0, 0.968254, 0.323534, 134062e-9, 0, 1, 1, 622487e-11, 0, 0, 1, 62251e-10, 0, 0, 1, 622837e-11, 0, 0, 0.999999, 624259e-11, 0, 0, 0.999998, 628127e-11, 0, 0, 0.999996, 636451e-11, 0, 0, 0.999991, 65218e-10, 0, 0, 0.999984, 679782e-11, 0, 0, 0.999973, 726361e-11, 0, 0, 0.999955, 803644e-11, 0, 0, 0.999931, 931397e-11, 0, 0, 0.999896, 114299e-10, 0, 0, 0.999847, 149402e-10, 0, 0, 0.999784, 207461e-10, 0, 0, 0.999692, 302493e-10, 0, 0, 0.999554, 454957e-10, 0, 997275e-10, 0.999326, 690762e-10, 0, 724813e-9, 0.998757, 101605e-9, 0, 20972e-7, 0.995367, 958745e-10, 0, 432324e-8, 0.99209, 832808e-10, 0, 746347e-8, 0.989517, 887601e-10, 0, 0.0115534, 0.987008, 10564e-8, 0, 0.0166134, 0.98421, 133179e-9, 0, 0.0226552, 0.98021, 161746e-9, 0, 0.0296838, 0.973676, 161821e-9, 0, 0.0377016, 0.967052, 178635e-9, 0, 0.0467079, 0.959385, 206765e-9, 0, 0.0567013, 0.949461, 22476e-8, 0, 0.0676796, 0.939578, 23574e-8, 0, 0.0796403, 0.932416, 25893e-8, 0, 0.0925812, 0.923759, 271228e-9, 0, 0.106501, 0.914223, 289165e-9, 0, 0.121397, 0.902942, 301156e-9, 0, 0.13727, 0.890419, 313852e-9, 0, 0.15412, 0.876639, 324408e-9, 0, 0.171946, 0.861316, 33249e-8, 0, 0.190751, 0.84496, 338497e-9, 0, 0.210537, 0.828427, 345861e-9, 0, 0.231305, 0.811871, 347863e-9, 0, 0.253057, 0.794397, 350225e-9, 0, 0.275797, 0.775726, 349915e-9, 0, 0.299525, 0.75617, 347297e-9, 0, 0.324242, 0.736091, 344232e-9, 0, 0.349947, 0.716213, 340835e-9, 0, 0.376633, 0.695736, 332369e-9, 0, 0.404289, 0.674961, 327943e-9, 0, 0.432895, 0.653518, 318533e-9, 0, 0.462415, 0.632574, 310391e-9, 0, 0.492788, 0.61134, 300755e-9, 0, 0.523909, 0.590017, 290506e-9, 0, 0.555556, 0.568752, 280446e-9, 0, 0.587302, 0.548061, 269902e-9, 0, 0.619048, 0.52711, 258815e-9, 0, 0.650794, 0.506682, 248481e-9, 0, 0.68254, 0.486524, 237141e-9, 0, 0.714286, 0.466812, 226872e-9, 0, 0.746032, 0.44732, 216037e-9, 0, 0.777778, 0.428473, 205629e-9, 0, 0.809524, 0.409921, 195691e-9, 0, 0.84127, 0.392028, 185457e-9, 0, 0.873016, 0.374606, 176436e-9, 0, 0.904762, 0.357601, 166508e-9, 0, 0.936508, 0.341348, 158385e-9, 0, 0.968254, 0.32542, 149203e-9, 0, 1, 1, 103967e-10, 0, 0, 1, 10397e-9, 0, 0, 1, 104019e-10, 0, 0, 0.999999, 104231e-10, 0, 0, 0.999998, 104806e-10, 0, 0, 0.999995, 106042e-10, 0, 0, 0.999991, 108366e-10, 0, 0, 0.999982, 112415e-10, 0, 0, 0.999968, 119174e-10, 0, 0, 0.99995, 130227e-10, 0, 0, 0.999922, 148176e-10, 0, 0, 0.999884, 177303e-10, 0, 0, 0.99983, 224564e-10, 0, 0, 0.999758, 300966e-10, 0, 0, 0.999654, 423193e-10, 0, 549083e-11, 0.999503, 614848e-10, 0, 296087e-9, 0.999237, 903576e-10, 0, 123144e-8, 0.998491, 1271e-7, 0, 295954e-8, 0.994594, 107754e-9, 0, 555829e-8, 0.99178, 103025e-9, 0, 907209e-8, 0.989265, 11154e-8, 0, 0.0135257, 0.986998, 136296e-9, 0, 0.0189327, 0.984137, 169154e-9, 0, 0.0252993, 0.979798, 196671e-9, 0, 0.0326272, 0.97337, 196678e-9, 0, 0.0409157, 0.967239, 223121e-9, 0, 0.0501623, 0.959543, 253809e-9, 0, 0.0603638, 0.949466, 265972e-9, 0, 0.0715171, 0.939074, 288372e-9, 0, 0.0836187, 0.931118, 310983e-9, 0, 0.0966657, 0.922525, 325561e-9, 0, 0.110656, 0.912983, 345725e-9, 0, 0.125588, 0.901617, 3556e-7, 0, 0.141461, 0.889487, 374012e-9, 0, 0.158275, 0.875787, 383445e-9, 0, 0.176031, 0.860654, 393972e-9, 0, 0.19473, 0.844417, 400311e-9, 0, 0.214374, 0.82741, 405004e-9, 0, 0.234967, 0.810545, 407378e-9, 0, 0.256512, 0.793312, 407351e-9, 0, 0.279011, 0.774847, 406563e-9, 0, 0.302468, 0.755621, 404903e-9, 0, 0.326887, 0.735511, 397486e-9, 0, 0.352266, 0.715435, 39357e-8, 0, 0.378605, 0.695403, 384739e-9, 0, 0.405897, 0.674681, 376108e-9, 0, 0.43413, 0.65359, 365997e-9, 0, 0.463277, 0.632471, 354957e-9, 0, 0.493295, 0.61151, 343593e-9, 0, 0.524106, 0.59064, 331841e-9, 0, 0.555561, 0.569386, 318891e-9, 0, 0.587302, 0.548785, 3072e-7, 0, 0.619048, 0.528146, 29361e-8, 0, 0.650794, 0.507872, 281709e-9, 0, 0.68254, 0.487805, 268627e-9, 0, 0.714286, 0.468196, 255887e-9, 0, 0.746032, 0.448922, 243997e-9, 0, 0.777778, 0.430093, 231662e-9, 0, 0.809524, 0.411845, 220339e-9, 0, 0.84127, 0.393808, 208694e-9, 0, 0.873016, 0.376615, 198045e-9, 0, 0.904762, 0.359655, 187375e-9, 0, 0.936508, 0.343452, 177371e-9, 0, 0.968254, 0.32765, 167525e-9, 0, 1, 1, 169351e-10, 0, 0, 1, 169356e-10, 0, 0, 1, 169427e-10, 0, 0, 0.999999, 169736e-10, 0, 0, 0.999998, 170575e-10, 0, 0, 0.999995, 172372e-10, 0, 0, 0.99999, 175739e-10, 0, 0, 0.999979, 181568e-10, 0, 0, 0.999966, 191206e-10, 0, 0, 0.999944, 20677e-9, 0, 0, 0.999912, 231644e-10, 0, 0, 0.999869, 271268e-10, 0, 0, 0.999811, 334272e-10, 0, 0, 0.99973, 433979e-10, 0, 0, 0.999617, 590083e-10, 0, 680315e-10, 0.999445, 829497e-10, 0, 612796e-9, 0.999138, 118019e-9, 0, 187408e-8, 0.998095, 156712e-9, 0, 395791e-8, 0.993919, 125054e-9, 0, 692144e-8, 0.991333, 126091e-9, 0, 0.0107962, 0.989226, 144912e-9, 0, 0.0155986, 0.986954, 175737e-9, 0, 0.0213364, 0.983982, 213883e-9, 0, 0.0280114, 0.979128, 234526e-9, 0, 0.0356226, 0.973327, 243725e-9, 0, 0.0441668, 0.967416, 2773e-7, 0, 0.0536399, 0.959729, 308799e-9, 0, 0.0640376, 0.949758, 322447e-9, 0, 0.0753554, 0.939173, 350021e-9, 0, 0.0875893, 0.9296, 370089e-9, 0, 0.100736, 0.921181, 391365e-9, 0, 0.114793, 0.91164, 413636e-9, 0, 0.129759, 0.900435, 427068e-9, 0, 0.145632, 0.888183, 441046e-9, 0, 0.162412, 0.874772, 454968e-9, 0, 0.180101, 0.859566, 461882e-9, 0, 0.1987, 0.843579, 471556e-9, 0, 0.218213, 0.826453, 474335e-9, 0, 0.238641, 0.809164, 477078e-9, 0, 0.259989, 0.792179, 47755e-8, 0, 0.282262, 0.773866, 472573e-9, 0, 0.305464, 0.754944, 469765e-9, 0, 0.329599, 0.735133, 462371e-9, 0, 0.35467, 0.714858, 453674e-9, 0, 0.380678, 0.694829, 443888e-9, 0, 0.407622, 0.674453, 432052e-9, 0, 0.435493, 0.653685, 420315e-9, 0, 0.464275, 0.632666, 406829e-9, 0, 0.493938, 0.611676, 392234e-9, 0, 0.524422, 0.591193, 379208e-9, 0, 0.555624, 0.570145, 36319e-8, 0, 0.587302, 0.549566, 349111e-9, 0, 0.619048, 0.529278, 334166e-9, 0, 0.650794, 0.509026, 318456e-9, 0, 0.68254, 0.489186, 30449e-8, 0, 0.714286, 0.469662, 289051e-9, 0, 0.746032, 0.450691, 275494e-9, 0, 0.777778, 0.431841, 261437e-9, 0, 0.809524, 0.413752, 247846e-9, 0, 0.84127, 0.395951, 235085e-9, 0, 0.873016, 0.378633, 222245e-9, 0, 0.904762, 0.36194, 210533e-9, 0, 0.936508, 0.345599, 198494e-9, 0, 0.968254, 0.329999, 188133e-9, 0, 1, 1, 269663e-10, 0, 0, 1, 26967e-9, 0, 0, 1, 269772e-10, 0, 0, 0.999999, 270214e-10, 0, 0, 0.999998, 271415e-10, 0, 0, 0.999994, 27398e-9, 0, 0, 0.999988, 278771e-10, 0, 0, 0.999977, 287019e-10, 0, 0, 0.999961, 300544e-10, 0, 0, 0.999937, 322138e-10, 0, 0, 0.999904, 356163e-10, 0, 0, 0.999854, 409465e-10, 0, 0, 0.99979, 492651e-10, 0, 0, 0.999699, 621722e-10, 0, 88288e-11, 0.999572, 819715e-10, 0, 223369e-9, 0.999381, 111689e-9, 0, 105414e-8, 0.999016, 153862e-9, 0, 26493e-7, 0.997437, 187667e-9, 0, 508608e-8, 0.993545, 155672e-9, 0, 840554e-8, 0.991135, 161455e-9, 0, 0.012629, 0.989157, 188241e-9, 0, 0.0177661, 0.986874, 226229e-9, 0, 0.0238198, 0.983714, 268668e-9, 0, 0.0307887, 0.978301, 277109e-9, 0, 0.0386688, 0.973227, 303446e-9, 0, 0.0474554, 0.967317, 341851e-9, 0, 0.0571428, 0.959477, 370885e-9, 0, 0.0677256, 0.950012, 392753e-9, 0, 0.0791988, 0.939484, 42781e-8, 0, 0.0915576, 0.928135, 443866e-9, 0, 0.104798, 0.919819, 472959e-9, 0, 0.118918, 0.910049, 491551e-9, 0, 0.133915, 0.899181, 512616e-9, 0, 0.149788, 0.886881, 523563e-9, 0, 0.166537, 0.87359, 540183e-9, 0, 0.184164, 0.858613, 547386e-9, 0, 0.202669, 0.842809, 554809e-9, 0, 0.222056, 0.825727, 558316e-9, 0, 0.242329, 0.808086, 557824e-9, 0, 0.263492, 0.790728, 556346e-9, 0, 0.285551, 0.772987, 552672e-9, 0, 0.30851, 0.7541, 543738e-9, 0, 0.332376, 0.734669, 536107e-9, 0, 0.357153, 0.714411, 523342e-9, 0, 0.382845, 0.694196, 512238e-9, 0, 0.409454, 0.674252, 497465e-9, 0, 0.436977, 0.65357, 481096e-9, 0, 0.465404, 0.632999, 467054e-9, 0, 0.494713, 0.611994, 448771e-9, 0, 0.524864, 0.591604, 431889e-9, 0, 0.555779, 0.571134, 415238e-9, 0, 0.587302, 0.550528, 396369e-9, 0, 0.619048, 0.530292, 379477e-9, 0, 0.650794, 0.510364, 361488e-9, 0, 0.68254, 0.490749, 343787e-9, 0, 0.714286, 0.471266, 327822e-9, 0, 0.746032, 0.452462, 310626e-9, 0, 0.777778, 0.433907, 295352e-9, 0, 0.809524, 0.415659, 279179e-9, 0, 0.84127, 0.398138, 264685e-9, 0, 0.873016, 0.380833, 249905e-9, 0, 0.904762, 0.364247, 236282e-9, 0, 0.936508, 0.348041, 222905e-9, 0, 0.968254, 0.332389, 210522e-9, 0, 1, 1, 420604e-10, 0, 0, 1, 420614e-10, 0, 0, 1, 420757e-10, 0, 0, 0.999999, 42138e-9, 0, 0, 0.999997, 423067e-10, 0, 0, 0.999993, 426668e-10, 0, 0, 0.999986, 433372e-10, 0, 0, 0.999974, 444857e-10, 0, 0, 0.999956, 463554e-10, 0, 0, 0.99993, 493105e-10, 0, 0, 0.999892, 539077e-10, 0, 0, 0.999838, 610005e-10, 0, 0, 0.999767, 718822e-10, 0, 0, 0.999666, 884581e-10, 0, 365471e-10, 0.999525, 113398e-9, 0, 485623e-9, 0.999311, 150043e-9, 0, 162096e-8, 0.998865, 200063e-9, 0, 355319e-8, 0.996278, 211014e-9, 0, 633818e-8, 0.992956, 189672e-9, 0, 0.0100043, 0.991017, 210262e-9, 0, 0.0145648, 0.989055, 244292e-9, 0, 0.0200237, 0.986741, 290481e-9, 0, 0.0263798, 0.983288, 334303e-9, 0, 0.033629, 0.977784, 340307e-9, 0, 0.0417652, 0.973037, 377864e-9, 0, 0.0507821, 0.967181, 4239e-7, 0, 0.060673, 0.958971, 443854e-9, 0, 0.0714314, 0.950093, 483039e-9, 0, 0.0830518, 0.939552, 517934e-9, 0, 0.0955288, 0.927678, 539449e-9, 0, 0.108859, 0.918278, 568604e-9, 0, 0.123038, 0.908449, 588505e-9, 0, 0.138065, 0.897713, 612473e-9, 0, 0.153938, 0.885533, 625575e-9, 0, 0.170657, 0.872131, 63854e-8, 0, 0.188224, 0.857517, 647034e-9, 0, 0.20664, 0.841796, 65209e-8, 0, 0.225909, 0.824726, 6544e-7, 0, 0.246035, 0.807297, 655744e-9, 0, 0.267022, 0.789058, 646716e-9, 0, 0.288878, 0.77189, 643898e-9, 0, 0.311607, 0.753082, 629973e-9, 0, 0.335216, 0.7341, 621564e-9, 0, 0.359713, 0.714094, 605171e-9, 0, 0.385103, 0.693839, 588752e-9, 0, 0.41139, 0.673891, 573294e-9, 0, 0.438576, 0.653565, 552682e-9, 0, 0.466656, 0.633326, 533446e-9, 0, 0.495617, 0.612582, 514635e-9, 0, 0.525431, 0.59205, 49303e-8, 0, 0.556041, 0.571918, 471842e-9, 0, 0.587338, 0.551572, 451713e-9, 0, 0.619048, 0.531553, 430049e-9, 0, 0.650794, 0.51175, 410445e-9, 0, 0.68254, 0.49238, 390098e-9, 0, 0.714286, 0.473143, 370033e-9, 0, 0.746032, 0.45423, 351205e-9, 0, 0.777778, 0.435963, 332049e-9, 0, 0.809524, 0.41787, 315021e-9, 0, 0.84127, 0.400387, 297315e-9, 0, 0.873016, 0.383332, 281385e-9, 0, 0.904762, 0.366665, 265397e-9, 0, 0.936508, 0.350633, 250601e-9, 0, 0.968254, 0.334964, 23589e-8, 0, 1, 1, 643736e-10, 0, 0, 1, 64375e-9, 0, 0, 1, 643947e-10, 0, 0, 0.999999, 64481e-9, 0, 0, 0.999997, 647143e-10, 0, 0, 0.999994, 652119e-10, 0, 0, 0.999985, 661359e-10, 0, 0, 0.999972, 677116e-10, 0, 0, 0.999952, 702599e-10, 0, 0, 0.999922, 742517e-10, 0, 0, 0.99988, 803906e-10, 0, 0, 0.99982, 897315e-10, 0, 0, 0.999741, 103838e-9, 0, 0, 0.999629, 12496e-8, 0, 149024e-9, 0.999474, 156161e-9, 0, 861027e-9, 0.999229, 201034e-9, 0, 231198e-8, 0.998662, 259069e-9, 0, 458147e-8, 0.995299, 245439e-9, 0, 770895e-8, 0.992732, 24498e-8, 0, 0.0117126, 0.990847, 273211e-9, 0, 0.0165989, 0.988911, 316492e-9, 0, 0.0223674, 0.98654, 37161e-8, 0, 0.0290135, 0.982636, 410352e-9, 0, 0.0365309, 0.977346, 421756e-9, 0, 0.0449117, 0.972909, 475578e-9, 0, 0.0541481, 0.966821, 522482e-9, 0, 0.0642326, 0.958686, 545008e-9, 0, 0.075158, 0.949754, 589286e-9, 0, 0.0869181, 0.939184, 619995e-9, 0, 0.0995074, 0.927505, 654266e-9, 0, 0.112922, 0.916606, 682362e-9, 0, 0.127157, 0.906707, 704286e-9, 0, 0.142212, 0.895937, 725909e-9, 0, 0.158085, 0.883913, 743939e-9, 0, 0.174776, 0.870642, 755157e-9, 0, 0.192287, 0.856241, 764387e-9, 0, 0.210619, 0.84069, 771032e-9, 0, 0.229775, 0.823728, 765906e-9, 0, 0.249761, 0.806481, 767604e-9, 0, 0.270582, 0.787924, 754385e-9, 0, 0.292243, 0.770588, 749668e-9, 0, 0.314753, 0.751991, 731613e-9, 0, 0.338118, 0.733407, 717655e-9, 0, 0.362347, 0.713688, 700604e-9, 0, 0.387447, 0.693595, 678765e-9, 0, 0.413424, 0.673426, 657042e-9, 0, 0.440284, 0.65359, 635892e-9, 0, 0.468027, 0.633576, 611569e-9, 0, 0.496645, 0.613144, 586011e-9, 0, 0.526122, 0.592711, 563111e-9, 0, 0.556417, 0.572722, 537699e-9, 0, 0.587451, 0.552762, 512556e-9, 0, 0.619048, 0.532985, 489757e-9, 0, 0.650794, 0.513219, 464139e-9, 0, 0.68254, 0.493992, 442193e-9, 0, 0.714286, 0.47509, 418629e-9, 0, 0.746032, 0.456287, 397045e-9, 0, 0.777778, 0.438152, 375504e-9, 0, 0.809524, 0.420294, 35492e-8, 0, 0.84127, 0.402749, 335327e-9, 0, 0.873016, 0.385879, 316422e-9, 0, 0.904762, 0.369352, 298333e-9, 0, 0.936508, 0.353301, 281417e-9, 0, 0.968254, 0.337781, 265203e-9, 0, 1, 1, 968267e-10, 0, 0, 1, 968284e-10, 0, 0, 1, 968556e-10, 0, 0, 0.999999, 969733e-10, 0, 0, 0.999997, 972913e-10, 0, 0, 0.999993, 979688e-10, 0, 0, 0.999984, 992239e-10, 0, 0, 0.999969, 101356e-9, 0, 0, 0.999946, 104784e-9, 0, 0, 0.999913, 110111e-9, 0, 0, 0.999868, 118217e-9, 0, 0, 0.999801, 130396e-9, 0, 0, 0.999712, 148523e-9, 0, 124907e-10, 0.999589, 175233e-9, 0, 355405e-9, 0.999416, 213999e-9, 0, 13528e-7, 0.999136, 268529e-9, 0, 312557e-8, 0.998367, 333088e-9, 0, 573045e-8, 0.994701, 304757e-9, 0, 919397e-8, 0.992497, 318031e-9, 0, 0.0135261, 0.990608, 353863e-9, 0, 0.0187278, 0.988715, 409044e-9, 0, 0.0247947, 0.986241, 472967e-9, 0, 0.0317196, 0.981696, 495104e-9, 0, 0.039494, 0.977097, 532873e-9, 0, 0.0481087, 0.972583, 594447e-9, 0, 0.0575549, 0.966142, 636867e-9, 0, 0.0678242, 0.95823, 669899e-9, 0, 0.0789089, 0.949677, 719499e-9, 0, 0.0908023, 0.939226, 750584e-9, 0, 0.103499, 0.927501, 793183e-9, 0, 0.116993, 0.915199, 81995e-8, 0, 0.131282, 0.90498, 847654e-9, 0, 0.146364, 0.894243, 868929e-9, 0, 0.162237, 0.882154, 884278e-9, 0, 0.178902, 0.869161, 898108e-9, 0, 0.196358, 0.854751, 901254e-9, 0, 0.21461, 0.839368, 90679e-8, 0, 0.23366, 0.822874, 901541e-9, 0, 0.253512, 0.805514, 897297e-9, 0, 0.274174, 0.78716, 881856e-9, 0, 0.29565, 0.769061, 870032e-9, 0, 0.31795, 0.751, 851719e-9, 0, 0.341081, 0.732614, 830671e-9, 0, 0.365053, 0.713171, 806569e-9, 0, 0.389874, 0.693472, 78338e-8, 0, 0.415553, 0.673528, 756404e-9, 0, 0.442098, 0.653397, 726872e-9, 0, 0.469512, 0.633781, 700494e-9, 0, 0.497794, 0.613877, 67105e-8, 0, 0.526935, 0.593506, 640361e-9, 0, 0.556908, 0.573667, 613502e-9, 0, 0.587657, 0.553932, 583177e-9, 0, 0.61906, 0.534345, 554375e-9, 0, 0.650794, 0.515042, 527811e-9, 0, 0.68254, 0.495674, 499367e-9, 0, 0.714286, 0.477132, 47429e-8, 0, 0.746032, 0.458609, 447726e-9, 0, 0.777778, 0.440354, 424205e-9, 0, 0.809524, 0.422765, 399549e-9, 0, 0.84127, 0.405472, 378315e-9, 0, 0.873016, 0.388482, 355327e-9, 0, 0.904762, 0.372191, 336122e-9, 0, 0.936508, 0.356099, 315247e-9, 0, 0.968254, 0.340737, 29794e-8, 0, 1, 1, 143327e-9, 0, 0, 1, 14333e-8, 0, 0, 1, 143366e-9, 0, 0, 0.999999, 143524e-9, 0, 0, 0.999996, 143952e-9, 0, 0, 0.999991, 144862e-9, 0, 0, 0.999981, 146544e-9, 0, 0, 0.999966, 149391e-9, 0, 0, 0.999941, 153946e-9, 0, 0, 0.999905, 160971e-9, 0, 0, 0.999852, 171562e-9, 0, 0, 0.99978, 18729e-8, 0, 0, 0.999681, 210386e-9, 0, 826239e-10, 0.999546, 243906e-9, 0, 664807e-9, 0.999352, 291739e-9, 0, 196192e-8, 0.999027, 357419e-9, 0, 405941e-8, 0.997886, 422349e-9, 0, 699664e-8, 0.99419, 385008e-9, 0, 0.0107896, 0.99214, 409775e-9, 0, 0.0154415, 0.990274, 456418e-9, 0, 0.0209488, 0.988455, 527008e-9, 0, 0.0273037, 0.985804, 597685e-9, 0, 0.0344969, 0.98103, 613124e-9, 0, 0.0425183, 0.976674, 668321e-9, 0, 0.0513575, 0.972021, 736985e-9, 0, 0.0610046, 0.965274, 773789e-9, 0, 0.0714508, 0.958046, 830852e-9, 0, 0.0826877, 0.949333, 875766e-9, 0, 0.0947085, 0.939135, 917088e-9, 0, 0.107507, 0.927119, 952244e-9, 0, 0.121078, 0.91469, 990626e-9, 0, 0.135419, 0.903006, 101304e-8, 0, 0.150526, 0.892368, 103834e-8, 0, 0.166399, 0.880231, 105002e-8, 0, 0.183038, 0.867432, 106331e-8, 0, 0.200443, 0.853208, 106783e-8, 0, 0.218618, 0.837956, 106458e-8, 0, 0.237566, 0.821772, 105945e-8, 0, 0.257291, 0.804328, 104685e-8, 0, 0.2778, 0.786465, 103178e-8, 0, 0.2991, 0.768004, 101077e-8, 0, 0.321199, 0.74972, 985504e-9, 0, 0.344106, 0.731682, 962893e-9, 0, 0.36783, 0.712813, 932146e-9, 0, 0.392383, 0.693139, 89871e-8, 0, 0.417774, 0.673566, 869678e-9, 0, 0.444013, 0.653483, 835525e-9, 0, 0.471107, 0.633891, 799853e-9, 0, 0.49906, 0.614433, 766838e-9, 0, 0.527869, 0.594586, 732227e-9, 0, 0.557517, 0.574769, 696442e-9, 0, 0.587966, 0.555149, 663935e-9, 0, 0.61913, 0.535898, 629826e-9, 0, 0.650794, 0.516753, 596486e-9, 0, 0.68254, 0.497816, 567078e-9, 0, 0.714286, 0.479034, 534399e-9, 0, 0.746032, 0.460975, 507013e-9, 0, 0.777778, 0.442935, 477421e-9, 0, 0.809524, 0.425263, 451101e-9, 0, 0.84127, 0.408248, 424964e-9, 0, 0.873016, 0.391339, 39993e-8, 0, 0.904762, 0.37513, 377619e-9, 0, 0.936508, 0.359172, 354418e-9, 0, 0.968254, 0.343876, 334823e-9, 0, 1, 1, 209042e-9, 0, 0, 1, 209045e-9, 0, 0, 1, 209093e-9, 0, 0, 0.999999, 209304e-9, 0, 0, 0.999996, 209871e-9, 0, 0, 0.999991, 211078e-9, 0, 0, 0.999979, 213304e-9, 0, 0, 0.999963, 217061e-9, 0, 0, 0.999933, 223042e-9, 0, 0, 0.999894, 232206e-9, 0, 0, 0.999837, 245901e-9, 0, 0, 0.999756, 266023e-9, 0, 102927e-11, 0.999648, 295204e-9, 0, 233468e-9, 0.999499, 336958e-9, 0, 108237e-8, 0.999283, 395563e-9, 0, 268832e-8, 0.998896, 473785e-9, 0, 511138e-8, 0.997006, 520008e-9, 0, 837705e-8, 0.993819, 497261e-9, 0, 0.0124928, 0.991632, 523722e-9, 0, 0.0174561, 0.989875, 587258e-9, 0, 0.0232596, 0.988109, 676329e-9, 0, 0.0298932, 0.985155, 747701e-9, 0, 0.0373453, 0.980479, 768803e-9, 0, 0.0456045, 0.976271, 841054e-9, 0, 0.0546593, 0.971347, 911469e-9, 0, 0.0644994, 0.964528, 953057e-9, 0, 0.0751152, 0.957632, 102221e-8, 0, 0.0864981, 0.948681, 106122e-8, 0, 0.0986407, 0.938716, 111857e-8, 0, 0.111537, 0.926629, 114762e-8, 0, 0.125182, 0.914025, 118995e-8, 0, 0.139571, 0.901026, 121228e-8, 0, 0.154703, 0.890358, 123946e-8, 0, 0.170576, 0.878283, 12527e-7, 0, 0.18719, 0.865459, 125536e-8, 0, 0.204547, 0.851407, 126134e-8, 0, 0.222648, 0.836276, 124759e-8, 0, 0.241498, 0.820436, 124443e-8, 0, 0.261101, 0.803253, 122071e-8, 0, 0.281465, 0.785562, 120107e-8, 0, 0.302595, 0.76718, 117762e-8, 0, 0.324501, 0.748551, 114289e-8, 0, 0.347192, 0.730564, 110872e-8, 0, 0.370679, 0.712253, 107636e-8, 0, 0.394973, 0.692867, 103646e-8, 0, 0.420085, 0.673695, 996793e-9, 0, 0.446027, 0.653912, 95675e-8, 0, 0.47281, 0.634129, 916739e-9, 0, 0.500441, 0.615004, 874401e-9, 0, 0.528921, 0.595587, 833411e-9, 0, 0.558244, 0.575965, 794556e-9, 0, 0.588384, 0.5566, 75196e-8, 0, 0.619281, 0.537428, 716381e-9, 0, 0.650795, 0.518623, 676558e-9, 0, 0.68254, 0.499964, 64074e-8, 0, 0.714286, 0.481356, 605984e-9, 0, 0.746032, 0.463279, 570256e-9, 0, 0.777778, 0.445673, 540138e-9, 0, 0.809524, 0.428032, 507299e-9, 0, 0.84127, 0.411112, 479553e-9, 0, 0.873016, 0.394444, 450737e-9, 0, 0.904762, 0.378247, 424269e-9, 0, 0.936508, 0.362415, 399111e-9, 0, 0.968254, 0.347103, 375274e-9, 0, 1, 1, 300729e-9, 0, 0, 1, 300733e-9, 0, 0, 1, 300797e-9, 0, 0, 0.999998, 301072e-9, 0, 0, 0.999996, 301817e-9, 0, 0, 0.999989, 303398e-9, 0, 0, 0.999977, 306309e-9, 0, 0, 0.999958, 311209e-9, 0, 0, 0.999927, 318975e-9, 0, 0, 0.999884, 330804e-9, 0, 0, 0.99982, 34834e-8, 0, 0, 0.999733, 373854e-9, 0, 326995e-10, 0.999613, 410424e-9, 0, 477174e-9, 0.999447, 462047e-9, 0, 161099e-8, 0.999204, 533322e-9, 0, 353153e-8, 0.998725, 624964e-9, 0, 627965e-8, 0.995871, 631786e-9, 0, 98693e-7, 0.993194, 632017e-9, 0, 0.0143011, 0.991541, 68923e-8, 0, 0.019568, 0.989773, 766892e-9, 0, 0.0256593, 0.987647, 863668e-9, 0, 0.0325625, 0.984193, 922089e-9, 0, 0.0402647, 0.980016, 970749e-9, 0, 0.0487532, 0.975859, 106027e-8, 0, 0.058016, 0.970514, 112239e-8, 0, 0.0680419, 0.963625, 117212e-8, 0, 0.0788208, 0.956959, 125211e-8, 0, 0.0903439, 0.947956, 129411e-8, 0, 0.102604, 0.93809, 135879e-8, 0, 0.115594, 0.92659, 139309e-8, 0, 0.129309, 0.913829, 143253e-8, 0, 0.143745, 0.90005, 145809e-8, 0, 0.158901, 0.888129, 14748e-7, 0, 0.174774, 0.87607, 148756e-8, 0, 0.191365, 0.863461, 148714e-8, 0, 0.208674, 0.849594, 148892e-8, 0, 0.226705, 0.834531, 146496e-8, 0, 0.245461, 0.81903, 14579e-7, 0, 0.264947, 0.802122, 143039e-8, 0, 0.28517, 0.78445, 139717e-8, 0, 0.306137, 0.766434, 136312e-8, 0, 0.327857, 0.747816, 132597e-8, 0, 0.350341, 0.729519, 128323e-8, 0, 0.373598, 0.711454, 123803e-8, 0, 0.397642, 0.692699, 119097e-8, 0, 0.422485, 0.673723, 114565e-8, 0, 0.448139, 0.654386, 109552e-8, 0, 0.474619, 0.634673, 104553e-8, 0, 0.501933, 0.615554, 99985e-8, 0, 0.530089, 0.596462, 948207e-9, 0, 0.559087, 0.577385, 902299e-9, 0, 0.588913, 0.558257, 856448e-9, 0, 0.619525, 0.5392, 810395e-9, 0, 0.650826, 0.520543, 768558e-9, 0, 0.68254, 0.502206, 7239e-7, 0, 0.714286, 0.48402, 685794e-9, 0, 0.746032, 0.465779, 64471e-8, 0, 0.777778, 0.448455, 609583e-9, 0, 0.809524, 0.431091, 57227e-8, 0, 0.84127, 0.414147, 54042e-8, 0, 0.873016, 0.39765, 506545e-9, 0, 0.904762, 0.381576, 477635e-9, 0, 0.936508, 0.365881, 448446e-9, 0, 0.968254, 0.350582, 421424e-9, 0, 1, 1, 427144e-9, 0, 0, 1, 427151e-9, 0, 0, 1, 427232e-9, 0, 0, 0.999998, 42759e-8, 0, 0, 0.999995, 428555e-9, 0, 0, 0.999988, 430603e-9, 0, 0, 0.999976, 434368e-9, 0, 0, 0.999952, 440688e-9, 0, 0, 0.999919, 450667e-9, 0, 0, 0.999871, 46578e-8, 0, 0, 0.999801, 488024e-9, 0, 0, 0.999704, 520092e-9, 0, 129791e-9, 0.999572, 565553e-9, 0, 821056e-9, 0.999389, 628906e-9, 0, 225241e-8, 0.999114, 714911e-9, 0, 449109e-8, 0.998488, 819218e-9, 0, 756249e-8, 0.995234, 80415e-8, 0, 0.0114716, 0.993021, 830181e-9, 0, 0.0162131, 0.991407, 902645e-9, 0, 0.021776, 0.989625, 996934e-9, 0, 0.0281471, 0.987064, 109707e-8, 0, 0.0353118, 0.983265, 114353e-8, 0, 0.0432562, 0.979535, 12272e-7, 0, 0.0519665, 0.975224, 132642e-8, 0, 0.0614298, 0.969574, 138092e-8, 0, 0.0716348, 0.963021, 145896e-8, 0, 0.0825709, 0.956046, 152834e-8, 0, 0.094229, 0.947136, 158217e-8, 0, 0.106602, 0.937313, 16347e-7, 0, 0.119682, 0.926073, 168383e-8, 0, 0.133465, 0.913121, 171627e-8, 0, 0.147947, 0.899165, 174229e-8, 0, 0.163125, 0.885891, 176137e-8, 0, 0.178998, 0.873783, 176406e-8, 0, 0.195566, 0.861331, 176156e-8, 0, 0.21283, 0.847569, 175346e-8, 0, 0.230793, 0.832785, 172753e-8, 0, 0.249459, 0.817442, 170204e-8, 0, 0.268832, 0.800613, 166576e-8, 0, 0.28892, 0.783597, 162909e-8, 0, 0.30973, 0.76571, 15826e-7, 0, 0.331271, 0.747021, 153106e-8, 0, 0.353554, 0.728593, 148036e-8, 0, 0.37659, 0.710661, 142808e-8, 0, 0.400391, 0.692426, 136906e-8, 0, 0.424973, 0.673623, 131066e-8, 0, 0.450347, 0.65494, 125569e-8, 0, 0.476531, 0.635448, 119517e-8, 0, 0.503535, 0.616221, 113828e-8, 0, 0.531372, 0.597531, 10816e-7, 0, 0.560047, 0.578795, 102673e-8, 0, 0.589554, 0.559892, 970985e-9, 0, 0.619869, 0.541307, 919773e-9, 0, 0.650923, 0.522608, 868479e-9, 0, 0.68254, 0.504484, 82137e-8, 0, 0.714286, 0.486603, 772916e-9, 0, 0.746032, 0.468802, 730353e-9, 0, 0.777778, 0.451172, 684955e-9, 0, 0.809524, 0.434348, 647565e-9, 0, 0.84127, 0.417445, 605863e-9, 0, 0.873016, 0.401077, 571885e-9, 0, 0.904762, 0.385039, 536034e-9, 0, 0.936508, 0.369483, 504227e-9, 0, 0.968254, 0.354272, 473165e-9, 0, 1, 1, 599525e-9, 0, 0, 1, 599533e-9, 0, 0, 1, 599639e-9, 0, 0, 0.999998, 600097e-9, 0, 0, 0.999994, 601336e-9, 0, 0, 0.999987, 603958e-9, 0, 0, 0.999972, 608775e-9, 0, 0, 0.999949, 616842e-9, 0, 0, 0.999912, 629534e-9, 0, 0, 0.999857, 648658e-9, 0, 0, 0.999781, 676615e-9, 0, 538873e-11, 0.999674, 716574e-9, 0, 308602e-9, 0.999528, 772641e-9, 0, 127003e-8, 0.999326, 849806e-9, 0, 300783e-8, 0.999009, 952682e-9, 0, 556637e-8, 0.998112, 106394e-8, 0, 895889e-8, 0.994496, 102228e-8, 0, 0.0131827, 0.992806, 108586e-8, 0, 0.0182277, 0.991211, 11759e-7, 0, 0.0240795, 0.989415, 128955e-8, 0, 0.030723, 0.986499, 139038e-8, 0, 0.0381418, 0.982679, 144539e-8, 0, 0.046321, 0.978839, 153954e-8, 0, 0.0552459, 0.974295, 164417e-8, 0, 0.0649034, 0.968784, 171517e-8, 0, 0.0752814, 0.962324, 180282e-8, 0, 0.0863693, 0.954956, 186387e-8, 0, 0.0981578, 0.94624, 193817e-8, 0, 0.110639, 0.936517, 198156e-8, 0, 0.123806, 0.925186, 203042e-8, 0, 0.137655, 0.91252, 20664e-7, 0, 0.15218, 0.898441, 207822e-8, 0, 0.16738, 0.884394, 20992e-7, 0, 0.183253, 0.871273, 208748e-8, 0, 0.199799, 0.859057, 208686e-8, 0, 0.21702, 0.845243, 205519e-8, 0, 0.234918, 0.830723, 202868e-8, 0, 0.253496, 0.815801, 199501e-8, 0, 0.272761, 0.79914, 194193e-8, 0, 0.292719, 0.782372, 188824e-8, 0, 0.313377, 0.76482, 183695e-8, 0, 0.334745, 0.746586, 177418e-8, 0, 0.356833, 0.7281, 170628e-8, 0, 0.379654, 0.709842, 164063e-8, 0, 0.403221, 0.692019, 157355e-8, 0, 0.427548, 0.67364, 150262e-8, 0, 0.452651, 0.655277, 143473e-8, 0, 0.478545, 0.636438, 136371e-8, 0, 0.505246, 0.617364, 129911e-8, 0, 0.532768, 0.598603, 123014e-8, 0, 0.561122, 0.580195, 116587e-8, 0, 0.590309, 0.561786, 110398e-8, 0, 0.620318, 0.543377, 104148e-8, 0, 0.651102, 0.525093, 983984e-9, 0, 0.682545, 0.506791, 92667e-8, 0, 0.714286, 0.489291, 874326e-9, 0, 0.746032, 0.471811, 821734e-9, 0, 0.777778, 0.454435, 774698e-9, 0, 0.809524, 0.437493, 727302e-9, 0, 0.84127, 0.420977, 684039e-9, 0, 0.873016, 0.404729, 64373e-8, 0, 0.904762, 0.388756, 60285e-8, 0, 0.936508, 0.373344, 56765e-8, 0, 0.968254, 0.358191, 531929e-9, 0, 1, 1, 832169e-9, 0, 0, 1, 832178e-9, 0, 0, 1, 83231e-8, 0, 0, 0.999998, 832893e-9, 0, 0, 0.999995, 834465e-9, 0, 0, 0.999985, 837791e-9, 0, 0, 0.999969, 843893e-9, 0, 0, 0.999944, 854086e-9, 0, 0, 0.999903, 870071e-9, 0, 0, 0.999843, 894042e-9, 0, 0, 0.999759, 928865e-9, 0, 531805e-10, 0.999643, 978242e-9, 0, 579365e-9, 0.99948, 104684e-8, 0, 182774e-8, 0.999255, 114012e-8, 0, 387804e-8, 0.998885, 126188e-8, 0, 675709e-8, 0.997405, 135888e-8, 0, 0.010468, 0.99424, 133626e-8, 0, 0.0150018, 0.992458, 140905e-8, 0, 0.0203443, 0.990929, 152305e-8, 0, 0.0264786, 0.989116, 165882e-8, 0, 0.0333875, 0.985624, 174128e-8, 0, 0.0410536, 0.982003, 182108e-8, 0, 0.0494609, 0.978336, 194498e-8, 0, 0.0585941, 0.973184, 202708e-8, 0, 0.0684396, 0.9678, 212166e-8, 0, 0.0789851, 0.961348, 221366e-8, 0, 0.0902199, 0.953841, 228219e-8, 0, 0.102134, 0.94534, 235662e-8, 0, 0.114721, 0.935552, 240572e-8, 0, 0.127972, 0.924064, 244405e-8, 0, 0.141884, 0.911827, 247557e-8, 0, 0.156451, 0.897731, 248374e-8, 0, 0.171672, 0.883409, 249863e-8, 0, 0.187545, 0.868625, 246688e-8, 0, 0.20407, 0.856529, 246523e-8, 0, 0.221249, 0.842999, 242368e-8, 0, 0.239083, 0.828505, 237354e-8, 0, 0.257578, 0.813825, 232588e-8, 0, 0.276738, 0.797813, 226731e-8, 0, 0.296569, 0.781097, 219704e-8, 0, 0.31708, 0.764038, 212394e-8, 0, 0.338281, 0.746067, 204786e-8, 0, 0.360181, 0.727687, 196728e-8, 0, 0.382794, 0.709571, 188779e-8, 0, 0.406133, 0.691503, 180532e-8, 0, 0.430213, 0.673673, 171849e-8, 0, 0.45505, 0.655732, 164147e-8, 0, 0.480662, 0.637399, 155858e-8, 0, 0.507065, 0.618616, 147641e-8, 0, 0.534278, 0.60005, 140125e-8, 0, 0.562313, 0.581713, 132441e-8, 0, 0.59118, 0.563546, 125014e-8, 0, 0.620875, 0.545605, 118249e-8, 0, 0.651373, 0.527559, 11116e-7, 0, 0.682593, 0.509764, 104979e-8, 0, 0.714286, 0.49193, 985977e-9, 0, 0.746032, 0.475011, 928592e-9, 0, 0.777778, 0.457878, 873466e-9, 0, 0.809524, 0.440979, 819585e-9, 0, 0.84127, 0.424613, 772365e-9, 0, 0.873016, 0.408549, 722195e-9, 0, 0.904762, 0.392771, 680014e-9, 0, 0.936508, 0.377317, 636797e-9, 0, 0.968254, 0.362352, 598318e-9, 0, 1, 1, 114313e-8, 0, 0, 1, 114314e-8, 0, 0, 0.999999, 114331e-8, 0, 0, 0.999998, 114404e-8, 0, 0, 0.999994, 114601e-8, 0, 0, 0.999984, 115019e-8, 0, 0, 0.999967, 115784e-8, 0, 0, 0.999937, 11706e-7, 0, 0, 0.999894, 119054e-8, 0, 0, 0.999828, 122031e-8, 0, 0, 0.999735, 126331e-8, 0, 169263e-9, 0.999606, 132382e-8, 0, 949167e-9, 0.999426, 14071e-7, 0, 249668e-8, 0.999173, 151895e-8, 0, 486392e-8, 0.99873, 166102e-8, 0, 806323e-8, 0.996243, 17023e-7, 0, 0.0120895, 0.993779, 172782e-8, 0, 0.0169288, 0.9919, 18108e-7, 0, 0.0225633, 0.990524, 196028e-8, 0, 0.028974, 0.98868, 212014e-8, 0, 0.036142, 0.984663, 217598e-8, 0, 0.044049, 0.981457, 230563e-8, 0, 0.0526781, 0.977608, 243966e-8, 0, 0.0620137, 0.972215, 251336e-8, 0, 0.0720418, 0.966798, 26285e-7, 0, 0.0827499, 0.960241, 271409e-8, 0, 0.0941271, 0.952489, 278381e-8, 0, 0.106164, 0.944127, 285399e-8, 0, 0.118852, 0.934282, 290994e-8, 0, 0.132185, 0.923271, 294558e-8, 0, 0.146157, 0.910803, 296269e-8, 0, 0.160766, 0.896705, 296803e-8, 0, 0.176007, 0.88238, 296637e-8, 0, 0.19188, 0.867116, 293163e-8, 0, 0.208385, 0.853636, 289418e-8, 0, 0.225523, 0.840469, 284663e-8, 0, 0.243296, 0.82639, 278594e-8, 0, 0.261709, 0.811759, 271618e-8, 0, 0.280767, 0.796113, 263187e-8, 0, 0.300476, 0.779518, 254589e-8, 0, 0.320845, 0.763142, 246003e-8, 0, 0.341883, 0.745464, 236529e-8, 0, 0.363601, 0.727491, 226536e-8, 0, 0.386011, 0.709414, 216375e-8, 0, 0.409128, 0.691396, 207127e-8, 0, 0.432967, 0.67368, 197106e-8, 0, 0.457545, 0.656049, 187022e-8, 0, 0.482881, 0.638188, 177605e-8, 0, 0.508992, 0.620177, 168482e-8, 0, 0.535899, 0.601506, 158909e-8, 0, 0.563619, 0.58362, 150583e-8, 0, 0.592165, 0.565496, 141791e-8, 0, 0.621544, 0.54789, 133693e-8, 0, 0.651743, 0.530323, 126038e-8, 0, 0.682709, 0.512795, 118556e-8, 0, 0.714286, 0.495199, 111527e-8, 0, 0.746032, 0.478101, 10489e-7, 0, 0.777778, 0.461511, 984264e-9, 0, 0.809524, 0.444879, 92591e-8, 0, 0.84127, 0.428424, 866582e-9, 0, 0.873016, 0.412495, 814463e-9, 0, 0.904762, 0.396975, 764498e-9, 0, 0.936508, 0.381614, 715967e-9, 0, 0.968254, 0.366732, 672483e-9, 0, 1, 1, 155501e-8, 0, 0, 1, 155503e-8, 0, 0, 1, 155524e-8, 0, 0, 0.999998, 155615e-8, 0, 0, 0.999994, 15586e-7, 0, 0, 0.999983, 156379e-8, 0, 0, 0.999963, 15733e-7, 0, 0, 0.999932, 158911e-8, 0, 0, 0.999882, 161376e-8, 0, 0, 0.99981, 165041e-8, 0, 100875e-10, 0.999708, 170304e-8, 0, 367658e-9, 0.999565, 177658e-8, 0, 14234e-7, 0.999368, 187688e-8, 0, 327939e-8, 0.999081, 200989e-8, 0, 596629e-8, 0.99852, 217177e-8, 0, 94852e-7, 0.99549, 21745e-7, 0, 0.013824, 0.993252, 222357e-8, 0, 0.0189642, 0.991727, 235022e-8, 0, 0.0248856, 0.989951, 250561e-8, 0, 0.0315669, 0.988029, 268829e-8, 0, 0.0389882, 0.984029, 27496e-7, 0, 0.0471302, 0.980683, 289793e-8, 0, 0.0559754, 0.976554, 303315e-8, 0, 0.0655081, 0.97139, 313257e-8, 0, 0.0757138, 0.965544, 323656e-8, 0, 0.08658, 0.95912, 333432e-8, 0, 0.0980954, 0.951183, 34039e-7, 0, 0.110251, 0.942974, 347515e-8, 0, 0.123038, 0.932642, 350381e-8, 0, 0.13645, 0.922158, 354519e-8, 0, 0.150482, 0.909404, 353851e-8, 0, 0.165129, 0.896071, 35435e-7, 0, 0.18039, 0.881206, 349936e-8, 0, 0.196263, 0.866077, 347256e-8, 0, 0.212748, 0.85093, 3415e-6, 0, 0.229847, 0.837703, 333367e-8, 0, 0.247561, 0.823878, 3249e-6, 0, 0.265895, 0.809449, 316347e-8, 0, 0.284854, 0.794379, 306351e-8, 0, 0.304445, 0.778138, 29499e-7, 0, 0.324675, 0.761997, 284099e-8, 0, 0.345555, 0.744938, 272104e-8, 0, 0.367095, 0.727212, 260715e-8, 0, 0.389309, 0.709549, 248855e-8, 0, 0.41221, 0.691704, 236783e-8, 0, 0.435814, 0.673689, 225178e-8, 0, 0.460138, 0.656453, 213765e-8, 0, 0.485203, 0.639128, 202178e-8, 0, 0.511028, 0.621512, 191443e-8, 0, 0.537634, 0.603598, 180977e-8, 0, 0.565041, 0.58559, 170456e-8, 0, 0.593268, 0.567852, 160927e-8, 0, 0.622327, 0.5503, 151395e-8, 0, 0.652217, 0.533033, 142499e-8, 0, 0.682907, 0.515942, 133955e-8, 0, 0.714296, 0.498814, 12602e-7, 0, 0.746032, 0.481595, 118188e-8, 0, 0.777778, 0.465117, 111171e-8, 0, 0.809524, 0.448865, 104091e-8, 0, 0.84127, 0.432711, 976618e-9, 0, 0.873016, 0.416822, 91859e-8, 0, 0.904762, 0.401272, 857704e-9, 0, 0.936508, 0.386226, 807172e-9, 0, 0.968254, 0.371321, 75464e-8, 0, 1, 1, 209596e-8, 0, 0, 1, 209598e-8, 0, 0, 1, 209624e-8, 0, 0, 0.999997, 209736e-8, 0, 0, 0.999991, 210039e-8, 0, 0, 0.999979, 210678e-8, 0, 0, 0.999959, 211847e-8, 0, 0, 0.999925, 21379e-7, 0, 0, 0.99987, 216809e-8, 0, 0, 0.999791, 221281e-8, 0, 681487e-10, 0.999677, 227669e-8, 0, 658161e-9, 0.999521, 236533e-8, 0, 200635e-8, 0.999301, 248514e-8, 0, 41779e-7, 0.998977, 264185e-8, 0, 718648e-8, 0.998191, 281695e-8, 0, 0.0110239, 0.994801, 278518e-8, 0, 0.015672, 0.993091, 288774e-8, 0, 0.0211091, 0.991571, 303931e-8, 0, 0.0273123, 0.9897, 321643e-8, 0, 0.034259, 0.987023, 337332e-8, 0, 0.0419282, 0.983289, 346146e-8, 0, 0.0502998, 0.979892, 363704e-8, 0, 0.0593562, 0.975111, 373601e-8, 0, 0.069081, 0.970351, 38842e-7, 0, 0.0794598, 0.964131, 397053e-8, 0, 0.0904798, 0.957747, 408078e-8, 0, 0.10213, 0.949536, 413533e-8, 0, 0.1144, 0.941372, 420305e-8, 0, 0.127284, 0.931049, 422815e-8, 0, 0.140772, 0.920647, 425048e-8, 0, 0.154862, 0.908033, 42281e-7, 0, 0.169548, 0.895028, 422026e-8, 0, 0.184828, 0.879968, 415042e-8, 0, 0.200701, 0.864875, 408821e-8, 0, 0.217167, 0.84918, 400909e-8, 0, 0.234227, 0.834934, 391178e-8, 0, 0.251884, 0.821397, 380066e-8, 0, 0.270141, 0.807135, 367974e-8, 0, 0.289004, 0.792363, 355172e-8, 0, 0.308479, 0.776661, 3411e-6, 0, 0.328575, 0.760705, 328123e-8, 0, 0.349301, 0.744408, 314003e-8, 0, 0.370668, 0.726994, 29906e-7, 0, 0.392689, 0.709598, 285034e-8, 0, 0.415379, 0.692112, 271179e-8, 0, 0.438754, 0.674435, 257185e-8, 0, 0.46283, 0.65676, 243425e-8, 0, 0.48763, 0.639982, 230351e-8, 0, 0.513173, 0.622983, 21777e-7, 0, 0.539482, 0.605471, 204991e-8, 0, 0.566579, 0.58796, 193759e-8, 0, 0.594488, 0.570463, 181976e-8, 0, 0.623226, 0.553058, 171497e-8, 0, 0.6528, 0.535894, 161109e-8, 0, 0.683198, 0.519089, 151394e-8, 0, 0.714354, 0.502454, 142122e-8, 0, 0.746032, 0.485681, 133488e-8, 0, 0.777778, 0.468935, 124975e-8, 0, 0.809524, 0.452951, 117309e-8, 0, 0.84127, 0.437139, 110155e-8, 0, 0.873016, 0.421446, 103124e-8, 0, 0.904762, 0.405951, 966387e-9, 0, 0.936508, 0.391003, 908119e-9, 0, 0.968254, 0.376198, 848057e-9, 0, 1, 1, 280076e-8, 0, 0, 1, 280078e-8, 0, 0, 0.999999, 280109e-8, 0, 0, 0.999997, 280246e-8, 0, 0, 0.999992, 280616e-8, 0, 0, 0.999979, 281396e-8, 0, 0, 0.999956, 282822e-8, 0, 0, 0.999916, 285186e-8, 0, 0, 0.999857, 28885e-7, 0, 0, 0.999768, 294259e-8, 0, 196026e-9, 0.999645, 301946e-8, 0, 104842e-8, 0.99947, 312541e-8, 0, 270199e-8, 0.999229, 326733e-8, 0, 519449e-8, 0.998852, 344992e-8, 0, 852602e-8, 0.997558, 361052e-8, 0, 0.0126804, 0.994417, 35898e-7, 0, 0.017635, 0.992824, 372393e-8, 0, 0.023365, 0.991344, 390695e-8, 0, 0.0298456, 0.989337, 410392e-8, 0, 0.0370529, 0.985811, 420987e-8, 0, 0.0449651, 0.982772, 437488e-8, 0, 0.0535615, 0.979001, 455069e-8, 0, 0.0628243, 0.974102, 464462e-8, 0, 0.0727368, 0.969197, 480577e-8, 0, 0.0832844, 0.962759, 487818e-8, 0, 0.0944545, 0.956207, 498176e-8, 0, 0.106236, 0.947909, 503392e-8, 0, 0.118619, 0.939596, 507474e-8, 0, 0.131595, 0.929642, 509798e-8, 0, 0.145159, 0.918807, 508476e-8, 0, 0.159305, 0.906921, 505634e-8, 0, 0.174028, 0.893312, 498845e-8, 0, 0.189327, 0.878933, 49133e-7, 0, 0.2052, 0.863986, 48259e-7, 0, 0.221647, 0.847936, 470848e-8, 0, 0.23867, 0.832253, 456889e-8, 0, 0.25627, 0.818619, 442726e-8, 0, 0.274453, 0.804788, 427677e-8, 0, 0.293222, 0.790241, 411906e-8, 0, 0.312585, 0.775162, 394833e-8, 0, 0.33255, 0.759463, 377366e-8, 0, 0.353126, 0.743598, 361026e-8, 0, 0.374324, 0.72697, 343627e-8, 0, 0.396158, 0.709646, 326422e-8, 0, 0.418641, 0.69277, 309717e-8, 0, 0.44179, 0.675371, 29356e-7, 0, 0.465624, 0.657863, 277712e-8, 0, 0.490163, 0.640772, 261738e-8, 0, 0.515429, 0.624441, 24737e-7, 0, 0.541445, 0.607497, 233125e-8, 0, 0.568236, 0.590438, 218994e-8, 0, 0.595828, 0.573224, 20664e-7, 0, 0.624242, 0.556168, 193526e-8, 0, 0.653496, 0.539232, 182463e-8, 0, 0.683588, 0.522352, 170735e-8, 0, 0.714482, 0.506172, 160555e-8, 0, 0.746032, 0.489842, 150451e-8, 0, 0.777778, 0.473463, 140938e-8, 0, 0.809524, 0.457266, 132568e-8, 0, 0.84127, 0.441609, 12376e-7, 0, 0.873016, 0.426348, 116265e-8, 0, 0.904762, 0.411002, 108935e-8, 0, 0.936508, 0.396045, 101946e-8, 0, 0.968254, 0.381448, 955665e-9, 0, 1, 1, 37121e-7, 0, 0, 1, 371213e-8, 0, 0, 1, 371251e-8, 0, 0, 0.999997, 371417e-8, 0, 0, 0.99999, 371863e-8, 0, 0, 0.999977, 372807e-8, 0, 0, 0.99995, 374529e-8, 0, 0, 0.999908, 37738e-7, 0, 0, 0.999843, 381789e-8, 0, 123596e-10, 0.999745, 388273e-8, 0, 407442e-9, 0.999608, 397443e-8, 0, 15447e-7, 0.999415, 409998e-8, 0, 351385e-8, 0.999143, 426662e-8, 0, 63316e-7, 0.9987, 447625e-8, 0, 998679e-8, 0.996363, 455323e-8, 0, 0.0144569, 0.994021, 461052e-8, 0, 0.0197151, 0.992372, 476359e-8, 0, 0.0257344, 0.991007, 499101e-8, 0, 0.0324882, 0.988767, 51972e-7, 0, 0.0399517, 0.984872, 528407e-8, 0, 0.0481022, 0.982004, 548926e-8, 0, 0.0569191, 0.977714, 564385e-8, 0, 0.0663839, 0.973076, 57693e-7, 0, 0.0764801, 0.967565, 58924e-7, 0, 0.0871928, 0.961384, 599629e-8, 0, 0.0985095, 0.954435, 605998e-8, 0, 0.110419, 0.946303, 61133e-7, 0, 0.122912, 0.937662, 612028e-8, 0, 0.13598, 0.927867, 612209e-8, 0, 0.149617, 0.916475, 604813e-8, 0, 0.163817, 0.90541, 603088e-8, 0, 0.178577, 0.891591, 592218e-8, 0, 0.193894, 0.877573, 578854e-8, 0, 0.209767, 0.862511, 566648e-8, 0, 0.226196, 0.846861, 551481e-8, 0, 0.243182, 0.83068, 533754e-8, 0, 0.260728, 0.815725, 515487e-8, 0, 0.278837, 0.802321, 49655e-7, 0, 0.297515, 0.787826, 475421e-8, 0, 0.316768, 0.773454, 456002e-8, 0, 0.336605, 0.758224, 434727e-8, 0, 0.357034, 0.74265, 414444e-8, 0, 0.378067, 0.726729, 393738e-8, 0, 0.399717, 0.710155, 373575e-8, 0, 0.421998, 0.693312, 353736e-8, 0, 0.444928, 0.67653, 334368e-8, 0, 0.468523, 0.659444, 315981e-8, 0, 0.492806, 0.642051, 297809e-8, 0, 0.517798, 0.625758, 280592e-8, 0, 0.543525, 0.609615, 264254e-8, 0, 0.570012, 0.592919, 248459e-8, 0, 0.597288, 0.576298, 233327e-8, 0, 0.625379, 0.559489, 219519e-8, 0, 0.654307, 0.542891, 205441e-8, 0, 0.684084, 0.526255, 193385e-8, 0, 0.714693, 0.509853, 180745e-8, 0, 0.746044, 0.494131, 169817e-8, 0, 0.777778, 0.478114, 15913e-7, 0, 0.809524, 0.462274, 148981e-8, 0, 0.84127, 0.446412, 139537e-8, 0, 0.873016, 0.431274, 130984e-8, 0, 0.904762, 0.41635, 122403e-8, 0, 0.936508, 0.401476, 114809e-8, 0, 0.968254, 0.386993, 107563e-8, 0, 1, 1, 488216e-8, 0, 0, 1, 48822e-7, 0, 0, 1, 488265e-8, 0, 0, 0.999997, 488463e-8, 0, 0, 0.999988, 488999e-8, 0, 0, 0.999974, 490129e-8, 0, 0, 0.999946, 492191e-8, 0, 0, 0.999897, 495598e-8, 0, 0, 0.999825, 500855e-8, 0, 744791e-10, 0.999718, 508559e-8, 0, 712744e-9, 0.999565, 5194e-6, 0, 215249e-8, 0.999352, 534147e-8, 0, 444576e-8, 0.999046, 553523e-8, 0, 759218e-8, 0.998492, 577016e-8, 0, 0.0115714, 0.995564, 578487e-8, 0, 0.0163557, 0.993339, 586414e-8, 0, 0.021915, 0.991834, 606002e-8, 0, 0.0282201, 0.990496, 633312e-8, 0, 0.0352433, 0.987826, 651941e-8, 0, 0.042959, 0.98383, 660842e-8, 0, 0.0513439, 0.98109, 685523e-8, 0, 0.0603772, 0.976131, 695778e-8, 0, 0.0700402, 0.971922, 714236e-8, 0, 0.0803163, 0.965901, 721437e-8, 0, 0.0911908, 0.959606, 732017e-8, 0, 0.102651, 0.952504, 735788e-8, 0, 0.114686, 0.944365, 738493e-8, 0, 0.127286, 0.935652, 737969e-8, 0, 0.140443, 0.925813, 733612e-8, 0, 0.154151, 0.914397, 723094e-8, 0, 0.168405, 0.903257, 714002e-8, 0, 0.183201, 0.890015, 700149e-8, 0, 0.198536, 0.876014, 682813e-8, 0, 0.214409, 0.861436, 665567e-8, 0, 0.23082, 0.845752, 644526e-8, 0, 0.24777, 0.829169, 621635e-8, 0, 0.265263, 0.813435, 597789e-8, 0, 0.283301, 0.799701, 575694e-8, 0, 0.301889, 0.785726, 549866e-8, 0, 0.321035, 0.77152, 52503e-7, 0, 0.340746, 0.75683, 499619e-8, 0, 0.361032, 0.741951, 47543e-7, 0, 0.381904, 0.726367, 45084e-7, 0, 0.403374, 0.710537, 426784e-8, 0, 0.425457, 0.693965, 403487e-8, 0, 0.448169, 0.677724, 38075e-7, 0, 0.47153, 0.66117, 359431e-8, 0, 0.495561, 0.644274, 338354e-8, 0, 0.520284, 0.627449, 318163e-8, 0, 0.545725, 0.611645, 299672e-8, 0, 0.571911, 0.595614, 281016e-8, 0, 0.598873, 0.579426, 264252e-8, 0, 0.62664, 0.563016, 247509e-8, 0, 0.655239, 0.546728, 232647e-8, 0, 0.684692, 0.530539, 217803e-8, 0, 0.714999, 0.514164, 204216e-8, 0, 0.746106, 0.498344, 191403e-8, 0, 0.777778, 0.482957, 179203e-8, 0, 0.809524, 0.467336, 167695e-8, 0, 0.84127, 0.451994, 157567e-8, 0, 0.873016, 0.436514, 147113e-8, 0, 0.904762, 0.42178, 138034e-8, 0, 0.936508, 0.407271, 129219e-8, 0, 0.968254, 0.392822, 12098e-7, 0, 1, 1, 637427e-8, 0, 0, 1, 637431e-8, 0, 0, 0.999999, 637485e-8, 0, 0, 0.999996, 637721e-8, 0, 0, 0.999987, 638357e-8, 0, 0, 0.999971, 6397e-6, 0, 0, 0.999939, 642142e-8, 0, 0, 0.999888, 646177e-8, 0, 0, 0.999807, 652387e-8, 0, 207916e-9, 0.999689, 661454e-8, 0, 112051e-8, 0.99952, 674155e-8, 0, 287719e-8, 0.999283, 691313e-8, 0, 550145e-8, 0.998936, 713598e-8, 0, 897928e-8, 0.998165, 738501e-8, 0, 0.0132829, 0.994847, 734388e-8, 0, 0.01838, 0.993182, 749991e-8, 0, 0.0242381, 0.991665, 77246e-7, 0, 0.030826, 0.989708, 797579e-8, 0, 0.0381152, 0.986663, 813011e-8, 0, 0.0460794, 0.983288, 830365e-8, 0, 0.0546951, 0.980104, 853496e-8, 0, 0.0639411, 0.974855, 861045e-8, 0, 0.0737988, 0.97045, 879133e-8, 0, 0.0842516, 0.964509, 886377e-8, 0, 0.0952848, 0.957594, 890346e-8, 0, 0.106886, 0.950546, 893289e-8, 0, 0.119044, 0.942225, 890074e-8, 0, 0.131749, 0.933365, 886826e-8, 0, 0.144994, 0.923202, 87316e-7, 0, 0.158772, 0.912605, 863082e-8, 0, 0.173078, 0.901099, 847403e-8, 0, 0.187908, 0.888177, 825838e-8, 0, 0.203261, 0.873955, 801834e-8, 0, 0.219134, 0.860091, 779026e-8, 0, 0.235527, 0.84434, 752478e-8, 0, 0.252443, 0.828517, 724074e-8, 0, 0.269883, 0.81239, 693769e-8, 0, 0.287851, 0.79721, 664817e-8, 0, 0.306352, 0.783489, 634763e-8, 0, 0.325393, 0.769514, 604221e-8, 0, 0.344981, 0.755419, 573568e-8, 0, 0.365126, 0.741083, 544359e-8, 0, 0.385839, 0.726059, 515515e-8, 0, 0.407132, 0.710809, 487139e-8, 0, 0.42902, 0.695052, 459846e-8, 0, 0.45152, 0.678886, 433412e-8, 0, 0.474651, 0.663042, 407981e-8, 0, 0.498433, 0.646634, 384264e-8, 0, 0.52289, 0.630117, 360897e-8, 0, 0.548048, 0.613804, 338863e-8, 0, 0.573936, 0.598338, 318486e-8, 0, 0.600584, 0.582687, 298377e-8, 0, 0.628027, 0.566809, 280082e-8, 0, 0.656295, 0.550817, 262255e-8, 0, 0.685417, 0.534937, 245835e-8, 0, 0.715406, 0.519151, 230574e-8, 0, 0.74624, 0.503118, 21549e-7, 0, 0.777778, 0.487723, 202008e-8, 0, 0.809524, 0.472725, 189355e-8, 0, 0.84127, 0.457599, 177108e-8, 0, 0.873016, 0.442558, 165843e-8, 0, 0.904762, 0.427624, 155494e-8, 0, 0.936508, 0.413171, 145273e-8, 0, 0.968254, 0.399122, 136454e-8, 0, 1, 1, 826496e-8, 0, 0, 1, 826499e-8, 0, 0, 1, 826564e-8, 0, 0, 0.999996, 826842e-8, 0, 0, 0.999987, 827589e-8, 0, 0, 0.999967, 829167e-8, 0, 0, 0.999933, 832037e-8, 0, 0, 0.999876, 836768e-8, 0, 109338e-10, 0.999786, 844031e-8, 0, 427145e-9, 0.999655, 854603e-8, 0, 16384e-7, 0.999468, 869337e-8, 0, 372392e-8, 0.999203, 8891e-6, 0, 668513e-8, 0.998803, 914387e-8, 0, 0.0104968, 0.99748, 935838e-8, 0, 0.015125, 0.994446, 933309e-8, 0, 0.0205338, 0.99292, 953084e-8, 0, 0.0266884, 0.991414, 97893e-7, 0, 0.0335565, 0.989049, 0.0100228, 0, 0.0411086, 0.98582, 0.0101664, 0, 0.0493181, 0.982441, 0.0103582, 0, 0.0581613, 0.978595, 0.0105292, 0, 0.0676169, 0.973495, 0.0106274, 0, 0.0776661, 0.968405, 0.0107261, 0, 0.0882926, 0.962717, 0.0108234, 0, 0.0994817, 0.955478, 0.0108102, 0, 0.111221, 0.948275, 0.0107914, 0, 0.123499, 0.940006, 0.0107161, 0, 0.136308, 0.930831, 0.0106309, 0, 0.149639, 0.920648, 0.0104083, 0, 0.163485, 0.910205, 0.0102312, 0, 0.177843, 0.898445, 0.0100051, 0, 0.192707, 0.885986, 971928e-8, 0, 0.208077, 0.872204, 940747e-8, 0, 0.22395, 0.858436, 91085e-7, 0, 0.240326, 0.843454, 876595e-8, 0, 0.257208, 0.827437, 839794e-8, 0, 0.274596, 0.811488, 803692e-8, 0, 0.292496, 0.796039, 767352e-8, 0, 0.310911, 0.781083, 73097e-7, 0, 0.329849, 0.767642, 694032e-8, 0, 0.349316, 0.753901, 657476e-8, 0, 0.369323, 0.740131, 622699e-8, 0, 0.38988, 0.725845, 58838e-7, 0, 0.410999, 0.710991, 555586e-8, 0, 0.432696, 0.696002, 523089e-8, 0, 0.454987, 0.680461, 492494e-8, 0, 0.47789, 0.664875, 463464e-8, 0, 0.501426, 0.649273, 435422e-8, 0, 0.52562, 0.63302, 40875e-7, 0, 0.550498, 0.61705, 384075e-8, 0, 0.576089, 0.601154, 359557e-8, 0, 0.602427, 0.586008, 337636e-8, 0, 0.629544, 0.570699, 316019e-8, 0, 0.657479, 0.555166, 296033e-8, 0, 0.686264, 0.539645, 277552e-8, 0, 0.715924, 0.524159, 259499e-8, 0, 0.746459, 0.508682, 243257e-8, 0, 0.777789, 0.493163, 227851e-8, 0, 0.809524, 0.478004, 213083e-8, 0, 0.84127, 0.46347, 199502e-8, 0, 0.873016, 0.448778, 186967e-8, 0, 0.904762, 0.434105, 174732e-8, 0, 0.936508, 0.419576, 163861e-8, 0, 0.968254, 0.405541, 153341e-8, 0, 1, 1, 0.0106462, 0, 0, 1, 0.0106462, 0, 0, 0.999999, 0.010647, 0, 0, 0.999995, 0.0106502, 0, 0, 0.999985, 0.0106589, 0, 0, 0.999964, 0.0106773, 0, 0, 0.999925, 0.0107106, 0, 0, 0.999861, 0.0107655, 0, 712986e-10, 0.999763, 0.0108497, 0, 743959e-9, 0.999616, 0.0109716, 0, 227361e-8, 0.999408, 0.0111408, 0, 46983e-7, 0.999112, 0.0113659, 0, 800158e-8, 0.998637, 0.0116475, 0, 0.0121493, 0.996223, 0.0117231, 0, 0.0171023, 0.994006, 0.0118064, 0, 0.0228218, 0.992444, 0.0120254, 0, 0.0292711, 0.991028, 0.0123314, 0, 0.036417, 0.98803, 0.0124954, 0, 0.0442295, 0.984816, 0.0126538, 0, 0.0526815, 0.981399, 0.0128537, 0, 0.0617492, 0.977085, 0.0129694, 0, 0.0714114, 0.972154, 0.013091, 0, 0.0816495, 0.966617, 0.0131166, 0, 0.0924472, 0.960628, 0.0131583, 0, 0.10379, 0.953295, 0.0131094, 0, 0.115665, 0.94575, 0.0129966, 0, 0.128062, 0.937654, 0.0128796, 0, 0.140972, 0.927716, 0.0126477, 0, 0.154387, 0.917932, 0.0123889, 0, 0.168301, 0.907719, 0.012131, 0, 0.182709, 0.89584, 0.0118013, 0, 0.197608, 0.883526, 0.0114145, 0, 0.212994, 0.870301, 0.0110075, 0, 0.228867, 0.856272, 0.0106019, 0, 0.245227, 0.842251, 0.0101938, 0, 0.262074, 0.826466, 973254e-8, 0, 0.279412, 0.810859, 92846e-7, 0, 0.297244, 0.795051, 883304e-8, 0, 0.315575, 0.780053, 840272e-8, 0, 0.334412, 0.76575, 796438e-8, 0, 0.35376, 0.752298, 752526e-8, 0, 0.373631, 0.739153, 711486e-8, 0, 0.394034, 0.725514, 670361e-8, 0, 0.414983, 0.711473, 632656e-8, 0, 0.436491, 0.696936, 595206e-8, 0, 0.458575, 0.682126, 559191e-8, 0, 0.481253, 0.667027, 525362e-8, 0, 0.504547, 0.651875, 493805e-8, 0, 0.528481, 0.636463, 462848e-8, 0, 0.553081, 0.620641, 433936e-8, 0, 0.578377, 0.604931, 407e-5, 0, 0.604404, 0.589549, 380864e-8, 0, 0.631197, 0.574712, 357049e-8, 0, 0.658795, 0.559775, 334466e-8, 0, 0.687238, 0.544514, 312505e-8, 0, 0.716559, 0.529555, 293199e-8, 0, 0.746776, 0.514402, 274204e-8, 0, 0.777849, 0.499302, 256647e-8, 0, 0.809524, 0.484114, 239901e-8, 0, 0.84127, 0.469308, 225148e-8, 0, 0.873016, 0.455133, 210178e-8, 0, 0.904762, 0.440939, 19727e-7, 0, 0.936508, 0.426627, 184382e-8, 0, 0.968254, 0.412509, 172548e-8, 0, 1, 1, 0.013628, 0, 0, 1, 0.0136281, 0, 0, 0.999999, 0.0136289, 0, 0, 0.999995, 0.0136327, 0, 0, 0.999983, 0.0136427, 0, 0, 0.99996, 0.0136638, 0, 0, 0.999917, 0.0137022, 0, 0, 0.999846, 0.0137652, 0, 204597e-9, 0.999736, 0.0138615, 0, 116837e-8, 0.999573, 0.0140007, 0, 303325e-8, 0.99934, 0.0141927, 0, 580613e-8, 0.999004, 0.0144457, 0, 945626e-8, 0.998407, 0.0147489, 0, 0.0139421, 0.995464, 0.014731, 0, 0.0192202, 0.993328, 0.0148283, 0, 0.0252495, 0.991799, 0.0150797, 0, 0.0319921, 0.990397, 0.0154316, 0, 0.0394138, 0.986835, 0.0155005, 0, 0.0474843, 0.983938, 0.0157308, 0, 0.0561763, 0.980154, 0.0158753, 0, 0.0654661, 0.975659, 0.0159581, 0, 0.0753326, 0.970171, 0.0159832, 0, 0.0857571, 0.964803, 0.0160084, 0, 0.0967236, 0.958366, 0.0159484, 0, 0.108218, 0.950613, 0.0158001, 0, 0.120227, 0.942874, 0.0155845, 0, 0.132741, 0.935005, 0.0154292, 0, 0.145751, 0.924991, 0.0150742, 0, 0.159249, 0.914814, 0.0146757, 0, 0.17323, 0.904743, 0.0143097, 0, 0.187687, 0.893216, 0.0138695, 0, 0.202619, 0.880769, 0.0133706, 0, 0.218021, 0.868136, 0.0128606, 0, 0.233894, 0.85469, 0.0123403, 0, 0.250238, 0.840593, 0.0118091, 0, 0.267052, 0.825808, 0.011253, 0, 0.284341, 0.81009, 0.0107099, 0, 0.302106, 0.79504, 0.0101636, 0, 0.320354, 0.779757, 964041e-8, 0, 0.33909, 0.764697, 911896e-8, 0, 0.358322, 0.750913, 859533e-8, 0, 0.378059, 0.738175, 811592e-8, 0, 0.398311, 0.725242, 764504e-8, 0, 0.41909, 0.711864, 718885e-8, 0, 0.440412, 0.698009, 675843e-8, 0, 0.462292, 0.683841, 634984e-8, 0, 0.484748, 0.669391, 595502e-8, 0, 0.507802, 0.654731, 558671e-8, 0, 0.531477, 0.639805, 523578e-8, 0, 0.555802, 0.624789, 490834e-8, 0, 0.580805, 0.609325, 459448e-8, 0, 0.606522, 0.593975, 430342e-8, 0, 0.63299, 0.578983, 403019e-8, 0, 0.66025, 0.564442, 37707e-7, 0, 0.688346, 0.549835, 35316e-7, 0, 0.717319, 0.535039, 330255e-8, 0, 0.7472, 0.520403, 308932e-8, 0, 0.777982, 0.505687, 289335e-8, 0, 0.809524, 0.490939, 270818e-8, 0, 0.84127, 0.476233, 25343e-7, 0, 0.873016, 0.461624, 237097e-8, 0, 0.904762, 0.447833, 222065e-8, 0, 0.936508, 0.433992, 207561e-8, 0, 0.968254, 0.420147, 194955e-8, 0, 1, 1, 0.0173415, 0, 0, 1, 0.0173416, 0, 0, 0.999999, 0.0173426, 0, 0, 0.999995, 0.0173468, 0, 0, 0.999983, 0.0173582, 0, 0, 0.999954, 0.0173822, 0, 0, 0.999908, 0.0174258, 0, 669501e-11, 0.999828, 0.0174973, 0, 427399e-9, 0.999705, 0.0176063, 0, 171019e-8, 0.999524, 0.0177631, 0, 39248e-7, 0.999263, 0.0179781, 0, 705382e-8, 0.998878, 0.018258, 0, 0.0110552, 0.998012, 0.0185551, 0, 0.0158812, 0.994614, 0.0184264, 0, 0.0214852, 0.993132, 0.0186385, 0, 0.0278239, 0.991563, 0.0189067, 0, 0.0348585, 0.989298, 0.0191577, 0, 0.0425544, 0.986036, 0.0192522, 0, 0.050881, 0.982558, 0.0194063, 0, 0.059811, 0.978531, 0.019486, 0, 0.0693209, 0.974198, 0.0195847, 0, 0.0793895, 0.968148, 0.0194749, 0, 0.0899984, 0.962565, 0.0194277, 0, 0.101132, 0.956041, 0.0192991, 0, 0.112775, 0.947749, 0.0189893, 0, 0.124917, 0.94018, 0.018704, 0, 0.137547, 0.93165, 0.0183458, 0, 0.150655, 0.921798, 0.0178775, 0, 0.164236, 0.911573, 0.0173618, 0, 0.178281, 0.901569, 0.0168482, 0, 0.192788, 0.890341, 0.016265, 0, 0.207752, 0.877835, 0.0156199, 0, 0.223171, 0.865472, 0.0149516, 0, 0.239044, 0.852905, 0.0143274, 0, 0.255371, 0.838906, 0.0136643, 0, 0.272153, 0.824888, 0.0129903, 0, 0.289393, 0.809977, 0.0123218, 0, 0.307093, 0.794697, 0.0116572, 0, 0.325259, 0.780028, 0.0110307, 0, 0.343896, 0.765124, 0.0104236, 0, 0.363012, 0.750411, 98219e-7, 0, 0.382617, 0.737264, 924397e-8, 0, 0.402719, 0.724799, 868719e-8, 0, 0.423332, 0.712253, 816476e-8, 0, 0.444469, 0.699267, 767262e-8, 0, 0.466146, 0.685618, 719746e-8, 0, 0.488383, 0.671736, 673916e-8, 0, 0.511199, 0.657777, 631937e-8, 0, 0.534618, 0.643497, 592411e-8, 0, 0.558668, 0.62889, 553928e-8, 0, 0.58338, 0.614299, 51934e-7, 0, 0.608787, 0.599197, 485985e-8, 0, 0.634929, 0.584175, 454357e-8, 0, 0.661849, 0.569541, 425787e-8, 0, 0.689594, 0.555193, 397905e-8, 0, 0.718211, 0.540947, 372364e-8, 0, 0.747742, 0.526593, 348599e-8, 0, 0.778205, 0.512335, 326103e-8, 0, 0.80953, 0.498017, 305137e-8, 0, 0.84127, 0.483609, 285485e-8, 0, 0.873016, 0.469368, 267472e-8, 0, 0.904762, 0.455037, 249945e-8, 0, 0.936508, 0.441493, 234792e-8, 0, 0.968254, 0.428147, 219936e-8, 0, 1, 1, 0.0219422, 0, 0, 1, 0.0219423, 0, 0, 0.999998, 0.0219434, 0, 0, 0.999993, 0.0219481, 0, 0, 0.999981, 0.021961, 0, 0, 0.999949, 0.0219879, 0, 0, 0.999896, 0.0220367, 0, 593194e-10, 0.999808, 0.0221167, 0, 75364e-8, 0.99967, 0.0222383, 0, 237884e-8, 0.999466, 0.0224125, 0, 495612e-8, 0.999174, 0.0226495, 0, 844887e-8, 0.998725, 0.0229525, 0, 0.0128058, 0.996979, 0.0231123, 0, 0.0179742, 0.994317, 0.0230742, 0, 0.0239047, 0.992781, 0.0232895, 0, 0.0305526, 0.991191, 0.0235734, 0, 0.0378786, 0.987787, 0.0236152, 0, 0.0458475, 0.985092, 0.0237994, 0, 0.0544287, 0.981121, 0.0238553, 0, 0.0635952, 0.976924, 0.0238706, 0, 0.0733233, 0.97218, 0.0238704, 0, 0.0835922, 0.965956, 0.0236598, 0, 0.0943839, 0.959998, 0.0234735, 0, 0.105682, 0.953245, 0.0232277, 0, 0.117474, 0.944445, 0.0226973, 0, 0.129747, 0.937087, 0.0223527, 0, 0.142491, 0.928341, 0.0218144, 0, 0.155697, 0.9184, 0.0211516, 0, 0.169358, 0.907959, 0.0204553, 0, 0.183469, 0.89808, 0.0197673, 0, 0.198024, 0.887047, 0.0189915, 0, 0.21302, 0.875221, 0.0182082, 0, 0.228455, 0.86269, 0.0173584, 0, 0.244329, 0.850735, 0.0165718, 0, 0.260639, 0.837545, 0.0157524, 0, 0.277389, 0.823639, 0.0149482, 0, 0.29458, 0.809699, 0.0141431, 0, 0.312216, 0.794797, 0.0133527, 0, 0.3303, 0.780578, 0.0126193, 0, 0.34884, 0.766019, 0.0118914, 0, 0.367842, 0.751447, 0.0111839, 0, 0.387315, 0.737275, 0.010514, 0, 0.40727, 0.724545, 987277e-8, 0, 0.427717, 0.712644, 926569e-8, 0, 0.448671, 0.700432, 869029e-8, 0, 0.470149, 0.687664, 814691e-8, 0, 0.492167, 0.674288, 763012e-8, 0, 0.514746, 0.660966, 714437e-8, 0, 0.537911, 0.647264, 668457e-8, 0, 0.561688, 0.633431, 626581e-8, 0, 0.586108, 0.619133, 585593e-8, 0, 0.611206, 0.604935, 548188e-8, 0, 0.637022, 0.590236, 513288e-8, 0, 0.663599, 0.575473, 47906e-7, 0, 0.690989, 0.561228, 448895e-8, 0, 0.719242, 0.547054, 420233e-8, 0, 0.748411, 0.533175, 392869e-8, 0, 0.778531, 0.519163, 367445e-8, 0, 0.809583, 0.505328, 344097e-8, 0, 0.84127, 0.491446, 322003e-8, 0, 0.873016, 0.477356, 301283e-8, 0, 0.904762, 0.46356, 282592e-8, 0, 0.936508, 0.449623, 264956e-8, 0, 0.968254, 0.436068, 246956e-8, 0, 1, 1, 0.0276135, 0, 0, 1, 0.0276136, 0, 0, 0.999998, 0.0276148, 0, 0, 0.999993, 0.0276201, 0, 0, 0.999976, 0.0276342, 0, 0, 0.999945, 0.027664, 0, 0, 0.999884, 0.0277179, 0, 18679e-8, 0.999784, 0.027806, 0, 119607e-8, 0.99963, 0.0279394, 0, 318407e-8, 0.999401, 0.0281295, 0, 613601e-8, 0.999066, 0.0283858, 0, 999963e-8, 0.998524, 0.0287027, 0, 0.0147164, 0.995702, 0.0286256, 0, 0.0202295, 0.993593, 0.0286733, 0, 0.0264876, 0.992067, 0.0288989, 0, 0.0334452, 0.990548, 0.0292135, 0, 0.0410621, 0.986775, 0.0291296, 0, 0.0493032, 0.984054, 0.0293099, 0, 0.0581381, 0.979481, 0.0291881, 0, 0.0675397, 0.975297, 0.0291598, 0, 0.0774848, 0.96981, 0.028954, 0, 0.0879528, 0.963524, 0.028628, 0, 0.0989258, 0.957398, 0.0283135, 0, 0.110388, 0.950088, 0.0278469, 0, 0.122327, 0.941538, 0.0271798, 0, 0.134729, 0.933332, 0.0265388, 0, 0.147587, 0.924392, 0.0257776, 0, 0.160889, 0.914581, 0.024916, 0, 0.174631, 0.904347, 0.0240242, 0, 0.188806, 0.894324, 0.0231229, 0, 0.203409, 0.883724, 0.022153, 0, 0.218437, 0.872207, 0.0211355, 0, 0.233888, 0.859927, 0.0201048, 0, 0.249761, 0.848373, 0.0191263, 0, 0.266056, 0.836023, 0.0181306, 0, 0.282774, 0.82289, 0.0171718, 0, 0.299917, 0.809324, 0.0162196, 0, 0.317488, 0.795361, 0.0152622, 0, 0.335493, 0.781253, 0.01439, 0, 0.353936, 0.767338, 0.013533, 0, 0.372825, 0.753156, 0.0127244, 0, 0.392168, 0.739122, 0.0119454, 0, 0.411976, 0.725358, 0.0112054, 0, 0.432259, 0.712949, 0.010487, 0, 0.453032, 0.701621, 984032e-8, 0, 0.47431, 0.689703, 921495e-8, 0, 0.496111, 0.677216, 862492e-8, 0, 0.518456, 0.664217, 806882e-8, 0, 0.541367, 0.65137, 755922e-8, 0, 0.564872, 0.638, 705705e-8, 0, 0.589001, 0.62453, 661266e-8, 0, 0.613789, 0.610601, 618432e-8, 0, 0.639277, 0.59676, 578033e-8, 0, 0.66551, 0.582433, 540927e-8, 0, 0.692539, 0.568026, 506104e-8, 0, 0.720422, 0.55414, 47353e-7, 0, 0.749216, 0.540178, 442889e-8, 0, 0.778974, 0.526513, 414363e-8, 0, 0.809711, 0.512954, 388237e-8, 0, 0.84127, 0.499403, 362875e-8, 0, 0.873016, 0.486026, 340827e-8, 0, 0.904762, 0.472345, 318598e-8, 0, 0.936508, 0.458828, 297635e-8, 0, 0.968254, 0.445379, 279447e-8, 0, 1, 1, 0.0345716, 0, 0, 1, 0.0345717, 0, 0, 0.999999, 0.034573, 0, 0, 0.999991, 0.0345787, 0, 0, 0.999974, 0.0345941, 0, 0, 0.999937, 0.0346263, 0, 188589e-11, 0.999869, 0.0346847, 0, 409238e-9, 0.999757, 0.0347798, 0, 17674e-7, 0.999582, 0.0349233, 0, 413658e-8, 0.999322, 0.0351265, 0, 747408e-8, 0.998939, 0.0353967, 0, 0.0117157, 0.998219, 0.0357018, 0, 0.0167966, 0.994974, 0.0354726, 0, 0.0226572, 0.993201, 0.0355621, 0, 0.0292445, 0.991573, 0.0357641, 0, 0.0365123, 0.989301, 0.0359252, 0, 0.0444203, 0.985712, 0.0358017, 0, 0.0529334, 0.982411, 0.0358353, 0, 0.0620214, 0.977827, 0.035617, 0, 0.0716574, 0.973278, 0.0354398, 0, 0.0818186, 0.967397, 0.0350483, 0, 0.0924846, 0.960696, 0.0344795, 0, 0.103638, 0.954349, 0.0339861, 0, 0.115263, 0.946066, 0.0331323, 0, 0.127348, 0.938012, 0.032359, 0, 0.13988, 0.929413, 0.0314413, 0, 0.152849, 0.920355, 0.0304103, 0, 0.166248, 0.910586, 0.0292785, 0, 0.18007, 0.900609, 0.0281391, 0, 0.194308, 0.890093, 0.0269103, 0, 0.208958, 0.880013, 0.0257269, 0, 0.224018, 0.869001, 0.0244671, 0, 0.239485, 0.85751, 0.0232252, 0, 0.255359, 0.84582, 0.0220117, 0, 0.271638, 0.834383, 0.0208274, 0, 0.288324, 0.822158, 0.0196628, 0, 0.305419, 0.809056, 0.0185306, 0, 0.322927, 0.795832, 0.0174174, 0, 0.340851, 0.782547, 0.0163758, 0, 0.359199, 0.7689, 0.015391, 0, 0.377975, 0.755526, 0.0144488, 0, 0.397189, 0.741681, 0.0135372, 0, 0.416851, 0.728178, 0.0126957, 0, 0.436971, 0.714642, 0.0118812, 0, 0.457564, 0.702756, 0.0111165, 0, 0.478644, 0.69175, 0.0104145, 0, 0.500229, 0.680159, 974439e-8, 0, 0.522339, 0.668073, 911926e-8, 0, 0.544997, 0.655405, 851393e-8, 0, 0.56823, 0.642921, 797637e-8, 0, 0.592068, 0.629993, 745119e-8, 0, 0.616546, 0.616828, 696972e-8, 0, 0.641705, 0.603305, 652425e-8, 0, 0.66759, 0.589833, 610188e-8, 0, 0.694255, 0.575945, 570834e-8, 0, 0.72176, 0.561745, 533384e-8, 0, 0.750168, 0.548277, 500001e-8, 0, 0.779545, 0.534467, 467582e-8, 0, 0.809933, 0.521032, 438092e-8, 0, 0.841272, 0.507877, 410348e-8, 0, 0.873016, 0.494654, 383618e-8, 0, 0.904762, 0.481592, 358699e-8, 0, 0.936508, 0.468509, 337281e-8, 0, 0.968254, 0.455293, 316196e-8, 0, 1, 1, 0.0430698, 0, 0, 1, 0.0430699, 0, 0, 0.999998, 0.0430713, 0, 0, 0.999991, 0.0430773, 0, 0, 0.99997, 0.0430936, 0, 0, 0.999928, 0.0431277, 0, 406396e-10, 0.999852, 0.0431893, 0, 744376e-9, 0.999724, 0.0432895, 0, 24806e-7, 0.999527, 0.0434397, 0, 524779e-8, 0.99923, 0.0436507, 0, 898164e-8, 0.998783, 0.0439255, 0, 0.0136083, 0.997507, 0.0441104, 0, 0.0190582, 0.994418, 0.0438225, 0, 0.0252694, 0.992864, 0.0439396, 0, 0.0321879, 0.991127, 0.0440962, 0, 0.039767, 0.987331, 0.0438408, 0, 0.0479667, 0.984819, 0.0438991, 0, 0.056752, 0.980384, 0.0435906, 0, 0.0660929, 0.975846, 0.0432543, 0, 0.075963, 0.970748, 0.0428293, 0, 0.0863398, 0.964303, 0.042153, 0, 0.0972035, 0.95772, 0.0414111, 0, 0.108537, 0.950747, 0.0405893, 0, 0.120325, 0.942533, 0.0394887, 0, 0.132554, 0.934045, 0.0383544, 0, 0.145215, 0.924942, 0.037057, 0, 0.158296, 0.915811, 0.0356993, 0, 0.17179, 0.90612, 0.0342401, 0, 0.185691, 0.896434, 0.0328078, 0, 0.199993, 0.886021, 0.031288, 0, 0.214691, 0.876081, 0.0297776, 0, 0.229782, 0.865608, 0.0282334, 0, 0.245265, 0.854924, 0.026749, 0, 0.261138, 0.843607, 0.02526, 0, 0.277401, 0.832456, 0.0238214, 0, 0.294056, 0.821342, 0.0224682, 0, 0.311104, 0.809303, 0.0211297, 0, 0.328548, 0.796468, 0.0198387, 0, 0.346394, 0.784046, 0.0186227, 0, 0.364645, 0.771262, 0.0174561, 0, 0.38331, 0.758118, 0.0163806, 0, 0.402396, 0.745075, 0.0153287, 0, 0.421912, 0.731926, 0.0143647, 0, 0.44187, 0.71863, 0.0134363, 0, 0.462283, 0.705414, 0.0125603, 0, 0.483165, 0.693792, 0.0117508, 0, 0.504535, 0.683108, 0.0110016, 0, 0.52641, 0.67183, 0.0102757, 0, 0.548816, 0.66015, 962044e-8, 0, 0.571776, 0.647907, 898031e-8, 0, 0.595323, 0.635734, 840811e-8, 0, 0.619489, 0.623208, 786211e-8, 0, 0.644317, 0.610438, 734953e-8, 0, 0.669852, 0.597345, 687688e-8, 0, 0.696148, 0.584138, 643469e-8, 0, 0.723267, 0.5707, 602236e-8, 0, 0.75128, 0.556966, 56324e-7, 0, 0.780258, 0.543607, 528277e-8, 0, 0.810268, 0.530213, 493999e-8, 0, 0.841311, 0.516912, 462265e-8, 0, 0.873016, 0.503916, 43307e-7, 0, 0.904762, 0.491146, 406858e-8, 0, 0.936508, 0.478439, 381436e-8, 0, 0.968254, 0.465834, 358003e-8, 0, 1, 1, 0.0534039, 0, 0, 1, 0.053404, 0, 0, 0.999998, 0.0534055, 0, 0, 0.999989, 0.0534116, 0, 0, 0.999968, 0.0534283, 0, 0, 0.999918, 0.0534633, 0, 155895e-9, 0.99983, 0.0535262, 0, 120914e-8, 0.999685, 0.0536281, 0, 334944e-8, 0.999461, 0.0537799, 0, 653077e-8, 0.999119, 0.0539902, 0, 0.0106718, 0.998582, 0.0542524, 0, 0.0156907, 0.995919, 0.0540318, 0, 0.0215147, 0.993735, 0.0538914, 0, 0.0280801, 0.992126, 0.0539557, 0, 0.0353323, 0.990266, 0.0540401, 0, 0.0432247, 0.986317, 0.0536064, 0, 0.0517172, 0.983213, 0.0534425, 0, 0.0607754, 0.978303, 0.0528622, 0, 0.0703698, 0.973665, 0.0523363, 0, 0.0804742, 0.968091, 0.0516165, 0, 0.0910667, 0.961026, 0.0505434, 0, 0.102128, 0.954333, 0.049523, 0, 0.113641, 0.946372, 0.0481698, 0, 0.125591, 0.938254, 0.0467674, 0, 0.137965, 0.929516, 0.0452341, 0, 0.150754, 0.920106, 0.0435083, 0, 0.163947, 0.910899, 0.0417399, 0, 0.177537, 0.901532, 0.0399389, 0, 0.191516, 0.891919, 0.0380901, 0, 0.205881, 0.882006, 0.0362341, 0, 0.220626, 0.871965, 0.0343444, 0, 0.235749, 0.862145, 0.0324832, 0, 0.251248, 0.852058, 0.0306681, 0, 0.267121, 0.84161, 0.0289097, 0, 0.283368, 0.830806, 0.0272079, 0, 0.299992, 0.820476, 0.0256089, 0, 0.316992, 0.809514, 0.0240394, 0, 0.334374, 0.797865, 0.0225379, 0, 0.35214, 0.785621, 0.0211235, 0, 0.370296, 0.773765, 0.0197908, 0, 0.388849, 0.761629, 0.0185235, 0, 0.407807, 0.748891, 0.0173358, 0, 0.427178, 0.736437, 0.0162305, 0, 0.446974, 0.723707, 0.0151778, 0, 0.467207, 0.710606, 0.0141791, 0, 0.487892, 0.698019, 0.0132592, 0, 0.509046, 0.686203, 0.0123887, 0, 0.530687, 0.675692, 0.0115976, 0, 0.552839, 0.664826, 0.0108325, 0, 0.575527, 0.65349, 0.0101348, 0, 0.59878, 0.641774, 947756e-8, 0, 0.622634, 0.629794, 886058e-8, 0, 0.647128, 0.617647, 828526e-8, 0, 0.672308, 0.60534, 775312e-8, 0, 0.698231, 0.592718, 726033e-8, 0, 0.724958, 0.579746, 679731e-8, 0, 0.752563, 0.566763, 636111e-8, 0, 0.781127, 0.553515, 595228e-8, 0, 0.810733, 0.540118, 556876e-8, 0, 0.841426, 0.527325, 523051e-8, 0, 0.873016, 0.514265, 490712e-8, 0, 0.904762, 0.501406, 460297e-8, 0, 0.936508, 0.488922, 431247e-8, 0, 0.968254, 0.476541, 40472e-7, 0, 1, 1, 0.0659184, 0, 0, 1, 0.0659185, 0, 0, 0.999998, 0.06592, 0, 0, 0.999988, 0.0659259, 0, 0, 0.999963, 0.0659423, 0, 0, 0.999907, 0.0659764, 0, 374198e-9, 0.999806, 0.0660376, 0, 182071e-8, 0.999639, 0.0661361, 0, 43894e-7, 0.999378, 0.0662814, 0, 800055e-8, 0.998985, 0.0664779, 0, 0.0125594, 0.998285, 0.0666914, 0, 0.0179786, 0.995071, 0.0661989, 0, 0.0241822, 0.993172, 0.0660454, 0, 0.031106, 0.991438, 0.0660105, 0, 0.0386952, 0.988428, 0.0656875, 0, 0.0469032, 0.985218, 0.0652913, 0, 0.0556905, 0.981128, 0.0647107, 0, 0.065023, 0.976015, 0.0638491, 0, 0.0748717, 0.97097, 0.062993, 0, 0.0852112, 0.964582, 0.0617927, 0, 0.0960199, 0.957383, 0.0603626, 0, 0.107279, 0.949969, 0.0588128, 0, 0.118971, 0.941843, 0.0570274, 0, 0.131084, 0.933624, 0.0551885, 0, 0.143604, 0.924543, 0.053122, 0, 0.156521, 0.914919, 0.0508897, 0, 0.169825, 0.905773, 0.0486418, 0, 0.18351, 0.896434, 0.0463364, 0, 0.197569, 0.887195, 0.0440623, 0, 0.211997, 0.877706, 0.0417799, 0, 0.226789, 0.867719, 0.03945, 0, 0.241944, 0.858587, 0.037243, 0, 0.257458, 0.849317, 0.0350956, 0, 0.273331, 0.839585, 0.0329852, 0, 0.289563, 0.829856, 0.0310028, 0, 0.306154, 0.819589, 0.0290953, 0, 0.323108, 0.809714, 0.0272738, 0, 0.340426, 0.79934, 0.0255631, 0, 0.358113, 0.788224, 0.0239175, 0, 0.376175, 0.776619, 0.0223831, 0, 0.394616, 0.76521, 0.0209298, 0, 0.413445, 0.753716, 0.0195786, 0, 0.432671, 0.741564, 0.0183001, 0, 0.452305, 0.729413, 0.0171259, 0, 0.472358, 0.717146, 0.0159933, 0, 0.492845, 0.70436, 0.0149495, 0, 0.513783, 0.69219, 0.0139681, 0, 0.535189, 0.680289, 0.0130577, 0, 0.557087, 0.669611, 0.0122198, 0, 0.5795, 0.659113, 0.0114174, 0, 0.602459, 0.648148, 0.0106729, 0, 0.625997, 0.636905, 998997e-8, 0, 0.650154, 0.625154, 934313e-8, 0, 0.674976, 0.613481, 874839e-8, 0, 0.700518, 0.60154, 818265e-8, 0, 0.726845, 0.58943, 766889e-8, 0, 0.754032, 0.576828, 717153e-8, 0, 0.782167, 0.564194, 672696e-8, 0, 0.811344, 0.551501, 630863e-8, 0, 0.841644, 0.538635, 592177e-8, 0, 0.873016, 0.525724, 554888e-8, 0, 0.904762, 0.513209, 520225e-8, 0, 0.936508, 0.500457, 488231e-8, 0, 0.968254, 0.48799, 457153e-8, 0, 1, 1, 0.0810131, 0, 0, 1, 0.0810133, 0, 0, 0.999997, 0.0810145, 0, 0, 0.999985, 0.08102, 0, 0, 0.999956, 0.0810347, 0, 195026e-10, 0.999893, 0.0810656, 0, 719316e-9, 0.999777, 0.0811205, 0, 259774e-8, 0.999583, 0.081208, 0, 561807e-8, 0.999281, 0.0813343, 0, 967472e-8, 0.998813, 0.0814969, 0, 0.0146627, 0.997597, 0.0815217, 0, 0.0204902, 0.994379, 0.0808502, 0, 0.0270802, 0.992744, 0.0806792, 0, 0.0343674, 0.990745, 0.0804589, 0, 0.0422974, 0.986646, 0.0796107, 0, 0.0508242, 0.983611, 0.0790913, 0, 0.0599087, 0.978869, 0.0780746, 0, 0.0695175, 0.973475, 0.0768218, 0, 0.0796223, 0.967845, 0.0754926, 0, 0.0901983, 0.960778, 0.0737063, 0, 0.101224, 0.953333, 0.0718052, 0, 0.112682, 0.945274, 0.0695946, 0, 0.124555, 0.936955, 0.0672492, 0, 0.136831, 0.928319, 0.0647732, 0, 0.149496, 0.919075, 0.0620947, 0, 0.162542, 0.909114, 0.0591816, 0, 0.175958, 0.900137, 0.0563917, 0, 0.189739, 0.891069, 0.0535392, 0, 0.203877, 0.882262, 0.0507642, 0, 0.218368, 0.873232, 0.0479793, 0, 0.233208, 0.864042, 0.045226, 0, 0.248393, 0.855002, 0.0425413, 0, 0.263923, 0.846569, 0.0400126, 0, 0.279796, 0.837714, 0.0375269, 0, 0.296012, 0.828918, 0.0352027, 0, 0.312573, 0.819783, 0.0330011, 0, 0.329479, 0.810129, 0.0308908, 0, 0.346734, 0.800866, 0.0289112, 0, 0.364342, 0.79093, 0.0270255, 0, 0.382307, 0.780593, 0.0252758, 0, 0.400637, 0.769511, 0.0236178, 0, 0.419337, 0.758558, 0.0220652, 0, 0.438418, 0.747632, 0.0206289, 0, 0.457889, 0.736146, 0.0192873, 0, 0.477761, 0.724093, 0.0180333, 0, 0.49805, 0.71234, 0.0168264, 0, 0.51877, 0.700201, 0.015746, 0, 0.53994, 0.687949, 0.0147027, 0, 0.561581, 0.676163, 0.0137512, 0, 0.583718, 0.665001, 0.0128655, 0, 0.60638, 0.65472, 0.0120366, 0, 0.629599, 0.644213, 0.0112604, 0, 0.653415, 0.633382, 0.0105413, 0, 0.677874, 0.62212, 986498e-8, 0, 0.70303, 0.610631, 923308e-8, 0, 0.728948, 0.599078, 864206e-8, 0, 0.755706, 0.587519, 811784e-8, 0, 0.783396, 0.575505, 761237e-8, 0, 0.812121, 0.563148, 713949e-8, 0, 0.841989, 0.550828, 668379e-8, 0, 0.873035, 0.538458, 627715e-8, 0, 0.904762, 0.525905, 588336e-8, 0, 0.936508, 0.513517, 552687e-8, 0, 0.968254, 0.501395, 519681e-8, 0, 1, 1, 0.0991506, 0, 0, 1, 0.0991504, 0, 0, 0.999996, 0.0991515, 0, 0, 0.999984, 0.0991558, 0, 0, 0.999947, 0.0991672, 0, 114389e-9, 0.999874, 0.0991912, 0, 121503e-8, 0.999739, 0.0992331, 0, 356108e-8, 0.999514, 0.0992983, 0, 705578e-8, 0.999159, 0.0993877, 0, 0.011574, 0.998586, 0.0994837, 0, 0.017003, 0.995731, 0.0988425, 0, 0.0232484, 0.993384, 0.098276, 0, 0.0302318, 0.991615, 0.0979269, 0, 0.0378884, 0.989029, 0.0973432, 0, 0.0461641, 0.985373, 0.0963539, 0, 0.0550136, 0.981278, 0.0952306, 0, 0.0643988, 0.975777, 0.0936233, 0, 0.0742868, 0.970526, 0.0920219, 0, 0.0846501, 0.963755, 0.0898912, 0, 0.0954644, 0.956676, 0.0876064, 0, 0.106709, 0.948099, 0.0847751, 0, 0.118367, 0.939718, 0.0818638, 0, 0.130423, 0.931305, 0.078857, 0, 0.142862, 0.922342, 0.0756127, 0, 0.155674, 0.912842, 0.0721473, 0, 0.168849, 0.903304, 0.0686195, 0, 0.182378, 0.89411, 0.0650589, 0, 0.196255, 0.885512, 0.0616022, 0, 0.210473, 0.877193, 0.0582434, 0, 0.225027, 0.86877, 0.0548979, 0, 0.239915, 0.860267, 0.0516095, 0, 0.255132, 0.851915, 0.048468, 0, 0.270678, 0.843912, 0.0454447, 0, 0.286551, 0.83604, 0.0425612, 0, 0.302751, 0.828245, 0.0398752, 0, 0.31928, 0.820159, 0.0373198, 0, 0.336138, 0.81167, 0.034916, 0, 0.35333, 0.802659, 0.0326402, 0, 0.370858, 0.793921, 0.0304901, 0, 0.388728, 0.784713, 0.0284857, 0, 0.406944, 0.774946, 0.0266186, 0, 0.425515, 0.76448, 0.0248593, 0, 0.444449, 0.753793, 0.0232114, 0, 0.463756, 0.743506, 0.0217039, 0, 0.483447, 0.732555, 0.0202841, 0, 0.503535, 0.720965, 0.0189648, 0, 0.524036, 0.709422, 0.0177189, 0, 0.544968, 0.697756, 0.0165626, 0, 0.56635, 0.685565, 0.015483, 0, 0.588208, 0.673987, 0.0144892, 0, 0.610569, 0.66244, 0.0135607, 0, 0.633466, 0.651675, 0.0126956, 0, 0.656936, 0.641598, 0.0118788, 0, 0.681025, 0.63121, 0.0111261, 0, 0.705788, 0.620514, 0.010437, 0, 0.731289, 0.609366, 978747e-8, 0, 0.757606, 0.598137, 917257e-8, 0, 0.784834, 0.586966, 859778e-8, 0, 0.813085, 0.575549, 806803e-8, 0, 0.842485, 0.563797, 757294e-8, 0, 0.87313, 0.551758, 710592e-8, 0, 0.904762, 0.539894, 66841e-7, 0, 0.936508, 0.527901, 627901e-8, 0, 0.968254, 0.515819, 590506e-8, 0, 1, 1, 0.120864, 0, 0, 1, 0.120864, 0, 0, 0.999996, 0.120864, 0, 0, 0.99998, 0.120867, 0, 0, 0.99994, 0.120872, 0, 323781e-9, 0.999852, 0.120884, 0, 188693e-8, 0.999693, 0.120903, 0, 473489e-8, 0.999426, 0.120929, 0, 872704e-8, 0.999002, 0.120955, 0, 0.0137237, 0.998235, 0.120918, 0, 0.0196068, 0.994608, 0.119764, 0, 0.0262803, 0.992997, 0.119265, 0, 0.0336657, 0.990968, 0.11863, 0, 0.0416987, 0.987002, 0.117261, 0, 0.0503261, 0.983524, 0.116009, 0, 0.0595035, 0.97875, 0.114252, 0, 0.0691935, 0.972652, 0.11193, 0, 0.0793645, 0.966613, 0.109555, 0, 0.0899894, 0.959275, 0.106612, 0, 0.101045, 0.951272, 0.103375, 0, 0.112512, 0.942323, 0.0996594, 0, 0.124372, 0.933679, 0.0958841, 0, 0.136611, 0.924822, 0.0919265, 0, 0.149216, 0.915742, 0.0878061, 0, 0.162176, 0.906348, 0.0834894, 0, 0.175482, 0.896883, 0.079085, 0, 0.189125, 0.88774, 0.0746745, 0, 0.203098, 0.87986, 0.0705773, 0, 0.217396, 0.871998, 0.0665005, 0, 0.232015, 0.864325, 0.0625413, 0, 0.24695, 0.856685, 0.0586781, 0, 0.2622, 0.84925, 0.0550063, 0, 0.277761, 0.841719, 0.0514727, 0, 0.293634, 0.834755, 0.0481398, 0, 0.309819, 0.827853, 0.0450172, 0, 0.326315, 0.820888, 0.0420969, 0, 0.343126, 0.813616, 0.0393702, 0, 0.360254, 0.805767, 0.0367771, 0, 0.377701, 0.797338, 0.0343274, 0, 0.395474, 0.789122, 0.0320529, 0, 0.413577, 0.780601, 0.0299485, 0, 0.432018, 0.771424, 0.0279812, 0, 0.450804, 0.761502, 0.0261054, 0, 0.469944, 0.751166, 0.0243942, 0, 0.489451, 0.741276, 0.0228087, 0, 0.509337, 0.730898, 0.0213265, 0, 0.529617, 0.719878, 0.0199307, 0, 0.550307, 0.708379, 0.0186574, 0, 0.571428, 0.697165, 0.0174446, 0, 0.593003, 0.685554, 0.0163144, 0, 0.615059, 0.673631, 0.015276, 0, 0.637628, 0.662385, 0.0143003, 0, 0.660746, 0.651059, 0.0134112, 0, 0.68446, 0.640451, 0.0125794, 0, 0.70882, 0.630536, 0.011793, 0, 0.733893, 0.620316, 0.0110547, 0, 0.759756, 0.609722, 0.0103668, 0, 0.786505, 0.598804, 973009e-8, 0, 0.814259, 0.587871, 912812e-8, 0, 0.843157, 0.577121, 858916e-8, 0, 0.87334, 0.566019, 807333e-8, 0, 0.904762, 0.554664, 759687e-8, 0, 0.936508, 0.543101, 714759e-8, 0, 0.968254, 0.531558, 673418e-8, 0, 1, 1, 0.146767, 0, 0, 1, 0.146767, 0, 0, 0.999997, 0.146767, 0, 0, 0.999977, 0.146765, 0, 320658e-11, 0.999929, 0.146762, 0, 682576e-9, 0.999823, 0.146753, 0, 276402e-8, 0.999633, 0.146735, 0, 614771e-8, 0.999314, 0.146699, 0, 0.0106613, 0.998796, 0.14662, 0, 0.0161546, 0.997124, 0.146107, 0, 0.0225063, 0.994062, 0.144857, 0, 0.0296198, 0.992154, 0.144011, 0, 0.037417, 0.989186, 0.142712, 0, 0.0458348, 0.985279, 0.140926, 0, 0.0548211, 0.980826, 0.13885, 0, 0.0643326, 0.975056, 0.136168, 0, 0.074333, 0.969005, 0.133217, 0, 0.0847917, 0.961554, 0.12959, 0, 0.0956828, 0.954206, 0.125886, 0, 0.106984, 0.945046, 0.121335, 0, 0.118675, 0.935678, 0.116492, 0, 0.130741, 0.926748, 0.111635, 0, 0.143166, 0.917764, 0.106625, 0, 0.155939, 0.908358, 0.101325, 0, 0.169049, 0.899219, 0.0960249, 0, 0.182487, 0.890089, 0.0906527, 0, 0.196245, 0.881488, 0.0853905, 0, 0.210317, 0.874031, 0.0804177, 0, 0.224697, 0.866932, 0.0756005, 0, 0.23938, 0.859976, 0.0709019, 0, 0.254364, 0.853375, 0.0664391, 0, 0.269646, 0.846971, 0.0622012, 0, 0.285223, 0.840483, 0.058129, 0, 0.301096, 0.833969, 0.0542762, 0, 0.317265, 0.82806, 0.0507042, 0, 0.333729, 0.822128, 0.047368, 0, 0.350491, 0.815989, 0.044272, 0, 0.367554, 0.809336, 0.0413444, 0, 0.38492, 0.802177, 0.038601, 0, 0.402594, 0.79441, 0.0360227, 0, 0.420582, 0.786573, 0.0336383, 0, 0.438891, 0.778619, 0.0314321, 0, 0.457527, 0.77, 0.029362, 0, 0.476499, 0.760698, 0.0274102, 0, 0.49582, 0.750932, 0.0256146, 0, 0.5155, 0.740993, 0.023974, 0, 0.535555, 0.731159, 0.0224182, 0, 0.556, 0.720836, 0.0209889, 0, 0.576855, 0.709913, 0.0196411, 0, 0.598143, 0.698415, 0.0183824, 0, 0.619888, 0.68745, 0.0172222, 0, 0.642123, 0.676154, 0.0161509, 0, 0.664883, 0.664383, 0.0151397, 0, 0.688211, 0.6533, 0.0141873, 0, 0.71216, 0.642072, 0.0133105, 0, 0.736792, 0.631412, 0.0124932, 0, 0.762186, 0.621622, 0.0117408, 0, 0.788439, 0.611681, 0.0110358, 0, 0.815672, 0.60142, 0.0103775, 0, 0.844034, 0.59083, 975623e-8, 0, 0.873699, 0.580254, 918084e-8, 0, 0.904765, 0.569841, 864721e-8, 0, 0.936508, 0.559224, 815731e-8, 0, 0.968254, 0.548315, 767924e-8, 0, 1, 1, 0.177563, 0, 0, 1, 0.177563, 0, 0, 0.999994, 0.177562, 0, 0, 0.999972, 0.177555, 0, 664171e-10, 0.999914, 0.177536, 0, 12276e-7, 0.999787, 0.177496, 0, 388025e-8, 0.999556, 0.17742, 0, 783463e-8, 0.999165, 0.177285, 0, 0.0128953, 0.9985, 0.177037, 0, 0.0189053, 0.995388, 0.175634, 0, 0.025742, 0.993102, 0.174375, 0, 0.033309, 0.990992, 0.173121, 0, 0.0415298, 0.986932, 0.170896, 0, 0.0503425, 0.982786, 0.16847, 0, 0.0596964, 0.977592, 0.165455, 0, 0.0695498, 0.971075, 0.161676, 0, 0.0798676, 0.963967, 0.157458, 0, 0.0906201, 0.956397, 0.152836, 0, 0.101783, 0.947489, 0.147467, 0, 0.113333, 0.937564, 0.14145, 0, 0.125254, 0.928182, 0.135383, 0, 0.137529, 0.919027, 0.129212, 0, 0.150144, 0.909618, 0.12276, 0, 0.163088, 0.900492, 0.116273, 0, 0.176351, 0.891671, 0.1098, 0, 0.189924, 0.883146, 0.103362, 0, 0.203799, 0.875151, 0.0970799, 0, 0.21797, 0.868338, 0.0911732, 0, 0.232433, 0.862033, 0.0854966, 0, 0.247182, 0.856107, 0.0800691, 0, 0.262216, 0.850644, 0.0749618, 0, 0.27753, 0.845261, 0.070079, 0, 0.293124, 0.839885, 0.0654321, 0, 0.308997, 0.834609, 0.0610975, 0, 0.325149, 0.829083, 0.0569741, 0, 0.341581, 0.82404, 0.0531736, 0, 0.358294, 0.818968, 0.049665, 0, 0.37529, 0.813496, 0.0463856, 0, 0.392573, 0.807533, 0.0433217, 0, 0.410148, 0.80099, 0.0404402, 0, 0.428019, 0.793891, 0.0377578, 0, 0.446192, 0.786281, 0.0352616, 0, 0.464676, 0.778773, 0.0329577, 0, 0.483478, 0.770737, 0.030808, 0, 0.502608, 0.762094, 0.0287964, 0, 0.522079, 0.752898, 0.0269254, 0, 0.541905, 0.743306, 0.0251926, 0, 0.5621, 0.733416, 0.023595, 0, 0.582684, 0.723742, 0.0221155, 0, 0.603677, 0.713542, 0.0207435, 0, 0.625106, 0.702755, 0.019434, 0, 0.646998, 0.691484, 0.0182046, 0, 0.66939, 0.680531, 0.0170771, 0, 0.692324, 0.66953, 0.0160339, 0, 0.715849, 0.658126, 0.0150677, 0, 0.740028, 0.646933, 0.0141551, 0, 0.764937, 0.636107, 0.0133179, 0, 0.790673, 0.625271, 0.0125284, 0, 0.817358, 0.615225, 0.0117937, 0, 0.84515, 0.605678, 0.0111181, 0, 0.874244, 0.59583, 0.0104759, 0, 0.904828, 0.585704, 986672e-8, 0, 0.936508, 0.575413, 929712e-8, 0, 0.968254, 0.565373, 876713e-8, 0, 1, 1, 0.214058, 0, 0, 0.999999, 0.214058, 0, 0, 0.999994, 0.214055, 0, 0, 0.999966, 0.214039, 0, 259642e-9, 0.999893, 0.213998, 0, 200075e-8, 0.999737, 0.21391, 0, 527775e-8, 0.999449, 0.213745, 0, 983959e-8, 0.99896, 0.213458, 0, 0.0154755, 0.9979, 0.212855, 0, 0.0220249, 0.994278, 0.210779, 0, 0.0293654, 0.992254, 0.20926, 0, 0.0374021, 0.98881, 0.206908, 0, 0.0460604, 0.984715, 0.204009, 0, 0.0552802, 0.979738, 0.200471, 0, 0.0650127, 0.972884, 0.195813, 0, 0.0752175, 0.965996, 0.190856, 0, 0.0858612, 0.957974, 0.185077, 0, 0.0969155, 0.949155, 0.17868, 0, 0.108356, 0.939288, 0.171513, 0, 0.120163, 0.928996, 0.163838, 0, 0.132319, 0.919563, 0.156246, 0, 0.144808, 0.910004, 0.148359, 0, 0.157618, 0.900791, 0.140417, 0, 0.170737, 0.892135, 0.132569, 0, 0.184155, 0.883803, 0.124741, 0, 0.197866, 0.876034, 0.117091, 0, 0.211861, 0.869219, 0.109835, 0, 0.226134, 0.863062, 0.102859, 0, 0.240682, 0.857795, 0.0962928, 0, 0.255499, 0.853009, 0.0900725, 0, 0.270583, 0.848603, 0.0842101, 0, 0.285931, 0.844335, 0.0786527, 0, 0.301542, 0.840208, 0.0734397, 0, 0.317415, 0.836035, 0.0685334, 0, 0.33355, 0.83172, 0.0639275, 0, 0.349948, 0.827135, 0.0595909, 0, 0.36661, 0.822797, 0.0556204, 0, 0.383539, 0.818387, 0.0519394, 0, 0.400738, 0.813565, 0.0485317, 0, 0.41821, 0.808142, 0.0453138, 0, 0.435961, 0.802212, 0.0423354, 0, 0.453997, 0.79573, 0.0395553, 0, 0.472324, 0.788741, 0.036988, 0, 0.490951, 0.781093, 0.0345688, 0, 0.509887, 0.773597, 0.0323297, 0, 0.529144, 0.765622, 0.0302719, 0, 0.548735, 0.757083, 0.0283477, 0, 0.568674, 0.747992, 0.0265562, 0, 0.588979, 0.738591, 0.0248844, 0, 0.609671, 0.728719, 0.0233342, 0, 0.630773, 0.719146, 0.0219081, 0, 0.652314, 0.709165, 0.0205711, 0, 0.674328, 0.69875, 0.0193248, 0, 0.696854, 0.687884, 0.0181582, 0, 0.719942, 0.676818, 0.0170746, 0, 0.743651, 0.666247, 0.0160718, 0, 0.768057, 0.655284, 0.0151262, 0, 0.793253, 0.64401, 0.0142561, 0, 0.819363, 0.633353, 0.0134327, 0, 0.846547, 0.622674, 0.012653, 0, 0.875017, 0.612265, 0.0119354, 0, 0.905021, 0.602455, 0.0112533, 0, 0.936508, 0.593147, 0.0106234, 0, 0.968254, 0.583592, 0.0100213, 0, 1, 1, 0.25717, 0, 0, 1, 0.25717, 0, 0, 0.999992, 0.257164, 0, 0, 0.999958, 0.257135, 0, 641715e-9, 0.999864, 0.25706, 0, 305314e-8, 0.999666, 0.256897, 0, 700975e-8, 0.999302, 0.256596, 0, 0.0122194, 0.998663, 0.25607, 0, 0.0184622, 0.995607, 0.254123, 0, 0.0255773, 0.993094, 0.252081, 0, 0.0334439, 0.9907, 0.249867, 0, 0.0419696, 0.98594, 0.246118, 0, 0.0510823, 0.981214, 0.242049, 0, 0.0607242, 0.974966, 0.236869, 0, 0.0708486, 0.967589, 0.230724, 0, 0.081417, 0.95915, 0.223635, 0, 0.0923974, 0.950257, 0.21596, 0, 0.103763, 0.940165, 0.207296, 0, 0.115491, 0.929396, 0.197901, 0, 0.127562, 0.919288, 0.188437, 0, 0.13996, 0.909428, 0.178762, 0, 0.15267, 0.900105, 0.169072, 0, 0.165679, 0.891418, 0.159478, 0, 0.178979, 0.883347, 0.15002, 0, 0.192558, 0.875992, 0.140813, 0, 0.20641, 0.869466, 0.13196, 0, 0.220529, 0.863699, 0.123501, 0, 0.234907, 0.858553, 0.115436, 0, 0.249542, 0.854379, 0.107901, 0, 0.264428, 0.850894, 0.10088, 0, 0.279564, 0.847632, 0.0942296, 0, 0.294947, 0.844571, 0.0879861, 0, 0.310575, 0.84163, 0.0821534, 0, 0.326448, 0.838542, 0.0766409, 0, 0.342566, 0.835412, 0.0715322, 0, 0.358929, 0.831899, 0.0666883, 0, 0.37554, 0.828177, 0.0622175, 0, 0.392399, 0.82416, 0.0580452, 0, 0.409511, 0.820393, 0.054267, 0, 0.426878, 0.816068, 0.0507172, 0, 0.444506, 0.811201, 0.0474041, 0, 0.4624, 0.805785, 0.0443174, 0, 0.480566, 0.799878, 0.0414562, 0, 0.499013, 0.793469, 0.0388147, 0, 0.517749, 0.786473, 0.0363453, 0, 0.536785, 0.778874, 0.0340225, 0, 0.556134, 0.771277, 0.0318599, 0, 0.575809, 0.763426, 0.0298859, 0, 0.595827, 0.755044, 0.0280357, 0, 0.616207, 0.746161, 0.0262979, 0, 0.636973, 0.737124, 0.0247295, 0, 0.65815, 0.72761, 0.0232514, 0, 0.679772, 0.717822, 0.0218755, 0, 0.701876, 0.708279, 0.0205942, 0, 0.724509, 0.698333, 0.0193947, 0, 0.74773, 0.68802, 0.0182717, 0, 0.771609, 0.677321, 0.0172044, 0, 0.79624, 0.666504, 0.0162122, 0, 0.821743, 0.656184, 0.0152924, 0, 0.84828, 0.64556, 0.0144326, 0, 0.876069, 0.634636, 0.0136157, 0, 0.905404, 0.624124, 0.0128612, 0, 0.936508, 0.613914, 0.0121435, 0, 0.968254, 0.603589, 0.0114887, 0, 1, 1, 0.307946, 0, 0, 0.999999, 0.307945, 0, 0, 0.999988, 0.307934, 0, 204479e-10, 0.999944, 0.307886, 0, 127833e-8, 0.999824, 0.307756, 0, 445047e-8, 0.999565, 0.30748, 0, 914673e-8, 0.999085, 0.306966, 0, 0.0150498, 0.998103, 0.306004, 0, 0.0219367, 0.994249, 0.303028, 0, 0.0296485, 0.991807, 0.300435, 0, 0.038068, 0.987773, 0.296554, 0, 0.0471062, 0.982673, 0.2916, 0, 0.0566942, 0.976623, 0.285641, 0, 0.0667768, 0.968757, 0.27815, 0, 0.0773099, 0.959849, 0.269529, 0, 0.088257, 0.950663, 0.260248, 0, 0.0995879, 0.940129, 0.249704, 0, 0.111277, 0.92895, 0.238291, 0, 0.123304, 0.917996, 0.226501, 0, 0.13565, 0.907813, 0.214669, 0, 0.148299, 0.898305, 0.202835, 0, 0.161237, 0.889626, 0.191158, 0, 0.174455, 0.88175, 0.179695, 0, 0.187941, 0.874715, 0.168548, 0, 0.201687, 0.868746, 0.15792, 0, 0.215687, 0.863703, 0.147807, 0, 0.229933, 0.859315, 0.138149, 0, 0.24442, 0.855538, 0.128993, 0, 0.259145, 0.852428, 0.120414, 0, 0.274103, 0.850168, 0.112498, 0, 0.289293, 0.848132, 0.105054, 0, 0.304711, 0.846291, 0.0981087, 0, 0.320357, 0.844431, 0.0915942, 0, 0.33623, 0.842493, 0.0855056, 0, 0.35233, 0.840368, 0.0798204, 0, 0.368658, 0.83798, 0.0745097, 0, 0.385214, 0.83523, 0.0695424, 0, 0.402002, 0.832091, 0.0649092, 0, 0.419023, 0.828667, 0.0606291, 0, 0.436282, 0.824805, 0.0566523, 0, 0.453782, 0.820988, 0.0530229, 0, 0.471529, 0.816635, 0.0496364, 0, 0.489528, 0.811725, 0.0464658, 0, 0.507788, 0.806316, 0.0435082, 0, 0.526317, 0.800469, 0.0407873, 0, 0.545124, 0.794107, 0.038255, 0, 0.564221, 0.787218, 0.0358825, 0, 0.583621, 0.779872, 0.0336785, 0, 0.603341, 0.772097, 0.0316379, 0, 0.623397, 0.764484, 0.0297379, 0, 0.643812, 0.756428, 0.0279581, 0, 0.664611, 0.748022, 0.0263153, 0, 0.685824, 0.739268, 0.0247799, 0, 0.707488, 0.73024, 0.0233385, 0, 0.729646, 0.720893, 0.0220035, 0, 0.752354, 0.71119, 0.0207555, 0, 0.77568, 0.701791, 0.0195843, 0, 0.799715, 0.692184, 0.0184891, 0, 0.824574, 0.682258, 0.0174541, 0, 0.850417, 0.67206, 0.0164873, 0, 0.877466, 0.661717, 0.0155959, 0, 0.90604, 0.651462, 0.0147519, 0, 0.936528, 0.641467, 0.0139727, 0, 0.968254, 0.631229, 0.0132363, 0, 1, 1, 0.367573, 0, 0, 0.999999, 0.367571, 0, 0, 0.999984, 0.367553, 0, 183382e-9, 0.999925, 0.367473, 0, 225254e-8, 0.999759, 0.367259, 0, 628165e-8, 0.99941, 0.366801, 0, 0.0117858, 0.998739, 0.365946, 0, 0.0184359, 0.995529, 0.363191, 0, 0.0260114, 0.992875, 0.360171, 0, 0.0343581, 0.989135, 0.355981, 0, 0.0433637, 0.984166, 0.350401, 0, 0.0529438, 0.977871, 0.343348, 0, 0.0630334, 0.96951, 0.334341, 0, 0.0735805, 0.959964, 0.323862, 0, 0.0845437, 0.950162, 0.312521, 0, 0.095889, 0.938882, 0.299577, 0, 0.107588, 0.926992, 0.285573, 0, 0.119617, 0.915589, 0.271212, 0, 0.131957, 0.904791, 0.256611, 0, 0.144591, 0.895177, 0.242224, 0, 0.157503, 0.886403, 0.227952, 0, 0.170682, 0.878957, 0.214192, 0, 0.184117, 0.872418, 0.200795, 0, 0.197799, 0.867029, 0.188015, 0, 0.21172, 0.862835, 0.175975, 0, 0.225873, 0.859411, 0.164526, 0, 0.240253, 0.856655, 0.153693, 0, 0.254854, 0.854519, 0.14352, 0, 0.269673, 0.852828, 0.13397, 0, 0.284707, 0.851412, 0.124984, 0, 0.299953, 0.850609, 0.116748, 0, 0.315408, 0.849855, 0.10905, 0, 0.331073, 0.849017, 0.101839, 0, 0.346946, 0.848079, 0.0951359, 0, 0.363028, 0.846911, 0.0888774, 0, 0.379318, 0.845445, 0.0830375, 0, 0.395818, 0.84362, 0.0775844, 0, 0.41253, 0.841411, 0.0725054, 0, 0.429457, 0.838768, 0.0677691, 0, 0.446602, 0.835801, 0.0634016, 0, 0.463968, 0.832341, 0.0593095, 0, 0.481561, 0.828424, 0.0555121, 0, 0.499386, 0.824312, 0.052024, 0, 0.51745, 0.819918, 0.0487865, 0, 0.535761, 0.815072, 0.0457801, 0, 0.554328, 0.809863, 0.0430184, 0, 0.573162, 0.804164, 0.0404245, 0, 0.592275, 0.798034, 0.0380146, 0, 0.611681, 0.791436, 0.0357436, 0, 0.631398, 0.784498, 0.0336475, 0, 0.651445, 0.777125, 0.0316666, 0, 0.671845, 0.769365, 0.0298122, 0, 0.692628, 0.761579, 0.0281001, 0, 0.713827, 0.753746, 0.0265049, 0, 0.735484, 0.745573, 0.0250067, 0, 0.75765, 0.737083, 0.0236026, 0, 0.78039, 0.728545, 0.0223302, 0, 0.803789, 0.719691, 0.0211243, 0, 0.82796, 0.710569, 0.0199983, 0, 0.853056, 0.701216, 0.0189569, 0, 0.879298, 0.692094, 0.0179702, 0, 0.907014, 0.682909, 0.0170418, 0, 0.936691, 0.673509, 0.0161732, 0, 0.968254, 0.663863, 0.0153406, 0, 1, 1, 0.437395, 0, 0, 0.999998, 0.437394, 0, 0, 0.99998, 0.437363, 0, 616704e-9, 0.999891, 0.437232, 0, 367925e-8, 0.999656, 0.436877, 0, 867446e-8, 0.999148, 0.436121, 0, 0.0150679, 0.997959, 0.434564, 0, 0.022531, 0.993464, 0.430134, 0, 0.0308507, 0.990606, 0.426077, 0, 0.0398805, 0.985027, 0.419397, 0, 0.0495148, 0.978491, 0.41118, 0, 0.0596749, 0.969643, 0.40048, 0, 0.0703001, 0.959189, 0.38769, 0, 0.0813427, 0.948223, 0.373575, 0, 0.0927641, 0.935955, 0.357622, 0, 0.104533, 0.923237, 0.34043, 0, 0.116624, 0.911074, 0.322735, 0, 0.129015, 0.899724, 0.30479, 0, 0.141687, 0.890189, 0.287392, 0, 0.154626, 0.881796, 0.270248, 0, 0.167818, 0.874781, 0.253659, 0, 0.181252, 0.869166, 0.237786, 0, 0.194918, 0.864725, 0.222618, 0, 0.208807, 0.861565, 0.208356, 0, 0.222913, 0.859284, 0.194867, 0, 0.237229, 0.857677, 0.18212, 0, 0.25175, 0.856714, 0.17018, 0, 0.266473, 0.856155, 0.158969, 0, 0.281392, 0.8558, 0.148413, 0, 0.296505, 0.855672, 0.138578, 0, 0.311811, 0.855538, 0.129345, 0, 0.327306, 0.855689, 0.120861, 0, 0.342991, 0.855767, 0.112969, 0, 0.358864, 0.855618, 0.105593, 0, 0.374925, 0.85525, 0.0987451, 0, 0.391176, 0.854583, 0.0923727, 0, 0.407616, 0.853534, 0.0864143, 0, 0.424249, 0.852061, 0.0808338, 0, 0.441076, 0.850253, 0.0756771, 0, 0.4581, 0.848004, 0.0708612, 0, 0.475324, 0.845333, 0.0663784, 0, 0.492754, 0.842376, 0.0622631, 0, 0.510394, 0.838956, 0.0584112, 0, 0.528251, 0.835121, 0.0548328, 0, 0.546331, 0.830842, 0.0514838, 0, 0.564644, 0.826212, 0.048355, 0, 0.583198, 0.821522, 0.0454714, 0, 0.602005, 0.816551, 0.0428263, 0, 0.621078, 0.811211, 0.0403612, 0, 0.640434, 0.805479, 0.038039, 0, 0.660089, 0.799409, 0.0358739, 0, 0.680066, 0.79306, 0.0338727, 0, 0.70039, 0.786395, 0.0319985, 0, 0.721094, 0.779416, 0.030241, 0, 0.742215, 0.77214, 0.0285951, 0, 0.7638, 0.764636, 0.0270747, 0, 0.785912, 0.756836, 0.0256354, 0, 0.808628, 0.749315, 0.0243027, 0, 0.832055, 0.741561, 0.0230497, 0, 0.856338, 0.733589, 0.0218801, 0, 0.88169, 0.725479, 0.020784, 0, 0.908441, 0.717255, 0.0197702, 0, 0.937125, 0.708829, 0.0188168, 0, 0.968254, 0.700191, 0.0179113, 0, 1, 1, 0.518937, 0, 0, 0.999998, 0.518933, 0, 0, 0.999967, 0.518883, 0, 147741e-8, 0.999832, 0.51866, 0, 573221e-8, 0.999466, 0.518057, 0, 0.011826, 0.998644, 0.516752, 0, 0.0192116, 0.994458, 0.512347, 0, 0.027573, 0.991223, 0.507675, 0, 0.0367099, 0.985515, 0.500188, 0, 0.046487, 0.978308, 0.490408, 0, 0.0568071, 0.968359, 0.477357, 0, 0.0675984, 0.95682, 0.461752, 0, 0.0788059, 0.943929, 0.443796, 0, 0.090386, 0.930224, 0.423893, 0, 0.102304, 0.916514, 0.402682, 0, 0.114532, 0.903653, 0.380914, 0, 0.127047, 0.892315, 0.359212, 0, 0.139828, 0.882942, 0.338102, 0, 0.152861, 0.875438, 0.31773, 0, 0.16613, 0.869642, 0.298186, 0, 0.179624, 0.865304, 0.279491, 0, 0.193332, 0.862382, 0.261804, 0, 0.207247, 0.860666, 0.245146, 0, 0.22136, 0.859788, 0.229406, 0, 0.235666, 0.859608, 0.214605, 0, 0.250158, 0.859912, 0.200691, 0, 0.264832, 0.86053, 0.187623, 0, 0.279684, 0.861368, 0.17539, 0, 0.294711, 0.862237, 0.163901, 0, 0.309911, 0.863127, 0.153175, 0, 0.32528, 0.863923, 0.143147, 0, 0.340819, 0.864567, 0.133781, 0, 0.356524, 0.865013, 0.125042, 0, 0.372397, 0.86539, 0.116952, 0, 0.388438, 0.865591, 0.109476, 0, 0.404645, 0.865517, 0.102542, 0, 0.421022, 0.865084, 0.0960688, 0, 0.437569, 0.864309, 0.0900499, 0, 0.454287, 0.863151, 0.0844328, 0, 0.471181, 0.861649, 0.0792218, 0, 0.488253, 0.859742, 0.0743482, 0, 0.505507, 0.857446, 0.0697963, 0, 0.522947, 0.854757, 0.0655364, 0, 0.54058, 0.851783, 0.061608, 0, 0.558412, 0.848516, 0.0579701, 0, 0.576449, 0.844897, 0.0545742, 0, 0.594701, 0.840956, 0.0514167, 0, 0.613178, 0.836676, 0.0484598, 0, 0.631892, 0.832075, 0.0456934, 0, 0.650856, 0.827191, 0.0431178, 0, 0.670088, 0.822295, 0.0407718, 0, 0.689606, 0.817294, 0.0386032, 0, 0.709434, 0.812013, 0.0365675, 0, 0.7296, 0.806465, 0.0346547, 0, 0.750138, 0.800691, 0.0328717, 0, 0.771093, 0.794709, 0.031211, 0, 0.792519, 0.788493, 0.0296504, 0, 0.814488, 0.782049, 0.0281782, 0, 0.837097, 0.775403, 0.0267965, 0, 0.860481, 0.76857, 0.0255002, 0, 0.884842, 0.761536, 0.0242759, 0, 0.910494, 0.754303, 0.0231142, 0, 0.937985, 0.74692, 0.0220305, 0, 0.968254, 0.739745, 0.0210192, 0, 1, 1, 0.613914, 0, 0, 0.999996, 0.613907, 0, 963597e-10, 0.999942, 0.613814, 0, 301247e-8, 0.999704, 0.613407, 0, 870385e-8, 0.999046, 0.612302, 0, 0.0160714, 0.995516, 0.608266, 0, 0.0245899, 0.991726, 0.602863, 0, 0.0339681, 0.985157, 0.593956, 0, 0.0440254, 0.97642, 0.581748, 0, 0.0546409, 0.964404, 0.565183, 0, 0.0657284, 0.950601, 0.545273, 0, 0.0772246, 0.935158, 0.522129, 0, 0.0890812, 0.919364, 0.496782, 0, 0.10126, 0.904754, 0.470571, 0, 0.113731, 0.89176, 0.444037, 0, 0.126469, 0.881492, 0.418322, 0, 0.139454, 0.873656, 0.393522, 0, 0.15267, 0.868053, 0.369795, 0, 0.166101, 0.864336, 0.347171, 0, 0.179736, 0.862259, 0.325737, 0, 0.193565, 0.861556, 0.305532, 0, 0.207578, 0.861776, 0.286416, 0, 0.221769, 0.862661, 0.268355, 0, 0.23613, 0.864015, 0.251334, 0, 0.250656, 0.865711, 0.235352, 0, 0.265343, 0.867519, 0.220302, 0, 0.280187, 0.869351, 0.206161, 0, 0.295183, 0.871144, 0.192908, 0, 0.31033, 0.872839, 0.180505, 0, 0.325624, 0.874307, 0.168848, 0, 0.341065, 0.875667, 0.158021, 0, 0.35665, 0.876758, 0.147877, 0, 0.37238, 0.87764, 0.138441, 0, 0.388253, 0.878237, 0.129627, 0, 0.404269, 0.878563, 0.121415, 0, 0.42043, 0.878572, 0.113741, 0, 0.436735, 0.87842, 0.106652, 0, 0.453187, 0.878057, 0.100097, 0, 0.469786, 0.877413, 0.0940128, 0, 0.486536, 0.87646, 0.0883462, 0, 0.503439, 0.875233, 0.0830924, 0, 0.520498, 0.8737, 0.0781975, 0, 0.537717, 0.871873, 0.07364, 0, 0.555102, 0.86978, 0.0694103, 0, 0.572657, 0.867405, 0.0654696, 0, 0.59039, 0.864751, 0.0617914, 0, 0.608307, 0.861818, 0.0583491, 0, 0.626419, 0.858645, 0.0551443, 0, 0.644733, 0.855307, 0.0521894, 0, 0.663264, 0.851736, 0.0494334, 0, 0.682025, 0.847927, 0.0468504, 0, 0.701032, 0.843888, 0.0444261, 0, 0.720308, 0.839629, 0.0421497, 0, 0.739875, 0.835158, 0.0400082, 0, 0.759764, 0.830509, 0.0380076, 0, 0.780014, 0.825714, 0.0361488, 0, 0.800673, 0.820729, 0.0343956, 0, 0.821803, 0.815751, 0.0327781, 0, 0.843492, 0.810752, 0.031275, 0, 0.86586, 0.805587, 0.0298542, 0, 0.889087, 0.800317, 0.0285397, 0, 0.913466, 0.79489, 0.0272948, 0, 0.93952, 0.789314, 0.0261139, 0, 0.96835, 0.783593, 0.0249938, 0, 1, 1, 0.724258, 0, 0, 0.999992, 0.724243, 0, 726889e-9, 0.99987, 0.724044, 0, 569574e-8, 0.999336, 0.72317, 0, 0.0131702, 0.996271, 0.719432, 0, 0.0220738, 0.991159, 0.712576, 0, 0.0319405, 0.982465, 0.700927, 0, 0.0425202, 0.97049, 0.684297, 0, 0.0536599, 0.953973, 0.661244, 0, 0.065258, 0.935546, 0.633804, 0, 0.0772427, 0.916596, 0.603071, 0, 0.0895616, 0.899353, 0.57105, 0, 0.102175, 0.885216, 0.539206, 0, 0.11505, 0.875076, 0.508714, 0, 0.128164, 0.868334, 0.479571, 0, 0.141495, 0.864414, 0.451796, 0, 0.155026, 0.862678, 0.425328, 0, 0.168745, 0.862835, 0.400352, 0, 0.182639, 0.864067, 0.376532, 0, 0.196699, 0.866086, 0.35391, 0, 0.210915, 0.868557, 0.332424, 0, 0.225282, 0.871271, 0.312053, 0, 0.239792, 0.874058, 0.292764, 0, 0.25444, 0.8768, 0.27453, 0, 0.269223, 0.87939, 0.257297, 0, 0.284135, 0.8819, 0.24114, 0, 0.299174, 0.884187, 0.225934, 0, 0.314337, 0.886262, 0.211669, 0, 0.329622, 0.888119, 0.198311, 0, 0.345026, 0.889709, 0.185783, 0, 0.360549, 0.891054, 0.174063, 0, 0.376189, 0.892196, 0.163143, 0, 0.391946, 0.893101, 0.152952, 0, 0.407819, 0.893803, 0.143475, 0, 0.423808, 0.894277, 0.134647, 0, 0.439914, 0.894532, 0.126434, 0, 0.456137, 0.894576, 0.1188, 0, 0.472479, 0.894393, 0.111694, 0, 0.48894, 0.893976, 0.105069, 0, 0.505523, 0.893346, 0.0989077, 0, 0.52223, 0.892502, 0.0931724, 0, 0.539064, 0.891441, 0.0878276, 0, 0.556028, 0.890276, 0.082903, 0, 0.573125, 0.888972, 0.0783505, 0, 0.590361, 0.887469, 0.0741083, 0, 0.607741, 0.885785, 0.0701633, 0, 0.62527, 0.883914, 0.0664835, 0, 0.642957, 0.881872, 0.0630567, 0, 0.660809, 0.879651, 0.0598527, 0, 0.678836, 0.877267, 0.0568615, 0, 0.69705, 0.874717, 0.05406, 0, 0.715465, 0.872012, 0.0514378, 0, 0.734098, 0.869157, 0.0489805, 0, 0.752968, 0.866155, 0.0466727, 0, 0.772101, 0.863014, 0.0445056, 0, 0.791529, 0.859748, 0.0424733, 0, 0.81129, 0.856416, 0.0405957, 0, 0.831438, 0.852958, 0.0388273, 0, 0.852044, 0.849382, 0.0371619, 0, 0.87321, 0.845694, 0.0355959, 0, 0.89509, 0.841893, 0.0341155, 0, 0.917932, 0.837981, 0.0327141, 0, 0.942204, 0.833963, 0.0313856, 0, 0.968981, 0.829847, 0.0301275, 0, 1, 1, 0.85214, 0, 0, 0.999969, 0.852095, 0, 279627e-8, 0.999483, 0.851408, 0, 0.0107635, 0.994545, 0.84579, 0, 0.0206454, 0.986188, 0.835231, 0, 0.0315756, 0.969847, 0.814687, 0, 0.0432021, 0.945951, 0.783735, 0, 0.0553396, 0.91917, 0.746074, 0, 0.0678766, 0.895488, 0.706938, 0, 0.0807395, 0.878232, 0.669534, 0, 0.0938767, 0.868252, 0.635168, 0, 0.10725, 0.863873, 0.603069, 0, 0.120832, 0.863369, 0.572514, 0, 0.134598, 0.86545, 0.543169, 0, 0.148533, 0.868803, 0.514578, 0, 0.16262, 0.872794, 0.486762, 0, 0.176849, 0.87702, 0.459811, 0, 0.19121, 0.881054, 0.433654, 0, 0.205694, 0.884974, 0.408574, 0, 0.220294, 0.888587, 0.384525, 0, 0.235005, 0.891877, 0.36156, 0, 0.24982, 0.894793, 0.339661, 0, 0.264737, 0.89743, 0.318913, 0, 0.279751, 0.899796, 0.299302, 0, 0.294859, 0.901943, 0.280843, 0, 0.310058, 0.903858, 0.263481, 0, 0.325346, 0.905574, 0.247197, 0, 0.340721, 0.907069, 0.231915, 0, 0.356181, 0.908379, 0.217614, 0, 0.371725, 0.90952, 0.20425, 0, 0.387353, 0.910483, 0.191758, 0, 0.403063, 0.91128, 0.180092, 0, 0.418854, 0.911936, 0.169222, 0, 0.434727, 0.912454, 0.159098, 0, 0.450682, 0.912835, 0.149668, 0, 0.466718, 0.913078, 0.140884, 0, 0.482837, 0.913192, 0.132709, 0, 0.499038, 0.913175, 0.125095, 0, 0.515324, 0.91304, 0.118012, 0, 0.531695, 0.912781, 0.111417, 0, 0.548153, 0.91241, 0.105281, 0, 0.5647, 0.911924, 0.0995691, 0, 0.581338, 0.911331, 0.0942531, 0, 0.59807, 0.910637, 0.0893076, 0, 0.6149, 0.90984, 0.0846998, 0, 0.63183, 0.908941, 0.0804044, 0, 0.648865, 0.907944, 0.0763984, 0, 0.666011, 0.906857, 0.0726638, 0, 0.683273, 0.90568, 0.0691783, 0, 0.700659, 0.904416, 0.0659222, 0, 0.718176, 0.903067, 0.0628782, 0, 0.735834, 0.901637, 0.0600307, 0, 0.753646, 0.900128, 0.0573647, 0, 0.771625, 0.898544, 0.0548668, 0, 0.78979, 0.89689, 0.052527, 0, 0.808162, 0.895165, 0.0503306, 0, 0.826771, 0.893371, 0.0482668, 0, 0.845654, 0.891572, 0.0463605, 0, 0.864863, 0.889763, 0.0445998, 0, 0.884472, 0.887894, 0.0429451, 0, 0.904592, 0.885967, 0.0413884, 0, 0.925407, 0.883984, 0.0399225, 0, 0.947271, 0.881945, 0.0385405, 0, 0.97105, 0.879854, 0.0372362, 0, 1, 0.999804, 0.995833, 0, 0, 0.938155, 0.933611, 0, 0.0158731, 0.864755, 0.854311, 0, 0.0317461, 0.888594, 0.865264, 0, 0.0476191, 0.905575, 0.863922, 0, 0.0634921, 0.915125, 0.850558, 0, 0.0793651, 0.920665, 0.829254, 0, 0.0952381, 0.924073, 0.802578, 0, 0.111111, 0.926304, 0.772211, 0, 0.126984, 0.927829, 0.739366, 0, 0.142857, 0.928924, 0.705033, 0, 0.15873, 0.92973, 0.670019, 0, 0.174603, 0.930339, 0.634993, 0, 0.190476, 0.930811, 0.600485, 0, 0.206349, 0.931191, 0.566897, 0, 0.222222, 0.93149, 0.534485, 0, 0.238095, 0.931737, 0.503429, 0, 0.253968, 0.931939, 0.473811, 0, 0.269841, 0.932108, 0.445668, 0, 0.285714, 0.93225, 0.418993, 0, 0.301587, 0.932371, 0.393762, 0, 0.31746, 0.932474, 0.369939, 0, 0.333333, 0.932562, 0.347479, 0, 0.349206, 0.932638, 0.326336, 0, 0.365079, 0.932703, 0.306462, 0, 0.380952, 0.93276, 0.287805, 0, 0.396825, 0.932809, 0.270313, 0, 0.412698, 0.932851, 0.253933, 0, 0.428571, 0.932887, 0.23861, 0, 0.444444, 0.932917, 0.224289, 0, 0.460317, 0.932943, 0.210917, 0, 0.47619, 0.932965, 0.19844, 0, 0.492063, 0.932982, 0.186807, 0, 0.507937, 0.932995, 0.175966, 0, 0.52381, 0.933005, 0.165869, 0, 0.539683, 0.933011, 0.156468, 0, 0.555556, 0.933013, 0.147719, 0, 0.571429, 0.933013, 0.139579, 0, 0.587302, 0.93301, 0.132007, 0, 0.603175, 0.933004, 0.124965, 0, 0.619048, 0.932994, 0.118416, 0, 0.634921, 0.932982, 0.112326, 0, 0.650794, 0.932968, 0.106663, 0, 0.666667, 0.93295, 0.101397, 0, 0.68254, 0.932931, 0.0964993, 0, 0.698413, 0.932908, 0.0919438, 0, 0.714286, 0.932883, 0.0877057, 0, 0.730159, 0.932856, 0.0837623, 0, 0.746032, 0.932827, 0.0800921, 0, 0.761905, 0.932796, 0.0766754, 0, 0.777778, 0.932762, 0.0734936, 0, 0.793651, 0.932727, 0.0705296, 0, 0.809524, 0.932689, 0.0677676, 0, 0.825397, 0.93265, 0.0651929, 0, 0.84127, 0.932609, 0.0627917, 0, 0.857143, 0.932565, 0.0605515, 0, 0.873016, 0.932521, 0.0584606, 0, 0.888889, 0.932474, 0.0565082, 0, 0.904762, 0.932427, 0.0546841, 0, 0.920635, 0.932377, 0.0529793, 0, 0.936508, 0.932326, 0.0513851, 0, 0.952381, 0.932274, 0.0498936, 0, 0.968254, 0.93222, 0.0484975, 0, 0.984127, 0.932164, 0.0471899, 0, 1], i = new Float32Array(e), o = new Float32Array(n), a = new cs(i, 64, 64, Sn, Vn, Zo, pi, pi, Dt, xn, 1), r = new cs(o, 64, 64, Sn, Vn, Zo, pi, pi, Dt, xn, 1);
    a.needsUpdate = !0, r.needsUpdate = !0;
    const l = new Uint16Array(e.length);
    e.forEach(function(h, p) {
      l[p] = Ep.toHalfFloat(h);
    });
    const c = new Uint16Array(n.length);
    n.forEach(function(h, p) {
      c[p] = Ep.toHalfFloat(h);
    });
    const u = new cs(l, 64, 64, Sn, gi, Zo, pi, pi, Dt, xn, 1), d = new cs(c, 64, 64, Sn, gi, Zo, pi, pi, Dt, xn, 1);
    return u.needsUpdate = !0, d.needsUpdate = !0, this.LTC_HALF_1 = u, this.LTC_HALF_2 = d, this.LTC_FLOAT_1 = a, this.LTC_FLOAT_2 = r, this;
  }
}
ba.LTC_HALF_1 = null;
ba.LTC_HALF_1 = null;
ba.LTC_FLOAT_1 = null;
ba.LTC_FLOAT_2 = null;
class BN {
  static init() {
    ba.init();
    const { LTC_FLOAT_1: e, LTC_FLOAT_2: n, LTC_HALF_1: i, LTC_HALF_2: o } = ba;
    nt.LTC_FLOAT_1 = e, nt.LTC_FLOAT_2 = n, nt.LTC_HALF_1 = i, nt.LTC_HALF_2 = o;
  }
}
let o9 = !1;
function NN() {
  o9 || (BN.init(), o9 = !0);
}
function Jl(s) {
  const e = s / 100;
  let n, i, o;
  return e <= 66 ? n = 255 : (n = e - 60, n = 329.698727446 * Math.pow(n, -0.1332047592), n = Math.max(0, Math.min(255, n))), e <= 66 ? (i = e, i = 99.4708025861 * Math.log(i) - 161.1195681661) : (i = e - 60, i = 288.1221695283 * Math.pow(i, -0.0755148492)), i = Math.max(0, Math.min(255, i)), e >= 66 ? o = 255 : e <= 19 ? o = 0 : (o = e - 10, o = 138.5177312231 * Math.log(o) - 305.0447927307, o = Math.max(0, Math.min(255, o))), { r: n / 255, g: i / 255, b: o / 255 };
}
class VN extends $i {
  constructor(n) {
    super(n);
    le(this, "light");
    le(this, "helper", null);
    le(this, "lightData");
    // Point of Interest
    le(this, "poiTarget", new pe());
    le(this, "smoothedPOI", new pe());
    // Path following callback (set by LayerManager)
    le(this, "pathProvider", null);
    // Layer position getter for POI layer tracking
    le(this, "layerPositionGetter", null);
    this.lightData = this.extractLightData(n), this.light = this.createLight(), this.group.add(this.light), this.createHelper(), this.lightData.pointOfInterest.enabled && this.updatePointOfInterest(0), this.initializeBlendMode();
  }
  // ============================================================================
  // DATA EXTRACTION
  // ============================================================================
  extractLightData(n) {
    var o, a, r, l, c, u, d, h, p, f, m, y, g, x, w, M, _, C, T, P, E, b, S;
    const i = n.data;
    return {
      lightType: (i == null ? void 0 : i.lightType) ?? "point",
      color: (i == null ? void 0 : i.color) ?? "#ffffff",
      colorTemperature: i == null ? void 0 : i.colorTemperature,
      useColorTemperature: (i == null ? void 0 : i.useColorTemperature) ?? !1,
      intensity: (i == null ? void 0 : i.intensity) ?? 100,
      physicalIntensity: i == null ? void 0 : i.physicalIntensity,
      usePhysicalIntensity: (i == null ? void 0 : i.usePhysicalIntensity) ?? !1,
      radius: (i == null ? void 0 : i.radius) ?? 500,
      falloff: (i == null ? void 0 : i.falloff) ?? "none",
      falloffDistance: (i == null ? void 0 : i.falloffDistance) ?? 500,
      coneAngle: (i == null ? void 0 : i.coneAngle) ?? 90,
      coneFeather: (i == null ? void 0 : i.coneFeather) ?? 50,
      areaWidth: (i == null ? void 0 : i.areaWidth) ?? 100,
      areaHeight: (i == null ? void 0 : i.areaHeight) ?? 100,
      pointOfInterest: {
        enabled: ((o = i == null ? void 0 : i.pointOfInterest) == null ? void 0 : o.enabled) ?? !1,
        targetType: ((a = i == null ? void 0 : i.pointOfInterest) == null ? void 0 : a.targetType) ?? "position",
        position: ((r = i == null ? void 0 : i.pointOfInterest) == null ? void 0 : r.position) ?? {
          id: "poi_pos",
          name: "POI Position",
          type: "vector3",
          value: { x: 0, y: 0, z: 0 },
          animated: !1,
          keyframes: []
        },
        targetLayerId: (l = i == null ? void 0 : i.pointOfInterest) == null ? void 0 : l.targetLayerId,
        offset: ((c = i == null ? void 0 : i.pointOfInterest) == null ? void 0 : c.offset) ?? { x: 0, y: 0, z: 0 },
        smoothing: ((u = i == null ? void 0 : i.pointOfInterest) == null ? void 0 : u.smoothing) ?? 0
      },
      pathFollowing: {
        enabled: ((d = i == null ? void 0 : i.pathFollowing) == null ? void 0 : d.enabled) ?? !1,
        splineLayerId: (h = i == null ? void 0 : i.pathFollowing) == null ? void 0 : h.splineLayerId,
        progress: ((p = i == null ? void 0 : i.pathFollowing) == null ? void 0 : p.progress) ?? {
          id: "path_progress",
          name: "Path Progress",
          type: "number",
          value: 0,
          animated: !1,
          keyframes: []
        },
        autoOrient: ((f = i == null ? void 0 : i.pathFollowing) == null ? void 0 : f.autoOrient) ?? !0,
        bankAngle: ((m = i == null ? void 0 : i.pathFollowing) == null ? void 0 : m.bankAngle) ?? {
          id: "bank_angle",
          name: "Bank Angle",
          type: "number",
          value: 0,
          animated: !1,
          keyframes: []
        }
      },
      shadow: {
        enabled: ((y = i == null ? void 0 : i.shadow) == null ? void 0 : y.enabled) ?? (i == null ? void 0 : i.castShadows) ?? !1,
        type: ((g = i == null ? void 0 : i.shadow) == null ? void 0 : g.type) ?? "pcf",
        mapSize: ((x = i == null ? void 0 : i.shadow) == null ? void 0 : x.mapSize) ?? 1024,
        darkness: ((w = i == null ? void 0 : i.shadow) == null ? void 0 : w.darkness) ?? (i == null ? void 0 : i.shadowDarkness) ?? 100,
        radius: ((M = i == null ? void 0 : i.shadow) == null ? void 0 : M.radius) ?? (i == null ? void 0 : i.shadowDiffusion) ?? 1,
        bias: ((_ = i == null ? void 0 : i.shadow) == null ? void 0 : _.bias) ?? -1e-4,
        normalBias: ((C = i == null ? void 0 : i.shadow) == null ? void 0 : C.normalBias) ?? 0,
        cameraNear: ((T = i == null ? void 0 : i.shadow) == null ? void 0 : T.cameraNear) ?? 1,
        cameraFar: ((P = i == null ? void 0 : i.shadow) == null ? void 0 : P.cameraFar) ?? 1e3,
        cameraSize: ((E = i == null ? void 0 : i.shadow) == null ? void 0 : E.cameraSize) ?? 500
      },
      lightLinking: {
        mode: ((b = i == null ? void 0 : i.lightLinking) == null ? void 0 : b.mode) ?? "include",
        layers: ((S = i == null ? void 0 : i.lightLinking) == null ? void 0 : S.layers) ?? []
      },
      animatedIntensity: i == null ? void 0 : i.animatedIntensity,
      animatedConeAngle: i == null ? void 0 : i.animatedConeAngle,
      animatedColor: i == null ? void 0 : i.animatedColor,
      animatedColorTemperature: i == null ? void 0 : i.animatedColorTemperature
    };
  }
  // ============================================================================
  // LIGHT CREATION
  // ============================================================================
  createLight() {
    const n = this.getEffectiveColor(), i = this.getEffectiveIntensity();
    switch (this.lightData.lightType) {
      case "point": {
        const o = new zs(n, i);
        return o.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, o.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, this.configureShadows(o), o;
      }
      case "spot": {
        const o = new Si(n, i);
        return o.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, o.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, o.angle = ln.degToRad((this.lightData.coneAngle ?? 90) / 2), o.penumbra = (this.lightData.coneFeather ?? 50) / 100, this.configureShadows(o), o;
      }
      case "parallel": {
        const o = new ws(n, i);
        return this.configureShadows(o), o;
      }
      case "ambient":
        return new Nm(n, i);
      case "area":
        return NN(), new g2(
          n,
          i,
          this.lightData.areaWidth ?? 100,
          this.lightData.areaHeight ?? 100
        );
      default:
        return fi.warn(`LightLayer: Unknown light type: ${this.lightData.lightType}, defaulting to point`), new zs(n, i);
    }
  }
  getEffectiveColor() {
    if (this.lightData.useColorTemperature && this.lightData.colorTemperature) {
      const n = Jl(this.lightData.colorTemperature);
      return new Mt(n.r, n.g, n.b);
    }
    return new Mt(this.lightData.color);
  }
  getEffectiveIntensity() {
    return this.lightData.usePhysicalIntensity && this.lightData.physicalIntensity ? this.lightData.physicalIntensity / 100 : this.lightData.intensity / 100;
  }
  // ============================================================================
  // SHADOW CONFIGURATION
  // ============================================================================
  configureShadows(n) {
    const i = this.lightData.shadow;
    if (n.castShadow = i.enabled, !!n.castShadow) {
      switch (n.shadow.mapSize.width = i.mapSize, n.shadow.mapSize.height = i.mapSize, i.type) {
        case "basic":
          break;
        case "pcf":
          n.shadow.radius = 1;
          break;
        case "pcfSoft":
          n.shadow.radius = i.radius;
          break;
        case "vsm":
          n.shadow.radius = i.radius;
          break;
      }
      if (n.shadow.bias = i.bias, n.shadow.normalBias = i.normalBias, n instanceof ws) {
        const o = n.shadow.camera;
        o.near = i.cameraNear, o.far = i.cameraFar, o.left = -i.cameraSize / 2, o.right = i.cameraSize / 2, o.top = i.cameraSize / 2, o.bottom = -i.cameraSize / 2, o.updateProjectionMatrix();
      } else n instanceof Si && (n.shadow.camera.near = i.cameraNear, n.shadow.camera.far = i.cameraFar, n.shadow.camera.updateProjectionMatrix());
    }
  }
  // ============================================================================
  // HELPER VISUALIZATION
  // ============================================================================
  createHelper() {
    switch (this.helper && (this.group.remove(this.helper), this.helper.dispose && this.helper.dispose()), this.lightData.lightType) {
      case "point": {
        const n = new w2(this.light, this.lightData.radius / 10);
        this.helper = n, this.group.add(n);
        break;
      }
      case "spot": {
        const n = new Ya(this.light);
        this.helper = n, this.group.add(n);
        break;
      }
      case "parallel": {
        const n = new C2(this.light, 50);
        this.helper = n, this.group.add(n);
        break;
      }
      case "area": {
        const n = new zN(this.light);
        this.helper = n, this.group.add(n);
        break;
      }
    }
  }
  // ============================================================================
  // POINT OF INTEREST
  // ============================================================================
  /**
   * Set callback for getting layer positions (for POI layer tracking)
   */
  setLayerPositionGetter(n) {
    this.layerPositionGetter = n;
  }
  /**
   * Update point of interest target
   */
  updatePointOfInterest(n) {
    const i = this.lightData.pointOfInterest;
    if (i.enabled && !(this.lightData.lightType !== "spot" && this.lightData.lightType !== "parallel")) {
      if (i.targetType === "layer" && i.targetLayerId && this.layerPositionGetter) {
        const o = this.layerPositionGetter(i.targetLayerId);
        o && (this.poiTarget.copy(o), this.poiTarget.x += i.offset.x, this.poiTarget.y += i.offset.y, this.poiTarget.z += i.offset.z);
      } else {
        const o = this.evaluator.evaluate(i.position, n);
        this.poiTarget.set(o.x, o.y, o.z);
      }
      i.smoothing > 0 ? this.smoothedPOI.lerp(this.poiTarget, 1 - i.smoothing) : this.smoothedPOI.copy(this.poiTarget), this.light instanceof Si ? (this.light.target.position.copy(this.smoothedPOI), this.light.target.updateMatrixWorld()) : this.light instanceof ws && (this.light.target.position.copy(this.smoothedPOI), this.light.target.updateMatrixWorld());
    }
  }
  // ============================================================================
  // PATH FOLLOWING
  // ============================================================================
  /**
   * Set path provider callback (from LayerManager's spline provider)
   */
  setPathProvider(n) {
    this.pathProvider = n;
  }
  /**
   * Update position and orientation from path
   */
  updatePathFollowing(n) {
    const i = this.lightData.pathFollowing;
    if (!i.enabled || !i.splineLayerId || !this.pathProvider) return;
    const o = this.evaluator.evaluate(i.progress, n), a = this.pathProvider(i.splineLayerId, o, n);
    if (a && (this.group.position.set(a.point.x, -a.point.y, a.point.z), i.autoOrient)) {
      const r = Math.atan2(a.tangent.y, a.tangent.x);
      this.group.rotation.z = -r;
      const l = this.evaluator.evaluate(i.bankAngle, n);
      this.group.rotation.x = ln.degToRad(l);
    }
  }
  // ============================================================================
  // PUBLIC SETTERS
  // ============================================================================
  setLightType(n) {
    n !== this.lightData.lightType && (this.lightData.lightType = n, this.group.remove(this.light), this.light.dispose && this.light.dispose(), this.light = this.createLight(), this.group.add(this.light), this.createHelper());
  }
  setColor(n) {
    this.lightData.color = n, this.lightData.useColorTemperature = !1, this.light.color.set(n);
  }
  setColorTemperature(n) {
    this.lightData.colorTemperature = n, this.lightData.useColorTemperature = !0;
    const i = Jl(n);
    this.light.color.setRGB(i.r, i.g, i.b);
  }
  setIntensity(n) {
    this.lightData.intensity = n, this.lightData.usePhysicalIntensity = !1, this.light.intensity = n / 100;
  }
  setFalloffDistance(n) {
    this.lightData.falloffDistance = n, (this.light instanceof zs || this.light instanceof Si) && (this.light.distance = this.lightData.falloff === "none" ? 0 : n);
  }
  setConeAngle(n) {
    this.light instanceof Si && (this.lightData.coneAngle = n, this.light.angle = ln.degToRad(n / 2), this.helper instanceof Ya && this.helper.update());
  }
  setConeFeather(n) {
    this.light instanceof Si && (this.lightData.coneFeather = n, this.light.penumbra = n / 100);
  }
  setAreaSize(n, i) {
    this.light instanceof g2 && (this.lightData.areaWidth = n, this.lightData.areaHeight = i, this.light.width = n, this.light.height = i);
  }
  setShadowEnabled(n) {
    this.lightData.shadow.enabled = n, (this.light instanceof zs || this.light instanceof Si || this.light instanceof ws) && (this.light.castShadow = n);
  }
  setShadowType(n) {
    this.lightData.shadow.type = n, (this.light instanceof zs || this.light instanceof Si || this.light instanceof ws) && this.configureShadows(this.light);
  }
  setPointOfInterestEnabled(n) {
    this.lightData.pointOfInterest.enabled = n;
  }
  setPointOfInterestTarget(n) {
    n ? (this.lightData.pointOfInterest.targetType = "layer", this.lightData.pointOfInterest.targetLayerId = n) : (this.lightData.pointOfInterest.targetType = "position", this.lightData.pointOfInterest.targetLayerId = void 0);
  }
  setPathFollowingEnabled(n) {
    this.lightData.pathFollowing.enabled = n;
  }
  setPathSpline(n) {
    this.lightData.pathFollowing.splineLayerId = n ?? void 0;
  }
  // ============================================================================
  // DRIVER PROPERTY ACCESS
  // ============================================================================
  /**
   * Get a light property value by driver property path
   * Used by PropertyDriverSystem for property-to-property linking
   */
  getDriverPropertyValue(n) {
    switch (n) {
      case "light.intensity":
        return this.lightData.intensity;
      case "light.color.r":
        return this.light.color.r * 255;
      case "light.color.g":
        return this.light.color.g * 255;
      case "light.color.b":
        return this.light.color.b * 255;
      case "light.colorTemperature":
        return this.lightData.colorTemperature ?? 6500;
      case "light.coneAngle":
        return this.lightData.coneAngle ?? 90;
      case "light.penumbra":
        return this.lightData.coneFeather ?? 50;
      case "light.falloff":
        return this.lightData.falloffDistance;
      case "light.shadow.intensity":
        return this.lightData.shadow.darkness;
      case "light.shadow.softness":
        return this.lightData.shadow.radius;
      case "light.shadow.bias":
        return this.lightData.shadow.bias * 1e4;
      case "light.poi.x":
        return this.poiTarget.x;
      case "light.poi.y":
        return this.poiTarget.y;
      case "light.poi.z":
        return this.poiTarget.z;
      case "light.areaSize.width":
        return this.lightData.areaWidth ?? 100;
      case "light.areaSize.height":
        return this.lightData.areaHeight ?? 100;
      case "light.physicalIntensity":
        return this.lightData.physicalIntensity ?? this.lightData.intensity * 100;
      default:
        return null;
    }
  }
  /**
   * Set a light property value by driver property path
   * Used by PropertyDriverSystem for driven values
   */
  setDriverPropertyValue(n, i) {
    switch (n) {
      case "light.intensity":
        this.light.intensity = i / 100, this.lightData.intensity = i;
        break;
      case "light.color.r":
        this.light.color.r = Math.max(0, Math.min(1, i / 255));
        break;
      case "light.color.g":
        this.light.color.g = Math.max(0, Math.min(1, i / 255));
        break;
      case "light.color.b":
        this.light.color.b = Math.max(0, Math.min(1, i / 255));
        break;
      case "light.colorTemperature":
        this.setColorTemperature(i);
        break;
      case "light.coneAngle":
        this.setConeAngle(i);
        break;
      case "light.penumbra":
        this.setConeFeather(i);
        break;
      case "light.falloff":
        this.setFalloffDistance(i);
        break;
      case "light.shadow.intensity":
        this.lightData.shadow.darkness = i;
        break;
      case "light.shadow.softness":
        this.lightData.shadow.radius = i, (this.light instanceof zs || this.light instanceof Si || this.light instanceof ws) && (this.light.shadow.radius = i);
        break;
      case "light.shadow.bias":
        this.lightData.shadow.bias = i / 1e4, (this.light instanceof zs || this.light instanceof Si || this.light instanceof ws) && (this.light.shadow.bias = i / 1e4);
        break;
      case "light.poi.x":
        this.poiTarget.x = i, this.updatePointOfInterest(0);
        break;
      case "light.poi.y":
        this.poiTarget.y = i, this.updatePointOfInterest(0);
        break;
      case "light.poi.z":
        this.poiTarget.z = i, this.updatePointOfInterest(0);
        break;
      case "light.areaSize.width":
        this.setAreaSize(i, this.lightData.areaHeight ?? 100);
        break;
      case "light.areaSize.height":
        this.setAreaSize(this.lightData.areaWidth ?? 100, i);
        break;
      case "light.physicalIntensity":
        this.lightData.physicalIntensity = i, this.lightData.usePhysicalIntensity && (this.light.intensity = i / 100);
        break;
    }
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getLight() {
    return this.light;
  }
  getLightData() {
    return { ...this.lightData };
  }
  getLightLinking() {
    return { ...this.lightData.lightLinking };
  }
  /**
   * Check if this light should affect a given layer
   */
  shouldAffectLayer(n) {
    const i = this.lightData.lightLinking;
    if (i.layers.length === 0)
      return !0;
    const o = i.layers.includes(n);
    return i.mode === "include" ? o : !o;
  }
  setHelperVisible(n) {
    this.helper && (this.helper.visible = n);
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    var i, o, a, r;
    if (this.lightData.pathFollowing.enabled && this.updatePathFollowing(n), this.lightData.pointOfInterest.enabled && this.updatePointOfInterest(n), (i = this.lightData.animatedIntensity) != null && i.animated) {
      const l = this.evaluator.evaluate(this.lightData.animatedIntensity, n);
      this.light.intensity = l / 100;
    }
    if ((o = this.lightData.animatedConeAngle) != null && o.animated && this.light instanceof Si) {
      const l = this.evaluator.evaluate(this.lightData.animatedConeAngle, n);
      this.light.angle = ln.degToRad(l / 2), this.helper instanceof Ya && this.helper.update();
    }
    if ((a = this.lightData.animatedColor) != null && a.animated) {
      const l = this.evaluator.evaluate(this.lightData.animatedColor, n);
      this.light.color.set(l);
    }
    if ((r = this.lightData.animatedColorTemperature) != null && r.animated && this.lightData.useColorTemperature) {
      const l = this.evaluator.evaluate(this.lightData.animatedColorTemperature, n), c = Jl(l);
      this.light.color.setRGB(c.r, c.g, c.b);
    }
    this.helper && (this.helper instanceof w2 || this.helper instanceof Ya || this.helper instanceof C2) && this.helper.update();
  }
  onApplyEvaluatedState(n) {
    const i = n.properties;
    if (i.intensity !== void 0 && (this.light.intensity = i.intensity / 100), i.coneAngle !== void 0 && this.light instanceof Si && (this.light.angle = ln.degToRad(i.coneAngle / 2), this.helper instanceof Ya && this.helper.update()), i.color !== void 0 && this.light.color.set(i.color), i.colorTemperature !== void 0 && this.lightData.useColorTemperature) {
      const o = Jl(i.colorTemperature);
      this.light.color.setRGB(o.r, o.g, o.b);
    }
    i.falloffDistance !== void 0 && (this.light instanceof zs || this.light instanceof Si) && (this.light.distance = this.lightData.falloff === "none" ? 0 : i.falloffDistance), (i["poi.x"] !== void 0 || i["poi.y"] !== void 0 || i["poi.z"] !== void 0) && (this.poiTarget.set(
      i["poi.x"] ?? this.poiTarget.x,
      i["poi.y"] ?? this.poiTarget.y,
      i["poi.z"] ?? this.poiTarget.z
    ), this.updatePointOfInterest(0));
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.lightType !== void 0 && i.lightType !== this.lightData.lightType && this.setLightType(i.lightType), i.color !== void 0 && this.setColor(i.color), i.colorTemperature !== void 0 && this.setColorTemperature(i.colorTemperature), i.intensity !== void 0 && this.setIntensity(i.intensity), i.falloffDistance !== void 0 && this.setFalloffDistance(i.falloffDistance), i.falloff !== void 0 && (this.lightData.falloff = i.falloff, this.setFalloffDistance(this.lightData.falloffDistance)), i.coneAngle !== void 0 && this.setConeAngle(i.coneAngle), i.coneFeather !== void 0 && this.setConeFeather(i.coneFeather), (i.areaWidth !== void 0 || i.areaHeight !== void 0) && this.setAreaSize(
      i.areaWidth ?? this.lightData.areaWidth ?? 100,
      i.areaHeight ?? this.lightData.areaHeight ?? 100
    ), i.shadow !== void 0 && (Object.assign(this.lightData.shadow, i.shadow), (this.light instanceof zs || this.light instanceof Si || this.light instanceof ws) && this.configureShadows(this.light)), i.pointOfInterest !== void 0 && Object.assign(this.lightData.pointOfInterest, i.pointOfInterest), i.pathFollowing !== void 0 && Object.assign(this.lightData.pathFollowing, i.pathFollowing), i.lightLinking !== void 0 && Object.assign(this.lightData.lightLinking, i.lightLinking), i.animatedIntensity !== void 0 && (this.lightData.animatedIntensity = i.animatedIntensity), i.animatedConeAngle !== void 0 && (this.lightData.animatedConeAngle = i.animatedConeAngle), i.animatedColor !== void 0 && (this.lightData.animatedColor = i.animatedColor), i.animatedColorTemperature !== void 0 && (this.lightData.animatedColorTemperature = i.animatedColorTemperature));
  }
  onDispose() {
    this.light.dispose && this.light.dispose(), this.helper && this.helper.dispose && this.helper.dispose();
  }
}
const HN = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, GN = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class $N extends $i {
  constructor(n, i) {
    super(n);
    le(this, "resources");
    // Textures
    le(this, "sourceTexture", null);
    le(this, "depthTexture", null);
    // Mesh and material
    le(this, "mesh");
    le(this, "geometry");
    le(this, "material");
    // Layer data
    le(this, "depthflowData");
    // Dimensions
    le(this, "width", 1920);
    le(this, "height", 1080);
    // Animation state
    le(this, "animationTime", 0);
    this.resources = i, this.depthflowData = this.extractDepthflowData(n), this.geometry = new nn(this.width, this.height), this.material = new dn({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new qe(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: HN,
      fragmentShader: GN,
      transparent: !0,
      side: mn,
      depthWrite: !1
    }), this.mesh = new Ke(this.geometry, this.material), this.mesh.name = `depthflow_${this.id}`, this.group.add(this.mesh), this.loadTextures(), this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(n) {
    var o, a, r, l, c, u, d, h, p, f, m, y, g, x;
    const i = n.data;
    return {
      sourceLayerId: (i == null ? void 0 : i.sourceLayerId) ?? "",
      depthLayerId: (i == null ? void 0 : i.depthLayerId) ?? "",
      config: {
        preset: ((o = i == null ? void 0 : i.config) == null ? void 0 : o.preset) ?? "static",
        zoom: ((a = i == null ? void 0 : i.config) == null ? void 0 : a.zoom) ?? 1,
        offsetX: ((r = i == null ? void 0 : i.config) == null ? void 0 : r.offsetX) ?? 0,
        offsetY: ((l = i == null ? void 0 : i.config) == null ? void 0 : l.offsetY) ?? 0,
        rotation: ((c = i == null ? void 0 : i.config) == null ? void 0 : c.rotation) ?? 0,
        depthScale: ((u = i == null ? void 0 : i.config) == null ? void 0 : u.depthScale) ?? 0.1,
        focusDepth: ((d = i == null ? void 0 : i.config) == null ? void 0 : d.focusDepth) ?? 0.5,
        dollyZoom: ((h = i == null ? void 0 : i.config) == null ? void 0 : h.dollyZoom) ?? 0,
        orbitRadius: ((p = i == null ? void 0 : i.config) == null ? void 0 : p.orbitRadius) ?? 0.1,
        orbitSpeed: ((f = i == null ? void 0 : i.config) == null ? void 0 : f.orbitSpeed) ?? 1,
        swingAmplitude: ((m = i == null ? void 0 : i.config) == null ? void 0 : m.swingAmplitude) ?? 0.05,
        swingFrequency: ((y = i == null ? void 0 : i.config) == null ? void 0 : y.swingFrequency) ?? 1,
        edgeDilation: ((g = i == null ? void 0 : i.config) == null ? void 0 : g.edgeDilation) ?? 0,
        inpaintEdges: ((x = i == null ? void 0 : i.config) == null ? void 0 : x.inpaintEdges) ?? !1
      },
      animatedZoom: i == null ? void 0 : i.animatedZoom,
      animatedOffsetX: i == null ? void 0 : i.animatedOffsetX,
      animatedOffsetY: i == null ? void 0 : i.animatedOffsetY,
      animatedRotation: i == null ? void 0 : i.animatedRotation,
      animatedDepthScale: i == null ? void 0 : i.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      n && (this.sourceTexture = n, this.material.uniforms.sourceTexture.value = n, n.image && this.setDimensions(n.image.width, n.image.height));
    }
    if (this.depthflowData.depthLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      n && (this.depthTexture = n, this.material.uniforms.depthTexture.value = n);
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(n) {
    const i = this.resources.getLayerTexture(n);
    return i || (fi.warn(`DepthflowLayer: Could not load texture for layer ${n}`), null);
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new nn(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Set source layer
   */
  async setSourceLayer(n) {
    var o;
    this.depthflowData.sourceLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((o = this.sourceTexture) == null || o.dispose(), this.sourceTexture = i, this.material.uniforms.sourceTexture.value = i);
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(n) {
    var o;
    this.depthflowData.depthLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((o = this.depthTexture) == null || o.dispose(), this.depthTexture = i, this.material.uniforms.depthTexture.value = i);
  }
  /**
   * Update config values
   */
  updateConfig(n) {
    Object.assign(this.depthflowData.config, n), n.depthScale !== void 0 && (this.material.uniforms.depthScale.value = n.depthScale), n.focusDepth !== void 0 && (this.material.uniforms.focusDepth.value = n.focusDepth), n.zoom !== void 0 && (this.material.uniforms.zoom.value = n.zoom), n.rotation !== void 0 && (this.material.uniforms.rotation.value = ln.degToRad(n.rotation)), n.edgeDilation !== void 0 && (this.material.uniforms.edgeDilation.value = n.edgeDilation);
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(n, i = 30) {
    const o = this.depthflowData.config, a = this.outPoint - this.inPoint, r = a > 0 ? (n - this.inPoint) / a : 0, l = n / i;
    let c = o.zoom, u = o.offsetX, d = o.offsetY, h = o.rotation;
    switch (o.preset) {
      case "static":
        break;
      case "zoom_in":
        c = 1 + r * 0.5;
        break;
      case "zoom_out":
        c = 1.5 - r * 0.5;
        break;
      case "dolly_zoom_in":
        c = 1 + r * 0.5, this.material.uniforms.depthScale.value = o.depthScale * (1 + o.dollyZoom * r);
        break;
      case "dolly_zoom_out":
        c = 1.5 - r * 0.5, this.material.uniforms.depthScale.value = o.depthScale * (1 + o.dollyZoom * (1 - r));
        break;
      case "pan_left":
        u = r * 0.2;
        break;
      case "pan_right":
        u = -r * 0.2;
        break;
      case "pan_up":
        d = r * 0.2;
        break;
      case "pan_down":
        d = -r * 0.2;
        break;
      case "circle_cw":
        u = Math.sin(r * Math.PI * 2) * o.orbitRadius, d = Math.cos(r * Math.PI * 2) * o.orbitRadius;
        break;
      case "circle_ccw":
        u = -Math.sin(r * Math.PI * 2) * o.orbitRadius, d = Math.cos(r * Math.PI * 2) * o.orbitRadius;
        break;
      case "horizontal_swing":
        u = Math.sin(l * o.swingFrequency * Math.PI * 2) * o.swingAmplitude;
        break;
      case "vertical_swing":
        d = Math.sin(l * o.swingFrequency * Math.PI * 2) * o.swingAmplitude;
        break;
    }
    return { zoom: c, offsetX: u, offsetY: d, rotation: h };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.depthflowData.config;
    const i = this.calculatePresetValues(n);
    let o = i.zoom, a = i.offsetX, r = i.offsetY, l = i.rotation;
    this.depthflowData.animatedZoom && (o = this.evaluator.evaluate(this.depthflowData.animatedZoom, n)), this.depthflowData.animatedOffsetX && (a = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, n)), this.depthflowData.animatedOffsetY && (r = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, n)), this.depthflowData.animatedRotation && (l = this.evaluator.evaluate(this.depthflowData.animatedRotation, n)), this.depthflowData.animatedDepthScale && (this.material.uniforms.depthScale.value = this.evaluator.evaluate(
      this.depthflowData.animatedDepthScale,
      n
    )), o = this.getDrivenOrBase("depthflow.zoom", o), a = this.getDrivenOrBase("depthflow.offsetX", a), r = this.getDrivenOrBase("depthflow.offsetY", r), l = this.getDrivenOrBase("depthflow.rotation", l), this.material.uniforms.zoom.value = o, this.material.uniforms.offset.value.set(a, r), this.material.uniforms.rotation.value = ln.degToRad(l), this.material.uniforms.time.value = n / 30, this.material.needsUpdate = !0;
  }
  onApplyEvaluatedState(n) {
    const i = n.properties;
    if (i.zoom !== void 0 && (this.material.uniforms.zoom.value = i.zoom), i.offsetX !== void 0 || i.offsetY !== void 0) {
      const o = i.offsetX ?? this.material.uniforms.offset.value.x, a = i.offsetY ?? this.material.uniforms.offset.value.y;
      this.material.uniforms.offset.value.set(o, a);
    }
    i.rotation !== void 0 && (this.material.uniforms.rotation.value = ln.degToRad(i.rotation)), i.depthScale !== void 0 && (this.material.uniforms.depthScale.value = i.depthScale), this.material.needsUpdate = !0;
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.sourceLayerId !== void 0 && i.sourceLayerId !== this.depthflowData.sourceLayerId && this.setSourceLayer(i.sourceLayerId), i.depthLayerId !== void 0 && i.depthLayerId !== this.depthflowData.depthLayerId && this.setDepthLayer(i.depthLayerId), i.config && this.updateConfig(i.config), i.animatedZoom !== void 0 && (this.depthflowData.animatedZoom = i.animatedZoom), i.animatedOffsetX !== void 0 && (this.depthflowData.animatedOffsetX = i.animatedOffsetX), i.animatedOffsetY !== void 0 && (this.depthflowData.animatedOffsetY = i.animatedOffsetY), i.animatedRotation !== void 0 && (this.depthflowData.animatedRotation = i.animatedRotation), i.animatedDepthScale !== void 0 && (this.depthflowData.animatedDepthScale = i.animatedDepthScale));
  }
  onDispose() {
    var n, i;
    (n = this.sourceTexture) == null || n.dispose(), (i = this.depthTexture) == null || i.dispose(), this.geometry.dispose(), this.material.dispose();
  }
}
class WN extends $i {
  constructor(n) {
    super(n);
    // Matte data
    le(this, "matteData");
    // Display mesh
    le(this, "mesh", null);
    le(this, "material", null);
    le(this, "texture", null);
    // Rendering canvas (grayscale output)
    le(this, "renderCanvas");
    le(this, "renderCtx");
    // Animation evaluator
    le(this, "matteEvaluator");
    // Dimensions
    le(this, "width", 512);
    le(this, "height", 512);
    // Noise seed for deterministic noise
    le(this, "noiseSeed");
    this.matteEvaluator = new Ta(), this.matteData = this.extractMatteData(n), this.noiseSeed = this.matteData.parameters.seed ?? Math.random() * 65536, this.renderCanvas = document.createElement("canvas"), this.renderCanvas.width = this.width, this.renderCanvas.height = this.height, this.renderCtx = this.renderCanvas.getContext("2d"), this.createMesh(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract matte data with defaults
   */
  extractMatteData(n) {
    const i = n.data;
    return i || {
      patternType: "linear_gradient",
      parameters: {},
      animation: {
        enabled: !1,
        speed: { id: "speed", name: "Speed", type: "number", value: 1, animated: !1, keyframes: [] },
        phase: { id: "phase", name: "Phase", type: "number", value: 0, animated: !1, keyframes: [] },
        direction: { id: "dir", name: "Direction", type: "number", value: 0, animated: !1, keyframes: [] }
      },
      inverted: !1,
      levels: {
        inputBlack: { id: "ib", name: "Input Black", type: "number", value: 0, animated: !1, keyframes: [] },
        inputWhite: { id: "iw", name: "Input White", type: "number", value: 255, animated: !1, keyframes: [] },
        gamma: { id: "g", name: "Gamma", type: "number", value: 1, animated: !1, keyframes: [] },
        outputBlack: { id: "ob", name: "Output Black", type: "number", value: 0, animated: !1, keyframes: [] },
        outputWhite: { id: "ow", name: "Output White", type: "number", value: 255, animated: !1, keyframes: [] }
      }
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const n = new nn(this.width, this.height);
    this.texture = new Vc(this.renderCanvas), this.texture.minFilter = Dt, this.texture.magFilter = Dt, this.material = new _n({
      map: this.texture,
      transparent: !0,
      side: mn
    }), this.mesh = new Ke(n, this.material), this.mesh.name = `matte_${this.id}`, this.group.add(this.mesh);
  }
  /**
   * Set dimensions
   */
  setDimensions(n, i) {
    this.width = n, this.height = i, this.renderCanvas.width = n, this.renderCanvas.height = i, this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new nn(n, i));
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    this.renderPattern(n), this.texture && (this.texture.needsUpdate = !0);
  }
  onUpdate(n) {
    n.data && (this.matteData = this.extractMatteData({ ...n, data: n.data }));
  }
  // ============================================================================
  // PATTERN RENDERING
  // ============================================================================
  /**
   * Render the pattern to the canvas
   */
  renderPattern(n) {
    const i = this.renderCtx, o = this.width, a = this.height;
    i.fillStyle = "black", i.fillRect(0, 0, o, a);
    const r = this.matteEvaluator.evaluate(this.matteData.animation.speed, n), l = this.matteEvaluator.evaluate(this.matteData.animation.phase, n), c = this.matteData.animation.enabled ? n * r / 60 + l : 0;
    switch (this.matteData.patternType) {
      case "linear_gradient":
        this.renderLinearGradient(i, o, a, n, c);
        break;
      case "radial_gradient":
        this.renderRadialGradient(i, o, a, n, c);
        break;
      case "angular_gradient":
        this.renderAngularGradient(i, o, a, n, c);
        break;
      case "ramp":
        this.renderRamp(i, o, a, n, c);
        break;
      case "noise":
        this.renderNoise(i, o, a, n, c);
        break;
      case "checkerboard":
        this.renderCheckerboard(i, o, a, n, c);
        break;
      case "circle":
        this.renderCircle(i, o, a, n, c);
        break;
      case "rectangle":
        this.renderRectangle(i, o, a, n, c);
        break;
      case "iris":
        this.renderIris(i, o, a, n, c);
        break;
      case "radial_wipe":
        this.renderRadialWipe(i, o, a, n, c);
        break;
      case "venetian_blinds":
        this.renderVenetianBlinds(i, o, a, n, c);
        break;
      case "dissolve":
        this.renderDissolve(i, o, a, n, c);
        break;
      case "wave":
        this.renderWave(i, o, a, n, c);
        break;
      default:
        i.fillStyle = "white", i.fillRect(0, 0, o, a);
    }
    this.applyLevels(n), this.matteData.inverted && this.invertCanvas();
  }
  // ============================================================================
  // PATTERN IMPLEMENTATIONS
  // ============================================================================
  renderLinearGradient(n, i, o, a, r) {
    const l = this.matteData.parameters, c = this.matteEvaluator.evaluate(l.angle, a) + r * 360, u = this.matteEvaluator.evaluate(l.blend, a), d = c * Math.PI / 180, h = Math.cos(d), p = Math.sin(d), f = Math.max(i, o) * 1.5, m = i / 2, y = o / 2, g = m - h * f / 2, x = y - p * f / 2, w = m + h * f / 2, M = y + p * f / 2, _ = n.createLinearGradient(g, x, w, M), C = Math.max(1e-3, u / 2);
    _.addColorStop(Math.max(0, 0.5 - C), "black"), _.addColorStop(Math.min(1, 0.5 + C), "white"), n.fillStyle = _, n.fillRect(0, 0, i, o);
  }
  renderRadialGradient(n, i, o, a, r) {
    const l = this.matteData.parameters, c = this.matteEvaluator.evaluate(l.centerX, a), u = this.matteEvaluator.evaluate(l.centerY, a), d = this.matteEvaluator.evaluate(l.radius, a) + r * 0.5, h = l.blend ? this.matteEvaluator.evaluate(l.blend, a) : 0.3, p = c * i, f = u * o, m = d * Math.max(i, o) / 2, y = n.createRadialGradient(p, f, 0, p, f, m);
    y.addColorStop(Math.max(0, 1 - h), "white"), y.addColorStop(1, "black"), n.fillStyle = y, n.fillRect(0, 0, i, o);
  }
  renderAngularGradient(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.centerX ? this.matteEvaluator.evaluate(l.centerX, a) : 0.5, u = l.centerY ? this.matteEvaluator.evaluate(l.centerY, a) : 0.5, d = (l.angle ? this.matteEvaluator.evaluate(l.angle, a) : 0) + r * 360, h = c * i, p = u * o, f = n.getImageData(0, 0, i, o), m = f.data;
    for (let y = 0; y < o; y++)
      for (let g = 0; g < i; g++) {
        const x = g - h, w = y - p;
        let M = Math.atan2(w, x) * 180 / Math.PI + d;
        M = (M % 360 + 360) % 360;
        const _ = Math.round(M / 360 * 255), C = (y * i + g) * 4;
        m[C] = m[C + 1] = m[C + 2] = _, m[C + 3] = 255;
      }
    n.putImageData(f, 0, 0);
  }
  renderRamp(n, i, o, a, r) {
    const l = this.matteData.parameters, c = this.matteEvaluator.evaluate(l.progress, a), u = l.softness ? this.matteEvaluator.evaluate(l.softness, a) : 0.1, d = l.angle ? this.matteEvaluator.evaluate(l.angle, a) : 0, h = this.matteData.animation.enabled ? (c + r) % 1 : c, p = d * Math.PI / 180, f = Math.cos(p), m = Math.sin(p), y = Math.max(i, o) * 1.5, g = i / 2, x = o / 2, w = g - f * y / 2, M = x - m * y / 2, _ = g + f * y / 2, C = x + m * y / 2, T = n.createLinearGradient(w, M, _, C), P = Math.max(1e-3, u / 2);
    T.addColorStop(Math.max(0, h - P), "black"), T.addColorStop(Math.min(1, h + P), "white"), n.fillStyle = T, n.fillRect(0, 0, i, o);
  }
  renderNoise(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.scale ? this.matteEvaluator.evaluate(l.scale, a) : 50, u = l.octaves ?? 4, d = n.getImageData(0, 0, i, o), h = d.data, p = r * 10;
    for (let f = 0; f < o; f++)
      for (let m = 0; m < i; m++) {
        let y = 0, g = 1, x = 1 / c;
        for (let _ = 0; _ < u; _++)
          y += this.perlinNoise(m * x + p, f * x) * g, g *= 0.5, x *= 2;
        const w = Math.round((y + 1) / 2 * 255), M = (f * i + m) * 4;
        h[M] = h[M + 1] = h[M + 2] = w, h[M + 3] = 255;
      }
    n.putImageData(d, 0, 0);
  }
  renderCheckerboard(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.tilesX ? this.matteEvaluator.evaluate(l.tilesX, a) : 8, u = l.tilesY ? this.matteEvaluator.evaluate(l.tilesY, a) : 8, d = l.rotation ? this.matteEvaluator.evaluate(l.rotation, a) : 0, h = i / c, p = o / u, f = r * h;
    n.save(), n.translate(i / 2, o / 2), n.rotate(d * Math.PI / 180), n.translate(-i / 2 - f, -o / 2);
    for (let m = -1; m <= u + 1; m++)
      for (let y = -1; y <= c + 1; y++) {
        const g = (y + m) % 2 === 0;
        n.fillStyle = g ? "white" : "black", n.fillRect(y * h, m * p, h, p);
      }
    n.restore();
  }
  renderCircle(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.centerX ? this.matteEvaluator.evaluate(l.centerX, a) : 0.5, u = l.centerY ? this.matteEvaluator.evaluate(l.centerY, a) : 0.5, d = l.radius ? this.matteEvaluator.evaluate(l.radius, a) : 0.5, h = l.feather ? this.matteEvaluator.evaluate(l.feather, a) : 0, p = c * i, f = u * o, m = (d + r * 0.5) * Math.min(i, o) / 2;
    if (h > 0) {
      const y = n.createRadialGradient(p, f, Math.max(0, m - h * 50), p, f, m);
      y.addColorStop(0, "white"), y.addColorStop(1, "black"), n.fillStyle = y, n.fillRect(0, 0, i, o);
    } else
      n.fillStyle = "white", n.beginPath(), n.arc(p, f, m, 0, Math.PI * 2), n.fill();
  }
  renderRectangle(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.centerX ? this.matteEvaluator.evaluate(l.centerX, a) : 0.5, u = l.centerY ? this.matteEvaluator.evaluate(l.centerY, a) : 0.5, d = l.width ? this.matteEvaluator.evaluate(l.width, a) : 0.5, h = l.height ? this.matteEvaluator.evaluate(l.height, a) : 0.5, p = l.cornerRadius ? this.matteEvaluator.evaluate(l.cornerRadius, a) : 0, f = c * i, m = u * o, y = (d + r * 0.2) * i, g = (h + r * 0.2) * o, x = p * Math.min(y, g) / 2;
    n.fillStyle = "white", n.beginPath(), n.roundRect(f - y / 2, m - g / 2, y, g, x), n.fill();
  }
  renderIris(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.progress ? this.matteEvaluator.evaluate(l.progress, a) : 0.5, u = l.feather ? this.matteEvaluator.evaluate(l.feather, a) : 0.1, d = l.centerX ? this.matteEvaluator.evaluate(l.centerX, a) : 0.5, h = l.centerY ? this.matteEvaluator.evaluate(l.centerY, a) : 0.5, p = this.matteData.animation.enabled ? (c + r) % 1 : c, f = d * i, m = h * o, y = Math.sqrt(i * i + o * o) / 2, g = p * y, x = n.createRadialGradient(f, m, Math.max(0, g - u * 100), f, m, g);
    x.addColorStop(0, "white"), x.addColorStop(1, "black"), n.fillStyle = x, n.fillRect(0, 0, i, o);
  }
  renderRadialWipe(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.progress ? this.matteEvaluator.evaluate(l.progress, a) : 0.5, u = l.centerX ? this.matteEvaluator.evaluate(l.centerX, a) : 0.5, d = l.centerY ? this.matteEvaluator.evaluate(l.centerY, a) : 0.5, h = l.softness ? this.matteEvaluator.evaluate(l.softness, a) : 0.05, p = this.matteData.animation.enabled ? (c + r) % 1 : c, f = u * i, m = d * o, y = p * Math.PI * 2, g = n.getImageData(0, 0, i, o), x = g.data;
    for (let w = 0; w < o; w++)
      for (let M = 0; M < i; M++) {
        const _ = M - f, C = w - m, P = Math.atan2(C, _) + Math.PI - y, E = Math.abs((P + Math.PI * 3) % (Math.PI * 2) - Math.PI) / Math.PI;
        let b = E < 0.5 ? 255 : 0;
        if (h > 0) {
          const A = h * Math.PI;
          Math.abs(E - 0.5) < A && (b = Math.round(255 * (1 - (E - 0.5 + A) / (A * 2))));
        }
        const S = (w * i + M) * 4;
        x[S] = x[S + 1] = x[S + 2] = b, x[S + 3] = 255;
      }
    n.putImageData(g, 0, 0);
  }
  renderVenetianBlinds(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.progress ? this.matteEvaluator.evaluate(l.progress, a) : 0.5, u = l.slats ? this.matteEvaluator.evaluate(l.slats, a) : 10, d = l.angle ? this.matteEvaluator.evaluate(l.angle, a) : 0, h = this.matteData.animation.enabled ? (c + r) % 1 : c, p = o / u, f = h * p;
    n.save(), n.translate(i / 2, o / 2), n.rotate(d * Math.PI / 180), n.translate(-i / 2, -o / 2);
    for (let m = 0; m < u; m++)
      n.fillStyle = "white", n.fillRect(0, m * p, i, f);
    n.restore();
  }
  renderDissolve(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.progress ? this.matteEvaluator.evaluate(l.progress, a) : 0.5, u = l.blockSize ? this.matteEvaluator.evaluate(l.blockSize, a) : 4, d = this.matteData.animation.enabled ? (c + r) % 1 : c, h = n.getImageData(0, 0, i, o), p = h.data, f = Math.ceil(i / u), m = Math.ceil(o / u);
    for (let y = 0; y < m; y++)
      for (let g = 0; g < f; g++) {
        const M = this.hash(g + y * f + this.noiseSeed) < d ? 255 : 0;
        for (let _ = 0; _ < u && y * u + _ < o; _++)
          for (let C = 0; C < u && g * u + C < i; C++) {
            const T = g * u + C, E = ((y * u + _) * i + T) * 4;
            p[E] = p[E + 1] = p[E + 2] = M, p[E + 3] = 255;
          }
      }
    n.putImageData(h, 0, 0);
  }
  renderWave(n, i, o, a, r) {
    const l = this.matteData.parameters, c = l.frequency ? this.matteEvaluator.evaluate(l.frequency, a) : 4, u = l.amplitude ? this.matteEvaluator.evaluate(l.amplitude, a) : 0.5, d = l.angle ? this.matteEvaluator.evaluate(l.angle, a) : 0, h = l.waveType ?? "sine", p = n.getImageData(0, 0, i, o), f = p.data, m = d * Math.PI / 180;
    for (let y = 0; y < o; y++)
      for (let g = 0; g < i; g++) {
        const w = (((g - i / 2) * Math.cos(m) - (y - o / 2) * Math.sin(m)) / i * c + r) * Math.PI * 2;
        let M;
        switch (h) {
          case "triangle":
            M = Math.abs(w / Math.PI % 2 - 1) * 2 - 1;
            break;
          case "square":
            M = Math.sin(w) >= 0 ? 1 : -1;
            break;
          case "sawtooth":
            M = w / Math.PI % 2 - 1;
            break;
          default:
            M = Math.sin(w);
        }
        const _ = Math.round((M * u + 1) / 2 * 255), C = (y * i + g) * 4;
        f[C] = f[C + 1] = f[C + 2] = _, f[C + 3] = 255;
      }
    n.putImageData(p, 0, 0);
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  /**
   * Apply levels adjustment
   */
  applyLevels(n) {
    const i = this.matteData.levels, o = this.matteEvaluator.evaluate(i.inputBlack, n), a = this.matteEvaluator.evaluate(i.inputWhite, n), r = this.matteEvaluator.evaluate(i.gamma, n), l = this.matteEvaluator.evaluate(i.outputBlack, n), c = this.matteEvaluator.evaluate(i.outputWhite, n);
    if (o === 0 && a === 255 && r === 1 && l === 0 && c === 255)
      return;
    const u = this.renderCtx.getImageData(0, 0, this.width, this.height), d = u.data, h = a - o, p = c - l;
    for (let f = 0; f < d.length; f += 4) {
      let m = d[f];
      m = Math.max(0, Math.min(255, (m - o) / h * 255)), m = Math.pow(m / 255, 1 / r) * 255, m = l + m / 255 * p, d[f] = d[f + 1] = d[f + 2] = Math.round(m);
    }
    this.renderCtx.putImageData(u, 0, 0);
  }
  /**
   * Invert the canvas
   */
  invertCanvas() {
    const n = this.renderCtx.getImageData(0, 0, this.width, this.height), i = n.data;
    for (let o = 0; o < i.length; o += 4)
      i[o] = 255 - i[o], i[o + 1] = 255 - i[o + 1], i[o + 2] = 255 - i[o + 2];
    this.renderCtx.putImageData(n, 0, 0);
  }
  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================
  /**
   * Simple deterministic hash function
   */
  hash(n) {
    const i = Math.sin(n) * 43758.5453123;
    return i - Math.floor(i);
  }
  /**
   * Simple 2D Perlin noise approximation
   */
  perlinNoise(n, i) {
    const o = Math.floor(n), a = Math.floor(i), r = n - o, l = i - a, c = this.hash(o + a * 57 + this.noiseSeed), u = this.hash(o + 1 + a * 57 + this.noiseSeed), d = this.hash(o + (a + 1) * 57 + this.noiseSeed), h = this.hash(o + 1 + (a + 1) * 57 + this.noiseSeed), p = r * r * (3 - 2 * r), f = l * l * (3 - 2 * l);
    return (c + p * (u - c) + f * (d - c) + p * f * (c - u - d + h)) * 2 - 1;
  }
  // ============================================================================
  // SOURCE CANVAS (for effects and track mattes)
  // ============================================================================
  getSourceCanvas() {
    return this.renderCanvas;
  }
  applyProcessedEffects(n) {
    this.renderCtx.clearRect(0, 0, this.width, this.height), this.renderCtx.drawImage(n, 0, 0), this.texture && (this.texture.needsUpdate = !0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.texture && (this.texture.dispose(), this.texture = null), this.material && (this.material.dispose(), this.material = null), this.mesh && (this.mesh.geometry.dispose(), this.mesh = null);
  }
}
function Zi(s, e) {
  const n = e.x - s.x, i = e.y - s.y;
  return Math.sqrt(n * n + i * i);
}
function Ws(s, e, n) {
  return {
    x: s.x + (e.x - s.x) * n,
    y: s.y + (e.y - s.y) * n
  };
}
function Zt(s, e) {
  return { x: s.x + e.x, y: s.y + e.y };
}
function tn(s, e) {
  return { x: s.x - e.x, y: s.y - e.y };
}
function bn(s, e) {
  return { x: s.x * e, y: s.y * e };
}
function Ui(s) {
  const e = Math.sqrt(s.x * s.x + s.y * s.y);
  return e < 1e-4 ? { x: 0, y: 0 } : { x: s.x / e, y: s.y / e };
}
function lo(s) {
  return { x: -s.y, y: s.x };
}
function d5(s, e) {
  return s.x * e.x + s.y * e.y;
}
function jN(s, e) {
  const n = Math.cos(e), i = Math.sin(e);
  return {
    x: s.x * n - s.y * i,
    y: s.x * i + s.y * n
  };
}
function U1(s, e, n) {
  const i = tn(s, e), o = jN(i, n);
  return Zt(o, e);
}
function Ts(s) {
  return { x: s.x, y: s.y };
}
function _a(s) {
  return {
    point: Ts(s.point),
    inHandle: Ts(s.inHandle),
    outHandle: Ts(s.outHandle)
  };
}
function Rn(s) {
  return {
    vertices: s.vertices.map(_a),
    closed: s.closed
  };
}
function _u(s, e, n, i, o) {
  const a = 1 - o, r = a * a, l = r * a, c = o * o, u = c * o;
  return {
    x: l * s.x + 3 * r * o * e.x + 3 * a * c * n.x + u * i.x,
    y: l * s.y + 3 * r * o * e.y + 3 * a * c * n.y + u * i.y
  };
}
function XN(s, e, n, i, o) {
  const a = 1 - o, r = a * a, l = o * o;
  return {
    x: 3 * r * (e.x - s.x) + 6 * a * o * (n.x - e.x) + 3 * l * (i.x - n.x),
    y: 3 * r * (e.y - s.y) + 6 * a * o * (n.y - e.y) + 3 * l * (i.y - n.y)
  };
}
function ta(s, e, n, i, o) {
  const a = Ws(s, e, o), r = Ws(e, n, o), l = Ws(n, i, o), c = Ws(a, r, o), u = Ws(r, l, o), d = Ws(c, u, o);
  return [
    [s, a, c, d],
    [d, u, l, i]
  ];
}
function wu(s, e, n, i, o = 32) {
  let a = 0, r = s;
  for (let l = 1; l <= o; l++) {
    const c = l / o, u = _u(s, e, n, i, c);
    a += Zi(r, u), r = u;
  }
  return a;
}
function Mu(s) {
  if (s.vertices.length < 2) return 0;
  let e = 0;
  const n = s.closed ? s.vertices.length : s.vertices.length - 1;
  for (let i = 0; i < n; i++) {
    const o = s.vertices[i], a = s.vertices[(i + 1) % s.vertices.length], r = o.point, l = Zt(o.point, o.outHandle), c = Zt(a.point, a.inHandle), u = a.point;
    e += wu(r, l, c, u);
  }
  return e;
}
function h5(s, e, n) {
  if (s.vertices.length < 2) return null;
  const i = n ?? Mu(s);
  if (i < 1e-4) return null;
  e = Math.max(0, Math.min(i, e));
  let o = 0;
  const a = s.closed ? s.vertices.length : s.vertices.length - 1;
  for (let l = 0; l < a; l++) {
    const c = s.vertices[l], u = s.vertices[(l + 1) % s.vertices.length], d = c.point, h = Zt(c.point, c.outHandle), p = Zt(u.point, u.inHandle), f = u.point, m = wu(d, h, p, f);
    if (o + m >= e) {
      const g = (e - o) / m, x = _u(d, h, p, f, g), w = Ui(XN(d, h, p, f, g)), M = (l + g) / a;
      return { point: x, tangent: w, t: M };
    }
    o += m;
  }
  const r = s.vertices[s.closed ? 0 : s.vertices.length - 1];
  return {
    point: Ts(r.point),
    tangent: { x: 1, y: 0 },
    t: 1
  };
}
function Qd(s, e, n, i = 0) {
  if (s.vertices.length < 2) return Rn(s);
  const o = Mu(s);
  if (o < 1e-4) return Rn(s);
  const a = i / 360 * 100;
  let r = ((e + a) % 100 + 100) % 100, l = ((n + a) % 100 + 100) % 100;
  if (r > l && s.closed) {
    const c = z1(s, r, 100, o), u = z1(s, 0, l, o);
    return YN(c, u);
  }
  return r > l && ([r, l] = [l, r]), z1(s, r, l, o);
}
function z1(s, e, n, i) {
  const o = e / 100 * i, a = n / 100 * i;
  if (a - o < 1e-3)
    return { vertices: [], closed: !1 };
  const r = [];
  let l = 0;
  const c = s.closed ? s.vertices.length : s.vertices.length - 1;
  let u = !1, d = null;
  for (let h = 0; h < c; h++) {
    const p = s.vertices[h], f = s.vertices[(h + 1) % s.vertices.length], m = p.point, y = Zt(p.point, p.outHandle), g = Zt(f.point, f.inHandle), x = f.point, w = wu(m, y, g, x), M = l;
    if (l + w > o && M < a) {
      const C = Math.max(0, (o - M) / w), T = Math.min(1, (a - M) / w);
      let P;
      if (C > 0 && T < 1) {
        const [, E] = ta(m, y, g, x, C), b = (T - C) / (1 - C), [S] = ta(E[0], E[1], E[2], E[3], b);
        P = S;
      } else if (C > 0) {
        const [, E] = ta(m, y, g, x, C);
        P = E;
      } else if (T < 1) {
        const [E] = ta(m, y, g, x, T);
        P = E;
      } else
        P = [m, y, g, x];
      !u || r.length === 0 ? (r.push({
        point: P[0],
        inHandle: { x: 0, y: 0 },
        outHandle: tn(P[1], P[0])
      }), u = !0) : d && Zi(d, P[0]) > 0.01 && r.length > 0 && (r[r.length - 1].outHandle = tn(P[1], r[r.length - 1].point)), r.push({
        point: P[3],
        inHandle: tn(P[2], P[3]),
        outHandle: { x: 0, y: 0 }
      }), d = P[3];
    }
    l += w;
  }
  for (let h = 0; h < r.length - 1; h++)
    ;
  return { vertices: r, closed: !1 };
}
function YN(s, e) {
  if (s.vertices.length === 0) return Rn(e);
  if (e.vertices.length === 0) return Rn(s);
  const n = Rn(s), i = e.vertices.map(_a), o = n.vertices[n.vertices.length - 1], a = i[0];
  return Zi(o.point, a.point) < 0.01 ? (o.outHandle = a.outHandle, n.vertices.push(...i.slice(1))) : n.vertices.push(...i), n;
}
function f5(s, e) {
  if (s.length === 0) return [];
  if (s.length === 1) return [Rn(s[0])];
  const n = s.map(p5);
  let i = [n[0]];
  for (let o = 1; o < n.length; o++) {
    const a = [];
    for (const r of i)
      switch (e) {
        case "add":
          a.push(...qN(r, n[o]));
          break;
        case "subtract":
        case "minusFront":
          a.push(...a9(r, n[o]));
          break;
        case "minusBack":
          a.push(...a9(n[o]));
          break;
        case "intersect":
          a.push(...ZN(r, n[o]));
          break;
        case "exclude":
          a.push(...KN(r, n[o]));
          break;
      }
    i = a;
  }
  return i.map(m5);
}
function p5(s, e = 16) {
  const n = [], i = s.closed ? s.vertices.length : s.vertices.length - 1;
  for (let o = 0; o < i; o++) {
    const a = s.vertices[o], r = s.vertices[(o + 1) % s.vertices.length], l = a.point, c = Zt(a.point, a.outHandle), u = Zt(r.point, r.inHandle), d = r.point;
    for (let h = 0; h < e; h++) {
      const p = h / e;
      n.push(_u(l, c, u, d, p));
    }
  }
  return n;
}
function m5(s) {
  return { vertices: s.map((n) => ({
    point: Ts(n),
    inHandle: { x: 0, y: 0 },
    outHandle: { x: 0, y: 0 }
  })), closed: !0 };
}
function qN(s, e) {
  return [s, e];
}
function a9(s, e) {
  return [s];
}
function ZN(s, e) {
  return [s];
}
function KN(s, e) {
  return [s, e];
}
function Yh(s, e, n = "miter", i = 4) {
  if (s.vertices.length < 2 || Math.abs(e) < 1e-3)
    return Rn(s);
  const o = [], a = s.vertices.length, r = s.closed;
  for (let l = 0; l < a; l++) {
    const c = s.vertices[l], u = s.vertices[(l - 1 + a) % a], d = s.vertices[(l + 1) % a];
    let h, p;
    l === 0 && !r ? (h = { x: 0, y: 0 }, p = Ui(tn(
      Zt(d.point, d.inHandle),
      Zt(c.point, c.outHandle)
    ))) : l === a - 1 && !r ? (h = Ui(tn(
      Zt(c.point, c.inHandle),
      Zt(u.point, u.outHandle)
    )), p = { x: 0, y: 0 }) : (h = Ui(tn(
      c.point,
      Zt(u.point, u.outHandle)
    )), p = Ui(tn(
      Zt(c.point, c.outHandle),
      c.point
    )));
    let f;
    if (Math.abs(h.x) < 1e-3 && Math.abs(h.y) < 1e-3)
      f = lo(p);
    else if (Math.abs(p.x) < 1e-3 && Math.abs(p.y) < 1e-3)
      f = lo(h);
    else {
      const g = lo(h), x = lo(p);
      f = Ui(Zt(g, x));
      const w = Math.acos(Math.max(-1, Math.min(1, d5(h, p))));
      if (w > 0.01) {
        const M = 1 / Math.cos(w / 2);
        n === "miter" && M <= i && (f = bn(f, M));
      }
    }
    const m = Zt(c.point, bn(f, e)), y = 1;
    o.push({
      point: m,
      inHandle: bn(c.inHandle, y),
      outHandle: bn(c.outHandle, y)
    });
  }
  return { vertices: o, closed: r };
}
function JN(s, e, n, i, o = "miter", a = 4) {
  const r = [Rn(s)];
  for (let l = 1; l < n; l++) {
    const c = e + i * l;
    r.push(Yh(s, c, o, a));
  }
  return r;
}
function v5(s, e) {
  if (s.vertices.length < 2 || Math.abs(e) < 1e-3)
    return Rn(s);
  const n = { x: 0, y: 0 };
  for (const a of s.vertices)
    n.x += a.point.x, n.y += a.point.y;
  n.x /= s.vertices.length, n.y /= s.vertices.length;
  const i = e / 100;
  return { vertices: s.vertices.map((a) => {
    const r = tn(a.point, n), l = Math.sqrt(r.x * r.x + r.y * r.y);
    if (l < 1e-3) return _a(a);
    const c = l * i, u = Zt(a.point, bn(Ui(r), c)), d = 1 + i * 0.5;
    return {
      point: u,
      inHandle: bn(a.inHandle, d),
      outHandle: bn(a.outHandle, d)
    };
  }), closed: s.closed };
}
function g5(s, e, n, i, o, a, r, l) {
  if (s.vertices.length < 2 || e < 1e-3)
    return Rn(s);
  const c = new W3(l);
  for (let f = 0; f < Math.floor(a * 100); f++)
    c.next();
  const u = o / 100, d = [], h = QN(s, Math.max(1, Math.floor(n)));
  let p = { x: 0, y: 0 };
  for (let f = 0; f < h.vertices.length; f++) {
    const m = h.vertices[f], y = c.next() * Math.PI * 2 + r, g = c.next() * e, x = {
      x: Math.cos(y) * g,
      y: Math.sin(y) * g
    }, w = {
      x: p.x * u + x.x * (1 - u),
      y: p.y * u + x.y * (1 - u)
    };
    p = w;
    const M = {
      point: Zt(m.point, w),
      inHandle: i === "smooth" ? Ts(m.inHandle) : { x: 0, y: 0 },
      outHandle: i === "smooth" ? Ts(m.outHandle) : { x: 0, y: 0 }
    };
    d.push(M);
  }
  return { vertices: d, closed: s.closed };
}
function QN(s, e = 1) {
  if (e <= 0) return Rn(s);
  let n = Rn(s);
  for (let i = 0; i < e; i++) {
    const o = [], a = n.closed ? n.vertices.length : n.vertices.length - 1;
    for (let r = 0; r < a; r++) {
      const l = n.vertices[r], c = n.vertices[(r + 1) % n.vertices.length], u = l.point, d = Zt(l.point, l.outHandle), h = Zt(c.point, c.inHandle), p = c.point, [f, m] = ta(u, d, h, p, 0.5);
      o.push({
        point: f[0],
        inHandle: r === 0 ? l.inHandle : tn(f[1], f[0]),
        outHandle: tn(f[1], f[0])
      }), o.push({
        point: f[3],
        inHandle: tn(f[2], f[3]),
        outHandle: tn(m[1], m[0])
      });
    }
    if (!n.closed) {
      const r = n.vertices[n.vertices.length - 1];
      o.push(_a(r));
    }
    n = { vertices: o, closed: n.closed };
  }
  return n;
}
function y5(s, e, n, i) {
  if (s.vertices.length < 2 || e < 1e-3 || n < 1)
    return Rn(s);
  const o = [], a = Mu(s), r = a / (n * (s.vertices.length - (s.closed ? 0 : 1)));
  let l = 0, c = 1;
  for (; l < a; ) {
    const u = h5(s, l, a);
    if (!u) break;
    const d = lo(u.tangent), h = bn(d, e * c), p = {
      point: Zt(u.point, h),
      inHandle: i === "smooth" ? bn(u.tangent, -r * 0.3) : { x: 0, y: 0 },
      outHandle: i === "smooth" ? bn(u.tangent, r * 0.3) : { x: 0, y: 0 }
    };
    o.push(p), l += r, c *= -1;
  }
  if (o.length > 0 && !s.closed) {
    const u = s.vertices[s.vertices.length - 1];
    o.push({
      point: Ts(u.point),
      inHandle: { x: 0, y: 0 },
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: o, closed: s.closed };
}
function x5(s, e, n) {
  if (s.vertices.length < 2 || Math.abs(e) < 1e-3)
    return Rn(s);
  let i = 1 / 0, o = -1 / 0;
  for (const c of s.vertices)
    i = Math.min(i, c.point.y), o = Math.max(o, c.point.y);
  const a = o - i;
  if (a < 1e-3) return Rn(s);
  const r = e * Math.PI / 180;
  return { vertices: s.vertices.map((c) => {
    const u = (c.point.y - i) / a, d = r * u, h = U1(c.point, n, d), p = Zt(c.point, c.inHandle), f = Zt(c.point, c.outHandle), m = U1(p, n, d), y = U1(f, n, d);
    return {
      point: h,
      inHandle: tn(m, h),
      outHandle: tn(y, h)
    };
  }), closed: s.closed };
}
function b5(s, e) {
  if (s.vertices.length < 2 || e < 1e-3)
    return Rn(s);
  const n = [], i = s.vertices.length;
  for (let o = 0; o < i; o++) {
    const a = s.vertices[o], r = s.vertices[(o - 1 + i) % i], l = s.vertices[(o + 1) % i];
    if (!s.closed && (o === 0 || o === i - 1)) {
      n.push(_a(a));
      continue;
    }
    const c = Ui(tn(r.point, a.point)), u = Ui(tn(l.point, a.point));
    if (d5(c, u) > 0.99) {
      n.push(_a(a));
      continue;
    }
    const h = Zi(a.point, r.point), p = Zi(a.point, l.point), f = Math.min(e, h / 2, p / 2), m = Zt(a.point, bn(c, f)), y = Zt(a.point, bn(u, f)), x = f * 0.5522847498;
    n.push({
      point: m,
      inHandle: { x: 0, y: 0 },
      outHandle: bn(c, -x)
    }), n.push({
      point: y,
      inHandle: bn(u, -x),
      outHandle: { x: 0, y: 0 }
    });
  }
  return { vertices: n, closed: s.closed };
}
function _5(s, e, n = 0, i = 1) {
  const o = e.x / 2, a = e.y / 2, r = Math.min(n, o, a), l = [
    { x: s.x - o, y: s.y - a },
    // TL
    { x: s.x + o, y: s.y - a },
    // TR
    { x: s.x + o, y: s.y + a },
    // BR
    { x: s.x - o, y: s.y + a }
    // BL
  ];
  if (i === -1 && l.reverse(), r < 0.01)
    return {
      vertices: l.map((d) => ({
        point: d,
        inHandle: { x: 0, y: 0 },
        outHandle: { x: 0, y: 0 }
      })),
      closed: !0
    };
  const c = 0.5522847498 * r, u = [];
  for (let d = 0; d < 4; d++) {
    const h = l[d], p = l[(d + 1) % 4], f = Ui(tn(p, h));
    lo(f), u.push({
      point: Zt(h, bn(f, r)),
      inHandle: bn(f, -c),
      outHandle: { x: 0, y: 0 }
    }), u.push({
      point: tn(p, bn(f, r)),
      inHandle: { x: 0, y: 0 },
      outHandle: bn(f, c)
    });
  }
  return { vertices: u, closed: !0 };
}
function w5(s, e, n = 1) {
  const i = e.x / 2, o = e.y / 2, a = 0.5522847498;
  let r = [
    {
      // Top
      point: { x: s.x, y: s.y - o },
      inHandle: { x: -i * a, y: 0 },
      outHandle: { x: i * a, y: 0 }
    },
    {
      // Right
      point: { x: s.x + i, y: s.y },
      inHandle: { x: 0, y: -o * a },
      outHandle: { x: 0, y: o * a }
    },
    {
      // Bottom
      point: { x: s.x, y: s.y + o },
      inHandle: { x: i * a, y: 0 },
      outHandle: { x: -i * a, y: 0 }
    },
    {
      // Left
      point: { x: s.x - i, y: s.y },
      inHandle: { x: 0, y: o * a },
      outHandle: { x: 0, y: -o * a }
    }
  ];
  return n === -1 && (r = r.reverse().map((l) => ({
    point: l.point,
    inHandle: l.outHandle,
    outHandle: l.inHandle
  }))), { vertices: r, closed: !0 };
}
function M5(s, e, n, i = 0, o = 0, a = 1) {
  const r = Math.max(3, Math.floor(e)), l = Math.PI * 2 / r, c = (o - 90) * (Math.PI / 180), u = [];
  for (let d = 0; d < r; d++) {
    const h = a === 1 ? d : r - 1 - d, p = c + l * h * a, f = {
      x: s.x + Math.cos(p) * n,
      y: s.y + Math.sin(p) * n
    }, m = n * (i / 100) * 0.5, y = p + Math.PI / 2 * a;
    u.push({
      point: f,
      inHandle: i > 0 ? {
        x: Math.cos(y) * m,
        y: Math.sin(y) * m
      } : { x: 0, y: 0 },
      outHandle: i > 0 ? {
        x: -Math.cos(y) * m,
        y: -Math.sin(y) * m
      } : { x: 0, y: 0 }
    });
  }
  return { vertices: u, closed: !0 };
}
function S5(s, e, n, i, o = 0, a = 0, r = 0, l = 1) {
  const c = Math.max(3, Math.floor(e)), u = Math.PI / c, d = (r - 90) * (Math.PI / 180), h = [];
  for (let p = 0; p < c * 2; p++) {
    const f = l === 1 ? p : c * 2 - 1 - p, m = d + u * f * l, y = f % 2 === 0, g = y ? n : i, x = y ? o : a, w = {
      x: s.x + Math.cos(m) * g,
      y: s.y + Math.sin(m) * g
    }, M = g * (x / 100) * 0.3, _ = m + Math.PI / 2 * l;
    h.push({
      point: w,
      inHandle: x > 0 ? {
        x: Math.cos(_) * M,
        y: Math.sin(_) * M
      } : { x: 0, y: 0 },
      outHandle: x > 0 ? {
        x: -Math.cos(_) * M,
        y: -Math.sin(_) * M
      } : { x: 0, y: 0 }
    });
  }
  return { vertices: h, closed: !0 };
}
function C5(s, e, n = !1) {
  if (s.vertices.length <= 2) return Rn(s);
  const i = p5(s, 32), o = eh(i, e);
  return n ? m5(o) : tV(o, s.closed);
}
function eh(s, e) {
  if (s.length <= 2) return [...s];
  let n = 0, i = 0;
  const o = s[0], a = s[s.length - 1];
  for (let r = 1; r < s.length - 1; r++) {
    const l = eV(s[r], o, a);
    l > n && (n = l, i = r);
  }
  if (n > e) {
    const r = eh(s.slice(0, i + 1), e), l = eh(s.slice(i), e);
    return [...r.slice(0, -1), ...l];
  } else
    return [o, a];
}
function eV(s, e, n) {
  const i = n.x - e.x, o = n.y - e.y, a = Math.sqrt(i * i + o * o);
  if (a < 1e-4) return Zi(s, e);
  const r = ((s.x - e.x) * i + (s.y - e.y) * o) / (a * a), l = {
    x: e.x + r * i,
    y: e.y + r * o
  };
  return Zi(s, l);
}
function tV(s, e) {
  const n = [];
  for (let i = 0; i < s.length; i++) {
    const o = s[(i - 1 + s.length) % s.length], a = s[i], r = s[(i + 1) % s.length], l = tn(o, a), c = tn(r, a), u = Math.min(
      Zi(a, o) * 0.3,
      Zi(a, r) * 0.3
    ), d = Ui(tn(c, l));
    n.push({
      point: Ts(a),
      inHandle: bn(d, -u),
      outHandle: bn(d, u)
    });
  }
  return { vertices: n, closed: e };
}
function T5(s, e) {
  if (s.vertices.length < 2) return Rn(s);
  const n = e / 100;
  return { vertices: s.vertices.map((o, a) => {
    const r = s.vertices[(a - 1 + s.vertices.length) % s.vertices.length], l = s.vertices[(a + 1) % s.vertices.length], c = tn(r.point, o.point), u = tn(l.point, o.point), d = Ui(tn(u, c)), h = (Zi(o.point, r.point) + Zi(o.point, l.point)) / 6, p = bn(d, -h), f = bn(d, h);
    return {
      point: Ts(o.point),
      inHandle: Ws(o.inHandle, p, n),
      outHandle: Ws(o.outHandle, f, n)
    };
  }), closed: s.closed };
}
function E5(s, e, n, i, o, a, r, l, c) {
  const u = [];
  for (let d = 0; d < e; d++) {
    const h = e > 1 ? d / (e - 1) : 0, p = r * d, f = {
      x: 100 + (a.x - 100) * d,
      y: 100 + (a.y - 100) * d
    }, m = {
      x: o.x * d,
      y: o.y * d
    }, y = l + (c - l) * h, g = s.map((x) => qh(x, i, m, f, p));
    u.push({
      paths: g,
      opacities: s.map(() => y / 100)
    });
  }
  return u;
}
function qh(s, e, n, i, o) {
  const a = o * Math.PI / 180, r = Math.cos(a), l = Math.sin(a), c = (d) => {
    let h = d.x - e.x, p = d.y - e.y;
    h *= i.x / 100, p *= i.y / 100;
    const f = h * r - p * l, m = h * l + p * r;
    return {
      x: f + e.x + n.x,
      y: m + e.y + n.y
    };
  };
  return { vertices: s.vertices.map((d) => {
    const h = c(d.point), p = Zt(d.point, d.inHandle), f = Zt(d.point, d.outHandle), m = c(p), y = c(f);
    return {
      point: h,
      inHandle: tn(m, h),
      outHandle: tn(y, h)
    };
  }), closed: s.closed };
}
const nV = {
  // Utilities
  distance: Zi,
  lerpPoint: Ws,
  addPoints: Zt,
  subtractPoints: tn,
  scalePoint: bn,
  normalize: Ui,
  perpendicular: lo,
  clonePath: Rn,
  // Bezier
  cubicBezierPoint: _u,
  cubicBezierLength: wu,
  getPathLength: Mu,
  getPointAtDistance: h5,
  splitCubicBezier: ta,
  // Path operators
  trimPath: Qd,
  mergePaths: f5,
  offsetPath: Yh,
  offsetPathMultiple: JN,
  puckerBloat: v5,
  wigglePath: g5,
  zigZagPath: y5,
  twistPath: x5,
  roundCorners: b5,
  // Generators
  generateRectangle: _5,
  generateEllipse: w5,
  generatePolygon: M5,
  generateStar: S5,
  // Illustrator features
  simplifyPath: C5,
  smoothPath: T5,
  // Repeater
  applyRepeater: E5,
  transformPath: qh
};
class iV extends $i {
  constructor(n) {
    super(n);
    le(this, "type", "shape");
    // Shape data
    le(this, "shapeData");
    // Rendering
    le(this, "canvas");
    le(this, "ctx");
    le(this, "texture");
    le(this, "mesh");
    // Canvas size (matches composition)
    le(this, "canvasWidth", 1920);
    le(this, "canvasHeight", 1080);
    // 3D extrusion (if any)
    le(this, "extrudedMeshes", []);
    le(this, "extrudeGroup");
    // Current frame for animation
    le(this, "currentFrame", 0);
    this.shapeData = n.data || {
      contents: [],
      blendMode: "normal",
      quality: "normal",
      gpuAccelerated: !0
    }, this.canvas = new OffscreenCanvas(this.canvasWidth, this.canvasHeight), this.ctx = this.canvas.getContext("2d"), this.texture = new Vc(this.canvas), this.texture.colorSpace = pn, this.texture.minFilter = Dt, this.texture.magFilter = Dt;
    const i = new nn(this.canvasWidth, this.canvasHeight), o = new _n({
      map: this.texture,
      transparent: !0,
      side: mn
    });
    this.mesh = new Ke(i, o), this.mesh.position.set(this.canvasWidth / 2, this.canvasHeight / 2, 0), this.group.add(this.mesh), this.extrudeGroup = new Bi(), this.group.add(this.extrudeGroup), this.renderShape();
  }
  // ============================================================================
  // SIZE MANAGEMENT
  // ============================================================================
  /**
   * Set canvas size (should match composition)
   */
  setSize(n, i) {
    n === this.canvasWidth && i === this.canvasHeight || (this.canvasWidth = n, this.canvasHeight = i, this.canvas = new OffscreenCanvas(n, i), this.ctx = this.canvas.getContext("2d"), this.texture.image = this.canvas, this.texture.needsUpdate = !0, this.mesh.geometry.dispose(), this.mesh.geometry = new nn(n, i), this.mesh.position.set(n / 2, i / 2, 0), this.renderShape());
  }
  // ============================================================================
  // SHAPE DATA ACCESS
  // ============================================================================
  getShapeData() {
    return this.shapeData;
  }
  setShapeData(n) {
    this.shapeData = n, this.renderShape();
  }
  addContent(n) {
    this.shapeData.contents.push(n), this.renderShape();
  }
  removeContent(n) {
    this.shapeData.contents.splice(n, 1), this.renderShape();
  }
  updateContent(n, i) {
    n >= 0 && n < this.shapeData.contents.length && (this.shapeData.contents[n] = i, this.renderShape());
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  evaluateFrame(n) {
    this.currentFrame = n, super.evaluateFrame(n), this.renderShape();
  }
  /**
   * Called during frame evaluation to update shape-specific properties
   */
  onEvaluateFrame(n) {
    this.currentFrame = n;
  }
  /**
   * Called when layer properties are updated
   */
  onUpdate(n) {
    n.data && (this.shapeData = n.data, this.renderShape());
  }
  onApplyEvaluatedState(n) {
    n.shapeData && (this.shapeData = n.shapeData), this.renderShape();
  }
  // ============================================================================
  // SHAPE RENDERING
  // ============================================================================
  /**
   * Main render function
   */
  renderShape() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    const n = this.evaluateContents(this.shapeData.contents);
    for (const i of n)
      this.renderPath(i);
    this.texture.needsUpdate = !0;
  }
  /**
   * Evaluate all shape contents into renderable paths
   */
  evaluateContents(n) {
    const i = [], o = [], a = [], r = [], l = [], c = [], u = [];
    for (const p of n)
      switch (p.type) {
        case "rectangle":
        case "ellipse":
        case "polygon":
        case "star":
        case "path":
          i.push(p);
          break;
        case "fill":
        case "stroke":
        case "gradientFill":
        case "gradientStroke":
          a.push(p);
          break;
        case "trimPaths":
        case "mergePaths":
        case "offsetPaths":
        case "puckerBloat":
        case "wigglePaths":
        case "zigZag":
        case "twist":
        case "roundedCorners":
          o.push(p);
          break;
        case "repeater":
          r.push(p);
          break;
        case "transform":
          l.push(p);
          break;
        case "group":
          c.push(p);
          break;
        case "simplifyPath":
        case "smoothPath":
        case "extrude":
        case "trace":
          u.push(p);
          break;
      }
    let d = i.map((p) => this.generatePath(p));
    for (const p of o)
      d = this.applyOperator(d, p);
    for (const p of u)
      d = this.applyIllustratorOperator(d, p);
    for (const p of l)
      d = d.map((f) => this.applyShapeTransform(f, p));
    for (const p of r)
      d = this.applyRepeater(d, p);
    const h = [];
    for (const p of d) {
      const f = { path: p };
      for (const m of a)
        this.applyModifier(f, m);
      h.push(f);
    }
    for (const p of c) {
      const f = this.evaluateContents(p.contents);
      h.push(...f);
    }
    return h;
  }
  /**
   * Generate a path from a shape generator
   */
  generatePath(n) {
    switch (n.type) {
      case "rectangle": {
        const i = n, o = this.getAnimatedValue(i.position), a = this.getAnimatedValue(i.size), r = this.getAnimatedValue(i.roundness);
        return _5(o, a, r, i.direction);
      }
      case "ellipse": {
        const i = n, o = this.getAnimatedValue(i.position), a = this.getAnimatedValue(i.size);
        return w5(o, a, i.direction);
      }
      case "polygon": {
        const i = n, o = this.getAnimatedValue(i.position), a = this.getAnimatedValue(i.points), r = this.getAnimatedValue(i.outerRadius), l = this.getAnimatedValue(i.outerRoundness), c = this.getAnimatedValue(i.rotation);
        return M5(o, a, r, l, c, i.direction);
      }
      case "star": {
        const i = n, o = this.getAnimatedValue(i.position), a = this.getAnimatedValue(i.points), r = this.getAnimatedValue(i.outerRadius), l = this.getAnimatedValue(i.innerRadius), c = this.getAnimatedValue(i.outerRoundness), u = this.getAnimatedValue(i.innerRoundness), d = this.getAnimatedValue(i.rotation);
        return S5(o, a, r, l, c, u, d, i.direction);
      }
      case "path": {
        const i = n;
        return Rn(this.getAnimatedValue(i.path));
      }
      default:
        return { vertices: [], closed: !1 };
    }
  }
  /**
   * Apply a path operator to paths
   */
  applyOperator(n, i) {
    switch (i.type) {
      case "trimPaths": {
        const o = i, a = this.getAnimatedValue(o.start), r = this.getAnimatedValue(o.end), l = this.getAnimatedValue(o.offset);
        return o.mode === "simultaneously" ? n.map((c) => Qd(c, a, r, l)) : n.map((c, u) => {
          const d = (a + 100 / n.length * u) % 100, h = (r + 100 / n.length * u) % 100;
          return Qd(c, d, h, l);
        });
      }
      case "mergePaths":
        return f5(n, i.mode);
      case "offsetPaths": {
        const o = i, a = this.getAnimatedValue(o.amount), r = this.getAnimatedValue(o.copies), l = this.getAnimatedValue(o.copyOffset), c = this.getAnimatedValue(o.miterLimit);
        return r <= 1 ? n.map((u) => Yh(u, a, o.lineJoin, c)) : n.flatMap(
          (u) => nV.offsetPathMultiple(u, a, r, l, o.lineJoin, c)
        );
      }
      case "puckerBloat": {
        const o = i, a = this.getAnimatedValue(o.amount);
        return n.map((r) => v5(r, a));
      }
      case "wigglePaths": {
        const o = i, a = this.getAnimatedValue(o.size), r = this.getAnimatedValue(o.detail), l = this.getAnimatedValue(o.correlation), c = this.getAnimatedValue(o.temporalPhase) + this.currentFrame * 0.1, u = this.getAnimatedValue(o.spatialPhase);
        return n.map(
          (d, h) => g5(d, a, r, o.points, l, c, u, o.randomSeed + h)
        );
      }
      case "zigZag": {
        const o = i, a = this.getAnimatedValue(o.size), r = this.getAnimatedValue(o.ridgesPerSegment);
        return n.map((l) => y5(l, a, r, o.points));
      }
      case "twist": {
        const o = i, a = this.getAnimatedValue(o.angle), r = this.getAnimatedValue(o.center);
        return n.map((l) => x5(l, a, r));
      }
      case "roundedCorners": {
        const o = i, a = this.getAnimatedValue(o.radius);
        return n.map((r) => b5(r, a));
      }
      default:
        return n;
    }
  }
  /**
   * Apply Illustrator-specific operators
   */
  applyIllustratorOperator(n, i) {
    switch (i.type) {
      case "simplifyPath": {
        const o = i, a = this.getAnimatedValue(o.tolerance);
        return n.map((r) => C5(r, a, o.straightLines));
      }
      case "smoothPath": {
        const o = i, a = this.getAnimatedValue(o.amount);
        return n.map((r) => T5(r, a));
      }
      case "extrude":
        return this.createExtrudedGeometry(n, i), n;
      case "trace":
        return n;
      default:
        return n;
    }
  }
  /**
   * Apply a shape transform
   */
  applyShapeTransform(n, i) {
    const o = this.getAnimatedValue(i.anchorPoint), a = this.getAnimatedValue(i.position), r = this.getAnimatedValue(i.scale), l = this.getAnimatedValue(i.rotation);
    return qh(n, o, a, r, l);
  }
  /**
   * Apply repeater operator
   */
  applyRepeater(n, i) {
    const o = Math.floor(this.getAnimatedValue(i.copies));
    if (o <= 1) return n;
    const a = this.getAnimatedValue(i.offset), r = this.getAnimatedValue(i.transform.anchorPoint), l = this.getAnimatedValue(i.transform.position), c = this.getAnimatedValue(i.transform.scale), u = this.getAnimatedValue(i.transform.rotation), d = this.getAnimatedValue(i.transform.startOpacity), h = this.getAnimatedValue(i.transform.endOpacity), p = E5(
      n,
      o,
      a,
      r,
      l,
      c,
      u,
      d,
      h
    ), f = [];
    if (i.composite === "below") {
      f.push(...n);
      for (const m of p.slice(1))
        f.push(...m.paths);
    } else {
      for (let m = p.length - 1; m >= 1; m--)
        f.push(...p[m].paths);
      f.push(...n);
    }
    return f;
  }
  /**
   * Apply a modifier (fill/stroke) to an evaluated path
   */
  applyModifier(n, i) {
    switch (i.type) {
      case "fill": {
        const o = i;
        n.fill = {
          color: this.getAnimatedValue(o.color),
          opacity: this.getAnimatedValue(o.opacity),
          rule: o.fillRule
        };
        break;
      }
      case "stroke": {
        const o = i;
        n.stroke = {
          color: this.getAnimatedValue(o.color),
          opacity: this.getAnimatedValue(o.opacity),
          width: this.getAnimatedValue(o.width),
          lineCap: o.lineCap,
          lineJoin: o.lineJoin,
          dashPattern: this.getAnimatedValue(o.dashPattern),
          dashOffset: this.getAnimatedValue(o.dashOffset)
        };
        break;
      }
      case "gradientFill": {
        const o = i, a = this.getAnimatedValue(o.gradient);
        n.gradientFill = {
          type: a.type,
          stops: a.stops,
          startPoint: a.startPoint,
          endPoint: a.endPoint,
          opacity: this.getAnimatedValue(o.opacity)
        };
        break;
      }
    }
  }
  /**
   * Get animated value at current frame
   */
  getAnimatedValue(n) {
    return n.value;
  }
  /**
   * Render a single evaluated path to canvas
   */
  renderPath(n) {
    const { path: i, fill: o, stroke: a, gradientFill: r } = n;
    if (i.vertices.length < 2) return;
    this.ctx.save();
    const l = this.buildPath2D(i);
    if (r) {
      const c = this.createGradient(r);
      this.ctx.globalAlpha = r.opacity / 100, this.ctx.fillStyle = c, this.ctx.fill(l, "nonzero");
    } else o && (this.ctx.globalAlpha = o.opacity / 100, this.ctx.fillStyle = this.colorToCSS(o.color), this.ctx.fill(l, o.rule));
    a && a.width > 0 && (this.ctx.globalAlpha = a.opacity / 100, this.ctx.strokeStyle = this.colorToCSS(a.color), this.ctx.lineWidth = a.width, this.ctx.lineCap = a.lineCap, this.ctx.lineJoin = a.lineJoin, a.dashPattern.length > 0 && (this.ctx.setLineDash(a.dashPattern), this.ctx.lineDashOffset = a.dashOffset), this.ctx.stroke(l)), this.ctx.restore();
  }
  /**
   * Build a Path2D from a BezierPath
   */
  buildPath2D(n) {
    const i = new Path2D();
    if (n.vertices.length === 0) return i;
    const o = n.vertices[0];
    i.moveTo(o.point.x, o.point.y);
    for (let a = 0; a < n.vertices.length; a++) {
      const r = n.vertices[a], l = n.vertices[(a + 1) % n.vertices.length];
      if (!n.closed && a === n.vertices.length - 1) break;
      const c = r.point.x + r.outHandle.x, u = r.point.y + r.outHandle.y, d = l.point.x + l.inHandle.x, h = l.point.y + l.inHandle.y;
      i.bezierCurveTo(c, u, d, h, l.point.x, l.point.y);
    }
    return n.closed && i.closePath(), i;
  }
  /**
   * Convert ShapeColor to CSS color string
   */
  colorToCSS(n) {
    return `rgba(${n.r}, ${n.g}, ${n.b}, ${n.a})`;
  }
  /**
   * Create canvas gradient
   */
  createGradient(n) {
    if (!n)
      return this.ctx.createLinearGradient(0, 0, 0, 0);
    const i = n.startPoint.x * this.canvasWidth, o = n.startPoint.y * this.canvasHeight, a = n.endPoint.x * this.canvasWidth, r = n.endPoint.y * this.canvasHeight;
    let l;
    if (n.type === "linear")
      l = this.ctx.createLinearGradient(i, o, a, r);
    else {
      const c = Math.sqrt(
        Math.pow(a - i, 2) + Math.pow(r - o, 2)
      );
      l = this.ctx.createRadialGradient(i, o, 0, i, o, c);
    }
    for (const c of n.stops)
      l.addColorStop(c.position, this.colorToCSS(c.color));
    return l;
  }
  /**
   * Create extruded 3D geometry from paths
   */
  createExtrudedGeometry(n, i) {
    for (const l of this.extrudedMeshes)
      this.extrudeGroup.remove(l), l.geometry.dispose(), l.material.dispose();
    this.extrudedMeshes = [];
    const o = this.getAnimatedValue(i.depth), a = this.getAnimatedValue(i.bevelDepth), r = this.getAnimatedValue(i.material.frontColor);
    this.getAnimatedValue(i.material.sideColor);
    for (const l of n) {
      if (l.vertices.length < 3 || !l.closed) continue;
      const c = new mu(), u = l.vertices[0];
      c.moveTo(u.point.x, u.point.y);
      for (let f = 0; f < l.vertices.length; f++) {
        const m = l.vertices[f], y = l.vertices[(f + 1) % l.vertices.length], g = m.point.x + m.outHandle.x, x = m.point.y + m.outHandle.y, w = y.point.x + y.inHandle.x, M = y.point.y + y.inHandle.y;
        c.bezierCurveTo(g, x, w, M, y.point.x, y.point.y);
      }
      const d = new Bh(c, {
        depth: o,
        bevelEnabled: a > 0,
        bevelThickness: a,
        bevelSize: a,
        bevelSegments: i.bevelSegments
      }), h = new zm({
        color: new Mt(r.r / 255, r.g / 255, r.b / 255),
        metalness: 0.1,
        roughness: 0.8
      }), p = new Ke(d, h);
      this.extrudeGroup.add(p), this.extrudedMeshes.push(p);
    }
  }
  // ============================================================================
  // CLEANUP
  // ============================================================================
  dispose() {
    this.texture.dispose(), this.mesh.geometry.dispose(), this.mesh.material.dispose();
    for (const n of this.extrudedMeshes)
      n.geometry.dispose(), n.material.dispose();
    super.dispose();
  }
}
class sV {
  constructor(e, n) {
    le(this, "scene");
    le(this, "resources");
    le(this, "layers");
    // Callbacks
    le(this, "onVideoMetadataLoaded");
    le(this, "precompRenderContext", null);
    le(this, "cameraGetter");
    le(this, "cameraAtFrameGetter");
    le(this, "cameraUpdater");
    // Renderer reference for particle systems
    le(this, "rendererRef", null);
    // Composition FPS for particle timing
    le(this, "compositionFPS", 60);
    // Camera reference for particles
    le(this, "cameraRef", null);
    // Audio reactive callback
    le(this, "audioReactiveGetter", null);
    // Track matte canvas cache - stores rendered canvases for layers used as track mattes
    le(this, "trackMatteCanvases", /* @__PURE__ */ new Map());
    // Ordered layer list for render order (respects track matte dependencies)
    le(this, "renderOrder", []);
    // Callback to get cross-composition matte canvas
    le(this, "crossCompMatteGetter", null);
    this.scene = e, this.resources = n, this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(e) {
    this.onVideoMetadataLoaded = e;
  }
  /**
   * Set the precomp render context
   * This allows precomp layers to render nested compositions
   */
  setPrecompRenderContext(e) {
    this.precompRenderContext = e;
    for (const n of this.layers.values())
      n.type === "precomp" && n.setRenderContext(e);
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(e, n, i) {
    this.cameraGetter = e, this.cameraUpdater = n, this.cameraAtFrameGetter = i;
    for (const o of this.layers.values())
      o.type === "camera" && o.setCameraCallbacks(e, n, i);
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(e) {
    this.rendererRef = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setRenderer(e);
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(e) {
    this.compositionFPS = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setFPS(e), n.type === "video" && n.setFPS(e), n.type === "precomp" && n.setFPS(e);
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(e) {
    this.cameraRef = e;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(e) {
    if (this.layers.has(e.id))
      return fi.warn(`LayerManager: Layer ${e.id} already exists, updating instead`), this.update(e.id, e), this.layers.get(e.id);
    const n = this.createLayerInstance(e);
    if (this.layers.set(e.id, n), this.setupLayerCallbacks(n, e), e.parentId) {
      const i = this.layers.get(e.parentId);
      i && n.setParent(i);
    }
    return n.hasParent() || this.scene.addToComposition(n.getObject()), n;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(e, n) {
    if (e.type === "video" && this.onVideoMetadataLoaded && e.setMetadataCallback((o) => {
      this.onVideoMetadataLoaded(n.id, o);
    }), e.type === "precomp" && this.precompRenderContext && e.setRenderContext(this.precompRenderContext), e.type === "camera" && this.cameraGetter && this.cameraUpdater) {
      const i = e;
      i.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter), i.setSplineProvider(this.createSplineProvider());
    }
    if (e.type === "particles") {
      const i = e;
      this.rendererRef && i.setRenderer(this.rendererRef), i.setFPS(this.compositionFPS);
    }
    if (e.type === "video" && e.setFPS(this.compositionFPS), e.type === "precomp" && e.setFPS(this.compositionFPS), e.type === "light") {
      const i = e;
      i.setLayerPositionGetter((o) => {
        const a = this.layers.get(o);
        if (a) {
          const r = a.getObject();
          return new pe(r.position.x, r.position.y, r.position.z);
        }
        return null;
      }), i.setPathProvider(this.createSplineProvider());
    }
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(e) {
    switch (e.type) {
      case "image":
        return new DB(e, this.resources);
      case "solid":
        return new IB(e);
      case "null":
        return new V2(e);
      case "text":
        return new kN(e, this.resources);
      case "spline":
        return new DN(e);
      case "particles":
        return new FN(e);
      case "video":
        return new Fw(e, this.resources);
      case "precomp":
        return new ON(e);
      case "camera":
        return new UN(e);
      case "light":
        return new VN(e);
      case "depthflow":
        return new $N(e, this.resources);
      case "matte":
        return new WN(e);
      case "shape":
        return new iV(e);
      default:
        return fi.warn(`LayerManager: Unknown layer type: ${e.type}, creating NullLayer`), new V2(e);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(e, n) {
    const i = this.layers.get(e);
    if (!i) {
      fi.warn(`LayerManager: Layer ${e} not found for update`);
      return;
    }
    i.update(n);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(e) {
    for (const { id: n, properties: i } of e)
      this.update(n, i);
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(e) {
    const n = this.layers.get(e);
    if (!n) {
      fi.warn(`LayerManager: Layer ${e} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(n.getObject()), n.dispose(), this.layers.delete(e);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(e) {
    for (const n of e)
      this.remove(n);
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [e, n] of this.layers)
      this.scene.removeFromComposition(n.getObject()), n.dispose();
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Apply pre-evaluated state from MotionEngine
   *
   * This is the NEW canonical way to update layer state.
   * Layers receive already-computed values and only APPLY them.
   * NO interpolation or time sampling happens here.
   *
   * Rendering order:
   * 1. Spline layers (for text-on-path dependencies)
   * 2. Text-on-path connections
   * 3. Track matte source layers (render to canvas)
   * 4. All other layers (with track mattes applied)
   *
   * @param evaluatedLayers - Pre-evaluated layer states from MotionEngine
   * @param frame - Optional frame number for animated spline/mask evaluation
   */
  applyEvaluatedState(e, n) {
    const i = n ?? 0;
    for (const o of e) {
      const a = this.layers.get(o.id);
      a && a.type === "spline" && a.applyEvaluatedState(o);
    }
    this.updateTextPathConnections(n), this.processTrackMattes(i);
    for (const o of e) {
      const a = this.layers.get(o.id);
      a && a.type !== "spline" && a.applyEvaluatedState(o);
    }
    this.scene.sortByZ();
  }
  /**
   * Evaluate all layers at a given frame
   *
   * @deprecated Use applyEvaluatedState() with pre-evaluated state from MotionEngine.
   * This method causes layers to internally call interpolateProperty(), violating
   * the single-source-of-truth principle.
   *
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(e, n) {
    this.updateTextPathConnections(e), this.processTrackMattes(e);
    const i = n ?? this.audioReactiveGetter;
    for (const o of this.layers.values()) {
      if (i) {
        const a = i(o.id, e);
        a.size > 0 && o.setAudioReactiveValues(a);
      }
      o.evaluateFrame(e);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    const i = this.layers.get(e);
    i && i.setDrivenValues(n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    const n = this.layers.get(e);
    n && n.clearDrivenValues();
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const e of this.layers.values())
      e.clearDrivenValues();
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   *
   * For animated splines, this must be called with the current frame
   * to get properly evaluated control points.
   *
   * @param frame - Optional frame number for animated spline evaluation
   */
  updateTextPathConnections(e) {
    for (const n of this.layers.values())
      if (n.type === "text") {
        const i = n, o = i.getTextData();
        if (o.pathLayerId) {
          const a = this.layers.get(o.pathLayerId);
          if (a && a.type === "spline")
            if (a.isAnimated() && e !== void 0) {
              const l = a.getEvaluatedControlPoints(e).map((c) => ({
                id: c.id,
                x: c.x,
                y: c.y,
                depth: c.depth,
                handleIn: c.handleIn,
                handleOut: c.handleOut,
                type: c.type
              }));
              i.setPathFromControlPoints(l, a.isClosed());
            } else {
              const r = a.getCurve();
              r && i.setPathFromCurve(r);
            }
        }
      }
  }
  // ============================================================================
  // SPLINE PATH PROVIDER (for Particle Systems)
  // ============================================================================
  /**
   * Create a SplinePathProvider that can be used by particle systems
   * to query spline positions for path-based emission
   *
   * USAGE:
   * ```typescript
   * const provider = layerManager.createSplineProvider();
   * particleSystem.setSplineProvider(provider);
   * ```
   */
  createSplineProvider() {
    return (e, n, i) => this.querySplinePath(e, n, i);
  }
  /**
   * Query a spline layer for position and tangent at parameter t
   *
   * @param layerId - ID of the spline layer
   * @param t - Parameter along the path (0-1)
   * @param frame - Current frame for animated splines
   * @returns Position, tangent, and length or null if spline not found
   */
  querySplinePath(e, n, i) {
    const o = this.layers.get(e);
    if (!o || o.type !== "spline")
      return null;
    const a = o;
    a.isAnimated() && a.getEvaluatedControlPoints(i);
    const r = a.getPointAt(n), l = a.getTangentAt(n), c = a.getLength();
    return !r || !l ? null : {
      point: {
        x: r.x,
        y: -r.y,
        // Negate back from Three.js coordinate system
        z: r.z
      },
      tangent: {
        x: l.x,
        y: -l.y
        // Negate back
      },
      length: c
    };
  }
  /**
   * Get all spline layer IDs (useful for UI to list available paths)
   */
  getSplineLayerIds() {
    const e = [];
    for (const [n, i] of this.layers)
      i.type === "spline" && e.push(n);
    return e;
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(e, n) {
    const i = this.layers.get(e);
    if (!i || i.type !== "text") {
      fi.warn(`LayerManager: Text layer ${e} not found`);
      return;
    }
    if (!n) {
      i.clearPath();
      return;
    }
    const o = this.layers.get(n);
    if (!o || o.type !== "spline") {
      fi.warn(`LayerManager: Spline layer ${n} not found`);
      return;
    }
    const a = o.getCurve();
    a && i.setPathFromCurve(a);
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(e) {
    var n;
    return ((n = this.layers.get(e)) == null ? void 0 : n.getObject()) ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(e) {
    return this.layers.get(e) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(e) {
    return Array.from(this.layers.values()).filter(
      (n) => n.type === e
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(e) {
    return this.layers.has(e);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const e of this.layers.values())
      if (e.hasParent()) {
        const n = e.getParent();
        n && n.getObject().remove(e.getObject());
      }
    for (const e of this.layers.values()) {
      const n = e.getParentId();
      if (n) {
        const i = this.layers.get(n);
        i ? e.setParent(i) : (e.setParent(null), this.scene.addToComposition(e.getObject()));
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(e, n) {
    const i = this.layers.get(e);
    if (i) {
      if (i.hasParent()) {
        const o = i.getParent();
        o && o.getObject().remove(i.getObject());
      } else
        this.scene.removeFromComposition(i.getObject());
      if (n) {
        const o = this.layers.get(n);
        o ? i.setParent(o) : (i.setParent(null), this.scene.addToComposition(i.getObject()));
      } else
        i.setParent(null), this.scene.addToComposition(i.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(e, n) {
    const i = this.layers.get(e);
    i && (i.getObject().position.z = n, this.scene.sortByZ());
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(e, n) {
    const i = this.layers.get(e);
    i && i.setVisible(n);
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(e) {
    const n = this.layers.get(e);
    if (n) {
      const i = !n.getObject().visible;
      return n.setVisible(i), i;
    }
    return !1;
  }
  /**
   * Solo a layer (hide all others)
   */
  soloLayer(e) {
    for (const [n, i] of this.layers)
      i.setVisible(n === e);
  }
  /**
   * Unsolo all layers (show all)
   */
  unsoloAll() {
    for (const e of this.layers.values())
      e.setVisible(!0);
  }
  // ============================================================================
  // TRACK MATTE PROCESSING
  // ============================================================================
  /**
   * Set callback for retrieving cross-composition matte canvases
   *
   * This enables track mattes from other compositions (precomps)
   * to be used as matte sources.
   */
  setCrossCompMatteGetter(e) {
    this.crossCompMatteGetter = e;
  }
  /**
   * Process track mattes for all layers
   *
   * Track mattes use one layer's rendered output to control
   * another layer's visibility (alpha or luma).
   *
   * This method:
   * 1. Identifies layers that are used as track mattes
   * 2. Collects their rendered canvases (from same comp or cross-comp)
   * 3. Passes the canvas to layers that use them as mattes
   *
   * @param frame - Current frame number for animated evaluation
   */
  processTrackMattes(e) {
    this.trackMatteCanvases.clear();
    for (const n of this.layers.values()) {
      const i = n.getTrackMatteLayerId(), o = n.getTrackMatteType();
      if (!i || o === "none")
        continue;
      let a = null;
      if (n.hasCrossCompMatte() && this.crossCompMatteGetter) {
        const r = n.getTrackMatteCompositionId();
        a = this.crossCompMatteGetter(r, i, e), a || fi.warn(
          `Cross-comp track matte not found: composition=${r}, layer=${i}`
        );
      } else {
        const r = this.layers.get(i);
        r ? this.trackMatteCanvases.has(i) ? a = this.trackMatteCanvases.get(i) : (a = this.getLayerRenderedCanvas(r, e), a && this.trackMatteCanvases.set(i, a)) : fi.warn(`Track matte source layer ${i} not found`);
      }
      n.setTrackMatteCanvas(a);
    }
  }
  /**
   * Get the rendered canvas from a layer (for use as track matte)
   *
   * This gets the layer's visual output as a canvas that can be used
   * for track matte operations.
   *
   * @param layer - The layer to get canvas from
   * @param frame - Current frame for animated content
   * @returns Canvas with layer's rendered content, or null if unavailable
   */
  getLayerRenderedCanvas(e, n) {
    var o;
    const i = (o = e.getSourceCanvas) == null ? void 0 : o.call(e);
    if (i) {
      const a = document.createElement("canvas");
      a.width = i.width, a.height = i.height;
      const r = a.getContext("2d");
      if (r)
        return r.drawImage(i, 0, 0), a;
    }
    return null;
  }
  /**
   * Update masks for a specific layer
   */
  setLayerMasks(e, n) {
    const i = this.layers.get(e);
    i && i.setMasks(n);
  }
  /**
   * Clear track matte assignment for a layer
   */
  clearTrackMatte(e) {
    const n = this.layers.get(e);
    n && n.setTrackMatteCanvas(null);
  }
  /**
   * Compute render order respecting track matte dependencies
   *
   * Matte layers must be rendered before the layers that use them.
   * This returns a topologically sorted list of layer IDs.
   */
  computeRenderOrder() {
    const e = [], n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), o = (a) => {
      if (n.has(a)) return;
      if (i.has(a)) {
        fi.warn(`Circular track matte dependency detected involving layer ${a}`);
        return;
      }
      i.add(a);
      const r = this.layers.get(a);
      if (r) {
        const l = r.getTrackMatteLayerId();
        l && this.layers.has(l) && o(l);
        const c = r.getParentId();
        c && this.layers.has(c) && o(c);
      }
      i.delete(a), n.add(a), e.push(a);
    };
    for (const a of this.layers.keys())
      o(a);
    return this.renderOrder = e, e;
  }
  /**
   * Get the computed render order
   */
  getRenderOrder() {
    return this.renderOrder;
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(e, n, i) {
    const o = new Gh(), a = new qe(e, n);
    o.setFromCamera(a, i);
    const r = this.scene.raycastComposition(o), l = /* @__PURE__ */ new Set();
    for (const c of r) {
      let u = c.object;
      for (; u; ) {
        if (u.userData.layerId) {
          l.add(u.userData.layerId);
          break;
        }
        u = u.parent;
      }
    }
    return Array.from(l).map((c) => this.layers.get(c)).filter((c) => c !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const e of this.layers.values())
      this.scene.removeFromComposition(e.getObject()), e.dispose();
    this.layers.clear();
  }
}
class oV {
  constructor(e, n) {
    /** The main camera */
    le(this, "camera");
    /** Keyframe evaluator for animations */
    le(this, "evaluator");
    /** Composition dimensions */
    le(this, "width");
    le(this, "height");
    /** Animation properties */
    le(this, "positionProp");
    le(this, "targetProp");
    le(this, "fovProp");
    /** Current target position (for lookAt) */
    le(this, "target");
    // ============================================================================
    // VIEWPORT ZOOM/PAN
    // ============================================================================
    /** Pan offset for viewport navigation */
    le(this, "panOffset", new qe(0, 0));
    le(this, "zoomLevel", 1);
    this.width = e, this.height = n, this.evaluator = new Ta(), this.camera = new Ti(
      50,
      // Field of view
      e / n,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const i = ln.degToRad(this.camera.fov), o = n / 2 / Math.tan(i / 2);
    this.camera.position.set(e / 2, -n / 2, o), this.target = new pe(e / 2, -n / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(e, n, i) {
    this.camera.position.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(e, n, i) {
    this.target.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera position directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setPositionDirect(e, n, i) {
    this.camera.position.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Set camera target directly (no coordinate transformation)
   * Used by MotionEngine when applying pre-evaluated camera state.
   */
  setTargetDirect(e, n, i) {
    this.target.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(e, n, i) {
    this.camera.rotation.set(
      ln.degToRad(e),
      ln.degToRad(n),
      ln.degToRad(i)
    ), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(e) {
    this.camera.fov = ln.clamp(e, 1, 179), this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(e, n) {
    this.camera.near = Math.max(1e-3, e), this.camera.far = Math.max(this.camera.near + 1, n), this.camera.updateProjectionMatrix();
  }
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(e) {
    this.zoomLevel = Math.max(0.1, Math.min(10, e)), this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation
   */
  setPan(e, n) {
    this.panOffset.set(e, n), this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   */
  updateCameraForViewport() {
    const e = ln.degToRad(this.camera.fov), i = this.height / 2 / Math.tan(e / 2) / this.zoomLevel, o = this.width / 2 - this.panOffset.x / this.zoomLevel, a = this.height / 2 - this.panOffset.y / this.zoomLevel;
    this.camera.position.set(o, -a, i), this.target.set(o, -a, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(e) {
    this.positionProp = e.position, this.targetProp = e.target, this.fovProp = e.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0, this.targetProp = void 0, this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(e) {
    if (this.positionProp) {
      const n = this.evaluator.evaluate(this.positionProp, e);
      this.setPosition(n.x, n.y, n.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const n = this.evaluator.evaluate(this.targetProp, e);
      this.setTarget(n.x, n.y, n.z ?? 0);
    }
    if (this.fovProp) {
      const n = this.evaluator.evaluate(this.fovProp, e);
      this.setFOV(n);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new viewport dimensions
   */
  resize(e, n) {
    this.width = e, this.height = n, this.camera.aspect = e / n, this.camera.updateProjectionMatrix();
    const i = ln.degToRad(this.camera.fov), o = n / 2 / Math.tan(i / 2);
    this.camera.position.x = e / 2, this.camera.position.y = -n / 2, this.camera.position.z = o, this.target.set(e / 2, -n / 2, 0), this.camera.lookAt(this.target);
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(e, n, i = 0) {
    const o = e / this.width * 2 - 1, a = -(n / this.height) * 2 + 1, r = new pe(o, a, 0.5);
    r.unproject(this.camera);
    const l = r.sub(this.camera.position).normalize(), c = (i - this.camera.position.z) / l.z;
    return this.camera.position.clone().add(l.multiplyScalar(c));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(e, n, i = 0) {
    const o = new pe(e, -n, i);
    return o.project(this.camera), {
      x: (o.x + 1) / 2 * this.width,
      y: (-o.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(e) {
    e.position && this.setPosition(e.position.x, e.position.y, e.position.z), e.target && this.setTarget(e.target.x, e.target.y, e.target.z), e.fov !== void 0 && this.setFOV(e.fov), (e.near !== void 0 || e.far !== void 0) && this.setClipPlanes(
      e.near ?? this.camera.near,
      e.far ?? this.camera.far
    );
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const e = ln.degToRad(50), n = this.height / 2 / Math.tan(e / 2);
    this.camera.fov = 50, this.camera.position.set(this.width / 2, -this.height / 2, n), this.target.set(this.width / 2, -this.height / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const e = new du(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    return e.position.set(0, 0, 1e3), e.lookAt(0, 0, 0), e;
  }
}
class aV {
  constructor() {
    // Texture cache (keyed by URL or ID)
    le(this, "textures");
    // Geometry cache (keyed by type and parameters)
    le(this, "geometries");
    // Material cache (keyed by configuration hash)
    le(this, "materials");
    // Texture loader
    le(this, "textureLoader");
    // Asset getter callback (set by WeylEngine)
    le(this, "assetGetter");
    // Statistics
    le(this, "stats", {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    });
    this.textures = /* @__PURE__ */ new Map(), this.geometries = /* @__PURE__ */ new Map(), this.materials = /* @__PURE__ */ new Map(), this.textureLoader = new fw(), this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(e) {
    this.assetGetter = e;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(e) {
    var n;
    return (n = this.assetGetter) == null ? void 0 : n.call(this, e);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const e = new nn(1, 1, 1, 1);
    this.geometries.set("plane:1:1", e);
    const n = new nn(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", n);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(e, n) {
    const i = this.getTextureCacheKey(e, n), o = this.textures.get(i);
    return o ? (this.stats.texturesFromCache++, o) : new Promise((a, r) => {
      this.textureLoader.load(
        e,
        (l) => {
          this.applyTextureOptions(l, n), this.textures.set(i, l), this.stats.texturesLoaded++, a(l);
        },
        void 0,
        // Progress callback
        (l) => {
          Fr.error("ResourceManager: Failed to load texture:", e, l), r(l);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(e, n, i) {
    const o = this.textures.get(n);
    if (o instanceof cs)
      return o.image = e, o.needsUpdate = !0, o;
    const a = new cs(
      e.data,
      e.width,
      e.height,
      Sn,
      ps
    );
    return this.applyTextureOptions(a, i), a.needsUpdate = !0, this.textures.set(n, a), this.stats.texturesLoaded++, a;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(e, n, i) {
    const o = this.textures.get(n);
    if (o instanceof Vc)
      return o.needsUpdate = !0, o;
    const a = new Vc(e);
    return this.applyTextureOptions(a, i), this.textures.set(n, a), this.stats.texturesLoaded++, a;
  }
  /**
   * Get a cached texture
   */
  getTexture(e) {
    return this.textures.get(e);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(e, n) {
    if (!n) {
      e.minFilter = Dt, e.magFilter = Dt, e.generateMipmaps = !1, e.colorSpace = pn;
      return;
    }
    n.wrapS !== void 0 && (e.wrapS = n.wrapS), n.wrapT !== void 0 && (e.wrapT = n.wrapT), n.minFilter !== void 0 && (e.minFilter = n.minFilter), n.magFilter !== void 0 && (e.magFilter = n.magFilter), n.generateMipmaps !== void 0 && (e.generateMipmaps = n.generateMipmaps), n.flipY !== void 0 && (e.flipY = n.flipY), n.colorSpace !== void 0 && (e.colorSpace = n.colorSpace);
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(e, n) {
    return n ? `${e}:${JSON.stringify(n)}` : e;
  }
  /**
   * Release a texture
   */
  releaseTexture(e) {
    const n = this.textures.get(e);
    n && (n.dispose(), this.textures.delete(e));
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(e) {
    const n = `layer:${e}`, i = this.textures.get(n);
    return i || null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(e, n) {
    const i = `layer:${e}`;
    this.textures.set(i, n);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(e = 1, n = 1) {
    const i = `plane:${e}:${n}`;
    let o = this.geometries.get(i);
    return o ? (this.stats.geometriesFromCache++, o) : (o = new nn(e, n, 1, 1), this.geometries.set(i, o), this.stats.geometriesCreated++, o);
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(e = 1, n = 32) {
    const i = `circle:${e}:${n}`;
    let o = this.geometries.get(i);
    return o ? (this.stats.geometriesFromCache++, o) : (o = new pu(e, n), this.geometries.set(i, o), this.stats.geometriesCreated++, o);
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(e = 1, n = 1, i = 1) {
    const o = `box:${e}:${n}:${i}`;
    let a = this.geometries.get(o);
    return a ? (this.stats.geometriesFromCache++, a) : (a = new Mn(e, n, i), this.geometries.set(o, a), this.stats.geometriesCreated++, a);
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(e) {
    const n = `basic:${JSON.stringify(e)}`;
    let i = this.materials.get(n);
    return i || (i = new _n({
      color: e.color ?? 16777215,
      transparent: e.transparent ?? !0,
      opacity: e.opacity ?? 1,
      map: e.map,
      side: e.side ?? mn
    }), this.materials.set(n, i), i);
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(e) {
    switch (e) {
      case "basic":
        return new _n({
          transparent: !0,
          side: mn
        });
      case "standard":
        return new zm({
          transparent: !0,
          side: mn
        });
      case "shader":
        return new dn();
      default:
        return new _n();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const e of this.textures.values())
      e.dispose();
    this.textures.clear();
    for (const e of this.geometries.values())
      e.dispose();
    this.geometries.clear();
    for (const e of this.materials.values())
      e.dispose();
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    Fr.debug("ResourceManager: Resource stats:", this.getStats());
  }
}
class rV {
  constructor() {
    // Frame timing
    le(this, "frameCount", 0);
    le(this, "lastTime", 0);
    le(this, "frameTimes", []);
    le(this, "maxFrameTimes", 60);
    // FPS calculation
    le(this, "fps", 0);
    le(this, "fpsUpdateInterval", 500);
    // ms
    le(this, "lastFpsUpdate", 0);
    le(this, "framesInInterval", 0);
    // Frame start time (for measuring frame duration)
    le(this, "frameStartTime", 0);
    // Last captured stats
    le(this, "lastStats", {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(e) {
    const n = performance.now(), i = n - this.frameStartTime;
    this.frameTimes.push(i), this.frameTimes.length > this.maxFrameTimes && this.frameTimes.shift(), this.frameCount++, this.framesInInterval++;
    const o = n - this.lastFpsUpdate;
    o >= this.fpsUpdateInterval && (this.fps = Math.round(this.framesInInterval * 1e3 / o), this.framesInInterval = 0, this.lastFpsUpdate = n);
    const a = e.info, r = performance.memory, l = (r == null ? void 0 : r.usedJSHeapSize) ?? 0, c = this.frameTimes.length > 0 ? this.frameTimes.reduce((u, d) => u + d, 0) / this.frameTimes.length : 0;
    return this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(c * 100) / 100,
      drawCalls: a.render.calls,
      triangles: a.render.triangles,
      textures: a.memory.textures,
      geometries: a.memory.geometries,
      memoryUsed: l
    }, this.lastTime = n, this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    return this.frameTimes.length === 0 ? 0 : this.frameTimes.reduce((e, n) => e + n, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    return this.frameTimes.length === 0 ? { min: 0, max: 0 } : {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0, this.frameTimes = [], this.fps = 0, this.framesInInterval = 0, this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime, this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(e = 30) {
    return this.fps > 0 && this.fps < e;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const e = this.lastStats, n = this.getFrameTimeRange();
    return [
      `FPS: ${e.fps}`,
      `Frame Time: ${e.frameTime.toFixed(2)}ms (min: ${n.min.toFixed(2)}, max: ${n.max.toFixed(2)})`,
      `Draw Calls: ${e.drawCalls}`,
      `Triangles: ${e.triangles.toLocaleString()}`,
      `Textures: ${e.textures}`,
      `Geometries: ${e.geometries}`,
      `Memory: ${(e.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join(`
`);
  }
}
class lV {
  constructor(e) {
    // Core subsystems
    le(this, "scene");
    le(this, "renderer");
    le(this, "layers");
    le(this, "camera");
    le(this, "resources");
    le(this, "performance");
    // State
    le(this, "state");
    le(this, "animationFrameId", null);
    // Background and overlay images
    le(this, "backgroundImage", null);
    le(this, "depthMapMesh", null);
    le(this, "depthMapSettings", { colormap: "viridis", opacity: 0.5, visible: !1 });
    // Viewport transform for pan/zoom
    le(this, "viewportTransform", [1, 0, 0, 1, 0, 0]);
    // Render mode
    le(this, "renderMode", "color");
    // Audio reactivity
    le(this, "audioReactiveGetter", null);
    // Transform controls for layer manipulation
    le(this, "transformControls", null);
    le(this, "selectedLayerId", null);
    le(this, "transformMode", "translate");
    // Transform change callback
    le(this, "onTransformChange", null);
    // Event system
    le(this, "eventHandlers");
    // Configuration
    le(this, "config");
    // Active camera tracking
    le(this, "activeCameraGetter");
    le(this, "activeCameraId", null);
    this.validateConfig(e), this.config = {
      canvas: e.canvas,
      width: e.width,
      height: e.height,
      compositionWidth: e.compositionWidth ?? e.width,
      compositionHeight: e.compositionHeight ?? e.height,
      pixelRatio: e.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      backgroundColor: e.backgroundColor ?? null,
      debug: e.debug ?? !1,
      powerPreference: e.powerPreference ?? "high-performance"
    }, this.state = {
      currentFrame: 0,
      // DEPRECATED: Use MotionEngine as time authority
      isRendering: !1,
      isDisposed: !1,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    }, this.eventHandlers = /* @__PURE__ */ new Map(), this.resources = new aV(), this.scene = new fB(this.config.backgroundColor), this.camera = new oV(this.config.width, this.config.height), this.renderer = new kB({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera), this.layers = new sV(this.scene, this.resources), this.performance = new rV(), this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    ), this.setupContextLossHandling(), this.config.debug && _s.debug("Initialized", this.config);
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(e) {
    if (!(e.canvas instanceof HTMLCanvasElement))
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    if (e.width <= 0 || e.height <= 0)
      throw new Error("WeylEngine requires positive width and height");
    if (e.width > 8192 || e.height > 8192)
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(e) {
    this.assertNotDisposed(), this.layers.create(e), this.emit("layerAdded", { layerId: e.id }), this.config.debug && _s.debug("Layer added:", e.id, e.type);
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(e, n) {
    this.assertNotDisposed(), this.layers.update(e, n), this.emit("layerUpdated", { layerId: e, properties: n });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(e) {
    this.assertNotDisposed(), this.layers.remove(e), this.emit("layerRemoved", { layerId: e }), this.config.debug && _s.debug("Layer removed:", e);
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(e) {
    return this.layers.getObject(e);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(e) {
    this.assertNotDisposed();
    const n = new Set(this.layers.getLayerIds()), i = new Set(e.map((o) => o.id));
    for (const o of n)
      i.has(o) || this.layers.remove(o);
    for (const o of e)
      n.has(o.id) ? this.layers.update(o.id, o) : this.layers.create(o);
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(e) {
    this.resources.setAssetGetter(e);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(e) {
    this.layers.setVideoMetadataCallback(e);
  }
  /**
   * Set the precomp render context for LayerManager
   * Allows precomp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setPrecompRenderContext(e) {
    this.layers.setPrecompRenderContext(e);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(e, n, i) {
    this.layers.setCameraCallbacks(e, n, i), this.activeCameraGetter = e;
  }
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(e) {
    this.activeCameraId = e;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter)
      return;
    const e = this.layers.getLayer(this.activeCameraId);
    if (!e || e.type !== "camera")
      return;
    const n = e, i = n.getExportData();
    if (!i)
      return;
    this.camera.setPosition(i.position.x, i.position.y, i.position.z), this.camera.setRotation(i.rotation.x, i.rotation.y, i.rotation.z), this.camera.setFOV(i.fov), this.camera.setClipPlanes(i.nearClip, i.farClip);
    const o = n.getCameraAtCurrentFrame();
    o && o.depthOfField && this.setDOFFromCamera(o.depthOfField);
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(e) {
    this.layers.setCompositionFPS(e);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer()), this.layers.setCamera(this.camera.camera);
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const e = this.camera.camera;
    return {
      projectionMatrix: e.projectionMatrix.clone(),
      viewMatrix: e.matrixWorldInverse.clone(),
      projectionMatrixInverse: e.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    this.layers.setLayerDrivenValues(e, n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    this.layers.clearLayerDrivenValues(e);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Apply a pre-evaluated FrameState from MotionEngine
   *
   * This is the CANONICAL way to update the rendering state.
   * FrameState is computed by MotionEngine.evaluate() which is PURE.
   *
   * ARCHITECTURAL RULE:
   * - Layers receive already-evaluated values via applyEvaluatedState()
   * - NO interpolation or time sampling happens here
   * - Single source of truth: MotionEngine
   *
   * @param frameState - Pre-evaluated state from MotionEngine.evaluate()
   */
  applyFrameState(e) {
    this.assertNotDisposed(), this.state.currentFrame = e.frame, this.layers.applyEvaluatedState(e.layers, e.frame), e.camera ? this.applyCameraState(e.camera) : (this.syncActiveCamera(), this.activeCameraId || this.camera.evaluateFrame(e.frame));
  }
  /**
   * Apply evaluated camera state directly
   */
  applyCameraState(e) {
    e && (this.camera.setPositionDirect(
      e.position.x,
      e.position.y,
      e.position.z
    ), this.camera.setTargetDirect(
      e.target.x,
      e.target.y,
      e.target.z
    ), this.camera.setFOV(e.fov));
  }
  /**
   * Set the current frame for animation evaluation
   *
   * @deprecated Use applyFrameState() with MotionEngine.evaluate() instead.
   * This method evaluates frames directly, bypassing the single time authority.
   * It is kept for backwards compatibility but should be phased out.
   *
   * @param frame - The frame number (0-indexed)
   */
  setFrame(e) {
    this.assertNotDisposed(), this.state.currentFrame = e, this.layers.evaluateFrame(e, this.audioReactiveGetter), this.syncActiveCamera(), this.activeCameraId || this.camera.evaluateFrame(e);
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e, this.layers.setAudioReactiveCallback(e);
  }
  /**
   * Get the current frame
   * @deprecated Frame authority is now MotionEngine. This returns cached value.
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed(), this.performance.beginFrame(), this.emit("frameStart", { frame: this.state.currentFrame }), this.renderer.render(), this.emit("frameEnd", { frame: this.state.currentFrame }), this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    if (this.assertNotDisposed(), this.animationFrameId !== null)
      return;
    this.state.isRendering = !0;
    const e = () => {
      !this.state.isRendering || this.state.isDisposed || (this.render(), this.animationFrameId = requestAnimationFrame(e));
    };
    this.animationFrameId = requestAnimationFrame(e);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = !1, this.animationFrameId !== null && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(e, n, i, o) {
    if (this.assertNotDisposed(), e <= 0 || n <= 0) {
      _s.warn("Invalid resize dimensions:", e, n);
      return;
    }
    this.state.viewport = { width: e, height: n }, this.renderer.resize(e, n);
    const a = i ?? e, r = o ?? n;
    this.camera.resize(a, r), this.emit("resize", { width: e, height: n, compositionWidth: i, compositionHeight: o });
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Set camera position
   */
  setCameraPosition(e, n, i) {
    this.camera.setPosition(e, n, i);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(e, n, i) {
    this.camera.setTarget(e, n, i);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(e) {
    this.camera.setFOV(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(e) {
    this.renderer.setDOF({
      enabled: e.enabled,
      focusDistance: e.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: e.aperture * 1e-4,
      maxBlur: e.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(e) {
    this.renderer.setDOFEnabled(e);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(e) {
    this.renderer.setFocusDistance(e);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(e) {
    this.renderer.setAperture(e * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // SSAO (Screen Space Ambient Occlusion)
  // ============================================================================
  /**
   * Configure SSAO effect
   * @param config - SSAO configuration options
   */
  setSSAO(e) {
    this.renderer.setSSAO(e);
  }
  /**
   * Enable or disable SSAO
   */
  setSSAOEnabled(e) {
    this.renderer.setSSAOEnabled(e);
  }
  /**
   * Set SSAO intensity
   * @param intensity - Occlusion intensity multiplier
   */
  setSSAOIntensity(e) {
    this.renderer.setSSAOIntensity(e);
  }
  /**
   * Set SSAO sampling radius
   * @param radius - Kernel radius for occlusion sampling
   */
  setSSAORadius(e) {
    this.renderer.setSSAORadius(e);
  }
  /**
   * Get current SSAO configuration
   */
  getSSAO() {
    return this.renderer.getSSAO();
  }
  // ============================================================================
  // BLOOM (Emissive Glow)
  // ============================================================================
  /**
   * Configure bloom effect
   * Makes emissive objects (lights, bright particles) glow
   * @param config - Bloom configuration options
   */
  setBloom(e) {
    this.renderer.setBloom(e);
  }
  /**
   * Enable or disable bloom
   */
  setBloomEnabled(e) {
    this.renderer.setBloomEnabled(e);
  }
  /**
   * Set bloom intensity
   * @param strength - Bloom strength multiplier
   */
  setBloomStrength(e) {
    this.renderer.setBloomStrength(e);
  }
  /**
   * Set bloom threshold
   * @param threshold - Brightness threshold for bloom (0-1)
   */
  setBloomThreshold(e) {
    this.renderer.setBloomThreshold(e);
  }
  /**
   * Get current bloom configuration
   */
  getBloom() {
    return this.renderer.getBloom();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(e) {
    this.viewportTransform = [...e];
    const n = e[0], i = e[4], o = e[5];
    this.camera.setZoom(n), this.camera.setPan(i, o);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(e) {
    this.assertNotDisposed(), this.backgroundImage && (this.scene.removeFromComposition(this.backgroundImage), this.backgroundImage.geometry.dispose(), this.backgroundImage.material.dispose());
    const n = new An(e);
    n.needsUpdate = !0, n.colorSpace = pn;
    const i = new nn(e.width, e.height), o = new _n({
      map: n,
      transparent: !0,
      depthWrite: !1
    });
    this.backgroundImage = new Ke(i, o), this.backgroundImage.position.set(e.width / 2, e.height / 2, -1e3), this.backgroundImage.userData.isBackground = !0, this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(e, n) {
    this.assertNotDisposed(), this.depthMapSettings = {
      colormap: n.colormap ?? this.depthMapSettings.colormap,
      opacity: n.opacity ?? this.depthMapSettings.opacity,
      visible: n.visible ?? this.depthMapSettings.visible
    }, this.depthMapMesh && (this.scene.removeFromComposition(this.depthMapMesh), this.depthMapMesh.geometry.dispose(), this.depthMapMesh.material.dispose());
    const i = new An(e);
    i.needsUpdate = !0;
    const o = this.createColormapMaterial(i, this.depthMapSettings), a = new nn(e.width, e.height);
    this.depthMapMesh = new Ke(a, o), this.depthMapMesh.position.set(e.width / 2, e.height / 2, -999), this.depthMapMesh.visible = this.depthMapSettings.visible, this.depthMapMesh.userData.isDepthOverlay = !0, this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(e, n) {
    const i = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, o = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `, a = n.colormap === "viridis" ? 0 : n.colormap === "plasma" ? 1 : 2;
    return new dn({
      uniforms: {
        depthMap: { value: e },
        opacity: { value: n.opacity },
        colormap: { value: a }
      },
      vertexShader: i,
      fragmentShader: o,
      transparent: !0,
      depthWrite: !1
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(e) {
    this.depthMapSettings.visible = e, this.depthMapMesh && (this.depthMapMesh.visible = e);
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(e) {
    if (this.depthMapSettings.colormap = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material, i = e === "viridis" ? 0 : e === "plasma" ? 1 : 2;
      n.uniforms.colormap.value = i;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(e) {
    if (this.depthMapSettings.opacity = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material;
      n.uniforms.opacity.value = e;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, this.renderer.setRenderMode(e);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(e, n) {
    const i = new Gh(), o = new qe(e, n);
    i.setFromCamera(o, this.camera.getCamera());
    const a = this.scene.raycastComposition(i);
    for (const r of a) {
      let l = r.object;
      for (; l; ) {
        if (l.userData.layerId)
          return l.userData.layerId;
        if (l.userData.isBackground || l.userData.isDepthOverlay)
          break;
        l = l.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    if (this.assertNotDisposed(), this.transformControls)
      return;
    const e = this.camera.getCamera(), n = this.renderer.getDomElement();
    this.transformControls = new sB(e, n), this.transformControls.setMode(this.transformMode), this.transformControls.setSpace("world"), this.transformControls.setSize(1), this.scene.addUIElement(this.transformControls), this.transformControls.addEventListener("change", () => {
      if (!this.transformControls || !this.selectedLayerId) return;
      const i = this.transformControls.object;
      if (!i) return;
      const o = {
        position: {
          x: i.position.x,
          y: i.position.y,
          z: i.position.z
        },
        rotationX: ln.radToDeg(i.rotation.x),
        rotationY: ln.radToDeg(i.rotation.y),
        rotationZ: ln.radToDeg(i.rotation.z),
        scale: {
          x: i.scale.x * 100,
          // Convert back to percentage
          y: i.scale.y * 100,
          z: i.scale.z * 100
        }
      };
      o.rotation = o.rotationZ, this.onTransformChange && this.onTransformChange(this.selectedLayerId, o);
    }), this.transformControls.addEventListener("dragging-changed", (i) => {
      this.emit("transform-dragging", { dragging: i.value });
    }), this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(e) {
    this.onTransformChange = e;
  }
  /**
   * Select a layer and attach transform controls
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(e) {
    if (this.assertNotDisposed(), this.transformControls || this.initializeTransformControls(), this.selectedLayerId && this.transformControls && this.transformControls.detach(), this.selectedLayerId = e, !e || !this.transformControls)
      return;
    const n = this.getLayerObject(e);
    n && this.transformControls.attach(n);
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(e) {
    this.transformMode = e, this.transformControls && this.transformControls.setMode(e);
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(e) {
    this.transformControls && (this.transformControls.visible = e, this.transformControls.enabled = e);
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    var e;
    return ((e = this.transformControls) == null ? void 0 : e.dragging) ?? !1;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const e = this.renderer.captureFrame();
    return {
      imageData: e,
      width: e.width,
      height: e.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(e = "png", n = 0.95) {
    this.assertNotDisposed();
    const { imageData: i, width: o, height: a } = this.captureFrame(), r = new OffscreenCanvas(o, a);
    return r.getContext("2d").putImageData(i, 0, 0), r.convertToBlob({
      type: `image/${e}`,
      quality: n
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const e = this.renderer.captureDepth(), n = this.camera.getState();
    return {
      depthBuffer: e,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: n.near,
      far: n.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var o;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (o = this.eventHandlers.get(e)) == null || o.forEach((a) => {
      try {
        a(i);
      } catch (r) {
        _s.error(`Event handler error for ${e}:`, r);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const e = this.config.canvas;
    e.addEventListener("webglcontextlost", (n) => {
      n.preventDefault(), this.stopRenderLoop(), this.emit("contextLost", null), _s.warn("WebGL context lost");
    }), e.addEventListener("webglcontextrestored", () => {
      this.emit("contextRestored", null), _s.info("WebGL context restored");
    });
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed)
      throw new Error("WeylEngine has been disposed");
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    this.state.isDisposed || (this.stopRenderLoop(), this.layers.dispose(), this.renderer.dispose(), this.scene.dispose(), this.resources.dispose(), this.eventHandlers.clear(), this.state.isDisposed = !0, this.emit("dispose", null), this.config.debug && _s.debug("Disposed"));
  }
}
const cV = { class: "spline-editor" }, uV = ["viewBox"], dV = ["x1", "y1", "x2", "y2"], hV = ["x1", "y1", "x2", "y2"], fV = ["cx", "cy", "onMousedown"], pV = ["cx", "cy", "onMousedown"], mV = ["cx", "cy", "onMousedown"], vV = ["cx", "cy"], gV = /* @__PURE__ */ Bt({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(s, { expose: e, emit: n }) {
    const i = s, o = n, a = un(), r = xe(null), l = xe(null), c = xe(null), u = Re(() => {
      if (!i.layerId) return [];
      const w = a.layers.find((_) => _.id === i.layerId);
      return !w || w.type !== "spline" || !w.data ? [] : w.data.controlPoints || [];
    });
    function d(w, M) {
      const _ = i.viewportTransform, C = (w - _[4]) / _[0], T = (M - _[5]) / _[3];
      return { x: C, y: T };
    }
    function h(w) {
      const _ = w.currentTarget.getBoundingClientRect(), C = w.clientX - _.left, T = w.clientY - _.top;
      return d(C, T);
    }
    function p(w) {
      if (!i.isPenMode) return;
      const M = h(w);
      if (i.layerId) {
        const _ = a.layers.find((C) => C.id === i.layerId);
        if (_ && _.type === "spline") {
          const C = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: M.x,
            y: M.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          a.addSplineControlPoint(i.layerId, C), r.value = C.id, c.value = {
            type: "handleOut",
            pointId: C.id,
            startX: M.x,
            startY: M.y
          }, o("pointAdded", C), o("pathUpdated");
        }
      }
    }
    function f(w) {
      var _;
      const M = h(w);
      if (i.isPenMode && (l.value = M), c.value && i.layerId) {
        const C = a.layers.find((E) => E.id === i.layerId);
        if (!C || C.type !== "spline") return;
        const P = (_ = C.data.controlPoints) == null ? void 0 : _.find((E) => E.id === c.value.pointId);
        if (!P) return;
        if (c.value.type === "point") {
          const E = M.x - P.x, b = M.y - P.y, S = { x: M.x, y: M.y };
          P.handleIn && (S.handleIn = { x: P.handleIn.x + E, y: P.handleIn.y + b }), P.handleOut && (S.handleOut = { x: P.handleOut.x + E, y: P.handleOut.y + b }), a.updateSplineControlPoint(i.layerId, P.id, S), o("pointMoved", P.id, M.x, M.y);
        } else if (c.value.type === "handleIn") {
          const E = { handleIn: { x: M.x, y: M.y } };
          if (P.type === "smooth") {
            const b = M.x - P.x, S = M.y - P.y;
            E.handleOut = { x: P.x - b, y: P.y - S };
          }
          a.updateSplineControlPoint(i.layerId, P.id, E), o("handleMoved", P.id, "in", M.x, M.y);
        } else if (c.value.type === "handleOut") {
          const E = { handleOut: { x: M.x, y: M.y } };
          if (P.type === "smooth") {
            const b = M.x - P.x, S = M.y - P.y;
            E.handleIn = { x: P.x - b, y: P.y - S };
          }
          a.updateSplineControlPoint(i.layerId, P.id, E), o("handleMoved", P.id, "out", M.x, M.y);
        }
        o("pathUpdated");
      }
    }
    function m() {
      var w;
      if (c.value && i.layerId) {
        const M = a.layers.find((_) => _.id === i.layerId);
        if (M && M.type === "spline") {
          const C = (w = M.data.controlPoints) == null ? void 0 : w.find((T) => T.id === c.value.pointId);
          if (C && C.handleOut) {
            const T = C.handleOut.x - C.x, P = C.handleOut.y - C.y;
            Math.sqrt(T * T + P * P) > 5 ? a.updateSplineControlPoint(i.layerId, C.id, {
              type: "smooth",
              handleIn: { x: C.x - T, y: C.y - P }
            }) : a.updateSplineControlPoint(i.layerId, C.id, {
              handleOut: null
            });
          }
        }
        c.value = null, o("pathUpdated");
      }
    }
    function y(w, M) {
      if (r.value = w, !i.isPenMode) {
        const _ = h(M);
        c.value = {
          type: "point",
          pointId: w,
          startX: _.x,
          startY: _.y
        };
      }
    }
    function g(w, M, _) {
      const C = h(_);
      c.value = {
        type: M === "in" ? "handleIn" : "handleOut",
        pointId: w,
        startX: C.x,
        startY: C.y
      };
    }
    function x(w) {
      if ((w.key === "Delete" || w.key === "Backspace") && r.value && i.layerId) {
        const M = a.layers.find((_) => _.id === i.layerId);
        if (M && M.type === "spline") {
          const _ = r.value;
          a.deleteSplineControlPoint(i.layerId, _), o("pointDeleted", _), o("pathUpdated"), r.value = null;
        }
      }
    }
    return gn(() => {
      window.addEventListener("keydown", x);
    }), Un(() => {
      window.removeEventListener("keydown", x);
    }), e({
      selectedPointId: r,
      clearSelection: () => {
        r.value = null;
      }
    }), (w, M) => (se(), re("div", cV, [
      (se(), re("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${s.canvasWidth} ${s.canvasHeight}`,
        onMousedown: p,
        onMousemove: f,
        onMouseup: m,
        onMouseleave: m
      }, [
        (se(!0), re(Xe, null, at(u.value, (_) => (se(), re(Xe, {
          key: `handles-${_.id}`
        }, [
          _.handleIn && r.value === _.id ? (se(), re("line", {
            key: 0,
            x1: _.x,
            y1: _.y,
            x2: _.handleIn.x,
            y2: _.handleIn.y,
            class: "handle-line"
          }, null, 8, dV)) : Te("", !0),
          _.handleOut && r.value === _.id ? (se(), re("line", {
            key: 1,
            x1: _.x,
            y1: _.y,
            x2: _.handleOut.x,
            y2: _.handleOut.y,
            class: "handle-line"
          }, null, 8, hV)) : Te("", !0)
        ], 64))), 128)),
        (se(!0), re(Xe, null, at(u.value, (_) => {
          var C, T;
          return se(), re(Xe, {
            key: `handle-points-${_.id}`
          }, [
            _.handleIn && r.value === _.id ? (se(), re("circle", {
              key: 0,
              cx: _.handleIn.x,
              cy: _.handleIn.y,
              r: "4",
              class: Le(["handle-point", { active: ((C = c.value) == null ? void 0 : C.type) === "handleIn" && c.value.pointId === _.id }]),
              onMousedown: _t((P) => g(_.id, "in", P), ["stop"])
            }, null, 42, fV)) : Te("", !0),
            _.handleOut && r.value === _.id ? (se(), re("circle", {
              key: 1,
              cx: _.handleOut.x,
              cy: _.handleOut.y,
              r: "4",
              class: Le(["handle-point", { active: ((T = c.value) == null ? void 0 : T.type) === "handleOut" && c.value.pointId === _.id }]),
              onMousedown: _t((P) => g(_.id, "out", P), ["stop"])
            }, null, 42, pV)) : Te("", !0)
          ], 64);
        }), 128)),
        (se(!0), re(Xe, null, at(u.value, (_) => (se(), re("circle", {
          key: `point-${_.id}`,
          cx: _.x,
          cy: _.y,
          r: "6",
          class: Le(["control-point", {
            selected: r.value === _.id,
            corner: _.type === "corner",
            smooth: _.type === "smooth"
          }]),
          onMousedown: _t((C) => y(_.id, C), ["stop"])
        }, null, 42, mV))), 128)),
        l.value && s.isPenMode ? (se(), re("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, vV)) : Te("", !0)
      ], 40, uV))
    ]));
  }
}), yV = /* @__PURE__ */ Vt(gV, [["__scopeId", "data-v-55bdee8d"]]), xV = {
  key: 1,
  class: "overlay-controls"
}, bV = { class: "render-mode-controls" }, _V = {
  key: 2,
  class: "transform-mode-controls"
}, wV = {
  key: 3,
  class: "performance-overlay"
}, MV = {
  key: 4,
  class: "loading-overlay"
}, SV = ["src"], CV = {
  key: 7,
  class: "segment-loading"
}, TV = /* @__PURE__ */ Bt({
  __name: "ThreeCanvas",
  setup(s, { expose: e }) {
    const n = un(), i = xe(null), o = xe(null), a = xe(null), r = w4(null), l = xe(!1), c = xe(1), u = xe(800), d = xe(600), h = xe(!1), p = xe("viridis"), f = xe(50), m = xe("color"), y = xe(!1), g = xe({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    }), x = xe([1, 0, 0, 1, 0, 0]), w = xe("translate"), M = xe(!1), _ = xe(null), C = Re(() => {
      const B = n.segmentPendingMask;
      if (!B) return {};
      const L = x.value, D = B.bounds.x * L[0] + L[4], j = B.bounds.y * L[3] + L[5], Z = B.bounds.width * L[0], z = B.bounds.height * L[3];
      return {
        left: `${D}px`,
        top: `${j}px`,
        width: `${Z}px`,
        height: `${z}px`
      };
    }), T = Re(() => {
      const B = n.segmentBoxStart, L = _.value;
      if (!B || !L) return {};
      const D = x.value, j = B.x * D[0] + D[4], Z = B.y * D[3] + D[5], z = L.x * D[0] + D[4], $ = L.y * D[3] + D[5];
      return {
        left: `${Math.min(j, z)}px`,
        top: `${Math.min(Z, $)}px`,
        width: `${Math.abs(z - j)}px`,
        height: `${Math.abs($ - Z)}px`
      };
    }), P = Re(() => n.depthMap !== null), E = Re(() => n.currentTool === "pen"), b = Re(() => {
      const B = n.selectedLayer;
      if ((B == null ? void 0 : B.type) === "spline")
        return B.id;
      if (E.value) {
        const L = n.layers.filter((D) => D.type === "spline");
        return L.length > 0 ? L[L.length - 1].id : null;
      }
      return null;
    }), S = Re(() => x.value);
    gn(async () => {
      if (!o.value || !i.value) return;
      const B = i.value, L = B.getBoundingClientRect();
      u.value = L.width, d.value = L.height;
      const D = {
        canvas: o.value,
        width: L.width,
        height: L.height,
        compositionWidth: n.width || 1920,
        compositionHeight: n.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: !0,
        alpha: !0,
        powerPreference: "high-performance"
      };
      try {
        l.value = !0, r.value = new lV(D), r.value.setAssetGetter((z) => n.assets[z]), r.value.setVideoMetadataCallback((z, $) => {
          n.onVideoMetadataLoaded(z, $);
        }), r.value.setCameraCallbacks(
          (z) => n.getCamera(z),
          (z, $) => n.updateCamera(z, $),
          (z, $) => n.getCameraAtFrame(z, $)
        ), r.value.setPrecompRenderContext({
          renderComposition: (z, $) => (n.getComposition(z) && console.log("[ThreeCanvas] Precomp render requested:", z, "frame:", $), null),
          getComposition: (z) => n.getComposition(z)
        }), r.value.setAudioReactiveCallback(
          (z, $) => n.getAudioReactiveValuesForLayer(z, $)
        ), r.value.initializeTransformControls(), r.value.setTransformChangeCallback((z, $) => {
          K(z, $);
        }), r.value.initializeParticleSystems(), r.value.setCompositionFPS(n.fps || 60), r.value.start(), await Xi(), R(), n.initializePropertyDriverSystem();
        const j = n.getFrameState(n.currentFrame);
        r.value.applyFrameState(j), fe(), new ResizeObserver(ee).observe(B), ce();
      } catch (j) {
        console.error("[ThreeCanvas] Failed to initialize engine:", j);
      } finally {
        l.value = !1;
      }
      A();
    }), Un(() => {
      r.value && (r.value.stop(), r.value.dispose(), r.value = null);
    });
    function A() {
      Ft(
        () => n.layers,
        () => {
          if (R(), r.value) {
            const B = n.getFrameState(n.currentFrame);
            r.value.applyFrameState(B);
          }
        },
        { deep: !0 }
      ), Ft(
        () => n.currentFrame,
        (B) => {
          if (r.value) {
            k();
            const L = n.getFrameState(B);
            r.value.applyFrameState(L);
          }
        }
      ), Ft(
        () => [n.width, n.height],
        ([B, L]) => {
          r.value && (r.value.resize(u.value, d.value, B, L), ce());
        }
      ), Ft(
        () => n.sourceImage,
        async (B) => {
          r.value && B && await U(B);
        },
        { immediate: !0 }
      ), Ft(
        () => n.depthMap,
        async (B) => {
          r.value && B && await I(B);
        },
        { immediate: !0 }
      ), Ft(
        () => {
          var B;
          return (B = r.value) == null ? void 0 : B.getPerformanceStats();
        },
        (B) => {
          B && (g.value = B);
        }
      ), Ft(
        () => n.activeCameraId,
        (B) => {
          if (!r.value) return;
          if (!B) {
            r.value.setActiveCameraLayer(null);
            return;
          }
          const L = n.layers.find(
            (D) => {
              var j;
              return D.type === "camera" && ((j = D.data) == null ? void 0 : j.cameraId) === B;
            }
          );
          L && r.value.setActiveCameraLayer(L.id);
        },
        { immediate: !0 }
      ), Ft(
        () => n.selectedLayerIds,
        (B) => {
          if (!r.value) return;
          const L = B.length > 0 ? B[0] : null;
          r.value.selectLayer(L);
        },
        { deep: !0 }
      );
    }
    function R() {
      if (!r.value) return;
      const B = new Set(r.value.getLayerIds()), L = new Set(n.layers.map((D) => D.id));
      for (const D of B)
        L.has(D) || r.value.removeLayer(D);
      for (const D of n.layers)
        B.has(D.id) ? r.value.updateLayer(D.id, D) : r.value.addLayer(D);
    }
    function k() {
      if (r.value) {
        r.value.clearAllDrivenValues();
        for (const B of n.layers) {
          const L = n.getDrivenValuesForLayer(B.id);
          L.size > 0 && r.value.setLayerDrivenValues(B.id, L);
        }
      }
    }
    async function U(B) {
      if (r.value)
        try {
          l.value = !0;
          const L = await W(B);
          r.value.setBackgroundImage(L);
        } catch (L) {
          console.error("[ThreeCanvas] Failed to load source image:", L);
        } finally {
          l.value = !1;
        }
    }
    async function I(B) {
      if (r.value)
        try {
          const L = await W(B);
          r.value.setDepthMap(L, {
            colormap: p.value,
            opacity: f.value / 100,
            visible: h.value
          });
        } catch (L) {
          console.error("[ThreeCanvas] Failed to load depth map:", L);
        }
    }
    function W(B) {
      return new Promise((L, D) => {
        const j = new Image();
        j.crossOrigin = "anonymous", j.onload = () => L(j), j.onerror = D, j.src = B.startsWith("data:") ? B : `data:image/png;base64,${B}`;
      });
    }
    function fe() {
      const B = i.value, L = o.value;
      if (!B || !L) return;
      let D = !1, j = !1, Z = 0, z = 0, $ = 0, oe = 1;
      B.addEventListener("mousedown", (O) => {
        O.button === 1 && O.preventDefault();
      }), B.addEventListener("auxclick", (O) => {
        O.button === 1 && O.preventDefault();
      }), L.addEventListener("wheel", (O) => {
        O.preventDefault();
        const V = O.deltaY;
        let H = c.value * (V > 0 ? 0.9 : 1.1);
        H = Math.min(Math.max(H, 0.1), 10);
        const X = L.getBoundingClientRect(), ue = O.clientX - X.left, me = O.clientY - X.top, _e = H / c.value;
        x.value[4] = ue - _e * (ue - x.value[4]), x.value[5] = me - _e * (me - x.value[5]), x.value[0] = H, x.value[3] = H, c.value = H, r.value && r.value.setViewportTransform(x.value);
      }, { passive: !1 }), L.addEventListener("mousedown", (O) => {
        var H, X;
        const V = n.currentTool;
        if (O.button === 1 || V === "hand" || O.button === 0 && O.altKey) {
          D = !0, Z = O.clientX, z = O.clientY, L.style.cursor = "grabbing", O.preventDefault();
          return;
        }
        if (V === "zoom") {
          if (O.shiftKey) {
            const ue = Math.max(c.value * 0.7, 0.1);
            c.value = ue, x.value[0] = ue, x.value[3] = ue, r.value && r.value.setViewportTransform(x.value);
          } else
            j = !0, $ = O.clientY, oe = c.value;
          return;
        }
        if (V === "text") {
          const ue = L.getBoundingClientRect(), me = q(O.clientX - ue.left, O.clientY - ue.top), _e = n.createLayer("text");
          (H = _e.transform) != null && H.position && (_e.transform.position.value = { x: me.x, y: me.y, z: 0 }), n.updateLayer(_e.id, {
            transform: {
              ..._e.transform,
              position: {
                ..._e.transform.position,
                value: { x: me.x, y: me.y, z: 0 }
              }
            }
          }), n.selectLayer(_e.id), n.setTool("select");
          return;
        }
        if (V === "segment" && O.button === 0) {
          const ue = L.getBoundingClientRect(), me = q(O.clientX - ue.left, O.clientY - ue.top);
          n.segmentMode === "point" ? G(me.x, me.y) : (n.setSegmentBoxStart({ x: me.x, y: me.y }), _.value = { x: me.x, y: me.y }, M.value = !0);
          return;
        }
        if (V === "select" && O.button === 0) {
          if ((X = r.value) != null && X.isTransformDragging())
            return;
          const ue = L.getBoundingClientRect(), me = (O.clientX - ue.left) / ue.width * 2 - 1, _e = -((O.clientY - ue.top) / ue.height) * 2 + 1;
          if (r.value) {
            const we = r.value.raycastLayers(me, _e);
            we ? (n.selectLayer(we), r.value.selectLayer(we)) : (n.clearSelection(), r.value.selectLayer(null));
          }
        }
      }), L.addEventListener("mousemove", (O) => {
        if (D) {
          const H = O.clientX - Z, X = O.clientY - z;
          x.value[4] += H, x.value[5] += X, Z = O.clientX, z = O.clientY, r.value && r.value.setViewportTransform(x.value);
          return;
        }
        if (j) {
          const X = 1 + ($ - O.clientY) * 0.01, ue = Math.max(0.1, Math.min(10, oe * X));
          c.value = ue, x.value[0] = ue, x.value[3] = ue, r.value && r.value.setViewportTransform(x.value);
          return;
        }
        if (M.value && n.segmentBoxStart) {
          const H = L.getBoundingClientRect(), X = q(O.clientX - H.left, O.clientY - H.top);
          _.value = { x: X.x, y: X.y };
          return;
        }
        const V = n.currentTool;
        V === "hand" ? L.style.cursor = "grab" : V === "zoom" ? L.style.cursor = "zoom-in" : V === "text" ? L.style.cursor = "text" : V === "pen" || V === "segment" ? L.style.cursor = "crosshair" : L.style.cursor = "default";
      }), L.addEventListener("mouseup", (O) => {
        D && (D = !1, L.style.cursor = n.currentTool === "hand" ? "grab" : "default"), j && (j = !1), M.value && n.segmentBoxStart && _.value && (M.value = !1, Q(
          n.segmentBoxStart.x,
          n.segmentBoxStart.y,
          _.value.x,
          _.value.y
        ), n.setSegmentBoxStart(null), _.value = null);
      }), L.addEventListener("mouseleave", () => {
        D = !1, j = !1, M.value && (M.value = !1, n.setSegmentBoxStart(null), _.value = null);
      });
    }
    function q(B, L) {
      const D = x.value;
      return {
        x: (B - D[4]) / D[0],
        y: (L - D[5]) / D[3]
      };
    }
    async function G(B, L) {
      if (!n.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      n.setSegmentLoading(!0);
      try {
        const D = await qm(n.sourceImage, { x: B, y: L });
        if (D.status === "success" && D.masks && D.masks.length > 0) {
          const j = D.masks[0];
          n.setSegmentPendingMask({
            mask: j.mask,
            bounds: j.bounds,
            area: j.area,
            score: j.score
          }), console.log("[ThreeCanvas] Segmentation successful, mask area:", j.area);
        } else
          console.warn("[ThreeCanvas] Segmentation returned no masks:", D.message);
      } catch (D) {
        console.error("[ThreeCanvas] Segmentation failed:", D);
      } finally {
        n.setSegmentLoading(!1);
      }
    }
    async function Q(B, L, D, j) {
      if (!n.sourceImage) {
        console.warn("[ThreeCanvas] No source image for segmentation");
        return;
      }
      const Z = [
        Math.min(B, D),
        Math.min(L, j),
        Math.max(B, D),
        Math.max(L, j)
      ];
      n.setSegmentLoading(!0);
      try {
        const z = await Zm(n.sourceImage, Z);
        if (z.status === "success" && z.masks && z.masks.length > 0) {
          const $ = z.masks[0];
          n.setSegmentPendingMask({
            mask: $.mask,
            bounds: $.bounds,
            area: $.area,
            score: $.score
          }), console.log("[ThreeCanvas] Box segmentation successful, mask area:", $.area);
        } else
          console.warn("[ThreeCanvas] Box segmentation returned no masks:", z.message);
      } catch (z) {
        console.error("[ThreeCanvas] Box segmentation failed:", z);
      } finally {
        n.setSegmentLoading(!1);
      }
    }
    function K(B, L) {
      var Z, z, $, oe;
      const D = n.layers.find((O) => O.id === B);
      if (!D) return;
      const j = {};
      L.position && D.transform && (j.transform = {
        ...D.transform,
        position: {
          ...D.transform.position,
          value: {
            x: L.position.x,
            y: L.position.y,
            z: L.position.z ?? ((z = (Z = D.transform.position) == null ? void 0 : Z.value) == null ? void 0 : z.z) ?? 0
          }
        }
      }), D.threeD ? (L.rotationX !== void 0 || L.rotationY !== void 0 || L.rotationZ !== void 0) && (!j.transform && D.transform && (j.transform = { ...D.transform }), j.transform && (L.rotationX !== void 0 && (j.transform.rotationX = { ...D.transform.rotationX, value: L.rotationX }), L.rotationY !== void 0 && (j.transform.rotationY = { ...D.transform.rotationY, value: L.rotationY }), L.rotationZ !== void 0 && (j.transform.rotationZ = { ...D.transform.rotationZ, value: L.rotationZ }))) : L.rotation !== void 0 && D.transform && (j.transform || (j.transform = { ...D.transform }), j.transform.rotation = { ...D.transform.rotation, value: L.rotation }), L.scale && D.transform && (j.transform || (j.transform = { ...D.transform }), j.transform.scale = {
        ...D.transform.scale,
        value: {
          x: L.scale.x,
          y: L.scale.y,
          z: L.scale.z ?? ((oe = ($ = D.transform.scale) == null ? void 0 : $.value) == null ? void 0 : oe.z) ?? 100
        }
      }), Object.keys(j).length > 0 && n.updateLayer(B, j);
    }
    function Y(B) {
      w.value = B, r.value && r.value.setTransformMode(B);
    }
    function ee(B) {
      for (const L of B) {
        const { width: D, height: j } = L.contentRect;
        D > 0 && j > 0 && (u.value = D, d.value = j, r.value && r.value.resize(D, j));
      }
    }
    function ce() {
      const B = i.value;
      if (!B || !r.value) return;
      const L = n.width || 1920, D = n.height || 1080, j = B.getBoundingClientRect(), Z = 60, z = (j.width - Z * 2) / L, $ = (j.height - Z * 2) / D, oe = Math.min(z, $, 1);
      x.value = [
        oe,
        0,
        0,
        oe,
        (j.width - L * oe) / 2,
        (j.height - D * oe) / 2
      ], c.value = oe, r.value.setViewportTransform(x.value);
    }
    function ae(B) {
      m.value = B, r.value && r.value.setRenderMode(B);
    }
    function de(B) {
      if (!b.value) {
        const L = n.createLayer("spline");
        n.selectLayer(L.id);
      }
    }
    function ie() {
      R();
    }
    function he() {
      const B = Math.min(c.value * 1.2, 10);
      c.value = B, x.value[0] = B, x.value[3] = B, r.value && r.value.setViewportTransform(x.value);
    }
    function ne() {
      const B = Math.max(c.value * 0.8, 0.1);
      c.value = B, x.value[0] = B, x.value[3] = B, r.value && r.value.setViewportTransform(x.value);
    }
    function N() {
      ce();
    }
    async function te() {
      if (!r.value) return null;
      const B = r.value.captureFrame();
      if (!(B != null && B.imageData)) return null;
      const L = document.createElement("canvas");
      L.width = B.width, L.height = B.height;
      const D = L.getContext("2d");
      return D ? (D.putImageData(B.imageData, 0, 0), L.toDataURL("image/png")) : null;
    }
    async function F() {
      if (!r.value) return null;
      const B = r.value.captureDepth();
      if (!(B != null && B.depthBuffer)) return null;
      const L = document.createElement("canvas");
      L.width = B.width, L.height = B.height;
      const D = L.getContext("2d");
      if (!D) return null;
      const j = D.createImageData(B.width, B.height);
      for (let Z = 0; Z < B.depthBuffer.length; Z++) {
        const z = Math.floor(B.depthBuffer[Z] * 255), $ = Z * 4;
        j.data[$] = z, j.data[$ + 1] = z, j.data[$ + 2] = z, j.data[$ + 3] = 255;
      }
      return D.putImageData(j, 0, 0), L.toDataURL("image/png");
    }
    return Ft(h, (B) => {
      r.value && r.value.setDepthOverlayVisible(B);
    }), Ft(p, (B) => {
      r.value && r.value.setDepthColormap(B);
    }), Ft(f, (B) => {
      r.value && r.value.setDepthOpacity(B / 100);
    }), e({
      engine: r,
      fitToView: N,
      zoomIn: he,
      zoomOut: ne,
      zoom: c,
      captureFrame: te,
      captureDepth: F,
      showPerformance: y,
      performanceStats: g,
      renderMode: m,
      setRenderMode: ae,
      transformMode: w,
      setTransformModeTo: Y
    }), (B, L) => (se(), re("div", {
      class: "three-canvas",
      ref_key: "containerRef",
      ref: i
    }, [
      v("canvas", {
        ref_key: "canvasRef",
        ref: o
      }, null, 512),
      b.value || E.value ? (se(), Tt(yV, {
        key: 0,
        layerId: b.value,
        canvasWidth: u.value,
        canvasHeight: d.value,
        zoom: c.value,
        viewportTransform: S.value,
        isPenMode: E.value,
        onPointAdded: de,
        onPathUpdated: ie,
        ref_key: "splineEditorRef",
        ref: a
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : Te("", !0),
      P.value ? (se(), re("div", xV, [
        v("label", null, [
          st(v("input", {
            type: "checkbox",
            "onUpdate:modelValue": L[0] || (L[0] = (D) => h.value = D)
          }, null, 512), [
            [Ci, h.value]
          ]),
          L[9] || (L[9] = ct(" Depth Overlay ", -1))
        ]),
        st(v("select", {
          "onUpdate:modelValue": L[1] || (L[1] = (D) => p.value = D),
          class: "colormap-select"
        }, [...L[10] || (L[10] = [
          v("option", { value: "viridis" }, "Viridis", -1),
          v("option", { value: "plasma" }, "Plasma", -1),
          v("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [En, p.value]
        ]),
        st(v("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": L[2] || (L[2] = (D) => f.value = D),
          class: "opacity-slider"
        }, null, 512), [
          [
            Ot,
            f.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : Te("", !0),
      v("div", bV, [
        v("button", {
          class: Le({ active: m.value === "color" }),
          onClick: L[3] || (L[3] = (D) => ae("color")),
          title: "Color View"
        }, [...L[11] || (L[11] = [
          v("i", { class: "pi pi-image" }, null, -1)
        ])], 2),
        v("button", {
          class: Le({ active: m.value === "depth" }),
          onClick: L[4] || (L[4] = (D) => ae("depth")),
          title: "Depth View"
        }, [...L[12] || (L[12] = [
          v("i", { class: "pi pi-box" }, null, -1)
        ])], 2),
        v("button", {
          class: Le({ active: m.value === "normal" }),
          onClick: L[5] || (L[5] = (D) => ae("normal")),
          title: "Normal View"
        }, [...L[13] || (L[13] = [
          v("i", { class: "pi pi-compass" }, null, -1)
        ])], 2)
      ]),
      He(n).selectedLayerIds.length > 0 ? (se(), re("div", _V, [
        v("button", {
          class: Le({ active: w.value === "translate" }),
          onClick: L[6] || (L[6] = (D) => Y("translate")),
          title: "Move (V)"
        }, [...L[14] || (L[14] = [
          v("i", { class: "pi pi-arrows-alt" }, null, -1)
        ])], 2),
        v("button", {
          class: Le({ active: w.value === "rotate" }),
          onClick: L[7] || (L[7] = (D) => Y("rotate")),
          title: "Rotate (R)"
        }, [...L[15] || (L[15] = [
          v("i", { class: "pi pi-sync" }, null, -1)
        ])], 2),
        v("button", {
          class: Le({ active: w.value === "scale" }),
          onClick: L[8] || (L[8] = (D) => Y("scale")),
          title: "Scale (S)"
        }, [...L[16] || (L[16] = [
          v("i", { class: "pi pi-expand" }, null, -1)
        ])], 2)
      ])) : Te("", !0),
      y.value ? (se(), re("div", wV, [
        v("span", null, "FPS: " + ye(g.value.fps), 1),
        v("span", null, "Draw: " + ye(g.value.drawCalls), 1),
        v("span", null, "Tris: " + ye(g.value.triangles), 1)
      ])) : Te("", !0),
      l.value ? (se(), re("div", MV, [...L[17] || (L[17] = [
        v("div", { class: "loading-spinner" }, null, -1),
        v("span", null, "Loading...", -1)
      ])])) : Te("", !0),
      He(n).segmentPendingMask ? (se(), re("div", {
        key: 5,
        class: "segment-mask-overlay",
        style: xt(C.value)
      }, [
        v("img", {
          src: "data:image/png;base64," + He(n).segmentPendingMask.mask,
          class: "mask-preview",
          alt: "Segmentation mask"
        }, null, 8, SV)
      ], 4)) : Te("", !0),
      M.value && He(n).segmentBoxStart && _.value ? (se(), re("div", {
        key: 6,
        class: "segment-box-preview",
        style: xt(T.value)
      }, null, 4)) : Te("", !0),
      He(n).segmentIsLoading ? (se(), re("div", CV, [...L[18] || (L[18] = [
        v("div", { class: "segment-spinner" }, null, -1),
        v("span", null, "Segmenting...", -1)
      ])])) : Te("", !0)
    ], 512));
  }
}), EV = /* @__PURE__ */ Vt(TV, [["__scopeId", "data-v-8dfcdece"]]), AV = { class: "prop-wrapper" }, PV = { class: "prop-content" }, kV = { class: "prop-name" }, DV = { class: "prop-inputs" }, IV = {
  key: 0,
  class: "vec-item"
}, RV = {
  key: 1,
  class: "color-input-wrapper"
}, LV = ["value"], FV = { class: "color-hex" }, OV = { class: "vec-item" }, UV = { class: "vec-item" }, zV = ["onMousedown", "onDblclick", "onContextmenu"], BV = /* @__PURE__ */ Bt({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(s, { emit: e }) {
    const n = s, i = un(), o = xe(/* @__PURE__ */ new Set()), a = xe(null), r = xe(!1), l = xe(0), c = xe(0), u = xe({
      visible: !1,
      x: 0,
      y: 0,
      keyframe: null
    }), d = Re(() => ({
      left: `${u.value.x}px`,
      top: `${u.value.y}px`
    })), h = Re(() => {
      const R = Math.min(l.value, c.value), k = Math.abs(c.value - l.value);
      return {
        left: `${R}px`,
        width: `${k}px`
      };
    }), p = Re(() => {
      var R;
      return (R = n.property.keyframes) == null ? void 0 : R.some((k) => k.frame === i.currentFrame);
    }), f = Re(() => i.selectedPropertyPath === n.propertyPath);
    function m() {
      i.setPropertyAnimated(n.layerId, n.propertyPath, !n.property.animated);
    }
    function y() {
      i.addKeyframe(n.layerId, n.propertyPath, n.property.value);
    }
    function g(R) {
      i.setPropertyValue(n.layerId, n.propertyPath, R);
    }
    function x(R, k) {
      const U = { ...n.property.value, [R]: k };
      i.setPropertyValue(n.layerId, n.propertyPath, U);
    }
    function w() {
      i.selectProperty(n.propertyPath);
    }
    function M(R) {
      const k = R.currentTarget.getBoundingClientRect(), U = R.clientX - k.left;
      r.value = !0, l.value = U, c.value = U, R.shiftKey || o.value.clear();
      const I = (fe) => {
        const q = fe.clientX - k.left;
        c.value = Math.max(0, q);
        const G = Math.min(l.value, c.value) / n.pixelsPerFrame, Q = Math.max(l.value, c.value) / n.pixelsPerFrame;
        fe.shiftKey || o.value.clear();
        for (const K of n.property.keyframes || [])
          K.frame >= G && K.frame <= Q && o.value.add(K.id);
      }, W = (fe) => {
        if (r.value = !1, Math.abs(c.value - l.value) < 5) {
          const G = Math.round(l.value / n.pixelsPerFrame);
          i.setFrame(Math.max(0, Math.min(i.frameCount - 1, G)));
        }
        window.removeEventListener("mousemove", I), window.removeEventListener("mouseup", W);
      };
      window.addEventListener("mousemove", I), window.addEventListener("mouseup", W);
    }
    function _(R, k) {
      R.shiftKey ? o.value.has(k.id) ? o.value.delete(k.id) : o.value.add(k.id) : (o.value.clear(), o.value.add(k.id));
      const U = R.clientX, I = k.frame, W = (q) => {
        const G = q.clientX - U, Q = Math.round(G / n.pixelsPerFrame);
        let K = Math.max(0, Math.min(i.frameCount - 1, I + Q));
        if (!q.altKey && i.snapConfig.enabled) {
          const Y = Wh(K, i.snapConfig, n.pixelsPerFrame, {
            layers: i.layers,
            selectedLayerId: n.layerId,
            currentFrame: i.currentFrame,
            audioAnalysis: i.audioAnalysis,
            peakData: i.peakData
          });
          Y && (K = Y.frame);
        }
        K !== k.frame && i.moveKeyframe(n.layerId, n.propertyPath, k.id, K);
      }, fe = () => {
        window.removeEventListener("mousemove", W), window.removeEventListener("mouseup", fe);
      };
      window.addEventListener("mousemove", W), window.addEventListener("mouseup", fe);
    }
    function C(R) {
      i.removeKeyframe(n.layerId, n.propertyPath, R), o.value.delete(R);
    }
    function T(R, k) {
      var I;
      o.value.has(k.id) || (o.value.clear(), o.value.add(k.id));
      const U = (I = a.value) == null ? void 0 : I.getBoundingClientRect();
      U && (u.value = {
        visible: !0,
        x: R.clientX - U.left,
        y: R.clientY - U.top,
        keyframe: k
      });
    }
    function P() {
      u.value.visible = !1, u.value.keyframe = null;
    }
    function E(R) {
      for (const k of o.value)
        i.setKeyframeInterpolation(n.layerId, n.propertyPath, k, R);
      P();
    }
    function b() {
      u.value.keyframe && i.setFrame(u.value.keyframe.frame), P();
    }
    function S() {
      for (const R of o.value)
        i.removeKeyframe(n.layerId, n.propertyPath, R);
      o.value.clear(), P();
    }
    function A(R) {
      u.value.visible && P();
    }
    return gn(() => {
      document.addEventListener("click", A);
    }), Un(() => {
      document.removeEventListener("click", A);
    }), (R, k) => {
      var U, I, W, fe;
      return se(), re("div", AV, [
        s.layoutMode === "sidebar" ? (se(), re("div", {
          key: 0,
          class: Le(["prop-sidebar", { selected: f.value }]),
          style: xt(s.gridStyle),
          onClick: w
        }, [
          k[10] || (k[10] = v("div", { class: "indent-spacer" }, null, -1)),
          v("div", {
            class: "icon-box",
            onClick: _t(y, ["stop"])
          }, [
            v("span", {
              class: Le(["kf-btn", { active: p.value }])
            }, "", 2)
          ]),
          v("div", {
            class: "icon-box",
            onClick: _t(m, ["stop"])
          }, [
            v("span", {
              class: Le(["stopwatch", { active: s.property.animated }])
            }, "", 2)
          ]),
          v("div", PV, [
            v("span", kV, ye(s.name), 1),
            v("div", DV, [
              s.name === "Z Position" ? (se(), re("div", IV, [
                k[7] || (k[7] = v("span", { class: "label z-label" }, "Z", -1)),
                Ne(it, {
                  modelValue: ((U = s.property.value) == null ? void 0 : U.z) ?? 0,
                  "onUpdate:modelValue": k[0] || (k[0] = (q) => x("z", q))
                }, null, 8, ["modelValue"])
              ])) : s.property.type === "color" ? (se(), re("div", RV, [
                v("input", {
                  type: "color",
                  value: s.property.value,
                  onInput: k[1] || (k[1] = (q) => g(q.target.value))
                }, null, 40, LV),
                v("span", FV, ye(s.property.value), 1)
              ])) : typeof s.property.value == "object" ? (se(), re(Xe, { key: 2 }, [
                v("div", OV, [
                  k[8] || (k[8] = v("span", { class: "label x-label" }, "X", -1)),
                  Ne(it, {
                    modelValue: s.property.value.x,
                    "onUpdate:modelValue": k[2] || (k[2] = (q) => x("x", q))
                  }, null, 8, ["modelValue"])
                ]),
                v("div", UV, [
                  k[9] || (k[9] = v("span", { class: "label y-label" }, "Y", -1)),
                  Ne(it, {
                    modelValue: s.property.value.y,
                    "onUpdate:modelValue": k[3] || (k[3] = (q) => x("y", q))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof s.property.value == "number" ? (se(), Tt(it, {
                key: 3,
                modelValue: s.property.value,
                "onUpdate:modelValue": g,
                precision: 1
              }, null, 8, ["modelValue"])) : Te("", !0)
            ])
          ])
        ], 6)) : (se(), re("div", {
          key: 1,
          class: "prop-track",
          onMousedown: M,
          ref_key: "trackRef",
          ref: a
        }, [
          r.value ? (se(), re("div", {
            key: 0,
            class: "selection-box",
            style: xt(h.value)
          }, null, 4)) : Te("", !0),
          (se(!0), re(Xe, null, at(s.property.keyframes, (q) => (se(), re("div", {
            key: q.id,
            class: Le(["keyframe", { selected: o.value.has(q.id), [q.interpolation || "linear"]: !0 }]),
            style: xt({ left: `${q.frame * s.pixelsPerFrame}px` }),
            onMousedown: _t((G) => _(G, q), ["stop"]),
            onDblclick: _t((G) => C(q.id), ["stop"]),
            onContextmenu: _t((G) => T(G, q), ["prevent", "stop"])
          }, null, 46, zV))), 128)),
          u.value.visible ? (se(), re("div", {
            key: 1,
            class: "keyframe-context-menu",
            style: xt(d.value)
          }, [
            k[16] || (k[16] = v("div", { class: "menu-header" }, "Interpolation", -1)),
            v("div", {
              class: Le(["menu-item", { active: ((I = u.value.keyframe) == null ? void 0 : I.interpolation) === "linear" }]),
              onClick: k[4] || (k[4] = (q) => E("linear"))
            }, [...k[11] || (k[11] = [
              v("span", { class: "icon" }, "", -1),
              ct(" Linear ", -1)
            ])], 2),
            v("div", {
              class: Le(["menu-item", { active: ((W = u.value.keyframe) == null ? void 0 : W.interpolation) === "bezier" }]),
              onClick: k[5] || (k[5] = (q) => E("bezier"))
            }, [...k[12] || (k[12] = [
              v("span", { class: "icon" }, "", -1),
              ct(" Bezier ", -1)
            ])], 2),
            v("div", {
              class: Le(["menu-item", { active: ((fe = u.value.keyframe) == null ? void 0 : fe.interpolation) === "hold" }]),
              onClick: k[6] || (k[6] = (q) => E("hold"))
            }, [...k[13] || (k[13] = [
              v("span", { class: "icon" }, "", -1),
              ct(" Hold ", -1)
            ])], 2),
            k[17] || (k[17] = v("div", { class: "menu-divider" }, null, -1)),
            v("div", {
              class: "menu-item",
              onClick: b
            }, [...k[14] || (k[14] = [
              v("span", { class: "icon" }, "", -1),
              ct(" Go to Frame ", -1)
            ])]),
            v("div", {
              class: "menu-item delete",
              onClick: S
            }, [...k[15] || (k[15] = [
              v("span", { class: "icon" }, "", -1),
              ct(" Delete ", -1)
            ])])
          ], 4)) : Te("", !0)
        ], 544))
      ]);
    };
  }
}), r9 = /* @__PURE__ */ Vt(BV, [["__scopeId", "data-v-32aca4cb"]]), NV = {
  key: 0,
  class: "track-wrapper"
}, VV = { class: "arrow" }, HV = { class: "layer-id" }, GV = { class: "type-icon" }, $V = {
  key: 0,
  class: "name-text"
}, WV = { class: "col-mode" }, jV = ["value"], XV = { class: "col-parent" }, YV = ["value"], qV = ["value"], ZV = {
  key: 0,
  class: "children-container"
}, KV = ["onMousedown"], JV = { class: "arrow-col" }, QV = { class: "arrow" }, eH = { class: "group-label" }, tH = { key: 0 }, nH = {
  key: 0,
  class: "children-container"
}, iH = { key: 0 }, sH = /* @__PURE__ */ Bt({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = un(), a = xe(!1), r = Re(() => n.isExpandedExternal ?? a.value), l = Re(() => o.selectedLayerIds.includes(n.layer.id)), c = xe(["Transform", "Text", "More Options"]), u = xe(!1), d = xe(""), h = xe(null), p = xe(!1), f = xe(0), m = xe(0), y = Re(() => {
      var ae;
      return ((ae = n.allLayers) == null ? void 0 : ae.filter((de) => de.id !== n.layer.id)) || [];
    }), g = Re(() => {
      const ae = {}, de = n.layer.transform, ie = [], he = (ne, N, te) => {
        te && ie.push({ path: ne, name: N, property: te });
      };
      return he("transform.anchorPoint", "Anchor Point", de.anchorPoint), he("transform.position", "Position", de.position), n.layer.threeD && ie.push({
        path: "transform.position.z",
        name: "Z Position",
        property: de.position
        // Pass full position property, PropertyTrack handles .z
      }), he("transform.scale", "Scale", de.scale), n.layer.threeD ? (de.orientation && ie.push({ path: "transform.orientation", name: "Orientation", property: de.orientation }), de.rotationX && ie.push({ path: "transform.rotationX", name: "X Rotation", property: de.rotationX }), de.rotationY && ie.push({ path: "transform.rotationY", name: "Y Rotation", property: de.rotationY }), de.rotationZ && ie.push({ path: "transform.rotationZ", name: "Z Rotation", property: de.rotationZ })) : de.rotation && ie.push({ path: "transform.rotation", name: "Rotation", property: de.rotation }), n.layer.opacity && ie.push({ path: "opacity", name: "Opacity", property: n.layer.opacity }), ae.Transform = ie, n.layer.properties && n.layer.properties.forEach((ne) => {
        const N = ne.group || "Properties";
        ae[N] || (ae[N] = []), ae[N].push({ path: ne.name, name: ne.name, property: ne });
      }), ae;
    }), x = Re(() => {
      const ae = n.pixelsPerFrame || 10;
      return { left: `${n.layer.inPoint * ae}px`, width: `${(n.layer.outPoint - n.layer.inPoint + 1) * ae}px` };
    });
    function w() {
      i("select", n.layer.id);
    }
    function M() {
      i("toggleExpand", n.layer.id, !r.value);
    }
    function _(ae) {
      c.value.includes(ae) ? c.value = c.value.filter((de) => de !== ae) : c.value.push(ae);
    }
    function C(ae) {
      return { text: "T", solid: "", camera: "" }[ae] || "";
    }
    function T() {
      u.value = !0, d.value = n.layer.name, Xi(() => {
        var ae;
        return (ae = h.value) == null ? void 0 : ae.focus();
      });
    }
    function P() {
      i("updateLayer", n.layer.id, { name: d.value }), u.value = !1;
    }
    function E(ae) {
      i("updateLayer", n.layer.id, { parentId: ae.target.value || null });
    }
    function b(ae) {
      i("updateLayer", n.layer.id, { blendMode: ae.target.value });
    }
    function S() {
    }
    function A() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function R() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function k() {
    }
    function U() {
      const ae = o.getActiveComp();
      if (!ae) return;
      const de = {
        anchorPoint: { x: ae.settings.width / 2, y: ae.settings.height / 2 },
        position: { x: ae.settings.width / 2, y: ae.settings.height / 2, z: 0 },
        scale: { x: 100, y: 100 },
        rotation: 0,
        rotationX: 0,
        rotationY: 0,
        rotationZ: 0,
        orientation: { x: 0, y: 0, z: 0 },
        opacity: 100
      }, ie = n.layer.transform;
      ie.anchorPoint && (ie.anchorPoint.value = { ...de.anchorPoint }), ie.position && (ie.position.value = n.layer.threeD ? { ...de.position } : { x: de.position.x, y: de.position.y }), ie.scale && (ie.scale.value = { x: de.scale.x, y: de.scale.y }), ie.rotation && (ie.rotation.value = de.rotation), ie.rotationX && (ie.rotationX.value = de.rotationX), ie.rotationY && (ie.rotationY.value = de.rotationY), ie.rotationZ && (ie.rotationZ.value = de.rotationZ), ie.orientation && (ie.orientation.value = { ...de.orientation }), n.layer.opacity && (n.layer.opacity.value = de.opacity), o.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[EnhancedLayerTrack] Reset transform for layer:", n.layer.name);
    }
    function I(ae) {
      f.value = ae.clientX, m.value = ae.clientY, p.value = !0, l.value || i("select", n.layer.id);
    }
    function W() {
      p.value = !1;
    }
    function fe() {
      o.duplicateLayer(n.layer.id), W();
    }
    function q() {
      W(), Xi(() => {
        u.value = !0, d.value = n.layer.name, Xi(() => {
          var ae;
          return (ae = h.value) == null ? void 0 : ae.focus();
        });
      });
    }
    function G() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible }), W();
    }
    function Q() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked }), W();
    }
    function K() {
      o.toggleLayer3D(n.layer.id), W();
    }
    function Y() {
      o.selectLayer(n.layer.id), o.precomposeSelectedLayers(n.layer.name + " Precomp"), W();
    }
    function ee() {
      o.deleteLayer(n.layer.id), W();
    }
    function ce(ae) {
      p.value && W();
    }
    return gn(() => {
      document.addEventListener("click", ce);
    }), Un(() => {
      document.removeEventListener("click", ce);
    }), (ae, de) => s.layer ? (se(), re("div", NV, [
      s.layoutMode === "sidebar" ? (se(), re(Xe, { key: 0 }, [
        v("div", {
          class: Le(["sidebar-row", { selected: l.value }]),
          style: xt(s.gridStyle),
          onMousedown: w,
          onContextmenu: _t(I, ["prevent"])
        }, [
          v("div", {
            class: "arrow-col",
            onMousedown: _t(M, ["stop"])
          }, [
            v("span", VV, ye(r.value ? "" : ""), 1)
          ], 32),
          v("div", {
            class: "label-box",
            onMousedown: _t(k, ["stop"]),
            style: xt({ background: s.layer.labelColor || "#999" })
          }, null, 36),
          v("div", HV, ye(s.index), 1),
          v("div", {
            class: "icon-col",
            onMousedown: _t(A, ["stop"])
          }, ye(s.layer.visible ? "" : ""), 33),
          v("div", {
            class: "icon-col",
            onMousedown: _t(R, ["stop"])
          }, ye(s.layer.locked ? "" : ""), 33),
          v("div", {
            class: Le(["icon-col cube-icon", { active: s.layer.threeD }]),
            onMousedown: de[0] || (de[0] = _t((ie) => He(o).toggleLayer3D(s.layer.id), ["stop"]))
          }, "", 34),
          v("div", {
            class: "layer-name-col",
            onDblclick: _t(T, ["stop"])
          }, [
            v("span", GV, ye(C(s.layer.type)), 1),
            u.value ? st((se(), re("input", {
              key: 1,
              "onUpdate:modelValue": de[1] || (de[1] = (ie) => d.value = ie),
              onBlur: P,
              onKeydown: Lr(P, ["enter"]),
              class: "rename-input",
              ref_key: "renameInput",
              ref: h
            }, null, 544)), [
              [Ot, d.value]
            ]) : (se(), re("span", $V, ye(s.layer.name), 1))
          ], 32),
          v("div", WV, [
            v("select", {
              value: s.layer.blendMode,
              class: "mini-select",
              onChange: b,
              onMousedown: de[2] || (de[2] = _t(() => {
              }, ["stop"]))
            }, [...de[5] || (de[5] = [
              fs('<optgroup label="Normal" data-v-fb7680b0><option value="normal" data-v-fb7680b0>Normal</option><option value="dissolve" data-v-fb7680b0>Dissolve</option></optgroup><optgroup label="Darken" data-v-fb7680b0><option value="darken" data-v-fb7680b0>Darken</option><option value="multiply" data-v-fb7680b0>Multiply</option><option value="colorBurn" data-v-fb7680b0>Color Burn</option><option value="linearBurn" data-v-fb7680b0>Linear Burn</option></optgroup><optgroup label="Lighten" data-v-fb7680b0><option value="add" data-v-fb7680b0>Add</option><option value="lighten" data-v-fb7680b0>Lighten</option><option value="screen" data-v-fb7680b0>Screen</option><option value="colorDodge" data-v-fb7680b0>Color Dodge</option><option value="linearDodge" data-v-fb7680b0>Linear Dodge</option></optgroup><optgroup label="Contrast" data-v-fb7680b0><option value="overlay" data-v-fb7680b0>Overlay</option><option value="softLight" data-v-fb7680b0>Soft Light</option><option value="hardLight" data-v-fb7680b0>Hard Light</option><option value="vividLight" data-v-fb7680b0>Vivid Light</option><option value="linearLight" data-v-fb7680b0>Linear Light</option><option value="pinLight" data-v-fb7680b0>Pin Light</option><option value="hardMix" data-v-fb7680b0>Hard Mix</option></optgroup><optgroup label="Inversion" data-v-fb7680b0><option value="difference" data-v-fb7680b0>Difference</option><option value="exclusion" data-v-fb7680b0>Exclusion</option><option value="subtract" data-v-fb7680b0>Subtract</option><option value="divide" data-v-fb7680b0>Divide</option></optgroup><optgroup label="Component" data-v-fb7680b0><option value="hue" data-v-fb7680b0>Hue</option><option value="saturation" data-v-fb7680b0>Saturation</option><option value="color" data-v-fb7680b0>Color</option><option value="luminosity" data-v-fb7680b0>Luminosity</option></optgroup>', 6)
            ])], 40, jV)
          ]),
          v("div", XV, [
            v("select", {
              value: s.layer.parentId || "",
              class: "mini-select",
              onChange: E,
              onMousedown: de[3] || (de[3] = _t(() => {
              }, ["stop"]))
            }, [
              de[6] || (de[6] = v("option", { value: "" }, "None", -1)),
              (se(!0), re(Xe, null, at(y.value, (ie) => (se(), re("option", {
                key: ie.id,
                value: ie.id
              }, ye(ie.index), 9, qV))), 128))
            ], 40, YV)
          ])
        ], 38),
        r.value ? (se(), re("div", ZV, [
          (se(!0), re(Xe, null, at(g.value, (ie, he) => (se(), re("div", {
            key: he,
            class: "property-group"
          }, [
            v("div", {
              class: "group-header sidebar-row",
              style: xt(s.gridStyle),
              onMousedown: _t((ne) => _(he), ["stop"])
            }, [
              v("div", JV, [
                v("span", QV, ye(c.value.includes(he) ? "" : ""), 1)
              ]),
              v("div", eH, [
                ct(ye(he) + " ", 1),
                he === "Transform" ? (se(), re("span", {
                  key: 0,
                  class: "reset-link",
                  onClick: _t(U, ["stop"])
                }, "Reset")) : Te("", !0)
              ])
            ], 44, KV),
            c.value.includes(he) ? (se(), re("div", tH, [
              (se(!0), re(Xe, null, at(ie, (ne) => (se(), Tt(r9, {
                key: ne.path,
                layerId: s.layer.id,
                propertyPath: ne.path,
                name: ne.name,
                property: ne.property,
                layoutMode: "sidebar",
                gridStyle: s.gridStyle,
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : Te("", !0)
      ], 64)) : (se(), re(Xe, { key: 1 }, [
        v("div", {
          class: "layer-row track-bg",
          onMousedown: w
        }, [
          v("div", {
            class: "duration-bar",
            style: xt(x.value),
            onMousedown: _t(S, ["stop"])
          }, [
            v("div", {
              class: "bar-fill",
              style: xt({ background: s.layer.labelColor || "#777" })
            }, null, 4)
          ], 36)
        ], 32),
        r.value ? (se(), re("div", nH, [
          (se(!0), re(Xe, null, at(g.value, (ie, he) => (se(), re("div", {
            key: he,
            class: "property-group"
          }, [
            de[7] || (de[7] = v("div", { class: "group-header track-bg" }, null, -1)),
            c.value.includes(he) ? (se(), re("div", iH, [
              (se(!0), re(Xe, null, at(ie, (ne) => (se(), Tt(r9, {
                key: ne.path,
                layerId: s.layer.id,
                propertyPath: ne.path,
                name: ne.name,
                property: ne.property,
                layoutMode: "track",
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]))), 128))
            ])) : Te("", !0)
          ]))), 128))
        ])) : Te("", !0)
      ], 64)),
      (se(), Tt(R0, { to: "body" }, [
        p.value ? (se(), re("div", {
          key: 0,
          class: "layer-context-menu",
          style: xt({ left: f.value + "px", top: m.value + "px" }),
          onClick: de[4] || (de[4] = _t(() => {
          }, ["stop"]))
        }, [
          v("button", { onClick: fe }, "Duplicate Layer"),
          v("button", { onClick: q }, "Rename"),
          de[8] || (de[8] = v("hr", null, null, -1)),
          v("button", { onClick: G }, ye(s.layer.visible ? "Hide" : "Show") + " Layer", 1),
          v("button", { onClick: Q }, ye(s.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
          v("button", { onClick: K }, ye(s.layer.threeD ? "Make 2D" : "Make 3D"), 1),
          de[9] || (de[9] = v("hr", null, null, -1)),
          v("button", { onClick: Y }, "Pre-compose..."),
          de[10] || (de[10] = v("hr", null, null, -1)),
          v("button", {
            onClick: ee,
            class: "danger"
          }, "Delete Layer")
        ], 4)) : Te("", !0)
      ]))
    ])) : Te("", !0);
  }
}), l9 = /* @__PURE__ */ Vt(sH, [["__scopeId", "data-v-fb7680b0"]]), oH = { class: "composition-tabs" }, aH = { class: "tabs-container" }, rH = ["onClick", "onDblclick", "onContextmenu"], lH = {
  key: 0,
  class: "precomp-icon",
  title: "Pre-composition"
}, cH = {
  key: 1,
  class: "tab-name"
}, uH = {
  key: 2,
  class: "tab-name"
}, dH = { class: "tab-info" }, hH = ["onClick"], fH = ["disabled"], pH = ["disabled"], mH = /* @__PURE__ */ Bt({
  __name: "CompositionTabs",
  emits: ["newComposition"],
  setup(s, { emit: e }) {
    const n = e, i = un(), o = xe(null), a = xe(""), r = xe(null), l = xe({
      visible: !1,
      x: 0,
      y: 0,
      comp: null
    }), c = Re(() => i.openCompositions), u = Re(() => i.activeCompositionId), d = Re(() => i.project.mainCompositionId);
    function h(b) {
      i.switchComposition(b);
    }
    function p(b) {
      i.closeCompositionTab(b);
    }
    function f(b) {
      const S = b.settings;
      return `${S.width}x${S.height} ${S.fps}fps`;
    }
    function m(b) {
      o.value = b.id, a.value = b.name, Xi(() => {
        var S, A;
        (S = r.value) == null || S.focus(), (A = r.value) == null || A.select();
      });
    }
    function y() {
      o.value && a.value.trim() && i.renameComposition(o.value, a.value.trim()), o.value = null, a.value = "";
    }
    function g() {
      o.value = null, a.value = "";
    }
    function x(b, S) {
      l.value = {
        visible: !0,
        x: b.clientX,
        y: b.clientY,
        comp: S
      };
    }
    function w() {
      l.value.visible = !1, l.value.comp = null;
    }
    function M() {
      l.value.comp && m(l.value.comp), w();
    }
    function _() {
      if (l.value.comp) {
        const b = l.value.comp, S = i.createComposition(
          `${b.name} Copy`,
          b.settings,
          b.isPrecomp
        );
        console.log("[CompositionTabs] Duplicated:", S.name);
      }
      w();
    }
    function C() {
      l.value.comp && i.switchComposition(l.value.comp.id), w();
    }
    function T() {
      l.value.comp && (i.project.mainCompositionId = l.value.comp.id, console.log("[CompositionTabs] Set main composition:", l.value.comp.name)), w();
    }
    function P() {
      l.value.comp && l.value.comp.id !== d.value && i.deleteComposition(l.value.comp.id), w();
    }
    function E() {
      l.value.visible && w();
    }
    return gn(() => {
      document.addEventListener("click", E);
    }), Un(() => {
      document.removeEventListener("click", E);
    }), (b, S) => {
      var A, R;
      return se(), re("div", oH, [
        v("div", aH, [
          (se(!0), re(Xe, null, at(c.value, (k) => (se(), re("div", {
            key: k.id,
            class: Le(["tab", {
              active: k.id === u.value,
              precomp: k.isPrecomp
            }]),
            onClick: (U) => h(k.id),
            onDblclick: (U) => m(k),
            onContextmenu: _t((U) => x(U, k), ["prevent"])
          }, [
            k.isPrecomp ? (se(), re("span", lH, "")) : Te("", !0),
            o.value === k.id ? (se(), re("span", cH, [
              st(v("input", {
                ref_for: !0,
                ref_key: "renameInput",
                ref: r,
                "onUpdate:modelValue": S[0] || (S[0] = (U) => a.value = U),
                type: "text",
                class: "rename-input",
                onBlur: y,
                onKeydown: [
                  Lr(y, ["enter"]),
                  Lr(g, ["escape"])
                ],
                onClick: S[1] || (S[1] = _t(() => {
                }, ["stop"]))
              }, null, 544), [
                [Ot, a.value]
              ])
            ])) : (se(), re("span", uH, ye(k.name), 1)),
            v("span", dH, ye(f(k)), 1),
            c.value.length > 1 ? (se(), re("button", {
              key: 3,
              class: "close-btn",
              onClick: _t((U) => p(k.id), ["stop"]),
              title: "Close tab"
            }, "  ", 8, hH)) : Te("", !0)
          ], 42, rH))), 128)),
          v("button", {
            class: "new-comp-btn",
            onClick: S[2] || (S[2] = (k) => n("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (se(), Tt(R0, { to: "body" }, [
          l.value.visible ? (se(), re("div", {
            key: 0,
            class: "context-menu",
            style: xt({ left: l.value.x + "px", top: l.value.y + "px" }),
            onClick: S[3] || (S[3] = _t(() => {
            }, ["stop"]))
          }, [
            v("button", { onClick: M }, "Rename"),
            v("button", { onClick: _ }, "Duplicate"),
            v("button", { onClick: C }, "Open in New Tab"),
            S[4] || (S[4] = v("hr", null, null, -1)),
            v("button", {
              onClick: T,
              disabled: ((A = l.value.comp) == null ? void 0 : A.id) === d.value
            }, " Set as Main Composition ", 8, fH),
            S[5] || (S[5] = v("hr", null, null, -1)),
            v("button", {
              onClick: P,
              disabled: ((R = l.value.comp) == null ? void 0 : R.id) === d.value,
              class: "danger"
            }, " Delete Composition ", 8, pH)
          ], 4)) : Te("", !0)
        ]))
      ]);
    };
  }
}), vH = /* @__PURE__ */ Vt(mH, [["__scopeId", "data-v-c032dfe4"]]), gH = { class: "timeline-header" }, yH = { class: "header-left" }, xH = { class: "timecode" }, bH = { class: "frame-display" }, _H = ["value"], wH = { class: "fps-label" }, MH = { class: "header-center" }, SH = {
  key: 0,
  class: "add-layer-menu"
}, CH = { class: "tool-group" }, TH = ["disabled"], EH = { class: "header-right" }, AH = { class: "timeline-content" }, PH = /* @__PURE__ */ Bt({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = un(), o = xe(10), a = xe(450), r = xe({}), l = xe(!1), c = xe(null), u = xe(null), d = xe(null), h = xe(null), p = xe(null), f = xe(null);
    let m = !1, y = !1;
    const g = xe(1e3), x = Re(() => i.layers || []), w = Re(() => i.currentFrame * o.value), M = Re(() => {
      const Y = i.frameCount * o.value;
      return Math.max(Y, g.value) + "px";
    }), _ = Re(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function C() {
      l.value = !l.value;
    }
    function T(Y) {
      Y === "text" ? i.createTextLayer() : Y === "video" ? i.createLayer("video") : Y === "camera" ? i.createCameraLayer() : i.createLayer(Y), l.value = !1;
    }
    function P(Y) {
      i.selectLayer(Y);
    }
    function E(Y, ee) {
      i.updateLayer(Y, ee);
    }
    function b() {
      i.selectedLayerIds.forEach((Y) => i.deleteLayer(Y));
    }
    function S(Y) {
      i.setFrame(parseInt(Y.target.value) || 0);
    }
    function A() {
      i.togglePlayback();
    }
    function R(Y, ee) {
      r.value[Y] = ee;
    }
    function k(Y) {
      const ee = i.fps, ce = Math.floor(Y / ee), ae = Math.floor(Y % ee), de = ce % 60, ie = Math.floor(ce / 60) % 60, he = Math.floor(ce / 3600), ne = (N, te = 2) => String(N).padStart(te, "0");
      return `${ne(he)};${ne(ie)};${ne(de)};${ne(ae)}`;
    }
    function U() {
      const Y = d.value;
      if (!Y) return;
      const ee = Y.getContext("2d");
      if (!ee) return;
      const ce = i.frameCount * o.value, ae = Math.max(ce, g.value);
      Y.width = ae, Y.height = 30, ee.fillStyle = "#222", ee.fillRect(0, 0, Y.width, Y.height), ee.strokeStyle = "#666", ee.fillStyle = "#aaa", ee.font = "11px sans-serif";
      const de = o.value;
      let ie, he;
      de >= 20 ? (ie = 1, he = 0) : de >= 10 ? (ie = 5, he = 1) : de >= 5 ? (ie = 10, he = 5) : de >= 2 ? (ie = 20, he = 10) : de >= 1 ? (ie = 50, he = 25) : de >= 0.5 ? (ie = 100, he = 50) : (ie = 200, he = 0);
      for (let ne = 0; ne <= i.frameCount; ne++) {
        const N = ne * de;
        if (ne % ie === 0) {
          ee.strokeStyle = "#888", ee.beginPath(), ee.moveTo(N, 12), ee.lineTo(N, 30), ee.stroke();
          const te = String(ne), F = ee.measureText(te), B = (ne + ie) * de, L = F.width + 20;
          (B - N >= L || ne === 0 || ne >= i.frameCount - ie) && (ee.fillStyle = "#ccc", ee.fillText(te, N + 3, 10));
        } else he > 0 && ne % he === 0 && (ee.strokeStyle = "#555", ee.beginPath(), ee.moveTo(N, 22), ee.lineTo(N, 30), ee.stroke());
      }
      ee.strokeStyle = "#444", ee.beginPath(), ee.moveTo(0, 29.5), ee.lineTo(Y.width, 29.5), ee.stroke();
    }
    function I(Y) {
      var ae, de;
      const ee = d.value.getBoundingClientRect();
      (ae = f.value) != null && ae.scrollLeft || (de = p.value) != null && de.scrollLeft;
      const ce = (ie) => {
        var te, F;
        const he = ((te = f.value) == null ? void 0 : te.scrollLeft) || ((F = p.value) == null ? void 0 : F.scrollLeft) || 0, ne = ie.clientX - ee.left + he;
        let N = Math.max(0, Math.min(i.frameCount - 1, ne / o.value));
        if (!ie.altKey && i.snapConfig.enabled) {
          const B = Wh(Math.round(N), i.snapConfig, o.value, {
            layers: i.layers,
            audioAnalysis: i.audioAnalysis,
            peakData: i.peakData
          });
          B && (N = B.frame);
        }
        i.setFrame(Math.round(N));
      };
      ce(Y), window.addEventListener("mousemove", ce), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", ce), { once: !0 });
    }
    function W(Y) {
      const ee = Y.clientX, ce = a.value, ae = (de) => {
        a.value = Math.max(300, ce + (de.clientX - ee));
      };
      window.addEventListener("mousemove", ae), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", ae), { once: !0 });
    }
    function fe(Y) {
      if (y) return;
      m = !0;
      const ee = Y.target;
      p.value && (p.value.scrollTop = ee.scrollTop), requestAnimationFrame(() => {
        m = !1;
      });
    }
    function q(Y) {
      const ee = Y.target;
      m || (y = !0, h.value && (h.value.scrollTop = ee.scrollTop), requestAnimationFrame(() => {
        y = !1;
      })), f.value && (f.value.scrollLeft = ee.scrollLeft);
    }
    function G(Y) {
      const ee = Y.target;
      p.value && (p.value.scrollLeft = ee.scrollLeft);
    }
    function Q(Y) {
      if (!(Y.target instanceof HTMLInputElement || Y.target instanceof HTMLTextAreaElement) && (Y.code === "Space" && (Y.preventDefault(), A()), (Y.code === "Delete" || Y.code === "Backspace") && (Y.preventDefault(), b()), (Y.ctrlKey || Y.metaKey) && Y.code === "KeyC" && (Y.preventDefault(), i.copySelectedLayers()), (Y.ctrlKey || Y.metaKey) && Y.code === "KeyX" && (Y.preventDefault(), i.cutSelectedLayers()), (Y.ctrlKey || Y.metaKey) && Y.code === "KeyV" && (Y.preventDefault(), i.pasteLayers()), (Y.ctrlKey || Y.metaKey) && Y.code === "KeyA" && (Y.preventDefault(), i.selectedLayerIds = i.layers.map((ee) => ee.id)), (Y.ctrlKey || Y.metaKey) && Y.code === "KeyD")) {
        Y.preventDefault();
        for (const ee of i.selectedLayerIds)
          i.duplicateLayer(ee);
      }
    }
    let K = null;
    return gn(() => {
      window.addEventListener("mousedown", (ee) => {
        c.value && !c.value.contains(ee.target) && (l.value = !1);
      });
      const Y = p.value || u.value;
      Y && (K = new ResizeObserver((ee) => {
        for (const ce of ee)
          g.value = ce.contentRect.width, U();
      }), K.observe(Y)), setTimeout(U, 100);
    }), Un(() => {
      K && K.disconnect();
    }), Ft(() => [M.value, o.value, i.frameCount], () => Xi(U)), (Y, ee) => (se(), re("div", {
      class: "timeline-panel",
      tabindex: "0",
      onKeydown: Q
    }, [
      Ne(vH, {
        onNewComposition: ee[0] || (ee[0] = (ce) => n("openCompositionSettings"))
      }),
      v("div", gH, [
        v("div", yH, [
          v("span", xH, ye(k(He(i).currentFrame)), 1),
          v("div", bH, [
            v("input", {
              type: "number",
              value: He(i).currentFrame,
              onChange: S,
              class: "frame-input"
            }, null, 40, _H),
            v("span", wH, ye(He(i).fps) + " fps", 1)
          ])
        ]),
        v("div", MH, [
          v("div", {
            class: "tool-group add-layer-wrapper",
            ref_key: "addLayerContainer",
            ref: c
          }, [
            v("button", {
              class: Le(["add-layer-btn", { active: l.value }]),
              onMousedown: _t(C, ["stop", "prevent"])
            }, [...ee[9] || (ee[9] = [
              v("span", { class: "icon" }, "+", -1),
              ct(" Layer ", -1)
            ])], 34),
            l.value ? (se(), re("div", SH, [
              v("button", {
                onMousedown: ee[1] || (ee[1] = (ce) => T("solid"))
              }, [...ee[10] || (ee[10] = [
                v("span", { class: "icon" }, "", -1),
                ct(" Solid", -1)
              ])], 32),
              v("button", {
                onMousedown: ee[2] || (ee[2] = (ce) => T("text"))
              }, [...ee[11] || (ee[11] = [
                v("span", { class: "icon" }, "T", -1),
                ct(" Text", -1)
              ])], 32),
              v("button", {
                onMousedown: ee[3] || (ee[3] = (ce) => T("spline"))
              }, [...ee[12] || (ee[12] = [
                v("span", { class: "icon" }, "~", -1),
                ct(" Shape", -1)
              ])], 32),
              v("button", {
                onMousedown: ee[4] || (ee[4] = (ce) => T("null"))
              }, [...ee[13] || (ee[13] = [
                v("span", { class: "icon" }, "", -1),
                ct(" Null", -1)
              ])], 32),
              v("button", {
                onMousedown: ee[5] || (ee[5] = (ce) => T("camera"))
              }, [...ee[14] || (ee[14] = [
                v("span", { class: "icon" }, "", -1),
                ct(" Camera", -1)
              ])], 32),
              v("button", {
                onMousedown: ee[6] || (ee[6] = (ce) => T("light"))
              }, [...ee[15] || (ee[15] = [
                v("span", { class: "icon" }, "", -1),
                ct(" Light", -1)
              ])], 32),
              v("button", {
                onMousedown: ee[7] || (ee[7] = (ce) => T("video"))
              }, [...ee[16] || (ee[16] = [
                v("span", { class: "icon" }, "", -1),
                ct(" Video", -1)
              ])], 32)
            ])) : Te("", !0)
          ], 512),
          v("div", CH, [
            v("button", {
              class: "delete-btn",
              onClick: b,
              disabled: He(i).selectedLayerIds.length === 0
            }, "", 8, TH)
          ])
        ]),
        v("div", EH, [
          st(v("input", {
            type: "range",
            min: "0.1",
            max: "50",
            step: "0.1",
            "onUpdate:modelValue": ee[8] || (ee[8] = (ce) => o.value = ce),
            class: "zoom-slider",
            title: "Zoom Timeline"
          }, null, 512), [
            [
              Ot,
              o.value,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      v("div", AH, [
        v("div", {
          class: "timeline-sidebar",
          style: xt({ width: a.value + "px" })
        }, [
          ee[17] || (ee[17] = fs('<div class="sidebar-header-row" data-v-0c0bcb17><div class="col-header col-arrow" data-v-0c0bcb17></div><div class="col-header col-name" data-v-0c0bcb17>Layer Name</div><div class="col-header col-mode" data-v-0c0bcb17>Mode</div><div class="col-header col-parent" data-v-0c0bcb17>Parent</div></div>', 1)),
          v("div", {
            class: "sidebar-scroll-area",
            ref_key: "sidebarScrollRef",
            ref: h,
            onScroll: fe
          }, [
            (se(!0), re(Xe, null, at(x.value, (ce, ae) => (se(), Tt(l9, {
              key: ce.id,
              layer: ce,
              index: ae + 1,
              layoutMode: "sidebar",
              isExpandedExternal: r.value[ce.id],
              allLayers: He(i).layers,
              gridStyle: _.value,
              onToggleExpand: R,
              onSelect: P,
              onUpdateLayer: E
            }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]))), 128))
          ], 544)
        ], 4),
        v("div", {
          class: "sidebar-resizer",
          onMousedown: W
        }, null, 32),
        v("div", {
          class: "track-viewport",
          ref_key: "trackViewportRef",
          ref: u
        }, [
          v("div", {
            class: "ruler-scroll-wrapper",
            onScroll: G,
            ref_key: "rulerScrollRef",
            ref: f
          }, [
            v("div", {
              class: "time-ruler",
              style: xt({ width: M.value }),
              onMousedown: I
            }, [
              v("canvas", {
                ref_key: "rulerCanvas",
                ref: d,
                height: "30"
              }, null, 512),
              v("div", {
                class: "playhead-head",
                style: xt({ left: w.value + "px" })
              }, null, 4),
              v("div", {
                class: "playhead-hit-area",
                style: xt({ left: w.value + "px" }),
                onMousedown: _t(I, ["stop"])
              }, null, 36)
            ], 36)
          ], 544),
          v("div", {
            class: "track-scroll-area",
            ref_key: "trackScrollRef",
            ref: p,
            onScroll: q
          }, [
            v("div", {
              class: "layer-bars-container",
              style: xt({ width: M.value })
            }, [
              ee[18] || (ee[18] = v("div", { class: "grid-background" }, null, -1)),
              (se(!0), re(Xe, null, at(x.value, (ce) => (se(), Tt(l9, {
                key: ce.id,
                layer: ce,
                layoutMode: "track",
                frameCount: He(i).frameCount,
                pixelsPerFrame: o.value,
                isExpandedExternal: r.value[ce.id],
                onSelect: P,
                onUpdateLayer: E
              }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]))), 128)),
              v("div", {
                class: "playhead-line",
                style: xt({ left: w.value + "px" })
              }, null, 4)
            ], 4)
          ], 544)
        ], 512)
      ])
    ], 32));
  }
}), c9 = /* @__PURE__ */ Vt(PH, [["__scopeId", "data-v-0c0bcb17"]]), kH = { class: "graph-editor" }, DH = { class: "graph-header" }, IH = { class: "mode-toggle" }, RH = { class: "preset-buttons" }, LH = ["onClick", "title"], FH = { class: "toolbar" }, OH = { class: "graph-content" }, UH = { class: "property-list" }, zH = { class: "property-list-header" }, BH = ["title"], NH = ["onClick"], VH = ["onClick"], HH = { class: "property-name" }, GH = {
  key: 0,
  class: "keyframe-count"
}, $H = {
  key: 0,
  class: "dimension-toggles"
}, WH = ["onClick"], jH = {
  key: 0,
  class: "no-properties"
}, XH = { class: "graph-main" }, YH = ["viewBox"], qH = ["onMousedown"], ZH = ["x", "y", "fill", "transform"], KH = {
  key: 1,
  class: "bezier-handles"
}, JH = {
  key: 0,
  class: "handle out-handle"
}, QH = ["x1", "y1", "x2", "y2"], eG = ["cx", "cy", "onMousedown"], tG = {
  key: 1,
  class: "handle in-handle"
}, nG = ["x1", "y1", "x2", "y2"], iG = ["cx", "cy", "onMousedown"], sG = ["x1", "x2", "y2"], oG = {
  key: 0,
  class: "keyframe-info-panel"
}, aG = { class: "info-row" }, rG = ["value"], lG = { class: "info-row" }, cG = ["value"], uG = { class: "info-row" }, dG = ["value"], hG = ["disabled"], fG = ["disabled"], pG = ["disabled"], mG = /* @__PURE__ */ Bt({
  __name: "GraphEditor",
  emits: ["close"],
  setup(s, { emit: e }) {
    const n = e, i = un(), o = xe(null), a = xe(null), r = xe(null), l = xe(null), c = xe(null), u = xe(null), d = xe(400), h = xe(200), p = xe("value"), f = po({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), m = xe([]), y = xe([]), g = xe({}), x = xe([]), w = xe(null), M = xe(null), _ = xe(null), C = xe(null), T = xe(null), P = xe(!1), E = xe(!0), b = { top: 10, right: 10, bottom: 10, left: 10 }, S = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, A = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], R = Re(() => {
      const ve = i.selectedLayer;
      if (!ve) return [];
      const Me = [];
      return Me.push(ve.transform.position), Me.push(ve.transform.scale), Me.push(ve.transform.rotation), Me.push(ve.opacity), Me.push(...ve.properties), Me;
    }), k = Re(() => R.value.filter(
      (ve) => y.value.includes(ve.id) && ve.animated
    )), U = Re(() => R.value.every((ve) => y.value.includes(ve.id))), I = Re(() => W(i.currentFrame));
    function W(ve) {
      const Me = d.value - b.left - b.right, Pe = (ve - f.frameStart) / (f.frameEnd - f.frameStart);
      return b.left + Pe * Me;
    }
    function fe(ve) {
      const Me = d.value - b.left - b.right, Pe = (ve - b.left) / Me;
      return f.frameStart + Pe * (f.frameEnd - f.frameStart);
    }
    function q(ve) {
      const Me = h.value - b.top - b.bottom, Pe = (ve - f.valueMin) / (f.valueMax - f.valueMin);
      return h.value - b.bottom - Pe * Me;
    }
    function G(ve) {
      const Me = h.value - b.top - b.bottom, Pe = (h.value - b.bottom - ve) / Me;
      return f.valueMin + Pe * (f.valueMax - f.valueMin);
    }
    function Q(ve) {
      return W(ve.frame);
    }
    function K(ve, Me) {
      const Pe = typeof Me.value == "number" ? Me.value : typeof Me.value == "object" ? Me.value.x ?? Me.value : 0;
      return q(Pe);
    }
    function Y(ve) {
      if (!ve) return 0;
      const Me = ve.keyframe.value;
      return typeof Me == "number" ? Me : typeof Me == "object" ? Me.x ?? 0 : 0;
    }
    function ee(ve, Me) {
      const Pe = ve.keyframes[Me];
      if (!Pe || !Pe.outHandle.enabled) return W(Pe.frame);
      const ze = Pe.frame + Pe.outHandle.frame;
      return W(ze);
    }
    function ce(ve, Me) {
      const Pe = ve.keyframes[Me];
      if (!Pe || !Pe.outHandle.enabled) return q(ie(Pe.value));
      const ze = ie(Pe.value) + Pe.outHandle.value;
      return q(ze);
    }
    function ae(ve, Me) {
      const Pe = ve.keyframes[Me];
      if (!Pe || !Pe.inHandle.enabled) return W(Pe.frame);
      const ze = Pe.frame + Pe.inHandle.frame;
      return W(ze);
    }
    function de(ve, Me) {
      const Pe = ve.keyframes[Me];
      if (!Pe || !Pe.inHandle.enabled) return q(ie(Pe.value));
      const ze = ie(Pe.value) + Pe.inHandle.value;
      return q(ze);
    }
    function ie(ve) {
      return typeof ve == "number" ? ve : typeof ve == "object" ? ve.x ?? ve.y ?? ve.z ?? 0 : 0;
    }
    function he(ve) {
      const Me = R.value.find((Pe) => Pe.id === ve);
      return Me ? S[Me.name] ?? S.default : S.default;
    }
    function ne(ve) {
      return ve.frame >= f.frameStart && ve.frame <= f.frameEnd;
    }
    function N(ve, Me) {
      return x.value.some((Pe) => Pe.propId === ve && Pe.index === Me);
    }
    function te(ve, Me) {
      if (!ve.animated || ve.keyframes.length === 0) return !1;
      const Pe = ve.keyframes[0].value;
      return typeof Pe == "object" && Me in Pe;
    }
    function F(ve) {
      const Me = m.value.indexOf(ve);
      Me === -1 ? m.value.push(ve) : m.value.splice(Me, 1);
    }
    function B(ve) {
      const Me = y.value.indexOf(ve);
      Me === -1 ? y.value.push(ve) : y.value.splice(Me, 1), Z();
    }
    function L() {
      U.value ? y.value = [] : y.value = R.value.map((ve) => ve.id), Z();
    }
    function D(ve, Me) {
      g.value[ve] || (g.value[ve] = []);
      const Pe = g.value[ve], ze = Pe.indexOf(Me);
      ze === -1 ? Pe.push(Me) : Pe.splice(ze, 1);
    }
    function j() {
      const ve = k.value;
      if (ve.length === 0) return;
      let Me = 1 / 0, Pe = -1 / 0, ze = 1 / 0, J = -1 / 0;
      for (const Ee of ve)
        for (const Se of Ee.keyframes) {
          Me = Math.min(Me, Se.frame), Pe = Math.max(Pe, Se.frame);
          const Oe = ie(Se.value);
          ze = Math.min(ze, Oe), J = Math.max(J, Oe);
        }
      const ge = (Pe - Me) * 0.1 || 10, be = (J - ze) * 0.1 || 10;
      f.frameStart = Me - ge, f.frameEnd = Pe + ge, f.valueMin = ze - be, f.valueMax = J + be;
    }
    function Z() {
      j();
    }
    function z() {
      E.value = !E.value;
    }
    function $(ve) {
      return x.value.length === 0 || !Oc[ve] ? !1 : ve === "linear" ? x.value.every((Pe) => Pe.keyframe.interpolation === "linear") : x.value.every((Pe) => Pe.keyframe.interpolation === "bezier");
    }
    function oe(ve) {
      const Me = Oc[ve];
      if (!Me) return;
      const Pe = i.selectedLayer;
      if (Pe) {
        for (const ze of x.value) {
          const J = R.value.find((et) => et.id === ze.propId);
          if (!J) continue;
          const ge = Ae(J), be = ze.index, Ee = be > 0 ? J.keyframes[be - 1] : null, Se = be < J.keyframes.length - 1 ? J.keyframes[be + 1] : null, Oe = Ee ? ze.keyframe.frame - Ee.frame : 10, De = Se ? Se.frame - ze.keyframe.frame : 10;
          if (ve === "linear")
            i.setKeyframeInterpolation(Pe.id, ge, ze.keyframe.id, "linear"), ze.keyframe.interpolation = "linear", ze.keyframe.outHandle = { frame: De * 0.33, value: 0, enabled: !1 }, ze.keyframe.inHandle = { frame: -Oe * 0.33, value: 0, enabled: !1 };
          else {
            const et = {
              frame: Me.outHandle.x * De,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            }, lt = {
              frame: -Me.inHandle.x * Oe,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            };
            i.setKeyframeInterpolation(Pe.id, ge, ze.keyframe.id, "bezier"), i.setKeyframeHandle(Pe.id, ge, ze.keyframe.id, "out", et), i.setKeyframeHandle(Pe.id, ge, ze.keyframe.id, "in", lt), ze.keyframe.interpolation = "bezier", ze.keyframe.outHandle = et, ze.keyframe.inHandle = lt;
          }
        }
        ut();
      }
    }
    function O(ve) {
      var J;
      const Me = (J = o.value) == null ? void 0 : J.getBoundingClientRect();
      if (!Me) return;
      const Pe = ve.clientX - Me.left, ze = ve.clientY - Me.top;
      ve.button === 1 || ve.button === 0 && ve.altKey ? M.value = { type: "pan", startX: Pe, startY: ze } : ve.button === 0 && (ve.shiftKey || (x.value = []), _.value = { x: Pe, y: ze, width: 0, height: 0 }, M.value = { type: "select", startX: Pe, startY: ze });
    }
    function V(ve) {
      var J;
      const Me = (J = o.value) == null ? void 0 : J.getBoundingClientRect();
      if (!Me) return;
      const Pe = ve.clientX - Me.left, ze = ve.clientY - Me.top;
      if (ue(Pe, ze), !!M.value)
        if (M.value.type === "pan") {
          const ge = Pe - (M.value.startX ?? 0), be = ze - (M.value.startY ?? 0), Ee = d.value - b.left - b.right, Se = h.value - b.top - b.bottom, Oe = -ge / Ee * (f.frameEnd - f.frameStart), De = be / Se * (f.valueMax - f.valueMin);
          f.frameStart += Oe, f.frameEnd += Oe, f.valueMin += De, f.valueMax += De, M.value.startX = Pe, M.value.startY = ze, ut();
        } else if (M.value.type === "select" && _.value) {
          const ge = M.value.startX ?? 0, be = M.value.startY ?? 0;
          _.value = {
            x: Math.min(Pe, ge),
            y: Math.min(ze, be),
            width: Math.abs(Pe - ge),
            height: Math.abs(ze - be)
          };
        } else M.value.type === "keyframe" ? we(Pe, ze) : (M.value.type === "outHandle" || M.value.type === "inHandle") && $e(Pe, ze);
    }
    function H() {
      var ve;
      ((ve = M.value) == null ? void 0 : ve.type) === "select" && _.value && _e(), M.value = null, _.value = null;
    }
    function X(ve) {
      var Ee;
      ve.preventDefault();
      const Me = (Ee = o.value) == null ? void 0 : Ee.getBoundingClientRect();
      if (!Me) return;
      const Pe = ve.clientX - Me.left, ze = ve.deltaY > 0 ? 1.1 : 0.9, J = fe(Pe), ge = J - (J - f.frameStart) * ze, be = J + (f.frameEnd - J) * ze;
      if (ve.shiftKey)
        f.frameStart = ge, f.frameEnd = be;
      else {
        f.frameStart = ge, f.frameEnd = be;
        const Se = ve.clientY - Me.top, Oe = G(Se);
        f.valueMin = Oe - (Oe - f.valueMin) * ze, f.valueMax = Oe + (f.valueMax - Oe) * ze;
      }
      ut();
    }
    function ue(ve, Me) {
      w.value = null;
      for (const Pe of k.value)
        for (let ze = 0; ze < Pe.keyframes.length; ze++) {
          const J = Pe.keyframes[ze], ge = Q(J), be = K(Pe, J);
          if (Math.sqrt((ve - ge) ** 2 + (Me - be) ** 2) < 10) {
            w.value = { propId: Pe.id, index: ze };
            return;
          }
        }
    }
    function me(ve, Me, Pe) {
      const ze = R.value.find((ge) => ge.id === ve);
      if (!ze) return;
      const J = ze.keyframes[Me];
      Pe.shiftKey || (x.value = []), N(ve, Me) || x.value.push({ propId: ve, index: Me, keyframe: J }), M.value = { type: "keyframe", propId: ve, index: Me };
    }
    function _e() {
      if (!_.value) return;
      const ve = _.value;
      for (const Me of k.value)
        for (let Pe = 0; Pe < Me.keyframes.length; Pe++) {
          const ze = Me.keyframes[Pe], J = Q(ze), ge = K(Me, ze);
          J >= ve.x && J <= ve.x + ve.width && ge >= ve.y && ge <= ve.y + ve.height && (N(Me.id, Pe) || x.value.push({ propId: Me.id, index: Pe, keyframe: ze }));
        }
    }
    function we(ve, Me) {
      const Pe = Math.round(fe(ve)), ze = G(Me), J = i.selectedLayer;
      if (J) {
        if (x.value.length > 0) {
          const ge = x.value[0], be = R.value.find((Oe) => Oe.id === ge.propId);
          if (!be) return;
          const Ee = P.value ? Math.round(Pe / 5) * 5 : Pe;
          typeof ge.keyframe.value == "number" || ge.keyframe.value;
          const Se = Ae(be);
          i.updateKeyframe(J.id, Se, ge.keyframe.id, {
            frame: Ee,
            value: typeof ge.keyframe.value == "number" ? ze : void 0
          }), ge.keyframe.frame = Ee, typeof ge.keyframe.value == "number" && (ge.keyframe.value = ze);
        }
        ut();
      }
    }
    function Ae(ve) {
      const Me = ve.name.toLowerCase();
      return Me === "position" ? "transform.position" : Me === "scale" ? "transform.scale" : Me === "rotation" ? "transform.rotation" : Me === "opacity" ? "opacity" : Me === "anchor point" ? "transform.anchorPoint" : ve.id;
    }
    function Ve(ve, Me, Pe, ze) {
      M.value = { type: ve, propId: Me, index: Pe }, document.addEventListener("mousemove", Fe), document.addEventListener("mouseup", je);
    }
    function Fe(ve) {
      var J;
      const Me = (J = o.value) == null ? void 0 : J.getBoundingClientRect();
      if (!Me || !M.value) return;
      const Pe = ve.clientX - Me.left, ze = ve.clientY - Me.top;
      $e(Pe, ze);
    }
    function $e(ve, Me) {
      if (!M.value || !M.value.propId) return;
      const Pe = i.selectedLayer;
      if (!Pe) return;
      const ze = R.value.find((Oe) => Oe.id === M.value.propId);
      if (!ze) return;
      const J = M.value.index, ge = ze.keyframes[J];
      if (!ge) return;
      const be = fe(ve), Ee = G(Me), Se = Ae(ze);
      if (M.value.type === "outHandle") {
        const Oe = ze.keyframes[J + 1];
        let De = be - ge.frame;
        Oe ? De = Math.max(0, Math.min(Oe.frame - ge.frame, De)) : De = Math.max(0, De);
        const et = Ee - ie(ge.value), lt = {
          frame: De,
          value: et,
          enabled: !0
        };
        i.setKeyframeHandle(Pe.id, Se, ge.id, "out", lt), ge.outHandle = lt, ge.interpolation = "bezier", Ze(ge, "out", Se);
      } else if (M.value.type === "inHandle") {
        const Oe = ze.keyframes[J - 1];
        let De = be - ge.frame;
        Oe ? De = Math.min(0, Math.max(Oe.frame - ge.frame, De)) : De = Math.min(0, De);
        const et = Ee - ie(ge.value), lt = {
          frame: De,
          value: et,
          enabled: !0
        };
        i.setKeyframeHandle(Pe.id, Se, ge.id, "in", lt), ge.inHandle = lt, Ze(ge, "in", Se);
      }
      ut();
    }
    function Ze(ve, Me, Pe) {
      if (!ve.controlMode || ve.controlMode === "corner")
        return;
      const ze = i.selectedLayer;
      if (ze && (ve.controlMode === "symmetric" && (Me === "in" ? (ve.outHandle.frame = -ve.inHandle.frame, ve.outHandle.value = -ve.inHandle.value, ve.outHandle.enabled = ve.inHandle.enabled, i.setKeyframeHandle(ze.id, Pe, ve.id, "out", { ...ve.outHandle })) : (ve.inHandle.frame = -ve.outHandle.frame, ve.inHandle.value = -ve.outHandle.value, ve.inHandle.enabled = ve.outHandle.enabled, i.setKeyframeHandle(ze.id, Pe, ve.id, "in", { ...ve.inHandle }))), ve.controlMode === "smooth")) {
        const J = Me === "in" ? ve.inHandle : ve.outHandle, ge = Me === "in" ? ve.outHandle : ve.inHandle, be = Me === "in" ? "out" : "in";
        if (J.frame !== 0 || J.value !== 0) {
          const Se = Math.atan2(J.value, J.frame) + Math.PI, Oe = Math.hypot(ge.frame, ge.value);
          ge.frame = Math.cos(Se) * Oe, ge.value = Math.sin(Se) * Oe, i.setKeyframeHandle(ze.id, Pe, ve.id, be, { ...ge });
        }
      }
    }
    function je() {
      M.value = null, document.removeEventListener("mousemove", Fe), document.removeEventListener("mouseup", je);
    }
    function Ue(ve) {
      C.value = { x: ve.offsetX, y: ve.offsetY };
    }
    function rt() {
      if (!C.value) return;
      const ve = i.selectedLayer;
      if (!ve) return;
      const Me = Math.round(fe(C.value.x)), Pe = G(C.value.y);
      if (k.value.length > 0) {
        const ze = k.value[0], J = Ae(ze), ge = typeof ze.value == "number" ? Pe : { x: Pe, y: Pe };
        i.addKeyframe(ve.id, J, ge, Me), ut();
      }
      C.value = null;
    }
    function Qe() {
      const ve = i.selectedLayer;
      if (ve) {
        for (const Me of x.value) {
          const Pe = R.value.find((ze) => ze.id === Me.propId);
          if (Pe) {
            const ze = Ae(Pe);
            i.removeKeyframe(ve.id, ze, Me.keyframe.id);
          }
        }
        x.value = [], ut();
      }
    }
    function yt() {
      T.value = x.value.map((ve) => ({ ...ve.keyframe }));
    }
    function Ce() {
      var J, ge;
      if (!T.value || k.value.length === 0) return;
      const ve = i.selectedLayer;
      if (!ve) return;
      const Me = k.value[0], Pe = Ae(Me), ze = i.currentFrame - T.value[0].frame;
      for (const be of T.value) {
        const Ee = be.frame + ze, Se = i.addKeyframe(ve.id, Pe, be.value, Ee);
        Se && (be.interpolation !== "linear" && i.setKeyframeInterpolation(ve.id, Pe, Se.id, be.interpolation), (J = be.inHandle) != null && J.enabled && i.setKeyframeHandle(ve.id, Pe, Se.id, "in", be.inHandle), (ge = be.outHandle) != null && ge.enabled && i.setKeyframeHandle(ve.id, Pe, Se.id, "out", be.outHandle));
      }
      ut();
    }
    function Be() {
      x.value = [];
      for (const ve of k.value)
        for (let Me = 0; Me < ve.keyframes.length; Me++)
          x.value.push({ propId: ve.id, index: Me, keyframe: ve.keyframes[Me] });
    }
    function ke() {
      const ve = [];
      for (const Me of k.value)
        for (let Pe = 0; Pe < Me.keyframes.length; Pe++)
          N(Me.id, Pe) || ve.push({ propId: Me.id, index: Pe, keyframe: Me.keyframes[Pe] });
      x.value = ve;
    }
    function Ge(ve) {
      const Me = parseInt(ve.target.value);
      x.value.length > 0 && !isNaN(Me) && (x.value[0].keyframe.frame = Me, ut());
    }
    function Ye(ve) {
      const Me = parseFloat(ve.target.value);
      if (x.value.length > 0 && !isNaN(Me)) {
        const Pe = x.value[0].keyframe;
        typeof Pe.value == "number" ? Pe.value = Me : typeof Pe.value == "object" && (Pe.value.x = Me), ut();
      }
    }
    function We(ve) {
      const Me = ve.target.value;
      x.value.length > 0 && (x.value[0].keyframe.interpolation = Me, ut());
    }
    function ht(ve) {
      var J;
      const Me = (J = l.value) == null ? void 0 : J.getBoundingClientRect();
      if (!Me) return;
      const Pe = ve.clientX - Me.left, ze = Math.round(fe(Pe));
      i.setFrame(ze);
    }
    function ut() {
      ft(), hn(), Yn();
    }
    function ft() {
      const ve = o.value;
      if (!ve) return;
      const Me = ve.getContext("2d");
      if (Me) {
        ve.width = d.value, ve.height = h.value, Me.fillStyle = "#1a1a1a", Me.fillRect(0, 0, d.value, h.value), vt(Me);
        for (const Pe of k.value)
          en(Me, Pe);
      }
    }
    function vt(ve) {
      const Me = d.value - b.left - b.right, Pe = h.value - b.top - b.bottom;
      ve.strokeStyle = "#2a2a2a", ve.lineWidth = 1;
      const ze = f.frameEnd - f.frameStart, J = Gt(ze, Me, 50), ge = f.valueMax - f.valueMin, be = Gt(ge, Pe, 30), Ee = Math.ceil(f.frameStart / J) * J;
      for (let Oe = Ee; Oe <= f.frameEnd; Oe += J) {
        const De = W(Oe);
        ve.beginPath(), ve.moveTo(De, b.top), ve.lineTo(De, h.value - b.bottom), ve.stroke();
      }
      const Se = Math.ceil(f.valueMin / be) * be;
      for (let Oe = Se; Oe <= f.valueMax; Oe += be) {
        const De = q(Oe);
        ve.beginPath(), ve.moveTo(b.left, De), ve.lineTo(d.value - b.right, De), ve.stroke();
      }
      if (ve.strokeStyle = "#3a3a3a", ve.lineWidth = 1, f.frameStart <= 0 && f.frameEnd >= 0) {
        const Oe = W(0);
        ve.beginPath(), ve.moveTo(Oe, b.top), ve.lineTo(Oe, h.value - b.bottom), ve.stroke();
      }
      if (f.valueMin <= 0 && f.valueMax >= 0) {
        const Oe = q(0);
        ve.beginPath(), ve.moveTo(b.left, Oe), ve.lineTo(d.value - b.right, Oe), ve.stroke();
      }
    }
    function Gt(ve, Me, Pe) {
      const ze = ve * Pe / Me, J = Math.pow(10, Math.floor(Math.log10(ze))), ge = ze / J;
      return ge <= 1 ? J : ge <= 2 ? 2 * J : ge <= 5 ? 5 * J : 10 * J;
    }
    function en(ve, Me) {
      if (Me.keyframes.length < 2) return;
      const Pe = he(Me.id);
      for (let ze = 0; ze < 2; ze++) {
        ze === 0 ? (ve.strokeStyle = "#000", ve.lineWidth = 4) : (ve.strokeStyle = Pe, ve.lineWidth = 2), ve.beginPath();
        let J = !1;
        for (let ge = 0; ge < Me.keyframes.length - 1; ge++) {
          const be = Me.keyframes[ge], Ee = Me.keyframes[ge + 1];
          if (Ee.frame < f.frameStart || be.frame > f.frameEnd) continue;
          const Se = Q(be), Oe = K(Me, be), De = Q(Ee), et = K(Me, Ee);
          if (J || (ve.moveTo(Se, Oe), J = !0), be.interpolation === "hold")
            ve.lineTo(De, Oe), ve.lineTo(De, et);
          else if (be.interpolation === "linear" || !be.outHandle.enabled && !Ee.inHandle.enabled)
            ve.lineTo(De, et);
          else {
            const lt = W(be.frame + be.outHandle.frame), gt = q(ie(be.value) + be.outHandle.value), wt = W(Ee.frame + Ee.inHandle.frame), dt = q(ie(Ee.value) + Ee.inHandle.value);
            ve.bezierCurveTo(lt, gt, wt, dt, De, et);
          }
        }
        ve.stroke();
      }
    }
    function hn() {
      var Ee;
      const ve = l.value;
      if (!ve) return;
      const Me = (Ee = r.value) == null ? void 0 : Ee.getBoundingClientRect();
      if (!Me) return;
      ve.width = Me.width, ve.height = 24;
      const Pe = ve.getContext("2d");
      if (!Pe) return;
      Pe.fillStyle = "#252525", Pe.fillRect(0, 0, ve.width, ve.height);
      const ze = f.frameEnd - f.frameStart, J = Gt(ze, ve.width, 60);
      Pe.fillStyle = "#888", Pe.font = "10px system-ui", Pe.textAlign = "center";
      const ge = Math.ceil(f.frameStart / J) * J;
      for (let Se = ge; Se <= f.frameEnd; Se += J) {
        const Oe = W(Se);
        Pe.fillText(Se.toString(), Oe, 16), Pe.strokeStyle = "#444", Pe.beginPath(), Pe.moveTo(Oe, 20), Pe.lineTo(Oe, 24), Pe.stroke();
      }
      const be = W(i.currentFrame);
      Pe.fillStyle = "#ff4444", Pe.beginPath(), Pe.moveTo(be - 5, 0), Pe.lineTo(be + 5, 0), Pe.lineTo(be, 8), Pe.closePath(), Pe.fill();
    }
    function Yn() {
      var be;
      const ve = u.value;
      if (!ve) return;
      const Me = (be = c.value) == null ? void 0 : be.getBoundingClientRect();
      if (!Me) return;
      ve.width = 40, ve.height = Me.height;
      const Pe = ve.getContext("2d");
      if (!Pe) return;
      Pe.fillStyle = "#252525", Pe.fillRect(0, 0, ve.width, ve.height);
      const ze = f.valueMax - f.valueMin, J = Gt(ze, ve.height, 30);
      Pe.fillStyle = "#888", Pe.font = "10px system-ui", Pe.textAlign = "right";
      const ge = Math.ceil(f.valueMin / J) * J;
      for (let Ee = ge; Ee <= f.valueMax; Ee += J) {
        const Se = q(Ee);
        Pe.fillText(Ee.toFixed(0), 36, Se + 4);
      }
    }
    function Pn(ve = "both") {
      for (const Me of x.value) {
        const Pe = R.value.find((De) => De.id === Me.propId);
        if (!Pe) continue;
        const ze = Me.keyframe, J = Me.index, ge = J > 0 ? Pe.keyframes[J - 1] : null, be = J < Pe.keyframes.length - 1 ? Pe.keyframes[J + 1] : null, Ee = ge ? ze.frame - ge.frame : 10, Se = be ? be.frame - ze.frame : 10, Oe = 0.3333;
        (ve === "both" || ve === "in") && (ze.inHandle = {
          frame: -Ee * Oe,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), (ve === "both" || ve === "out") && (ze.outHandle = {
          frame: Se * Oe,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), ze.interpolation = "bezier", ze.controlMode = "smooth";
      }
      ut();
    }
    function li() {
      const ve = i.currentFrame, Me = [];
      for (const ze of k.value)
        for (const J of ze.keyframes)
          Me.includes(J.frame) || Me.push(J.frame);
      Me.sort((ze, J) => ze - J);
      const Pe = [...Me].reverse().find((ze) => ze < ve);
      Pe !== void 0 && i.setFrame(Pe);
    }
    function Ei() {
      const ve = i.currentFrame, Me = [];
      for (const ze of k.value)
        for (const J of ze.keyframes)
          Me.includes(J.frame) || Me.push(J.frame);
      Me.sort((ze, J) => ze - J);
      const Pe = Me.find((ze) => ze > ve);
      Pe !== void 0 && i.setFrame(Pe);
    }
    function Ai(ve) {
      if (ve.key === "F9") {
        ve.preventDefault(), ve.ctrlKey && ve.shiftKey ? Pn("out") : ve.shiftKey ? Pn("in") : Pn("both");
        return;
      }
      if (ve.key.toLowerCase() === "j") {
        ve.preventDefault(), li();
        return;
      }
      if (ve.key.toLowerCase() === "k") {
        ve.preventDefault(), Ei();
        return;
      }
      if (ve.key === "Delete" || ve.key === "Backspace") {
        ve.preventDefault(), Qe();
        return;
      }
      if (ve.key.toLowerCase() === "f" && !ve.ctrlKey) {
        ve.preventDefault(), ve.shiftKey ? j() : x.value.length > 0 ? qn() : j();
        return;
      }
      if (ve.key === "=" || ve.key === "+") {
        ve.preventDefault(), kn();
        return;
      }
      if (ve.key === "-" || ve.key === "_") {
        ve.preventDefault(), yi();
        return;
      }
    }
    function qn() {
      if (x.value.length === 0) {
        j();
        return;
      }
      let ve = 1 / 0, Me = -1 / 0, Pe = 1 / 0, ze = -1 / 0;
      for (const be of x.value) {
        ve = Math.min(ve, be.keyframe.frame), Me = Math.max(Me, be.keyframe.frame);
        const Ee = ie(be.keyframe.value);
        Pe = Math.min(Pe, Ee), ze = Math.max(ze, Ee);
      }
      const J = (Me - ve) * 0.1 || 10, ge = (ze - Pe) * 0.1 || 10;
      f.frameStart = ve - J, f.frameEnd = Me + J, f.valueMin = Pe - ge, f.valueMax = ze + ge, ut();
    }
    function kn() {
      const ve = (f.frameStart + f.frameEnd) / 2, Me = f.frameEnd - f.frameStart;
      f.frameStart = ve - Me * 0.4, f.frameEnd = ve + Me * 0.4, ut();
    }
    function yi() {
      const ve = (f.frameStart + f.frameEnd) / 2, Me = f.frameEnd - f.frameStart;
      f.frameStart = ve - Me * 0.6, f.frameEnd = ve + Me * 0.6, ut();
    }
    let Ki = null;
    return gn(() => {
      a.value && (Ki = new ResizeObserver((ve) => {
        for (const Me of ve)
          d.value = Me.contentRect.width, h.value = Me.contentRect.height, ut();
      }), Ki.observe(a.value)), y.value = R.value.filter((ve) => ve.animated).map((ve) => ve.id), window.addEventListener("keydown", Ai), j(), ut();
    }), Un(() => {
      Ki == null || Ki.disconnect(), window.removeEventListener("keydown", Ai);
    }), Ft([() => i.currentFrame, y, p], () => {
      ut();
    }), Ft(R, () => {
      j(), ut();
    }, { deep: !0 }), (ve, Me) => {
      var Pe, ze;
      return se(), re("div", kH, [
        v("div", DH, [
          Me[9] || (Me[9] = v("span", { class: "graph-title" }, "Graph Editor", -1)),
          v("div", IH, [
            v("button", {
              class: Le({ active: p.value === "value" }),
              onClick: Me[0] || (Me[0] = (J) => p.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            v("button", {
              class: Le({ active: p.value === "speed" }),
              onClick: Me[1] || (Me[1] = (J) => p.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          v("div", RH, [
            (se(), re(Xe, null, at(A, (J) => v("button", {
              key: J.key,
              class: Le(["preset-btn", { active: $(J.key) }]),
              onClick: (ge) => oe(J.key),
              title: J.label
            }, ye(J.shortLabel), 11, LH)), 64))
          ]),
          v("div", FH, [
            v("button", {
              onClick: j,
              title: "Fit to View"
            }, [...Me[5] || (Me[5] = [
              v("span", { class: "icon" }, "[ ]", -1)
            ])]),
            v("button", {
              onClick: z,
              class: Le({ active: E.value }),
              title: "Auto-select Nearby Keyframes"
            }, [...Me[6] || (Me[6] = [
              v("span", { class: "icon" }, "A", -1)
            ])], 2),
            v("button", {
              onClick: Me[2] || (Me[2] = (J) => P.value = !P.value),
              class: Le({ active: P.value }),
              title: "Snap to Grid"
            }, [...Me[7] || (Me[7] = [
              v("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          v("button", {
            class: "close-btn",
            onClick: Me[3] || (Me[3] = (J) => n("close"))
          }, [...Me[8] || (Me[8] = [
            v("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        v("div", OH, [
          v("div", UH, [
            v("div", zH, [
              Me[10] || (Me[10] = ct(" Properties ", -1)),
              v("button", {
                class: "toggle-all-btn",
                onClick: L,
                title: U.value ? "Hide All" : "Show All"
              }, ye(U.value ? "Hide" : "Show"), 9, BH)
            ]),
            (se(!0), re(Xe, null, at(R.value, (J) => (se(), re("div", {
              key: J.id,
              class: Le(["property-item", {
                selected: m.value.includes(J.id),
                animated: J.animated
              }])
            }, [
              v("div", {
                class: "property-row",
                onClick: (ge) => F(J.id)
              }, [
                v("span", {
                  class: Le(["visibility-toggle", { visible: y.value.includes(J.id) }]),
                  onClick: _t((ge) => B(J.id), ["stop"])
                }, null, 10, VH),
                v("span", {
                  class: "property-color",
                  style: xt({ background: he(J.id) })
                }, null, 4),
                v("span", HH, ye(J.name), 1),
                J.animated ? (se(), re("span", GH, ye(J.keyframes.length), 1)) : Te("", !0)
              ], 8, NH),
              J.name === "Position" || J.name === "Scale" ? (se(), re("div", $H, [
                (se(), re(Xe, null, at(["x", "y", "z"], (ge) => {
                  var be;
                  return v("button", {
                    key: ge,
                    class: Le({
                      active: (be = g.value[J.id]) == null ? void 0 : be.includes(ge),
                      hasValue: te(J, ge)
                    }),
                    onClick: (Ee) => D(J.id, ge)
                  }, ye(ge.toUpperCase()), 11, WH);
                }), 64))
              ])) : Te("", !0)
            ], 2))), 128)),
            R.value.length === 0 ? (se(), re("div", jH, " No animated properties ")) : Te("", !0)
          ]),
          v("div", XH, [
            v("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: r
            }, [
              v("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: ht
              }, null, 512)
            ], 512),
            v("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: a
            }, [
              v("canvas", {
                ref_key: "canvasRef",
                ref: o,
                onMousedown: O,
                onMousemove: V,
                onMouseup: H,
                onMouseleave: H,
                onWheel: X,
                onContextmenu: _t(Ue, ["prevent"])
              }, null, 544),
              _.value ? (se(), re("div", {
                key: 0,
                class: "selection-box",
                style: xt({
                  left: _.value.x + "px",
                  top: _.value.y + "px",
                  width: _.value.width + "px",
                  height: _.value.height + "px"
                })
              }, null, 4)) : Te("", !0),
              (se(), re("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${d.value} ${h.value}`
              }, [
                (se(!0), re(Xe, null, at(k.value, (J) => (se(), re("g", {
                  key: J.id,
                  class: "property-handles"
                }, [
                  (se(!0), re(Xe, null, at(J.keyframes, (ge, be) => {
                    var Ee, Se, Oe, De, et, lt, gt, wt;
                    return se(), re(Xe, { key: be }, [
                      ne(ge) ? (se(), re("g", {
                        key: 0,
                        class: Le(["keyframe-marker", {
                          selected: N(J.id, be),
                          hovered: ((Ee = w.value) == null ? void 0 : Ee.propId) === J.id && ((Se = w.value) == null ? void 0 : Se.index) === be
                        }]),
                        onMousedown: _t((dt) => me(J.id, be, dt), ["stop"])
                      }, [
                        v("rect", {
                          x: Q(ge) - 5,
                          y: K(J, ge) - 5,
                          width: "10",
                          height: "10",
                          fill: he(J.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${Q(ge)}, ${K(J, ge)})`
                        }, null, 8, ZH)
                      ], 42, qH)) : Te("", !0),
                      N(J.id, be) && ge.interpolation !== "hold" ? (se(), re("g", KH, [
                        J.keyframes[be + 1] && (ge.outHandle.enabled || ge.interpolation === "bezier") ? (se(), re("g", JH, [
                          v("line", {
                            x1: Q(ge),
                            y1: K(J, ge),
                            x2: ee(J, be),
                            y2: ce(J, be),
                            class: "handle-line"
                          }, null, 8, QH),
                          v("circle", {
                            cx: ee(J, be),
                            cy: ce(J, be),
                            r: "5",
                            class: Le(["handle-point", { dragging: ((Oe = M.value) == null ? void 0 : Oe.type) === "outHandle" && ((De = M.value) == null ? void 0 : De.propId) === J.id && ((et = M.value) == null ? void 0 : et.index) === be }]),
                            onMousedown: _t((dt) => Ve("outHandle", J.id, be), ["stop"])
                          }, null, 42, eG)
                        ])) : Te("", !0),
                        be > 0 && (ge.inHandle.enabled || ge.interpolation === "bezier") ? (se(), re("g", tG, [
                          v("line", {
                            x1: Q(ge),
                            y1: K(J, ge),
                            x2: ae(J, be),
                            y2: de(J, be),
                            class: "handle-line"
                          }, null, 8, nG),
                          v("circle", {
                            cx: ae(J, be),
                            cy: de(J, be),
                            r: "5",
                            class: Le(["handle-point", { dragging: ((lt = M.value) == null ? void 0 : lt.type) === "inHandle" && ((gt = M.value) == null ? void 0 : gt.propId) === J.id && ((wt = M.value) == null ? void 0 : wt.index) === be }]),
                            onMousedown: _t((dt) => Ve("inHandle", J.id, be), ["stop"])
                          }, null, 42, iG)
                        ])) : Te("", !0)
                      ])) : Te("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                v("line", {
                  x1: I.value,
                  y1: 0,
                  x2: I.value,
                  y2: h.value,
                  class: "current-time-line"
                }, null, 8, sG)
              ], 8, YH))
            ], 512),
            v("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: c
            }, [
              v("canvas", {
                ref_key: "valueAxisCanvas",
                ref: u
              }, null, 512)
            ], 512)
          ])
        ]),
        x.value.length > 0 ? (se(), re("div", oG, [
          v("div", aG, [
            Me[11] || (Me[11] = v("span", { class: "info-label" }, "Frame:", -1)),
            v("input", {
              type: "number",
              value: (Pe = x.value[0]) == null ? void 0 : Pe.keyframe.frame,
              onChange: Ge,
              class: "info-input"
            }, null, 40, rG)
          ]),
          v("div", lG, [
            Me[12] || (Me[12] = v("span", { class: "info-label" }, "Value:", -1)),
            v("input", {
              type: "number",
              value: Y(x.value[0]),
              onChange: Ye,
              class: "info-input",
              step: "0.1"
            }, null, 40, cG)
          ]),
          v("div", uG, [
            Me[14] || (Me[14] = v("span", { class: "info-label" }, "Interpolation:", -1)),
            v("select", {
              value: (ze = x.value[0]) == null ? void 0 : ze.keyframe.interpolation,
              onChange: We,
              class: "info-select"
            }, [...Me[13] || (Me[13] = [
              v("option", { value: "linear" }, "Linear", -1),
              v("option", { value: "bezier" }, "Bezier", -1),
              v("option", { value: "hold" }, "Hold", -1)
            ])], 40, dG)
          ])
        ])) : Te("", !0),
        C.value ? (se(), re("div", {
          key: 1,
          class: "context-menu",
          style: xt({ left: C.value.x + "px", top: C.value.y + "px" }),
          onClick: Me[4] || (Me[4] = (J) => C.value = null)
        }, [
          v("button", { onClick: rt }, "Add Keyframe"),
          v("button", {
            onClick: Qe,
            disabled: x.value.length === 0
          }, "Delete Keyframe(s)", 8, hG),
          Me[15] || (Me[15] = v("hr", null, null, -1)),
          v("button", {
            onClick: yt,
            disabled: x.value.length === 0
          }, "Copy", 8, fG),
          v("button", {
            onClick: Ce,
            disabled: !T.value
          }, "Paste", 8, pG),
          Me[16] || (Me[16] = v("hr", null, null, -1)),
          v("button", { onClick: Be }, "Select All"),
          v("button", { onClick: ke }, "Invert Selection")
        ], 4)) : Te("", !0)
      ]);
    };
  }
}), vG = /* @__PURE__ */ Vt(mG, [["__scopeId", "data-v-70deec8d"]]), { abs: Ja, cos: Ns, sin: jo, acos: gG, atan2: Qa, sqrt: y0, pow: ji } = Math;
function er(s) {
  return s < 0 ? -ji(-s, 1 / 3) : ji(s, 1 / 3);
}
const A5 = Math.PI, Ql = 2 * A5, x0 = A5 / 2, yG = 1e-6, B1 = Number.MAX_SAFE_INTEGER || 9007199254740991, N1 = Number.MIN_SAFE_INTEGER || -9007199254740991, xG = { x: 0, y: 0, z: 0 }, Je = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(s, e) {
    const n = e(s);
    let i = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (i += n.z * n.z), y0(i);
  },
  compute: function(s, e, n) {
    if (s === 0)
      return e[0].t = 0, e[0];
    const i = e.length - 1;
    if (s === 1)
      return e[i].t = 1, e[i];
    const o = 1 - s;
    let a = e;
    if (i === 0)
      return e[0].t = s, e[0];
    if (i === 1) {
      const l = {
        x: o * a[0].x + s * a[1].x,
        y: o * a[0].y + s * a[1].y,
        t: s
      };
      return n && (l.z = o * a[0].z + s * a[1].z), l;
    }
    if (i < 4) {
      let l = o * o, c = s * s, u, d, h, p = 0;
      i === 2 ? (a = [a[0], a[1], a[2], xG], u = l, d = o * s * 2, h = c) : i === 3 && (u = l * o, d = l * s * 3, h = o * c * 3, p = s * c);
      const f = {
        x: u * a[0].x + d * a[1].x + h * a[2].x + p * a[3].x,
        y: u * a[0].y + d * a[1].y + h * a[2].y + p * a[3].y,
        t: s
      };
      return n && (f.z = u * a[0].z + d * a[1].z + h * a[2].z + p * a[3].z), f;
    }
    const r = JSON.parse(JSON.stringify(e));
    for (; r.length > 1; ) {
      for (let l = 0; l < r.length - 1; l++)
        r[l] = {
          x: r[l].x + (r[l + 1].x - r[l].x) * s,
          y: r[l].y + (r[l + 1].y - r[l].y) * s
        }, typeof r[l].z < "u" && (r[l].z = r[l].z + (r[l + 1].z - r[l].z) * s);
      r.splice(r.length - 1, 1);
    }
    return r[0].t = s, r[0];
  },
  computeWithRatios: function(s, e, n, i) {
    const o = 1 - s, a = n, r = e;
    let l = a[0], c = a[1], u = a[2], d = a[3], h;
    if (l *= o, c *= s, r.length === 2)
      return h = l + c, {
        x: (l * r[0].x + c * r[1].x) / h,
        y: (l * r[0].y + c * r[1].y) / h,
        z: i ? (l * r[0].z + c * r[1].z) / h : !1,
        t: s
      };
    if (l *= o, c *= 2 * o, u *= s * s, r.length === 3)
      return h = l + c + u, {
        x: (l * r[0].x + c * r[1].x + u * r[2].x) / h,
        y: (l * r[0].y + c * r[1].y + u * r[2].y) / h,
        z: i ? (l * r[0].z + c * r[1].z + u * r[2].z) / h : !1,
        t: s
      };
    if (l *= o, c *= 1.5 * o, u *= 3 * o, d *= s * s * s, r.length === 4)
      return h = l + c + u + d, {
        x: (l * r[0].x + c * r[1].x + u * r[2].x + d * r[3].x) / h,
        y: (l * r[0].y + c * r[1].y + u * r[2].y + d * r[3].y) / h,
        z: i ? (l * r[0].z + c * r[1].z + u * r[2].z + d * r[3].z) / h : !1,
        t: s
      };
  },
  derive: function(s, e) {
    const n = [];
    for (let i = s, o = i.length, a = o - 1; o > 1; o--, a--) {
      const r = [];
      for (let l = 0, c; l < a; l++)
        c = {
          x: a * (i[l + 1].x - i[l].x),
          y: a * (i[l + 1].y - i[l].y)
        }, e && (c.z = a * (i[l + 1].z - i[l].z)), r.push(c);
      n.push(r), i = r;
    }
    return n;
  },
  between: function(s, e, n) {
    return e <= s && s <= n || Je.approximately(s, e) || Je.approximately(s, n);
  },
  approximately: function(s, e, n) {
    return Ja(s - e) <= (n || yG);
  },
  length: function(s) {
    const n = Je.Tvalues.length;
    let i = 0;
    for (let o = 0, a; o < n; o++)
      a = 0.5 * Je.Tvalues[o] + 0.5, i += Je.Cvalues[o] * Je.arcfn(a, s);
    return 0.5 * i;
  },
  map: function(s, e, n, i, o) {
    const a = n - e, r = o - i, l = s - e, c = l / a;
    return i + r * c;
  },
  lerp: function(s, e, n) {
    const i = {
      x: e.x + s * (n.x - e.x),
      y: e.y + s * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (i.z = e.z + s * (n.z - e.z)), i;
  },
  pointToString: function(s) {
    let e = s.x + "/" + s.y;
    return typeof s.z < "u" && (e += "/" + s.z), e;
  },
  pointsToString: function(s) {
    return "[" + s.map(Je.pointToString).join(", ") + "]";
  },
  copy: function(s) {
    return JSON.parse(JSON.stringify(s));
  },
  angle: function(s, e, n) {
    const i = e.x - s.x, o = e.y - s.y, a = n.x - s.x, r = n.y - s.y, l = i * r - o * a, c = i * a + o * r;
    return Qa(l, c);
  },
  // round as string, to avoid rounding errors
  round: function(s, e) {
    const n = "" + s, i = n.indexOf(".");
    return parseFloat(n.substring(0, i + 1 + e));
  },
  dist: function(s, e) {
    const n = s.x - e.x, i = s.y - e.y;
    return y0(n * n + i * i);
  },
  closest: function(s, e) {
    let n = ji(2, 63), i, o;
    return s.forEach(function(a, r) {
      o = Je.dist(e, a), o < n && (n = o, i = r);
    }), { mdist: n, mpos: i };
  },
  abcratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = ji(s, e) + ji(1 - s, e), i = n - 1;
    return Ja(i / n);
  },
  projectionratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = ji(1 - s, e), i = ji(s, e) + n;
    return n / i;
  },
  lli8: function(s, e, n, i, o, a, r, l) {
    const c = (s * i - e * n) * (o - r) - (s - n) * (o * l - a * r), u = (s * i - e * n) * (a - l) - (e - i) * (o * l - a * r), d = (s - n) * (a - l) - (e - i) * (o - r);
    return d == 0 ? !1 : { x: c / d, y: u / d };
  },
  lli4: function(s, e, n, i) {
    const o = s.x, a = s.y, r = e.x, l = e.y, c = n.x, u = n.y, d = i.x, h = i.y;
    return Je.lli8(o, a, r, l, c, u, d, h);
  },
  lli: function(s, e) {
    return Je.lli4(s, s.c, e, e.c);
  },
  makeline: function(s, e) {
    return new P5(
      s.x,
      s.y,
      (s.x + e.x) / 2,
      (s.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(s) {
    let e = B1, n = B1, i = N1, o = N1;
    return s.forEach(function(a) {
      const r = a.bbox();
      e > r.x.min && (e = r.x.min), n > r.y.min && (n = r.y.min), i < r.x.max && (i = r.x.max), o < r.y.max && (o = r.y.max);
    }), {
      x: { min: e, mid: (e + i) / 2, max: i, size: i - e },
      y: { min: n, mid: (n + o) / 2, max: o, size: o - n }
    };
  },
  shapeintersections: function(s, e, n, i, o) {
    if (!Je.bboxoverlap(e, i)) return [];
    const a = [], r = [s.startcap, s.forward, s.back, s.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return r.forEach(function(c) {
      c.virtual || l.forEach(function(u) {
        if (u.virtual) return;
        const d = c.intersects(u, o);
        d.length > 0 && (d.c1 = c, d.c2 = u, d.s1 = s, d.s2 = n, a.push(d));
      });
    }), a;
  },
  makeshape: function(s, e, n) {
    const i = e.points.length, o = s.points.length, a = Je.makeline(e.points[i - 1], s.points[0]), r = Je.makeline(s.points[o - 1], e.points[0]), l = {
      startcap: a,
      forward: s,
      back: e,
      endcap: r,
      bbox: Je.findbbox([a, s, e, r])
    };
    return l.intersections = function(c) {
      return Je.shapeintersections(
        l,
        l.bbox,
        c,
        c.bbox,
        n
      );
    }, l;
  },
  getminmax: function(s, e, n) {
    if (!n) return { min: 0, max: 0 };
    let i = B1, o = N1, a, r;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, c = n.length; l < c; l++)
      a = n[l], r = s.get(a), r[e] < i && (i = r[e]), r[e] > o && (o = r[e]);
    return { min: i, mid: (i + o) / 2, max: o, size: o - i };
  },
  align: function(s, e) {
    const n = e.p1.x, i = e.p1.y, o = -Qa(e.p2.y - i, e.p2.x - n), a = function(r) {
      return {
        x: (r.x - n) * Ns(o) - (r.y - i) * jo(o),
        y: (r.x - n) * jo(o) + (r.y - i) * Ns(o)
      };
    };
    return s.map(a);
  },
  roots: function(s, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = s.length - 1, i = Je.align(s, e), o = function(P) {
      return 0 <= P && P <= 1;
    };
    if (n === 2) {
      const P = i[0].y, E = i[1].y, b = i[2].y, S = P - 2 * E + b;
      if (S !== 0) {
        const A = -y0(E * E - P * b), R = -P + E, k = -(A + R) / S, U = -(-A + R) / S;
        return [k, U].filter(o);
      } else if (E !== b && S === 0)
        return [(2 * E - b) / (2 * E - 2 * b)].filter(o);
      return [];
    }
    const a = i[0].y, r = i[1].y, l = i[2].y, c = i[3].y;
    let u = -a + 3 * r - 3 * l + c, d = 3 * a - 6 * r + 3 * l, h = -3 * a + 3 * r, p = a;
    if (Je.approximately(u, 0)) {
      if (Je.approximately(d, 0))
        return Je.approximately(h, 0) ? [] : [-p / h].filter(o);
      const P = y0(h * h - 4 * d * p), E = 2 * d;
      return [(P - h) / E, (-h - P) / E].filter(o);
    }
    d /= u, h /= u, p /= u;
    const f = (3 * h - d * d) / 3, m = f / 3, y = (2 * d * d * d - 9 * d * h + 27 * p) / 27, g = y / 2, x = g * g + m * m * m;
    let w, M, _, C, T;
    if (x < 0) {
      const P = -f / 3, E = P * P * P, b = y0(E), S = -y / (2 * b), A = S < -1 ? -1 : S > 1 ? 1 : S, R = gG(A), k = er(b), U = 2 * k;
      return _ = U * Ns(R / 3) - d / 3, C = U * Ns((R + Ql) / 3) - d / 3, T = U * Ns((R + 2 * Ql) / 3) - d / 3, [_, C, T].filter(o);
    } else {
      if (x === 0)
        return w = g < 0 ? er(-g) : -er(g), _ = 2 * w - d / 3, C = -w - d / 3, [_, C].filter(o);
      {
        const P = y0(x);
        return w = er(-g + P), M = er(g + P), [w - M - d / 3].filter(o);
      }
    }
  },
  droots: function(s) {
    if (s.length === 3) {
      const e = s[0], n = s[1], i = s[2], o = e - 2 * n + i;
      if (o !== 0) {
        const a = -y0(n * n - e * i), r = -e + n, l = -(a + r) / o, c = -(-a + r) / o;
        return [l, c];
      } else if (n !== i && o === 0)
        return [(2 * n - i) / (2 * (n - i))];
      return [];
    }
    if (s.length === 2) {
      const e = s[0], n = s[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(s, e, n, i, o) {
    let a, r, l, c, u = 0, d = 0;
    const h = Je.compute(s, e), p = Je.compute(s, n), f = h.x * h.x + h.y * h.y;
    if (i ? (a = y0(
      ji(h.y * p.z - p.y * h.z, 2) + ji(h.z * p.x - p.z * h.x, 2) + ji(h.x * p.y - p.x * h.y, 2)
    ), r = ji(f + h.z * h.z, 3 / 2)) : (a = h.x * p.y - h.y * p.x, r = ji(f, 3 / 2)), a === 0 || r === 0)
      return { k: 0, r: 0 };
    if (u = a / r, d = r / a, !o) {
      const m = Je.curvature(s - 1e-3, e, n, i, !0).k, y = Je.curvature(s + 1e-3, e, n, i, !0).k;
      c = (y - u + (u - m)) / 2, l = (Ja(y - u) + Ja(u - m)) / 2;
    }
    return { k: u, r: d, dk: c, adk: l };
  },
  inflections: function(s) {
    if (s.length < 4) return [];
    const e = Je.align(s, { p1: s[0], p2: s.slice(-1)[0] }), n = e[2].x * e[1].y, i = e[3].x * e[1].y, o = e[1].x * e[2].y, a = e[3].x * e[2].y, r = 18 * (-3 * n + 2 * i + 3 * o - a), l = 18 * (3 * n - i - 3 * o), c = 18 * (o - n);
    if (Je.approximately(r, 0)) {
      if (!Je.approximately(l, 0)) {
        let p = -c / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const u = 2 * r;
    if (Je.approximately(u, 0)) return [];
    const d = l * l - 4 * r * c;
    if (d < 0) return [];
    const h = Math.sqrt(d);
    return [(h - l) / u, -(l + h) / u].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(s, e) {
    const n = ["x", "y"], i = n.length;
    for (let o = 0, a, r, l, c; o < i; o++)
      if (a = n[o], r = s[a].mid, l = e[a].mid, c = (s[a].size + e[a].size) / 2, Ja(r - l) >= c) return !1;
    return !0;
  },
  expandbox: function(s, e) {
    e.x.min < s.x.min && (s.x.min = e.x.min), e.y.min < s.y.min && (s.y.min = e.y.min), e.z && e.z.min < s.z.min && (s.z.min = e.z.min), e.x.max > s.x.max && (s.x.max = e.x.max), e.y.max > s.y.max && (s.y.max = e.y.max), e.z && e.z.max > s.z.max && (s.z.max = e.z.max), s.x.mid = (s.x.min + s.x.max) / 2, s.y.mid = (s.y.min + s.y.max) / 2, s.z && (s.z.mid = (s.z.min + s.z.max) / 2), s.x.size = s.x.max - s.x.min, s.y.size = s.y.max - s.y.min, s.z && (s.z.size = s.z.max - s.z.min);
  },
  pairiteration: function(s, e, n) {
    const i = s.bbox(), o = e.bbox(), a = 1e5, r = n || 0.5;
    if (i.x.size + i.y.size < r && o.x.size + o.y.size < r)
      return [
        (a * (s._t1 + s._t2) / 2 | 0) / a + "/" + (a * (e._t1 + e._t2) / 2 | 0) / a
      ];
    let l = s.split(0.5), c = e.split(0.5), u = [
      { left: l.left, right: c.left },
      { left: l.left, right: c.right },
      { left: l.right, right: c.right },
      { left: l.right, right: c.left }
    ];
    u = u.filter(function(h) {
      return Je.bboxoverlap(h.left.bbox(), h.right.bbox());
    });
    let d = [];
    return u.length === 0 || (u.forEach(function(h) {
      d = d.concat(
        Je.pairiteration(h.left, h.right, r)
      );
    }), d = d.filter(function(h, p) {
      return d.indexOf(h) === p;
    })), d;
  },
  getccenter: function(s, e, n) {
    const i = e.x - s.x, o = e.y - s.y, a = n.x - e.x, r = n.y - e.y, l = i * Ns(x0) - o * jo(x0), c = i * jo(x0) + o * Ns(x0), u = a * Ns(x0) - r * jo(x0), d = a * jo(x0) + r * Ns(x0), h = (s.x + e.x) / 2, p = (s.y + e.y) / 2, f = (e.x + n.x) / 2, m = (e.y + n.y) / 2, y = h + l, g = p + c, x = f + u, w = m + d, M = Je.lli8(h, p, y, g, f, m, x, w), _ = Je.dist(M, s);
    let C = Qa(s.y - M.y, s.x - M.x), T = Qa(e.y - M.y, e.x - M.x), P = Qa(n.y - M.y, n.x - M.x), E;
    return C < P ? ((C > T || T > P) && (C += Ql), C > P && (E = P, P = C, C = E)) : P < T && T < C ? (E = P, P = C, C = E) : P += Ql, M.s = C, M.e = P, M.r = _, M;
  },
  numberSort: function(s, e) {
    return s - e;
  }
};
class Tr {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Je.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), i = 1; i < e.length; i++)
      Je.expandbox(n, e[i].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(i) {
      n.push(...i.offset(e));
    }), new Tr(n);
  }
}
const { abs: tr, min: u9, max: d9, cos: bG, sin: _G, acos: wG, sqrt: nr } = Math, MG = Math.PI;
let P5 = class wn {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), i = !1;
    if (typeof n[0] == "object") {
      i = n.length;
      const f = [];
      n.forEach(function(m) {
        ["x", "y", "z"].forEach(function(y) {
          typeof m[y] < "u" && f.push(m[y]);
        });
      }), n = f;
    }
    let o = !1;
    const a = n.length;
    if (i) {
      if (i > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        o = !0;
      }
    } else if (a !== 6 && a !== 8 && a !== 9 && a !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const r = this._3d = !o && (a === 9 || a === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let f = 0, m = r ? 3 : 2; f < a; f += m) {
      var c = {
        x: n[f],
        y: n[f + 1]
      };
      r && (c.z = n[f + 2]), l.push(c);
    }
    const u = this.order = l.length - 1, d = this.dims = ["x", "y"];
    r && d.push("z"), this.dimlen = d.length;
    const h = Je.align(l, { p1: l[0], p2: l[u] }), p = Je.dist(l[0], l[u]);
    this._linear = h.reduce((f, m) => f + tr(m.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, i, o) {
    if (typeof o > "u" && (o = 0.5), o === 0)
      return new wn(n, n, i);
    if (o === 1)
      return new wn(e, n, n);
    const a = wn.getABC(2, e, n, i, o);
    return new wn(e, a.A, i);
  }
  static cubicFromPoints(e, n, i, o, a) {
    typeof o > "u" && (o = 0.5);
    const r = wn.getABC(3, e, n, i, o);
    typeof a > "u" && (a = Je.dist(n, r.C));
    const l = a * (1 - o) / o, c = Je.dist(e, i), u = (i.x - e.x) / c, d = (i.y - e.y) / c, h = a * u, p = a * d, f = l * u, m = l * d, y = { x: n.x - h, y: n.y - p }, g = { x: n.x + f, y: n.y + m }, x = r.A, w = { x: x.x + (y.x - x.x) / (1 - o), y: x.y + (y.y - x.y) / (1 - o) }, M = { x: x.x + (g.x - x.x) / o, y: x.y + (g.y - x.y) / o }, _ = { x: e.x + (w.x - e.x) / o, y: e.y + (w.y - e.y) / o }, C = {
      x: i.x + (M.x - i.x) / (1 - o),
      y: i.y + (M.y - i.y) / (1 - o)
    };
    return new wn(e, _, C, i);
  }
  static getUtils() {
    return Je;
  }
  getUtils() {
    return wn.getUtils();
  }
  static get PolyBezier() {
    return Tr;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Je.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, i = e[0].y, o = ["M", n, i, this.order === 2 ? "Q" : "C"];
    for (let a = 1, r = e.length; a < r; a++)
      o.push(e[a].x), o.push(e[a].y);
    return o.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Je.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = Je.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return Je.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, i, o, a = 0.5) {
    const r = Je.projectionratio(a, e), l = 1 - r, c = {
      x: r * n.x + l * o.x,
      y: r * n.y + l * o.y
    }, u = Je.abcratio(a, e);
    return { A: {
      x: i.x + (i.x - c.x) / u,
      y: i.y + (i.y - c.y) / u
    }, B: i, C: c, S: n, E: o };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let i = this.points[0], o = this.points[this.order];
    return wn.getABC(this.order, i, n, o, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, i, o; n < e; n++)
      o = n / (e - 1), i = this.compute(o), i.t = o, this._lut.push(i);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const i = this.getLUT(), o = [];
    for (let a = 0, r, l = 0; a < i.length; a++)
      r = i[a], Je.dist(r, e) < n && (o.push(r), l += a / i.length);
    return o.length ? t /= o.length : !1;
  }
  project(e) {
    const n = this.getLUT(), i = n.length - 1, o = Je.closest(n, e), a = o.mpos, r = (a - 1) / i, l = (a + 1) / i, c = 0.1 / i;
    let u = o.mdist, d = r, h = d, p;
    u += 1;
    for (let f; d < l + c; d += c)
      p = this.compute(d), f = Je.dist(e, p), f < u && (u = f, h = d);
    return h = h < 0 ? 0 : h > 1 ? 1 : h, p = this.compute(h), p.t = h, p.d = u, p;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Je.computeWithRatios(e, this.points, this.ratios, this._3d) : Je.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], i = e.length;
    for (let o = 1, a, r; o < i; o++)
      a = e[o], r = e[o - 1], n[o] = {
        x: (i - o) / i * a.x + o / i * r.x,
        y: (i - o) / i * a.y + o / i * r.y
      };
    return n[i] = e[i - 1], new wn(n);
  }
  derivative(e) {
    return Je.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Je.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new wn(Je.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Je.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Je.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), i = nr(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / i, y: n.x / i };
  }
  __normal3(e) {
    const n = this.derivative(e), i = this.derivative(e + 0.01), o = nr(n.x * n.x + n.y * n.y + n.z * n.z), a = nr(i.x * i.x + i.y * i.y + i.z * i.z);
    n.x /= o, n.y /= o, n.z /= o, i.x /= a, i.y /= a, i.z /= a;
    const r = {
      x: i.y * n.z - i.z * n.y,
      y: i.z * n.x - i.x * n.z,
      z: i.x * n.y - i.y * n.x
    }, l = nr(r.x * r.x + r.y * r.y + r.z * r.z);
    r.x /= l, r.y /= l, r.z /= l;
    const c = [
      r.x * r.x,
      r.x * r.y - r.z,
      r.x * r.z + r.y,
      r.x * r.y + r.z,
      r.y * r.y,
      r.y * r.z - r.x,
      r.x * r.z - r.y,
      r.y * r.z + r.x,
      r.z * r.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, i = [], o = [], a = 0;
    for (o[a++] = n[0], o[a++] = n[1], o[a++] = n[2], this.order === 3 && (o[a++] = n[3]); n.length > 1; ) {
      i = [];
      for (let r = 0, l, c = n.length - 1; r < c; r++)
        l = Je.lerp(e, n[r], n[r + 1]), o[a++] = l, i.push(l);
      n = i;
    }
    return o;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const i = this.hull(e), o = {
      left: this.order === 2 ? new wn([i[0], i[3], i[5]]) : new wn([i[0], i[4], i[7], i[9]]),
      right: this.order === 2 ? new wn([i[5], i[4], i[2]]) : new wn([i[9], i[8], i[6], i[3]]),
      span: i
    };
    return o.left._t1 = Je.map(0, 0, 1, this._t1, this._t2), o.left._t2 = Je.map(e, 0, 1, this._t1, this._t2), o.right._t1 = Je.map(e, 0, 1, this._t1, this._t2), o.right._t2 = Je.map(1, 0, 1, this._t1, this._t2), n ? (n = Je.map(n, e, 1, 0, 1), o.right.split(n).left) : o;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(i) {
        let o = function(r) {
          return r[i];
        }, a = this.dpoints[0].map(o);
        e[i] = Je.droots(a), this.order === 3 && (a = this.dpoints[1].map(o), e[i] = e[i].concat(Je.droots(a))), e[i] = e[i].filter(function(r) {
          return r >= 0 && r <= 1;
        }), n = n.concat(e[i].sort(Je.numberSort));
      }).bind(this)
    ), e.values = n.sort(Je.numberSort).filter(function(i, o) {
      return n.indexOf(i) === o;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(i) {
        n[i] = Je.getminmax(this, i, e[i]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), i = e.bbox();
    return Je.bboxoverlap(n, i);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const i = this.get(e), o = this.normal(e), a = {
        c: i,
        n: o,
        x: i.x + o.x * n,
        y: i.y + o.y * n
      };
      return this._3d && (a.z = i.z + o.z * n), a;
    }
    if (this._linear) {
      const i = this.normal(0), o = this.points.map(function(a) {
        const r = {
          x: a.x + e * i.x,
          y: a.y + e * i.y
        };
        return a.z && i.z && (r.z = a.z + e * i.z), r;
      });
      return [new wn(o)];
    }
    return this.reduce().map(function(i) {
      return i._linear ? i.offset(e)[0] : i.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const o = Je.angle(this.points[0], this.points[3], this.points[1]), a = Je.angle(this.points[0], this.points[3], this.points[2]);
      if (o > 0 && a < 0 || o < 0 && a > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let i = e.x * n.x + e.y * n.y;
    return this._3d && (i += e.z * n.z), tr(wG(i)) < MG / 3;
  }
  reduce() {
    let e, n = 0, i = 0, o = 0.01, a, r = [], l = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      i = c[e], a = this.split(n, i), a._t1 = n, a._t2 = i, r.push(a), n = i;
    return r.forEach(function(u) {
      for (n = 0, i = 0; i <= 1; )
        for (i = n + o; i <= 1 + o; i += o)
          if (a = u.split(n, i), !a.simple()) {
            if (i -= o, tr(n - i) < o)
              return [];
            a = u.split(n, i), a._t1 = Je.map(n, 0, 1, u._t1, u._t2), a._t2 = Je.map(i, 0, 1, u._t1, u._t2), l.push(a), n = i;
            break;
          }
      n < 1 && (a = u.split(n, 1), a._t1 = Je.map(n, 0, 1, u._t1, u._t2), a._t2 = u._t2, l.push(a));
    }), l;
  }
  translate(e, n, i) {
    i = typeof i == "number" ? i : n;
    const o = this.order;
    let a = this.points.map((r, l) => (1 - l / o) * n + l / o * i);
    return new wn(
      this.points.map((r, l) => ({
        x: r.x + e.x * a[l],
        y: r.y + e.y * a[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let i = !1;
    if (typeof e == "function" && (i = e), i && n === 2)
      return this.raise().scale(i);
    const o = this.clockwise, a = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        i ? i(0) : e,
        i ? i(1) : e
      );
    const r = i ? i(0) : e, l = i ? i(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], u = [], d = Je.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!d)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(h) {
      const p = u[h * n] = Je.copy(a[h * n]);
      p.x += (h ? l : r) * c[h].n.x, p.y += (h ? l : r) * c[h].n.y;
    }), i ? ([0, 1].forEach(function(h) {
      if (!(n === 2 && h)) {
        var p = a[h + 1], f = {
          x: p.x - d.x,
          y: p.y - d.y
        }, m = i ? i((h + 1) / n) : e;
        i && !o && (m = -m);
        var y = nr(f.x * f.x + f.y * f.y);
        f.x /= y, f.y /= y, u[h + 1] = {
          x: p.x + m * f.x,
          y: p.y + m * f.y
        };
      }
    }), new wn(u)) : ([0, 1].forEach((h) => {
      if (n === 2 && h) return;
      const p = u[h * n], f = this.derivative(h), m = { x: p.x + f.x, y: p.y + f.y };
      u[h + 1] = Je.lli4(p, m, d, a[h + 1]);
    }), new wn(u));
  }
  outline(e, n, i, o) {
    if (n = n === void 0 ? e : n, this._linear) {
      const C = this.normal(0), T = this.points[0], P = this.points[this.points.length - 1];
      let E, b, S;
      i === void 0 && (i = e, o = n), E = { x: T.x + C.x * e, y: T.y + C.y * e }, S = { x: P.x + C.x * i, y: P.y + C.y * i }, b = { x: (E.x + S.x) / 2, y: (E.y + S.y) / 2 };
      const A = [E, b, S];
      E = { x: T.x - C.x * n, y: T.y - C.y * n }, S = { x: P.x - C.x * o, y: P.y - C.y * o }, b = { x: (E.x + S.x) / 2, y: (E.y + S.y) / 2 };
      const R = [S, b, E], k = Je.makeline(R[2], A[0]), U = Je.makeline(A[2], R[0]), I = [k, new wn(A), U, new wn(R)];
      return new Tr(I);
    }
    const a = this.reduce(), r = a.length, l = [];
    let c = [], u, d = 0, h = this.length();
    const p = typeof i < "u" && typeof o < "u";
    function f(C, T, P, E, b) {
      return function(S) {
        const A = E / P, R = (E + b) / P, k = T - C;
        return Je.map(S, 0, 1, C + A * k, C + R * k);
      };
    }
    a.forEach(function(C) {
      const T = C.length();
      p ? (l.push(
        C.scale(f(e, i, h, d, T))
      ), c.push(
        C.scale(f(-n, -o, h, d, T))
      )) : (l.push(C.scale(e)), c.push(C.scale(-n))), d += T;
    }), c = c.map(function(C) {
      return u = C.points, u[3] ? C.points = [u[3], u[2], u[1], u[0]] : C.points = [u[2], u[1], u[0]], C;
    }).reverse();
    const m = l[0].points[0], y = l[r - 1].points[l[r - 1].points.length - 1], g = c[r - 1].points[c[r - 1].points.length - 1], x = c[0].points[0], w = Je.makeline(g, m), M = Je.makeline(y, x), _ = [w].concat(l).concat([M]).concat(c);
    return new Tr(_);
  }
  outlineshapes(e, n, i) {
    n = n || e;
    const o = this.outline(e, n).curves, a = [];
    for (let r = 1, l = o.length; r < l / 2; r++) {
      const c = Je.makeshape(
        o[r],
        o[l - r],
        i
      );
      c.startcap.virtual = r > 1, c.endcap.virtual = r < l / 2 - 1, a.push(c);
    }
    return a;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof wn && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = u9(e.p1.x, e.p2.x), i = u9(e.p1.y, e.p2.y), o = d9(e.p1.x, e.p2.x), a = d9(e.p1.y, e.p2.y);
    return Je.roots(this.points, e).filter((r) => {
      var l = this.get(r);
      return Je.between(l.x, n, o) && Je.between(l.y, i, a);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), i = n.length - 2, o = [];
    for (let a = 0, r, l, c; a < i; a++)
      l = n.slice(a, a + 1), c = n.slice(a + 2), r = this.curveintersects(l, c, e), o.push(...r);
    return o;
  }
  curveintersects(e, n, i) {
    const o = [];
    e.forEach(function(r) {
      n.forEach(function(l) {
        r.overlaps(l) && o.push({ left: r, right: l });
      });
    });
    let a = [];
    return o.forEach(function(r) {
      const l = Je.pairiteration(
        r.left,
        r.right,
        i
      );
      l.length > 0 && (a = a.concat(l));
    }), a;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, i, o) {
    const a = (o - i) / 4, r = this.get(i + a), l = this.get(o - a), c = Je.dist(e, n), u = Je.dist(e, r), d = Je.dist(e, l);
    return tr(u - c) + tr(d - c);
  }
  _iterate(e, n) {
    let i = 0, o = 1, a;
    do {
      a = 0, o = 1;
      let r = this.get(i), l, c, u, d, h = !1, p = !1, f, m = o, y = 1;
      do
        if (p = h, d = u, m = (i + o) / 2, l = this.get(m), c = this.get(o), u = Je.getccenter(r, l, c), u.interval = {
          start: i,
          end: o
        }, h = this._error(u, r, i, o) <= e, f = p && !h, f || (y = o), h) {
          if (o >= 1) {
            if (u.interval.end = y = 1, d = u, o > 1) {
              let x = {
                x: u.x + u.r * bG(u.e),
                y: u.y + u.r * _G(u.e)
              };
              u.e += Je.angle({ x: u.x, y: u.y }, x, this.get(1));
            }
            break;
          }
          o = o + (o - i) / 2;
        } else
          o = m;
      while (!f && a++ < 100);
      if (a >= 100)
        break;
      d = d || u, n.push(d), i = y;
    } while (o < 1);
    return n;
  }
};
const SG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: P5
}, Symbol.toStringTag, { value: "Module" })), h9 = SG;
class CG {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    le(this, "curve");
    le(this, "lut");
    le(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, i = this.curve.get(0);
    for (let o = 0; o <= e; o++) {
      const a = o / e, r = this.curve.get(a);
      if (o > 0) {
        const l = r.x - i.x, c = r.y - i.y;
        n += Math.sqrt(l * l + c * c);
      }
      this.lut.push({
        t: a,
        length: n
      }), i = r;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.lut.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.lut[l].length < e ? n = l + 1 : i = l;
    }
    const o = this.lut[n], a = this.lut[Math.max(0, n - 1)];
    if (o.length === a.length)
      return o.t;
    const r = (e - a.length) / (o.length - a.length);
    return a.t + r * (o.t - a.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], i = this.totalLength / (e - 1);
    for (let o = 0; o < e; o++) {
      const a = o * i;
      n.push(this.getPointAtDistance(a));
    }
    return n;
  }
}
function TG(s) {
  if (!s || s.length < 2)
    return null;
  let e = null;
  for (const n of s) {
    const [i, ...o] = n;
    if (i === "M")
      e = { x: o[0], y: o[1] };
    else {
      if (i === "C" && e)
        return new h9(
          e.x,
          e.y,
          o[0],
          o[1],
          // control point 1
          o[2],
          o[3],
          // control point 2
          o[4],
          o[5]
          // end point
        );
      if (i === "Q" && e)
        return new h9(
          e.x,
          e.y,
          o[0],
          o[1],
          // control point
          o[2],
          o[3]
          // end point
        );
    }
  }
  return null;
}
class EG {
  constructor() {
    le(this, "offscreenCanvas", null);
    le(this, "ctx", null);
    le(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const i = Math.round(e / 8) * 8, o = Math.round(n / 8) * 8, a = Math.max(256, i), r = Math.max(256, o), l = e === a && n === r;
    return {
      valid: l,
      correctedWidth: a,
      correctedHeight: r,
      message: l ? void 0 : `Adjusted to ${a}x${r} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, i) {
    const { frameCount: o } = e.composition, { width: a, height: r } = n;
    this.offscreenCanvas = new OffscreenCanvas(a, r), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let c = 0; c < o; c++) {
      i && i({
        frame: c,
        total: o,
        percent: Math.round(c / o * 100)
      }), this.stepParticleSystemsToFrame(e, c);
      const u = await this.generateFrame(e, c, n);
      l.push(u);
    }
    return this.particleSystems.clear(), i && i({
      frame: o,
      total: o,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, i) {
    const o = this.ctx, { width: a, height: r } = i;
    if (o.fillStyle = "#FFFFFF", o.fillRect(0, 0, a, r), i.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    o.fillStyle = "#000000";
    const l = a / e.composition.width, c = r / e.composition.height, u = e.layers.filter(
      (h) => h.type === "text" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of u)
      await this.renderTextLayerToMatte(o, h, e, n, l, c);
    const d = e.layers.filter(
      (h) => h.type === "particles" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of d)
      this.renderParticleLayerToMatte(o, h, a, r);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, i) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== i.width || this.offscreenCanvas.height !== i.height) && (this.offscreenCanvas = new OffscreenCanvas(i.width, i.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const o = await this.generateFrame(e, n, i);
    return URL.createObjectURL(o);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, i, o, a, r) {
    const l = n.data;
    if (!l) return;
    const c = n.properties.find((h) => h.name === "fontSize"), d = (c ? mt(c, o) : l.fontSize) * Math.min(a, r);
    e.font = `${l.fontWeight} ${d}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, i, o, d, a, r) : this.renderTextBlockToMatte(e, n, l, o, d, a, r);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, i, o, a, r, l, c) {
    const u = o.layers.find((M) => M.id === i.pathLayerId);
    if (!u || u.type !== "spline") return;
    const d = u.data;
    if (!(d != null && d.controlPoints) || d.controlPoints.length < 2) return;
    const h = this.buildPathCommands(d);
    if (!h || h.length < 2) return;
    const p = TG(h);
    if (!p) return;
    const f = new CG(p), m = n.properties.find((M) => M.name === "pathOffset"), y = m ? mt(m, a) : i.pathOffset, g = f.totalLength;
    let x = y * g;
    const w = 4 * Math.min(l, c);
    for (const M of i.text) {
      if (M === " ") {
        const A = e.measureText(" ").width;
        x += A + i.letterSpacing;
        continue;
      }
      const _ = e.measureText(M).width, C = Math.max(0, Math.min(x, g)), { point: T, tangent: P } = f.getPointAtDistance(C), E = Math.atan2(P.y, P.x), b = T.x * l, S = T.y * c;
      e.save(), e.translate(b, S), e.rotate(E), e.fillRect(
        -w,
        -r - w,
        _ + w * 2,
        r + w * 2
      ), e.restore(), x += _ + i.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const i = [];
    i.push(["M", n[0].x, n[0].y]);
    for (let o = 0; o < n.length - 1; o++) {
      const a = n[o], r = n[o + 1], l = a.handleOut || { x: a.x, y: a.y }, c = r.handleIn || { x: r.x, y: r.y };
      i.push([
        "C",
        l.x,
        l.y,
        c.x,
        c.y,
        r.x,
        r.y
      ]);
    }
    return i;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, i, o, a, r, l) {
    const c = n.transform.position, u = mt(c, o), d = n.transform.rotation, h = mt(d, o), p = n.transform.scale, f = mt(p, o);
    e.save(), e.translate(u.x * r, u.y * l), e.rotate(h * Math.PI / 180), e.scale(f.x, f.y);
    const y = e.measureText(i.text).width, g = a, x = 4;
    e.fillRect(
      -x,
      -g - x,
      y + x * 2,
      g + x * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", i) {
    const o = (await Promise.resolve().then(() => EY)).default, a = new o();
    e.forEach((u, d) => {
      const h = `${n}_${String(d).padStart(4, "0")}.png`;
      a.file(h, u);
    });
    const r = await a.generateAsync(
      { type: "blob" },
      (u) => {
        i && i(Math.round(u.percent));
      }
    ), l = URL.createObjectURL(r), c = document.createElement("a");
    c.href = l, c.download = `${n}.zip`, document.body.appendChild(c), c.click(), document.body.removeChild(c), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (i) => i.type === "particles"
    );
    for (const i of n) {
      const o = i.data;
      if (!o) continue;
      const a = new lu(o.systemConfig);
      for (const l of o.emitters)
        a.addEmitter(l);
      for (const l of o.gravityWells)
        a.addGravityWell(l);
      for (const l of o.vortices)
        a.addVortex(l);
      for (const l of o.modulations)
        a.addModulation(l);
      const r = o.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < r; l++)
        a.step();
      this.particleSystems.set(i.id, a);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const i of e.layers) {
        if (i.type !== "particles") continue;
        const o = this.particleSystems.get(i.id);
        o && i.visible && n >= i.inPoint && n <= i.outPoint && o.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, i, o) {
    const a = this.particleSystems.get(n.id);
    if (!a) return;
    const r = a.renderToMask(i, o), l = new OffscreenCanvas(i, o);
    l.getContext("2d").putImageData(r, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const Z0 = new EG(), AG = { class: "export-dialog" }, PG = { class: "dialog-header" }, kG = { class: "dialog-content" }, DG = { class: "form-group" }, IG = { class: "resolution-presets" }, RG = ["onClick"], LG = { class: "custom-resolution" }, FG = { class: "dimension-input" }, OG = { class: "dimension-input" }, UG = {
  key: 0,
  class: "dimension-warning"
}, zG = { class: "form-group" }, BG = { class: "matte-mode-options" }, NG = { class: "form-group" }, VG = { class: "preview-container" }, HG = ["src"], GG = {
  key: 1,
  class: "preview-placeholder"
}, $G = {
  key: 0,
  class: "progress-section"
}, WG = { class: "progress-bar" }, jG = { class: "progress-text" }, XG = { class: "dialog-footer" }, YG = { class: "export-info" }, qG = ["disabled"], ZG = ["disabled"], KG = /* @__PURE__ */ Bt({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = e, i = un(), o = Z0.getResolutionPresets(), a = xe("720p (1280x720)"), r = xe(1280), l = xe(720), c = xe(), u = xe("exclude_text"), d = xe(null), h = xe(!1), p = xe(0), f = xe(""), m = Re(() => r.value), y = Re(() => l.value);
    function g(_) {
      a.value = _.label, r.value = _.width, l.value = _.height, c.value = void 0;
    }
    function x() {
      const _ = Z0.validateDimensions(r.value, l.value);
      if (!_.valid)
        r.value = _.correctedWidth, l.value = _.correctedHeight, c.value = _.message, a.value = "";
      else {
        c.value = void 0;
        const C = o.find(
          (T) => T.width === r.value && T.height === l.value
        );
        a.value = (C == null ? void 0 : C.label) || "";
      }
    }
    async function w() {
      if (!i.hasProject) return;
      d.value && (URL.revokeObjectURL(d.value), d.value = null);
      const _ = {
        width: m.value,
        height: y.value,
        matteMode: u.value
      };
      d.value = await Z0.generatePreviewFrame(
        i.project,
        0,
        _
      );
    }
    async function M() {
      if (h.value || !i.hasProject) return;
      h.value = !0, p.value = 0, f.value = "Generating frames...";
      const _ = {
        width: m.value,
        height: y.value,
        matteMode: u.value
      };
      try {
        const C = await Z0.generateMatteSequence(
          i.project,
          _,
          (T) => {
            p.value = T.percent, f.value = `Generating frame ${T.frame + 1} of ${T.total}...`;
          }
        );
        f.value = "Creating ZIP archive...", await Z0.downloadAsZip(
          C,
          `matte_${Date.now()}`,
          (T) => {
            f.value = `Compressing... ${T}%`;
          }
        ), f.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (C) {
        console.error("[ExportDialog] Export failed:", C), f.value = `Export failed: ${C instanceof Error ? C.message : "Unknown error"}`;
      } finally {
        h.value = !1;
      }
    }
    return Ft(
      [m, y, u],
      () => {
        w();
      },
      { immediate: !1 }
    ), gn(() => {
      if (i.hasProject) {
        const _ = Z0.validateDimensions(i.width, i.height);
        r.value = _.correctedWidth, l.value = _.correctedHeight;
        const C = o.find(
          (T) => T.width === r.value && T.height === l.value
        );
        a.value = (C == null ? void 0 : C.label) || "", _.valid || (c.value = _.message);
      }
      w();
    }), Un(() => {
      d.value && URL.revokeObjectURL(d.value), Z0.dispose();
    }), (_, C) => (se(), re("div", {
      class: "export-dialog-overlay",
      onClick: C[6] || (C[6] = _t((T) => n("close"), ["self"]))
    }, [
      v("div", AG, [
        v("div", PG, [
          C[8] || (C[8] = v("h3", null, "Export Matte Sequence", -1)),
          v("button", {
            class: "close-btn",
            onClick: C[0] || (C[0] = (T) => n("close"))
          }, [...C[7] || (C[7] = [
            v("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        v("div", kG, [
          v("div", DG, [
            C[13] || (C[13] = v("label", null, "Resolution", -1)),
            v("div", IG, [
              (se(!0), re(Xe, null, at(He(o), (T) => (se(), re("button", {
                key: T.label,
                class: Le(["preset-btn", { active: a.value === T.label }]),
                onClick: (P) => g(T)
              }, ye(T.label), 11, RG))), 128))
            ]),
            v("div", LG, [
              v("div", FG, [
                C[9] || (C[9] = v("label", null, "Width", -1)),
                st(v("input", {
                  "onUpdate:modelValue": C[1] || (C[1] = (T) => r.value = T),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: x
                }, null, 544), [
                  [
                    Ot,
                    r.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              C[11] || (C[11] = v("span", { class: "dimension-x" }, "", -1)),
              v("div", OG, [
                C[10] || (C[10] = v("label", null, "Height", -1)),
                st(v("input", {
                  "onUpdate:modelValue": C[2] || (C[2] = (T) => l.value = T),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: x
                }, null, 544), [
                  [
                    Ot,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            c.value ? (se(), re("p", UG, [
              C[12] || (C[12] = v("i", { class: "pi pi-info-circle" }, null, -1)),
              ct(" " + ye(c.value), 1)
            ])) : Te("", !0)
          ]),
          v("div", zG, [
            C[16] || (C[16] = v("label", null, "Matte Mode", -1)),
            v("div", BG, [
              v("button", {
                class: Le(["mode-btn", { active: u.value === "exclude_text" }]),
                onClick: C[3] || (C[3] = (T) => u.value = "exclude_text")
              }, [...C[14] || (C[14] = [
                v("i", { class: "pi pi-ban" }, null, -1),
                v("span", null, "Exclude Text", -1),
                v("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              v("button", {
                class: Le(["mode-btn", { active: u.value === "include_all" }]),
                onClick: C[4] || (C[4] = (T) => u.value = "include_all")
              }, [...C[15] || (C[15] = [
                v("i", { class: "pi pi-check-circle" }, null, -1),
                v("span", null, "Include All", -1),
                v("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          v("div", NG, [
            C[18] || (C[18] = v("label", null, "Preview (Frame 0)", -1)),
            v("div", VG, [
              d.value ? (se(), re("img", {
                key: 0,
                src: d.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, HG)) : (se(), re("div", GG, [...C[17] || (C[17] = [
                v("i", { class: "pi pi-image" }, null, -1),
                v("span", null, "Generating preview...", -1)
              ])]))
            ]),
            C[19] || (C[19] = v("p", { class: "preview-info" }, [
              ct(" White = Keep original / generate content"),
              v("br"),
              ct(" Black = Exclude from generation ")
            ], -1))
          ]),
          h.value ? (se(), re("div", $G, [
            v("div", WG, [
              v("div", {
                class: "progress-fill",
                style: xt({ width: `${p.value}%` })
              }, null, 4)
            ]),
            v("p", jG, ye(f.value), 1)
          ])) : Te("", !0)
        ]),
        v("div", XG, [
          v("div", YG, [
            v("span", null, ye(He(i).frameCount) + " frames @ " + ye(m.value) + "" + ye(y.value), 1)
          ]),
          v("button", {
            class: "cancel-btn",
            onClick: C[5] || (C[5] = (T) => n("close")),
            disabled: h.value
          }, " Cancel ", 8, qG),
          v("button", {
            class: "export-btn",
            onClick: M,
            disabled: h.value || !He(i).hasProject
          }, [
            C[20] || (C[20] = v("i", { class: "pi pi-download" }, null, -1)),
            ct(" " + ye(h.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, ZG)
        ])
      ])
    ]));
  }
}), JG = /* @__PURE__ */ Vt(KG, [["__scopeId", "data-v-34eee532"]]), QG = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !1,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  motionctrl: {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 3
  },
  cogvideox: {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ati: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ttm: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "ttm-wan": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "ttm-cogvideox": {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 8,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 50,
    cfgScale: 6
  },
  "ttm-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 8,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  }
}, e$ = {
  midas: {
    format: "midas",
    bitDepth: 8,
    invert: !0,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  zoe: {
    format: "zoe",
    bitDepth: 16,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: !1,
    normalize: !1,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  normalized: {
    format: "normalized",
    bitDepth: 8,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
}, t$ = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
], n$ = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
], f9 = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  motionctrl: {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  cogvideox: {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  ati: {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  ttm: {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "ttm-wan": {
    name: "TTM (Wan 2.1 Backend)",
    description: "Time-to-Move with Wan 2.1 model for high-quality generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControl", "TTM_TrajectoryFromPoints", "WanImageToVideo"]
  },
  "ttm-cogvideox": {
    name: "TTM (CogVideoX Backend)",
    description: "Time-to-Move with CogVideoX model for longer sequences",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["prompt", "last_frame", "tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlCogVideo", "TTM_TrajectoryFromPoints", "CogVideoImageToVideo"]
  },
  "ttm-svd": {
    name: "TTM (SVD Backend)",
    description: "Time-to-Move with Stable Video Diffusion for fast generation",
    requiredInputs: ["reference_image", "motion_masks", "trajectories"],
    optionalInputs: ["tweak_index", "tstrong_index"],
    outputTypes: ["video"],
    comfyNodes: ["TTM_ApplyMotionControlSVD", "TTM_TrajectoryFromPoints", "SVDEncode"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};
function i$(s) {
  const { width: e, height: n, nearClip: i, farClip: o, camera: a, layers: r, frame: l } = s, c = new Float32Array(e * n);
  c.fill(o);
  let u = o, d = i;
  const h = [...r].filter((p) => p.visible).sort((p, f) => {
    const m = V1(p, l), y = V1(f, l);
    return m - y;
  });
  for (const p of h) {
    const f = V1(p, l), m = s$(p, l);
    if (m < 0.01) continue;
    const y = o$(p, l, a, e, n);
    if (!y) continue;
    const g = a.position.z, x = Math.abs(f - g), w = Math.max(i, Math.min(o, x));
    u = Math.min(u, w), d = Math.max(d, w), p.type === "depthflow" && a$(p) ? r$(c, p, y, e, n, i, o) : l$(c, y, w, m, e, n);
  }
  return {
    depthBuffer: c,
    width: e,
    height: n,
    minDepth: u,
    maxDepth: d
  };
}
function V1(s, e) {
  var i;
  const n = (i = s.transform) == null ? void 0 : i.position;
  if (!n) return 0;
  if (n.keyframes && n.keyframes.length > 0)
    return k5(n.keyframes, e, 2) || 0;
  if (n.value) {
    const o = n.value;
    if (typeof o == "object" && "z" in o)
      return o.z ?? 0;
  }
  return 0;
}
function s$(s, e) {
  var n;
  return s.opacity && "keyframes" in s.opacity && ((n = s.opacity.keyframes) == null ? void 0 : n.length) > 0 ? (k5(s.opacity.keyframes, e) || 100) / 100 : s.opacity && "value" in s.opacity ? (s.opacity.value || 100) / 100 : 1;
}
function o$(s, e, n, i, o) {
  var E, b, S;
  let a = 0, r = 0;
  const l = (E = s.transform) == null ? void 0 : E.position;
  if (l && "value" in l) {
    const A = l.value;
    Array.isArray(A) && (a = A[0] || 0, r = A[1] || 0);
  }
  const c = s.width || i, u = s.height || o;
  let d = 1, h = 1;
  const p = (b = s.transform) == null ? void 0 : b.scale;
  if (p && "value" in p) {
    const A = p.value;
    Array.isArray(A) && (d = (A[0] || 100) / 100, h = (A[1] || 100) / 100);
  }
  const f = c * d, m = u * h;
  let y = 0.5, g = 0.5;
  const x = (S = s.transform) == null ? void 0 : S.anchorPoint;
  if (x && "value" in x) {
    const A = x.value;
    Array.isArray(A) && (y = (A[0] || 0) / c + 0.5, g = (A[1] || 0) / u + 0.5);
  }
  const w = a - f * y + i / 2, M = r - m * g + o / 2, _ = Math.max(0, Math.min(i, w)), C = Math.max(0, Math.min(o, M)), T = Math.max(0, Math.min(i - _, f - (_ - w))), P = Math.max(0, Math.min(o - C, m - (C - M)));
  return T <= 0 || P <= 0 ? null : {
    x: _,
    y: C,
    width: T,
    height: P
  };
}
function a$(s) {
  return s.type === "depthflow" && !!s.depthMapData;
}
function r$(s, e, n, i, o, a, r) {
  const l = e.depthMapData, c = e.depthWidth || n.width, u = e.depthHeight || n.height;
  for (let d = 0; d < n.height; d++)
    for (let h = 0; h < n.width; h++) {
      const p = Math.floor(n.x + h), f = Math.floor(n.y + d);
      if (p < 0 || p >= i || f < 0 || f >= o) continue;
      const m = Math.floor(h / n.width * c), g = Math.floor(d / n.height * u) * c + m;
      let x;
      l instanceof Float32Array ? x = l[g] : x = l[g] / 255;
      const w = a + x * (r - a), M = f * i + p;
      w < s[M] && (s[M] = w);
    }
}
function l$(s, e, n, i, o, a) {
  const r = Math.floor(e.x), l = Math.floor(e.y), c = Math.min(o, Math.ceil(e.x + e.width)), u = Math.min(a, Math.ceil(e.y + e.height));
  for (let d = l; d < u; d++)
    for (let h = r; h < c; h++) {
      const p = d * o + h;
      i > 0.5 && n < s[p] && (s[p] = n);
    }
}
function k5(s, e, n) {
  if (!s || s.length === 0) return null;
  let i = s[0], o = s[s.length - 1];
  for (let c = 0; c < s.length; c++)
    if (s[c].frame <= e && (i = s[c]), s[c].frame >= e && c < s.length) {
      o = s[c];
      break;
    }
  if (i.frame === o.frame) {
    const c = i.value;
    return n !== void 0 && Array.isArray(c) ? c[n] : c;
  }
  const a = (e - i.frame) / (o.frame - i.frame), r = n !== void 0 && Array.isArray(i.value) ? i.value[n] : i.value, l = n !== void 0 && Array.isArray(o.value) ? o.value[n] : o.value;
  return r + (l - r) * a;
}
function c$(s, e) {
  const n = e$[e], { depthBuffer: i, width: o, height: a, minDepth: r, maxDepth: l } = s, c = o * a;
  if (n.bitDepth === 16) {
    const u = new Uint16Array(c);
    for (let d = 0; d < c; d++) {
      let h;
      n.normalize ? h = (i[d] - r) / (l - r) : h = i[d] / n.farClip, n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(65535, Math.round(h * 65535)));
    }
    return u;
  } else {
    const u = new Uint8Array(c);
    for (let d = 0; d < c; d++) {
      let h = (i[d] - r) / (l - r);
      n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(255, Math.round(h * 255)));
    }
    return u;
  }
}
function u$(s, e, n) {
  const i = new ImageData(e, n), o = s instanceof Uint16Array;
  for (let a = 0; a < e * n; a++) {
    const r = o ? Math.floor(s[a] / 256) : s[a], l = a * 4;
    i.data[l] = r, i.data[l + 1] = r, i.data[l + 2] = r, i.data[l + 3] = 255;
  }
  return i;
}
const ec = r0("ComfyUI");
class d$ {
  constructor(e) {
    le(this, "serverAddress");
    le(this, "clientId");
    le(this, "ws", null);
    le(this, "messageHandlers", /* @__PURE__ */ new Map());
    this.serverAddress = e.serverAddress.replace(/\/$/, ""), this.clientId = e.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      return (await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      })).ok;
    } catch {
      return !1;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const e = await fetch(`http://${this.serverAddress}/system_stats`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const e = await fetch(`http://${this.serverAddress}/prompt`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(e, n, i = "input", o, a = !0) {
    const r = new FormData();
    r.append("image", e, n), r.append("type", i), r.append("overwrite", a.toString()), o && r.append("subfolder", o);
    const l = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: r
    });
    if (!l.ok) {
      const c = await l.text();
      throw new Error(`Failed to upload image: ${c}`);
    }
    return l.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(e, n, i) {
    const o = new FormData();
    o.append("image", e, n), o.append("original_ref", JSON.stringify(i)), o.append("type", "input");
    const a = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: o
    });
    if (!a.ok)
      throw new Error(`Failed to upload mask: ${await a.text()}`);
    return a.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(e, n) {
    const i = {
      prompt: e,
      client_id: this.clientId,
      extra_data: n
    }, o = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(i)
    });
    if (!o.ok) {
      const a = await o.text();
      throw new Error(`Failed to queue prompt: ${a}`);
    }
    return o.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(e) {
    const n = e ? `http://${this.serverAddress}/history/${e}` : `http://${this.serverAddress}/history`, i = await fetch(n);
    if (!i.ok)
      throw new Error(`Failed to get history: ${await i.text()}`);
    return i.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(e, n = "", i = "output") {
    const o = new URLSearchParams({
      filename: e,
      subfolder: n,
      type: i
    }), a = await fetch(`http://${this.serverAddress}/view?${o}`);
    if (!a.ok)
      throw new Error(`Failed to get output: ${await a.text()}`);
    return a.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(e, n = "", i = "output") {
    const o = await this.getOutput(e, n, i);
    return new Promise((a, r) => {
      const l = new FileReader();
      l.onloadend = () => a(l.result), l.onerror = r, l.readAsDataURL(o);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const e = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!e.ok)
      throw new Error(`Failed to interrupt: ${await e.text()}`);
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const e = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: !0 })
    });
    if (!e.ok)
      throw new Error(`Failed to clear queue: ${await e.text()}`);
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(e, n) {
    const i = await fetch(`http://${this.serverAddress}/${e}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: n })
    });
    if (!i.ok)
      throw new Error(`Failed to delete from ${e}: ${await i.text()}`);
  }
  /**
   * Get available models
   */
  async getModels(e) {
    const n = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    }, i = await fetch(
      `http://${this.serverAddress}/models/${n[e]}`
    );
    return i.ok ? i.json() : [];
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((e, n) => {
      const i = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(i), this.ws.onopen = () => {
        ec.debug("WebSocket connected"), e();
      }, this.ws.onerror = (o) => {
        ec.error("WebSocket error:", o), n(new Error("WebSocket connection failed"));
      }, this.ws.onclose = () => {
        ec.debug("WebSocket disconnected"), this.ws = null;
      }, this.ws.onmessage = (o) => {
        try {
          const a = JSON.parse(o.data);
          this.handleWebSocketMessage(a);
        } catch (a) {
          ec.error("Failed to parse WebSocket message:", a);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    this.ws && (this.ws.close(), this.ws = null), this.messageHandlers.clear();
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(e, n) {
    this.messageHandlers.set(e, n);
  }
  /**
   * Remove a message handler
   */
  offMessage(e) {
    this.messageHandlers.delete(e);
  }
  handleWebSocketMessage(e) {
    const { type: n } = e, i = this.messageHandlers.get(n);
    i && i(e);
    const o = this.messageHandlers.get("all");
    o && o(e);
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(e, n, i) {
    const o = new OffscreenCanvas(e.width, e.height);
    o.getContext("2d").putImageData(e, 0, 0);
    const r = await o.convertToBlob({ type: "image/png" });
    return this.uploadImage(r, n, "input", i);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(e, n, i) {
    let o;
    return e instanceof OffscreenCanvas ? o = await e.convertToBlob({ type: "image/png" }) : o = await new Promise((a, r) => {
      e.toBlob((l) => {
        l ? a(l) : r(new Error("Failed to convert canvas to blob"));
      }, "image/png");
    }), this.uploadImage(o, n, "input", i);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(e, n, i = 3e5) {
    const o = Date.now();
    return this.isWebSocketConnected() || await this.connectWebSocket(), new Promise((a, r) => {
      let l = !1;
      const c = () => {
        this.offMessage("progress"), this.offMessage("executing"), this.offMessage("executed"), this.offMessage("execution_error");
      }, u = () => {
        Date.now() - o > i && (c(), r(new Error("Prompt execution timed out")));
      };
      this.onMessage("progress", (d) => {
        u(), n == null || n({
          status: "executing",
          currentStep: d.data.value,
          totalSteps: d.data.max,
          percentage: d.data.value / d.data.max * 100
        });
      }), this.onMessage("executing", (d) => {
        u(), d.data.prompt_id === e && (n == null || n({
          status: "executing",
          currentNode: d.data.node,
          percentage: 10
          // Approximate
        }));
      }), this.onMessage("executed", async (d) => {
        if (d.data.prompt_id === e && !l) {
          l = !0, c(), n == null || n({
            status: "completed",
            percentage: 100
          });
          const h = await this.getHistory(e);
          a(h[e]);
        }
      }), this.onMessage("execution_error", (d) => {
        d.data.prompt_id === e && (c(), n == null || n({
          status: "error",
          percentage: 0
        }), r(new Error(d.data.exception_message || "Execution failed")));
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(e, n) {
    const { prompt_id: i } = await this.queuePrompt(e);
    n == null || n({
      status: "queued",
      percentage: 0
    });
    const o = await this.waitForPrompt(i, n), a = [];
    for (const r of Object.values(o.outputs))
      r.images && a.push(...r.images), r.gifs && a.push(...r.gifs);
    return {
      promptId: i,
      history: o,
      outputs: a
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let tc = null;
function qo(s) {
  return (!tc || s && s !== tc.server) && (tc = new d$({
    serverAddress: s || "127.0.0.1:8188"
  })), tc;
}
let D5 = 1;
function Ps() {
  D5 = 1;
}
function ot() {
  return String(D5++);
}
function tt(s, e, n) {
  const i = {
    class_type: s,
    inputs: e
  };
  return n && (i._meta = { title: n }), i;
}
function Ie(s, e = 0) {
  return [s, e];
}
function Zh(s, e) {
  const n = ot();
  return s[n] = tt("CheckpointLoaderSimple", {
    ckpt_name: e
  }, "Load Checkpoint"), n;
}
function wa(s, e, n, i) {
  const o = ot();
  return s[o] = tt("CLIPTextEncode", {
    clip: e,
    text: n
  }, i), o;
}
function s0(s, e, n) {
  const i = ot();
  return s[i] = tt("LoadImage", {
    image: e
  }, n || "Load Image"), i;
}
function o0(s, e, n, i) {
  const o = ot();
  return s[o] = tt("ImageResize", {
    image: e,
    width: n,
    height: i,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image"), o;
}
function h$(s, e, n) {
  const i = ot();
  return s[i] = tt("VAEEncode", {
    pixels: e,
    vae: n
  }, "VAE Encode"), i;
}
function Aa(s, e, n) {
  const i = ot();
  return s[i] = tt("VAEDecode", {
    samples: e,
    vae: n
  }, "VAE Decode"), i;
}
function Pa(s, e, n, i, o, a) {
  const r = ot();
  return s[r] = tt("KSampler", {
    model: e,
    positive: n,
    negative: i,
    latent_image: o,
    seed: a.seed ?? Math.floor(Math.random() * 2147483647),
    steps: a.steps ?? 20,
    cfg: a.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: a.denoise ?? 1
  }, "KSampler"), r;
}
function Yi(s, e, n) {
  const i = ot();
  return s[i] = tt("VHS_VideoCombine", {
    images: e,
    frame_rate: n.fps,
    loop_count: 0,
    filename_prefix: n.filename || "weyl_output",
    format: n.format || "video/h264-mp4",
    pingpong: !1,
    save_output: !0,
    audio: null,
    meta_batch: null
  }, "Video Output"), i;
}
function p9(s) {
  Ps();
  const e = {}, n = s.width > 640 || s.height > 640, i = s.wanModel || (n ? "i2v_720p" : "i2v_480p"), o = ot();
  e[o] = tt("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${i}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const a = ot();
  e[a] = tt("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const r = ot();
  e[r] = tt("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const l = s0(e, s.referenceImage || "input.png", "Reference Image"), c = o0(e, Ie(l), s.width, s.height), u = ot();
  e[u] = tt("WanTextEncode", {
    text_encoder: Ie(r),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = ot();
  e[d] = tt("WanImageToVideo", {
    wan_model: Ie(o),
    positive: Ie(u),
    image: Ie(c),
    vae: Ie(a),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: s.denoise || 1
  }, "I2V Generation");
  const h = ot();
  return e[h] = tt("WanVAEDecode", {
    vae: Ie(a),
    samples: Ie(d),
    enable_vae_tiling: !0,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode"), Yi(e, Ie(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_i2v"
  }), e;
}
function f$(s) {
  Ps();
  const e = {}, n = ot();
  e[n] = tt("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const i = ot();
  e[i] = tt("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const o = ot();
  e[o] = tt("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const a = s0(e, s.referenceImage || "input.png", "Reference Image"), r = o0(e, Ie(a), s.width, s.height), l = ot();
  e[l] = tt("WanTextEncode", {
    text_encoder: Ie(o),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const c = ot();
  e[c] = tt("WanFunCameraMotion", {
    motion_type: s.cameraMotion || "Static",
    length: s.frameCount
  }, "Camera Motion");
  const u = ot();
  e[u] = tt("WanFunCameraI2V", {
    wan_model: Ie(n),
    positive: Ie(l),
    image: Ie(r),
    camera_motion: Ie(c),
    vae: Ie(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const d = ot();
  return e[d] = tt("WanVAEDecode", {
    vae: Ie(i),
    samples: Ie(u),
    enable_vae_tiling: !0
  }, "VAE Decode"), Yi(e, Ie(d), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_fun_camera"
  }), e;
}
function p$(s) {
  Ps();
  const e = {}, n = ot();
  e[n] = tt("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const i = ot();
  e[i] = tt("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const o = ot();
  e[o] = tt("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const a = s0(e, s.referenceImage || "first.png", "First Frame"), r = s0(e, s.lastFrameImage || "last.png", "Last Frame"), l = o0(e, Ie(a), s.width, s.height), c = o0(e, Ie(r), s.width, s.height), u = ot();
  e[u] = tt("WanTextEncode", {
    text_encoder: Ie(o),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = ot();
  e[d] = tt("WanFirstLastFrameToVideo", {
    wan_model: Ie(n),
    positive: Ie(u),
    first_frame: Ie(l),
    last_frame: Ie(c),
    vae: Ie(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const h = ot();
  return e[h] = tt("WanVAEDecode", {
    vae: Ie(i),
    samples: Ie(d),
    enable_vae_tiling: !0
  }, "VAE Decode"), Yi(e, Ie(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_flf"
  }), e;
}
function m$(s) {
  var h;
  Ps();
  const e = {}, n = ot();
  e[n] = tt("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const i = ot();
  e[i] = tt("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const o = s0(e, s.referenceImage || "input.png", "Reference Image"), a = o0(e, Ie(o), s.width, s.height), r = ot();
  s.trajType === "custom" && ((h = s.cameraData) != null && h.trajectory) ? e[r] = tt("Uni3CCustomTrajectory", {
    trajectory_data: JSON.stringify(s.cameraData.trajectory),
    length: s.frameCount
  }, "Custom Trajectory") : e[r] = tt("Uni3CPresetTrajectory", {
    traj_type: s.trajType || "orbit",
    length: s.frameCount
  }, "Preset Trajectory");
  const l = ot();
  e[l] = tt("ApplyUni3CCameraControl", {
    model: Ie(i),
    uni3c: Ie(n),
    trajectory: Ie(r),
    image: Ie(a),
    control_strength: 1
  }, "Apply Camera Control");
  const c = ot();
  e[c] = tt("SVDEncode", {
    model: Ie(l),
    image: Ie(a),
    vae: Ie(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = Pa(
    e,
    Ie(l),
    Ie(c, 1),
    Ie(c, 2),
    Ie(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5, denoise: 1 }
  ), d = Aa(e, Ie(u), Ie(i, 2));
  return Yi(e, Ie(d), {
    fps: s.fps,
    filename: s.outputFilename || "uni3c_output"
  }), e;
}
function v$(s) {
  Ps();
  const e = {}, n = ot();
  e[n] = tt("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const i = ot();
  e[i] = tt("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const o = s0(e, s.referenceImage || "input.png", "Reference Image"), a = o0(e, Ie(o), s.width, s.height), r = ot();
  s.cameraPoses ? e[r] = tt("MotionCtrlCameraPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[r] = tt("MotionCtrlPresetPoses", {
    preset: s.motionPreset || "static",
    length: s.frameCount
  }, "Preset Poses");
  const l = ot();
  e[l] = tt("ApplyMotionCtrl", {
    model: Ie(i),
    motion_ctrl: Ie(n),
    camera_poses: Ie(r),
    control_strength: 1
  }, "Apply MotionCtrl");
  const c = ot();
  e[c] = tt("SVDEncode", {
    model: Ie(l),
    image: Ie(a),
    vae: Ie(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = Pa(
    e,
    Ie(l),
    Ie(c, 1),
    Ie(c, 2),
    Ie(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5 }
  ), d = Aa(e, Ie(u), Ie(i, 2));
  return Yi(e, Ie(d), {
    fps: s.fps,
    filename: s.outputFilename || "motionctrl_output"
  }), e;
}
function g$(s) {
  Ps();
  const e = {}, n = Zh(e, s.checkpoint || "sd_xl_base_1.0.safetensors"), i = ot();
  e[i] = tt("ControlNetLoader", {
    control_net_name: s.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const o = ot();
  e[o] = tt("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const a = s0(e, s.referenceImage || "reference.png", "Reference Image"), r = o0(e, Ie(a), s.width, s.height), l = wa(e, Ie(n, 1), s.prompt, "Positive"), c = wa(e, Ie(n, 1), s.negativePrompt, "Negative"), u = ot();
  e[u] = tt("ControlNetApply", {
    conditioning: Ie(l),
    control_net: Ie(i),
    image: Ie(o),
    strength: 1
  }, "Apply ControlNet");
  const d = h$(e, Ie(r), Ie(n, 2)), h = Pa(
    e,
    Ie(n),
    Ie(u),
    Ie(c),
    Ie(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7, denoise: s.denoise || 0.75 }
  ), p = Aa(e, Ie(h), Ie(n, 2));
  return Yi(e, Ie(p), {
    fps: s.fps,
    filename: s.outputFilename || "controlnet_depth"
  }), e;
}
function y$(s) {
  Ps();
  const e = {}, n = Zh(e, s.checkpoint || "dreamshaper_8.safetensors"), i = ot();
  e[i] = tt("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const o = ot();
  e[o] = tt("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const a = ot();
  s.cameraPoses ? e[a] = tt("ADE_CameraCtrlPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[a] = tt("ADE_CameraCtrlPreset", {
    motion_type: s.cameraMotion || "Static",
    speed: 1,
    frame_length: s.frameCount
  }, "Camera Preset");
  const r = ot();
  e[r] = tt("ADE_ApplyAnimateDiffModel", {
    model: Ie(n),
    motion_model: Ie(i)
  }, "Apply AnimateDiff");
  const l = ot();
  e[l] = tt("ADE_ApplyCameraCtrl", {
    model: Ie(r),
    cameractrl: Ie(o),
    poses: Ie(a)
  }, "Apply CameraCtrl");
  const c = wa(e, Ie(n, 1), s.prompt, "Positive"), u = wa(e, Ie(n, 1), s.negativePrompt, "Negative"), d = ot();
  e[d] = tt("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = Pa(
    e,
    Ie(l),
    Ie(c),
    Ie(u),
    Ie(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), p = Aa(e, Ie(h), Ie(n, 2));
  return Yi(e, Ie(p), {
    fps: s.fps,
    filename: s.outputFilename || "animatediff_cameractrl"
  }), e;
}
function x$(s) {
  Ps();
  const e = {}, n = ot();
  e[n] = tt("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const i = ot();
  e[i] = tt("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const o = ot();
  e[o] = tt("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const a = s0(e, s.referenceImage || "input.png", "Reference Image"), r = o0(e, Ie(a), s.width, s.height), l = ot();
  e[l] = tt("CogVideoTextEncode", {
    text_encoder: Ie(i),
    prompt: s.prompt,
    force_offload: !0
  }, "Encode Prompt");
  const c = ot();
  e[c] = tt("CogVideoImageToVideo", {
    model: Ie(n),
    positive: Ie(l),
    image: Ie(r),
    vae: Ie(o),
    width: s.width,
    height: s.height,
    num_frames: s.frameCount,
    steps: s.steps || 50,
    cfg: s.cfgScale || 6,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const u = ot();
  return e[u] = tt("CogVideoDecode", {
    vae: Ie(o),
    samples: Ie(c),
    enable_vae_tiling: !0
  }, "Decode Video"), Yi(e, Ie(u), {
    fps: s.fps,
    filename: s.outputFilename || "cogvideox_output"
  }), e;
}
function b$(s) {
  Ps();
  const e = {}, n = s.ttmModel || "wan", i = s.ttmLayers || [], o = s0(e, s.referenceImage || "reference.png", "Reference Image"), a = o0(e, Ie(o), s.width, s.height), r = ot();
  e[r] = tt("LoadImage", {
    image: s.ttmCombinedMask || "combined_motion_mask.png"
  }, "Combined Motion Mask");
  const l = [], c = [];
  for (let d = 0; d < i.length; d++) {
    const h = i[d], p = ot();
    e[p] = tt("LoadImage", {
      image: h.motionMask
    }, `Layer ${d + 1} Mask: ${h.layerName}`), l.push(p);
    const f = ot();
    e[f] = tt("TTM_TrajectoryFromPoints", {
      points: JSON.stringify(h.trajectory.map((m) => [m.x, m.y])),
      frames: JSON.stringify(h.trajectory.map((m) => m.frame)),
      total_frames: s.frameCount,
      interpolation: "linear"
    }, `Trajectory: ${h.layerName}`), c.push(f);
  }
  let u = null;
  if (i.length > 0 && (u = ot(), e[u] = tt("TTM_CombineLayers", {
    masks: l.map((d) => Ie(d)),
    trajectories: c.map((d) => Ie(d)),
    blend_mode: "additive"
  }, "Combine Layer Data")), n === "wan") {
    const d = ot();
    e[d] = tt("DownloadAndLoadWan2_1Model", {
      model: "wan2.1_i2v_480p_bf16.safetensors",
      base_precision: "bf16",
      quantization: "disabled"
    }, "Load Wan Model");
    const h = ot();
    e[h] = tt("DownloadAndLoadWanVAE", {
      vae: "wan_2.1_vae.safetensors",
      precision: "bf16"
    }, "Load Wan VAE");
    const p = ot();
    e[p] = tt("DownloadAndLoadWanTextEncoder", {
      text_encoder: "umt5-xxl-enc-bf16.safetensors",
      precision: "bf16"
    }, "Load Text Encoder");
    const f = ot();
    e[f] = tt("WanTextEncode", {
      text_encoder: Ie(p),
      prompt: s.prompt,
      force_offload: !0
    }, "Positive Prompt");
    const m = ot();
    e[m] = tt("TTM_ApplyMotionControl", {
      wan_model: Ie(d),
      image: Ie(a),
      motion_mask: Ie(r),
      layer_data: u ? Ie(u) : null,
      tweak_index: s.ttmTweakIndex ?? 0,
      tstrong_index: s.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const y = ot();
    e[y] = tt("WanImageToVideo", {
      wan_model: Ie(m),
      positive: Ie(f),
      image: Ie(a),
      vae: Ie(h),
      width: s.width,
      height: s.height,
      length: s.frameCount,
      steps: s.steps || 30,
      cfg: s.cfgScale || 5,
      seed: s.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "DPM++ 2M SDE",
      denoise_strength: s.denoise || 1
    }, "TTM I2V Generation");
    const g = ot();
    e[g] = tt("WanVAEDecode", {
      vae: Ie(h),
      samples: Ie(y),
      enable_vae_tiling: !0,
      tile_sample_min_height: 240,
      tile_sample_min_width: 240,
      tile_overlap_factor_height: 0.2,
      tile_overlap_factor_width: 0.2
    }, "VAE Decode"), Yi(e, Ie(g), {
      fps: s.fps,
      filename: s.outputFilename || "ttm_output"
    });
  } else if (n === "cogvideox") {
    const d = ot();
    e[d] = tt("DownloadAndLoadCogVideoModel", {
      model: "CogVideoX-5b-I2V",
      precision: "bf16"
    }, "Load CogVideoX");
    const h = ot();
    e[h] = tt("DownloadAndLoadCogVideoTextEncoder", {
      model: "t5-v1_1-xxl-encoder-bf16",
      precision: "bf16"
    }, "Load T5 Encoder");
    const p = ot();
    e[p] = tt("DownloadAndLoadCogVideoVAE", {
      model: "cogvideox_vae",
      precision: "bf16"
    }, "Load CogVideo VAE");
    const f = ot();
    e[f] = tt("CogVideoTextEncode", {
      text_encoder: Ie(h),
      prompt: s.prompt,
      force_offload: !0
    }, "Encode Prompt");
    const m = ot();
    e[m] = tt("TTM_ApplyMotionControlCogVideo", {
      model: Ie(d),
      image: Ie(a),
      motion_mask: Ie(r),
      layer_data: u ? Ie(u) : null,
      tweak_index: s.ttmTweakIndex ?? 0,
      tstrong_index: s.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const y = ot();
    e[y] = tt("CogVideoImageToVideo", {
      model: Ie(m),
      positive: Ie(f),
      image: Ie(a),
      vae: Ie(p),
      width: s.width,
      height: s.height,
      num_frames: s.frameCount,
      steps: s.steps || 50,
      cfg: s.cfgScale || 6,
      seed: s.seed ?? Math.floor(Math.random() * 2147483647),
      scheduler: "CogVideoX DDIM"
    }, "CogVideoX I2V");
    const g = ot();
    e[g] = tt("CogVideoDecode", {
      vae: Ie(p),
      samples: Ie(y),
      enable_vae_tiling: !0
    }, "Decode Video"), Yi(e, Ie(g), {
      fps: s.fps,
      filename: s.outputFilename || "ttm_cogvideo_output"
    });
  } else {
    const d = ot();
    e[d] = tt("ImageOnlyCheckpointLoader", {
      ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
    }, "Load SVD");
    const h = ot();
    e[h] = tt("TTM_ApplyMotionControlSVD", {
      model: Ie(d),
      image: Ie(a),
      motion_mask: Ie(r),
      layer_data: u ? Ie(u) : null,
      tweak_index: s.ttmTweakIndex ?? 0,
      tstrong_index: s.ttmTstrongIndex ?? 0
    }, "Apply TTM Motion");
    const p = ot();
    e[p] = tt("SVDEncode", {
      model: Ie(h),
      image: Ie(a),
      vae: Ie(d, 2),
      width: s.width,
      height: s.height,
      video_frames: s.frameCount,
      motion_bucket_id: 127,
      fps: s.fps,
      augmentation_level: 0
    }, "SVD Encode");
    const f = Pa(
      e,
      Ie(h),
      Ie(p, 1),
      Ie(p, 2),
      Ie(p),
      { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5, denoise: 1 }
    ), m = Aa(e, Ie(f), Ie(d, 2));
    Yi(e, Ie(m), {
      fps: s.fps,
      filename: s.outputFilename || "ttm_svd_output"
    });
  }
  return e;
}
function m9(s, e) {
  Ps();
  const n = {}, i = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  }, o = Zh(n, s.checkpoint || "v1-5-pruned-emaonly.safetensors"), a = ot();
  n[a] = tt("ControlNetLoader", {
    control_net_name: s.controlnetModel || i[e]
  }, `Load ControlNet ${e}`);
  const r = ot();
  n[r] = tt("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const l = wa(n, Ie(o, 1), s.prompt, "Positive"), c = wa(n, Ie(o, 1), s.negativePrompt, "Negative"), u = ot();
  n[u] = tt("ControlNetApply", {
    conditioning: Ie(l),
    control_net: Ie(a),
    image: Ie(r),
    strength: 1
  }, "Apply ControlNet");
  const d = ot();
  n[d] = tt("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = Pa(
    n,
    Ie(o),
    Ie(u),
    Ie(c),
    Ie(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), p = Aa(n, Ie(h), Ie(o, 2));
  return Yi(n, Ie(p), {
    fps: s.fps,
    filename: s.outputFilename || `controlnet_${e}`
  }), n;
}
function _$(s, e) {
  switch (s) {
    case "wan22-i2v":
      return p9(e);
    case "wan22-t2v":
      return p9({ ...e, referenceImage: void 0 });
    case "wan22-fun-camera":
      return f$(e);
    case "wan22-first-last":
      return p$(e);
    case "uni3c-camera":
    case "uni3c-motion":
      return m$(e);
    case "motionctrl":
    case "motionctrl-svd":
      return v$(e);
    case "cogvideox":
      return x$(e);
    case "controlnet-depth":
      return g$(e);
    case "controlnet-canny":
      return m9(e, "canny");
    case "controlnet-lineart":
      return m9(e, "lineart");
    case "animatediff-cameractrl":
      return y$(e);
    case "ttm":
    case "ttm-wan":
    case "ttm-cogvideox":
    case "ttm-svd":
      return b$(e);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${s}`);
  }
}
function w$(s) {
  const e = [], n = [], i = Object.keys(s);
  for (const [a, r] of Object.entries(s)) {
    r.class_type || e.push(`Node ${a}: missing class_type`);
    for (const [l, c] of Object.entries(r.inputs))
      if (Array.isArray(c) && c.length === 2) {
        const [u] = c;
        typeof u == "string" && !i.includes(u) && e.push(`Node ${a}.${l}: references non-existent node ${u}`);
      }
  }
  return Object.values(s).some(
    (a) => a.class_type.includes("Save") || a.class_type.includes("Output") || a.class_type.includes("Preview")
  ) || n.push("Workflow has no output/save nodes"), {
    valid: e.length === 0,
    errors: e,
    warnings: n
  };
}
class M$ {
  constructor(e) {
    le(this, "layers");
    le(this, "cameraKeyframes");
    le(this, "config");
    le(this, "onProgress");
    le(this, "abortSignal");
    le(this, "aborted", !1);
    this.layers = e.layers, this.cameraKeyframes = e.cameraKeyframes, this.config = e.config, this.onProgress = e.onProgress || (() => {
    }), this.abortSignal = e.abortSignal, this.abortSignal && this.abortSignal.addEventListener("abort", () => {
      this.aborted = !0;
    });
  }
  checkAborted() {
    if (this.aborted)
      throw new Error("Export aborted");
  }
  updateProgress(e) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...e
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const e = Date.now(), n = {
      success: !1,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const i = this.validateConfig();
      if (i.length > 0)
        return n.errors = i, n;
      this.config.exportReferenceFrame && (this.checkAborted(), await this.renderReferenceFrame(n)), this.config.exportLastFrame && (this.checkAborted(), await this.renderLastFrame(n)), this.config.exportDepthMap && (this.checkAborted(), await this.renderDepthSequence(n)), this.config.exportControlImages && (this.checkAborted(), await this.renderControlSequence(n)), this.config.exportCameraData && (this.checkAborted(), await this.exportCameraData(n)), this.checkAborted(), await this.generateWorkflow(n), this.config.autoQueueWorkflow && this.config.comfyuiServer && (this.checkAborted(), await this.queueWorkflow(n)), n.success = n.errors.length === 0;
    } catch (i) {
      i instanceof Error && i.message === "Export aborted" ? n.errors.push("Export was cancelled") : n.errors.push(i instanceof Error ? i.message : "Unknown error");
    }
    return n.duration = Date.now() - e, n;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const e = [];
    return (this.config.width < 64 || this.config.width > 4096) && e.push("Width must be between 64 and 4096"), (this.config.height < 64 || this.config.height > 4096) && e.push("Height must be between 64 and 4096"), (this.config.frameCount < 1 || this.config.frameCount > 1e3) && e.push("Frame count must be between 1 and 1000"), (this.config.fps < 1 || this.config.fps > 120) && e.push("FPS must be between 1 and 120"), (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) && e.push("Invalid start frame"), (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) && e.push("Invalid end frame"), !this.config.prompt && this.needsPrompt() && e.push("Prompt is required for this export target"), e;
  }
  needsPrompt() {
    return !["controlnet-depth", "controlnet-canny", "controlnet-lineart"].includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.startFrame);
    const o = await n.convertToBlob({ type: "image/png" }), a = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const l = await qo(this.config.comfyuiServer).uploadImage(o, a);
      e.outputFiles.referenceImage = l.name;
    } else
      e.outputFiles.referenceImage = await this.saveBlobLocally(o, a);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.endFrame - 1);
    const o = await n.convertToBlob({ type: "image/png" }), a = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const l = await qo(this.config.comfyuiServer).uploadImage(o, a);
      e.outputFiles.lastImage = l.name;
    } else
      e.outputFiles.lastImage = await this.saveBlobLocally(o, a);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(e, n) {
    e.clearRect(0, 0, e.canvas.width, e.canvas.height);
    const i = [...this.layers].filter((o) => o.visible).sort((o, a) => {
      var c, u, d, h, p, f;
      const r = ((d = (u = (c = o.transform) == null ? void 0 : c.position) == null ? void 0 : u.value) == null ? void 0 : d.z) ?? 0, l = ((f = (p = (h = a.transform) == null ? void 0 : h.position) == null ? void 0 : p.value) == null ? void 0 : f.z) ?? 0;
      return r - l;
    });
    for (const o of i)
      await this.renderLayerToCanvas(e, o, n);
  }
  async renderLayerToCanvas(e, n, i) {
    var u, d, h, p, f, m, y;
    const o = ((d = (u = n.transform) == null ? void 0 : u.position) == null ? void 0 : d.value) ?? { x: 0, y: 0 }, a = ((p = (h = n.transform) == null ? void 0 : h.scale) == null ? void 0 : p.value) ?? { x: 100, y: 100 }, r = ((m = (f = n.transform) == null ? void 0 : f.rotation) == null ? void 0 : m.value) ?? 0, l = typeof ((y = n.opacity) == null ? void 0 : y.value) == "number" ? n.opacity.value : 100;
    e.save(), e.globalAlpha = l / 100, e.translate(o.x, o.y), e.rotate(r * Math.PI / 180), e.scale(a.x / 100, a.y / 100);
    const c = n.data;
    if (n.type === "image" && (c != null && c.src)) {
      const g = await this.loadImage(c.src);
      e.drawImage(g, -g.width / 2, -g.height / 2);
    } else if (n.type === "solid" && (c != null && c.color)) {
      e.fillStyle = c.color || "#000000";
      const g = c.width ?? 100, x = c.height ?? 100;
      e.fillRect(-g / 2, -x / 2, g, x);
    }
    e.restore();
  }
  loadImage(e) {
    return new Promise((n, i) => {
      const o = new Image();
      o.onload = () => n(o), o.onerror = i, o.src = e;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let o = 0; o < n; o++) {
      this.checkAborted();
      const a = this.config.startFrame + o, r = o / n * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: r,
        overallProgress: 15 + r * 0.25,
        currentFrame: o + 1,
        totalFrames: n,
        message: `Rendering depth frame ${o + 1}/${n}`
      });
      const l = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: !1,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      }, c = i$({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: l,
        layers: this.layers,
        frame: a
      }), u = c$(
        c,
        this.config.depthFormat
      ), d = u$(
        u,
        this.config.width,
        this.config.height
      ), h = new OffscreenCanvas(this.config.width, this.config.height);
      h.getContext("2d").putImageData(d, 0, 0);
      const f = await h.convertToBlob({ type: "image/png" }), m = `${this.config.filenamePrefix}_depth_${String(o).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const g = await qo(this.config.comfyuiServer).uploadImage(f, m, "input", "depth_sequence");
        i.push(g.name);
      } else
        i.push(await this.saveBlobLocally(f, m));
    }
    e.outputFiles.depthSequence = i, this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let o = 0; o < n; o++) {
      this.checkAborted();
      const a = this.config.startFrame + o, r = o / n * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: r,
        overallProgress: 40 + r * 0.2,
        currentFrame: o + 1,
        totalFrames: n,
        message: `Rendering control frame ${o + 1}/${n}`
      });
      const l = new OffscreenCanvas(this.config.width, this.config.height), c = l.getContext("2d");
      await this.renderFrameToCanvas(c, a);
      const d = await (await this.applyControlPreprocessing(l, this.config.controlType || "depth")).convertToBlob({ type: "image/png" }), h = `${this.config.filenamePrefix}_control_${String(o).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const f = await qo(this.config.comfyuiServer).uploadImage(d, h, "input", "control_sequence");
        i.push(f.name);
      } else
        i.push(await this.saveBlobLocally(d, h));
    }
    e.outputFiles.controlSequence = i, this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(e, n) {
    const i = new OffscreenCanvas(e.width, e.height), o = i.getContext("2d"), r = e.getContext("2d").getImageData(0, 0, e.width, e.height), l = r.data;
    switch (n) {
      case "canny":
        this.applyEdgeDetection(l, e.width, e.height);
        break;
      case "lineart":
        this.applyLineart(l);
        break;
      case "softedge":
        this.applySoftEdge(l, e.width, e.height);
        break;
    }
    return o.putImageData(r, 0, 0), i;
  }
  applyEdgeDetection(e, n, i) {
    const o = new Float32Array(n * i);
    for (let r = 0; r < n * i; r++) {
      const l = r * 4;
      o[r] = (e[l] * 0.299 + e[l + 1] * 0.587 + e[l + 2] * 0.114) / 255;
    }
    const a = new Float32Array(n * i);
    for (let r = 1; r < i - 1; r++)
      for (let l = 1; l < n - 1; l++) {
        const c = r * n + l, u = -o[c - n - 1] + o[c - n + 1] + -2 * o[c - 1] + 2 * o[c + 1] + -o[c + n - 1] + o[c + n + 1], d = -o[c - n - 1] - 2 * o[c - n] - o[c - n + 1] + o[c + n - 1] + 2 * o[c + n] + o[c + n + 1];
        a[c] = Math.min(1, Math.sqrt(u * u + d * d) * 2);
      }
    for (let r = 0; r < n * i; r++) {
      const l = r * 4, c = Math.floor(a[r] * 255);
      e[l] = c, e[l + 1] = c, e[l + 2] = c;
    }
  }
  applyLineart(e) {
    for (let n = 0; n < e.length; n += 4) {
      const o = e[n] * 0.299 + e[n + 1] * 0.587 + e[n + 2] * 0.114 > 128 ? 255 : 0;
      e[n] = o, e[n + 1] = o, e[n + 2] = o;
    }
  }
  applySoftEdge(e, n, i) {
    this.applyEdgeDetection(e, n, i);
    const o = new Uint8ClampedArray(e), a = 2;
    for (let r = a; r < i - a; r++)
      for (let l = a; l < n - a; l++) {
        let c = 0, u = 0;
        for (let p = -a; p <= a; p++)
          for (let f = -a; f <= a; f++) {
            const m = ((r + p) * n + (l + f)) * 4;
            c += o[m], u++;
          }
        const d = (r * n + l) * 4, h = Math.floor(c / u);
        e[d] = h, e[d + 1] = h, e[d + 2] = h;
      }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(e) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const n = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: !1,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: !1
      }
    }, i = eM(
      this.config.target,
      n,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    ), o = `${this.config.filenamePrefix}_camera.json`, a = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    this.config.comfyuiServer ? e.outputFiles.cameraData = o : e.outputFiles.cameraData = await this.saveBlobLocally(a, o), this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(e) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const n = {
      referenceImage: e.outputFiles.referenceImage,
      lastFrameImage: e.outputFiles.lastImage,
      depthSequence: e.outputFiles.depthSequence,
      controlImages: e.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    e.outputFiles.cameraData && (n.cameraData = e.outputFiles.cameraData);
    const i = _$(this.config.target, n), o = w$(i);
    o.valid || e.errors.push(...o.errors), e.warnings.push(...o.warnings);
    const a = `${this.config.filenamePrefix}_workflow.json`, r = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    e.outputFiles.workflowJson = await this.saveBlobLocally(r, a), this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(e) {
    if (!this.config.comfyuiServer || !e.outputFiles.workflowJson)
      return;
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const n = qo(this.config.comfyuiServer);
    if (!await n.checkConnection()) {
      e.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const a = await (await fetch(e.outputFiles.workflowJson)).json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const r = await n.queuePrompt(a);
    if (e.outputFiles.promptId = r.prompt_id, r.node_errors && Object.keys(r.node_errors).length > 0) {
      e.errors.push("Workflow has node errors: " + JSON.stringify(r.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await n.waitForPrompt(r.prompt_id, (l) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: l.percentage,
          overallProgress: 80 + l.percentage * 0.15,
          message: `Generating: ${l.percentage.toFixed(0)}%`,
          preview: l.preview
        });
      }), this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (l) {
      e.errors.push(l instanceof Error ? l.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(e, n) {
    const i = URL.createObjectURL(e), o = document.createElement("a");
    return o.href = i, o.download = n, document.body.appendChild(o), o.click(), document.body.removeChild(o), i;
  }
}
async function S$(s, e, n, i) {
  return new M$({
    layers: s,
    cameraKeyframes: e,
    config: n,
    onProgress: i
  }).execute();
}
const C$ = { class: "export-dialog" }, T$ = { class: "dialog-tabs" }, E$ = { class: "dialog-content" }, A$ = {
  key: 0,
  class: "tab-content"
}, P$ = { class: "target-grid" }, k$ = { class: "target-buttons" }, D$ = ["onClick"], I$ = {
  key: 0,
  class: "target-info"
}, R$ = { class: "info-row" }, L$ = { class: "info-row" }, F$ = { class: "info-row" }, O$ = {
  key: 1,
  class: "tab-content"
}, U$ = { class: "settings-section" }, z$ = { class: "preset-buttons" }, B$ = ["onClick"], N$ = { class: "input-row" }, V$ = { class: "settings-section" }, H$ = { class: "preset-buttons" }, G$ = ["onClick"], $$ = { class: "input-row" }, W$ = { class: "input-row" }, j$ = { class: "settings-section" }, X$ = { class: "checkbox-grid" }, Y$ = {
  key: 0,
  class: "settings-section"
}, q$ = ["value"], Z$ = {
  key: 1,
  class: "settings-section"
}, K$ = ["value"], J$ = {
  key: 2,
  class: "tab-content"
}, Q$ = { class: "settings-section" }, eW = { class: "settings-section" }, tW = { class: "settings-section" }, nW = { class: "input-row" }, iW = { class: "input-row seed-row" }, sW = {
  key: 3,
  class: "tab-content"
}, oW = { class: "settings-section" }, aW = { class: "server-row" }, rW = { key: 0 }, lW = { key: 1 }, cW = { key: 2 }, uW = { key: 3 }, dW = { class: "settings-section" }, hW = { class: "checkbox-large" }, fW = {
  key: 0,
  class: "export-progress"
}, pW = { class: "progress-header" }, mW = { class: "progress-bar" }, vW = {
  key: 0,
  class: "progress-details"
}, gW = {
  key: 1,
  class: "export-error"
}, yW = { class: "dialog-footer" }, xW = ["disabled"], bW = /* @__PURE__ */ Bt({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = xe("target"), a = xe("wan22-i2v"), r = xe(832), l = xe(480), c = xe(81), u = xe(24), d = xe(0), h = xe(81), p = xe(!0), f = xe(!1), m = xe(!0), y = xe(!0), g = xe(!1), x = xe("midas"), w = xe("depth"), M = xe(""), _ = xe("blurry, low quality, distorted"), C = xe(void 0), T = xe(30), P = xe(5), E = xe("127.0.0.1:8188"), b = xe(!1), S = xe("disconnected"), A = xe(!1), R = xe(null), k = xe(null), U = xe(null), I = Re(() => f9[a.value]), W = Re(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      Uni3C: ["uni3c-camera", "uni3c-motion"],
      MotionCtrl: ["motionctrl", "motionctrl-svd"],
      Camera: ["animatediff-cameractrl", "camera-comfyui", "ati"],
      Advanced: ["light-x", "ttm", "cogvideox"],
      ControlNet: ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      Custom: ["custom-workflow"]
    })), fe = Re(() => ({
      "wan22-i2v": "Image to Video",
      "wan22-t2v": "Text to Video",
      "wan22-fun-camera": "Fun Camera",
      "wan22-first-last": "First + Last Frame",
      "wan-move": "Point Trajectories",
      "uni3c-camera": "Camera Control",
      "uni3c-motion": "Motion + Camera",
      motionctrl: "MotionCtrl",
      "motionctrl-svd": "MotionCtrl SVD",
      cogvideox: "CogVideoX I2V",
      "animatediff-cameractrl": "CameraCtrl",
      "camera-comfyui": "4x4 Matrices",
      ati: "Any Trajectory",
      "light-x": "Relighting",
      ttm: "Cut & Drag",
      "controlnet-depth": "Depth",
      "controlnet-canny": "Canny Edge",
      "controlnet-lineart": "Line Art",
      "custom-workflow": "Custom Workflow"
    })), q = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ], G = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function Q(he) {
      a.value = he;
      const ne = QG[he];
      ne && (r.value = ne.width ?? 832, l.value = ne.height ?? 480, c.value = ne.frameCount ?? 81, u.value = ne.fps ?? 24, h.value = c.value);
      const N = f9[he];
      N && (p.value = N.requiredInputs.includes("depth_sequence") || N.requiredInputs.includes("depth_map"), m.value = N.requiredInputs.includes("camera_data") || N.requiredInputs.includes("camera_trajectory") || N.requiredInputs.includes("camera_poses"), y.value = N.requiredInputs.includes("reference_image") || N.requiredInputs.includes("first_frame"), g.value = N.requiredInputs.includes("last_frame"), f.value = he.startsWith("controlnet-"));
    }
    async function K() {
      S.value = "connecting";
      try {
        const ne = await qo(E.value).checkConnection();
        S.value = ne ? "connected" : "error";
      } catch {
        S.value = "error";
      }
    }
    function Y(he) {
      r.value = he.width, l.value = he.height;
    }
    function ee(he) {
      c.value = he, h.value = Math.min(h.value, he);
    }
    function ce() {
      C.value = Math.floor(Math.random() * 2147483647);
    }
    async function ae() {
      A.value = !0, k.value = null, U.value = new AbortController();
      const he = {
        target: a.value,
        width: r.value,
        height: l.value,
        frameCount: c.value,
        fps: u.value,
        startFrame: d.value,
        endFrame: h.value,
        outputDir: "",
        filenamePrefix: `weyl_${a.value}_${Date.now()}`,
        exportDepthMap: p.value,
        exportControlImages: f.value,
        exportCameraData: m.value,
        exportReferenceFrame: y.value,
        exportLastFrame: g.value,
        depthFormat: x.value,
        controlType: w.value,
        prompt: M.value,
        negativePrompt: _.value,
        seed: C.value,
        steps: T.value,
        cfgScale: P.value,
        comfyuiServer: E.value,
        autoQueueWorkflow: b.value
      };
      try {
        const ne = await S$(
          n.layers,
          n.cameraKeyframes,
          he,
          (N) => {
            R.value = N;
          }
        );
        ne.success ? i("exported", ne) : k.value = ne.errors.join(`
`);
      } catch (ne) {
        k.value = ne instanceof Error ? ne.message : "Export failed";
      } finally {
        A.value = !1, U.value = null;
      }
    }
    function de() {
      U.value && U.value.abort();
    }
    function ie() {
      A.value && de(), i("close");
    }
    return gn(() => {
      h.value = Math.min(c.value, n.totalFrames), K();
    }), Ft(a, () => {
      Q(a.value);
    }), (he, ne) => {
      var N, te, F;
      return se(), re("div", {
        class: "export-dialog-overlay",
        onClick: _t(ie, ["self"])
      }, [
        v("div", C$, [
          v("header", { class: "dialog-header" }, [
            ne[24] || (ne[24] = v("h2", null, "Export to ComfyUI", -1)),
            v("button", {
              class: "close-btn",
              onClick: ie
            }, "")
          ]),
          v("nav", T$, [
            v("button", {
              class: Le({ active: o.value === "target" }),
              onClick: ne[0] || (ne[0] = (B) => o.value = "target")
            }, " Target ", 2),
            v("button", {
              class: Le({ active: o.value === "output" }),
              onClick: ne[1] || (ne[1] = (B) => o.value = "output")
            }, " Output ", 2),
            v("button", {
              class: Le({ active: o.value === "generation" }),
              onClick: ne[2] || (ne[2] = (B) => o.value = "generation")
            }, " Generation ", 2),
            v("button", {
              class: Le({ active: o.value === "comfyui" }),
              onClick: ne[3] || (ne[3] = (B) => o.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          v("div", E$, [
            o.value === "target" ? (se(), re("div", A$, [
              v("div", P$, [
                (se(!0), re(Xe, null, at(W.value, (B, L) => (se(), re("div", {
                  key: L,
                  class: "target-category"
                }, [
                  v("h3", null, ye(L), 1),
                  v("div", k$, [
                    (se(!0), re(Xe, null, at(B, (D) => (se(), re("button", {
                      key: D,
                      class: Le({ selected: a.value === D }),
                      onClick: (j) => Q(D)
                    }, ye(fe.value[D]), 11, D$))), 128))
                  ])
                ]))), 128))
              ]),
              I.value ? (se(), re("div", I$, [
                v("h4", null, ye(fe.value[a.value]), 1),
                v("div", R$, [
                  ne[25] || (ne[25] = v("span", { class: "label" }, "Required:", -1)),
                  v("span", null, ye(I.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                v("div", L$, [
                  ne[26] || (ne[26] = v("span", { class: "label" }, "Optional:", -1)),
                  v("span", null, ye(I.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                v("div", F$, [
                  ne[27] || (ne[27] = v("span", { class: "label" }, "Outputs:", -1)),
                  v("span", null, ye(I.value.outputTypes.join(", ")), 1)
                ])
              ])) : Te("", !0)
            ])) : Te("", !0),
            o.value === "output" ? (se(), re("div", O$, [
              v("div", U$, [
                ne[28] || (ne[28] = v("h3", null, "Resolution", -1)),
                v("div", z$, [
                  (se(!0), re(Xe, null, at(He(t$), (B) => (se(), re("button", {
                    key: B.name,
                    onClick: (L) => Y(B)
                  }, ye(B.name), 9, B$))), 128))
                ]),
                v("div", N$, [
                  Ne(it, {
                    modelValue: r.value,
                    "onUpdate:modelValue": ne[4] || (ne[4] = (B) => r.value = B),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  Ne(it, {
                    modelValue: l.value,
                    "onUpdate:modelValue": ne[5] || (ne[5] = (B) => l.value = B),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              v("div", V$, [
                ne[29] || (ne[29] = v("h3", null, "Frames", -1)),
                v("div", H$, [
                  (se(!0), re(Xe, null, at(He(n$), (B) => (se(), re("button", {
                    key: B.name,
                    onClick: (L) => ee(B.frameCount)
                  }, ye(B.name), 9, G$))), 128))
                ]),
                v("div", $$, [
                  Ne(it, {
                    modelValue: c.value,
                    "onUpdate:modelValue": ne[6] || (ne[6] = (B) => c.value = B),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  Ne(it, {
                    modelValue: u.value,
                    "onUpdate:modelValue": ne[7] || (ne[7] = (B) => u.value = B),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                v("div", W$, [
                  Ne(it, {
                    modelValue: d.value,
                    "onUpdate:modelValue": ne[8] || (ne[8] = (B) => d.value = B),
                    label: "Start",
                    min: 0,
                    max: h.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  Ne(it, {
                    modelValue: h.value,
                    "onUpdate:modelValue": ne[9] || (ne[9] = (B) => h.value = B),
                    label: "End",
                    min: d.value + 1,
                    max: c.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              v("div", j$, [
                ne[35] || (ne[35] = v("h3", null, "Export Options", -1)),
                v("div", X$, [
                  v("label", null, [
                    st(v("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ne[10] || (ne[10] = (B) => y.value = B)
                    }, null, 512), [
                      [Ci, y.value]
                    ]),
                    ne[30] || (ne[30] = ct(" Reference Frame ", -1))
                  ]),
                  v("label", null, [
                    st(v("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ne[11] || (ne[11] = (B) => g.value = B)
                    }, null, 512), [
                      [Ci, g.value]
                    ]),
                    ne[31] || (ne[31] = ct(" Last Frame ", -1))
                  ]),
                  v("label", null, [
                    st(v("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ne[12] || (ne[12] = (B) => p.value = B)
                    }, null, 512), [
                      [Ci, p.value]
                    ]),
                    ne[32] || (ne[32] = ct(" Depth Maps ", -1))
                  ]),
                  v("label", null, [
                    st(v("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ne[13] || (ne[13] = (B) => f.value = B)
                    }, null, 512), [
                      [Ci, f.value]
                    ]),
                    ne[33] || (ne[33] = ct(" Control Images ", -1))
                  ]),
                  v("label", null, [
                    st(v("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": ne[14] || (ne[14] = (B) => m.value = B)
                    }, null, 512), [
                      [Ci, m.value]
                    ]),
                    ne[34] || (ne[34] = ct(" Camera Data ", -1))
                  ])
                ])
              ]),
              p.value ? (se(), re("div", Y$, [
                ne[36] || (ne[36] = v("h3", null, "Depth Format", -1)),
                st(v("select", {
                  "onUpdate:modelValue": ne[15] || (ne[15] = (B) => x.value = B)
                }, [
                  (se(), re(Xe, null, at(q, (B) => v("option", {
                    key: B.value,
                    value: B.value
                  }, ye(B.label), 9, q$)), 64))
                ], 512), [
                  [En, x.value]
                ])
              ])) : Te("", !0),
              f.value ? (se(), re("div", Z$, [
                ne[37] || (ne[37] = v("h3", null, "Control Type", -1)),
                st(v("select", {
                  "onUpdate:modelValue": ne[16] || (ne[16] = (B) => w.value = B)
                }, [
                  (se(), re(Xe, null, at(G, (B) => v("option", {
                    key: B.value,
                    value: B.value
                  }, ye(B.label), 9, K$)), 64))
                ], 512), [
                  [En, w.value]
                ])
              ])) : Te("", !0)
            ])) : Te("", !0),
            o.value === "generation" ? (se(), re("div", J$, [
              v("div", Q$, [
                ne[38] || (ne[38] = v("h3", null, "Prompt", -1)),
                st(v("textarea", {
                  "onUpdate:modelValue": ne[17] || (ne[17] = (B) => M.value = B),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [Ot, M.value]
                ])
              ]),
              v("div", eW, [
                ne[39] || (ne[39] = v("h3", null, "Negative Prompt", -1)),
                st(v("textarea", {
                  "onUpdate:modelValue": ne[18] || (ne[18] = (B) => _.value = B),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [Ot, _.value]
                ])
              ]),
              v("div", tW, [
                ne[40] || (ne[40] = v("h3", null, "Parameters", -1)),
                v("div", nW, [
                  Ne(it, {
                    modelValue: T.value,
                    "onUpdate:modelValue": ne[19] || (ne[19] = (B) => T.value = B),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  Ne(it, {
                    modelValue: P.value,
                    "onUpdate:modelValue": ne[20] || (ne[20] = (B) => P.value = B),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                v("div", iW, [
                  Ne(it, {
                    modelValue: C.value ?? 0,
                    "onUpdate:modelValue": ne[21] || (ne[21] = (B) => C.value = B),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  v("button", {
                    class: "randomize-btn",
                    onClick: ce
                  }, "Random")
                ])
              ])
            ])) : Te("", !0),
            o.value === "comfyui" ? (se(), re("div", sW, [
              v("div", oW, [
                ne[41] || (ne[41] = v("h3", null, "Server", -1)),
                v("div", aW, [
                  st(v("input", {
                    type: "text",
                    "onUpdate:modelValue": ne[22] || (ne[22] = (B) => E.value = B),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [Ot, E.value]
                  ]),
                  v("button", { onClick: K }, ye(S.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                v("div", {
                  class: Le(["connection-status", S.value])
                }, [
                  S.value === "connected" ? (se(), re("span", rW, "Connected")) : S.value === "error" ? (se(), re("span", lW, "Connection failed")) : S.value === "connecting" ? (se(), re("span", cW, "Connecting...")) : (se(), re("span", uW, "Not connected"))
                ], 2)
              ]),
              v("div", dW, [
                ne[43] || (ne[43] = v("h3", null, "Workflow", -1)),
                v("label", hW, [
                  st(v("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": ne[23] || (ne[23] = (B) => b.value = B)
                  }, null, 512), [
                    [Ci, b.value]
                  ]),
                  ne[42] || (ne[42] = v("span", null, [
                    v("strong", null, "Auto-queue workflow"),
                    v("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : Te("", !0)
          ]),
          A.value ? (se(), re("div", fW, [
            v("div", pW, [
              v("span", null, ye(((N = R.value) == null ? void 0 : N.message) || "Exporting..."), 1),
              v("button", { onClick: de }, "Cancel")
            ]),
            v("div", mW, [
              v("div", {
                class: "progress-fill",
                style: xt({ width: `${((te = R.value) == null ? void 0 : te.overallProgress) || 0}%` })
              }, null, 4)
            ]),
            (F = R.value) != null && F.currentFrame ? (se(), re("div", vW, " Frame " + ye(R.value.currentFrame) + " / " + ye(R.value.totalFrames), 1)) : Te("", !0)
          ])) : Te("", !0),
          k.value ? (se(), re("div", gW, ye(k.value), 1)) : Te("", !0),
          v("footer", yW, [
            v("button", {
              class: "secondary",
              onClick: ie
            }, "Cancel"),
            v("button", {
              class: "primary",
              disabled: A.value,
              onClick: ae
            }, ye(A.value ? "Exporting..." : "Export"), 9, xW)
          ])
        ])
      ]);
    };
  }
}), _W = /* @__PURE__ */ Vt(bW, [["__scopeId", "data-v-784836ff"]]), wW = { class: "dialog-container" }, MW = { class: "dialog-content" }, SW = { class: "form-row" }, CW = { class: "tabs" }, TW = {
  key: 0,
  class: "tab-content"
}, EW = { class: "form-row" }, AW = { class: "form-row dimensions-row" }, PW = { class: "dimension-group" }, kW = { class: "dimension-group" }, DW = { class: "form-row" }, IW = { class: "aspect-info" }, RW = { class: "form-row" }, LW = { class: "form-row" }, FW = { class: "resolution-info" }, OW = { class: "form-row" }, UW = { class: "duration-inputs" }, zW = { class: "duration-helper" }, BW = { class: "form-row" }, NW = { class: "color-picker-row" }, VW = { class: "color-label" }, HW = {
  key: 1,
  class: "tab-content"
}, GW = { class: "form-row" }, $W = { class: "form-row" }, WW = { class: "form-row" }, jW = { class: "motion-blur-settings" }, XW = {
  key: 0,
  class: "motion-blur-params"
}, YW = { class: "param-row" }, qW = { class: "param-row" }, ZW = { class: "dialog-footer" }, KW = { class: "preview-toggle" }, JW = /* @__PURE__ */ Bt({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = un(), a = xe("basic"), r = xe("custom"), l = xe(!1), c = xe(16 / 9), u = xe(!1), d = xe({
      name: "Main Comp",
      width: 1920,
      height: 1080,
      pixelAspectRatio: 1,
      fps: 30,
      frameCount: 300,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: !0,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: !1,
      shutterAngle: 180,
      shutterPhase: -90
    }), h = Re(() => {
      const b = d.value.width / d.value.height * d.value.pixelAspectRatio;
      return Math.abs(b - 16 / 9) < 0.01 ? "16:9 (1.78)" : Math.abs(b - 4 / 3) < 0.01 ? "4:3 (1.33)" : Math.abs(b - 1) < 0.01 ? "1:1 (1.0)" : Math.abs(b - 9 / 16) < 0.01 ? "9:16 (0.56)" : Math.abs(b - 21 / 9) < 0.01 ? "21:9 (2.33)" : `${b.toFixed(2)}`;
    }), p = Re(() => d.value.frameCount / d.value.fps), f = xe("00:00:10:00"), m = Re(() => {
      const S = { full: 1, half: 2, third: 3, quarter: 4 }[d.value.resolution], A = Math.floor(d.value.width / S), R = Math.floor(d.value.height / S), k = (A * R * 4 / (1024 * 1024)).toFixed(1);
      return `${A} x ${R}, ${k} MB per 8bpc frame`;
    }), y = {
      "1080p30": { width: 1920, height: 1080, fps: 30 },
      "1080p60": { width: 1920, height: 1080, fps: 60 },
      "720p30": { width: 1280, height: 720, fps: 30 },
      "4k30": { width: 3840, height: 2160, fps: 30 },
      instagram_square: { width: 1080, height: 1080, fps: 30 },
      instagram_story: { width: 1080, height: 1920, fps: 30 },
      tiktok: { width: 1080, height: 1920, fps: 30 },
      youtube_short: { width: 1080, height: 1920, fps: 60 },
      sd15_512: { width: 512, height: 512, fps: 8 },
      sd15_768: { width: 768, height: 512, fps: 8 },
      sdxl_1024: { width: 1024, height: 1024, fps: 8 },
      wan_480p: { width: 832, height: 480, fps: 16 },
      wan_720p: { width: 1280, height: 720, fps: 16 }
    };
    function g() {
      const b = y[r.value];
      b && (b.width && (d.value.width = b.width), b.height && (d.value.height = b.height), b.fps && (d.value.fps = b.fps), c.value = d.value.width / d.value.height, M());
    }
    function x(b) {
      d.value.width = Math.round(d.value.width / 8) * 8, d.value.height = Math.round(d.value.height / 8) * 8, l.value ? b === "width" ? d.value.height = Math.round(d.value.width / c.value / 8) * 8 : d.value.width = Math.round(d.value.height * c.value / 8) * 8 : c.value = d.value.width / d.value.height, r.value = "custom";
    }
    function w() {
      const b = f.value.split(":").map((S) => parseInt(S) || 0);
      if (b.length === 4) {
        const [S, A, R, k] = b, U = S * 3600 + A * 60 + R;
        d.value.frameCount = Math.round(U * d.value.fps) + k;
      } else b.length === 1 && (d.value.frameCount = b[0]);
    }
    function M() {
      const b = d.value.frameCount, S = d.value.fps, A = Math.floor(b / S), R = b % Math.round(S), k = Math.floor(A / 3600), U = Math.floor(A % 3600 / 60), I = A % 60;
      f.value = `${_(k)}:${_(U)}:${_(I)}:${_(R)}`;
    }
    function _(b) {
      return b.toString().padStart(2, "0");
    }
    function C() {
      var b, S, A, R, k, U;
      d.value = {
        name: ((S = (b = o.project) == null ? void 0 : b.meta) == null ? void 0 : S.name) || "Main Comp",
        width: o.width,
        height: o.height,
        pixelAspectRatio: 1,
        fps: o.fps,
        frameCount: o.frameCount,
        resolution: "full",
        backgroundColor: ((R = (A = o.project) == null ? void 0 : A.composition) == null ? void 0 : R.backgroundColor) || "#000000",
        autoResizeToContent: ((U = (k = o.project) == null ? void 0 : k.composition) == null ? void 0 : U.autoResizeToContent) ?? !0,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: !1,
        shutterAngle: 180,
        shutterPhase: -90
      }, c.value = d.value.width / d.value.height, M();
    }
    function T() {
      i("close");
    }
    function P() {
      i("confirm", { ...d.value }), i("close");
    }
    function E(b) {
      b.key === "Escape" ? T() : b.key === "Enter" && !b.shiftKey && P();
    }
    return Ft(() => n.visible, (b) => {
      b && C();
    }), Ft(d, () => {
      u.value && n.visible && o.resizeComposition(d.value.width, d.value.height, d.value.frameCount);
    }, { deep: !0 }), gn(() => {
      window.addEventListener("keydown", E);
    }), Un(() => {
      window.removeEventListener("keydown", E);
    }), (b, S) => (se(), Tt(R0, { to: "body" }, [
      s.visible ? (se(), re("div", {
        key: 0,
        class: "dialog-overlay",
        onClick: _t(T, ["self"])
      }, [
        v("div", wW, [
          v("div", { class: "dialog-header" }, [
            S[20] || (S[20] = v("span", { class: "dialog-title" }, "Composition Settings", -1)),
            v("button", {
              class: "close-btn",
              onClick: T
            }, "")
          ]),
          v("div", MW, [
            v("div", SW, [
              S[21] || (S[21] = v("label", null, "Composition Name:", -1)),
              st(v("input", {
                type: "text",
                "onUpdate:modelValue": S[0] || (S[0] = (A) => d.value.name = A),
                class: "text-input full-width"
              }, null, 512), [
                [Ot, d.value.name]
              ])
            ]),
            v("div", CW, [
              v("button", {
                class: Le({ active: a.value === "basic" }),
                onClick: S[1] || (S[1] = (A) => a.value = "basic")
              }, "Basic", 2),
              v("button", {
                class: Le({ active: a.value === "advanced" }),
                onClick: S[2] || (S[2] = (A) => a.value = "advanced")
              }, "Advanced", 2)
            ]),
            a.value === "basic" ? (se(), re("div", TW, [
              v("div", EW, [
                S[23] || (S[23] = v("label", null, "Preset:", -1)),
                st(v("select", {
                  "onUpdate:modelValue": S[3] || (S[3] = (A) => r.value = A),
                  onChange: g,
                  class: "select-input"
                }, [...S[22] || (S[22] = [
                  v("option", { value: "custom" }, "Custom", -1),
                  v("optgroup", { label: "Video" }, [
                    v("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                    v("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                    v("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                    v("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                  ], -1),
                  v("optgroup", { label: "Social Media" }, [
                    v("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                    v("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                    v("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                    v("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                  ], -1),
                  v("optgroup", { label: "AI Video (ComfyUI)" }, [
                    v("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                    v("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                    v("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                    v("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                    v("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)")
                  ], -1)
                ])], 544), [
                  [En, r.value]
                ])
              ]),
              v("div", AW, [
                v("div", PW, [
                  S[24] || (S[24] = v("label", null, "Width:", -1)),
                  st(v("input", {
                    type: "number",
                    "onUpdate:modelValue": S[4] || (S[4] = (A) => d.value.width = A),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: S[5] || (S[5] = (A) => x("width"))
                  }, null, 544), [
                    [
                      Ot,
                      d.value.width,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  S[25] || (S[25] = v("span", { class: "unit" }, "px", -1))
                ]),
                v("button", {
                  class: Le(["lock-btn", { locked: l.value }]),
                  onClick: S[6] || (S[6] = (A) => l.value = !l.value),
                  title: "Lock Aspect Ratio"
                }, ye(l.value ? "" : ""), 3),
                v("div", kW, [
                  S[26] || (S[26] = v("label", null, "Height:", -1)),
                  st(v("input", {
                    type: "number",
                    "onUpdate:modelValue": S[7] || (S[7] = (A) => d.value.height = A),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: S[8] || (S[8] = (A) => x("height"))
                  }, null, 544), [
                    [
                      Ot,
                      d.value.height,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  S[27] || (S[27] = v("span", { class: "unit" }, "px", -1))
                ])
              ]),
              v("div", DW, [
                S[29] || (S[29] = v("label", null, "Pixel Aspect Ratio:", -1)),
                st(v("select", {
                  "onUpdate:modelValue": S[9] || (S[9] = (A) => d.value.pixelAspectRatio = A),
                  class: "select-input"
                }, [...S[28] || (S[28] = [
                  v("option", { value: "1" }, "Square Pixels (1.0)", -1),
                  v("option", { value: "1.067" }, "D1/DV NTSC (0.9)", -1),
                  v("option", { value: "1.422" }, "D1/DV PAL (1.067)", -1),
                  v("option", { value: "1.333" }, "Anamorphic 2:1 (2.0)", -1)
                ])], 512), [
                  [En, d.value.pixelAspectRatio]
                ]),
                v("span", IW, "Frame Aspect Ratio: " + ye(h.value), 1)
              ]),
              v("div", RW, [
                S[31] || (S[31] = v("label", null, "Frame Rate:", -1)),
                st(v("select", {
                  "onUpdate:modelValue": S[10] || (S[10] = (A) => d.value.fps = A),
                  class: "select-input short"
                }, [...S[30] || (S[30] = [
                  v("option", { value: 8 }, "8", -1),
                  v("option", { value: 12 }, "12", -1),
                  v("option", { value: 15 }, "15", -1),
                  v("option", { value: 16 }, "16", -1),
                  v("option", { value: 23.976 }, "23.976", -1),
                  v("option", { value: 24 }, "24", -1),
                  v("option", { value: 25 }, "25", -1),
                  v("option", { value: 29.97 }, "29.97", -1),
                  v("option", { value: 30 }, "30", -1),
                  v("option", { value: 50 }, "50", -1),
                  v("option", { value: 59.94 }, "59.94", -1),
                  v("option", { value: 60 }, "60", -1)
                ])], 512), [
                  [
                    En,
                    d.value.fps,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                S[32] || (S[32] = v("span", { class: "unit" }, "frames per second", -1))
              ]),
              v("div", LW, [
                S[34] || (S[34] = v("label", null, "Resolution:", -1)),
                st(v("select", {
                  "onUpdate:modelValue": S[11] || (S[11] = (A) => d.value.resolution = A),
                  class: "select-input short"
                }, [...S[33] || (S[33] = [
                  v("option", { value: "full" }, "Full", -1),
                  v("option", { value: "half" }, "Half", -1),
                  v("option", { value: "third" }, "Third", -1),
                  v("option", { value: "quarter" }, "Quarter", -1)
                ])], 512), [
                  [En, d.value.resolution]
                ]),
                v("span", FW, ye(m.value), 1)
              ]),
              v("div", OW, [
                S[35] || (S[35] = v("label", null, "Duration:", -1)),
                v("div", UW, [
                  st(v("input", {
                    type: "text",
                    "onUpdate:modelValue": S[12] || (S[12] = (A) => f.value = A),
                    class: "timecode-input",
                    placeholder: "00:00:00:00",
                    onBlur: w
                  }, null, 544), [
                    [Ot, f.value]
                  ]),
                  v("span", zW, ye(d.value.frameCount) + " frames = " + ye(p.value.toFixed(2)) + "s ", 1)
                ])
              ]),
              v("div", BW, [
                S[36] || (S[36] = v("label", null, "Background Color:", -1)),
                v("div", NW, [
                  st(v("input", {
                    type: "color",
                    "onUpdate:modelValue": S[13] || (S[13] = (A) => d.value.backgroundColor = A),
                    class: "color-input"
                  }, null, 512), [
                    [Ot, d.value.backgroundColor]
                  ]),
                  v("span", VW, ye(d.value.backgroundColor), 1)
                ])
              ])
            ])) : Te("", !0),
            a.value === "advanced" ? (se(), re("div", HW, [
              v("div", GW, [
                v("label", null, [
                  st(v("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": S[14] || (S[14] = (A) => d.value.autoResizeToContent = A)
                  }, null, 512), [
                    [Ci, d.value.autoResizeToContent]
                  ]),
                  S[37] || (S[37] = ct(" Auto-resize composition when importing video ", -1))
                ])
              ]),
              v("div", $W, [
                S[38] || (S[38] = v("label", null, "Start Timecode:", -1)),
                st(v("input", {
                  type: "text",
                  "onUpdate:modelValue": S[15] || (S[15] = (A) => d.value.startTimecode = A),
                  class: "timecode-input",
                  placeholder: "00:00:00:00"
                }, null, 512), [
                  [Ot, d.value.startTimecode]
                ])
              ]),
              v("div", WW, [
                S[44] || (S[44] = v("label", null, "Motion Blur:", -1)),
                v("div", jW, [
                  v("label", null, [
                    st(v("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": S[16] || (S[16] = (A) => d.value.motionBlurEnabled = A)
                    }, null, 512), [
                      [Ci, d.value.motionBlurEnabled]
                    ]),
                    S[39] || (S[39] = ct(" Enable Motion Blur ", -1))
                  ]),
                  d.value.motionBlurEnabled ? (se(), re("div", XW, [
                    v("div", YW, [
                      S[40] || (S[40] = v("label", null, "Shutter Angle:", -1)),
                      st(v("input", {
                        type: "number",
                        "onUpdate:modelValue": S[17] || (S[17] = (A) => d.value.shutterAngle = A),
                        min: "0",
                        max: "720",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          Ot,
                          d.value.shutterAngle,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      S[41] || (S[41] = v("span", { class: "unit" }, "", -1))
                    ]),
                    v("div", qW, [
                      S[42] || (S[42] = v("label", null, "Shutter Phase:", -1)),
                      st(v("input", {
                        type: "number",
                        "onUpdate:modelValue": S[18] || (S[18] = (A) => d.value.shutterPhase = A),
                        min: "-360",
                        max: "360",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          Ot,
                          d.value.shutterPhase,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      S[43] || (S[43] = v("span", { class: "unit" }, "", -1))
                    ])
                  ])) : Te("", !0)
                ])
              ])
            ])) : Te("", !0)
          ]),
          v("div", ZW, [
            v("div", KW, [
              v("label", null, [
                st(v("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": S[19] || (S[19] = (A) => u.value = A)
                }, null, 512), [
                  [Ci, u.value]
                ]),
                S[45] || (S[45] = ct(" Preview ", -1))
              ])
            ]),
            v("div", { class: "dialog-actions" }, [
              v("button", {
                class: "btn btn-secondary",
                onClick: T
              }, "Cancel"),
              v("button", {
                class: "btn btn-primary",
                onClick: P
              }, "OK")
            ])
          ])
        ])
      ])) : Te("", !0)
    ]));
  }
}), QW = /* @__PURE__ */ Vt(JW, [["__scopeId", "data-v-76356b13"]]), b0 = r0("MotionIntentResolver"), H1 = `You are a motion graphics expert analyzing images for camera movements and animation paths.

Given an image, suggest motion paths and camera trajectories that would create compelling visual effects.

ALWAYS respond in valid JSON format with this structure:
{
  "description": "Brief description of suggested motion",
  "confidence": 0.0-1.0,
  "cameraIntents": [...],
  "splineIntents": [...],
  "particleIntents": [...],
  "layerIntents": [...]
}

For spline/path suggestions, provide control points as:
{
  "suggestedPoints": [
    { "id": "p1", "x": 100, "y": 200, "depth": 0.5, "handleIn": null, "handleOut": null, "type": "smooth" }
  ]
}

Consider:
- Depth information if available (closer = lower depth values)
- Subject positions and focal points
- Natural motion paths that follow scene geometry
- Parallax opportunities based on depth layers
`, ej = `Analyze this image and suggest camera/motion paths.

Consider:
1. Main subjects and their positions
2. Depth layers (foreground, midground, background)
3. Natural movement paths that would be visually interesting
4. Points of interest to orbit around or move between

Suggest 2-3 different trajectory options with varying complexity.`;
class tj {
  constructor(e) {
    le(this, "config");
    le(this, "lastResult", null);
    this.config = {
      modelId: (e == null ? void 0 : e.modelId) ?? "rule-based",
      apiEndpoint: e == null ? void 0 : e.apiEndpoint,
      apiKey: e == null ? void 0 : e.apiKey,
      maxTokens: (e == null ? void 0 : e.maxTokens) ?? 2048,
      temperature: (e == null ? void 0 : e.temperature) ?? 0.7
    };
  }
  /**
   * Resolve a user prompt into structured motion intents
   */
  async resolve(e, n, i) {
    const o = i ?? this.config.modelId;
    b0.info(`Resolving motion intent with ${o}:`, e);
    try {
      let a;
      switch (o) {
        case "rule-based":
          a = await this.resolveWithRules(e, n);
          break;
        case "gpt-4v":
        case "gpt-4o":
          a = await this.resolveWithOpenAI(e, n, o);
          break;
        case "claude-vision":
          a = await this.resolveWithClaude(e, n);
          break;
        case "qwen-vl":
        case "qwen2-vl":
        case "llava":
        case "local-vlm":
          a = await this.resolveWithLocalVLM(e, n, o);
          break;
        default:
          a = await this.resolveWithRules(e, n);
      }
      return this.lastResult = a, a;
    } catch (a) {
      return b0.error("Motion intent resolution failed:", a), this.resolveWithRules(e, n);
    }
  }
  /**
   * Suggest paths based on image analysis
   * This is the main entry point for "suggest trajectories across image"
   */
  async suggestPaths(e, n) {
    return this.resolve(ej, e, n);
  }
  // ============================================================================
  // RULE-BASED FALLBACK
  // ============================================================================
  async resolveWithRules(e, n) {
    const i = e.toLowerCase(), o = {
      description: "Rule-based motion suggestion",
      confidence: 0.6,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: []
    }, a = [];
    (i.includes("dolly") || i.includes("push in") || i.includes("pull out")) && a.push({
      type: "dolly",
      intensity: this.extractIntensity(i),
      axis: "z",
      durationFrames: n.frameCount,
      suggestedEasing: "easeInOut"
    }), (i.includes("pan") || i.includes("sweep")) && a.push({
      type: "pan",
      intensity: this.extractIntensity(i),
      axis: "y",
      durationFrames: n.frameCount,
      suggestedEasing: "easeInOut"
    }), (i.includes("orbit") || i.includes("around")) && a.push({
      type: "orbit",
      intensity: this.extractIntensity(i),
      durationFrames: n.frameCount,
      orbitCenter: { x: n.width / 2, y: n.height / 2, z: 0 },
      suggestedEasing: "linear"
    }), (i.includes("drift") || i.includes("float") || i.includes("subtle")) && a.push({
      type: "drift",
      intensity: "very_subtle",
      durationFrames: n.frameCount,
      suggestedEasing: "easeInOut"
    }), (i.includes("handheld") || i.includes("shake")) && a.push({
      type: "handheld",
      intensity: this.extractIntensity(i),
      noiseAmount: i.includes("light") ? 0.3 : 0.6,
      durationFrames: n.frameCount
    });
    const r = [];
    if (n.depthMap || i.includes("path") || i.includes("trajectory")) {
      const c = this.generateDefaultPath(n);
      if (r.push({
        usage: "camera_path",
        smoothness: 0.8,
        complexity: c.length,
        worldSpace: !0,
        suggestedPoints: c,
        closed: !1
      }), n.depthMap) {
        const u = this.generateDepthBasedPath(n);
        r.push({
          usage: "camera_path",
          smoothness: 0.9,
          complexity: u.length,
          worldSpace: !0,
          suggestedPoints: u,
          closed: !1
        });
      }
    }
    const l = [];
    return (i.includes("particle") || i.includes("dust") || i.includes("snow")) && l.push({
      behavior: i.includes("snow") ? "snow" : i.includes("dust") ? "dust" : "drift",
      intensity: 0.5,
      spread: 45,
      lifetime: 120
    }), {
      ...o,
      cameraIntents: a,
      splineIntents: r,
      particleIntents: l
    };
  }
  extractIntensity(e) {
    return e.includes("very subtle") || e.includes("barely") ? "very_subtle" : e.includes("subtle") || e.includes("gentle") || e.includes("soft") ? "subtle" : e.includes("dramatic") || e.includes("intense") || e.includes("strong") ? "dramatic" : e.includes("bold") || e.includes("dynamic") ? "strong" : "medium";
  }
  generateDefaultPath(e) {
    const { width: n, height: i } = e, o = Math.min(n, i) * 0.1;
    return [
      this.createControlPoint("p1", o, i / 2, 0),
      this.createControlPoint("p2", n * 0.33, i * 0.3, 0.3),
      this.createControlPoint("p3", n * 0.66, i * 0.7, 0.6),
      this.createControlPoint("p4", n - o, i / 2, 1)
    ];
  }
  generateDepthBasedPath(e) {
    const { width: n, height: i, depthMap: o } = e;
    if (!o)
      return this.generateDefaultPath(e);
    const a = [], r = 5;
    for (let l = 0; l < r; l++) {
      const c = l / (r - 1), u = n * (0.2 + c * 0.6), d = i * (0.3 + Math.sin(c * Math.PI) * 0.4), h = Math.floor(d) * n + Math.floor(u), p = o[h] ?? 0.5;
      a.push(this.createControlPoint(`dp${l}`, u, d, p));
    }
    return a;
  }
  createControlPoint(e, n, i, o) {
    return {
      id: e,
      x: n,
      y: i,
      depth: o,
      handleIn: null,
      handleOut: null,
      type: "smooth"
    };
  }
  // ============================================================================
  // OPENAI GPT-4V / GPT-4o
  // ============================================================================
  async resolveWithOpenAI(e, n, i) {
    var r, l;
    if (!this.config.apiKey)
      return b0.warn("OpenAI API key not configured, falling back to rule-based"), this.resolveWithRules(e, n);
    const o = n.frameImage ? this.imageDataToBase64(n.frameImage) : null, a = [
      { role: "system", content: H1 },
      {
        role: "user",
        content: o ? [
          { type: "text", text: e },
          { type: "image_url", image_url: { url: `data:image/png;base64,${o}` } }
        ] : e
      }
    ];
    try {
      const c = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: i === "gpt-4o" ? "gpt-4o" : "gpt-4-vision-preview",
          messages: a,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature
        })
      });
      if (!c.ok)
        throw new Error(`OpenAI API error: ${c.status}`);
      const d = (l = (r = (await c.json()).choices[0]) == null ? void 0 : r.message) == null ? void 0 : l.content;
      return this.parseAIResponse(d, e);
    } catch (c) {
      return b0.error("OpenAI API call failed:", c), this.resolveWithRules(e, n);
    }
  }
  // ============================================================================
  // CLAUDE VISION
  // ============================================================================
  async resolveWithClaude(e, n) {
    var a;
    if (!this.config.apiKey)
      return b0.warn("Anthropic API key not configured, falling back to rule-based"), this.resolveWithRules(e, n);
    const i = n.frameImage ? this.imageDataToBase64(n.frameImage) : null, o = i ? [
      { type: "image", source: { type: "base64", media_type: "image/png", data: i } },
      { type: "text", text: e }
    ] : [{ type: "text", text: e }];
    try {
      const r = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.config.apiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify({
          model: "claude-3-5-sonnet-20241022",
          max_tokens: this.config.maxTokens,
          system: H1,
          messages: [{ role: "user", content: o }]
        })
      });
      if (!r.ok)
        throw new Error(`Anthropic API error: ${r.status}`);
      const c = (a = (await r.json()).content[0]) == null ? void 0 : a.text;
      return this.parseAIResponse(c, e);
    } catch (r) {
      return b0.error("Anthropic API call failed:", r), this.resolveWithRules(e, n);
    }
  }
  // ============================================================================
  // LOCAL VLM (via ComfyUI or local endpoint)
  // ============================================================================
  async resolveWithLocalVLM(e, n, i) {
    const o = this.config.apiEndpoint ?? "http://localhost:8188/api/vlm", a = n.frameImage ? this.imageDataToBase64(n.frameImage) : null;
    try {
      const r = await fetch(o, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          model: i,
          prompt: `${H1}

User request: ${e}`,
          image: a,
          max_tokens: this.config.maxTokens
        })
      });
      if (!r.ok)
        throw new Error(`Local VLM API error: ${r.status}`);
      const l = await r.json();
      return this.parseAIResponse(l.response ?? l.text ?? l.content, e);
    } catch (r) {
      return b0.error("Local VLM API call failed:", r), this.resolveWithRules(e, n);
    }
  }
  // ============================================================================
  // RESPONSE PARSING
  // ============================================================================
  parseAIResponse(e, n) {
    try {
      const i = e.match(/\{[\s\S]*\}/);
      if (i) {
        const o = JSON.parse(i[0]);
        return {
          description: o.description ?? "AI-generated motion suggestion",
          confidence: o.confidence ?? 0.8,
          cameraIntents: o.cameraIntents ?? [],
          splineIntents: o.splineIntents ?? [],
          particleIntents: o.particleIntents ?? [],
          layerIntents: o.layerIntents ?? [],
          rawResponse: e
        };
      }
    } catch (i) {
      b0.warn("Failed to parse AI response as JSON:", i);
    }
    return {
      description: e.slice(0, 200),
      confidence: 0.5,
      cameraIntents: [],
      splineIntents: [],
      particleIntents: [],
      layerIntents: [],
      rawResponse: e
    };
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  imageDataToBase64(e) {
    const n = document.createElement("canvas");
    return n.width = e.width, n.height = e.height, n.getContext("2d").putImageData(e, 0, 0), n.toDataURL("image/png").split(",")[1];
  }
  /**
   * Get last resolution result
   */
  getLastResult() {
    return this.lastResult;
  }
  /**
   * Update configuration
   */
  setConfig(e) {
    this.config = { ...this.config, ...e };
  }
}
const nc = new tj(), nj = r0("MotionIntentTranslator"), ic = {
  very_subtle: 10,
  subtle: 30,
  medium: 80,
  strong: 200,
  dramatic: 500
}, ij = {
  very_subtle: 2,
  subtle: 5,
  medium: 15,
  strong: 45,
  dramatic: 90
};
function sj(s, e) {
  const n = e / 3;
  switch (s) {
    case "linear":
      return {
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 }
      };
    case "easeIn":
      return {
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: n, value: 0, enabled: !0 }
      };
    case "easeOut":
      return {
        inHandle: { frame: -n, value: 0, enabled: !0 },
        outHandle: { frame: 0, value: 0, enabled: !1 }
      };
    case "easeInOut":
      return {
        inHandle: { frame: -n, value: 0, enabled: !0 },
        outHandle: { frame: n, value: 0, enabled: !0 }
      };
    case "bounce":
      return {
        inHandle: { frame: -n * 0.5, value: 0, enabled: !0 },
        outHandle: { frame: n * 0.5, value: 0, enabled: !0 }
      };
    case "elastic":
      return {
        inHandle: { frame: -n * 0.3, value: 0, enabled: !0 },
        outHandle: { frame: n * 0.3, value: 0, enabled: !0 }
      };
    default:
      return {
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 }
      };
  }
}
class oj {
  /**
   * Translate a camera motion intent to keyframes
   */
  translateCameraIntent(e, n, i, o) {
    const a = e.durationFrames ?? o, r = ic[e.intensity], l = ij[e.intensity], c = e.suggestedEasing ?? "easeInOut", u = [];
    switch (e.type) {
      case "dolly":
        u.push(
          this.createPositionKeyframes(
            n,
            "transform.position.z",
            i.z,
            i.z + (e.axis === "z" ? r : 0),
            0,
            a,
            c
          )
        );
        break;
      case "truck":
        u.push(
          this.createPositionKeyframes(
            n,
            "transform.position.x",
            i.x,
            i.x + r,
            0,
            a,
            c
          )
        );
        break;
      case "pedestal":
        u.push(
          this.createPositionKeyframes(
            n,
            "transform.position.y",
            i.y,
            i.y + r,
            0,
            a,
            c
          )
        );
        break;
      case "pan":
        u.push(
          this.createRotationKeyframes(
            n,
            "transform.rotation.y",
            0,
            l,
            0,
            a,
            c
          )
        );
        break;
      case "tilt":
        u.push(
          this.createRotationKeyframes(
            n,
            "transform.rotation.x",
            0,
            l,
            0,
            a,
            c
          )
        );
        break;
      case "roll":
        u.push(
          this.createRotationKeyframes(
            n,
            "transform.rotation.z",
            0,
            l,
            0,
            a,
            c
          )
        );
        break;
      case "zoom":
        u.push(
          this.createPositionKeyframes(
            n,
            "camera.fov",
            60,
            60 - r * 0.5,
            // Narrower FOV = zoom in
            0,
            a,
            c
          )
        );
        break;
      case "drift":
        u.push(
          ...this.createDriftKeyframes(n, i, a, e.intensity)
        );
        break;
      case "handheld":
        u.push(
          ...this.createHandheldKeyframes(
            n,
            i,
            a,
            e.noiseAmount ?? 0.5
          )
        );
        break;
      case "orbit":
        e.orbitCenter && u.push(
          ...this.createOrbitKeyframes(
            n,
            i,
            e.orbitCenter,
            a,
            e.intensity
          )
        );
        break;
      case "crane":
        u.push(
          ...this.createCraneKeyframes(n, i, a, e.intensity)
        );
        break;
      case "follow_path":
        e.suggestedPath && nj.info("Camera path following requires spline layer creation");
        break;
    }
    return u;
  }
  /**
   * Translate a spline intent to a spline layer configuration
   */
  translateSplineIntent(e, n, i) {
    const o = e.suggestedPoints.map((a, r) => ({
      id: a.id ?? `sp_${r}`,
      x: a.x,
      y: a.y,
      depth: a.depth ?? 0,
      handleIn: this.generateHandle(e.suggestedPoints, r, -1, e.smoothness),
      handleOut: this.generateHandle(e.suggestedPoints, r, 1, e.smoothness),
      type: a.type ?? "smooth"
    }));
    return {
      keyframeBatches: [],
      newSplines: [
        {
          name: `AI Path - ${e.usage}`,
          points: o,
          closed: e.closed
        }
      ]
    };
  }
  /**
   * Translate a particle intent to emitter configuration
   */
  translateParticleIntent(e, n, i) {
    const o = {
      emissionRate: e.intensity * 20,
      particleLifetime: e.lifetime ?? 60,
      spread: e.spread ?? 30
    };
    switch (e.behavior) {
      case "snow":
        Object.assign(o, {
          direction: 270,
          speed: 50,
          speedVariance: 20,
          gravity: 0.1
        });
        break;
      case "rain":
        Object.assign(o, {
          direction: 270,
          speed: 200,
          speedVariance: 30,
          gravity: 0.5
        });
        break;
      case "dust":
        Object.assign(o, {
          direction: 0,
          speed: 20,
          speedVariance: 15,
          gravity: 0
        });
        break;
      case "fireflies":
        Object.assign(o, {
          direction: 90,
          speed: 30,
          speedVariance: 20,
          gravity: -0.05
        });
        break;
      case "explosion":
        Object.assign(o, {
          direction: 0,
          spread: 360,
          speed: 300,
          speedVariance: 100,
          initialBurst: 50,
          emissionRate: 0
        });
        break;
      case "vortex":
        Object.assign(o, {
          direction: 0,
          spread: 360,
          speed: 100
          // Would need vortex force field
        });
        break;
    }
    return {
      keyframeBatches: [],
      newLayers: [
        {
          type: "particles",
          name: `AI Particles - ${e.behavior}`,
          config: o
        }
      ]
    };
  }
  /**
   * Translate a layer motion intent to keyframes
   */
  translateLayerIntent(e, n, i) {
    const o = i, a = e.amplitude, r = e.frequency ?? 1, l = [];
    switch (e.motionType) {
      case "parallax":
        l.push(
          this.createOscillatingKeyframes(
            n.id,
            "transform.position.x",
            0,
            a * 50,
            o,
            r,
            e.phase ?? 0
          )
        );
        break;
      case "float":
        l.push(
          this.createOscillatingKeyframes(
            n.id,
            "transform.position.y",
            0,
            a * 30,
            o,
            r,
            e.phase ?? 0
          )
        );
        break;
      case "sway":
        l.push(
          this.createOscillatingKeyframes(
            n.id,
            "transform.position.x",
            0,
            a * 40,
            o,
            r,
            e.phase ?? 0
          )
        );
        break;
      case "breathe":
        l.push(
          this.createOscillatingKeyframes(
            n.id,
            "transform.scale.x",
            100,
            100 + a * 10,
            o,
            r,
            e.phase ?? 0
          ),
          this.createOscillatingKeyframes(
            n.id,
            "transform.scale.y",
            100,
            100 + a * 10,
            o,
            r,
            e.phase ?? 0
          )
        );
        break;
      case "pulse":
        l.push(
          this.createOscillatingKeyframes(
            n.id,
            "opacity",
            100,
            100 - a * 30,
            o,
            r * 2,
            e.phase ?? 0
          )
        );
        break;
      case "rotate":
        l.push(
          this.createPositionKeyframes(
            n.id,
            "transform.rotation.z",
            0,
            360 * r,
            0,
            o,
            "linear"
          )
        );
        break;
    }
    return l;
  }
  // ============================================================================
  // KEYFRAME GENERATORS
  // ============================================================================
  createPositionKeyframes(e, n, i, o, a, r, l) {
    const c = sj(l, r - a);
    return {
      layerId: e,
      propertyPath: n,
      keyframes: [
        {
          id: `kf_${e}_${n}_0`,
          frame: a,
          value: i,
          interpolation: l === "linear" ? "linear" : "bezier",
          ...c,
          controlMode: "smooth"
        },
        {
          id: `kf_${e}_${n}_1`,
          frame: r,
          value: o,
          interpolation: "linear",
          inHandle: { frame: 0, value: 0, enabled: !1 },
          outHandle: { frame: 0, value: 0, enabled: !1 },
          controlMode: "smooth"
        }
      ]
    };
  }
  createRotationKeyframes(e, n, i, o, a, r, l) {
    return this.createPositionKeyframes(
      e,
      n,
      i,
      o,
      a,
      r,
      l
    );
  }
  createOscillatingKeyframes(e, n, i, o, a, r, l) {
    const c = [], d = a / r / 4;
    for (let h = 0; h <= r * 4; h++) {
      const p = Math.round(h * d);
      if (p > a) break;
      const f = (h + l * 4) % 4;
      let m;
      switch (f) {
        case 0:
          m = i;
          break;
        case 1:
          m = i + o;
          break;
        case 2:
          m = i;
          break;
        case 3:
          m = i - o;
          break;
        default:
          m = i;
      }
      c.push({
        id: `kf_${e}_${n}_${h}`,
        frame: p,
        value: m,
        interpolation: "bezier",
        inHandle: { frame: -d * 0.5, value: 0, enabled: !0 },
        outHandle: { frame: d * 0.5, value: 0, enabled: !0 },
        controlMode: "smooth"
      });
    }
    return { layerId: e, propertyPath: n, keyframes: c };
  }
  createDriftKeyframes(e, n, i, o) {
    const a = ic[o] * 0.3;
    return [
      this.createOscillatingKeyframes(e, "transform.position.x", n.x, a, i, 0.5, 0),
      this.createOscillatingKeyframes(e, "transform.position.y", n.y, a * 0.7, i, 0.3, 0.25),
      this.createOscillatingKeyframes(e, "transform.position.z", n.z, a * 0.5, i, 0.4, 0.5)
    ];
  }
  createHandheldKeyframes(e, n, i, o) {
    const a = this.hashString(e), r = o * 5, l = [];
    for (const c of ["x", "y", "z"]) {
      const u = [], d = n[c], h = Math.floor(i / 4);
      for (let p = 0; p <= h; p++) {
        const f = Math.min(p * 4, i), m = this.deterministicNoise(a, c, f) * r;
        u.push({
          id: `kf_${e}_handheld_${c}_${p}`,
          frame: f,
          value: d + m,
          interpolation: "bezier",
          inHandle: { frame: -1, value: 0, enabled: !0 },
          outHandle: { frame: 1, value: 0, enabled: !0 },
          controlMode: "smooth"
        });
      }
      l.push({
        layerId: e,
        propertyPath: `transform.position.${c}`,
        keyframes: u
      });
    }
    return l;
  }
  createOrbitKeyframes(e, n, i, o, a) {
    const r = Math.sqrt(
      Math.pow(n.x - i.x, 2) + Math.pow(n.z - i.z, 2)
    ) || ic[a], l = 8, c = [], u = [];
    for (let d = 0; d <= l; d++) {
      const h = Math.round(d / l * o), p = d / l * Math.PI * 2;
      c.push({
        id: `kf_${e}_orbit_x_${d}`,
        frame: h,
        value: i.x + Math.cos(p) * r,
        interpolation: "bezier",
        inHandle: { frame: -o / l * 0.3, value: 0, enabled: !0 },
        outHandle: { frame: o / l * 0.3, value: 0, enabled: !0 },
        controlMode: "smooth"
      }), u.push({
        id: `kf_${e}_orbit_z_${d}`,
        frame: h,
        value: i.z + Math.sin(p) * r,
        interpolation: "bezier",
        inHandle: { frame: -o / l * 0.3, value: 0, enabled: !0 },
        outHandle: { frame: o / l * 0.3, value: 0, enabled: !0 },
        controlMode: "smooth"
      });
    }
    return [
      { layerId: e, propertyPath: "transform.position.x", keyframes: c },
      { layerId: e, propertyPath: "transform.position.z", keyframes: u }
    ];
  }
  createCraneKeyframes(e, n, i, o) {
    const a = ic[o];
    return [
      this.createPositionKeyframes(
        e,
        "transform.position.y",
        n.y,
        n.y + a,
        0,
        i / 2,
        "easeOut"
      ),
      this.createPositionKeyframes(
        e,
        "transform.position.z",
        n.z,
        n.z + a * 0.5,
        0,
        i,
        "easeInOut"
      )
    ];
  }
  // ============================================================================
  // UTILITIES
  // ============================================================================
  generateHandle(e, n, i, o) {
    const a = e[n - 1], r = e[n + 1], l = e[n];
    if (!l) return null;
    let c = 0, u = 0;
    if (a && r)
      c = (r.x - a.x) * 0.25 * o, u = (r.y - a.y) * 0.25 * o;
    else if (r)
      c = (r.x - l.x) * 0.25 * o, u = (r.y - l.y) * 0.25 * o;
    else if (a)
      c = (l.x - a.x) * 0.25 * o, u = (l.y - a.y) * 0.25 * o;
    else
      return null;
    return {
      x: c * i,
      y: u * i
    };
  }
  hashString(e) {
    let n = 0;
    for (let i = 0; i < e.length; i++) {
      const o = e.charCodeAt(i);
      n = (n << 5) - n + o, n = n & n;
    }
    return Math.abs(n);
  }
  deterministicNoise(e, n, i) {
    const a = e + (n === "x" ? 0 : n === "y" ? 1e3 : 2e3) + i * 13, r = Math.sin(a) * 1e4;
    return r - Math.floor(r) - 0.5;
  }
}
const v9 = new oj(), aj = { class: "dialog-container" }, rj = { class: "dialog-content" }, lj = { class: "form-section" }, cj = { class: "form-row" }, uj = {
  key: 0,
  class: "form-row api-key-row"
}, dj = ["placeholder"], hj = {
  key: 1,
  class: "form-row"
}, fj = { class: "form-section" }, pj = { class: "prompt-presets" }, mj = ["onClick"], vj = {
  key: 0,
  class: "form-section"
}, gj = {
  key: 0,
  class: "spinner"
}, yj = { class: "status-text" }, xj = {
  key: 1,
  class: "form-section"
}, bj = { class: "suggestions-list" }, _j = ["onClick"], wj = { class: "suggestion-header" }, Mj = { class: "suggestion-type" }, Sj = { class: "suggestion-confidence" }, Cj = { class: "suggestion-description" }, Tj = { class: "suggestion-details" }, Ej = { key: 0 }, Aj = { key: 1 }, Pj = { class: "form-section preview-section" }, kj = { class: "dialog-footer" }, Dj = { class: "footer-left" }, Ij = ["disabled"], Rj = {
  key: 0,
  class: "spinner-small"
}, Lj = { class: "dialog-actions" }, Fj = ["disabled"], Oj = /* @__PURE__ */ Bt({
  __name: "PathSuggestionDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "accept", "preview"],
  setup(s, { emit: e }) {
    const n = e, i = un(), o = xe("rule-based"), a = xe(""), r = xe("http://localhost:8188/api/vlm"), l = xe(""), c = xe(null), u = xe("idle"), d = xe(""), h = xe([]), p = xe(null), f = xe(!0), m = [
      { id: "dolly", label: "Dolly", prompt: "Gentle dolly in towards the subject" },
      { id: "orbit", label: "Orbit", prompt: "Slow orbit around the center point" },
      { id: "drift", label: "Drift", prompt: "Subtle floating drift movement" },
      { id: "handheld", label: "Handheld", prompt: "Organic handheld camera shake" },
      { id: "pan", label: "Pan", prompt: "Smooth horizontal pan across the scene" },
      { id: "crane", label: "Crane", prompt: "Vertical crane movement" }
    ], y = Re(() => ["gpt-4v", "gpt-4o", "claude-vision"].includes(o.value)), g = Re(() => ["qwen-vl", "qwen2-vl", "llava", "local-vlm"].includes(o.value)), x = Re(() => o.value.startsWith("gpt-") ? "sk-..." : o.value === "claude-vision" ? "sk-ant-..." : "API Key");
    function w(S) {
      c.value = S.id, l.value = S.prompt;
    }
    async function M() {
      u.value = "loading", d.value = "Testing connection...";
      try {
        nc.setConfig({
          modelId: o.value,
          apiKey: a.value || void 0,
          apiEndpoint: g.value ? r.value : void 0
        });
        const S = {
          compositionId: i.activeCompositionId,
          width: i.width,
          height: i.height,
          frameCount: i.frameCount,
          fps: i.fps,
          selectedLayerIds: [],
          currentFrame: i.currentFrame
        };
        await nc.resolve("test", S, o.value), u.value = "success", d.value = "Connection successful!";
      } catch (S) {
        u.value = "error", d.value = `Connection failed: ${S instanceof Error ? S.message : "Unknown error"}`;
      }
    }
    async function _(S) {
      if (S)
        try {
          const A = new Image();
          A.crossOrigin = "anonymous", await new Promise((W, fe) => {
            A.onload = () => W(), A.onerror = fe, A.src = S;
          });
          const R = document.createElement("canvas");
          R.width = A.width, R.height = A.height;
          const k = R.getContext("2d");
          if (!k) return;
          k.drawImage(A, 0, 0);
          const U = k.getImageData(0, 0, A.width, A.height), I = new Float32Array(A.width * A.height);
          for (let W = 0; W < I.length; W++) {
            const fe = U.data[W * 4], q = U.data[W * 4 + 1], G = U.data[W * 4 + 2];
            I[W] = (fe + q + G) / (3 * 255);
          }
          return I;
        } catch (A) {
          console.warn("[PathSuggestionDialog] Failed to load depth map:", A);
          return;
        }
    }
    async function C() {
      try {
        const S = document.querySelector(".viewport-content canvas");
        if (!S) return;
        const A = S.getContext("2d") || S.getContext("webgl2") || S.getContext("webgl");
        if (!A) return;
        if (A instanceof WebGLRenderingContext || A instanceof WebGL2RenderingContext) {
          const R = S.width, k = S.height, U = new Uint8Array(R * k * 4);
          A.readPixels(0, 0, R, k, A.RGBA, A.UNSIGNED_BYTE, U);
          const I = new ImageData(R, k);
          for (let W = 0; W < k; W++)
            for (let fe = 0; fe < R; fe++) {
              const q = ((k - 1 - W) * R + fe) * 4, G = (W * R + fe) * 4;
              I.data[G] = U[q], I.data[G + 1] = U[q + 1], I.data[G + 2] = U[q + 2], I.data[G + 3] = U[q + 3];
            }
          return I;
        }
        return A instanceof CanvasRenderingContext2D ? A.getImageData(0, 0, S.width, S.height) : void 0;
      } catch (S) {
        console.warn("[PathSuggestionDialog] Failed to capture frame:", S);
        return;
      }
    }
    async function T() {
      if (!l.value.trim()) {
        u.value = "error", d.value = "Please enter a motion description";
        return;
      }
      u.value = "loading", d.value = "Analyzing scene and generating suggestions...", h.value = [], p.value = null;
      try {
        nc.setConfig({
          modelId: o.value,
          apiKey: a.value || void 0,
          apiEndpoint: g.value ? r.value : void 0
        });
        const S = await _(i.depthMap), A = await C(), R = {
          compositionId: i.activeCompositionId,
          width: i.width,
          height: i.height,
          frameCount: i.frameCount,
          fps: i.fps,
          selectedLayerIds: i.selectedLayerIds,
          currentFrame: i.currentFrame,
          depthMap: S,
          frameImage: A
        }, k = await nc.resolve(l.value, R, o.value), U = [];
        if (k.cameraIntents)
          for (const I of k.cameraIntents)
            U.push({
              type: "camera",
              description: `${I.type} motion - ${I.intensity}`,
              confidence: 0.8,
              duration: I.durationFrames,
              intent: I
            });
        if (k.splineIntents)
          for (const I of k.splineIntents)
            U.push({
              type: "spline",
              description: `${I.usage} - ${I.suggestedPoints.length} point path`,
              confidence: 0.9,
              points: I.suggestedPoints.map((W) => ({ x: W.x, y: W.y, depth: W.depth })),
              intent: I
            });
        h.value = U, u.value = "success", d.value = `Found ${U.length} suggestion${U.length !== 1 ? "s" : ""}`, U.length > 0 && (p.value = 0), f.value && n("preview", h.value);
      } catch (S) {
        u.value = "error", d.value = `Analysis failed: ${S instanceof Error ? S.message : "Unknown error"}`;
      }
    }
    function P() {
      if (p.value === null) return;
      const S = h.value[p.value], A = {
        keyframes: [],
        splines: []
      };
      if (S.type === "camera") {
        const R = v9.translateCameraIntent(
          S.intent,
          i.width,
          i.height,
          i.frameCount
        );
        A.keyframes = R.keyframeBatches;
      } else if (S.type === "spline") {
        const R = v9.translateSplineIntent(
          S.intent,
          i.width,
          i.height
        );
        A.splines = R.newSplines || [];
      }
      n("accept", A), n("close");
    }
    function E() {
      n("close");
    }
    Ft(f, (S) => {
      S && h.value.length > 0 ? n("preview", h.value) : n("preview", []);
    });
    function b(S) {
      S.key === "Escape" ? E() : S.key === "Enter" && S.ctrlKey && T();
    }
    return gn(() => {
      window.addEventListener("keydown", b);
    }), Un(() => {
      window.removeEventListener("keydown", b);
    }), (S, A) => (se(), Tt(R0, { to: "body" }, [
      s.visible ? (se(), re("div", {
        key: 0,
        class: "dialog-overlay",
        onClick: _t(E, ["self"])
      }, [
        v("div", aj, [
          v("div", { class: "dialog-header" }, [
            A[5] || (A[5] = v("span", { class: "dialog-title" }, "AI Path Suggestion", -1)),
            v("button", {
              class: "close-btn",
              onClick: E
            }, "")
          ]),
          v("div", rj, [
            v("div", lj, [
              A[9] || (A[9] = v("label", { class: "section-label" }, "Vision Model", -1)),
              v("div", cj, [
                st(v("select", {
                  "onUpdate:modelValue": A[0] || (A[0] = (R) => o.value = R),
                  class: "select-input"
                }, [...A[6] || (A[6] = [
                  v("option", { value: "rule-based" }, "Rule-Based (Offline)", -1),
                  v("optgroup", { label: "Cloud Models" }, [
                    v("option", { value: "gpt-4o" }, "OpenAI GPT-4o"),
                    v("option", { value: "gpt-4v" }, "OpenAI GPT-4V"),
                    v("option", { value: "claude-vision" }, "Claude Vision")
                  ], -1),
                  v("optgroup", { label: "Local Models" }, [
                    v("option", { value: "qwen2-vl" }, "Qwen2-VL"),
                    v("option", { value: "qwen-vl" }, "Qwen-VL"),
                    v("option", { value: "llava" }, "LLaVA"),
                    v("option", { value: "local-vlm" }, "Custom Local VLM")
                  ], -1)
                ])], 512), [
                  [En, o.value]
                ])
              ]),
              y.value ? (se(), re("div", uj, [
                A[7] || (A[7] = v("label", null, "API Key:", -1)),
                st(v("input", {
                  type: "password",
                  "onUpdate:modelValue": A[1] || (A[1] = (R) => a.value = R),
                  class: "text-input",
                  placeholder: x.value
                }, null, 8, dj), [
                  [Ot, a.value]
                ]),
                v("button", {
                  class: "btn btn-small",
                  onClick: M
                }, "Test")
              ])) : Te("", !0),
              g.value ? (se(), re("div", hj, [
                A[8] || (A[8] = v("label", null, "Endpoint:", -1)),
                st(v("input", {
                  type: "text",
                  "onUpdate:modelValue": A[2] || (A[2] = (R) => r.value = R),
                  class: "text-input",
                  placeholder: "http://localhost:8188/api/vlm"
                }, null, 512), [
                  [Ot, r.value]
                ])
              ])) : Te("", !0)
            ]),
            v("div", fj, [
              A[10] || (A[10] = v("label", { class: "section-label" }, "Motion Description", -1)),
              v("div", pj, [
                (se(), re(Xe, null, at(m, (R) => v("button", {
                  key: R.id,
                  class: Le(["preset-btn", { active: c.value === R.id }]),
                  onClick: (k) => w(R)
                }, ye(R.label), 11, mj)), 64))
              ]),
              st(v("textarea", {
                "onUpdate:modelValue": A[3] || (A[3] = (R) => l.value = R),
                class: "prompt-input",
                rows: "3",
                placeholder: "Describe the motion you want, e.g., 'dolly in slowly' or 'orbit around the subject'"
              }, null, 512), [
                [Ot, l.value]
              ])
            ]),
            u.value !== "idle" ? (se(), re("div", vj, [
              v("div", {
                class: Le(["status-bar", u.value])
              }, [
                u.value === "loading" ? (se(), re("span", gj)) : Te("", !0),
                v("span", yj, ye(d.value), 1)
              ], 2)
            ])) : Te("", !0),
            h.value.length > 0 ? (se(), re("div", xj, [
              A[11] || (A[11] = v("label", { class: "section-label" }, "Suggested Paths", -1)),
              v("div", bj, [
                (se(!0), re(Xe, null, at(h.value, (R, k) => (se(), re("div", {
                  key: k,
                  class: Le(["suggestion-item", { selected: p.value === k }]),
                  onClick: (U) => p.value = k
                }, [
                  v("div", wj, [
                    v("span", Mj, ye(R.type), 1),
                    v("span", Sj, ye(Math.round(R.confidence * 100)) + "% ", 1)
                  ]),
                  v("div", Cj, ye(R.description), 1),
                  v("div", Tj, [
                    R.points ? (se(), re("span", Ej, ye(R.points.length) + " points", 1)) : Te("", !0),
                    R.duration ? (se(), re("span", Aj, ye(R.duration) + " frames", 1)) : Te("", !0)
                  ])
                ], 10, _j))), 128))
              ])
            ])) : Te("", !0),
            v("div", Pj, [
              v("label", null, [
                st(v("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": A[4] || (A[4] = (R) => f.value = R)
                }, null, 512), [
                  [Ci, f.value]
                ]),
                A[12] || (A[12] = ct(" Show preview on canvas ", -1))
              ])
            ])
          ]),
          v("div", kj, [
            v("div", Dj, [
              v("button", {
                class: "btn btn-secondary",
                onClick: T,
                disabled: u.value === "loading"
              }, [
                u.value === "loading" ? (se(), re("span", Rj)) : Te("", !0),
                ct(" " + ye(u.value === "loading" ? "Analyzing..." : "Suggest Paths"), 1)
              ], 8, Ij)
            ]),
            v("div", Lj, [
              v("button", {
                class: "btn btn-secondary",
                onClick: E
              }, "Cancel"),
              v("button", {
                class: "btn btn-primary",
                onClick: P,
                disabled: p.value === null
              }, " Accept ", 8, Fj)
            ])
          ])
        ])
      ])) : Te("", !0)
    ]));
  }
}), Uj = /* @__PURE__ */ Vt(Oj, [["__scopeId", "data-v-f14ac83f"]]), zj = ["viewBox"], Bj = ["width", "height"], Nj = ["d"], Vj = {
  key: 0,
  width: "100%",
  height: "100%",
  fill: "url(#preview-grid)"
}, Hj = ["onClick"], Gj = ["d", "stroke"], $j = ["d", "stroke", "stroke-dasharray"], Wj = { key: 2 }, jj = ["cx", "cy", "stroke"], Xj = ["cx", "cy", "fill"], Yj = ["x", "y", "fill"], qj = ["x", "y"], Zj = ["x", "y", "fill"], Kj = ["cx", "cy", "stroke"], Jj = ["x1", "y1", "x2", "y2", "stroke"], Qj = ["x", "y", "fill"], eX = { key: 1 }, tX = ["cx", "cy"], nX = ["cx", "cy"], iX = {
  key: 0,
  class: "legend"
}, sX = ["onClick"], oX = { class: "legend-text" }, aX = {
  key: 1,
  class: "instructions"
}, rX = /* @__PURE__ */ Bt({
  __name: "PathPreviewOverlay",
  props: {
    width: {},
    height: {},
    suggestions: {},
    selectedIndex: {},
    showGrid: { type: Boolean, default: !0 },
    showPoints: { type: Boolean, default: !0 },
    showLabels: { type: Boolean, default: !0 },
    showDepth: { type: Boolean, default: !0 },
    showLegend: { type: Boolean, default: !0 },
    showAnimation: { type: Boolean, default: !0 },
    gridSize: { default: 50 }
  },
  emits: ["select"],
  setup(s, { emit: e }) {
    const n = s, i = e, o = xe(null), a = xe(null);
    let r = 0, l = null;
    const c = [
      "#4a90d9",
      // Blue
      "#d94a4a",
      // Red
      "#4ad94a",
      // Green
      "#d9d94a",
      // Yellow
      "#d94ad9",
      // Magenta
      "#4ad9d9"
      // Cyan
    ], u = Re(() => ({
      width: `${n.width}px`,
      height: `${n.height}px`
    })), d = Re(() => n.suggestions.filter((y) => y.type === "camera" && y.points && y.points.length >= 2).map((y) => {
      var g;
      return {
        type: ((g = y.description) == null ? void 0 : g.split(" ")[0]) || "Camera",
        startX: y.points[0].x,
        startY: y.points[0].y,
        endX: y.points[y.points.length - 1].x,
        endY: y.points[y.points.length - 1].y
      };
    }));
    function h(y, g) {
      const x = c[y % c.length];
      if (g === 1) return x;
      const w = parseInt(x.slice(1, 3), 16), M = parseInt(x.slice(3, 5), 16), _ = parseInt(x.slice(5, 7), 16);
      return `rgba(${w}, ${M}, ${_}, ${g})`;
    }
    function p(y) {
      if (y.length < 2) return "";
      let g = `M ${y[0].x} ${y[0].y}`;
      if (y.length === 2)
        g += ` L ${y[1].x} ${y[1].y}`;
      else
        for (let x = 0; x < y.length - 1; x++) {
          const w = y[Math.max(0, x - 1)], M = y[x], _ = y[x + 1], C = y[Math.min(y.length - 1, x + 2)], T = 0.3, P = M.x + (_.x - w.x) * T, E = M.y + (_.y - w.y) * T, b = _.x - (C.x - M.x) * T, S = _.y - (C.y - M.y) * T;
          g += ` C ${P} ${E}, ${b} ${S}, ${_.x} ${_.y}`;
        }
      return g;
    }
    function f() {
      if (n.selectedIndex === null) {
        a.value = null;
        return;
      }
      const y = n.suggestions[n.selectedIndex];
      if (!y.points || y.points.length < 2) {
        a.value = null;
        return;
      }
      const g = y.points, x = g.length - 1;
      function w() {
        r = (r + 0.5) % (x * 60);
        const M = r / (x * 60), _ = Math.min(Math.floor(M * x), x - 1), C = M * x - _, T = g[_], P = g[_ + 1];
        a.value = {
          x: T.x + (P.x - T.x) * C,
          y: T.y + (P.y - T.y) * C
        }, l = requestAnimationFrame(w);
      }
      w();
    }
    function m() {
      l !== null && (cancelAnimationFrame(l), l = null), a.value = null;
    }
    return Ft(() => n.suggestions, (y) => {
      for (const g of y)
        g.points && !g.pathData && (g.pathData = p(g.points));
    }, { immediate: !0, deep: !0 }), Ft(() => n.selectedIndex, () => {
      m(), n.showAnimation && f();
    }), gn(() => {
      n.showAnimation && n.selectedIndex !== null && f();
    }), Un(() => {
      m();
    }), (y, g) => (se(), re("div", {
      ref_key: "overlayRef",
      ref: o,
      class: "path-preview-overlay",
      style: xt(u.value)
    }, [
      (se(), re("svg", {
        class: "preview-svg",
        viewBox: `0 0 ${s.width} ${s.height}`,
        preserveAspectRatio: "xMidYMid meet"
      }, [
        v("defs", null, [
          v("pattern", {
            id: "preview-grid",
            width: s.gridSize,
            height: s.gridSize,
            patternUnits: "userSpaceOnUse"
          }, [
            v("path", {
              d: `M ${s.gridSize} 0 L 0 0 0 ${s.gridSize}`,
              fill: "none",
              stroke: "rgba(255,255,255,0.05)",
              "stroke-width": "1"
            }, null, 8, Nj)
          ], 8, Bj),
          g[0] || (g[0] = fs('<filter id="path-glow" x="-50%" y="-50%" width="200%" height="200%" data-v-021b36ff><feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" data-v-021b36ff></feGaussianBlur><feMerge data-v-021b36ff><feMergeNode in="blur" data-v-021b36ff></feMergeNode><feMergeNode in="SourceGraphic" data-v-021b36ff></feMergeNode></feMerge></filter><marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse" data-v-021b36ff><path d="M 0 0 L 10 5 L 0 10 z" fill="#4a90d9" data-v-021b36ff></path></marker>', 2))
        ]),
        s.showGrid ? (se(), re("rect", Vj)) : Te("", !0),
        (se(!0), re(Xe, null, at(s.suggestions, (x, w) => (se(), re("g", {
          key: w,
          class: Le(["path-group", { selected: s.selectedIndex === w }]),
          onClick: (M) => i("select", w)
        }, [
          x.pathData ? (se(), re("path", {
            key: 0,
            d: x.pathData,
            fill: "none",
            stroke: h(w, 0.3),
            "stroke-width": "8",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            filter: "url(#path-glow)"
          }, null, 8, Gj)) : Te("", !0),
          x.pathData ? (se(), re("path", {
            key: 1,
            d: x.pathData,
            fill: "none",
            stroke: h(w, 1),
            "stroke-width": "2",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-dasharray": s.selectedIndex === w ? "none" : "8,4",
            "marker-end": "url(#arrow)"
          }, null, 8, $j)) : Te("", !0),
          x.points && s.showPoints ? (se(), re("g", Wj, [
            (se(!0), re(Xe, null, at(x.points, (M, _) => (se(), re("g", {
              key: _,
              class: "control-point"
            }, [
              v("circle", {
                cx: M.x,
                cy: M.y,
                r: "8",
                fill: "none",
                stroke: h(w, 0.5),
                "stroke-width": "2"
              }, null, 8, jj),
              v("circle", {
                cx: M.x,
                cy: M.y,
                r: "4",
                fill: h(w, 1)
              }, null, 8, Xj),
              s.showLabels ? (se(), re("text", {
                key: 0,
                x: M.x + 12,
                y: M.y + 4,
                class: "point-label",
                fill: h(w, 0.8)
              }, ye(_ + 1), 9, Yj)) : Te("", !0),
              M.depth !== void 0 && s.showDepth ? (se(), re("text", {
                key: 1,
                x: M.x + 12,
                y: M.y + 16,
                class: "depth-label"
              }, " z: " + ye(M.depth.toFixed(2)), 9, qj)) : Te("", !0)
            ]))), 128))
          ])) : Te("", !0)
        ], 10, Hj))), 128)),
        (se(!0), re(Xe, null, at(d.value, (x, w) => (se(), re("g", {
          key: `cam-${w}`
        }, [
          v("g", {
            class: Le(["camera-indicator", { selected: s.selectedIndex === w }])
          }, [
            v("rect", {
              x: x.startX - 12,
              y: x.startY - 8,
              width: "24",
              height: "16",
              rx: "2",
              fill: h(w, 0.8)
            }, null, 8, Zj),
            v("circle", {
              cx: x.startX + 8,
              cy: x.startY,
              r: "4",
              fill: "none",
              stroke: h(w, 1),
              "stroke-width": "2"
            }, null, 8, Kj),
            v("line", {
              x1: x.startX,
              y1: x.startY,
              x2: x.endX,
              y2: x.endY,
              stroke: h(w, 1),
              "stroke-width": "2",
              "stroke-dasharray": "4,2",
              "marker-end": "url(#arrow)"
            }, null, 8, Jj),
            v("text", {
              x: (x.startX + x.endX) / 2,
              y: (x.startY + x.endY) / 2 - 10,
              class: "motion-label",
              fill: h(w, 1)
            }, ye(x.type), 9, Qj)
          ], 2)
        ]))), 128)),
        a.value && s.showAnimation ? (se(), re("g", eX, [
          v("circle", {
            cx: a.value.x,
            cy: a.value.y,
            r: "6",
            fill: "#fff",
            class: "animated-dot"
          }, null, 8, tX),
          v("circle", {
            cx: a.value.x,
            cy: a.value.y,
            r: "12",
            fill: "none",
            stroke: "#fff",
            "stroke-width": "2",
            opacity: "0.5",
            class: "animated-ring"
          }, null, 8, nX)
        ])) : Te("", !0)
      ], 8, zj)),
      s.suggestions.length > 0 && s.showLegend ? (se(), re("div", iX, [
        (se(!0), re(Xe, null, at(s.suggestions, (x, w) => (se(), re("div", {
          key: w,
          class: Le(["legend-item", { selected: s.selectedIndex === w }]),
          onClick: (M) => i("select", w)
        }, [
          v("span", {
            class: "legend-color",
            style: xt({ backgroundColor: h(w, 1) })
          }, null, 4),
          v("span", oX, ye(x.description || `Path ${w + 1}`), 1)
        ], 10, sX))), 128))
      ])) : Te("", !0),
      s.suggestions.length > 0 ? (se(), re("div", aX, " Click a path to select it. Press Enter to accept. ")) : Te("", !0)
    ], 4));
  }
}), lX = /* @__PURE__ */ Vt(rX, [["__scopeId", "data-v-021b36ff"]]), cX = { class: "workspace-layout" }, uX = { class: "toolbar" }, dX = { class: "tool-group" }, hX = { class: "tool-group segment-options" }, fX = {
  key: 1,
  class: "loading-indicator"
}, pX = { class: "tool-group" }, mX = ["title"], vX = { class: "icon" }, gX = { class: "timecode-display" }, yX = { class: "tool-group" }, xX = { class: "tool-group" }, bX = ["disabled"], _X = ["disabled"], wX = { class: "workspace-content" }, MX = { class: "panel left-panel" }, SX = { class: "panel-tabs" }, CX = { class: "panel-content" }, TX = { class: "panel viewport-panel" }, EX = { class: "viewport-header" }, AX = { class: "viewport-tabs" }, PX = { class: "viewport-controls" }, kX = { class: "viewport-content" }, DX = { class: "panel timeline-panel" }, IX = { class: "panel graph-editor-panel" }, RX = {
  key: 1,
  class: "panel timeline-panel"
}, LX = { class: "panel right-panel" }, FX = { class: "panel-tabs" }, OX = { class: "panel-content" }, UX = { class: "status-bar" }, zX = { class: "status-left" }, BX = { class: "status-item" }, NX = { class: "status-item" }, VX = { class: "status-center" }, HX = {
  key: 0,
  class: "render-progress"
}, GX = { class: "status-right" }, $X = { class: "status-item" }, WX = { class: "status-item" }, jX = /* @__PURE__ */ Bt({
  __name: "WorkspaceLayout",
  setup(s) {
    const e = un(), n = Re({
      get: () => e.currentTool,
      set: (H) => e.setTool(H)
    }), i = Re(() => e.segmentMode), o = Re(() => e.segmentPendingMask), a = Re(() => e.segmentIsLoading);
    function r(H) {
      e.setSegmentMode(H);
    }
    async function l() {
      await e.confirmSegmentMask();
    }
    function c() {
      e.clearSegmentPendingMask();
    }
    const u = xe("standard"), d = xe("project"), h = xe("properties"), p = xe("composition"), f = xe("fit"), m = xe(!1), y = xe(!0), g = xe(!1), x = xe(!1), w = xe(!1), M = xe(!1), _ = xe(!1), C = xe([]), T = xe(null), P = xe(!1), E = xe("cpu"), b = xe(null), S = Re(() => {
      const H = e.getActiveCameraAtFrame();
      return H || $m("default", k.value, U.value);
    }), A = xe(Wm()), R = xe({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), k = Re(() => {
      var H, X;
      return ((X = (H = e.project) == null ? void 0 : H.composition) == null ? void 0 : X.width) || 1920;
    }), U = Re(() => {
      var H, X;
      return ((X = (H = e.project) == null ? void 0 : H.composition) == null ? void 0 : X.height) || 1080;
    }), I = xe(60), W = xe("0 MB"), fe = xe(0), q = Re(() => {
      var Ae, Ve;
      const H = e.currentFrame, X = ((Ve = (Ae = e.project) == null ? void 0 : Ae.composition) == null ? void 0 : Ve.fps) || 30, ue = H / X, me = Math.floor(ue / 60), _e = Math.floor(ue % 60), we = H % X;
      return `${String(me).padStart(2, "0")}:${String(_e).padStart(2, "0")}:${String(we).padStart(2, "0")}`;
    }), G = Re(() => {
      var H, X;
      return ((X = (H = e.project) == null ? void 0 : H.meta) == null ? void 0 : X.name) || "Untitled Project";
    }), Q = Re(() => {
      var X;
      const H = (X = e.project) == null ? void 0 : X.composition;
      return H ? `${H.width}${H.height} @ ${H.fps}fps` : "No Composition";
    }), K = Re(() => e.canUndo), Y = Re(() => e.canRedo);
    function ee() {
      P.value = !P.value, P.value ? e.play() : e.pause();
    }
    function ce() {
      e.goToStart();
    }
    function ae() {
      e.goToEnd();
    }
    function de() {
      e.setFrame(e.currentFrame + 1);
    }
    function ie() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function he() {
      e.undo();
    }
    function ne() {
      e.redo();
    }
    function N(H) {
      e.activeCameraId && e.updateCamera(H.id, H);
    }
    function te() {
      console.log("[Weyl] Matte export completed");
    }
    function F(H) {
      console.log("[Weyl] ComfyUI export completed", H), w.value = !1;
    }
    function B(H) {
      console.log("[Weyl] Composition settings updated:", H), e.updateCompositionSettings(e.activeCompositionId, {
        width: H.width,
        height: H.height,
        fps: H.fps,
        frameCount: H.frameCount,
        backgroundColor: H.backgroundColor,
        autoResizeToContent: H.autoResizeToContent
      }), e.renameComposition(e.activeCompositionId, H.name), M.value = !1;
    }
    function L(H, X) {
      if (H.length === 0) return "";
      if (H.length === 1) return `M ${H[0].x} ${H[0].y}`;
      let ue = `M ${H[0].x} ${H[0].y}`;
      for (let me = 0; me < H.length - 1; me++) {
        const _e = H[me], we = H[me + 1];
        if (_e.handleOut && we.handleIn) {
          const Ae = _e.x + _e.handleOut.x, Ve = _e.y + _e.handleOut.y, Fe = we.x + we.handleIn.x, $e = we.y + we.handleIn.y;
          ue += ` C ${Ae} ${Ve}, ${Fe} ${$e}, ${we.x} ${we.y}`;
        } else if (_e.handleOut) {
          const Ae = _e.x + _e.handleOut.x, Ve = _e.y + _e.handleOut.y;
          ue += ` Q ${Ae} ${Ve}, ${we.x} ${we.y}`;
        } else if (we.handleIn) {
          const Ae = we.x + we.handleIn.x, Ve = we.y + we.handleIn.y;
          ue += ` Q ${Ae} ${Ve}, ${we.x} ${we.y}`;
        } else
          ue += ` L ${we.x} ${we.y}`;
      }
      return X && H.length > 2 && (ue += " Z"), ue;
    }
    function D() {
      _.value = !1, C.value = [], T.value = null;
    }
    function j(H) {
      C.value = H, T.value = H.length > 0 ? 0 : null;
    }
    function Z(H) {
      if (console.log("[Weyl] Path suggestion accepted:", H), H.keyframes && H.keyframes.length > 0)
        for (const X of H.keyframes)
          for (const ue of X.keyframes)
            e.addKeyframe(X.layerId, X.propertyPath, ue.frame, ue.value, ue.easing);
      if (H.splines && H.splines.length > 0)
        for (const X of H.splines) {
          const ue = e.createSplineLayer();
          X.name && e.renameLayer(ue.id, X.name);
          const me = (X.points || []).map((we, Ae) => ({
            id: we.id || `cp_${Date.now()}_${Ae}`,
            x: we.x,
            y: we.y,
            depth: we.depth ?? 0,
            // Preserve z-space depth
            handleIn: we.handleIn || null,
            // Preserve bezier handles from translator
            handleOut: we.handleOut || null,
            type: we.type || "smooth"
          })), _e = L(me, X.closed || !1);
          e.updateLayerData(ue.id, {
            controlPoints: me,
            pathData: _e,
            closed: X.closed || !1
          });
        }
      C.value = [], T.value = null, _.value = !1;
    }
    const z = Re(() => {
      const H = e.getActiveCameraAtFrame();
      return H ? e.getCameraKeyframes(H.id) : [];
    });
    function $() {
      if (b.value)
        if (f.value === "fit")
          b.value.fitToView();
        else {
          const H = parseInt(f.value) / 100;
          b.value.zoom = H;
        }
    }
    function oe(H) {
      var X, ue;
      if (!(((X = document.activeElement) == null ? void 0 : X.tagName) === "INPUT" || ((ue = document.activeElement) == null ? void 0 : ue.tagName) === "TEXTAREA"))
        switch (H.key.toLowerCase()) {
          case " ":
            H.preventDefault(), ee();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            H.ctrlKey || H.metaKey ? (H.preventDefault(), H.shiftKey ? ne() : he()) : n.value = "zoom";
            break;
          case "home":
            H.preventDefault(), ce();
            break;
          case "end":
            H.preventDefault(), ae();
            break;
          case "arrowleft":
            H.preventDefault(), ie();
            break;
          case "arrowright":
            H.preventDefault(), de();
            break;
          case "g":
            H.shiftKey && (g.value = !g.value);
            break;
          case "k":
            (H.ctrlKey || H.metaKey) && (H.preventDefault(), M.value = !0);
            break;
        }
    }
    let O;
    function V() {
      if ("memory" in performance) {
        const H = performance.memory, X = Math.round(H.usedJSHeapSize / 1024 / 1024);
        W.value = `${X} MB`;
      }
    }
    return gn(async () => {
      const H = await PM();
      E.value = H.tier, window.addEventListener("keydown", oe), O = window.setInterval(V, 1e3);
    }), Un(() => {
      window.removeEventListener("keydown", oe), clearInterval(O);
    }), (H, X) => (se(), re("div", cX, [
      v("div", uX, [
        v("div", dX, [
          v("button", {
            class: Le({ active: n.value === "select" }),
            onClick: X[0] || (X[0] = (ue) => n.value = "select"),
            title: "Select (V)"
          }, [...X[32] || (X[32] = [
            v("span", { class: "icon" }, "", -1)
          ])], 2),
          v("button", {
            class: Le({ active: n.value === "pen" }),
            onClick: X[1] || (X[1] = (ue) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...X[33] || (X[33] = [
            v("span", { class: "icon" }, "", -1)
          ])], 2),
          v("button", {
            class: Le({ active: n.value === "text" }),
            onClick: X[2] || (X[2] = (ue) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...X[34] || (X[34] = [
            v("span", { class: "icon" }, "T", -1)
          ])], 2),
          v("button", {
            class: Le({ active: n.value === "hand" }),
            onClick: X[3] || (X[3] = (ue) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...X[35] || (X[35] = [
            v("span", { class: "icon" }, "", -1)
          ])], 2),
          v("button", {
            class: Le({ active: n.value === "zoom" }),
            onClick: X[4] || (X[4] = (ue) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...X[36] || (X[36] = [
            v("span", { class: "icon" }, "", -1)
          ])], 2),
          v("button", {
            class: Le({ active: n.value === "segment" }),
            onClick: X[5] || (X[5] = (ue) => n.value = "segment"),
            title: "Segment Tool (S) - Click to select objects"
          }, [...X[37] || (X[37] = [
            v("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        n.value === "segment" ? (se(), re(Xe, { key: 0 }, [
          X[43] || (X[43] = v("div", { class: "divider" }, null, -1)),
          v("div", hX, [
            v("button", {
              class: Le({ active: i.value === "point" }),
              onClick: X[6] || (X[6] = (ue) => r("point")),
              title: "Point Mode - Click to segment"
            }, [...X[38] || (X[38] = [
              v("span", { class: "icon" }, "", -1),
              ct(" Point ", -1)
            ])], 2),
            v("button", {
              class: Le({ active: i.value === "box" }),
              onClick: X[7] || (X[7] = (ue) => r("box")),
              title: "Box Mode - Draw rectangle to segment"
            }, [...X[39] || (X[39] = [
              v("span", { class: "icon" }, "", -1),
              ct(" Box ", -1)
            ])], 2),
            o.value ? (se(), re(Xe, { key: 0 }, [
              X[42] || (X[42] = v("div", { class: "divider" }, null, -1)),
              v("button", {
                onClick: l,
                class: "confirm-btn",
                title: "Create Layer from Selection"
              }, [...X[40] || (X[40] = [
                v("span", { class: "icon" }, "", -1),
                ct(" Create Layer ", -1)
              ])]),
              v("button", {
                onClick: c,
                class: "cancel-btn",
                title: "Cancel Selection"
              }, [...X[41] || (X[41] = [
                v("span", { class: "icon" }, "", -1)
              ])])
            ], 64)) : Te("", !0),
            a.value ? (se(), re("span", fX, "Segmenting...")) : Te("", !0)
          ])
        ], 64)) : Te("", !0),
        X[55] || (X[55] = v("div", { class: "divider" }, null, -1)),
        v("div", pX, [
          v("button", {
            onClick: ce,
            title: "Go to Start (Home)"
          }, [...X[44] || (X[44] = [
            v("span", { class: "icon" }, "", -1)
          ])]),
          v("button", {
            onClick: ie,
            title: "Step Backward"
          }, [...X[45] || (X[45] = [
            v("span", { class: "icon" }, "", -1)
          ])]),
          v("button", {
            onClick: ee,
            title: P.value ? "Pause (Space)" : "Play (Space)"
          }, [
            v("span", vX, ye(P.value ? "" : ""), 1)
          ], 8, mX),
          v("button", {
            onClick: de,
            title: "Step Forward"
          }, [...X[46] || (X[46] = [
            v("span", { class: "icon" }, "", -1)
          ])]),
          v("button", {
            onClick: ae,
            title: "Go to End (End)"
          }, [...X[47] || (X[47] = [
            v("span", { class: "icon" }, "", -1)
          ])])
        ]),
        v("div", gX, ye(q.value), 1),
        X[56] || (X[56] = v("div", { class: "divider" }, null, -1)),
        v("div", yX, [
          st(v("select", {
            "onUpdate:modelValue": X[8] || (X[8] = (ue) => u.value = ue),
            class: "workspace-selector"
          }, [...X[48] || (X[48] = [
            v("option", { value: "standard" }, "Standard", -1),
            v("option", { value: "animation" }, "Animation", -1),
            v("option", { value: "effects" }, "Effects", -1),
            v("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [En, u.value]
          ])
        ]),
        X[57] || (X[57] = v("div", { class: "spacer" }, null, -1)),
        v("div", xX, [
          v("span", {
            class: Le(["gpu-badge", E.value])
          }, ye(E.value.toUpperCase()), 3),
          v("button", {
            onClick: he,
            disabled: !K.value,
            title: "Undo (Ctrl+Z)"
          }, [...X[49] || (X[49] = [
            v("span", { class: "icon" }, "", -1)
          ])], 8, bX),
          v("button", {
            onClick: ne,
            disabled: !Y.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...X[50] || (X[50] = [
            v("span", { class: "icon" }, "", -1)
          ])], 8, _X),
          X[54] || (X[54] = v("div", { class: "divider" }, null, -1)),
          v("button", {
            onClick: X[9] || (X[9] = (ue) => _.value = !0),
            title: "AI Path Suggestion",
            class: "ai-btn"
          }, [...X[51] || (X[51] = [
            v("span", { class: "icon" }, "", -1),
            ct(" AI ", -1)
          ])]),
          v("button", {
            onClick: X[10] || (X[10] = (ue) => x.value = !0),
            title: "Export Matte"
          }, [...X[52] || (X[52] = [
            v("span", { class: "icon" }, "", -1),
            ct(" Matte ", -1)
          ])]),
          v("button", {
            onClick: X[11] || (X[11] = (ue) => w.value = !0),
            title: "Export to ComfyUI"
          }, [...X[53] || (X[53] = [
            v("span", { class: "icon" }, "", -1),
            ct(" ComfyUI ", -1)
          ])])
        ])
      ]),
      v("div", wX, [
        Ne(He(Wu), { class: "default-theme horizontal-split" }, {
          default: ss(() => [
            Ne(He(N0), {
              size: 12,
              "min-size": 8,
              "max-size": 20
            }, {
              default: ss(() => [
                v("div", MX, [
                  v("div", SX, [
                    v("button", {
                      class: Le({ active: d.value === "project" }),
                      onClick: X[12] || (X[12] = (ue) => d.value = "project")
                    }, " Project ", 2),
                    v("button", {
                      class: Le({ active: d.value === "effects" }),
                      onClick: X[13] || (X[13] = (ue) => d.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  v("div", CX, [
                    d.value === "project" ? (se(), Tt(iS, {
                      key: 0,
                      onOpenCompositionSettings: X[14] || (X[14] = (ue) => M.value = !0)
                    })) : d.value === "effects" ? (se(), Tt(OS, { key: 1 })) : Te("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            Ne(He(N0), {
              size: 70,
              "min-size": 40
            }, {
              default: ss(() => [
                Ne(He(Wu), {
                  horizontal: "",
                  class: "default-theme"
                }, {
                  default: ss(() => [
                    Ne(He(N0), {
                      size: 65,
                      "min-size": 20
                    }, {
                      default: ss(() => [
                        v("div", TX, [
                          v("div", EX, [
                            v("div", AX, [
                              v("button", {
                                class: Le({ active: p.value === "composition" }),
                                onClick: X[15] || (X[15] = (ue) => p.value = "composition")
                              }, " Composition ", 2),
                              v("button", {
                                class: Le({ active: p.value === "layer" }),
                                onClick: X[16] || (X[16] = (ue) => p.value = "layer")
                              }, " Layer ", 2),
                              v("button", {
                                class: Le({ active: p.value === "footage" }),
                                onClick: X[17] || (X[17] = (ue) => p.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            v("div", PX, [
                              st(v("select", {
                                "onUpdate:modelValue": X[18] || (X[18] = (ue) => f.value = ue),
                                onChange: $,
                                class: "zoom-select"
                              }, [...X[58] || (X[58] = [
                                v("option", { value: "fit" }, "Fit", -1),
                                v("option", { value: "25" }, "25%", -1),
                                v("option", { value: "50" }, "50%", -1),
                                v("option", { value: "75" }, "75%", -1),
                                v("option", { value: "100" }, "100%", -1),
                                v("option", { value: "150" }, "150%", -1),
                                v("option", { value: "200" }, "200%", -1)
                              ])], 544), [
                                [En, f.value]
                              ]),
                              v("button", {
                                class: Le({ active: m.value }),
                                onClick: X[19] || (X[19] = (ue) => m.value = !m.value),
                                title: "Toggle Guides"
                              }, [...X[59] || (X[59] = [
                                v("span", { class: "icon" }, "", -1)
                              ])], 2),
                              v("button", {
                                class: Le({ active: y.value }),
                                onClick: X[20] || (X[20] = (ue) => y.value = !y.value),
                                title: "Toggle Grid"
                              }, [...X[60] || (X[60] = [
                                v("span", { class: "icon" }, "", -1)
                              ])], 2)
                            ])
                          ]),
                          v("div", kX, [
                            p.value === "composition" ? (se(), Tt(EV, {
                              key: 0,
                              ref_key: "threeCanvasRef",
                              ref: b
                            }, null, 512)) : (se(), Tt(iB, {
                              key: 1,
                              camera: S.value,
                              viewportState: A.value,
                              viewOptions: R.value,
                              compWidth: k.value,
                              compHeight: U.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    Ne(He(N0), {
                      size: 35,
                      "min-size": 15
                    }, {
                      default: ss(() => [
                        g.value ? (se(), Tt(He(Wu), {
                          key: 0,
                          horizontal: "",
                          class: "default-theme"
                        }, {
                          default: ss(() => [
                            Ne(He(N0), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: ss(() => [
                                v("div", DX, [
                                  Ne(c9, {
                                    onOpenCompositionSettings: X[21] || (X[21] = (ue) => M.value = !0)
                                  })
                                ])
                              ]),
                              _: 1
                            }),
                            Ne(He(N0), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: ss(() => [
                                v("div", IX, [
                                  Ne(vG, {
                                    onClose: X[22] || (X[22] = (ue) => g.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : (se(), re("div", RX, [
                          Ne(c9, {
                            onOpenCompositionSettings: X[23] || (X[23] = (ue) => M.value = !0)
                          })
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            Ne(He(N0), {
              size: 18,
              "min-size": 12,
              "max-size": 25
            }, {
              default: ss(() => [
                v("div", LX, [
                  v("div", FX, [
                    v("button", {
                      class: Le({ active: h.value === "effects" }),
                      onClick: X[24] || (X[24] = (ue) => h.value = "effects")
                    }, " Effects ", 2),
                    v("button", {
                      class: Le({ active: h.value === "properties" }),
                      onClick: X[25] || (X[25] = (ue) => h.value = "properties")
                    }, " Props ", 2),
                    v("button", {
                      class: Le({ active: h.value === "camera" }),
                      onClick: X[26] || (X[26] = (ue) => h.value = "camera")
                    }, " Cam ", 2),
                    v("button", {
                      class: Le({ active: h.value === "audio" }),
                      onClick: X[27] || (X[27] = (ue) => h.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  v("div", OX, [
                    h.value === "effects" ? (se(), Tt(oT, { key: 0 })) : h.value === "properties" ? (se(), Tt(IF, { key: 1 })) : h.value === "camera" ? (se(), Tt(uU, {
                      key: 2,
                      camera: S.value,
                      "onUpdate:camera": N
                    }, null, 8, ["camera"])) : h.value === "audio" ? (se(), Tt(Fz, { key: 3 })) : Te("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      v("div", UX, [
        v("div", zX, [
          v("span", BX, ye(G.value), 1),
          X[61] || (X[61] = v("span", { class: "status-divider" }, "|", -1)),
          v("span", NX, ye(Q.value), 1)
        ]),
        v("div", VX, [
          fe.value > 0 ? (se(), re("span", HX, " Rendering: " + ye(Math.round(fe.value * 100)) + "% ", 1)) : Te("", !0)
        ]),
        v("div", GX, [
          v("span", $X, ye(W.value), 1),
          X[62] || (X[62] = v("span", { class: "status-divider" }, "|", -1)),
          v("span", WX, ye(I.value) + " fps", 1)
        ])
      ]),
      x.value ? (se(), Tt(JG, {
        key: 0,
        onClose: X[28] || (X[28] = (ue) => x.value = !1),
        onExported: te
      })) : Te("", !0),
      w.value ? (se(), Tt(_W, {
        key: 1,
        layers: He(e).layers,
        "camera-keyframes": z.value,
        "current-frame": He(e).currentFrame,
        "total-frames": He(e).frameCount,
        onClose: X[29] || (X[29] = (ue) => w.value = !1),
        onExported: F
      }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : Te("", !0),
      Ne(QW, {
        visible: M.value,
        onClose: X[30] || (X[30] = (ue) => M.value = !1),
        onConfirm: B
      }, null, 8, ["visible"]),
      Ne(Uj, {
        visible: _.value,
        onClose: D,
        onAccept: Z,
        onPreview: j
      }, null, 8, ["visible"]),
      C.value.length > 0 ? (se(), Tt(R0, {
        key: 2,
        to: ".viewport-content"
      }, [
        Ne(lX, {
          width: k.value,
          height: U.value,
          suggestions: C.value,
          selectedIndex: T.value,
          onSelect: X[31] || (X[31] = (ue) => T.value = ue)
        }, null, 8, ["width", "height", "suggestions", "selectedIndex"])
      ])) : Te("", !0)
    ]));
  }
}), XX = /* @__PURE__ */ Vt(jX, [["__scopeId", "data-v-05c5905a"]]), YX = /* @__PURE__ */ Bt({
  __name: "App",
  setup(s) {
    return (e, n) => (se(), Tt(XX));
  }
}), I5 = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
], R5 = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function L5(s) {
  const e = { r: 0, g: 0, b: 0, a: 0, next: null };
  let n = e;
  for (let i = 1; i < s; i++)
    n.next = { r: 0, g: 0, b: 0, a: 0, next: null }, n = n.next;
  return n.next = e, e;
}
function F5(s, e, n) {
  const i = s.data, o = s.width, a = s.height;
  e = Math.max(0, Math.min(255, Math.round(e))), n = Math.max(0, Math.min(255, Math.round(n))), !(e === 0 && n === 0) && (e > 0 && qX(i, o, a, e), n > 0 && ZX(i, o, a, n));
}
function qX(s, e, n, i) {
  const o = i + i + 1, a = e - 1, r = I5[i], l = R5[i], c = L5(o);
  for (let u = 0; u < n; u++) {
    let d = 0, h = 0, p = 0, f = 0, m = 0, y = 0, g = 0, x = 0, w = 0, M = 0, _ = 0, C = 0;
    const T = u * e;
    let P = c, E = c;
    const b = s[T * 4], S = s[T * 4 + 1], A = s[T * 4 + 2], R = s[T * 4 + 3];
    for (let U = 0; U <= i; U++) {
      P.r = b, P.g = S, P.b = A, P.a = R;
      const I = i + 1 - U;
      w += b * I, M += S * I, _ += A * I, C += R * I, U > 0 ? (d += b, h += S, p += A, f += R) : (m += b, y += S, g += A, x += R), P = P.next;
    }
    for (let U = 1; U <= i; U++) {
      const I = Math.min(U, a), W = (T + I) * 4, fe = s[W], q = s[W + 1], G = s[W + 2], Q = s[W + 3];
      P.r = fe, P.g = q, P.b = G, P.a = Q;
      const K = i + 1 - U;
      w += fe * K, M += q * K, _ += G * K, C += Q * K, d += fe, h += q, p += G, f += Q, P = P.next;
    }
    let k = c;
    for (let U = 0; U < i; U++)
      k = k.next;
    E = k.next;
    for (let U = 0; U < e; U++) {
      const I = (T + U) * 4;
      s[I] = w * r >>> l, s[I + 1] = M * r >>> l, s[I + 2] = _ * r >>> l, s[I + 3] = C * r >>> l, w -= m, M -= y, _ -= g, C -= x, m -= k.r, y -= k.g, g -= k.b, x -= k.a;
      const W = Math.min(U + i + 1, a), fe = (T + W) * 4;
      k.r = s[fe], k.g = s[fe + 1], k.b = s[fe + 2], k.a = s[fe + 3], d += k.r, h += k.g, p += k.b, f += k.a, w += d, M += h, _ += p, C += f, k = k.next, m += E.r, y += E.g, g += E.b, x += E.a, d -= E.r, h -= E.g, p -= E.b, f -= E.a, E = E.next;
    }
  }
}
function ZX(s, e, n, i) {
  const o = i + i + 1, a = n - 1, r = I5[i], l = R5[i], c = L5(o);
  for (let u = 0; u < e; u++) {
    let d = 0, h = 0, p = 0, f = 0, m = 0, y = 0, g = 0, x = 0, w = 0, M = 0, _ = 0, C = 0, T = c, P = c;
    const E = s[u * 4], b = s[u * 4 + 1], S = s[u * 4 + 2], A = s[u * 4 + 3];
    for (let k = 0; k <= i; k++) {
      T.r = E, T.g = b, T.b = S, T.a = A;
      const U = i + 1 - k;
      w += E * U, M += b * U, _ += S * U, C += A * U, k > 0 ? (d += E, h += b, p += S, f += A) : (m += E, y += b, g += S, x += A), T = T.next;
    }
    for (let k = 1; k <= i; k++) {
      const I = (Math.min(k, a) * e + u) * 4, W = s[I], fe = s[I + 1], q = s[I + 2], G = s[I + 3];
      T.r = W, T.g = fe, T.b = q, T.a = G;
      const Q = i + 1 - k;
      w += W * Q, M += fe * Q, _ += q * Q, C += G * Q, d += W, h += fe, p += q, f += G, T = T.next;
    }
    let R = c;
    for (let k = 0; k < i; k++)
      R = R.next;
    P = R.next;
    for (let k = 0; k < n; k++) {
      const U = (k * e + u) * 4;
      s[U] = w * r >>> l, s[U + 1] = M * r >>> l, s[U + 2] = _ * r >>> l, s[U + 3] = C * r >>> l, w -= m, M -= y, _ -= g, C -= x, m -= R.r, y -= R.g, g -= R.b, x -= R.a;
      const W = (Math.min(k + i + 1, a) * e + u) * 4;
      R.r = s[W], R.g = s[W + 1], R.b = s[W + 2], R.a = s[W + 3], d += R.r, h += R.g, p += R.b, f += R.a, w += d, M += h, _ += p, C += f, R = R.next, m += P.r, y += P.g, g += P.b, x += P.a, d -= P.r, h -= P.g, p -= P.b, f -= P.a, P = P.next;
    }
  }
}
function KX(s, e) {
  const n = e.blurriness ?? 10, i = e.blur_dimensions ?? "both";
  if (n <= 0)
    return s;
  const o = On(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height);
  let r = 0, l = 0;
  switch (i) {
    case "horizontal":
      r = n;
      break;
    case "vertical":
      l = n;
      break;
    case "both":
    default:
      r = n, l = n;
      break;
  }
  return F5(a, r, l), o.ctx.putImageData(a, 0, 0), o;
}
function JX(s, e) {
  const n = (e.direction ?? 0) * Math.PI / 180, i = Math.max(0, Math.min(500, e.blur_length ?? 10));
  if (i <= 0)
    return s;
  const { width: o, height: a } = s.canvas, r = On(s.canvas), l = s.ctx.getImageData(0, 0, o, a), c = r.ctx.createImageData(o, a), u = l.data, d = c.data, h = Math.cos(n), p = Math.sin(n), f = Math.max(3, Math.ceil(i)), m = Math.floor(f / 2);
  for (let y = 0; y < a; y++)
    for (let g = 0; g < o; g++) {
      let x = 0, w = 0, M = 0, _ = 0, C = 0;
      for (let P = -m; P <= m; P++) {
        const E = Math.round(g + h * P * (i / f)), b = Math.round(y + p * P * (i / f)), S = Math.max(0, Math.min(o - 1, E)), R = (Math.max(0, Math.min(a - 1, b)) * o + S) * 4;
        x += u[R], w += u[R + 1], M += u[R + 2], _ += u[R + 3], C++;
      }
      const T = (y * o + g) * 4;
      d[T] = Math.round(x / C), d[T + 1] = Math.round(w / C), d[T + 2] = Math.round(M / C), d[T + 3] = Math.round(_ / C);
    }
  return r.ctx.putImageData(c, 0, 0), r;
}
function QX(s, e) {
  const n = e.type ?? "spin", i = Math.max(0, Math.min(100, e.amount ?? 10)), o = (e.center_x ?? 50) / 100, a = (e.center_y ?? 50) / 100, r = e.quality ?? "good";
  if (i <= 0)
    return s;
  const { width: l, height: c } = s.canvas, u = On(s.canvas), d = s.ctx.getImageData(0, 0, l, c), h = u.ctx.createImageData(l, c), p = d.data, f = h.data, m = o * l, y = a * c, g = r === "best" ? 32 : r === "good" ? 16 : 8;
  if (n === "spin") {
    const x = i / 100 * Math.PI * 0.5;
    for (let w = 0; w < c; w++)
      for (let M = 0; M < l; M++) {
        let _ = 0, C = 0, T = 0, P = 0;
        const E = M - m, b = w - y, S = Math.sqrt(E * E + b * b), A = Math.atan2(b, E);
        for (let k = 0; k < g; k++) {
          const U = k / (g - 1) - 0.5, I = A + U * x, W = Math.round(m + Math.cos(I) * S), fe = Math.round(y + Math.sin(I) * S), q = Math.max(0, Math.min(l - 1, W)), Q = (Math.max(0, Math.min(c - 1, fe)) * l + q) * 4;
          _ += p[Q], C += p[Q + 1], T += p[Q + 2], P += p[Q + 3];
        }
        const R = (w * l + M) * 4;
        f[R] = Math.round(_ / g), f[R + 1] = Math.round(C / g), f[R + 2] = Math.round(T / g), f[R + 3] = Math.round(P / g);
      }
  } else {
    const x = i / 100;
    for (let w = 0; w < c; w++)
      for (let M = 0; M < l; M++) {
        let _ = 0, C = 0, T = 0, P = 0;
        const E = M - m, b = w - y;
        for (let A = 0; A < g; A++) {
          const k = 1 - A / (g - 1) * x, U = Math.round(m + E * k), I = Math.round(y + b * k), W = Math.max(0, Math.min(l - 1, U)), q = (Math.max(0, Math.min(c - 1, I)) * l + W) * 4;
          _ += p[q], C += p[q + 1], T += p[q + 2], P += p[q + 3];
        }
        const S = (w * l + M) * 4;
        f[S] = Math.round(_ / g), f[S + 1] = Math.round(C / g), f[S + 2] = Math.round(T / g), f[S + 3] = Math.round(P / g);
      }
  }
  return u.ctx.putImageData(h, 0, 0), u;
}
function eY(s, e) {
  const n = Math.max(0, Math.min(100, Math.round(e.radius ?? 5))), i = Math.max(1, Math.min(5, e.iterations ?? 1));
  if (n <= 0)
    return s;
  const { width: o, height: a } = s.canvas;
  let r = On(s.canvas);
  r.ctx.drawImage(s.canvas, 0, 0);
  for (let l = 0; l < i; l++) {
    const c = r.ctx.getImageData(0, 0, o, a), u = c.data, d = new Uint8ClampedArray(u.length), h = n * 2 + 1;
    for (let p = 0; p < a; p++)
      for (let f = 0; f < o; f++) {
        let m = 0, y = 0, g = 0, x = 0;
        for (let M = -n; M <= n; M++) {
          const _ = Math.max(0, Math.min(o - 1, f + M)), C = (p * o + _) * 4;
          m += u[C], y += u[C + 1], g += u[C + 2], x += u[C + 3];
        }
        const w = (p * o + f) * 4;
        d[w] = Math.round(m / h), d[w + 1] = Math.round(y / h), d[w + 2] = Math.round(g / h), d[w + 3] = Math.round(x / h);
      }
    u.set(d);
    for (let p = 0; p < a; p++)
      for (let f = 0; f < o; f++) {
        let m = 0, y = 0, g = 0, x = 0;
        for (let M = -n; M <= n; M++) {
          const C = (Math.max(0, Math.min(a - 1, p + M)) * o + f) * 4;
          m += u[C], y += u[C + 1], g += u[C + 2], x += u[C + 3];
        }
        const w = (p * o + f) * 4;
        d[w] = Math.round(m / h), d[w + 1] = Math.round(y / h), d[w + 2] = Math.round(g / h), d[w + 3] = Math.round(x / h);
      }
    c.data.set(d), r.ctx.putImageData(c, 0, 0);
  }
  return r;
}
function tY(s, e) {
  const n = (e.amount ?? 100) / 100, i = Math.max(1, Math.min(100, e.radius ?? 1)), o = e.threshold ?? 0;
  if (n <= 0)
    return s;
  const { width: a, height: r } = s.canvas, l = On(s.canvas);
  l.ctx.drawImage(s.canvas, 0, 0);
  const c = l.ctx.getImageData(0, 0, a, r);
  F5(c, i, i);
  const u = On(s.canvas), d = s.ctx.getImageData(0, 0, a, r), h = d.data, p = c.data;
  for (let f = 0; f < h.length; f += 4)
    for (let m = 0; m < 3; m++) {
      const y = h[f + m] - p[f + m];
      if (Math.abs(y) >= o) {
        const g = h[f + m] + y * n;
        h[f + m] = Math.max(0, Math.min(255, Math.round(g)));
      }
    }
  return u.ctx.putImageData(d, 0, 0), u;
}
function nY() {
  Bn("gaussian-blur", KX), Bn("directional-blur", JX), Bn("radial-blur", QX), Bn("box-blur", eY), Bn("sharpen", tY);
}
function iY(s, e) {
  const n = (e.brightness ?? 0) / 100, i = (e.contrast ?? 0) / 100, o = e.use_legacy ?? !1;
  if (n === 0 && i === 0)
    return s;
  const a = On(s.canvas), r = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = r.data, c = o ? 1 + i : 259 * (i * 255 + 255) / (255 * (259 - i * 255));
  for (let u = 0; u < l.length; u += 4) {
    let d = l[u], h = l[u + 1], p = l[u + 2];
    d += n * 255, h += n * 255, p += n * 255, d = c * (d - 128) + 128, h = c * (h - 128) + 128, p = c * (p - 128) + 128, l[u] = Math.max(0, Math.min(255, d)), l[u + 1] = Math.max(0, Math.min(255, h)), l[u + 2] = Math.max(0, Math.min(255, p));
  }
  return a.ctx.putImageData(r, 0, 0), a;
}
function O5(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), o = Math.min(s, e, n), a = (i + o) / 2;
  let r = 0, l = 0;
  if (i !== o) {
    const c = i - o;
    switch (l = a > 0.5 ? c / (2 - i - o) : c / (i + o), i) {
      case s:
        r = ((e - n) / c + (e < n ? 6 : 0)) / 6;
        break;
      case e:
        r = ((n - s) / c + 2) / 6;
        break;
      case n:
        r = ((s - e) / c + 4) / 6;
        break;
    }
  }
  return [r, l, a];
}
function U5(s, e, n) {
  let i, o, a;
  if (e === 0)
    i = o = a = n;
  else {
    const r = (u, d, h) => (h < 0 && (h += 1), h > 1 && (h -= 1), h < 0.16666666666666666 ? u + (d - u) * 6 * h : h < 0.5 ? d : h < 0.6666666666666666 ? u + (d - u) * (0.6666666666666666 - h) * 6 : u), l = n < 0.5 ? n * (1 + e) : n + e - n * e, c = 2 * n - l;
    i = r(c, l, s + 1 / 3), o = r(c, l, s), a = r(c, l, s - 1 / 3);
  }
  return [Math.round(i * 255), Math.round(o * 255), Math.round(a * 255)];
}
function sY(s, e) {
  const n = (e.master_hue ?? 0) / 360, i = (e.master_saturation ?? 0) / 100, o = (e.master_lightness ?? 0) / 100, a = e.colorize ?? !1;
  if (n === 0 && i === 0 && o === 0 && !a)
    return s;
  const r = On(s.canvas), l = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), c = l.data;
  for (let u = 0; u < c.length; u += 4) {
    const d = c[u], h = c[u + 1], p = c[u + 2];
    let [f, m, y] = O5(d, h, p);
    a ? (f = n, m = Math.abs(i) + 0.25) : (f = (f + n) % 1, f < 0 && (f += 1), m = m + m * i), y = y + y * o, m = Math.max(0, Math.min(1, m)), y = Math.max(0, Math.min(1, y));
    const [g, x, w] = U5(f, m, y);
    c[u] = g, c[u + 1] = x, c[u + 2] = w;
  }
  return r.ctx.putImageData(l, 0, 0), r;
}
function oY(s, e) {
  const n = e.input_black ?? 0, i = e.input_white ?? 255, o = e.gamma ?? 1, a = e.output_black ?? 0, r = e.output_white ?? 255;
  if (n === 0 && i === 255 && o === 1 && a === 0 && r === 255)
    return s;
  const l = On(s.canvas), c = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), u = c.data, d = new Uint8Array(256), h = i - n, p = r - a;
  for (let f = 0; f < 256; f++) {
    let m = (f - n) / h;
    m = Math.max(0, Math.min(1, m)), m = Math.pow(m, 1 / o), m = a + m * p, m = Math.max(0, Math.min(255, m)), d[f] = Math.round(m);
  }
  for (let f = 0; f < u.length; f += 4)
    u[f] = d[u[f]], u[f + 1] = d[u[f + 1]], u[f + 2] = d[u[f + 2]];
  return l.ctx.putImageData(c, 0, 0), l;
}
function aY(s, e) {
  const n = e.map_black_to ?? { r: 0, g: 0, b: 0 }, i = e.map_white_to ?? { r: 255, g: 255, b: 255 }, o = (e.amount_to_tint ?? 100) / 100;
  if (o === 0)
    return s;
  const a = On(s.canvas), r = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = r.data;
  for (let c = 0; c < l.length; c += 4) {
    const u = l[c], d = l[c + 1], h = l[c + 2], p = (u * 0.299 + d * 0.587 + h * 0.114) / 255, f = n.r + (i.r - n.r) * p, m = n.g + (i.g - n.g) * p, y = n.b + (i.b - n.b) * p;
    l[c] = Math.round(u + (f - u) * o), l[c + 1] = Math.round(d + (m - d) * o), l[c + 2] = Math.round(h + (y - h) * o);
  }
  return a.ctx.putImageData(r, 0, 0), a;
}
function rY(s, e, n, i, o) {
  const a = o * o, r = a * o, l = 1 - o, c = l * l;
  return c * l * s + 3 * c * o * e + 3 * l * a * n + r * i;
}
function ir(s) {
  const e = new Uint8Array(256);
  if (!s || s.length === 0) {
    for (let i = 0; i < 256; i++)
      e[i] = i;
    return e;
  }
  if (s.length === 1) {
    for (let i = 0; i < 256; i++)
      e[i] = Math.max(0, Math.min(255, Math.round(s[0].y)));
    return e;
  }
  const n = [...s].sort((i, o) => i.x - o.x);
  n[0].x > 0 && n.unshift({ x: 0, y: n[0].y }), n[n.length - 1].x < 255 && n.push({ x: 255, y: n[n.length - 1].y });
  for (let i = 0; i < 256; i++) {
    let o = 0;
    for (let f = 0; f < n.length - 1; f++)
      if (i >= n[f].x && i <= n[f + 1].x) {
        o = f;
        break;
      }
    const a = n[o], r = n[o + 1], l = (i - a.x) / (r.x - a.x || 1);
    let c = 0, u = 0;
    if (o > 0) {
      const f = n[o - 1];
      c = (r.y - f.y) / (r.x - f.x || 1) * (r.x - a.x);
    }
    if (o < n.length - 2) {
      const f = n[o + 2];
      u = (f.y - a.y) / (f.x - a.x || 1) * (r.x - a.x);
    }
    const d = a.y + c / 3, h = r.y - u / 3, p = rY(a.y, d, h, r.y, l);
    e[i] = Math.max(0, Math.min(255, Math.round(p)));
  }
  return e;
}
function lY(s, e) {
  const n = e.master_curve, i = e.red_curve, o = e.green_curve, a = e.blue_curve, r = e.alpha_curve, l = (e.blend_with_original ?? 100) / 100;
  if (!(n || i || o || a || r) || l === 0)
    return s;
  const u = ir(n ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), d = ir(i ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), h = ir(o ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), p = ir(a ?? [{ x: 0, y: 0 }, { x: 255, y: 255 }]), f = r ? ir(r) : null, m = On(s.canvas), y = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), g = y.data;
  for (let x = 0; x < g.length; x += 4) {
    const w = g[x], M = g[x + 1], _ = g[x + 2], C = g[x + 3];
    let T = u[w], P = u[M], E = u[_];
    T = d[T], P = h[P], E = p[E];
    const b = f ? f[C] : C;
    l < 1 && (T = Math.round(w + (T - w) * l), P = Math.round(M + (P - M) * l), E = Math.round(_ + (E - _) * l)), g[x] = T, g[x + 1] = P, g[x + 2] = E, g[x + 3] = b;
  }
  return m.ctx.putImageData(y, 0, 0), m;
}
function cY(s, e) {
  const n = e.glow_threshold ?? 128, i = e.glow_radius ?? 20, o = (e.glow_intensity ?? 100) / 100, a = e.glow_operation ?? "add";
  if (o === 0 || i === 0)
    return s;
  const { width: r, height: l } = s.canvas, c = On(s.canvas), u = document.createElement("canvas");
  u.width = r, u.height = l;
  const d = u.getContext("2d"), h = s.ctx.getImageData(0, 0, r, l), p = d.createImageData(r, l);
  for (let y = 0; y < h.data.length; y += 4) {
    const g = h.data[y], x = h.data[y + 1], w = h.data[y + 2], M = h.data[y + 3], _ = g * 0.299 + x * 0.587 + w * 0.114;
    if (_ > n) {
      const C = (_ - n) / (255 - n) * o;
      p.data[y] = Math.min(255, g * C), p.data[y + 1] = Math.min(255, x * C), p.data[y + 2] = Math.min(255, w * C), p.data[y + 3] = M;
    } else
      p.data[y] = 0, p.data[y + 1] = 0, p.data[y + 2] = 0, p.data[y + 3] = 0;
  }
  d.putImageData(p, 0, 0);
  const f = document.createElement("canvas");
  f.width = r, f.height = l;
  const m = f.getContext("2d");
  switch (m.filter = `blur(${i}px)`, m.drawImage(u, 0, 0), c.ctx.drawImage(s.canvas, 0, 0), a) {
    case "screen":
      c.ctx.globalCompositeOperation = "screen";
      break;
    case "lighten":
      c.ctx.globalCompositeOperation = "lighten";
      break;
    case "add":
    default:
      c.ctx.globalCompositeOperation = "lighter";
      break;
  }
  return c.ctx.drawImage(f, 0, 0), c.ctx.globalCompositeOperation = "source-over", c;
}
function uY(s, e) {
  const n = e.shadow_color ?? { r: 0, g: 0, b: 0 }, i = (e.opacity ?? 50) / 100, o = (e.direction ?? 135) * Math.PI / 180, a = e.distance ?? 5, r = e.softness ?? 5, l = e.shadow_only ?? !1, c = On(s.canvas), { width: u, height: d } = s.canvas, h = Math.cos(o) * a, p = Math.sin(o) * a;
  return c.ctx.shadowColor = `rgba(${n.r}, ${n.g}, ${n.b}, ${i})`, c.ctx.shadowBlur = r, c.ctx.shadowOffsetX = h, c.ctx.shadowOffsetY = p, c.ctx.drawImage(s.canvas, 0, 0), c.ctx.shadowColor = "transparent", c.ctx.shadowBlur = 0, c.ctx.shadowOffsetX = 0, c.ctx.shadowOffsetY = 0, l || c.ctx.drawImage(s.canvas, 0, 0), c;
}
function dY(s, e) {
  const n = (e.shadow_red ?? 0) / 100, i = (e.shadow_green ?? 0) / 100, o = (e.shadow_blue ?? 0) / 100, a = (e.midtone_red ?? 0) / 100, r = (e.midtone_green ?? 0) / 100, l = (e.midtone_blue ?? 0) / 100, c = (e.highlight_red ?? 0) / 100, u = (e.highlight_green ?? 0) / 100, d = (e.highlight_blue ?? 0) / 100, h = e.preserve_luminosity ?? !0;
  if (n === 0 && i === 0 && o === 0 && a === 0 && r === 0 && l === 0 && c === 0 && u === 0 && d === 0)
    return s;
  const p = On(s.canvas), f = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), m = f.data;
  for (let y = 0; y < m.length; y += 4) {
    let g = m[y], x = m[y + 1], w = m[y + 2];
    const M = (g * 0.299 + x * 0.587 + w * 0.114) / 255, _ = Math.max(0, 1 - M * 3), C = Math.max(0, (M - 0.67) * 3), T = 1 - _ - C, P = n * _ + a * T + c * C, E = i * _ + r * T + u * C, b = o * _ + l * T + d * C;
    if (g = g + P * 255, x = x + E * 255, w = w + b * 255, h) {
      const S = (g * 0.299 + x * 0.587 + w * 0.114) / 255;
      if (S > 1e-3) {
        const A = M / S;
        g *= A, x *= A, w *= A;
      }
    }
    m[y] = Math.max(0, Math.min(255, Math.round(g))), m[y + 1] = Math.max(0, Math.min(255, Math.round(x))), m[y + 2] = Math.max(0, Math.min(255, Math.round(w)));
  }
  return p.ctx.putImageData(f, 0, 0), p;
}
function hY(s, e) {
  const n = e.exposure ?? 0, i = e.offset ?? 0, o = e.gamma ?? 1;
  if (n === 0 && i === 0 && o === 1)
    return s;
  const a = On(s.canvas), r = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = r.data, c = new Uint8Array(256), u = Math.pow(2, n), d = 1 / o;
  for (let h = 0; h < 256; h++) {
    let p = h / 255;
    p *= u, p += i, p = Math.max(0, Math.min(1, p)), p = Math.pow(p, d), c[h] = Math.round(p * 255);
  }
  for (let h = 0; h < l.length; h += 4)
    l[h] = c[l[h]], l[h + 1] = c[l[h + 1]], l[h + 2] = c[l[h + 2]];
  return a.ctx.putImageData(r, 0, 0), a;
}
function fY(s, e) {
  const n = (e.vibrance ?? 0) / 100, i = (e.saturation ?? 0) / 100;
  if (n === 0 && i === 0)
    return s;
  const o = On(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), r = a.data;
  for (let l = 0; l < r.length; l += 4) {
    let c = r[l] / 255, u = r[l + 1] / 255, d = r[l + 2] / 255;
    const h = Math.max(c, u, d), p = Math.min(c, u, d), f = h - p, m = c * 0.299 + u * 0.587 + d * 0.114, y = 1 - Math.max(0, Math.min(
      1,
      Math.abs(c - 0.8) * 2 + Math.abs(u - 0.5) * 2 + Math.abs(d - 0.3) * 3
    )), g = n * (1 - f) * (1 - y * 0.5), x = 1 + i + g;
    c = m + (c - m) * x, u = m + (u - m) * x, d = m + (d - m) * x, r[l] = Math.max(0, Math.min(255, Math.round(c * 255))), r[l + 1] = Math.max(0, Math.min(255, Math.round(u * 255))), r[l + 2] = Math.max(0, Math.min(255, Math.round(d * 255)));
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function pY(s, e) {
  const n = (e.blend ?? 100) / 100, i = e.channel ?? "rgb";
  if (n === 0)
    return s;
  const o = On(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), r = a.data;
  for (let l = 0; l < r.length; l += 4) {
    const c = r[l], u = r[l + 1], d = r[l + 2];
    let h = c, p = u, f = d;
    switch (i) {
      case "rgb":
        h = 255 - h, p = 255 - p, f = 255 - f;
        break;
      case "red":
        h = 255 - h;
        break;
      case "green":
        p = 255 - p;
        break;
      case "blue":
        f = 255 - f;
        break;
      case "hue":
      case "saturation":
      case "lightness": {
        let [m, y, g] = O5(h, p, f);
        i === "hue" ? m = (m + 0.5) % 1 : i === "saturation" ? y = 1 - y : i === "lightness" && (g = 1 - g), [h, p, f] = U5(m, y, g);
        break;
      }
    }
    n < 1 && (h = Math.round(c + (h - c) * n), p = Math.round(u + (p - u) * n), f = Math.round(d + (f - d) * n)), r[l] = h, r[l + 1] = p, r[l + 2] = f;
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function mY(s, e) {
  const n = Math.max(2, Math.min(256, e.levels ?? 6));
  if (n === 256)
    return s;
  const i = On(s.canvas), o = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), a = o.data, r = new Uint8Array(256), l = 255 / (n - 1);
  for (let c = 0; c < 256; c++) {
    const u = Math.round(c / 255 * (n - 1));
    r[c] = Math.round(u * l);
  }
  for (let c = 0; c < a.length; c += 4)
    a[c] = r[a[c]], a[c + 1] = r[a[c + 1]], a[c + 2] = r[a[c + 2]];
  return i.ctx.putImageData(o, 0, 0), i;
}
function vY(s, e) {
  const n = e.threshold ?? 128, i = On(s.canvas), o = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), a = o.data;
  for (let r = 0; r < a.length; r += 4) {
    const l = a[r], c = a[r + 1], u = a[r + 2], h = l * 0.299 + c * 0.587 + u * 0.114 >= n ? 255 : 0;
    a[r] = h, a[r + 1] = h, a[r + 2] = h;
  }
  return i.ctx.putImageData(o, 0, 0), i;
}
function gY() {
  Bn("brightness-contrast", iY), Bn("hue-saturation", sY), Bn("levels", oY), Bn("tint", aY), Bn("curves", lY), Bn("glow", cY), Bn("drop-shadow", uY), Bn("color-balance", dY), Bn("exposure", hY), Bn("vibrance", fY), Bn("invert", pY), Bn("posterize", mY), Bn("threshold", vY);
}
function yY() {
  nY(), gY();
}
let z5 = null;
function g9(s) {
  let e = null;
  if (typeof s == "string" ? e = document.getElementById(s) || document.querySelector(s) : s instanceof HTMLElement ? e = s : e = document.getElementById("weyl-compositor-root") || document.getElementById("app"), !e) return null;
  yY();
  const n = f6(YX);
  return n.use(v6()), n.mount(e), z5 = n, xY(), n;
}
function xY() {
  window.addEventListener("weyl:inputs-ready", (s) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: s.detail }));
  });
}
async function PY(s, e) {
  var n, i;
  return ((i = (n = window.WeylCompositor) == null ? void 0 : n.sendOutput) == null ? void 0 : i.call(n, s, e)) ?? !1;
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => g9()) : setTimeout(() => {
  z5 || g9();
}, 0);
const ai = r0("ProjectStorage"), Su = "/weyl/compositor";
async function bY(s, e) {
  try {
    ai.info(`Saving project${e ? ` (${e})` : ""}...`);
    const i = await (await fetch(`${Su}/save_project`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        project: s,
        project_id: e
      })
    })).json();
    return i.status === "success" ? ai.info(`Project saved: ${i.project_id}`) : ai.error(`Failed to save project: ${i.message}`), i;
  } catch (n) {
    return ai.error("Error saving project:", n), {
      status: "error",
      message: n instanceof Error ? n.message : "Unknown error"
    };
  }
}
async function _Y(s) {
  try {
    ai.info(`Loading project: ${s}...`);
    const n = await (await fetch(`${Su}/load_project/${encodeURIComponent(s)}`)).json();
    return n.status === "success" ? ai.info(`Project loaded: ${s}`) : ai.error(`Failed to load project: ${n.message}`), n;
  } catch (e) {
    return ai.error("Error loading project:", e), {
      status: "error",
      message: e instanceof Error ? e.message : "Unknown error"
    };
  }
}
async function wY() {
  var s;
  try {
    ai.info("Listing projects...");
    const n = await (await fetch(`${Su}/list_projects`)).json();
    return n.status === "success" ? ai.info(`Found ${((s = n.projects) == null ? void 0 : s.length) || 0} projects`) : ai.error(`Failed to list projects: ${n.message}`), n;
  } catch (e) {
    return ai.error("Error listing projects:", e), {
      status: "error",
      message: e instanceof Error ? e.message : "Unknown error"
    };
  }
}
async function MY(s) {
  try {
    ai.info(`Deleting project: ${s}...`);
    const n = await (await fetch(`${Su}/delete_project/${encodeURIComponent(s)}`, {
      method: "DELETE"
    })).json();
    return n.status === "success" ? ai.info(`Project deleted: ${s}`) : ai.error(`Failed to delete project: ${n.message}`), n;
  } catch (e) {
    return ai.error("Error deleting project:", e), {
      status: "error",
      message: e instanceof Error ? e.message : "Unknown error"
    };
  }
}
const sc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  deleteProject: MY,
  listProjects: wY,
  loadProject: _Y,
  saveProject: bY
}, Symbol.toStringTag, { value: "Module" }));
var oc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function SY(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function ac(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var B5 = { exports: {} };
(function(s, e) {
  var n = { env: {} };
  /*!
  
  	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  	<http://stuartk.com/jszip>
  
  	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  	JSZip uses the library pako released under the MIT license :
  	https://github.com/nodeca/pako/blob/main/LICENSE
  	*/
  (function(i) {
    s.exports = i();
  })(function() {
    return function i(o, a, r) {
      function l(d, h) {
        if (!a[d]) {
          if (!o[d]) {
            var p = typeof ac == "function" && ac;
            if (!h && p) return p(d, !0);
            if (c) return c(d, !0);
            var f = new Error("Cannot find module '" + d + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var m = a[d] = { exports: {} };
          o[d][0].call(m.exports, function(y) {
            var g = o[d][1][y];
            return l(g || y);
          }, m, m.exports, i, o, a, r);
        }
        return a[d].exports;
      }
      for (var c = typeof ac == "function" && ac, u = 0; u < r.length; u++) l(r[u]);
      return l;
    }({ 1: [function(i, o, a) {
      var r = i("./utils"), l = i("./support"), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      a.encode = function(u) {
        for (var d, h, p, f, m, y, g, x = [], w = 0, M = u.length, _ = M, C = r.getTypeOf(u) !== "string"; w < u.length; ) _ = M - w, p = C ? (d = u[w++], h = w < M ? u[w++] : 0, w < M ? u[w++] : 0) : (d = u.charCodeAt(w++), h = w < M ? u.charCodeAt(w++) : 0, w < M ? u.charCodeAt(w++) : 0), f = d >> 2, m = (3 & d) << 4 | h >> 4, y = 1 < _ ? (15 & h) << 2 | p >> 6 : 64, g = 2 < _ ? 63 & p : 64, x.push(c.charAt(f) + c.charAt(m) + c.charAt(y) + c.charAt(g));
        return x.join("");
      }, a.decode = function(u) {
        var d, h, p, f, m, y, g = 0, x = 0, w = "data:";
        if (u.substr(0, w.length) === w) throw new Error("Invalid base64 input, it looks like a data url.");
        var M, _ = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (u.charAt(u.length - 1) === c.charAt(64) && _--, u.charAt(u.length - 2) === c.charAt(64) && _--, _ % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (M = l.uint8array ? new Uint8Array(0 | _) : new Array(0 | _); g < u.length; ) d = c.indexOf(u.charAt(g++)) << 2 | (f = c.indexOf(u.charAt(g++))) >> 4, h = (15 & f) << 4 | (m = c.indexOf(u.charAt(g++))) >> 2, p = (3 & m) << 6 | (y = c.indexOf(u.charAt(g++))), M[x++] = d, m !== 64 && (M[x++] = h), y !== 64 && (M[x++] = p);
        return M;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(i, o, a) {
      var r = i("./external"), l = i("./stream/DataWorker"), c = i("./stream/Crc32Probe"), u = i("./stream/DataLengthProbe");
      function d(h, p, f, m, y) {
        this.compressedSize = h, this.uncompressedSize = p, this.crc32 = f, this.compression = m, this.compressedContent = y;
      }
      d.prototype = { getContentWorker: function() {
        var h = new l(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), p = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== p.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new l(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, d.createWorkerFrom = function(h, p, f) {
        return h.pipe(new c()).pipe(new u("uncompressedSize")).pipe(p.compressWorker(f)).pipe(new u("compressedSize")).withStreamInfo("compression", p);
      }, o.exports = d;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(i, o, a) {
      var r = i("./stream/GenericWorker");
      a.STORE = { magic: "\0\0", compressWorker: function() {
        return new r("STORE compression");
      }, uncompressWorker: function() {
        return new r("STORE decompression");
      } }, a.DEFLATE = i("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(i, o, a) {
      var r = i("./utils"), l = function() {
        for (var c, u = [], d = 0; d < 256; d++) {
          c = d;
          for (var h = 0; h < 8; h++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
          u[d] = c;
        }
        return u;
      }();
      o.exports = function(c, u) {
        return c !== void 0 && c.length ? r.getTypeOf(c) !== "string" ? function(d, h, p, f) {
          var m = l, y = f + p;
          d ^= -1;
          for (var g = f; g < y; g++) d = d >>> 8 ^ m[255 & (d ^ h[g])];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : function(d, h, p, f) {
          var m = l, y = f + p;
          d ^= -1;
          for (var g = f; g < y; g++) d = d >>> 8 ^ m[255 & (d ^ h.charCodeAt(g))];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(i, o, a) {
      a.base64 = !1, a.binary = !1, a.dir = !1, a.createFolders = !0, a.date = null, a.compression = null, a.compressionOptions = null, a.comment = null, a.unixPermissions = null, a.dosPermissions = null;
    }, {}], 6: [function(i, o, a) {
      var r = null;
      r = typeof Promise < "u" ? Promise : i("lie"), o.exports = { Promise: r };
    }, { lie: 37 }], 7: [function(i, o, a) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", l = i("pako"), c = i("./utils"), u = i("./stream/GenericWorker"), d = r ? "uint8array" : "array";
      function h(p, f) {
        u.call(this, "FlateWorker/" + p), this._pako = null, this._pakoAction = p, this._pakoOptions = f, this.meta = {};
      }
      a.magic = "\b\0", c.inherits(h, u), h.prototype.processChunk = function(p) {
        this.meta = p.meta, this._pako === null && this._createPako(), this._pako.push(c.transformTo(d, p.data), !1);
      }, h.prototype.flush = function() {
        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        u.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new l[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var p = this;
        this._pako.onData = function(f) {
          p.push({ data: f, meta: p.meta });
        };
      }, a.compressWorker = function(p) {
        return new h("Deflate", p);
      }, a.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(i, o, a) {
      function r(m, y) {
        var g, x = "";
        for (g = 0; g < y; g++) x += String.fromCharCode(255 & m), m >>>= 8;
        return x;
      }
      function l(m, y, g, x, w, M) {
        var _, C, T = m.file, P = m.compression, E = M !== d.utf8encode, b = c.transformTo("string", M(T.name)), S = c.transformTo("string", d.utf8encode(T.name)), A = T.comment, R = c.transformTo("string", M(A)), k = c.transformTo("string", d.utf8encode(A)), U = S.length !== T.name.length, I = k.length !== A.length, W = "", fe = "", q = "", G = T.dir, Q = T.date, K = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        y && !g || (K.crc32 = m.crc32, K.compressedSize = m.compressedSize, K.uncompressedSize = m.uncompressedSize);
        var Y = 0;
        y && (Y |= 8), E || !U && !I || (Y |= 2048);
        var ee = 0, ce = 0;
        G && (ee |= 16), w === "UNIX" ? (ce = 798, ee |= function(de, ie) {
          var he = de;
          return de || (he = ie ? 16893 : 33204), (65535 & he) << 16;
        }(T.unixPermissions, G)) : (ce = 20, ee |= function(de) {
          return 63 & (de || 0);
        }(T.dosPermissions)), _ = Q.getUTCHours(), _ <<= 6, _ |= Q.getUTCMinutes(), _ <<= 5, _ |= Q.getUTCSeconds() / 2, C = Q.getUTCFullYear() - 1980, C <<= 4, C |= Q.getUTCMonth() + 1, C <<= 5, C |= Q.getUTCDate(), U && (fe = r(1, 1) + r(h(b), 4) + S, W += "up" + r(fe.length, 2) + fe), I && (q = r(1, 1) + r(h(R), 4) + k, W += "uc" + r(q.length, 2) + q);
        var ae = "";
        return ae += `
\0`, ae += r(Y, 2), ae += P.magic, ae += r(_, 2), ae += r(C, 2), ae += r(K.crc32, 4), ae += r(K.compressedSize, 4), ae += r(K.uncompressedSize, 4), ae += r(b.length, 2), ae += r(W.length, 2), { fileRecord: p.LOCAL_FILE_HEADER + ae + b + W, dirRecord: p.CENTRAL_FILE_HEADER + r(ce, 2) + ae + r(R.length, 2) + "\0\0\0\0" + r(ee, 4) + r(x, 4) + b + W + R };
      }
      var c = i("../utils"), u = i("../stream/GenericWorker"), d = i("../utf8"), h = i("../crc32"), p = i("../signature");
      function f(m, y, g, x) {
        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = y, this.zipPlatform = g, this.encodeFileName = x, this.streamFiles = m, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      c.inherits(f, u), f.prototype.push = function(m) {
        var y = m.meta.percent || 0, g = this.entriesCount, x = this._sources.length;
        this.accumulate ? this.contentBuffer.push(m) : (this.bytesWritten += m.data.length, u.prototype.push.call(this, { data: m.data, meta: { currentFile: this.currentFile, percent: g ? (y + 100 * (g - x - 1)) / g : 100 } }));
      }, f.prototype.openedSource = function(m) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = m.file.name;
        var y = this.streamFiles && !m.file.dir;
        if (y) {
          var g = l(m, y, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: g.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, f.prototype.closedSource = function(m) {
        this.accumulate = !1;
        var y = this.streamFiles && !m.file.dir, g = l(m, y, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(g.dirRecord), y) this.push({ data: function(x) {
          return p.DATA_DESCRIPTOR + r(x.crc32, 4) + r(x.compressedSize, 4) + r(x.uncompressedSize, 4);
        }(m), meta: { percent: 100 } });
        else for (this.push({ data: g.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, f.prototype.flush = function() {
        for (var m = this.bytesWritten, y = 0; y < this.dirRecords.length; y++) this.push({ data: this.dirRecords[y], meta: { percent: 100 } });
        var g = this.bytesWritten - m, x = function(w, M, _, C, T) {
          var P = c.transformTo("string", T(C));
          return p.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(w, 2) + r(w, 2) + r(M, 4) + r(_, 4) + r(P.length, 2) + P;
        }(this.dirRecords.length, g, m, this.zipComment, this.encodeFileName);
        this.push({ data: x, meta: { percent: 100 } });
      }, f.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, f.prototype.registerPrevious = function(m) {
        this._sources.push(m);
        var y = this;
        return m.on("data", function(g) {
          y.processChunk(g);
        }), m.on("end", function() {
          y.closedSource(y.previous.streamInfo), y._sources.length ? y.prepareNextSource() : y.end();
        }), m.on("error", function(g) {
          y.error(g);
        }), this;
      }, f.prototype.resume = function() {
        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, f.prototype.error = function(m) {
        var y = this._sources;
        if (!u.prototype.error.call(this, m)) return !1;
        for (var g = 0; g < y.length; g++) try {
          y[g].error(m);
        } catch {
        }
        return !0;
      }, f.prototype.lock = function() {
        u.prototype.lock.call(this);
        for (var m = this._sources, y = 0; y < m.length; y++) m[y].lock();
      }, o.exports = f;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(i, o, a) {
      var r = i("../compressions"), l = i("./ZipFileWorker");
      a.generateWorker = function(c, u, d) {
        var h = new l(u.streamFiles, d, u.platform, u.encodeFileName), p = 0;
        try {
          c.forEach(function(f, m) {
            p++;
            var y = function(M, _) {
              var C = M || _, T = r[C];
              if (!T) throw new Error(C + " is not a valid compression method !");
              return T;
            }(m.options.compression, u.compression), g = m.options.compressionOptions || u.compressionOptions || {}, x = m.dir, w = m.date;
            m._compressWorker(y, g).withStreamInfo("file", { name: f, dir: x, date: w, comment: m.comment || "", unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions }).pipe(h);
          }), h.entriesCount = p;
        } catch (f) {
          h.error(f);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(i, o, a) {
      function r() {
        if (!(this instanceof r)) return new r();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var l = new r();
          for (var c in this) typeof this[c] != "function" && (l[c] = this[c]);
          return l;
        };
      }
      (r.prototype = i("./object")).loadAsync = i("./load"), r.support = i("./support"), r.defaults = i("./defaults"), r.version = "3.10.1", r.loadAsync = function(l, c) {
        return new r().loadAsync(l, c);
      }, r.external = i("./external"), o.exports = r;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(i, o, a) {
      var r = i("./utils"), l = i("./external"), c = i("./utf8"), u = i("./zipEntries"), d = i("./stream/Crc32Probe"), h = i("./nodejsUtils");
      function p(f) {
        return new l.Promise(function(m, y) {
          var g = f.decompressed.getContentWorker().pipe(new d());
          g.on("error", function(x) {
            y(x);
          }).on("end", function() {
            g.streamInfo.crc32 !== f.decompressed.crc32 ? y(new Error("Corrupted zip : CRC32 mismatch")) : m();
          }).resume();
        });
      }
      o.exports = function(f, m) {
        var y = this;
        return m = r.extend(m || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: c.utf8decode }), h.isNode && h.isStream(f) ? l.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", f, !0, m.optimizedBinaryString, m.base64).then(function(g) {
          var x = new u(m);
          return x.load(g), x;
        }).then(function(g) {
          var x = [l.Promise.resolve(g)], w = g.files;
          if (m.checkCRC32) for (var M = 0; M < w.length; M++) x.push(p(w[M]));
          return l.Promise.all(x);
        }).then(function(g) {
          for (var x = g.shift(), w = x.files, M = 0; M < w.length; M++) {
            var _ = w[M], C = _.fileNameStr, T = r.resolve(_.fileNameStr);
            y.file(T, _.decompressed, { binary: !0, optimizedBinaryString: !0, date: _.date, dir: _.dir, comment: _.fileCommentStr.length ? _.fileCommentStr : null, unixPermissions: _.unixPermissions, dosPermissions: _.dosPermissions, createFolders: m.createFolders }), _.dir || (y.file(T).unsafeOriginalName = C);
          }
          return x.zipComment.length && (y.comment = x.zipComment), y;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(i, o, a) {
      var r = i("../utils"), l = i("../stream/GenericWorker");
      function c(u, d) {
        l.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(d);
      }
      r.inherits(c, l), c.prototype._bindStream = function(u) {
        var d = this;
        (this._stream = u).pause(), u.on("data", function(h) {
          d.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          d.isPaused ? this.generatedError = h : d.error(h);
        }).on("end", function() {
          d.isPaused ? d._upstreamEnded = !0 : d.end();
        });
      }, c.prototype.pause = function() {
        return !!l.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, o.exports = c;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(i, o, a) {
      var r = i("readable-stream").Readable;
      function l(c, u, d) {
        r.call(this, u), this._helper = c;
        var h = this;
        c.on("data", function(p, f) {
          h.push(p) || h._helper.pause(), d && d(f);
        }).on("error", function(p) {
          h.emit("error", p);
        }).on("end", function() {
          h.push(null);
        });
      }
      i("../utils").inherits(l, r), l.prototype._read = function() {
        this._helper.resume();
      }, o.exports = l;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(i, o, a) {
      o.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(r, l) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(r, l);
        if (typeof r == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(r, l);
      }, allocBuffer: function(r) {
        if (Buffer.alloc) return Buffer.alloc(r);
        var l = new Buffer(r);
        return l.fill(0), l;
      }, isBuffer: function(r) {
        return Buffer.isBuffer(r);
      }, isStream: function(r) {
        return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
      } };
    }, {}], 15: [function(i, o, a) {
      function r(T, P, E) {
        var b, S = c.getTypeOf(P), A = c.extend(E || {}, h);
        A.date = A.date || /* @__PURE__ */ new Date(), A.compression !== null && (A.compression = A.compression.toUpperCase()), typeof A.unixPermissions == "string" && (A.unixPermissions = parseInt(A.unixPermissions, 8)), A.unixPermissions && 16384 & A.unixPermissions && (A.dir = !0), A.dosPermissions && 16 & A.dosPermissions && (A.dir = !0), A.dir && (T = w(T)), A.createFolders && (b = x(T)) && M.call(this, b, !0);
        var R = S === "string" && A.binary === !1 && A.base64 === !1;
        E && E.binary !== void 0 || (A.binary = !R), (P instanceof p && P.uncompressedSize === 0 || A.dir || !P || P.length === 0) && (A.base64 = !1, A.binary = !0, P = "", A.compression = "STORE", S = "string");
        var k = null;
        k = P instanceof p || P instanceof u ? P : y.isNode && y.isStream(P) ? new g(T, P) : c.prepareContent(T, P, A.binary, A.optimizedBinaryString, A.base64);
        var U = new f(T, k, A);
        this.files[T] = U;
      }
      var l = i("./utf8"), c = i("./utils"), u = i("./stream/GenericWorker"), d = i("./stream/StreamHelper"), h = i("./defaults"), p = i("./compressedObject"), f = i("./zipObject"), m = i("./generate"), y = i("./nodejsUtils"), g = i("./nodejs/NodejsStreamInputAdapter"), x = function(T) {
        T.slice(-1) === "/" && (T = T.substring(0, T.length - 1));
        var P = T.lastIndexOf("/");
        return 0 < P ? T.substring(0, P) : "";
      }, w = function(T) {
        return T.slice(-1) !== "/" && (T += "/"), T;
      }, M = function(T, P) {
        return P = P !== void 0 ? P : h.createFolders, T = w(T), this.files[T] || r.call(this, T, null, { dir: !0, createFolders: P }), this.files[T];
      };
      function _(T) {
        return Object.prototype.toString.call(T) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(T) {
        var P, E, b;
        for (P in this.files) b = this.files[P], (E = P.slice(this.root.length, P.length)) && P.slice(0, this.root.length) === this.root && T(E, b);
      }, filter: function(T) {
        var P = [];
        return this.forEach(function(E, b) {
          T(E, b) && P.push(b);
        }), P;
      }, file: function(T, P, E) {
        if (arguments.length !== 1) return T = this.root + T, r.call(this, T, P, E), this;
        if (_(T)) {
          var b = T;
          return this.filter(function(A, R) {
            return !R.dir && b.test(A);
          });
        }
        var S = this.files[this.root + T];
        return S && !S.dir ? S : null;
      }, folder: function(T) {
        if (!T) return this;
        if (_(T)) return this.filter(function(S, A) {
          return A.dir && T.test(S);
        });
        var P = this.root + T, E = M.call(this, P), b = this.clone();
        return b.root = E.name, b;
      }, remove: function(T) {
        T = this.root + T;
        var P = this.files[T];
        if (P || (T.slice(-1) !== "/" && (T += "/"), P = this.files[T]), P && !P.dir) delete this.files[T];
        else for (var E = this.filter(function(S, A) {
          return A.name.slice(0, T.length) === T;
        }), b = 0; b < E.length; b++) delete this.files[E[b].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(T) {
        var P, E = {};
        try {
          if ((E = c.extend(T || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: l.utf8encode })).type = E.type.toLowerCase(), E.compression = E.compression.toUpperCase(), E.type === "binarystring" && (E.type = "string"), !E.type) throw new Error("No output type specified.");
          c.checkSupport(E.type), E.platform !== "darwin" && E.platform !== "freebsd" && E.platform !== "linux" && E.platform !== "sunos" || (E.platform = "UNIX"), E.platform === "win32" && (E.platform = "DOS");
          var b = E.comment || this.comment || "";
          P = m.generateWorker(this, E, b);
        } catch (S) {
          (P = new u("error")).error(S);
        }
        return new d(P, E.type || "string", E.mimeType);
      }, generateAsync: function(T, P) {
        return this.generateInternalStream(T).accumulate(P);
      }, generateNodeStream: function(T, P) {
        return (T = T || {}).type || (T.type = "nodebuffer"), this.generateInternalStream(T).toNodejsStream(P);
      } };
      o.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(i, o, a) {
      o.exports = i("stream");
    }, { stream: void 0 }], 17: [function(i, o, a) {
      var r = i("./DataReader");
      function l(c) {
        r.call(this, c);
        for (var u = 0; u < this.data.length; u++) c[u] = 255 & c[u];
      }
      i("../utils").inherits(l, r), l.prototype.byteAt = function(c) {
        return this.data[this.zero + c];
      }, l.prototype.lastIndexOfSignature = function(c) {
        for (var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), p = c.charCodeAt(3), f = this.length - 4; 0 <= f; --f) if (this.data[f] === u && this.data[f + 1] === d && this.data[f + 2] === h && this.data[f + 3] === p) return f - this.zero;
        return -1;
      }, l.prototype.readAndCheckSignature = function(c) {
        var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), p = c.charCodeAt(3), f = this.readData(4);
        return u === f[0] && d === f[1] && h === f[2] && p === f[3];
      }, l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, o.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(i, o, a) {
      var r = i("../utils");
      function l(c) {
        this.data = c, this.length = c.length, this.index = 0, this.zero = 0;
      }
      l.prototype = { checkOffset: function(c) {
        this.checkIndex(this.index + c);
      }, checkIndex: function(c) {
        if (this.length < this.zero + c || c < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + c + "). Corrupted zip ?");
      }, setIndex: function(c) {
        this.checkIndex(c), this.index = c;
      }, skip: function(c) {
        this.setIndex(this.index + c);
      }, byteAt: function() {
      }, readInt: function(c) {
        var u, d = 0;
        for (this.checkOffset(c), u = this.index + c - 1; u >= this.index; u--) d = (d << 8) + this.byteAt(u);
        return this.index += c, d;
      }, readString: function(c) {
        return r.transformTo("string", this.readData(c));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var c = this.readInt(4);
        return new Date(Date.UTC(1980 + (c >> 25 & 127), (c >> 21 & 15) - 1, c >> 16 & 31, c >> 11 & 31, c >> 5 & 63, (31 & c) << 1));
      } }, o.exports = l;
    }, { "../utils": 32 }], 19: [function(i, o, a) {
      var r = i("./Uint8ArrayReader");
      function l(c) {
        r.call(this, c);
      }
      i("../utils").inherits(l, r), l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, o.exports = l;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(i, o, a) {
      var r = i("./DataReader");
      function l(c) {
        r.call(this, c);
      }
      i("../utils").inherits(l, r), l.prototype.byteAt = function(c) {
        return this.data.charCodeAt(this.zero + c);
      }, l.prototype.lastIndexOfSignature = function(c) {
        return this.data.lastIndexOf(c) - this.zero;
      }, l.prototype.readAndCheckSignature = function(c) {
        return c === this.readData(4);
      }, l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, o.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(i, o, a) {
      var r = i("./ArrayReader");
      function l(c) {
        r.call(this, c);
      }
      i("../utils").inherits(l, r), l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, o.exports = l;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(i, o, a) {
      var r = i("../utils"), l = i("../support"), c = i("./ArrayReader"), u = i("./StringReader"), d = i("./NodeBufferReader"), h = i("./Uint8ArrayReader");
      o.exports = function(p) {
        var f = r.getTypeOf(p);
        return r.checkSupport(f), f !== "string" || l.uint8array ? f === "nodebuffer" ? new d(p) : l.uint8array ? new h(r.transformTo("uint8array", p)) : new c(r.transformTo("array", p)) : new u(p);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(i, o, a) {
      a.LOCAL_FILE_HEADER = "PK", a.CENTRAL_FILE_HEADER = "PK", a.CENTRAL_DIRECTORY_END = "PK", a.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", a.ZIP64_CENTRAL_DIRECTORY_END = "PK", a.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(i, o, a) {
      var r = i("./GenericWorker"), l = i("../utils");
      function c(u) {
        r.call(this, "ConvertWorker to " + u), this.destType = u;
      }
      l.inherits(c, r), c.prototype.processChunk = function(u) {
        this.push({ data: l.transformTo(this.destType, u.data), meta: u.meta });
      }, o.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(i, o, a) {
      var r = i("./GenericWorker"), l = i("../crc32");
      function c() {
        r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      i("../utils").inherits(c, r), c.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = l(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, o.exports = c;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(i, o, a) {
      var r = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
      }
      r.inherits(c, l), c.prototype.processChunk = function(u) {
        if (u) {
          var d = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = d + u.data.length;
        }
        l.prototype.processChunk.call(this, u);
      }, o.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(i, o, a) {
      var r = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataWorker");
        var d = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(h) {
          d.dataIsReady = !0, d.data = h, d.max = h && h.length || 0, d.type = r.getTypeOf(h), d.isPaused || d._tickAndRepeat();
        }, function(h) {
          d.error(h);
        });
      }
      r.inherits(c, l), c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this.data = null;
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, r.delay(this._tickAndRepeat, [], this)), !0);
      }, c.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, c.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var u = null, d = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            u = this.data.substring(this.index, d);
            break;
          case "uint8array":
            u = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            u = this.data.slice(this.index, d);
        }
        return this.index = d, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, o.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(i, o, a) {
      function r(l) {
        this.name = l || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      r.prototype = { push: function(l) {
        this.emit("data", l);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (l) {
          this.emit("error", l);
        }
        return !0;
      }, error: function(l) {
        return !this.isFinished && (this.isPaused ? this.generatedError = l : (this.isFinished = !0, this.emit("error", l), this.previous && this.previous.error(l), this.cleanUp()), !0);
      }, on: function(l, c) {
        return this._listeners[l].push(c), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(l, c) {
        if (this._listeners[l]) for (var u = 0; u < this._listeners[l].length; u++) this._listeners[l][u].call(this, c);
      }, pipe: function(l) {
        return l.registerPrevious(this);
      }, registerPrevious: function(l) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = l.streamInfo, this.mergeStreamInfo(), this.previous = l;
        var c = this;
        return l.on("data", function(u) {
          c.processChunk(u);
        }), l.on("end", function() {
          c.end();
        }), l.on("error", function(u) {
          c.error(u);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var l = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), l = !0), this.previous && this.previous.resume(), !l;
      }, flush: function() {
      }, processChunk: function(l) {
        this.push(l);
      }, withStreamInfo: function(l, c) {
        return this.extraStreamInfo[l] = c, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var l in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, l) && (this.streamInfo[l] = this.extraStreamInfo[l]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var l = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + l : l;
      } }, o.exports = r;
    }, {}], 29: [function(i, o, a) {
      var r = i("../utils"), l = i("./ConvertWorker"), c = i("./GenericWorker"), u = i("../base64"), d = i("../support"), h = i("../external"), p = null;
      if (d.nodestream) try {
        p = i("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function f(y, g) {
        return new h.Promise(function(x, w) {
          var M = [], _ = y._internalType, C = y._outputType, T = y._mimeType;
          y.on("data", function(P, E) {
            M.push(P), g && g(E);
          }).on("error", function(P) {
            M = [], w(P);
          }).on("end", function() {
            try {
              var P = function(E, b, S) {
                switch (E) {
                  case "blob":
                    return r.newBlob(r.transformTo("arraybuffer", b), S);
                  case "base64":
                    return u.encode(b);
                  default:
                    return r.transformTo(E, b);
                }
              }(C, function(E, b) {
                var S, A = 0, R = null, k = 0;
                for (S = 0; S < b.length; S++) k += b[S].length;
                switch (E) {
                  case "string":
                    return b.join("");
                  case "array":
                    return Array.prototype.concat.apply([], b);
                  case "uint8array":
                    for (R = new Uint8Array(k), S = 0; S < b.length; S++) R.set(b[S], A), A += b[S].length;
                    return R;
                  case "nodebuffer":
                    return Buffer.concat(b);
                  default:
                    throw new Error("concat : unsupported type '" + E + "'");
                }
              }(_, M), T);
              x(P);
            } catch (E) {
              w(E);
            }
            M = [];
          }).resume();
        });
      }
      function m(y, g, x) {
        var w = g;
        switch (g) {
          case "blob":
          case "arraybuffer":
            w = "uint8array";
            break;
          case "base64":
            w = "string";
        }
        try {
          this._internalType = w, this._outputType = g, this._mimeType = x, r.checkSupport(w), this._worker = y.pipe(new l(w)), y.lock();
        } catch (M) {
          this._worker = new c("error"), this._worker.error(M);
        }
      }
      m.prototype = { accumulate: function(y) {
        return f(this, y);
      }, on: function(y, g) {
        var x = this;
        return y === "data" ? this._worker.on(y, function(w) {
          g.call(x, w.data, w.meta);
        }) : this._worker.on(y, function() {
          r.delay(g, arguments, x);
        }), this;
      }, resume: function() {
        return r.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(y) {
        if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new p(this, { objectMode: this._outputType !== "nodebuffer" }, y);
      } }, o.exports = m;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(i, o, a) {
      if (a.base64 = !0, a.array = !0, a.string = !0, a.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", a.nodebuffer = typeof Buffer < "u", a.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") a.blob = !1;
      else {
        var r = new ArrayBuffer(0);
        try {
          a.blob = new Blob([r], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            l.append(r), a.blob = l.getBlob("application/zip").size === 0;
          } catch {
            a.blob = !1;
          }
        }
      }
      try {
        a.nodestream = !!i("readable-stream").Readable;
      } catch {
        a.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(i, o, a) {
      for (var r = i("./utils"), l = i("./support"), c = i("./nodejsUtils"), u = i("./stream/GenericWorker"), d = new Array(256), h = 0; h < 256; h++) d[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      d[254] = d[254] = 1;
      function p() {
        u.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function f() {
        u.call(this, "utf-8 encode");
      }
      a.utf8encode = function(m) {
        return l.nodebuffer ? c.newBufferFrom(m, "utf-8") : function(y) {
          var g, x, w, M, _, C = y.length, T = 0;
          for (M = 0; M < C; M++) (64512 & (x = y.charCodeAt(M))) == 55296 && M + 1 < C && (64512 & (w = y.charCodeAt(M + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (w - 56320), M++), T += x < 128 ? 1 : x < 2048 ? 2 : x < 65536 ? 3 : 4;
          for (g = l.uint8array ? new Uint8Array(T) : new Array(T), M = _ = 0; _ < T; M++) (64512 & (x = y.charCodeAt(M))) == 55296 && M + 1 < C && (64512 & (w = y.charCodeAt(M + 1))) == 56320 && (x = 65536 + (x - 55296 << 10) + (w - 56320), M++), x < 128 ? g[_++] = x : (x < 2048 ? g[_++] = 192 | x >>> 6 : (x < 65536 ? g[_++] = 224 | x >>> 12 : (g[_++] = 240 | x >>> 18, g[_++] = 128 | x >>> 12 & 63), g[_++] = 128 | x >>> 6 & 63), g[_++] = 128 | 63 & x);
          return g;
        }(m);
      }, a.utf8decode = function(m) {
        return l.nodebuffer ? r.transformTo("nodebuffer", m).toString("utf-8") : function(y) {
          var g, x, w, M, _ = y.length, C = new Array(2 * _);
          for (g = x = 0; g < _; ) if ((w = y[g++]) < 128) C[x++] = w;
          else if (4 < (M = d[w])) C[x++] = 65533, g += M - 1;
          else {
            for (w &= M === 2 ? 31 : M === 3 ? 15 : 7; 1 < M && g < _; ) w = w << 6 | 63 & y[g++], M--;
            1 < M ? C[x++] = 65533 : w < 65536 ? C[x++] = w : (w -= 65536, C[x++] = 55296 | w >> 10 & 1023, C[x++] = 56320 | 1023 & w);
          }
          return C.length !== x && (C.subarray ? C = C.subarray(0, x) : C.length = x), r.applyFromCharCode(C);
        }(m = r.transformTo(l.uint8array ? "uint8array" : "array", m));
      }, r.inherits(p, u), p.prototype.processChunk = function(m) {
        var y = r.transformTo(l.uint8array ? "uint8array" : "array", m.data);
        if (this.leftOver && this.leftOver.length) {
          if (l.uint8array) {
            var g = y;
            (y = new Uint8Array(g.length + this.leftOver.length)).set(this.leftOver, 0), y.set(g, this.leftOver.length);
          } else y = this.leftOver.concat(y);
          this.leftOver = null;
        }
        var x = function(M, _) {
          var C;
          for ((_ = _ || M.length) > M.length && (_ = M.length), C = _ - 1; 0 <= C && (192 & M[C]) == 128; ) C--;
          return C < 0 || C === 0 ? _ : C + d[M[C]] > _ ? C : _;
        }(y), w = y;
        x !== y.length && (l.uint8array ? (w = y.subarray(0, x), this.leftOver = y.subarray(x, y.length)) : (w = y.slice(0, x), this.leftOver = y.slice(x, y.length))), this.push({ data: a.utf8decode(w), meta: m.meta });
      }, p.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: a.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, a.Utf8DecodeWorker = p, r.inherits(f, u), f.prototype.processChunk = function(m) {
        this.push({ data: a.utf8encode(m.data), meta: m.meta });
      }, a.Utf8EncodeWorker = f;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(i, o, a) {
      var r = i("./support"), l = i("./base64"), c = i("./nodejsUtils"), u = i("./external");
      function d(g) {
        return g;
      }
      function h(g, x) {
        for (var w = 0; w < g.length; ++w) x[w] = 255 & g.charCodeAt(w);
        return x;
      }
      i("setimmediate"), a.newBlob = function(g, x) {
        a.checkSupport("blob");
        try {
          return new Blob([g], { type: x });
        } catch {
          try {
            var w = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return w.append(g), w.getBlob(x);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var p = { stringifyByChunk: function(g, x, w) {
        var M = [], _ = 0, C = g.length;
        if (C <= w) return String.fromCharCode.apply(null, g);
        for (; _ < C; ) x === "array" || x === "nodebuffer" ? M.push(String.fromCharCode.apply(null, g.slice(_, Math.min(_ + w, C)))) : M.push(String.fromCharCode.apply(null, g.subarray(_, Math.min(_ + w, C)))), _ += w;
        return M.join("");
      }, stringifyByChar: function(g) {
        for (var x = "", w = 0; w < g.length; w++) x += String.fromCharCode(g[w]);
        return x;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return r.nodebuffer && String.fromCharCode.apply(null, c.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function f(g) {
        var x = 65536, w = a.getTypeOf(g), M = !0;
        if (w === "uint8array" ? M = p.applyCanBeUsed.uint8array : w === "nodebuffer" && (M = p.applyCanBeUsed.nodebuffer), M) for (; 1 < x; ) try {
          return p.stringifyByChunk(g, w, x);
        } catch {
          x = Math.floor(x / 2);
        }
        return p.stringifyByChar(g);
      }
      function m(g, x) {
        for (var w = 0; w < g.length; w++) x[w] = g[w];
        return x;
      }
      a.applyFromCharCode = f;
      var y = {};
      y.string = { string: d, array: function(g) {
        return h(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return y.string.uint8array(g).buffer;
      }, uint8array: function(g) {
        return h(g, new Uint8Array(g.length));
      }, nodebuffer: function(g) {
        return h(g, c.allocBuffer(g.length));
      } }, y.array = { string: f, array: d, arraybuffer: function(g) {
        return new Uint8Array(g).buffer;
      }, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, y.arraybuffer = { string: function(g) {
        return f(new Uint8Array(g));
      }, array: function(g) {
        return m(new Uint8Array(g), new Array(g.byteLength));
      }, arraybuffer: d, uint8array: function(g) {
        return new Uint8Array(g);
      }, nodebuffer: function(g) {
        return c.newBufferFrom(new Uint8Array(g));
      } }, y.uint8array = { string: f, array: function(g) {
        return m(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return g.buffer;
      }, uint8array: d, nodebuffer: function(g) {
        return c.newBufferFrom(g);
      } }, y.nodebuffer = { string: f, array: function(g) {
        return m(g, new Array(g.length));
      }, arraybuffer: function(g) {
        return y.nodebuffer.uint8array(g).buffer;
      }, uint8array: function(g) {
        return m(g, new Uint8Array(g.length));
      }, nodebuffer: d }, a.transformTo = function(g, x) {
        if (x = x || "", !g) return x;
        a.checkSupport(g);
        var w = a.getTypeOf(x);
        return y[w][g](x);
      }, a.resolve = function(g) {
        for (var x = g.split("/"), w = [], M = 0; M < x.length; M++) {
          var _ = x[M];
          _ === "." || _ === "" && M !== 0 && M !== x.length - 1 || (_ === ".." ? w.pop() : w.push(_));
        }
        return w.join("/");
      }, a.getTypeOf = function(g) {
        return typeof g == "string" ? "string" : Object.prototype.toString.call(g) === "[object Array]" ? "array" : r.nodebuffer && c.isBuffer(g) ? "nodebuffer" : r.uint8array && g instanceof Uint8Array ? "uint8array" : r.arraybuffer && g instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(g) {
        if (!r[g.toLowerCase()]) throw new Error(g + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(g) {
        var x, w, M = "";
        for (w = 0; w < (g || "").length; w++) M += "\\x" + ((x = g.charCodeAt(w)) < 16 ? "0" : "") + x.toString(16).toUpperCase();
        return M;
      }, a.delay = function(g, x, w) {
        setImmediate(function() {
          g.apply(w || null, x || []);
        });
      }, a.inherits = function(g, x) {
        function w() {
        }
        w.prototype = x.prototype, g.prototype = new w();
      }, a.extend = function() {
        var g, x, w = {};
        for (g = 0; g < arguments.length; g++) for (x in arguments[g]) Object.prototype.hasOwnProperty.call(arguments[g], x) && w[x] === void 0 && (w[x] = arguments[g][x]);
        return w;
      }, a.prepareContent = function(g, x, w, M, _) {
        return u.Promise.resolve(x).then(function(C) {
          return r.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(T, P) {
            var E = new FileReader();
            E.onload = function(b) {
              T(b.target.result);
            }, E.onerror = function(b) {
              P(b.target.error);
            }, E.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var T = a.getTypeOf(C);
          return T ? (T === "arraybuffer" ? C = a.transformTo("uint8array", C) : T === "string" && (_ ? C = l.decode(C) : w && M !== !0 && (C = function(P) {
            return h(P, r.uint8array ? new Uint8Array(P.length) : new Array(P.length));
          }(C))), C) : u.Promise.reject(new Error("Can't read the data of '" + g + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(i, o, a) {
      var r = i("./reader/readerFor"), l = i("./utils"), c = i("./signature"), u = i("./zipEntry"), d = i("./support");
      function h(p) {
        this.files = [], this.loadOptions = p;
      }
      h.prototype = { checkSignature: function(p) {
        if (!this.reader.readAndCheckSignature(p)) {
          this.reader.index -= 4;
          var f = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + l.pretty(f) + ", expected " + l.pretty(p) + ")");
        }
      }, isSignature: function(p, f) {
        var m = this.reader.index;
        this.reader.setIndex(p);
        var y = this.reader.readString(4) === f;
        return this.reader.setIndex(m), y;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var p = this.reader.readData(this.zipCommentLength), f = d.uint8array ? "uint8array" : "array", m = l.transformTo(f, p);
        this.zipComment = this.loadOptions.decodeFileName(m);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var p, f, m, y = this.zip64EndOfCentralSize - 44; 0 < y; ) p = this.reader.readInt(2), f = this.reader.readInt(4), m = this.reader.readData(f), this.zip64ExtensibleData[p] = { id: p, length: f, value: m };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var p, f;
        for (p = 0; p < this.files.length; p++) f = this.files[p], this.reader.setIndex(f.localHeaderOffset), this.checkSignature(c.LOCAL_FILE_HEADER), f.readLocalPart(this.reader), f.handleUTF8(), f.processAttributes();
      }, readCentralDir: function() {
        var p;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(c.CENTRAL_FILE_HEADER); ) (p = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(p);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var p = this.reader.lastIndexOfSignature(c.CENTRAL_DIRECTORY_END);
        if (p < 0) throw this.isSignature(0, c.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(p);
        var f = p;
        if (this.checkSignature(c.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === l.MAX_VALUE_16BITS || this.diskWithCentralDirStart === l.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === l.MAX_VALUE_16BITS || this.centralDirRecords === l.MAX_VALUE_16BITS || this.centralDirSize === l.MAX_VALUE_32BITS || this.centralDirOffset === l.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (p = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(p), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, c.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var m = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
        var y = f - m;
        if (0 < y) this.isSignature(f, c.CENTRAL_FILE_HEADER) || (this.reader.zero = y);
        else if (y < 0) throw new Error("Corrupted zip: missing " + Math.abs(y) + " bytes.");
      }, prepareReader: function(p) {
        this.reader = r(p);
      }, load: function(p) {
        this.prepareReader(p), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, o.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(i, o, a) {
      var r = i("./reader/readerFor"), l = i("./utils"), c = i("./compressedObject"), u = i("./crc32"), d = i("./utf8"), h = i("./compressions"), p = i("./support");
      function f(m, y) {
        this.options = m, this.loadOptions = y;
      }
      f.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(m) {
        var y, g;
        if (m.skip(22), this.fileNameLength = m.readInt(2), g = m.readInt(2), this.fileName = m.readData(this.fileNameLength), m.skip(g), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((y = function(x) {
          for (var w in h) if (Object.prototype.hasOwnProperty.call(h, w) && h[w].magic === x) return h[w];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + l.pretty(this.compressionMethod) + " unknown (inner file : " + l.transformTo("string", this.fileName) + ")");
        this.decompressed = new c(this.compressedSize, this.uncompressedSize, this.crc32, y, m.readData(this.compressedSize));
      }, readCentralPart: function(m) {
        this.versionMadeBy = m.readInt(2), m.skip(2), this.bitFlag = m.readInt(2), this.compressionMethod = m.readString(2), this.date = m.readDate(), this.crc32 = m.readInt(4), this.compressedSize = m.readInt(4), this.uncompressedSize = m.readInt(4);
        var y = m.readInt(2);
        if (this.extraFieldsLength = m.readInt(2), this.fileCommentLength = m.readInt(2), this.diskNumberStart = m.readInt(2), this.internalFileAttributes = m.readInt(2), this.externalFileAttributes = m.readInt(4), this.localHeaderOffset = m.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        m.skip(y), this.readExtraFields(m), this.parseZIP64ExtraField(m), this.fileComment = m.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var m = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), m == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), m == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var m = r(this.extraFields[1].value);
          this.uncompressedSize === l.MAX_VALUE_32BITS && (this.uncompressedSize = m.readInt(8)), this.compressedSize === l.MAX_VALUE_32BITS && (this.compressedSize = m.readInt(8)), this.localHeaderOffset === l.MAX_VALUE_32BITS && (this.localHeaderOffset = m.readInt(8)), this.diskNumberStart === l.MAX_VALUE_32BITS && (this.diskNumberStart = m.readInt(4));
        }
      }, readExtraFields: function(m) {
        var y, g, x, w = m.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); m.index + 4 < w; ) y = m.readInt(2), g = m.readInt(2), x = m.readData(g), this.extraFields[y] = { id: y, length: g, value: x };
        m.setIndex(w);
      }, handleUTF8: function() {
        var m = p.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = d.utf8decode(this.fileName), this.fileCommentStr = d.utf8decode(this.fileComment);
        else {
          var y = this.findExtraFieldUnicodePath();
          if (y !== null) this.fileNameStr = y;
          else {
            var g = l.transformTo(m, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(g);
          }
          var x = this.findExtraFieldUnicodeComment();
          if (x !== null) this.fileCommentStr = x;
          else {
            var w = l.transformTo(m, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(w);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var m = this.extraFields[28789];
        if (m) {
          var y = r(m.value);
          return y.readInt(1) !== 1 || u(this.fileName) !== y.readInt(4) ? null : d.utf8decode(y.readData(m.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var m = this.extraFields[25461];
        if (m) {
          var y = r(m.value);
          return y.readInt(1) !== 1 || u(this.fileComment) !== y.readInt(4) ? null : d.utf8decode(y.readData(m.length - 5));
        }
        return null;
      } }, o.exports = f;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(i, o, a) {
      function r(y, g, x) {
        this.name = y, this.dir = x.dir, this.date = x.date, this.comment = x.comment, this.unixPermissions = x.unixPermissions, this.dosPermissions = x.dosPermissions, this._data = g, this._dataBinary = x.binary, this.options = { compression: x.compression, compressionOptions: x.compressionOptions };
      }
      var l = i("./stream/StreamHelper"), c = i("./stream/DataWorker"), u = i("./utf8"), d = i("./compressedObject"), h = i("./stream/GenericWorker");
      r.prototype = { internalStream: function(y) {
        var g = null, x = "string";
        try {
          if (!y) throw new Error("No output type specified.");
          var w = (x = y.toLowerCase()) === "string" || x === "text";
          x !== "binarystring" && x !== "text" || (x = "string"), g = this._decompressWorker();
          var M = !this._dataBinary;
          M && !w && (g = g.pipe(new u.Utf8EncodeWorker())), !M && w && (g = g.pipe(new u.Utf8DecodeWorker()));
        } catch (_) {
          (g = new h("error")).error(_);
        }
        return new l(g, x, "");
      }, async: function(y, g) {
        return this.internalStream(y).accumulate(g);
      }, nodeStream: function(y, g) {
        return this.internalStream(y || "nodebuffer").toNodejsStream(g);
      }, _compressWorker: function(y, g) {
        if (this._data instanceof d && this._data.compression.magic === y.magic) return this._data.getCompressedWorker();
        var x = this._decompressWorker();
        return this._dataBinary || (x = x.pipe(new u.Utf8EncodeWorker())), d.createWorkerFrom(x, y, g);
      }, _decompressWorker: function() {
        return this._data instanceof d ? this._data.getContentWorker() : this._data instanceof h ? this._data : new c(this._data);
      } };
      for (var p = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], f = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, m = 0; m < p.length; m++) r.prototype[p[m]] = f;
      o.exports = r;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(i, o, a) {
      (function(r) {
        var l, c, u = r.MutationObserver || r.WebKitMutationObserver;
        if (u) {
          var d = 0, h = new u(y), p = r.document.createTextNode("");
          h.observe(p, { characterData: !0 }), l = function() {
            p.data = d = ++d % 2;
          };
        } else if (r.setImmediate || r.MessageChannel === void 0) l = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
          var g = r.document.createElement("script");
          g.onreadystatechange = function() {
            y(), g.onreadystatechange = null, g.parentNode.removeChild(g), g = null;
          }, r.document.documentElement.appendChild(g);
        } : function() {
          setTimeout(y, 0);
        };
        else {
          var f = new r.MessageChannel();
          f.port1.onmessage = y, l = function() {
            f.port2.postMessage(0);
          };
        }
        var m = [];
        function y() {
          var g, x;
          c = !0;
          for (var w = m.length; w; ) {
            for (x = m, m = [], g = -1; ++g < w; ) x[g]();
            w = m.length;
          }
          c = !1;
        }
        o.exports = function(g) {
          m.push(g) !== 1 || c || l();
        };
      }).call(this, typeof oc < "u" ? oc : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(i, o, a) {
      var r = i("immediate");
      function l() {
      }
      var c = {}, u = ["REJECTED"], d = ["FULFILLED"], h = ["PENDING"];
      function p(w) {
        if (typeof w != "function") throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, w !== l && g(this, w);
      }
      function f(w, M, _) {
        this.promise = w, typeof M == "function" && (this.onFulfilled = M, this.callFulfilled = this.otherCallFulfilled), typeof _ == "function" && (this.onRejected = _, this.callRejected = this.otherCallRejected);
      }
      function m(w, M, _) {
        r(function() {
          var C;
          try {
            C = M(_);
          } catch (T) {
            return c.reject(w, T);
          }
          C === w ? c.reject(w, new TypeError("Cannot resolve promise with itself")) : c.resolve(w, C);
        });
      }
      function y(w) {
        var M = w && w.then;
        if (w && (typeof w == "object" || typeof w == "function") && typeof M == "function") return function() {
          M.apply(w, arguments);
        };
      }
      function g(w, M) {
        var _ = !1;
        function C(E) {
          _ || (_ = !0, c.reject(w, E));
        }
        function T(E) {
          _ || (_ = !0, c.resolve(w, E));
        }
        var P = x(function() {
          M(T, C);
        });
        P.status === "error" && C(P.value);
      }
      function x(w, M) {
        var _ = {};
        try {
          _.value = w(M), _.status = "success";
        } catch (C) {
          _.status = "error", _.value = C;
        }
        return _;
      }
      (o.exports = p).prototype.finally = function(w) {
        if (typeof w != "function") return this;
        var M = this.constructor;
        return this.then(function(_) {
          return M.resolve(w()).then(function() {
            return _;
          });
        }, function(_) {
          return M.resolve(w()).then(function() {
            throw _;
          });
        });
      }, p.prototype.catch = function(w) {
        return this.then(null, w);
      }, p.prototype.then = function(w, M) {
        if (typeof w != "function" && this.state === d || typeof M != "function" && this.state === u) return this;
        var _ = new this.constructor(l);
        return this.state !== h ? m(_, this.state === d ? w : M, this.outcome) : this.queue.push(new f(_, w, M)), _;
      }, f.prototype.callFulfilled = function(w) {
        c.resolve(this.promise, w);
      }, f.prototype.otherCallFulfilled = function(w) {
        m(this.promise, this.onFulfilled, w);
      }, f.prototype.callRejected = function(w) {
        c.reject(this.promise, w);
      }, f.prototype.otherCallRejected = function(w) {
        m(this.promise, this.onRejected, w);
      }, c.resolve = function(w, M) {
        var _ = x(y, M);
        if (_.status === "error") return c.reject(w, _.value);
        var C = _.value;
        if (C) g(w, C);
        else {
          w.state = d, w.outcome = M;
          for (var T = -1, P = w.queue.length; ++T < P; ) w.queue[T].callFulfilled(M);
        }
        return w;
      }, c.reject = function(w, M) {
        w.state = u, w.outcome = M;
        for (var _ = -1, C = w.queue.length; ++_ < C; ) w.queue[_].callRejected(M);
        return w;
      }, p.resolve = function(w) {
        return w instanceof this ? w : c.resolve(new this(l), w);
      }, p.reject = function(w) {
        var M = new this(l);
        return c.reject(M, w);
      }, p.all = function(w) {
        var M = this;
        if (Object.prototype.toString.call(w) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var _ = w.length, C = !1;
        if (!_) return this.resolve([]);
        for (var T = new Array(_), P = 0, E = -1, b = new this(l); ++E < _; ) S(w[E], E);
        return b;
        function S(A, R) {
          M.resolve(A).then(function(k) {
            T[R] = k, ++P !== _ || C || (C = !0, c.resolve(b, T));
          }, function(k) {
            C || (C = !0, c.reject(b, k));
          });
        }
      }, p.race = function(w) {
        var M = this;
        if (Object.prototype.toString.call(w) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var _ = w.length, C = !1;
        if (!_) return this.resolve([]);
        for (var T = -1, P = new this(l); ++T < _; ) E = w[T], M.resolve(E).then(function(b) {
          C || (C = !0, c.resolve(P, b));
        }, function(b) {
          C || (C = !0, c.reject(P, b));
        });
        var E;
        return P;
      };
    }, { immediate: 36 }], 38: [function(i, o, a) {
      var r = {};
      (0, i("./lib/utils/common").assign)(r, i("./lib/deflate"), i("./lib/inflate"), i("./lib/zlib/constants")), o.exports = r;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(i, o, a) {
      var r = i("./zlib/deflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/messages"), d = i("./zlib/zstream"), h = Object.prototype.toString, p = 0, f = -1, m = 0, y = 8;
      function g(w) {
        if (!(this instanceof g)) return new g(w);
        this.options = l.assign({ level: f, method: y, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, w || {});
        var M = this.options;
        M.raw && 0 < M.windowBits ? M.windowBits = -M.windowBits : M.gzip && 0 < M.windowBits && M.windowBits < 16 && (M.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var _ = r.deflateInit2(this.strm, M.level, M.method, M.windowBits, M.memLevel, M.strategy);
        if (_ !== p) throw new Error(u[_]);
        if (M.header && r.deflateSetHeader(this.strm, M.header), M.dictionary) {
          var C;
          if (C = typeof M.dictionary == "string" ? c.string2buf(M.dictionary) : h.call(M.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(M.dictionary) : M.dictionary, (_ = r.deflateSetDictionary(this.strm, C)) !== p) throw new Error(u[_]);
          this._dict_set = !0;
        }
      }
      function x(w, M) {
        var _ = new g(M);
        if (_.push(w, !0), _.err) throw _.msg || u[_.err];
        return _.result;
      }
      g.prototype.push = function(w, M) {
        var _, C, T = this.strm, P = this.options.chunkSize;
        if (this.ended) return !1;
        C = M === ~~M ? M : M === !0 ? 4 : 0, typeof w == "string" ? T.input = c.string2buf(w) : h.call(w) === "[object ArrayBuffer]" ? T.input = new Uint8Array(w) : T.input = w, T.next_in = 0, T.avail_in = T.input.length;
        do {
          if (T.avail_out === 0 && (T.output = new l.Buf8(P), T.next_out = 0, T.avail_out = P), (_ = r.deflate(T, C)) !== 1 && _ !== p) return this.onEnd(_), !(this.ended = !0);
          T.avail_out !== 0 && (T.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(c.buf2binstring(l.shrinkBuf(T.output, T.next_out))) : this.onData(l.shrinkBuf(T.output, T.next_out)));
        } while ((0 < T.avail_in || T.avail_out === 0) && _ !== 1);
        return C === 4 ? (_ = r.deflateEnd(this.strm), this.onEnd(_), this.ended = !0, _ === p) : C !== 2 || (this.onEnd(p), !(T.avail_out = 0));
      }, g.prototype.onData = function(w) {
        this.chunks.push(w);
      }, g.prototype.onEnd = function(w) {
        w === p && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = w, this.msg = this.strm.msg;
      }, a.Deflate = g, a.deflate = x, a.deflateRaw = function(w, M) {
        return (M = M || {}).raw = !0, x(w, M);
      }, a.gzip = function(w, M) {
        return (M = M || {}).gzip = !0, x(w, M);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(i, o, a) {
      var r = i("./zlib/inflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/constants"), d = i("./zlib/messages"), h = i("./zlib/zstream"), p = i("./zlib/gzheader"), f = Object.prototype.toString;
      function m(g) {
        if (!(this instanceof m)) return new m(g);
        this.options = l.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
        var x = this.options;
        x.raw && 0 <= x.windowBits && x.windowBits < 16 && (x.windowBits = -x.windowBits, x.windowBits === 0 && (x.windowBits = -15)), !(0 <= x.windowBits && x.windowBits < 16) || g && g.windowBits || (x.windowBits += 32), 15 < x.windowBits && x.windowBits < 48 && !(15 & x.windowBits) && (x.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var w = r.inflateInit2(this.strm, x.windowBits);
        if (w !== u.Z_OK) throw new Error(d[w]);
        this.header = new p(), r.inflateGetHeader(this.strm, this.header);
      }
      function y(g, x) {
        var w = new m(x);
        if (w.push(g, !0), w.err) throw w.msg || d[w.err];
        return w.result;
      }
      m.prototype.push = function(g, x) {
        var w, M, _, C, T, P, E = this.strm, b = this.options.chunkSize, S = this.options.dictionary, A = !1;
        if (this.ended) return !1;
        M = x === ~~x ? x : x === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof g == "string" ? E.input = c.binstring2buf(g) : f.call(g) === "[object ArrayBuffer]" ? E.input = new Uint8Array(g) : E.input = g, E.next_in = 0, E.avail_in = E.input.length;
        do {
          if (E.avail_out === 0 && (E.output = new l.Buf8(b), E.next_out = 0, E.avail_out = b), (w = r.inflate(E, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && S && (P = typeof S == "string" ? c.string2buf(S) : f.call(S) === "[object ArrayBuffer]" ? new Uint8Array(S) : S, w = r.inflateSetDictionary(this.strm, P)), w === u.Z_BUF_ERROR && A === !0 && (w = u.Z_OK, A = !1), w !== u.Z_STREAM_END && w !== u.Z_OK) return this.onEnd(w), !(this.ended = !0);
          E.next_out && (E.avail_out !== 0 && w !== u.Z_STREAM_END && (E.avail_in !== 0 || M !== u.Z_FINISH && M !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (_ = c.utf8border(E.output, E.next_out), C = E.next_out - _, T = c.buf2string(E.output, _), E.next_out = C, E.avail_out = b - C, C && l.arraySet(E.output, E.output, _, C, 0), this.onData(T)) : this.onData(l.shrinkBuf(E.output, E.next_out)))), E.avail_in === 0 && E.avail_out === 0 && (A = !0);
        } while ((0 < E.avail_in || E.avail_out === 0) && w !== u.Z_STREAM_END);
        return w === u.Z_STREAM_END && (M = u.Z_FINISH), M === u.Z_FINISH ? (w = r.inflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === u.Z_OK) : M !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(E.avail_out = 0));
      }, m.prototype.onData = function(g) {
        this.chunks.push(g);
      }, m.prototype.onEnd = function(g) {
        g === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
      }, a.Inflate = m, a.inflate = y, a.inflateRaw = function(g, x) {
        return (x = x || {}).raw = !0, y(g, x);
      }, a.ungzip = y;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(i, o, a) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      a.assign = function(u) {
        for (var d = Array.prototype.slice.call(arguments, 1); d.length; ) {
          var h = d.shift();
          if (h) {
            if (typeof h != "object") throw new TypeError(h + "must be non-object");
            for (var p in h) h.hasOwnProperty(p) && (u[p] = h[p]);
          }
        }
        return u;
      }, a.shrinkBuf = function(u, d) {
        return u.length === d ? u : u.subarray ? u.subarray(0, d) : (u.length = d, u);
      };
      var l = { arraySet: function(u, d, h, p, f) {
        if (d.subarray && u.subarray) u.set(d.subarray(h, h + p), f);
        else for (var m = 0; m < p; m++) u[f + m] = d[h + m];
      }, flattenChunks: function(u) {
        var d, h, p, f, m, y;
        for (d = p = 0, h = u.length; d < h; d++) p += u[d].length;
        for (y = new Uint8Array(p), d = f = 0, h = u.length; d < h; d++) m = u[d], y.set(m, f), f += m.length;
        return y;
      } }, c = { arraySet: function(u, d, h, p, f) {
        for (var m = 0; m < p; m++) u[f + m] = d[h + m];
      }, flattenChunks: function(u) {
        return [].concat.apply([], u);
      } };
      a.setTyped = function(u) {
        u ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, l)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, c));
      }, a.setTyped(r);
    }, {}], 42: [function(i, o, a) {
      var r = i("./common"), l = !0, c = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        l = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        c = !1;
      }
      for (var u = new r.Buf8(256), d = 0; d < 256; d++) u[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      function h(p, f) {
        if (f < 65537 && (p.subarray && c || !p.subarray && l)) return String.fromCharCode.apply(null, r.shrinkBuf(p, f));
        for (var m = "", y = 0; y < f; y++) m += String.fromCharCode(p[y]);
        return m;
      }
      u[254] = u[254] = 1, a.string2buf = function(p) {
        var f, m, y, g, x, w = p.length, M = 0;
        for (g = 0; g < w; g++) (64512 & (m = p.charCodeAt(g))) == 55296 && g + 1 < w && (64512 & (y = p.charCodeAt(g + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (y - 56320), g++), M += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
        for (f = new r.Buf8(M), g = x = 0; x < M; g++) (64512 & (m = p.charCodeAt(g))) == 55296 && g + 1 < w && (64512 & (y = p.charCodeAt(g + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (y - 56320), g++), m < 128 ? f[x++] = m : (m < 2048 ? f[x++] = 192 | m >>> 6 : (m < 65536 ? f[x++] = 224 | m >>> 12 : (f[x++] = 240 | m >>> 18, f[x++] = 128 | m >>> 12 & 63), f[x++] = 128 | m >>> 6 & 63), f[x++] = 128 | 63 & m);
        return f;
      }, a.buf2binstring = function(p) {
        return h(p, p.length);
      }, a.binstring2buf = function(p) {
        for (var f = new r.Buf8(p.length), m = 0, y = f.length; m < y; m++) f[m] = p.charCodeAt(m);
        return f;
      }, a.buf2string = function(p, f) {
        var m, y, g, x, w = f || p.length, M = new Array(2 * w);
        for (m = y = 0; m < w; ) if ((g = p[m++]) < 128) M[y++] = g;
        else if (4 < (x = u[g])) M[y++] = 65533, m += x - 1;
        else {
          for (g &= x === 2 ? 31 : x === 3 ? 15 : 7; 1 < x && m < w; ) g = g << 6 | 63 & p[m++], x--;
          1 < x ? M[y++] = 65533 : g < 65536 ? M[y++] = g : (g -= 65536, M[y++] = 55296 | g >> 10 & 1023, M[y++] = 56320 | 1023 & g);
        }
        return h(M, y);
      }, a.utf8border = function(p, f) {
        var m;
        for ((f = f || p.length) > p.length && (f = p.length), m = f - 1; 0 <= m && (192 & p[m]) == 128; ) m--;
        return m < 0 || m === 0 ? f : m + u[p[m]] > f ? m : f;
      };
    }, { "./common": 41 }], 43: [function(i, o, a) {
      o.exports = function(r, l, c, u) {
        for (var d = 65535 & r | 0, h = r >>> 16 & 65535 | 0, p = 0; c !== 0; ) {
          for (c -= p = 2e3 < c ? 2e3 : c; h = h + (d = d + l[u++] | 0) | 0, --p; ) ;
          d %= 65521, h %= 65521;
        }
        return d | h << 16 | 0;
      };
    }, {}], 44: [function(i, o, a) {
      o.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(i, o, a) {
      var r = function() {
        for (var l, c = [], u = 0; u < 256; u++) {
          l = u;
          for (var d = 0; d < 8; d++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          c[u] = l;
        }
        return c;
      }();
      o.exports = function(l, c, u, d) {
        var h = r, p = d + u;
        l ^= -1;
        for (var f = d; f < p; f++) l = l >>> 8 ^ h[255 & (l ^ c[f])];
        return -1 ^ l;
      };
    }, {}], 46: [function(i, o, a) {
      var r, l = i("../utils/common"), c = i("./trees"), u = i("./adler32"), d = i("./crc32"), h = i("./messages"), p = 0, f = 4, m = 0, y = -2, g = -1, x = 4, w = 2, M = 8, _ = 9, C = 286, T = 30, P = 19, E = 2 * C + 1, b = 15, S = 3, A = 258, R = A + S + 1, k = 42, U = 113, I = 1, W = 2, fe = 3, q = 4;
      function G(D, j) {
        return D.msg = h[j], j;
      }
      function Q(D) {
        return (D << 1) - (4 < D ? 9 : 0);
      }
      function K(D) {
        for (var j = D.length; 0 <= --j; ) D[j] = 0;
      }
      function Y(D) {
        var j = D.state, Z = j.pending;
        Z > D.avail_out && (Z = D.avail_out), Z !== 0 && (l.arraySet(D.output, j.pending_buf, j.pending_out, Z, D.next_out), D.next_out += Z, j.pending_out += Z, D.total_out += Z, D.avail_out -= Z, j.pending -= Z, j.pending === 0 && (j.pending_out = 0));
      }
      function ee(D, j) {
        c._tr_flush_block(D, 0 <= D.block_start ? D.block_start : -1, D.strstart - D.block_start, j), D.block_start = D.strstart, Y(D.strm);
      }
      function ce(D, j) {
        D.pending_buf[D.pending++] = j;
      }
      function ae(D, j) {
        D.pending_buf[D.pending++] = j >>> 8 & 255, D.pending_buf[D.pending++] = 255 & j;
      }
      function de(D, j) {
        var Z, z, $ = D.max_chain_length, oe = D.strstart, O = D.prev_length, V = D.nice_match, H = D.strstart > D.w_size - R ? D.strstart - (D.w_size - R) : 0, X = D.window, ue = D.w_mask, me = D.prev, _e = D.strstart + A, we = X[oe + O - 1], Ae = X[oe + O];
        D.prev_length >= D.good_match && ($ >>= 2), V > D.lookahead && (V = D.lookahead);
        do
          if (X[(Z = j) + O] === Ae && X[Z + O - 1] === we && X[Z] === X[oe] && X[++Z] === X[oe + 1]) {
            oe += 2, Z++;
            do
              ;
            while (X[++oe] === X[++Z] && X[++oe] === X[++Z] && X[++oe] === X[++Z] && X[++oe] === X[++Z] && X[++oe] === X[++Z] && X[++oe] === X[++Z] && X[++oe] === X[++Z] && X[++oe] === X[++Z] && oe < _e);
            if (z = A - (_e - oe), oe = _e - A, O < z) {
              if (D.match_start = j, V <= (O = z)) break;
              we = X[oe + O - 1], Ae = X[oe + O];
            }
          }
        while ((j = me[j & ue]) > H && --$ != 0);
        return O <= D.lookahead ? O : D.lookahead;
      }
      function ie(D) {
        var j, Z, z, $, oe, O, V, H, X, ue, me = D.w_size;
        do {
          if ($ = D.window_size - D.lookahead - D.strstart, D.strstart >= me + (me - R)) {
            for (l.arraySet(D.window, D.window, me, me, 0), D.match_start -= me, D.strstart -= me, D.block_start -= me, j = Z = D.hash_size; z = D.head[--j], D.head[j] = me <= z ? z - me : 0, --Z; ) ;
            for (j = Z = me; z = D.prev[--j], D.prev[j] = me <= z ? z - me : 0, --Z; ) ;
            $ += me;
          }
          if (D.strm.avail_in === 0) break;
          if (O = D.strm, V = D.window, H = D.strstart + D.lookahead, X = $, ue = void 0, ue = O.avail_in, X < ue && (ue = X), Z = ue === 0 ? 0 : (O.avail_in -= ue, l.arraySet(V, O.input, O.next_in, ue, H), O.state.wrap === 1 ? O.adler = u(O.adler, V, ue, H) : O.state.wrap === 2 && (O.adler = d(O.adler, V, ue, H)), O.next_in += ue, O.total_in += ue, ue), D.lookahead += Z, D.lookahead + D.insert >= S) for (oe = D.strstart - D.insert, D.ins_h = D.window[oe], D.ins_h = (D.ins_h << D.hash_shift ^ D.window[oe + 1]) & D.hash_mask; D.insert && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[oe + S - 1]) & D.hash_mask, D.prev[oe & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = oe, oe++, D.insert--, !(D.lookahead + D.insert < S)); ) ;
        } while (D.lookahead < R && D.strm.avail_in !== 0);
      }
      function he(D, j) {
        for (var Z, z; ; ) {
          if (D.lookahead < R) {
            if (ie(D), D.lookahead < R && j === p) return I;
            if (D.lookahead === 0) break;
          }
          if (Z = 0, D.lookahead >= S && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + S - 1]) & D.hash_mask, Z = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart), Z !== 0 && D.strstart - Z <= D.w_size - R && (D.match_length = de(D, Z)), D.match_length >= S) if (z = c._tr_tally(D, D.strstart - D.match_start, D.match_length - S), D.lookahead -= D.match_length, D.match_length <= D.max_lazy_match && D.lookahead >= S) {
            for (D.match_length--; D.strstart++, D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + S - 1]) & D.hash_mask, Z = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart, --D.match_length != 0; ) ;
            D.strstart++;
          } else D.strstart += D.match_length, D.match_length = 0, D.ins_h = D.window[D.strstart], D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + 1]) & D.hash_mask;
          else z = c._tr_tally(D, 0, D.window[D.strstart]), D.lookahead--, D.strstart++;
          if (z && (ee(D, !1), D.strm.avail_out === 0)) return I;
        }
        return D.insert = D.strstart < S - 1 ? D.strstart : S - 1, j === f ? (ee(D, !0), D.strm.avail_out === 0 ? fe : q) : D.last_lit && (ee(D, !1), D.strm.avail_out === 0) ? I : W;
      }
      function ne(D, j) {
        for (var Z, z, $; ; ) {
          if (D.lookahead < R) {
            if (ie(D), D.lookahead < R && j === p) return I;
            if (D.lookahead === 0) break;
          }
          if (Z = 0, D.lookahead >= S && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + S - 1]) & D.hash_mask, Z = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart), D.prev_length = D.match_length, D.prev_match = D.match_start, D.match_length = S - 1, Z !== 0 && D.prev_length < D.max_lazy_match && D.strstart - Z <= D.w_size - R && (D.match_length = de(D, Z), D.match_length <= 5 && (D.strategy === 1 || D.match_length === S && 4096 < D.strstart - D.match_start) && (D.match_length = S - 1)), D.prev_length >= S && D.match_length <= D.prev_length) {
            for ($ = D.strstart + D.lookahead - S, z = c._tr_tally(D, D.strstart - 1 - D.prev_match, D.prev_length - S), D.lookahead -= D.prev_length - 1, D.prev_length -= 2; ++D.strstart <= $ && (D.ins_h = (D.ins_h << D.hash_shift ^ D.window[D.strstart + S - 1]) & D.hash_mask, Z = D.prev[D.strstart & D.w_mask] = D.head[D.ins_h], D.head[D.ins_h] = D.strstart), --D.prev_length != 0; ) ;
            if (D.match_available = 0, D.match_length = S - 1, D.strstart++, z && (ee(D, !1), D.strm.avail_out === 0)) return I;
          } else if (D.match_available) {
            if ((z = c._tr_tally(D, 0, D.window[D.strstart - 1])) && ee(D, !1), D.strstart++, D.lookahead--, D.strm.avail_out === 0) return I;
          } else D.match_available = 1, D.strstart++, D.lookahead--;
        }
        return D.match_available && (z = c._tr_tally(D, 0, D.window[D.strstart - 1]), D.match_available = 0), D.insert = D.strstart < S - 1 ? D.strstart : S - 1, j === f ? (ee(D, !0), D.strm.avail_out === 0 ? fe : q) : D.last_lit && (ee(D, !1), D.strm.avail_out === 0) ? I : W;
      }
      function N(D, j, Z, z, $) {
        this.good_length = D, this.max_lazy = j, this.nice_length = Z, this.max_chain = z, this.func = $;
      }
      function te() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = M, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new l.Buf16(2 * E), this.dyn_dtree = new l.Buf16(2 * (2 * T + 1)), this.bl_tree = new l.Buf16(2 * (2 * P + 1)), K(this.dyn_ltree), K(this.dyn_dtree), K(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new l.Buf16(b + 1), this.heap = new l.Buf16(2 * C + 1), K(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new l.Buf16(2 * C + 1), K(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function F(D) {
        var j;
        return D && D.state ? (D.total_in = D.total_out = 0, D.data_type = w, (j = D.state).pending = 0, j.pending_out = 0, j.wrap < 0 && (j.wrap = -j.wrap), j.status = j.wrap ? k : U, D.adler = j.wrap === 2 ? 0 : 1, j.last_flush = p, c._tr_init(j), m) : G(D, y);
      }
      function B(D) {
        var j = F(D);
        return j === m && function(Z) {
          Z.window_size = 2 * Z.w_size, K(Z.head), Z.max_lazy_match = r[Z.level].max_lazy, Z.good_match = r[Z.level].good_length, Z.nice_match = r[Z.level].nice_length, Z.max_chain_length = r[Z.level].max_chain, Z.strstart = 0, Z.block_start = 0, Z.lookahead = 0, Z.insert = 0, Z.match_length = Z.prev_length = S - 1, Z.match_available = 0, Z.ins_h = 0;
        }(D.state), j;
      }
      function L(D, j, Z, z, $, oe) {
        if (!D) return y;
        var O = 1;
        if (j === g && (j = 6), z < 0 ? (O = 0, z = -z) : 15 < z && (O = 2, z -= 16), $ < 1 || _ < $ || Z !== M || z < 8 || 15 < z || j < 0 || 9 < j || oe < 0 || x < oe) return G(D, y);
        z === 8 && (z = 9);
        var V = new te();
        return (D.state = V).strm = D, V.wrap = O, V.gzhead = null, V.w_bits = z, V.w_size = 1 << V.w_bits, V.w_mask = V.w_size - 1, V.hash_bits = $ + 7, V.hash_size = 1 << V.hash_bits, V.hash_mask = V.hash_size - 1, V.hash_shift = ~~((V.hash_bits + S - 1) / S), V.window = new l.Buf8(2 * V.w_size), V.head = new l.Buf16(V.hash_size), V.prev = new l.Buf16(V.w_size), V.lit_bufsize = 1 << $ + 6, V.pending_buf_size = 4 * V.lit_bufsize, V.pending_buf = new l.Buf8(V.pending_buf_size), V.d_buf = 1 * V.lit_bufsize, V.l_buf = 3 * V.lit_bufsize, V.level = j, V.strategy = oe, V.method = Z, B(D);
      }
      r = [new N(0, 0, 0, 0, function(D, j) {
        var Z = 65535;
        for (Z > D.pending_buf_size - 5 && (Z = D.pending_buf_size - 5); ; ) {
          if (D.lookahead <= 1) {
            if (ie(D), D.lookahead === 0 && j === p) return I;
            if (D.lookahead === 0) break;
          }
          D.strstart += D.lookahead, D.lookahead = 0;
          var z = D.block_start + Z;
          if ((D.strstart === 0 || D.strstart >= z) && (D.lookahead = D.strstart - z, D.strstart = z, ee(D, !1), D.strm.avail_out === 0) || D.strstart - D.block_start >= D.w_size - R && (ee(D, !1), D.strm.avail_out === 0)) return I;
        }
        return D.insert = 0, j === f ? (ee(D, !0), D.strm.avail_out === 0 ? fe : q) : (D.strstart > D.block_start && (ee(D, !1), D.strm.avail_out), I);
      }), new N(4, 4, 8, 4, he), new N(4, 5, 16, 8, he), new N(4, 6, 32, 32, he), new N(4, 4, 16, 16, ne), new N(8, 16, 32, 32, ne), new N(8, 16, 128, 128, ne), new N(8, 32, 128, 256, ne), new N(32, 128, 258, 1024, ne), new N(32, 258, 258, 4096, ne)], a.deflateInit = function(D, j) {
        return L(D, j, M, 15, 8, 0);
      }, a.deflateInit2 = L, a.deflateReset = B, a.deflateResetKeep = F, a.deflateSetHeader = function(D, j) {
        return D && D.state ? D.state.wrap !== 2 ? y : (D.state.gzhead = j, m) : y;
      }, a.deflate = function(D, j) {
        var Z, z, $, oe;
        if (!D || !D.state || 5 < j || j < 0) return D ? G(D, y) : y;
        if (z = D.state, !D.output || !D.input && D.avail_in !== 0 || z.status === 666 && j !== f) return G(D, D.avail_out === 0 ? -5 : y);
        if (z.strm = D, Z = z.last_flush, z.last_flush = j, z.status === k) if (z.wrap === 2) D.adler = 0, ce(z, 31), ce(z, 139), ce(z, 8), z.gzhead ? (ce(z, (z.gzhead.text ? 1 : 0) + (z.gzhead.hcrc ? 2 : 0) + (z.gzhead.extra ? 4 : 0) + (z.gzhead.name ? 8 : 0) + (z.gzhead.comment ? 16 : 0)), ce(z, 255 & z.gzhead.time), ce(z, z.gzhead.time >> 8 & 255), ce(z, z.gzhead.time >> 16 & 255), ce(z, z.gzhead.time >> 24 & 255), ce(z, z.level === 9 ? 2 : 2 <= z.strategy || z.level < 2 ? 4 : 0), ce(z, 255 & z.gzhead.os), z.gzhead.extra && z.gzhead.extra.length && (ce(z, 255 & z.gzhead.extra.length), ce(z, z.gzhead.extra.length >> 8 & 255)), z.gzhead.hcrc && (D.adler = d(D.adler, z.pending_buf, z.pending, 0)), z.gzindex = 0, z.status = 69) : (ce(z, 0), ce(z, 0), ce(z, 0), ce(z, 0), ce(z, 0), ce(z, z.level === 9 ? 2 : 2 <= z.strategy || z.level < 2 ? 4 : 0), ce(z, 3), z.status = U);
        else {
          var O = M + (z.w_bits - 8 << 4) << 8;
          O |= (2 <= z.strategy || z.level < 2 ? 0 : z.level < 6 ? 1 : z.level === 6 ? 2 : 3) << 6, z.strstart !== 0 && (O |= 32), O += 31 - O % 31, z.status = U, ae(z, O), z.strstart !== 0 && (ae(z, D.adler >>> 16), ae(z, 65535 & D.adler)), D.adler = 1;
        }
        if (z.status === 69) if (z.gzhead.extra) {
          for ($ = z.pending; z.gzindex < (65535 & z.gzhead.extra.length) && (z.pending !== z.pending_buf_size || (z.gzhead.hcrc && z.pending > $ && (D.adler = d(D.adler, z.pending_buf, z.pending - $, $)), Y(D), $ = z.pending, z.pending !== z.pending_buf_size)); ) ce(z, 255 & z.gzhead.extra[z.gzindex]), z.gzindex++;
          z.gzhead.hcrc && z.pending > $ && (D.adler = d(D.adler, z.pending_buf, z.pending - $, $)), z.gzindex === z.gzhead.extra.length && (z.gzindex = 0, z.status = 73);
        } else z.status = 73;
        if (z.status === 73) if (z.gzhead.name) {
          $ = z.pending;
          do {
            if (z.pending === z.pending_buf_size && (z.gzhead.hcrc && z.pending > $ && (D.adler = d(D.adler, z.pending_buf, z.pending - $, $)), Y(D), $ = z.pending, z.pending === z.pending_buf_size)) {
              oe = 1;
              break;
            }
            oe = z.gzindex < z.gzhead.name.length ? 255 & z.gzhead.name.charCodeAt(z.gzindex++) : 0, ce(z, oe);
          } while (oe !== 0);
          z.gzhead.hcrc && z.pending > $ && (D.adler = d(D.adler, z.pending_buf, z.pending - $, $)), oe === 0 && (z.gzindex = 0, z.status = 91);
        } else z.status = 91;
        if (z.status === 91) if (z.gzhead.comment) {
          $ = z.pending;
          do {
            if (z.pending === z.pending_buf_size && (z.gzhead.hcrc && z.pending > $ && (D.adler = d(D.adler, z.pending_buf, z.pending - $, $)), Y(D), $ = z.pending, z.pending === z.pending_buf_size)) {
              oe = 1;
              break;
            }
            oe = z.gzindex < z.gzhead.comment.length ? 255 & z.gzhead.comment.charCodeAt(z.gzindex++) : 0, ce(z, oe);
          } while (oe !== 0);
          z.gzhead.hcrc && z.pending > $ && (D.adler = d(D.adler, z.pending_buf, z.pending - $, $)), oe === 0 && (z.status = 103);
        } else z.status = 103;
        if (z.status === 103 && (z.gzhead.hcrc ? (z.pending + 2 > z.pending_buf_size && Y(D), z.pending + 2 <= z.pending_buf_size && (ce(z, 255 & D.adler), ce(z, D.adler >> 8 & 255), D.adler = 0, z.status = U)) : z.status = U), z.pending !== 0) {
          if (Y(D), D.avail_out === 0) return z.last_flush = -1, m;
        } else if (D.avail_in === 0 && Q(j) <= Q(Z) && j !== f) return G(D, -5);
        if (z.status === 666 && D.avail_in !== 0) return G(D, -5);
        if (D.avail_in !== 0 || z.lookahead !== 0 || j !== p && z.status !== 666) {
          var V = z.strategy === 2 ? function(H, X) {
            for (var ue; ; ) {
              if (H.lookahead === 0 && (ie(H), H.lookahead === 0)) {
                if (X === p) return I;
                break;
              }
              if (H.match_length = 0, ue = c._tr_tally(H, 0, H.window[H.strstart]), H.lookahead--, H.strstart++, ue && (ee(H, !1), H.strm.avail_out === 0)) return I;
            }
            return H.insert = 0, X === f ? (ee(H, !0), H.strm.avail_out === 0 ? fe : q) : H.last_lit && (ee(H, !1), H.strm.avail_out === 0) ? I : W;
          }(z, j) : z.strategy === 3 ? function(H, X) {
            for (var ue, me, _e, we, Ae = H.window; ; ) {
              if (H.lookahead <= A) {
                if (ie(H), H.lookahead <= A && X === p) return I;
                if (H.lookahead === 0) break;
              }
              if (H.match_length = 0, H.lookahead >= S && 0 < H.strstart && (me = Ae[_e = H.strstart - 1]) === Ae[++_e] && me === Ae[++_e] && me === Ae[++_e]) {
                we = H.strstart + A;
                do
                  ;
                while (me === Ae[++_e] && me === Ae[++_e] && me === Ae[++_e] && me === Ae[++_e] && me === Ae[++_e] && me === Ae[++_e] && me === Ae[++_e] && me === Ae[++_e] && _e < we);
                H.match_length = A - (we - _e), H.match_length > H.lookahead && (H.match_length = H.lookahead);
              }
              if (H.match_length >= S ? (ue = c._tr_tally(H, 1, H.match_length - S), H.lookahead -= H.match_length, H.strstart += H.match_length, H.match_length = 0) : (ue = c._tr_tally(H, 0, H.window[H.strstart]), H.lookahead--, H.strstart++), ue && (ee(H, !1), H.strm.avail_out === 0)) return I;
            }
            return H.insert = 0, X === f ? (ee(H, !0), H.strm.avail_out === 0 ? fe : q) : H.last_lit && (ee(H, !1), H.strm.avail_out === 0) ? I : W;
          }(z, j) : r[z.level].func(z, j);
          if (V !== fe && V !== q || (z.status = 666), V === I || V === fe) return D.avail_out === 0 && (z.last_flush = -1), m;
          if (V === W && (j === 1 ? c._tr_align(z) : j !== 5 && (c._tr_stored_block(z, 0, 0, !1), j === 3 && (K(z.head), z.lookahead === 0 && (z.strstart = 0, z.block_start = 0, z.insert = 0))), Y(D), D.avail_out === 0)) return z.last_flush = -1, m;
        }
        return j !== f ? m : z.wrap <= 0 ? 1 : (z.wrap === 2 ? (ce(z, 255 & D.adler), ce(z, D.adler >> 8 & 255), ce(z, D.adler >> 16 & 255), ce(z, D.adler >> 24 & 255), ce(z, 255 & D.total_in), ce(z, D.total_in >> 8 & 255), ce(z, D.total_in >> 16 & 255), ce(z, D.total_in >> 24 & 255)) : (ae(z, D.adler >>> 16), ae(z, 65535 & D.adler)), Y(D), 0 < z.wrap && (z.wrap = -z.wrap), z.pending !== 0 ? m : 1);
      }, a.deflateEnd = function(D) {
        var j;
        return D && D.state ? (j = D.state.status) !== k && j !== 69 && j !== 73 && j !== 91 && j !== 103 && j !== U && j !== 666 ? G(D, y) : (D.state = null, j === U ? G(D, -3) : m) : y;
      }, a.deflateSetDictionary = function(D, j) {
        var Z, z, $, oe, O, V, H, X, ue = j.length;
        if (!D || !D.state || (oe = (Z = D.state).wrap) === 2 || oe === 1 && Z.status !== k || Z.lookahead) return y;
        for (oe === 1 && (D.adler = u(D.adler, j, ue, 0)), Z.wrap = 0, ue >= Z.w_size && (oe === 0 && (K(Z.head), Z.strstart = 0, Z.block_start = 0, Z.insert = 0), X = new l.Buf8(Z.w_size), l.arraySet(X, j, ue - Z.w_size, Z.w_size, 0), j = X, ue = Z.w_size), O = D.avail_in, V = D.next_in, H = D.input, D.avail_in = ue, D.next_in = 0, D.input = j, ie(Z); Z.lookahead >= S; ) {
          for (z = Z.strstart, $ = Z.lookahead - (S - 1); Z.ins_h = (Z.ins_h << Z.hash_shift ^ Z.window[z + S - 1]) & Z.hash_mask, Z.prev[z & Z.w_mask] = Z.head[Z.ins_h], Z.head[Z.ins_h] = z, z++, --$; ) ;
          Z.strstart = z, Z.lookahead = S - 1, ie(Z);
        }
        return Z.strstart += Z.lookahead, Z.block_start = Z.strstart, Z.insert = Z.lookahead, Z.lookahead = 0, Z.match_length = Z.prev_length = S - 1, Z.match_available = 0, D.next_in = V, D.input = H, D.avail_in = O, Z.wrap = oe, m;
      }, a.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(i, o, a) {
      o.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(i, o, a) {
      o.exports = function(r, l) {
        var c, u, d, h, p, f, m, y, g, x, w, M, _, C, T, P, E, b, S, A, R, k, U, I, W;
        c = r.state, u = r.next_in, I = r.input, d = u + (r.avail_in - 5), h = r.next_out, W = r.output, p = h - (l - r.avail_out), f = h + (r.avail_out - 257), m = c.dmax, y = c.wsize, g = c.whave, x = c.wnext, w = c.window, M = c.hold, _ = c.bits, C = c.lencode, T = c.distcode, P = (1 << c.lenbits) - 1, E = (1 << c.distbits) - 1;
        e: do {
          _ < 15 && (M += I[u++] << _, _ += 8, M += I[u++] << _, _ += 8), b = C[M & P];
          t: for (; ; ) {
            if (M >>>= S = b >>> 24, _ -= S, (S = b >>> 16 & 255) === 0) W[h++] = 65535 & b;
            else {
              if (!(16 & S)) {
                if (!(64 & S)) {
                  b = C[(65535 & b) + (M & (1 << S) - 1)];
                  continue t;
                }
                if (32 & S) {
                  c.mode = 12;
                  break e;
                }
                r.msg = "invalid literal/length code", c.mode = 30;
                break e;
              }
              A = 65535 & b, (S &= 15) && (_ < S && (M += I[u++] << _, _ += 8), A += M & (1 << S) - 1, M >>>= S, _ -= S), _ < 15 && (M += I[u++] << _, _ += 8, M += I[u++] << _, _ += 8), b = T[M & E];
              n: for (; ; ) {
                if (M >>>= S = b >>> 24, _ -= S, !(16 & (S = b >>> 16 & 255))) {
                  if (!(64 & S)) {
                    b = T[(65535 & b) + (M & (1 << S) - 1)];
                    continue n;
                  }
                  r.msg = "invalid distance code", c.mode = 30;
                  break e;
                }
                if (R = 65535 & b, _ < (S &= 15) && (M += I[u++] << _, (_ += 8) < S && (M += I[u++] << _, _ += 8)), m < (R += M & (1 << S) - 1)) {
                  r.msg = "invalid distance too far back", c.mode = 30;
                  break e;
                }
                if (M >>>= S, _ -= S, (S = h - p) < R) {
                  if (g < (S = R - S) && c.sane) {
                    r.msg = "invalid distance too far back", c.mode = 30;
                    break e;
                  }
                  if (U = w, (k = 0) === x) {
                    if (k += y - S, S < A) {
                      for (A -= S; W[h++] = w[k++], --S; ) ;
                      k = h - R, U = W;
                    }
                  } else if (x < S) {
                    if (k += y + x - S, (S -= x) < A) {
                      for (A -= S; W[h++] = w[k++], --S; ) ;
                      if (k = 0, x < A) {
                        for (A -= S = x; W[h++] = w[k++], --S; ) ;
                        k = h - R, U = W;
                      }
                    }
                  } else if (k += x - S, S < A) {
                    for (A -= S; W[h++] = w[k++], --S; ) ;
                    k = h - R, U = W;
                  }
                  for (; 2 < A; ) W[h++] = U[k++], W[h++] = U[k++], W[h++] = U[k++], A -= 3;
                  A && (W[h++] = U[k++], 1 < A && (W[h++] = U[k++]));
                } else {
                  for (k = h - R; W[h++] = W[k++], W[h++] = W[k++], W[h++] = W[k++], 2 < (A -= 3); ) ;
                  A && (W[h++] = W[k++], 1 < A && (W[h++] = W[k++]));
                }
                break;
              }
            }
            break;
          }
        } while (u < d && h < f);
        u -= A = _ >> 3, M &= (1 << (_ -= A << 3)) - 1, r.next_in = u, r.next_out = h, r.avail_in = u < d ? d - u + 5 : 5 - (u - d), r.avail_out = h < f ? f - h + 257 : 257 - (h - f), c.hold = M, c.bits = _;
      };
    }, {}], 49: [function(i, o, a) {
      var r = i("../utils/common"), l = i("./adler32"), c = i("./crc32"), u = i("./inffast"), d = i("./inftrees"), h = 1, p = 2, f = 0, m = -2, y = 1, g = 852, x = 592;
      function w(k) {
        return (k >>> 24 & 255) + (k >>> 8 & 65280) + ((65280 & k) << 8) + ((255 & k) << 24);
      }
      function M() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function _(k) {
        var U;
        return k && k.state ? (U = k.state, k.total_in = k.total_out = U.total = 0, k.msg = "", U.wrap && (k.adler = 1 & U.wrap), U.mode = y, U.last = 0, U.havedict = 0, U.dmax = 32768, U.head = null, U.hold = 0, U.bits = 0, U.lencode = U.lendyn = new r.Buf32(g), U.distcode = U.distdyn = new r.Buf32(x), U.sane = 1, U.back = -1, f) : m;
      }
      function C(k) {
        var U;
        return k && k.state ? ((U = k.state).wsize = 0, U.whave = 0, U.wnext = 0, _(k)) : m;
      }
      function T(k, U) {
        var I, W;
        return k && k.state ? (W = k.state, U < 0 ? (I = 0, U = -U) : (I = 1 + (U >> 4), U < 48 && (U &= 15)), U && (U < 8 || 15 < U) ? m : (W.window !== null && W.wbits !== U && (W.window = null), W.wrap = I, W.wbits = U, C(k))) : m;
      }
      function P(k, U) {
        var I, W;
        return k ? (W = new M(), (k.state = W).window = null, (I = T(k, U)) !== f && (k.state = null), I) : m;
      }
      var E, b, S = !0;
      function A(k) {
        if (S) {
          var U;
          for (E = new r.Buf32(512), b = new r.Buf32(32), U = 0; U < 144; ) k.lens[U++] = 8;
          for (; U < 256; ) k.lens[U++] = 9;
          for (; U < 280; ) k.lens[U++] = 7;
          for (; U < 288; ) k.lens[U++] = 8;
          for (d(h, k.lens, 0, 288, E, 0, k.work, { bits: 9 }), U = 0; U < 32; ) k.lens[U++] = 5;
          d(p, k.lens, 0, 32, b, 0, k.work, { bits: 5 }), S = !1;
        }
        k.lencode = E, k.lenbits = 9, k.distcode = b, k.distbits = 5;
      }
      function R(k, U, I, W) {
        var fe, q = k.state;
        return q.window === null && (q.wsize = 1 << q.wbits, q.wnext = 0, q.whave = 0, q.window = new r.Buf8(q.wsize)), W >= q.wsize ? (r.arraySet(q.window, U, I - q.wsize, q.wsize, 0), q.wnext = 0, q.whave = q.wsize) : (W < (fe = q.wsize - q.wnext) && (fe = W), r.arraySet(q.window, U, I - W, fe, q.wnext), (W -= fe) ? (r.arraySet(q.window, U, I - W, W, 0), q.wnext = W, q.whave = q.wsize) : (q.wnext += fe, q.wnext === q.wsize && (q.wnext = 0), q.whave < q.wsize && (q.whave += fe))), 0;
      }
      a.inflateReset = C, a.inflateReset2 = T, a.inflateResetKeep = _, a.inflateInit = function(k) {
        return P(k, 15);
      }, a.inflateInit2 = P, a.inflate = function(k, U) {
        var I, W, fe, q, G, Q, K, Y, ee, ce, ae, de, ie, he, ne, N, te, F, B, L, D, j, Z, z, $ = 0, oe = new r.Buf8(4), O = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!k || !k.state || !k.output || !k.input && k.avail_in !== 0) return m;
        (I = k.state).mode === 12 && (I.mode = 13), G = k.next_out, fe = k.output, K = k.avail_out, q = k.next_in, W = k.input, Q = k.avail_in, Y = I.hold, ee = I.bits, ce = Q, ae = K, j = f;
        e: for (; ; ) switch (I.mode) {
          case y:
            if (I.wrap === 0) {
              I.mode = 13;
              break;
            }
            for (; ee < 16; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            if (2 & I.wrap && Y === 35615) {
              oe[I.check = 0] = 255 & Y, oe[1] = Y >>> 8 & 255, I.check = c(I.check, oe, 2, 0), ee = Y = 0, I.mode = 2;
              break;
            }
            if (I.flags = 0, I.head && (I.head.done = !1), !(1 & I.wrap) || (((255 & Y) << 8) + (Y >> 8)) % 31) {
              k.msg = "incorrect header check", I.mode = 30;
              break;
            }
            if ((15 & Y) != 8) {
              k.msg = "unknown compression method", I.mode = 30;
              break;
            }
            if (ee -= 4, D = 8 + (15 & (Y >>>= 4)), I.wbits === 0) I.wbits = D;
            else if (D > I.wbits) {
              k.msg = "invalid window size", I.mode = 30;
              break;
            }
            I.dmax = 1 << D, k.adler = I.check = 1, I.mode = 512 & Y ? 10 : 12, ee = Y = 0;
            break;
          case 2:
            for (; ee < 16; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            if (I.flags = Y, (255 & I.flags) != 8) {
              k.msg = "unknown compression method", I.mode = 30;
              break;
            }
            if (57344 & I.flags) {
              k.msg = "unknown header flags set", I.mode = 30;
              break;
            }
            I.head && (I.head.text = Y >> 8 & 1), 512 & I.flags && (oe[0] = 255 & Y, oe[1] = Y >>> 8 & 255, I.check = c(I.check, oe, 2, 0)), ee = Y = 0, I.mode = 3;
          case 3:
            for (; ee < 32; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            I.head && (I.head.time = Y), 512 & I.flags && (oe[0] = 255 & Y, oe[1] = Y >>> 8 & 255, oe[2] = Y >>> 16 & 255, oe[3] = Y >>> 24 & 255, I.check = c(I.check, oe, 4, 0)), ee = Y = 0, I.mode = 4;
          case 4:
            for (; ee < 16; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            I.head && (I.head.xflags = 255 & Y, I.head.os = Y >> 8), 512 & I.flags && (oe[0] = 255 & Y, oe[1] = Y >>> 8 & 255, I.check = c(I.check, oe, 2, 0)), ee = Y = 0, I.mode = 5;
          case 5:
            if (1024 & I.flags) {
              for (; ee < 16; ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              I.length = Y, I.head && (I.head.extra_len = Y), 512 & I.flags && (oe[0] = 255 & Y, oe[1] = Y >>> 8 & 255, I.check = c(I.check, oe, 2, 0)), ee = Y = 0;
            } else I.head && (I.head.extra = null);
            I.mode = 6;
          case 6:
            if (1024 & I.flags && (Q < (de = I.length) && (de = Q), de && (I.head && (D = I.head.extra_len - I.length, I.head.extra || (I.head.extra = new Array(I.head.extra_len)), r.arraySet(I.head.extra, W, q, de, D)), 512 & I.flags && (I.check = c(I.check, W, de, q)), Q -= de, q += de, I.length -= de), I.length)) break e;
            I.length = 0, I.mode = 7;
          case 7:
            if (2048 & I.flags) {
              if (Q === 0) break e;
              for (de = 0; D = W[q + de++], I.head && D && I.length < 65536 && (I.head.name += String.fromCharCode(D)), D && de < Q; ) ;
              if (512 & I.flags && (I.check = c(I.check, W, de, q)), Q -= de, q += de, D) break e;
            } else I.head && (I.head.name = null);
            I.length = 0, I.mode = 8;
          case 8:
            if (4096 & I.flags) {
              if (Q === 0) break e;
              for (de = 0; D = W[q + de++], I.head && D && I.length < 65536 && (I.head.comment += String.fromCharCode(D)), D && de < Q; ) ;
              if (512 & I.flags && (I.check = c(I.check, W, de, q)), Q -= de, q += de, D) break e;
            } else I.head && (I.head.comment = null);
            I.mode = 9;
          case 9:
            if (512 & I.flags) {
              for (; ee < 16; ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              if (Y !== (65535 & I.check)) {
                k.msg = "header crc mismatch", I.mode = 30;
                break;
              }
              ee = Y = 0;
            }
            I.head && (I.head.hcrc = I.flags >> 9 & 1, I.head.done = !0), k.adler = I.check = 0, I.mode = 12;
            break;
          case 10:
            for (; ee < 32; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            k.adler = I.check = w(Y), ee = Y = 0, I.mode = 11;
          case 11:
            if (I.havedict === 0) return k.next_out = G, k.avail_out = K, k.next_in = q, k.avail_in = Q, I.hold = Y, I.bits = ee, 2;
            k.adler = I.check = 1, I.mode = 12;
          case 12:
            if (U === 5 || U === 6) break e;
          case 13:
            if (I.last) {
              Y >>>= 7 & ee, ee -= 7 & ee, I.mode = 27;
              break;
            }
            for (; ee < 3; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            switch (I.last = 1 & Y, ee -= 1, 3 & (Y >>>= 1)) {
              case 0:
                I.mode = 14;
                break;
              case 1:
                if (A(I), I.mode = 20, U !== 6) break;
                Y >>>= 2, ee -= 2;
                break e;
              case 2:
                I.mode = 17;
                break;
              case 3:
                k.msg = "invalid block type", I.mode = 30;
            }
            Y >>>= 2, ee -= 2;
            break;
          case 14:
            for (Y >>>= 7 & ee, ee -= 7 & ee; ee < 32; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            if ((65535 & Y) != (Y >>> 16 ^ 65535)) {
              k.msg = "invalid stored block lengths", I.mode = 30;
              break;
            }
            if (I.length = 65535 & Y, ee = Y = 0, I.mode = 15, U === 6) break e;
          case 15:
            I.mode = 16;
          case 16:
            if (de = I.length) {
              if (Q < de && (de = Q), K < de && (de = K), de === 0) break e;
              r.arraySet(fe, W, q, de, G), Q -= de, q += de, K -= de, G += de, I.length -= de;
              break;
            }
            I.mode = 12;
            break;
          case 17:
            for (; ee < 14; ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            if (I.nlen = 257 + (31 & Y), Y >>>= 5, ee -= 5, I.ndist = 1 + (31 & Y), Y >>>= 5, ee -= 5, I.ncode = 4 + (15 & Y), Y >>>= 4, ee -= 4, 286 < I.nlen || 30 < I.ndist) {
              k.msg = "too many length or distance symbols", I.mode = 30;
              break;
            }
            I.have = 0, I.mode = 18;
          case 18:
            for (; I.have < I.ncode; ) {
              for (; ee < 3; ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              I.lens[O[I.have++]] = 7 & Y, Y >>>= 3, ee -= 3;
            }
            for (; I.have < 19; ) I.lens[O[I.have++]] = 0;
            if (I.lencode = I.lendyn, I.lenbits = 7, Z = { bits: I.lenbits }, j = d(0, I.lens, 0, 19, I.lencode, 0, I.work, Z), I.lenbits = Z.bits, j) {
              k.msg = "invalid code lengths set", I.mode = 30;
              break;
            }
            I.have = 0, I.mode = 19;
          case 19:
            for (; I.have < I.nlen + I.ndist; ) {
              for (; N = ($ = I.lencode[Y & (1 << I.lenbits) - 1]) >>> 16 & 255, te = 65535 & $, !((ne = $ >>> 24) <= ee); ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              if (te < 16) Y >>>= ne, ee -= ne, I.lens[I.have++] = te;
              else {
                if (te === 16) {
                  for (z = ne + 2; ee < z; ) {
                    if (Q === 0) break e;
                    Q--, Y += W[q++] << ee, ee += 8;
                  }
                  if (Y >>>= ne, ee -= ne, I.have === 0) {
                    k.msg = "invalid bit length repeat", I.mode = 30;
                    break;
                  }
                  D = I.lens[I.have - 1], de = 3 + (3 & Y), Y >>>= 2, ee -= 2;
                } else if (te === 17) {
                  for (z = ne + 3; ee < z; ) {
                    if (Q === 0) break e;
                    Q--, Y += W[q++] << ee, ee += 8;
                  }
                  ee -= ne, D = 0, de = 3 + (7 & (Y >>>= ne)), Y >>>= 3, ee -= 3;
                } else {
                  for (z = ne + 7; ee < z; ) {
                    if (Q === 0) break e;
                    Q--, Y += W[q++] << ee, ee += 8;
                  }
                  ee -= ne, D = 0, de = 11 + (127 & (Y >>>= ne)), Y >>>= 7, ee -= 7;
                }
                if (I.have + de > I.nlen + I.ndist) {
                  k.msg = "invalid bit length repeat", I.mode = 30;
                  break;
                }
                for (; de--; ) I.lens[I.have++] = D;
              }
            }
            if (I.mode === 30) break;
            if (I.lens[256] === 0) {
              k.msg = "invalid code -- missing end-of-block", I.mode = 30;
              break;
            }
            if (I.lenbits = 9, Z = { bits: I.lenbits }, j = d(h, I.lens, 0, I.nlen, I.lencode, 0, I.work, Z), I.lenbits = Z.bits, j) {
              k.msg = "invalid literal/lengths set", I.mode = 30;
              break;
            }
            if (I.distbits = 6, I.distcode = I.distdyn, Z = { bits: I.distbits }, j = d(p, I.lens, I.nlen, I.ndist, I.distcode, 0, I.work, Z), I.distbits = Z.bits, j) {
              k.msg = "invalid distances set", I.mode = 30;
              break;
            }
            if (I.mode = 20, U === 6) break e;
          case 20:
            I.mode = 21;
          case 21:
            if (6 <= Q && 258 <= K) {
              k.next_out = G, k.avail_out = K, k.next_in = q, k.avail_in = Q, I.hold = Y, I.bits = ee, u(k, ae), G = k.next_out, fe = k.output, K = k.avail_out, q = k.next_in, W = k.input, Q = k.avail_in, Y = I.hold, ee = I.bits, I.mode === 12 && (I.back = -1);
              break;
            }
            for (I.back = 0; N = ($ = I.lencode[Y & (1 << I.lenbits) - 1]) >>> 16 & 255, te = 65535 & $, !((ne = $ >>> 24) <= ee); ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            if (N && !(240 & N)) {
              for (F = ne, B = N, L = te; N = ($ = I.lencode[L + ((Y & (1 << F + B) - 1) >> F)]) >>> 16 & 255, te = 65535 & $, !(F + (ne = $ >>> 24) <= ee); ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              Y >>>= F, ee -= F, I.back += F;
            }
            if (Y >>>= ne, ee -= ne, I.back += ne, I.length = te, N === 0) {
              I.mode = 26;
              break;
            }
            if (32 & N) {
              I.back = -1, I.mode = 12;
              break;
            }
            if (64 & N) {
              k.msg = "invalid literal/length code", I.mode = 30;
              break;
            }
            I.extra = 15 & N, I.mode = 22;
          case 22:
            if (I.extra) {
              for (z = I.extra; ee < z; ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              I.length += Y & (1 << I.extra) - 1, Y >>>= I.extra, ee -= I.extra, I.back += I.extra;
            }
            I.was = I.length, I.mode = 23;
          case 23:
            for (; N = ($ = I.distcode[Y & (1 << I.distbits) - 1]) >>> 16 & 255, te = 65535 & $, !((ne = $ >>> 24) <= ee); ) {
              if (Q === 0) break e;
              Q--, Y += W[q++] << ee, ee += 8;
            }
            if (!(240 & N)) {
              for (F = ne, B = N, L = te; N = ($ = I.distcode[L + ((Y & (1 << F + B) - 1) >> F)]) >>> 16 & 255, te = 65535 & $, !(F + (ne = $ >>> 24) <= ee); ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              Y >>>= F, ee -= F, I.back += F;
            }
            if (Y >>>= ne, ee -= ne, I.back += ne, 64 & N) {
              k.msg = "invalid distance code", I.mode = 30;
              break;
            }
            I.offset = te, I.extra = 15 & N, I.mode = 24;
          case 24:
            if (I.extra) {
              for (z = I.extra; ee < z; ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              I.offset += Y & (1 << I.extra) - 1, Y >>>= I.extra, ee -= I.extra, I.back += I.extra;
            }
            if (I.offset > I.dmax) {
              k.msg = "invalid distance too far back", I.mode = 30;
              break;
            }
            I.mode = 25;
          case 25:
            if (K === 0) break e;
            if (de = ae - K, I.offset > de) {
              if ((de = I.offset - de) > I.whave && I.sane) {
                k.msg = "invalid distance too far back", I.mode = 30;
                break;
              }
              ie = de > I.wnext ? (de -= I.wnext, I.wsize - de) : I.wnext - de, de > I.length && (de = I.length), he = I.window;
            } else he = fe, ie = G - I.offset, de = I.length;
            for (K < de && (de = K), K -= de, I.length -= de; fe[G++] = he[ie++], --de; ) ;
            I.length === 0 && (I.mode = 21);
            break;
          case 26:
            if (K === 0) break e;
            fe[G++] = I.length, K--, I.mode = 21;
            break;
          case 27:
            if (I.wrap) {
              for (; ee < 32; ) {
                if (Q === 0) break e;
                Q--, Y |= W[q++] << ee, ee += 8;
              }
              if (ae -= K, k.total_out += ae, I.total += ae, ae && (k.adler = I.check = I.flags ? c(I.check, fe, ae, G - ae) : l(I.check, fe, ae, G - ae)), ae = K, (I.flags ? Y : w(Y)) !== I.check) {
                k.msg = "incorrect data check", I.mode = 30;
                break;
              }
              ee = Y = 0;
            }
            I.mode = 28;
          case 28:
            if (I.wrap && I.flags) {
              for (; ee < 32; ) {
                if (Q === 0) break e;
                Q--, Y += W[q++] << ee, ee += 8;
              }
              if (Y !== (4294967295 & I.total)) {
                k.msg = "incorrect length check", I.mode = 30;
                break;
              }
              ee = Y = 0;
            }
            I.mode = 29;
          case 29:
            j = 1;
            break e;
          case 30:
            j = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return m;
        }
        return k.next_out = G, k.avail_out = K, k.next_in = q, k.avail_in = Q, I.hold = Y, I.bits = ee, (I.wsize || ae !== k.avail_out && I.mode < 30 && (I.mode < 27 || U !== 4)) && R(k, k.output, k.next_out, ae - k.avail_out) ? (I.mode = 31, -4) : (ce -= k.avail_in, ae -= k.avail_out, k.total_in += ce, k.total_out += ae, I.total += ae, I.wrap && ae && (k.adler = I.check = I.flags ? c(I.check, fe, ae, k.next_out - ae) : l(I.check, fe, ae, k.next_out - ae)), k.data_type = I.bits + (I.last ? 64 : 0) + (I.mode === 12 ? 128 : 0) + (I.mode === 20 || I.mode === 15 ? 256 : 0), (ce == 0 && ae === 0 || U === 4) && j === f && (j = -5), j);
      }, a.inflateEnd = function(k) {
        if (!k || !k.state) return m;
        var U = k.state;
        return U.window && (U.window = null), k.state = null, f;
      }, a.inflateGetHeader = function(k, U) {
        var I;
        return k && k.state && 2 & (I = k.state).wrap ? ((I.head = U).done = !1, f) : m;
      }, a.inflateSetDictionary = function(k, U) {
        var I, W = U.length;
        return k && k.state ? (I = k.state).wrap !== 0 && I.mode !== 11 ? m : I.mode === 11 && l(1, U, W, 0) !== I.check ? -3 : R(k, U, W, W) ? (I.mode = 31, -4) : (I.havedict = 1, f) : m;
      }, a.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(i, o, a) {
      var r = i("../utils/common"), l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      o.exports = function(h, p, f, m, y, g, x, w) {
        var M, _, C, T, P, E, b, S, A, R = w.bits, k = 0, U = 0, I = 0, W = 0, fe = 0, q = 0, G = 0, Q = 0, K = 0, Y = 0, ee = null, ce = 0, ae = new r.Buf16(16), de = new r.Buf16(16), ie = null, he = 0;
        for (k = 0; k <= 15; k++) ae[k] = 0;
        for (U = 0; U < m; U++) ae[p[f + U]]++;
        for (fe = R, W = 15; 1 <= W && ae[W] === 0; W--) ;
        if (W < fe && (fe = W), W === 0) return y[g++] = 20971520, y[g++] = 20971520, w.bits = 1, 0;
        for (I = 1; I < W && ae[I] === 0; I++) ;
        for (fe < I && (fe = I), k = Q = 1; k <= 15; k++) if (Q <<= 1, (Q -= ae[k]) < 0) return -1;
        if (0 < Q && (h === 0 || W !== 1)) return -1;
        for (de[1] = 0, k = 1; k < 15; k++) de[k + 1] = de[k] + ae[k];
        for (U = 0; U < m; U++) p[f + U] !== 0 && (x[de[p[f + U]]++] = U);
        if (E = h === 0 ? (ee = ie = x, 19) : h === 1 ? (ee = l, ce -= 257, ie = c, he -= 257, 256) : (ee = u, ie = d, -1), k = I, P = g, G = U = Y = 0, C = -1, T = (K = 1 << (q = fe)) - 1, h === 1 && 852 < K || h === 2 && 592 < K) return 1;
        for (; ; ) {
          for (b = k - G, A = x[U] < E ? (S = 0, x[U]) : x[U] > E ? (S = ie[he + x[U]], ee[ce + x[U]]) : (S = 96, 0), M = 1 << k - G, I = _ = 1 << q; y[P + (Y >> G) + (_ -= M)] = b << 24 | S << 16 | A | 0, _ !== 0; ) ;
          for (M = 1 << k - 1; Y & M; ) M >>= 1;
          if (M !== 0 ? (Y &= M - 1, Y += M) : Y = 0, U++, --ae[k] == 0) {
            if (k === W) break;
            k = p[f + x[U]];
          }
          if (fe < k && (Y & T) !== C) {
            for (G === 0 && (G = fe), P += I, Q = 1 << (q = k - G); q + G < W && !((Q -= ae[q + G]) <= 0); ) q++, Q <<= 1;
            if (K += 1 << q, h === 1 && 852 < K || h === 2 && 592 < K) return 1;
            y[C = Y & T] = fe << 24 | q << 16 | P - g | 0;
          }
        }
        return Y !== 0 && (y[P + Y] = k - G << 24 | 64 << 16 | 0), w.bits = fe, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(i, o, a) {
      o.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(i, o, a) {
      var r = i("../utils/common"), l = 0, c = 1;
      function u($) {
        for (var oe = $.length; 0 <= --oe; ) $[oe] = 0;
      }
      var d = 0, h = 29, p = 256, f = p + 1 + h, m = 30, y = 19, g = 2 * f + 1, x = 15, w = 16, M = 7, _ = 256, C = 16, T = 17, P = 18, E = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], b = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], S = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], R = new Array(2 * (f + 2));
      u(R);
      var k = new Array(2 * m);
      u(k);
      var U = new Array(512);
      u(U);
      var I = new Array(256);
      u(I);
      var W = new Array(h);
      u(W);
      var fe, q, G, Q = new Array(m);
      function K($, oe, O, V, H) {
        this.static_tree = $, this.extra_bits = oe, this.extra_base = O, this.elems = V, this.max_length = H, this.has_stree = $ && $.length;
      }
      function Y($, oe) {
        this.dyn_tree = $, this.max_code = 0, this.stat_desc = oe;
      }
      function ee($) {
        return $ < 256 ? U[$] : U[256 + ($ >>> 7)];
      }
      function ce($, oe) {
        $.pending_buf[$.pending++] = 255 & oe, $.pending_buf[$.pending++] = oe >>> 8 & 255;
      }
      function ae($, oe, O) {
        $.bi_valid > w - O ? ($.bi_buf |= oe << $.bi_valid & 65535, ce($, $.bi_buf), $.bi_buf = oe >> w - $.bi_valid, $.bi_valid += O - w) : ($.bi_buf |= oe << $.bi_valid & 65535, $.bi_valid += O);
      }
      function de($, oe, O) {
        ae($, O[2 * oe], O[2 * oe + 1]);
      }
      function ie($, oe) {
        for (var O = 0; O |= 1 & $, $ >>>= 1, O <<= 1, 0 < --oe; ) ;
        return O >>> 1;
      }
      function he($, oe, O) {
        var V, H, X = new Array(x + 1), ue = 0;
        for (V = 1; V <= x; V++) X[V] = ue = ue + O[V - 1] << 1;
        for (H = 0; H <= oe; H++) {
          var me = $[2 * H + 1];
          me !== 0 && ($[2 * H] = ie(X[me]++, me));
        }
      }
      function ne($) {
        var oe;
        for (oe = 0; oe < f; oe++) $.dyn_ltree[2 * oe] = 0;
        for (oe = 0; oe < m; oe++) $.dyn_dtree[2 * oe] = 0;
        for (oe = 0; oe < y; oe++) $.bl_tree[2 * oe] = 0;
        $.dyn_ltree[2 * _] = 1, $.opt_len = $.static_len = 0, $.last_lit = $.matches = 0;
      }
      function N($) {
        8 < $.bi_valid ? ce($, $.bi_buf) : 0 < $.bi_valid && ($.pending_buf[$.pending++] = $.bi_buf), $.bi_buf = 0, $.bi_valid = 0;
      }
      function te($, oe, O, V) {
        var H = 2 * oe, X = 2 * O;
        return $[H] < $[X] || $[H] === $[X] && V[oe] <= V[O];
      }
      function F($, oe, O) {
        for (var V = $.heap[O], H = O << 1; H <= $.heap_len && (H < $.heap_len && te(oe, $.heap[H + 1], $.heap[H], $.depth) && H++, !te(oe, V, $.heap[H], $.depth)); ) $.heap[O] = $.heap[H], O = H, H <<= 1;
        $.heap[O] = V;
      }
      function B($, oe, O) {
        var V, H, X, ue, me = 0;
        if ($.last_lit !== 0) for (; V = $.pending_buf[$.d_buf + 2 * me] << 8 | $.pending_buf[$.d_buf + 2 * me + 1], H = $.pending_buf[$.l_buf + me], me++, V === 0 ? de($, H, oe) : (de($, (X = I[H]) + p + 1, oe), (ue = E[X]) !== 0 && ae($, H -= W[X], ue), de($, X = ee(--V), O), (ue = b[X]) !== 0 && ae($, V -= Q[X], ue)), me < $.last_lit; ) ;
        de($, _, oe);
      }
      function L($, oe) {
        var O, V, H, X = oe.dyn_tree, ue = oe.stat_desc.static_tree, me = oe.stat_desc.has_stree, _e = oe.stat_desc.elems, we = -1;
        for ($.heap_len = 0, $.heap_max = g, O = 0; O < _e; O++) X[2 * O] !== 0 ? ($.heap[++$.heap_len] = we = O, $.depth[O] = 0) : X[2 * O + 1] = 0;
        for (; $.heap_len < 2; ) X[2 * (H = $.heap[++$.heap_len] = we < 2 ? ++we : 0)] = 1, $.depth[H] = 0, $.opt_len--, me && ($.static_len -= ue[2 * H + 1]);
        for (oe.max_code = we, O = $.heap_len >> 1; 1 <= O; O--) F($, X, O);
        for (H = _e; O = $.heap[1], $.heap[1] = $.heap[$.heap_len--], F($, X, 1), V = $.heap[1], $.heap[--$.heap_max] = O, $.heap[--$.heap_max] = V, X[2 * H] = X[2 * O] + X[2 * V], $.depth[H] = ($.depth[O] >= $.depth[V] ? $.depth[O] : $.depth[V]) + 1, X[2 * O + 1] = X[2 * V + 1] = H, $.heap[1] = H++, F($, X, 1), 2 <= $.heap_len; ) ;
        $.heap[--$.heap_max] = $.heap[1], function(Ae, Ve) {
          var Fe, $e, Ze, je, Ue, rt, Qe = Ve.dyn_tree, yt = Ve.max_code, Ce = Ve.stat_desc.static_tree, Be = Ve.stat_desc.has_stree, ke = Ve.stat_desc.extra_bits, Ge = Ve.stat_desc.extra_base, Ye = Ve.stat_desc.max_length, We = 0;
          for (je = 0; je <= x; je++) Ae.bl_count[je] = 0;
          for (Qe[2 * Ae.heap[Ae.heap_max] + 1] = 0, Fe = Ae.heap_max + 1; Fe < g; Fe++) Ye < (je = Qe[2 * Qe[2 * ($e = Ae.heap[Fe]) + 1] + 1] + 1) && (je = Ye, We++), Qe[2 * $e + 1] = je, yt < $e || (Ae.bl_count[je]++, Ue = 0, Ge <= $e && (Ue = ke[$e - Ge]), rt = Qe[2 * $e], Ae.opt_len += rt * (je + Ue), Be && (Ae.static_len += rt * (Ce[2 * $e + 1] + Ue)));
          if (We !== 0) {
            do {
              for (je = Ye - 1; Ae.bl_count[je] === 0; ) je--;
              Ae.bl_count[je]--, Ae.bl_count[je + 1] += 2, Ae.bl_count[Ye]--, We -= 2;
            } while (0 < We);
            for (je = Ye; je !== 0; je--) for ($e = Ae.bl_count[je]; $e !== 0; ) yt < (Ze = Ae.heap[--Fe]) || (Qe[2 * Ze + 1] !== je && (Ae.opt_len += (je - Qe[2 * Ze + 1]) * Qe[2 * Ze], Qe[2 * Ze + 1] = je), $e--);
          }
        }($, oe), he(X, we, $.bl_count);
      }
      function D($, oe, O) {
        var V, H, X = -1, ue = oe[1], me = 0, _e = 7, we = 4;
        for (ue === 0 && (_e = 138, we = 3), oe[2 * (O + 1) + 1] = 65535, V = 0; V <= O; V++) H = ue, ue = oe[2 * (V + 1) + 1], ++me < _e && H === ue || (me < we ? $.bl_tree[2 * H] += me : H !== 0 ? (H !== X && $.bl_tree[2 * H]++, $.bl_tree[2 * C]++) : me <= 10 ? $.bl_tree[2 * T]++ : $.bl_tree[2 * P]++, X = H, we = (me = 0) === ue ? (_e = 138, 3) : H === ue ? (_e = 6, 3) : (_e = 7, 4));
      }
      function j($, oe, O) {
        var V, H, X = -1, ue = oe[1], me = 0, _e = 7, we = 4;
        for (ue === 0 && (_e = 138, we = 3), V = 0; V <= O; V++) if (H = ue, ue = oe[2 * (V + 1) + 1], !(++me < _e && H === ue)) {
          if (me < we) for (; de($, H, $.bl_tree), --me != 0; ) ;
          else H !== 0 ? (H !== X && (de($, H, $.bl_tree), me--), de($, C, $.bl_tree), ae($, me - 3, 2)) : me <= 10 ? (de($, T, $.bl_tree), ae($, me - 3, 3)) : (de($, P, $.bl_tree), ae($, me - 11, 7));
          X = H, we = (me = 0) === ue ? (_e = 138, 3) : H === ue ? (_e = 6, 3) : (_e = 7, 4);
        }
      }
      u(Q);
      var Z = !1;
      function z($, oe, O, V) {
        ae($, (d << 1) + (V ? 1 : 0), 3), function(H, X, ue, me) {
          N(H), ce(H, ue), ce(H, ~ue), r.arraySet(H.pending_buf, H.window, X, ue, H.pending), H.pending += ue;
        }($, oe, O);
      }
      a._tr_init = function($) {
        Z || (function() {
          var oe, O, V, H, X, ue = new Array(x + 1);
          for (H = V = 0; H < h - 1; H++) for (W[H] = V, oe = 0; oe < 1 << E[H]; oe++) I[V++] = H;
          for (I[V - 1] = H, H = X = 0; H < 16; H++) for (Q[H] = X, oe = 0; oe < 1 << b[H]; oe++) U[X++] = H;
          for (X >>= 7; H < m; H++) for (Q[H] = X << 7, oe = 0; oe < 1 << b[H] - 7; oe++) U[256 + X++] = H;
          for (O = 0; O <= x; O++) ue[O] = 0;
          for (oe = 0; oe <= 143; ) R[2 * oe + 1] = 8, oe++, ue[8]++;
          for (; oe <= 255; ) R[2 * oe + 1] = 9, oe++, ue[9]++;
          for (; oe <= 279; ) R[2 * oe + 1] = 7, oe++, ue[7]++;
          for (; oe <= 287; ) R[2 * oe + 1] = 8, oe++, ue[8]++;
          for (he(R, f + 1, ue), oe = 0; oe < m; oe++) k[2 * oe + 1] = 5, k[2 * oe] = ie(oe, 5);
          fe = new K(R, E, p + 1, f, x), q = new K(k, b, 0, m, x), G = new K(new Array(0), S, 0, y, M);
        }(), Z = !0), $.l_desc = new Y($.dyn_ltree, fe), $.d_desc = new Y($.dyn_dtree, q), $.bl_desc = new Y($.bl_tree, G), $.bi_buf = 0, $.bi_valid = 0, ne($);
      }, a._tr_stored_block = z, a._tr_flush_block = function($, oe, O, V) {
        var H, X, ue = 0;
        0 < $.level ? ($.strm.data_type === 2 && ($.strm.data_type = function(me) {
          var _e, we = 4093624447;
          for (_e = 0; _e <= 31; _e++, we >>>= 1) if (1 & we && me.dyn_ltree[2 * _e] !== 0) return l;
          if (me.dyn_ltree[18] !== 0 || me.dyn_ltree[20] !== 0 || me.dyn_ltree[26] !== 0) return c;
          for (_e = 32; _e < p; _e++) if (me.dyn_ltree[2 * _e] !== 0) return c;
          return l;
        }($)), L($, $.l_desc), L($, $.d_desc), ue = function(me) {
          var _e;
          for (D(me, me.dyn_ltree, me.l_desc.max_code), D(me, me.dyn_dtree, me.d_desc.max_code), L(me, me.bl_desc), _e = y - 1; 3 <= _e && me.bl_tree[2 * A[_e] + 1] === 0; _e--) ;
          return me.opt_len += 3 * (_e + 1) + 5 + 5 + 4, _e;
        }($), H = $.opt_len + 3 + 7 >>> 3, (X = $.static_len + 3 + 7 >>> 3) <= H && (H = X)) : H = X = O + 5, O + 4 <= H && oe !== -1 ? z($, oe, O, V) : $.strategy === 4 || X === H ? (ae($, 2 + (V ? 1 : 0), 3), B($, R, k)) : (ae($, 4 + (V ? 1 : 0), 3), function(me, _e, we, Ae) {
          var Ve;
          for (ae(me, _e - 257, 5), ae(me, we - 1, 5), ae(me, Ae - 4, 4), Ve = 0; Ve < Ae; Ve++) ae(me, me.bl_tree[2 * A[Ve] + 1], 3);
          j(me, me.dyn_ltree, _e - 1), j(me, me.dyn_dtree, we - 1);
        }($, $.l_desc.max_code + 1, $.d_desc.max_code + 1, ue + 1), B($, $.dyn_ltree, $.dyn_dtree)), ne($), V && N($);
      }, a._tr_tally = function($, oe, O) {
        return $.pending_buf[$.d_buf + 2 * $.last_lit] = oe >>> 8 & 255, $.pending_buf[$.d_buf + 2 * $.last_lit + 1] = 255 & oe, $.pending_buf[$.l_buf + $.last_lit] = 255 & O, $.last_lit++, oe === 0 ? $.dyn_ltree[2 * O]++ : ($.matches++, oe--, $.dyn_ltree[2 * (I[O] + p + 1)]++, $.dyn_dtree[2 * ee(oe)]++), $.last_lit === $.lit_bufsize - 1;
      }, a._tr_align = function($) {
        ae($, 2, 3), de($, _, R), function(oe) {
          oe.bi_valid === 16 ? (ce(oe, oe.bi_buf), oe.bi_buf = 0, oe.bi_valid = 0) : 8 <= oe.bi_valid && (oe.pending_buf[oe.pending++] = 255 & oe.bi_buf, oe.bi_buf >>= 8, oe.bi_valid -= 8);
        }($);
      };
    }, { "../utils/common": 41 }], 53: [function(i, o, a) {
      o.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(i, o, a) {
      (function(r) {
        (function(l, c) {
          if (!l.setImmediate) {
            var u, d, h, p, f = 1, m = {}, y = !1, g = l.document, x = Object.getPrototypeOf && Object.getPrototypeOf(l);
            x = x && x.setTimeout ? x : l, u = {}.toString.call(l.process) === "[object process]" ? function(C) {
              n.nextTick(function() {
                M(C);
              });
            } : function() {
              if (l.postMessage && !l.importScripts) {
                var C = !0, T = l.onmessage;
                return l.onmessage = function() {
                  C = !1;
                }, l.postMessage("", "*"), l.onmessage = T, C;
              }
            }() ? (p = "setImmediate$" + Math.random() + "$", l.addEventListener ? l.addEventListener("message", _, !1) : l.attachEvent("onmessage", _), function(C) {
              l.postMessage(p + C, "*");
            }) : l.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(C) {
              M(C.data);
            }, function(C) {
              h.port2.postMessage(C);
            }) : g && "onreadystatechange" in g.createElement("script") ? (d = g.documentElement, function(C) {
              var T = g.createElement("script");
              T.onreadystatechange = function() {
                M(C), T.onreadystatechange = null, d.removeChild(T), T = null;
              }, d.appendChild(T);
            }) : function(C) {
              setTimeout(M, 0, C);
            }, x.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var T = new Array(arguments.length - 1), P = 0; P < T.length; P++) T[P] = arguments[P + 1];
              var E = { callback: C, args: T };
              return m[f] = E, u(f), f++;
            }, x.clearImmediate = w;
          }
          function w(C) {
            delete m[C];
          }
          function M(C) {
            if (y) setTimeout(M, 0, C);
            else {
              var T = m[C];
              if (T) {
                y = !0;
                try {
                  (function(P) {
                    var E = P.callback, b = P.args;
                    switch (b.length) {
                      case 0:
                        E();
                        break;
                      case 1:
                        E(b[0]);
                        break;
                      case 2:
                        E(b[0], b[1]);
                        break;
                      case 3:
                        E(b[0], b[1], b[2]);
                        break;
                      default:
                        E.apply(c, b);
                    }
                  })(T);
                } finally {
                  w(C), y = !1;
                }
              }
            }
          }
          function _(C) {
            C.source === l && typeof C.data == "string" && C.data.indexOf(p) === 0 && M(+C.data.slice(p.length));
          }
        })(typeof self > "u" ? r === void 0 ? this : r : self);
      }).call(this, typeof oc < "u" ? oc : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(B5);
var CY = B5.exports;
const TY = /* @__PURE__ */ SY(CY), EY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: TY
}, Symbol.toStringTag, { value: "Module" }));
export {
  g9 as mountApp,
  PY as sendToComfyUI
};
