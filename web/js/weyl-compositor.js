var By = Object.defineProperty;
var Vy = (s, e, n) => e in s ? By(s, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : s[e] = n;
var pe = (s, e, n) => Vy(s, typeof e != "symbol" ? e + "" : e, n);
/**
* @vue/shared v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function jh(s) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const n of s.split(",")) e[n] = 1;
  return (n) => n in e;
}
const Qt = {}, wo = [], es = () => {
}, eg = () => !1, Jc = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // uppercase letter
(s.charCodeAt(2) > 122 || s.charCodeAt(2) < 97), Yh = (s) => s.startsWith("onUpdate:"), Xn = Object.assign, qh = (s, e) => {
  const n = s.indexOf(e);
  n > -1 && s.splice(n, 1);
}, Gy = Object.prototype.hasOwnProperty, Wt = (s, e) => Gy.call(s, e), yt = Array.isArray, So = (s) => ul(s) === "[object Map]", Vo = (s) => ul(s) === "[object Set]", sp = (s) => ul(s) === "[object Date]", Ct = (s) => typeof s == "function", gn = (s) => typeof s == "string", Vi = (s) => typeof s == "symbol", en = (s) => s !== null && typeof s == "object", tg = (s) => (en(s) || Ct(s)) && Ct(s.then) && Ct(s.catch), ng = Object.prototype.toString, ul = (s) => ng.call(s), Hy = (s) => ul(s).slice(8, -1), ig = (s) => ul(s) === "[object Object]", Qc = (s) => gn(s) && s !== "NaN" && s[0] !== "-" && "" + parseInt(s, 10) === s, Ta = /* @__PURE__ */ jh(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), eu = (s) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (n) => e[n] || (e[n] = s(n));
}, Wy = /-\w/g, Ai = eu(
  (s) => s.replace(Wy, (e) => e.slice(1).toUpperCase())
), $y = /\B([A-Z])/g, ir = eu(
  (s) => s.replace($y, "-$1").toLowerCase()
), tu = eu((s) => s.charAt(0).toUpperCase() + s.slice(1)), ku = eu(
  (s) => s ? `on${tu(s)}` : ""
), Js = (s, e) => !Object.is(s, e), gc = (s, ...e) => {
  for (let n = 0; n < s.length; n++)
    s[n](...e);
}, sg = (s, e, n, i = !1) => {
  Object.defineProperty(s, e, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: n
  });
}, nu = (s) => {
  const e = parseFloat(s);
  return isNaN(e) ? s : e;
};
let rp;
const iu = () => rp || (rp = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function bt(s) {
  if (yt(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++) {
      const i = s[n], r = gn(i) ? qy(i) : bt(i);
      if (r)
        for (const o in r)
          e[o] = r[o];
    }
    return e;
  } else if (gn(s) || en(s))
    return s;
}
const Xy = /;(?![^(]*\))/g, jy = /:([^]+)/, Yy = /\/\*[^]*?\*\//g;
function qy(s) {
  const e = {};
  return s.replace(Yy, "").split(Xy).forEach((n) => {
    if (n) {
      const i = n.split(jy);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Ue(s) {
  let e = "";
  if (gn(s))
    e = s;
  else if (yt(s))
    for (let n = 0; n < s.length; n++) {
      const i = Ue(s[n]);
      i && (e += i + " ");
    }
  else if (en(s))
    for (const n in s)
      s[n] && (e += n + " ");
  return e.trim();
}
const Zy = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Ky = /* @__PURE__ */ jh(Zy);
function rg(s) {
  return !!s || s === "";
}
function Jy(s, e) {
  if (s.length !== e.length) return !1;
  let n = !0;
  for (let i = 0; n && i < s.length; i++)
    n = dl(s[i], e[i]);
  return n;
}
function dl(s, e) {
  if (s === e) return !0;
  let n = sp(s), i = sp(e);
  if (n || i)
    return n && i ? s.getTime() === e.getTime() : !1;
  if (n = Vi(s), i = Vi(e), n || i)
    return s === e;
  if (n = yt(s), i = yt(e), n || i)
    return n && i ? Jy(s, e) : !1;
  if (n = en(s), i = en(e), n || i) {
    if (!n || !i)
      return !1;
    const r = Object.keys(s).length, o = Object.keys(e).length;
    if (r !== o)
      return !1;
    for (const a in s) {
      const l = s.hasOwnProperty(a), c = e.hasOwnProperty(a);
      if (l && !c || !l && c || !dl(s[a], e[a]))
        return !1;
    }
  }
  return String(s) === String(e);
}
function Zh(s, e) {
  return s.findIndex((n) => dl(n, e));
}
const og = (s) => !!(s && s.__v_isRef === !0), be = (s) => gn(s) ? s : s == null ? "" : yt(s) || en(s) && (s.toString === ng || !Ct(s.toString)) ? og(s) ? be(s.value) : JSON.stringify(s, ag, 2) : String(s), ag = (s, e) => og(e) ? ag(s, e.value) : So(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce(
    (n, [i, r], o) => (n[Lu(i, o) + " =>"] = r, n),
    {}
  )
} : Vo(e) ? {
  [`Set(${e.size})`]: [...e.values()].map((n) => Lu(n))
} : Vi(e) ? Lu(e) : en(e) && !yt(e) && !ig(e) ? String(e) : e, Lu = (s, e = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Vi(s) ? `Symbol(${(n = s.description) != null ? n : e})` : s
  );
};
/**
* @vue/reactivity v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Gn;
class lg {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Gn, !e && Gn && (this.index = (Gn.scopes || (Gn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].pause();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let e, n;
      if (this.scopes)
        for (e = 0, n = this.scopes.length; e < n; e++)
          this.scopes[e].resume();
      for (e = 0, n = this.effects.length; e < n; e++)
        this.effects[e].resume();
    }
  }
  run(e) {
    if (this._active) {
      const n = Gn;
      try {
        return Gn = this, e();
      } finally {
        Gn = n;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Gn, Gn = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Gn = this.prevScope, this.prevScope = void 0);
  }
  stop(e) {
    if (this._active) {
      this._active = !1;
      let n, i;
      for (n = 0, i = this.effects.length; n < i; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, i = this.cleanups.length; n < i; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, i = this.scopes.length; n < i; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !e) {
        const r = this.parent.scopes.pop();
        r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function cg(s) {
  return new lg(s);
}
function ug() {
  return Gn;
}
function Qy(s, e = !1) {
  Gn && Gn.cleanups.push(s);
}
let tn;
const Fu = /* @__PURE__ */ new WeakSet();
class dg {
  constructor(e) {
    this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Gn && Gn.active && Gn.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Fu.has(this) && (Fu.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || fg(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, op(this), pg(this);
    const e = tn, n = Bi;
    tn = this, Bi = !0;
    try {
      return this.fn();
    } finally {
      mg(this), tn = e, Bi = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let e = this.deps; e; e = e.nextDep)
        Qh(e);
      this.deps = this.depsTail = void 0, op(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Fu.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Nd(this) && this.run();
  }
  get dirty() {
    return Nd(this);
  }
}
let hg = 0, Aa, Pa;
function fg(s, e = !1) {
  if (s.flags |= 8, e) {
    s.next = Pa, Pa = s;
    return;
  }
  s.next = Aa, Aa = s;
}
function Kh() {
  hg++;
}
function Jh() {
  if (--hg > 0)
    return;
  if (Pa) {
    let e = Pa;
    for (Pa = void 0; e; ) {
      const n = e.next;
      e.next = void 0, e.flags &= -9, e = n;
    }
  }
  let s;
  for (; Aa; ) {
    let e = Aa;
    for (Aa = void 0; e; ) {
      const n = e.next;
      if (e.next = void 0, e.flags &= -9, e.flags & 1)
        try {
          e.trigger();
        } catch (i) {
          s || (s = i);
        }
      e = n;
    }
  }
  if (s) throw s;
}
function pg(s) {
  for (let e = s.deps; e; e = e.nextDep)
    e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e;
}
function mg(s) {
  let e, n = s.depsTail, i = n;
  for (; i; ) {
    const r = i.prevDep;
    i.version === -1 ? (i === n && (n = r), Qh(i), e1(i)) : e = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = r;
  }
  s.deps = e, s.depsTail = n;
}
function Nd(s) {
  for (let e = s.deps; e; e = e.nextDep)
    if (e.dep.version !== e.version || e.dep.computed && (vg(e.dep.computed) || e.dep.version !== e.version))
      return !0;
  return !!s._dirty;
}
function vg(s) {
  if (s.flags & 4 && !(s.flags & 16) || (s.flags &= -17, s.globalVersion === $a) || (s.globalVersion = $a, !s.isSSR && s.flags & 128 && (!s.deps && !s._dirty || !Nd(s))))
    return;
  s.flags |= 2;
  const e = s.dep, n = tn, i = Bi;
  tn = s, Bi = !0;
  try {
    pg(s);
    const r = s.fn(s._value);
    (e.version === 0 || Js(r, s._value)) && (s.flags |= 128, s._value = r, e.version++);
  } catch (r) {
    throw e.version++, r;
  } finally {
    tn = n, Bi = i, mg(s), s.flags &= -3;
  }
}
function Qh(s, e = !1) {
  const { dep: n, prevSub: i, nextSub: r } = s;
  if (i && (i.nextSub = r, s.prevSub = void 0), r && (r.prevSub = i, s.nextSub = void 0), n.subs === s && (n.subs = i, !i && n.computed)) {
    n.computed.flags &= -5;
    for (let o = n.computed.deps; o; o = o.nextDep)
      Qh(o, !0);
  }
  !e && !--n.sc && n.map && n.map.delete(n.key);
}
function e1(s) {
  const { prevDep: e, nextDep: n } = s;
  e && (e.nextDep = n, s.prevDep = void 0), n && (n.prevDep = e, s.nextDep = void 0);
}
let Bi = !0;
const gg = [];
function Es() {
  gg.push(Bi), Bi = !1;
}
function Ts() {
  const s = gg.pop();
  Bi = s === void 0 ? !0 : s;
}
function op(s) {
  const { cleanup: e } = s;
  if (s.cleanup = void 0, e) {
    const n = tn;
    tn = void 0;
    try {
      e();
    } finally {
      tn = n;
    }
  }
}
let $a = 0;
class t1 {
  constructor(e, n) {
    this.sub = e, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ef {
  // TODO isolatedDeclarations "__v_skip"
  constructor(e) {
    this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(e) {
    if (!tn || !Bi || tn === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== tn)
      n = this.activeLink = new t1(tn, this), tn.deps ? (n.prevDep = tn.depsTail, tn.depsTail.nextDep = n, tn.depsTail = n) : tn.deps = tn.depsTail = n, yg(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const i = n.nextDep;
      i.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = i), n.prevDep = tn.depsTail, n.nextDep = void 0, tn.depsTail.nextDep = n, tn.depsTail = n, tn.deps === n && (tn.deps = i);
    }
    return n;
  }
  trigger(e) {
    this.version++, $a++, this.notify(e);
  }
  notify(e) {
    Kh();
    try {
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      Jh();
    }
  }
}
function yg(s) {
  if (s.dep.sc++, s.sub.flags & 4) {
    const e = s.dep.computed;
    if (e && !s.dep.subs) {
      e.flags |= 20;
      for (let i = e.deps; i; i = i.nextDep)
        yg(i);
    }
    const n = s.dep.subs;
    n !== s && (s.prevSub = n, n && (n.nextSub = s)), s.dep.subs = s;
  }
}
const Ic = /* @__PURE__ */ new WeakMap(), Ir = Symbol(
  ""
), Bd = Symbol(
  ""
), Xa = Symbol(
  ""
);
function Hn(s, e, n) {
  if (Bi && tn) {
    let i = Ic.get(s);
    i || Ic.set(s, i = /* @__PURE__ */ new Map());
    let r = i.get(n);
    r || (i.set(n, r = new ef()), r.map = i, r.key = n), r.track();
  }
}
function _s(s, e, n, i, r, o) {
  const a = Ic.get(s);
  if (!a) {
    $a++;
    return;
  }
  const l = (c) => {
    c && c.trigger();
  };
  if (Kh(), e === "clear")
    a.forEach(l);
  else {
    const c = yt(s), u = c && Qc(n);
    if (c && n === "length") {
      const d = Number(i);
      a.forEach((h, m) => {
        (m === "length" || m === Xa || !Vi(m) && m >= d) && l(h);
      });
    } else
      switch ((n !== void 0 || a.has(void 0)) && l(a.get(n)), u && l(a.get(Xa)), e) {
        case "add":
          c ? u && l(a.get("length")) : (l(a.get(Ir)), So(s) && l(a.get(Bd)));
          break;
        case "delete":
          c || (l(a.get(Ir)), So(s) && l(a.get(Bd)));
          break;
        case "set":
          So(s) && l(a.get(Ir));
          break;
      }
  }
  Jh();
}
function n1(s, e) {
  const n = Ic.get(s);
  return n && n.get(e);
}
function $r(s) {
  const e = zt(s);
  return e === s ? e : (Hn(e, "iterate", Xa), xi(s) ? e : e.map(Gi));
}
function su(s) {
  return Hn(s = zt(s), "iterate", Xa), s;
}
function js(s, e) {
  return As(s) ? ws(s) ? Ao(Gi(e)) : Ao(e) : Gi(e);
}
const i1 = {
  __proto__: null,
  [Symbol.iterator]() {
    return Uu(this, Symbol.iterator, (s) => js(this, s));
  },
  concat(...s) {
    return $r(this).concat(
      ...s.map((e) => yt(e) ? $r(e) : e)
    );
  },
  entries() {
    return Uu(this, "entries", (s) => (s[1] = js(this, s[1]), s));
  },
  every(s, e) {
    return os(this, "every", s, e, void 0, arguments);
  },
  filter(s, e) {
    return os(
      this,
      "filter",
      s,
      e,
      (n) => n.map((i) => js(this, i)),
      arguments
    );
  },
  find(s, e) {
    return os(
      this,
      "find",
      s,
      e,
      (n) => js(this, n),
      arguments
    );
  },
  findIndex(s, e) {
    return os(this, "findIndex", s, e, void 0, arguments);
  },
  findLast(s, e) {
    return os(
      this,
      "findLast",
      s,
      e,
      (n) => js(this, n),
      arguments
    );
  },
  findLastIndex(s, e) {
    return os(this, "findLastIndex", s, e, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(s, e) {
    return os(this, "forEach", s, e, void 0, arguments);
  },
  includes(...s) {
    return Ou(this, "includes", s);
  },
  indexOf(...s) {
    return Ou(this, "indexOf", s);
  },
  join(s) {
    return $r(this).join(s);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...s) {
    return Ou(this, "lastIndexOf", s);
  },
  map(s, e) {
    return os(this, "map", s, e, void 0, arguments);
  },
  pop() {
    return na(this, "pop");
  },
  push(...s) {
    return na(this, "push", s);
  },
  reduce(s, ...e) {
    return ap(this, "reduce", s, e);
  },
  reduceRight(s, ...e) {
    return ap(this, "reduceRight", s, e);
  },
  shift() {
    return na(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(s, e) {
    return os(this, "some", s, e, void 0, arguments);
  },
  splice(...s) {
    return na(this, "splice", s);
  },
  toReversed() {
    return $r(this).toReversed();
  },
  toSorted(s) {
    return $r(this).toSorted(s);
  },
  toSpliced(...s) {
    return $r(this).toSpliced(...s);
  },
  unshift(...s) {
    return na(this, "unshift", s);
  },
  values() {
    return Uu(this, "values", (s) => js(this, s));
  }
};
function Uu(s, e, n) {
  const i = su(s), r = i[e]();
  return i !== s && !xi(s) && (r._next = r.next, r.next = () => {
    const o = r._next();
    return o.done || (o.value = n(o.value)), o;
  }), r;
}
const s1 = Array.prototype;
function os(s, e, n, i, r, o) {
  const a = su(s), l = a !== s && !xi(s), c = a[e];
  if (c !== s1[e]) {
    const h = c.apply(s, o);
    return l ? Gi(h) : h;
  }
  let u = n;
  a !== s && (l ? u = function(h, m) {
    return n.call(this, js(s, h), m, s);
  } : n.length > 2 && (u = function(h, m) {
    return n.call(this, h, m, s);
  }));
  const d = c.call(a, u, i);
  return l && r ? r(d) : d;
}
function ap(s, e, n, i) {
  const r = su(s);
  let o = n;
  return r !== s && (xi(s) ? n.length > 3 && (o = function(a, l, c) {
    return n.call(this, a, l, c, s);
  }) : o = function(a, l, c) {
    return n.call(this, a, js(s, l), c, s);
  }), r[e](o, ...i);
}
function Ou(s, e, n) {
  const i = zt(s);
  Hn(i, "iterate", Xa);
  const r = i[e](...n);
  return (r === -1 || r === !1) && ru(n[0]) ? (n[0] = zt(n[0]), i[e](...n)) : r;
}
function na(s, e, n = []) {
  Es(), Kh();
  const i = zt(s)[e].apply(s, n);
  return Jh(), Ts(), i;
}
const r1 = /* @__PURE__ */ jh("__proto__,__v_isRef,__isVue"), _g = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((s) => s !== "arguments" && s !== "caller").map((s) => Symbol[s]).filter(Vi)
);
function o1(s) {
  Vi(s) || (s = String(s));
  const e = zt(this);
  return Hn(e, "has", s), e.hasOwnProperty(s);
}
class xg {
  constructor(e = !1, n = !1) {
    this._isReadonly = e, this._isShallow = n;
  }
  get(e, n, i) {
    if (n === "__v_skip") return e.__v_skip;
    const r = this._isReadonly, o = this._isShallow;
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return o;
    if (n === "__v_raw")
      return i === (r ? o ? v1 : Mg : o ? Sg : wg).get(e) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(e) === Object.getPrototypeOf(i) ? e : void 0;
    const a = yt(e);
    if (!r) {
      let c;
      if (a && (c = i1[n]))
        return c;
      if (n === "hasOwnProperty")
        return o1;
    }
    const l = Reflect.get(
      e,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      vn(e) ? e : i
    );
    if ((Vi(n) ? _g.has(n) : r1(n)) || (r || Hn(e, "get", n), o))
      return l;
    if (vn(l)) {
      const c = a && Qc(n) ? l : l.value;
      return r && en(c) ? Gd(c) : c;
    }
    return en(l) ? r ? Gd(l) : Go(l) : l;
  }
}
class bg extends xg {
  constructor(e = !1) {
    super(!1, e);
  }
  set(e, n, i, r) {
    let o = e[n];
    const a = yt(e) && Qc(n);
    if (!this._isShallow) {
      const u = As(o);
      if (!xi(i) && !As(i) && (o = zt(o), i = zt(i)), !a && vn(o) && !vn(i))
        return u || (o.value = i), !0;
    }
    const l = a ? Number(n) < e.length : Wt(e, n), c = Reflect.set(
      e,
      n,
      i,
      vn(e) ? e : r
    );
    return e === zt(r) && (l ? Js(i, o) && _s(e, "set", n, i) : _s(e, "add", n, i)), c;
  }
  deleteProperty(e, n) {
    const i = Wt(e, n);
    e[n];
    const r = Reflect.deleteProperty(e, n);
    return r && i && _s(e, "delete", n, void 0), r;
  }
  has(e, n) {
    const i = Reflect.has(e, n);
    return (!Vi(n) || !_g.has(n)) && Hn(e, "has", n), i;
  }
  ownKeys(e) {
    return Hn(
      e,
      "iterate",
      yt(e) ? "length" : Ir
    ), Reflect.ownKeys(e);
  }
}
class a1 extends xg {
  constructor(e = !1) {
    super(!0, e);
  }
  set(e, n) {
    return !0;
  }
  deleteProperty(e, n) {
    return !0;
  }
}
const l1 = /* @__PURE__ */ new bg(), c1 = /* @__PURE__ */ new a1(), u1 = /* @__PURE__ */ new bg(!0);
const Vd = (s) => s, El = (s) => Reflect.getPrototypeOf(s);
function d1(s, e, n) {
  return function(...i) {
    const r = this.__v_raw, o = zt(r), a = So(o), l = s === "entries" || s === Symbol.iterator && a, c = s === "keys" && a, u = r[s](...i), d = n ? Vd : e ? Ao : Gi;
    return !e && Hn(
      o,
      "iterate",
      c ? Bd : Ir
    ), {
      // iterator protocol
      next() {
        const { value: h, done: m } = u.next();
        return m ? { value: h, done: m } : {
          value: l ? [d(h[0]), d(h[1])] : d(h),
          done: m
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Tl(s) {
  return function(...e) {
    return s === "delete" ? !1 : s === "clear" ? void 0 : this;
  };
}
function h1(s, e) {
  const n = {
    get(r) {
      const o = this.__v_raw, a = zt(o), l = zt(r);
      s || (Js(r, l) && Hn(a, "get", r), Hn(a, "get", l));
      const { has: c } = El(a), u = e ? Vd : s ? Ao : Gi;
      if (c.call(a, r))
        return u(o.get(r));
      if (c.call(a, l))
        return u(o.get(l));
      o !== a && o.get(r);
    },
    get size() {
      const r = this.__v_raw;
      return !s && Hn(zt(r), "iterate", Ir), r.size;
    },
    has(r) {
      const o = this.__v_raw, a = zt(o), l = zt(r);
      return s || (Js(r, l) && Hn(a, "has", r), Hn(a, "has", l)), r === l ? o.has(r) : o.has(r) || o.has(l);
    },
    forEach(r, o) {
      const a = this, l = a.__v_raw, c = zt(l), u = e ? Vd : s ? Ao : Gi;
      return !s && Hn(c, "iterate", Ir), l.forEach((d, h) => r.call(o, u(d), u(h), a));
    }
  };
  return Xn(
    n,
    s ? {
      add: Tl("add"),
      set: Tl("set"),
      delete: Tl("delete"),
      clear: Tl("clear")
    } : {
      add(r) {
        !e && !xi(r) && !As(r) && (r = zt(r));
        const o = zt(this);
        return El(o).has.call(o, r) || (o.add(r), _s(o, "add", r, r)), this;
      },
      set(r, o) {
        !e && !xi(o) && !As(o) && (o = zt(o));
        const a = zt(this), { has: l, get: c } = El(a);
        let u = l.call(a, r);
        u || (r = zt(r), u = l.call(a, r));
        const d = c.call(a, r);
        return a.set(r, o), u ? Js(o, d) && _s(a, "set", r, o) : _s(a, "add", r, o), this;
      },
      delete(r) {
        const o = zt(this), { has: a, get: l } = El(o);
        let c = a.call(o, r);
        c || (r = zt(r), c = a.call(o, r)), l && l.call(o, r);
        const u = o.delete(r);
        return c && _s(o, "delete", r, void 0), u;
      },
      clear() {
        const r = zt(this), o = r.size !== 0, a = r.clear();
        return o && _s(
          r,
          "clear",
          void 0,
          void 0
        ), a;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((r) => {
    n[r] = d1(r, s, e);
  }), n;
}
function tf(s, e) {
  const n = h1(s, e);
  return (i, r, o) => r === "__v_isReactive" ? !s : r === "__v_isReadonly" ? s : r === "__v_raw" ? i : Reflect.get(
    Wt(n, r) && r in i ? n : i,
    r,
    o
  );
}
const f1 = {
  get: /* @__PURE__ */ tf(!1, !1)
}, p1 = {
  get: /* @__PURE__ */ tf(!1, !0)
}, m1 = {
  get: /* @__PURE__ */ tf(!0, !1)
};
const wg = /* @__PURE__ */ new WeakMap(), Sg = /* @__PURE__ */ new WeakMap(), Mg = /* @__PURE__ */ new WeakMap(), v1 = /* @__PURE__ */ new WeakMap();
function g1(s) {
  switch (s) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function y1(s) {
  return s.__v_skip || !Object.isExtensible(s) ? 0 : g1(Hy(s));
}
function Go(s) {
  return As(s) ? s : nf(
    s,
    !1,
    l1,
    f1,
    wg
  );
}
function _1(s) {
  return nf(
    s,
    !1,
    u1,
    p1,
    Sg
  );
}
function Gd(s) {
  return nf(
    s,
    !0,
    c1,
    m1,
    Mg
  );
}
function nf(s, e, n, i, r) {
  if (!en(s) || s.__v_raw && !(e && s.__v_isReactive))
    return s;
  const o = y1(s);
  if (o === 0)
    return s;
  const a = r.get(s);
  if (a)
    return a;
  const l = new Proxy(
    s,
    o === 2 ? i : n
  );
  return r.set(s, l), l;
}
function ws(s) {
  return As(s) ? ws(s.__v_raw) : !!(s && s.__v_isReactive);
}
function As(s) {
  return !!(s && s.__v_isReadonly);
}
function xi(s) {
  return !!(s && s.__v_isShallow);
}
function ru(s) {
  return s ? !!s.__v_raw : !1;
}
function zt(s) {
  const e = s && s.__v_raw;
  return e ? zt(e) : s;
}
function ys(s) {
  return !Wt(s, "__v_skip") && Object.isExtensible(s) && sg(s, "__v_skip", !0), s;
}
const Gi = (s) => en(s) ? Go(s) : s, Ao = (s) => en(s) ? Gd(s) : s;
function vn(s) {
  return s ? s.__v_isRef === !0 : !1;
}
function Se(s) {
  return Cg(s, !1);
}
function x1(s) {
  return Cg(s, !0);
}
function Cg(s, e) {
  return vn(s) ? s : new b1(s, e);
}
class b1 {
  constructor(e, n) {
    this.dep = new ef(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? e : zt(e), this._value = n ? e : Gi(e), this.__v_isShallow = n;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(e) {
    const n = this._rawValue, i = this.__v_isShallow || xi(e) || As(e);
    e = i ? e : zt(e), Js(e, n) && (this._rawValue = e, this._value = i ? e : Gi(e), this.dep.trigger());
  }
}
function Ge(s) {
  return vn(s) ? s.value : s;
}
const w1 = {
  get: (s, e, n) => e === "__v_raw" ? s : Ge(Reflect.get(s, e, n)),
  set: (s, e, n, i) => {
    const r = s[e];
    return vn(r) && !vn(n) ? (r.value = n, !0) : Reflect.set(s, e, n, i);
  }
};
function Eg(s) {
  return ws(s) ? s : new Proxy(s, w1);
}
function S1(s) {
  const e = yt(s) ? new Array(s.length) : {};
  for (const n in s)
    e[n] = C1(s, n);
  return e;
}
class M1 {
  constructor(e, n, i) {
    this._object = e, this._key = n, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0, this._raw = zt(e);
    let r = !0, o = e;
    if (!yt(e) || !Qc(String(n)))
      do
        r = !ru(o) || xi(o);
      while (r && (o = o.__v_raw));
    this._shallow = r;
  }
  get value() {
    let e = this._object[this._key];
    return this._shallow && (e = Ge(e)), this._value = e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    if (this._shallow && vn(this._raw[this._key])) {
      const n = this._object[this._key];
      if (vn(n)) {
        n.value = e;
        return;
      }
    }
    this._object[this._key] = e;
  }
  get dep() {
    return n1(this._raw, this._key);
  }
}
function C1(s, e, n) {
  return new M1(s, e, n);
}
class E1 {
  constructor(e, n, i) {
    this.fn = e, this.setter = n, this._value = void 0, this.dep = new ef(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = $a - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    tn !== this)
      return fg(this, !0), !0;
  }
  get value() {
    const e = this.dep.track();
    return vg(this), e && (e.version = this.dep.version), this._value;
  }
  set value(e) {
    this.setter && this.setter(e);
  }
}
function T1(s, e, n = !1) {
  let i, r;
  return Ct(s) ? i = s : (i = s.get, r = s.set), new E1(i, r, n);
}
const Al = {}, kc = /* @__PURE__ */ new WeakMap();
let xr;
function A1(s, e = !1, n = xr) {
  if (n) {
    let i = kc.get(n);
    i || kc.set(n, i = []), i.push(s);
  }
}
function P1(s, e, n = Qt) {
  const { immediate: i, deep: r, once: o, scheduler: a, augmentJob: l, call: c } = n, u = (x) => r ? x : xi(x) || r === !1 || r === 0 ? xs(x, 1) : xs(x);
  let d, h, m, p, y = !1, _ = !1;
  if (vn(s) ? (h = () => s.value, y = xi(s)) : ws(s) ? (h = () => u(s), y = !0) : yt(s) ? (_ = !0, y = s.some((x) => ws(x) || xi(x)), h = () => s.map((x) => {
    if (vn(x))
      return x.value;
    if (ws(x))
      return u(x);
    if (Ct(x))
      return c ? c(x, 2) : x();
  })) : Ct(s) ? e ? h = c ? () => c(s, 2) : s : h = () => {
    if (m) {
      Es();
      try {
        m();
      } finally {
        Ts();
      }
    }
    const x = xr;
    xr = d;
    try {
      return c ? c(s, 3, [p]) : s(p);
    } finally {
      xr = x;
    }
  } : h = es, e && r) {
    const x = h, C = r === !0 ? 1 / 0 : r;
    h = () => xs(x(), C);
  }
  const v = ug(), g = () => {
    d.stop(), v && v.active && qh(v.effects, d);
  };
  if (o && e) {
    const x = e;
    e = (...C) => {
      x(...C), g();
    };
  }
  let S = _ ? new Array(s.length).fill(Al) : Al;
  const w = (x) => {
    if (!(!(d.flags & 1) || !d.dirty && !x))
      if (e) {
        const C = d.run();
        if (r || y || (_ ? C.some((E, P) => Js(E, S[P])) : Js(C, S))) {
          m && m();
          const E = xr;
          xr = d;
          try {
            const P = [
              C,
              // pass undefined as the old value when it's changed for the first time
              S === Al ? void 0 : _ && S[0] === Al ? [] : S,
              p
            ];
            S = C, c ? c(e, 3, P) : (
              // @ts-expect-error
              e(...P)
            );
          } finally {
            xr = E;
          }
        }
      } else
        d.run();
  };
  return l && l(w), d = new dg(h), d.scheduler = a ? () => a(w, !1) : w, p = (x) => A1(x, !1, d), m = d.onStop = () => {
    const x = kc.get(d);
    if (x) {
      if (c)
        c(x, 4);
      else
        for (const C of x) C();
      kc.delete(d);
    }
  }, e ? i ? w(!0) : S = d.run() : a ? a(w.bind(null, !0), !0) : d.run(), g.pause = d.pause.bind(d), g.resume = d.resume.bind(d), g.stop = g, g;
}
function xs(s, e = 1 / 0, n) {
  if (e <= 0 || !en(s) || s.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(s) || 0) >= e))
    return s;
  if (n.set(s, e), e--, vn(s))
    xs(s.value, e, n);
  else if (yt(s))
    for (let i = 0; i < s.length; i++)
      xs(s[i], e, n);
  else if (Vo(s) || So(s))
    s.forEach((i) => {
      xs(i, e, n);
    });
  else if (ig(s)) {
    for (const i in s)
      xs(s[i], e, n);
    for (const i of Object.getOwnPropertySymbols(s))
      Object.prototype.propertyIsEnumerable.call(s, i) && xs(s[i], e, n);
  }
  return s;
}
/**
* @vue/runtime-core v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function hl(s, e, n, i) {
  try {
    return i ? s(...i) : s();
  } catch (r) {
    ou(r, e, n);
  }
}
function ns(s, e, n, i) {
  if (Ct(s)) {
    const r = hl(s, e, n, i);
    return r && tg(r) && r.catch((o) => {
      ou(o, e, n);
    }), r;
  }
  if (yt(s)) {
    const r = [];
    for (let o = 0; o < s.length; o++)
      r.push(ns(s[o], e, n, i));
    return r;
  }
}
function ou(s, e, n, i = !0) {
  const r = e ? e.vnode : null, { errorHandler: o, throwUnhandledErrorInProduction: a } = e && e.appContext.config || Qt;
  if (e) {
    let l = e.parent;
    const c = e.proxy, u = `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; l; ) {
      const d = l.ec;
      if (d) {
        for (let h = 0; h < d.length; h++)
          if (d[h](s, c, u) === !1)
            return;
      }
      l = l.parent;
    }
    if (o) {
      Es(), hl(o, null, 10, [
        s,
        c,
        u
      ]), Ts();
      return;
    }
  }
  D1(s, n, r, i, a);
}
function D1(s, e, n, i = !0, r = !1) {
  if (r)
    throw s;
  console.error(s);
}
const ei = [];
let Ki = -1;
const Mo = [];
let Ys = null, fo = 0;
const Tg = /* @__PURE__ */ Promise.resolve();
let Lc = null;
function Ti(s) {
  const e = Lc || Tg;
  return s ? e.then(this ? s.bind(this) : s) : e;
}
function R1(s) {
  let e = Ki + 1, n = ei.length;
  for (; e < n; ) {
    const i = e + n >>> 1, r = ei[i], o = ja(r);
    o < s || o === s && r.flags & 2 ? e = i + 1 : n = i;
  }
  return e;
}
function sf(s) {
  if (!(s.flags & 1)) {
    const e = ja(s), n = ei[ei.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(s.flags & 2) && e >= ja(n) ? ei.push(s) : ei.splice(R1(e), 0, s), s.flags |= 1, Ag();
  }
}
function Ag() {
  Lc || (Lc = Tg.then(Dg));
}
function I1(s) {
  yt(s) ? Mo.push(...s) : Ys && s.id === -1 ? Ys.splice(fo + 1, 0, s) : s.flags & 1 || (Mo.push(s), s.flags |= 1), Ag();
}
function lp(s, e, n = Ki + 1) {
  for (; n < ei.length; n++) {
    const i = ei[n];
    if (i && i.flags & 2) {
      if (s && i.id !== s.uid)
        continue;
      ei.splice(n, 1), n--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function Pg(s) {
  if (Mo.length) {
    const e = [...new Set(Mo)].sort(
      (n, i) => ja(n) - ja(i)
    );
    if (Mo.length = 0, Ys) {
      Ys.push(...e);
      return;
    }
    for (Ys = e, fo = 0; fo < Ys.length; fo++) {
      const n = Ys[fo];
      n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2;
    }
    Ys = null, fo = 0;
  }
}
const ja = (s) => s.id == null ? s.flags & 2 ? -1 : 1 / 0 : s.id;
function Dg(s) {
  try {
    for (Ki = 0; Ki < ei.length; Ki++) {
      const e = ei[Ki];
      e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2), hl(
        e,
        e.i,
        e.i ? 15 : 14
      ), e.flags & 4 || (e.flags &= -2));
    }
  } finally {
    for (; Ki < ei.length; Ki++) {
      const e = ei[Ki];
      e && (e.flags &= -2);
    }
    Ki = -1, ei.length = 0, Pg(), Lc = null, (ei.length || Mo.length) && Dg();
  }
}
let kn = null, Rg = null;
function Fc(s) {
  const e = kn;
  return kn = s, Rg = s && s.type.__scopeId || null, e;
}
function Fi(s, e = kn, n) {
  if (!e || s._n)
    return s;
  const i = (...r) => {
    i._d && zc(-1);
    const o = Fc(e);
    let a;
    try {
      a = s(...r);
    } finally {
      Fc(o), i._d && zc(1);
    }
    return a;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function ct(s, e) {
  if (kn === null)
    return s;
  const n = du(kn), i = s.dirs || (s.dirs = []);
  for (let r = 0; r < e.length; r++) {
    let [o, a, l, c = Qt] = e[r];
    o && (Ct(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && xs(a), i.push({
      dir: o,
      instance: n,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: c
    }));
  }
  return s;
}
function or(s, e, n, i) {
  const r = s.dirs, o = e && e.dirs;
  for (let a = 0; a < r.length; a++) {
    const l = r[a];
    o && (l.oldValue = o[a].value);
    let c = l.dir[i];
    c && (Es(), ns(c, n, 8, [
      s.el,
      l,
      s,
      e
    ]), Ts());
  }
}
const Ig = Symbol("_vte"), k1 = (s) => s.__isTeleport, Da = (s) => s && (s.disabled || s.disabled === ""), cp = (s) => s && (s.defer || s.defer === ""), up = (s) => typeof SVGElement < "u" && s instanceof SVGElement, dp = (s) => typeof MathMLElement == "function" && s instanceof MathMLElement, Hd = (s, e) => {
  const n = s && s.to;
  return gn(n) ? e ? e(n) : null : n;
}, kg = {
  name: "Teleport",
  __isTeleport: !0,
  process(s, e, n, i, r, o, a, l, c, u) {
    const {
      mc: d,
      pc: h,
      pbc: m,
      o: { insert: p, querySelector: y, createText: _, createComment: v }
    } = u, g = Da(e.props);
    let { shapeFlag: S, children: w, dynamicChildren: x } = e;
    if (s == null) {
      const C = e.el = _(""), E = e.anchor = _("");
      p(C, n, i), p(E, n, i);
      const P = (b, M) => {
        S & 16 && d(
          w,
          b,
          M,
          r,
          o,
          a,
          l,
          c
        );
      }, T = () => {
        const b = e.target = Hd(e.props, y), M = Lg(b, e, _, p);
        b && (a !== "svg" && up(b) ? a = "svg" : a !== "mathml" && dp(b) && (a = "mathml"), r && r.isCE && (r.ce._teleportTargets || (r.ce._teleportTargets = /* @__PURE__ */ new Set())).add(b), g || (P(b, M), yc(e, !1)));
      };
      g && (P(n, E), yc(e, !0)), cp(e.props) ? (e.el.__isMounted = !1, Jn(() => {
        T(), delete e.el.__isMounted;
      }, o)) : T();
    } else {
      if (cp(e.props) && s.el.__isMounted === !1) {
        Jn(() => {
          kg.process(
            s,
            e,
            n,
            i,
            r,
            o,
            a,
            l,
            c,
            u
          );
        }, o);
        return;
      }
      e.el = s.el, e.targetStart = s.targetStart;
      const C = e.anchor = s.anchor, E = e.target = s.target, P = e.targetAnchor = s.targetAnchor, T = Da(s.props), b = T ? n : E, M = T ? C : P;
      if (a === "svg" || up(E) ? a = "svg" : (a === "mathml" || dp(E)) && (a = "mathml"), x ? (m(
        s.dynamicChildren,
        x,
        b,
        r,
        o,
        a,
        l
      ), cf(s, e, !0)) : c || h(
        s,
        e,
        b,
        M,
        r,
        o,
        a,
        l,
        !1
      ), g)
        T ? e.props && s.props && e.props.to !== s.props.to && (e.props.to = s.props.to) : Pl(
          e,
          n,
          C,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (s.props && s.props.to)) {
        const L = e.target = Hd(
          e.props,
          y
        );
        L && Pl(
          e,
          L,
          null,
          u,
          0
        );
      } else T && Pl(
        e,
        E,
        P,
        u,
        1
      );
      yc(e, g);
    }
  },
  remove(s, e, n, { um: i, o: { remove: r } }, o) {
    const {
      shapeFlag: a,
      children: l,
      anchor: c,
      targetStart: u,
      targetAnchor: d,
      target: h,
      props: m
    } = s;
    if (h && (r(u), r(d)), o && r(c), a & 16) {
      const p = o || !Da(m);
      for (let y = 0; y < l.length; y++) {
        const _ = l[y];
        i(
          _,
          e,
          n,
          p,
          !!_.dynamicChildren
        );
      }
    }
  },
  move: Pl,
  hydrate: L1
};
function Pl(s, e, n, { o: { insert: i }, m: r }, o = 2) {
  o === 0 && i(s.targetAnchor, e, n);
  const { el: a, anchor: l, shapeFlag: c, children: u, props: d } = s, h = o === 2;
  if (h && i(a, e, n), (!h || Da(d)) && c & 16)
    for (let m = 0; m < u.length; m++)
      r(
        u[m],
        e,
        n,
        2
      );
  h && i(l, e, n);
}
function L1(s, e, n, i, r, o, {
  o: { nextSibling: a, parentNode: l, querySelector: c, insert: u, createText: d }
}, h) {
  function m(_, v, g, S) {
    v.anchor = h(
      a(_),
      v,
      l(_),
      n,
      i,
      r,
      o
    ), v.targetStart = g, v.targetAnchor = S;
  }
  const p = e.target = Hd(
    e.props,
    c
  ), y = Da(e.props);
  if (p) {
    const _ = p._lpa || p.firstChild;
    if (e.shapeFlag & 16)
      if (y)
        m(
          s,
          e,
          _,
          _ && a(_)
        );
      else {
        e.anchor = a(s);
        let v = _;
        for (; v; ) {
          if (v && v.nodeType === 8) {
            if (v.data === "teleport start anchor")
              e.targetStart = v;
            else if (v.data === "teleport anchor") {
              e.targetAnchor = v, p._lpa = e.targetAnchor && a(e.targetAnchor);
              break;
            }
          }
          v = a(v);
        }
        e.targetAnchor || Lg(p, e, d, u), h(
          _ && a(_),
          e,
          p,
          n,
          i,
          r,
          o
        );
      }
    yc(e, y);
  } else y && e.shapeFlag & 16 && m(s, e, s, a(s));
  return e.anchor && a(e.anchor);
}
const Po = kg;
function yc(s, e) {
  const n = s.ctx;
  if (n && n.ut) {
    let i, r;
    for (e ? (i = s.el, r = s.anchor) : (i = s.targetStart, r = s.targetAnchor); i && i !== r; )
      i.nodeType === 1 && i.setAttribute("data-v-owner", n.uid), i = i.nextSibling;
    n.ut();
  }
}
function Lg(s, e, n, i) {
  const r = e.targetStart = n(""), o = e.targetAnchor = n("");
  return r[Ig] = o, s && (i(r, s), i(o, s)), o;
}
const F1 = Symbol("_leaveCb");
function rf(s, e) {
  s.shapeFlag & 6 && s.component ? (s.transition = e, rf(s.component.subTree, e)) : s.shapeFlag & 128 ? (s.ssContent.transition = e.clone(s.ssContent), s.ssFallback.transition = e.clone(s.ssFallback)) : s.transition = e;
}
// @__NO_SIDE_EFFECTS__
function Ut(s, e) {
  return Ct(s) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Xn({ name: s.name }, e, { setup: s })
  ) : s;
}
function Fg(s) {
  s.ids = [s.ids[0] + s.ids[2]++ + "-", 0, 0];
}
const Uc = /* @__PURE__ */ new WeakMap();
function Ra(s, e, n, i, r = !1) {
  if (yt(s)) {
    s.forEach(
      (y, _) => Ra(
        y,
        e && (yt(e) ? e[_] : e),
        n,
        i,
        r
      )
    );
    return;
  }
  if (Co(i) && !r) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && Ra(s, e, n, i.component.subTree);
    return;
  }
  const o = i.shapeFlag & 4 ? du(i.component) : i.el, a = r ? null : o, { i: l, r: c } = s, u = e && e.r, d = l.refs === Qt ? l.refs = {} : l.refs, h = l.setupState, m = zt(h), p = h === Qt ? eg : (y) => Wt(m, y);
  if (u != null && u !== c) {
    if (hp(e), gn(u))
      d[u] = null, p(u) && (h[u] = null);
    else if (vn(u)) {
      u.value = null;
      const y = e;
      y.k && (d[y.k] = null);
    }
  }
  if (Ct(c))
    hl(c, l, 12, [a, d]);
  else {
    const y = gn(c), _ = vn(c);
    if (y || _) {
      const v = () => {
        if (s.f) {
          const g = y ? p(c) ? h[c] : d[c] : c.value;
          if (r)
            yt(g) && qh(g, o);
          else if (yt(g))
            g.includes(o) || g.push(o);
          else if (y)
            d[c] = [o], p(c) && (h[c] = d[c]);
          else {
            const S = [o];
            c.value = S, s.k && (d[s.k] = S);
          }
        } else y ? (d[c] = a, p(c) && (h[c] = a)) : _ && (c.value = a, s.k && (d[s.k] = a));
      };
      if (a) {
        const g = () => {
          v(), Uc.delete(s);
        };
        g.id = -1, Uc.set(s, g), Jn(g, n);
      } else
        hp(s), v();
    }
  }
}
function hp(s) {
  const e = Uc.get(s);
  e && (e.flags |= 8, Uc.delete(s));
}
iu().requestIdleCallback;
iu().cancelIdleCallback;
const Co = (s) => !!s.type.__asyncLoader, Ug = (s) => s.type.__isKeepAlive;
function U1(s, e) {
  Og(s, "a", e);
}
function O1(s, e) {
  Og(s, "da", e);
}
function Og(s, e, n = Wn) {
  const i = s.__wdc || (s.__wdc = () => {
    let r = n;
    for (; r; ) {
      if (r.isDeactivated)
        return;
      r = r.parent;
    }
    return s();
  });
  if (au(e, i, n), n) {
    let r = n.parent;
    for (; r && r.parent; )
      Ug(r.parent.vnode) && z1(i, e, n, r), r = r.parent;
  }
}
function z1(s, e, n, i) {
  const r = au(
    e,
    s,
    i,
    !0
    /* prepend */
  );
  jn(() => {
    qh(i[e], r);
  }, n);
}
function au(s, e, n = Wn, i = !1) {
  if (n) {
    const r = n[s] || (n[s] = []), o = e.__weh || (e.__weh = (...a) => {
      Es();
      const l = fl(n), c = ns(e, n, s, a);
      return l(), Ts(), c;
    });
    return i ? r.unshift(o) : r.push(o), o;
  }
}
const Ds = (s) => (e, n = Wn) => {
  (!Za || s === "sp") && au(s, (...i) => e(...i), n);
}, N1 = Ds("bm"), _n = Ds("m"), B1 = Ds(
  "bu"
), V1 = Ds("u"), of = Ds(
  "bum"
), jn = Ds("um"), G1 = Ds(
  "sp"
), H1 = Ds("rtg"), W1 = Ds("rtc");
function $1(s, e = Wn) {
  au("ec", s, e);
}
const X1 = "components", zg = Symbol.for("v-ndc");
function Ng(s) {
  return gn(s) ? j1(X1, s, !1) || s : s || zg;
}
function j1(s, e, n = !0, i = !1) {
  const r = kn || Wn;
  if (r) {
    const o = r.type;
    {
      const l = O_(
        o,
        !1
      );
      if (l && (l === e || l === Ai(e) || l === tu(Ai(e))))
        return o;
    }
    const a = (
      // local registration
      // check instance[type] first which is resolved for options API
      fp(r[s] || o[s], e) || // global registration
      fp(r.appContext[s], e)
    );
    return !a && i ? o : a;
  }
}
function fp(s, e) {
  return s && (s[e] || s[Ai(e)] || s[tu(Ai(e))]);
}
function at(s, e, n, i) {
  let r;
  const o = n, a = yt(s);
  if (a || gn(s)) {
    const l = a && ws(s);
    let c = !1, u = !1;
    l && (c = !xi(s), u = As(s), s = su(s)), r = new Array(s.length);
    for (let d = 0, h = s.length; d < h; d++)
      r[d] = e(
        c ? u ? Ao(Gi(s[d])) : Gi(s[d]) : s[d],
        d,
        void 0,
        o
      );
  } else if (typeof s == "number") {
    r = new Array(s);
    for (let l = 0; l < s; l++)
      r[l] = e(l + 1, l, void 0, o);
  } else if (en(s))
    if (s[Symbol.iterator])
      r = Array.from(
        s,
        (l, c) => e(l, c, void 0, o)
      );
    else {
      const l = Object.keys(s);
      r = new Array(l.length);
      for (let c = 0, u = l.length; c < u; c++) {
        const d = l[c];
        r[c] = e(s[d], d, c, o);
      }
    }
  else
    r = [];
  return r;
}
function Y1(s, e, n = {}, i, r) {
  if (kn.ce || kn.parent && Co(kn.parent) && kn.parent.ce) {
    const u = Object.keys(n).length > 0;
    return re(), St(
      Ze,
      null,
      [Ne("slot", n, i)],
      u ? -2 : 64
    );
  }
  let o = s[e];
  o && o._c && (o._d = !1), re();
  const a = o && Bg(o(n)), l = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  a && a.key, c = St(
    Ze,
    {
      key: (l && !Vi(l) ? l : `_${e}`) + // #7256 force differentiate fallback content from actual content
      (!a && i ? "_fb" : "")
    },
    a || [],
    a && s._ === 1 ? 64 : -2
  );
  return c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), o && o._c && (o._d = !0), c;
}
function Bg(s) {
  return s.some((e) => qa(e) ? !(e.type === Ps || e.type === Ze && !Bg(e.children)) : !0) ? s : null;
}
const Wd = (s) => s ? r0(s) ? du(s) : Wd(s.parent) : null, Ia = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Xn(/* @__PURE__ */ Object.create(null), {
    $: (s) => s,
    $el: (s) => s.vnode.el,
    $data: (s) => s.data,
    $props: (s) => s.props,
    $attrs: (s) => s.attrs,
    $slots: (s) => s.slots,
    $refs: (s) => s.refs,
    $parent: (s) => Wd(s.parent),
    $root: (s) => Wd(s.root),
    $host: (s) => s.ce,
    $emit: (s) => s.emit,
    $options: (s) => Gg(s),
    $forceUpdate: (s) => s.f || (s.f = () => {
      sf(s.update);
    }),
    $nextTick: (s) => s.n || (s.n = Ti.bind(s.proxy)),
    $watch: (s) => l_.bind(s)
  })
), zu = (s, e) => s !== Qt && !s.__isScriptSetup && Wt(s, e), q1 = {
  get({ _: s }, e) {
    if (e === "__v_skip")
      return !0;
    const { ctx: n, setupState: i, data: r, props: o, accessCache: a, type: l, appContext: c } = s;
    if (e[0] !== "$") {
      const m = a[e];
      if (m !== void 0)
        switch (m) {
          case 1:
            return i[e];
          case 2:
            return r[e];
          case 4:
            return n[e];
          case 3:
            return o[e];
        }
      else {
        if (zu(i, e))
          return a[e] = 1, i[e];
        if (r !== Qt && Wt(r, e))
          return a[e] = 2, r[e];
        if (Wt(o, e))
          return a[e] = 3, o[e];
        if (n !== Qt && Wt(n, e))
          return a[e] = 4, n[e];
        $d && (a[e] = 0);
      }
    }
    const u = Ia[e];
    let d, h;
    if (u)
      return e === "$attrs" && Hn(s.attrs, "get", ""), u(s);
    if (
      // css module (injected by vue-loader)
      (d = l.__cssModules) && (d = d[e])
    )
      return d;
    if (n !== Qt && Wt(n, e))
      return a[e] = 4, n[e];
    if (
      // global properties
      h = c.config.globalProperties, Wt(h, e)
    )
      return h[e];
  },
  set({ _: s }, e, n) {
    const { data: i, setupState: r, ctx: o } = s;
    return zu(r, e) ? (r[e] = n, !0) : i !== Qt && Wt(i, e) ? (i[e] = n, !0) : Wt(s.props, e) || e[0] === "$" && e.slice(1) in s ? !1 : (o[e] = n, !0);
  },
  has({
    _: { data: s, setupState: e, accessCache: n, ctx: i, appContext: r, props: o, type: a }
  }, l) {
    let c;
    return !!(n[l] || s !== Qt && l[0] !== "$" && Wt(s, l) || zu(e, l) || Wt(o, l) || Wt(i, l) || Wt(Ia, l) || Wt(r.config.globalProperties, l) || (c = a.__cssModules) && c[l]);
  },
  defineProperty(s, e, n) {
    return n.get != null ? s._.accessCache[e] = 0 : Wt(n, "value") && this.set(s, e, n.value, null), Reflect.defineProperty(s, e, n);
  }
};
function Z1() {
  return K1().slots;
}
function K1(s) {
  const e = uu();
  return e.setupContext || (e.setupContext = a0(e));
}
function pp(s) {
  return yt(s) ? s.reduce(
    (e, n) => (e[n] = null, e),
    {}
  ) : s;
}
let $d = !0;
function J1(s) {
  const e = Gg(s), n = s.proxy, i = s.ctx;
  $d = !1, e.beforeCreate && mp(e.beforeCreate, s, "bc");
  const {
    // state
    data: r,
    computed: o,
    methods: a,
    watch: l,
    provide: c,
    inject: u,
    // lifecycle
    created: d,
    beforeMount: h,
    mounted: m,
    beforeUpdate: p,
    updated: y,
    activated: _,
    deactivated: v,
    beforeDestroy: g,
    beforeUnmount: S,
    destroyed: w,
    unmounted: x,
    render: C,
    renderTracked: E,
    renderTriggered: P,
    errorCaptured: T,
    serverPrefetch: b,
    // public API
    expose: M,
    inheritAttrs: L,
    // assets
    components: N,
    directives: D,
    filters: O
  } = e;
  if (u && Q1(u, i, null), a)
    for (const he in a) {
      const ee = a[he];
      Ct(ee) && (i[he] = ee.bind(n));
    }
  if (r) {
    const he = r.call(n, n);
    en(he) && (s.data = Go(he));
  }
  if ($d = !0, o)
    for (const he in o) {
      const ee = o[he], le = Ct(ee) ? ee.bind(n, n) : Ct(ee.get) ? ee.get.bind(n, n) : es, oe = !Ct(ee) && Ct(ee.set) ? ee.set.bind(n) : es, Y = Oe({
        get: le,
        set: oe
      });
      Object.defineProperty(i, he, {
        enumerable: !0,
        configurable: !0,
        get: () => Y.value,
        set: (j) => Y.value = j
      });
    }
  if (l)
    for (const he in l)
      Vg(l[he], i, n, he);
  if (c) {
    const he = Ct(c) ? c.call(n) : c;
    Reflect.ownKeys(he).forEach((ee) => {
      $s(ee, he[ee]);
    });
  }
  d && mp(d, s, "c");
  function G(he, ee) {
    yt(ee) ? ee.forEach((le) => he(le.bind(n))) : ee && he(ee.bind(n));
  }
  if (G(N1, h), G(_n, m), G(B1, p), G(V1, y), G(U1, _), G(O1, v), G($1, T), G(W1, E), G(H1, P), G(of, S), G(jn, x), G(G1, b), yt(M))
    if (M.length) {
      const he = s.exposed || (s.exposed = {});
      M.forEach((ee) => {
        Object.defineProperty(he, ee, {
          get: () => n[ee],
          set: (le) => n[ee] = le,
          enumerable: !0
        });
      });
    } else s.exposed || (s.exposed = {});
  C && s.render === es && (s.render = C), L != null && (s.inheritAttrs = L), N && (s.components = N), D && (s.directives = D), b && Fg(s);
}
function Q1(s, e, n = es) {
  yt(s) && (s = Xd(s));
  for (const i in s) {
    const r = s[i];
    let o;
    en(r) ? "default" in r ? o = Ui(
      r.from || i,
      r.default,
      !0
    ) : o = Ui(r.from || i) : o = Ui(r), vn(o) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => o.value,
      set: (a) => o.value = a
    }) : e[i] = o;
  }
}
function mp(s, e, n) {
  ns(
    yt(s) ? s.map((i) => i.bind(e.proxy)) : s.bind(e.proxy),
    e,
    n
  );
}
function Vg(s, e, n, i) {
  let r = i.includes(".") ? $g(n, i) : () => n[i];
  if (gn(s)) {
    const o = e[s];
    Ct(o) && Ft(r, o);
  } else if (Ct(s))
    Ft(r, s.bind(n));
  else if (en(s))
    if (yt(s))
      s.forEach((o) => Vg(o, e, n, i));
    else {
      const o = Ct(s.handler) ? s.handler.bind(n) : e[s.handler];
      Ct(o) && Ft(r, o, s);
    }
}
function Gg(s) {
  const e = s.type, { mixins: n, extends: i } = e, {
    mixins: r,
    optionsCache: o,
    config: { optionMergeStrategies: a }
  } = s.appContext, l = o.get(e);
  let c;
  return l ? c = l : !r.length && !n && !i ? c = e : (c = {}, r.length && r.forEach(
    (u) => Oc(c, u, a, !0)
  ), Oc(c, e, a)), en(e) && o.set(e, c), c;
}
function Oc(s, e, n, i = !1) {
  const { mixins: r, extends: o } = e;
  o && Oc(s, o, n, !0), r && r.forEach(
    (a) => Oc(s, a, n, !0)
  );
  for (const a in e)
    if (!(i && a === "expose")) {
      const l = e_[a] || n && n[a];
      s[a] = l ? l(s[a], e[a]) : e[a];
    }
  return s;
}
const e_ = {
  data: vp,
  props: gp,
  emits: gp,
  // objects
  methods: ba,
  computed: ba,
  // lifecycle
  beforeCreate: qn,
  created: qn,
  beforeMount: qn,
  mounted: qn,
  beforeUpdate: qn,
  updated: qn,
  beforeDestroy: qn,
  beforeUnmount: qn,
  destroyed: qn,
  unmounted: qn,
  activated: qn,
  deactivated: qn,
  errorCaptured: qn,
  serverPrefetch: qn,
  // assets
  components: ba,
  directives: ba,
  // watch
  watch: n_,
  // provide / inject
  provide: vp,
  inject: t_
};
function vp(s, e) {
  return e ? s ? function() {
    return Xn(
      Ct(s) ? s.call(this, this) : s,
      Ct(e) ? e.call(this, this) : e
    );
  } : e : s;
}
function t_(s, e) {
  return ba(Xd(s), Xd(e));
}
function Xd(s) {
  if (yt(s)) {
    const e = {};
    for (let n = 0; n < s.length; n++)
      e[s[n]] = s[n];
    return e;
  }
  return s;
}
function qn(s, e) {
  return s ? [...new Set([].concat(s, e))] : e;
}
function ba(s, e) {
  return s ? Xn(/* @__PURE__ */ Object.create(null), s, e) : e;
}
function gp(s, e) {
  return s ? yt(s) && yt(e) ? [.../* @__PURE__ */ new Set([...s, ...e])] : Xn(
    /* @__PURE__ */ Object.create(null),
    pp(s),
    pp(e ?? {})
  ) : e;
}
function n_(s, e) {
  if (!s) return e;
  if (!e) return s;
  const n = Xn(/* @__PURE__ */ Object.create(null), s);
  for (const i in e)
    n[i] = qn(s[i], e[i]);
  return n;
}
function Hg() {
  return {
    app: null,
    config: {
      isNativeTag: eg,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let i_ = 0;
function s_(s, e) {
  return function(i, r = null) {
    Ct(i) || (i = Xn({}, i)), r != null && !en(r) && (r = null);
    const o = Hg(), a = /* @__PURE__ */ new WeakSet(), l = [];
    let c = !1;
    const u = o.app = {
      _uid: i_++,
      _component: i,
      _props: r,
      _container: null,
      _context: o,
      _instance: null,
      version: B_,
      get config() {
        return o.config;
      },
      set config(d) {
      },
      use(d, ...h) {
        return a.has(d) || (d && Ct(d.install) ? (a.add(d), d.install(u, ...h)) : Ct(d) && (a.add(d), d(u, ...h))), u;
      },
      mixin(d) {
        return o.mixins.includes(d) || o.mixins.push(d), u;
      },
      component(d, h) {
        return h ? (o.components[d] = h, u) : o.components[d];
      },
      directive(d, h) {
        return h ? (o.directives[d] = h, u) : o.directives[d];
      },
      mount(d, h, m) {
        if (!c) {
          const p = u._ceVNode || Ne(i, r);
          return p.appContext = o, m === !0 ? m = "svg" : m === !1 && (m = void 0), s(p, d, m), c = !0, u._container = d, d.__vue_app__ = u, du(p.component);
        }
      },
      onUnmount(d) {
        l.push(d);
      },
      unmount() {
        c && (ns(
          l,
          u._instance,
          16
        ), s(null, u._container), delete u._container.__vue_app__);
      },
      provide(d, h) {
        return o.provides[d] = h, u;
      },
      runWithContext(d) {
        const h = kr;
        kr = u;
        try {
          return d();
        } finally {
          kr = h;
        }
      }
    };
    return u;
  };
}
let kr = null;
function $s(s, e) {
  if (Wn) {
    let n = Wn.provides;
    const i = Wn.parent && Wn.parent.provides;
    i === n && (n = Wn.provides = Object.create(i)), n[s] = e;
  }
}
function Ui(s, e, n = !1) {
  const i = uu();
  if (i || kr) {
    let r = kr ? kr._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (r && s in r)
      return r[s];
    if (arguments.length > 1)
      return n && Ct(e) ? e.call(i && i.proxy) : e;
  }
}
function r_() {
  return !!(uu() || kr);
}
const o_ = Symbol.for("v-scx"), a_ = () => Ui(o_);
function Ft(s, e, n) {
  return Wg(s, e, n);
}
function Wg(s, e, n = Qt) {
  const { immediate: i, deep: r, flush: o, once: a } = n, l = Xn({}, n), c = e && i || !e && o !== "post";
  let u;
  if (Za) {
    if (o === "sync") {
      const p = a_();
      u = p.__watcherHandles || (p.__watcherHandles = []);
    } else if (!c) {
      const p = () => {
      };
      return p.stop = es, p.resume = es, p.pause = es, p;
    }
  }
  const d = Wn;
  l.call = (p, y, _) => ns(p, d, y, _);
  let h = !1;
  o === "post" ? l.scheduler = (p) => {
    Jn(p, d && d.suspense);
  } : o !== "sync" && (h = !0, l.scheduler = (p, y) => {
    y ? p() : sf(p);
  }), l.augmentJob = (p) => {
    e && (p.flags |= 4), h && (p.flags |= 2, d && (p.id = d.uid, p.i = d));
  };
  const m = P1(s, e, l);
  return Za && (u ? u.push(m) : c && m()), m;
}
function l_(s, e, n) {
  const i = this.proxy, r = gn(s) ? s.includes(".") ? $g(i, s) : () => i[s] : s.bind(i, i);
  let o;
  Ct(e) ? o = e : (o = e.handler, n = e);
  const a = fl(this), l = Wg(r, o.bind(i), n);
  return a(), l;
}
function $g(s, e) {
  const n = e.split(".");
  return () => {
    let i = s;
    for (let r = 0; r < n.length && i; r++)
      i = i[n[r]];
    return i;
  };
}
const c_ = (s, e) => e === "modelValue" || e === "model-value" ? s.modelModifiers : s[`${e}Modifiers`] || s[`${Ai(e)}Modifiers`] || s[`${ir(e)}Modifiers`];
function u_(s, e, ...n) {
  if (s.isUnmounted) return;
  const i = s.vnode.props || Qt;
  let r = n;
  const o = e.startsWith("update:"), a = o && c_(i, e.slice(7));
  a && (a.trim && (r = n.map((d) => gn(d) ? d.trim() : d)), a.number && (r = n.map(nu)));
  let l, c = i[l = ku(e)] || // also try camelCase event handler (#2249)
  i[l = ku(Ai(e))];
  !c && o && (c = i[l = ku(ir(e))]), c && ns(
    c,
    s,
    6,
    r
  );
  const u = i[l + "Once"];
  if (u) {
    if (!s.emitted)
      s.emitted = {};
    else if (s.emitted[l])
      return;
    s.emitted[l] = !0, ns(
      u,
      s,
      6,
      r
    );
  }
}
const d_ = /* @__PURE__ */ new WeakMap();
function Xg(s, e, n = !1) {
  const i = n ? d_ : e.emitsCache, r = i.get(s);
  if (r !== void 0)
    return r;
  const o = s.emits;
  let a = {}, l = !1;
  if (!Ct(s)) {
    const c = (u) => {
      const d = Xg(u, e, !0);
      d && (l = !0, Xn(a, d));
    };
    !n && e.mixins.length && e.mixins.forEach(c), s.extends && c(s.extends), s.mixins && s.mixins.forEach(c);
  }
  return !o && !l ? (en(s) && i.set(s, null), null) : (yt(o) ? o.forEach((c) => a[c] = null) : Xn(a, o), en(s) && i.set(s, a), a);
}
function lu(s, e) {
  return !s || !Jc(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Wt(s, e[0].toLowerCase() + e.slice(1)) || Wt(s, ir(e)) || Wt(s, e));
}
function yp(s) {
  const {
    type: e,
    vnode: n,
    proxy: i,
    withProxy: r,
    propsOptions: [o],
    slots: a,
    attrs: l,
    emit: c,
    render: u,
    renderCache: d,
    props: h,
    data: m,
    setupState: p,
    ctx: y,
    inheritAttrs: _
  } = s, v = Fc(s);
  let g, S;
  try {
    if (n.shapeFlag & 4) {
      const x = r || i, C = x;
      g = Ji(
        u.call(
          C,
          x,
          d,
          h,
          p,
          m,
          y
        )
      ), S = l;
    } else {
      const x = e;
      g = Ji(
        x.length > 1 ? x(
          h,
          { attrs: l, slots: a, emit: c }
        ) : x(
          h,
          null
        )
      ), S = e.props ? l : h_(l);
    }
  } catch (x) {
    ka.length = 0, ou(x, s, 1), g = Ne(Ps);
  }
  let w = g;
  if (S && _ !== !1) {
    const x = Object.keys(S), { shapeFlag: C } = w;
    x.length && C & 7 && (o && x.some(Yh) && (S = f_(
      S,
      o
    )), w = Do(w, S, !1, !0));
  }
  return n.dirs && (w = Do(w, null, !1, !0), w.dirs = w.dirs ? w.dirs.concat(n.dirs) : n.dirs), n.transition && rf(w, n.transition), g = w, Fc(v), g;
}
const h_ = (s) => {
  let e;
  for (const n in s)
    (n === "class" || n === "style" || Jc(n)) && ((e || (e = {}))[n] = s[n]);
  return e;
}, f_ = (s, e) => {
  const n = {};
  for (const i in s)
    (!Yh(i) || !(i.slice(9) in e)) && (n[i] = s[i]);
  return n;
};
function p_(s, e, n) {
  const { props: i, children: r, component: o } = s, { props: a, children: l, patchFlag: c } = e, u = o.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (n && c >= 0) {
    if (c & 1024)
      return !0;
    if (c & 16)
      return i ? _p(i, a, u) : !!a;
    if (c & 8) {
      const d = e.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        const m = d[h];
        if (a[m] !== i[m] && !lu(u, m))
          return !0;
      }
    }
  } else
    return (r || l) && (!l || !l.$stable) ? !0 : i === a ? !1 : i ? a ? _p(i, a, u) : !0 : !!a;
  return !1;
}
function _p(s, e, n) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(s).length)
    return !0;
  for (let r = 0; r < i.length; r++) {
    const o = i[r];
    if (e[o] !== s[o] && !lu(n, o))
      return !0;
  }
  return !1;
}
function m_({ vnode: s, parent: e }, n) {
  for (; e; ) {
    const i = e.subTree;
    if (i.suspense && i.suspense.activeBranch === s && (i.el = s.el), i === s)
      (s = e.vnode).el = n, e = e.parent;
    else
      break;
  }
}
const jg = {}, Yg = () => Object.create(jg), qg = (s) => Object.getPrototypeOf(s) === jg;
function v_(s, e, n, i = !1) {
  const r = {}, o = Yg();
  s.propsDefaults = /* @__PURE__ */ Object.create(null), Zg(s, e, r, o);
  for (const a in s.propsOptions[0])
    a in r || (r[a] = void 0);
  n ? s.props = i ? r : _1(r) : s.type.props ? s.props = r : s.props = o, s.attrs = o;
}
function g_(s, e, n, i) {
  const {
    props: r,
    attrs: o,
    vnode: { patchFlag: a }
  } = s, l = zt(r), [c] = s.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || a > 0) && !(a & 16)
  ) {
    if (a & 8) {
      const d = s.vnode.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        let m = d[h];
        if (lu(s.emitsOptions, m))
          continue;
        const p = e[m];
        if (c)
          if (Wt(o, m))
            p !== o[m] && (o[m] = p, u = !0);
          else {
            const y = Ai(m);
            r[y] = jd(
              c,
              l,
              y,
              p,
              s,
              !1
            );
          }
        else
          p !== o[m] && (o[m] = p, u = !0);
      }
    }
  } else {
    Zg(s, e, r, o) && (u = !0);
    let d;
    for (const h in l)
      (!e || // for camelCase
      !Wt(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = ir(h)) === h || !Wt(e, d))) && (c ? n && // for camelCase
      (n[h] !== void 0 || // for kebab-case
      n[d] !== void 0) && (r[h] = jd(
        c,
        l,
        h,
        void 0,
        s,
        !0
      )) : delete r[h]);
    if (o !== l)
      for (const h in o)
        (!e || !Wt(e, h)) && (delete o[h], u = !0);
  }
  u && _s(s.attrs, "set", "");
}
function Zg(s, e, n, i) {
  const [r, o] = s.propsOptions;
  let a = !1, l;
  if (e)
    for (let c in e) {
      if (Ta(c))
        continue;
      const u = e[c];
      let d;
      r && Wt(r, d = Ai(c)) ? !o || !o.includes(d) ? n[d] = u : (l || (l = {}))[d] = u : lu(s.emitsOptions, c) || (!(c in i) || u !== i[c]) && (i[c] = u, a = !0);
    }
  if (o) {
    const c = zt(n), u = l || Qt;
    for (let d = 0; d < o.length; d++) {
      const h = o[d];
      n[h] = jd(
        r,
        c,
        h,
        u[h],
        s,
        !Wt(u, h)
      );
    }
  }
  return a;
}
function jd(s, e, n, i, r, o) {
  const a = s[n];
  if (a != null) {
    const l = Wt(a, "default");
    if (l && i === void 0) {
      const c = a.default;
      if (a.type !== Function && !a.skipFactory && Ct(c)) {
        const { propsDefaults: u } = r;
        if (n in u)
          i = u[n];
        else {
          const d = fl(r);
          i = u[n] = c.call(
            null,
            e
          ), d();
        }
      } else
        i = c;
      r.ce && r.ce._setProp(n, i);
    }
    a[
      0
      /* shouldCast */
    ] && (o && !l ? i = !1 : a[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === ir(n)) && (i = !0));
  }
  return i;
}
const y_ = /* @__PURE__ */ new WeakMap();
function Kg(s, e, n = !1) {
  const i = n ? y_ : e.propsCache, r = i.get(s);
  if (r)
    return r;
  const o = s.props, a = {}, l = [];
  let c = !1;
  if (!Ct(s)) {
    const d = (h) => {
      c = !0;
      const [m, p] = Kg(h, e, !0);
      Xn(a, m), p && l.push(...p);
    };
    !n && e.mixins.length && e.mixins.forEach(d), s.extends && d(s.extends), s.mixins && s.mixins.forEach(d);
  }
  if (!o && !c)
    return en(s) && i.set(s, wo), wo;
  if (yt(o))
    for (let d = 0; d < o.length; d++) {
      const h = Ai(o[d]);
      xp(h) && (a[h] = Qt);
    }
  else if (o)
    for (const d in o) {
      const h = Ai(d);
      if (xp(h)) {
        const m = o[d], p = a[h] = yt(m) || Ct(m) ? { type: m } : Xn({}, m), y = p.type;
        let _ = !1, v = !0;
        if (yt(y))
          for (let g = 0; g < y.length; ++g) {
            const S = y[g], w = Ct(S) && S.name;
            if (w === "Boolean") {
              _ = !0;
              break;
            } else w === "String" && (v = !1);
          }
        else
          _ = Ct(y) && y.name === "Boolean";
        p[
          0
          /* shouldCast */
        ] = _, p[
          1
          /* shouldCastTrue */
        ] = v, (_ || Wt(p, "default")) && l.push(h);
      }
    }
  const u = [a, l];
  return en(s) && i.set(s, u), u;
}
function xp(s) {
  return s[0] !== "$" && !Ta(s);
}
const af = (s) => s === "_" || s === "_ctx" || s === "$stable", lf = (s) => yt(s) ? s.map(Ji) : [Ji(s)], __ = (s, e, n) => {
  if (e._n)
    return e;
  const i = Fi((...r) => lf(e(...r)), n);
  return i._c = !1, i;
}, Jg = (s, e, n) => {
  const i = s._ctx;
  for (const r in s) {
    if (af(r)) continue;
    const o = s[r];
    if (Ct(o))
      e[r] = __(r, o, i);
    else if (o != null) {
      const a = lf(o);
      e[r] = () => a;
    }
  }
}, Qg = (s, e) => {
  const n = lf(e);
  s.slots.default = () => n;
}, e0 = (s, e, n) => {
  for (const i in e)
    (n || !af(i)) && (s[i] = e[i]);
}, x_ = (s, e, n) => {
  const i = s.slots = Yg();
  if (s.vnode.shapeFlag & 32) {
    const r = e._;
    r ? (e0(i, e, n), n && sg(i, "_", r, !0)) : Jg(e, i);
  } else e && Qg(s, e);
}, b_ = (s, e, n) => {
  const { vnode: i, slots: r } = s;
  let o = !0, a = Qt;
  if (i.shapeFlag & 32) {
    const l = e._;
    l ? n && l === 1 ? o = !1 : e0(r, e, n) : (o = !e.$stable, Jg(e, r)), a = e;
  } else e && (Qg(s, e), a = { default: 1 });
  if (o)
    for (const l in r)
      !af(l) && a[l] == null && delete r[l];
}, Jn = E_;
function w_(s) {
  return S_(s);
}
function S_(s, e) {
  const n = iu();
  n.__VUE__ = !0;
  const {
    insert: i,
    remove: r,
    patchProp: o,
    createElement: a,
    createText: l,
    createComment: c,
    setText: u,
    setElementText: d,
    parentNode: h,
    nextSibling: m,
    setScopeId: p = es,
    insertStaticContent: y
  } = s, _ = (k, Q, Z, R = null, ie = null, J = null, B = void 0, $ = null, se = !!Q.dynamicChildren) => {
    if (k === Q)
      return;
    k && !ia(k, Q) && (R = H(k), j(k, ie, J, !0), k = null), Q.patchFlag === -2 && (se = !1, Q.dynamicChildren = null);
    const { type: U, ref: z, shapeFlag: K } = Q;
    switch (U) {
      case cu:
        v(k, Q, Z, R);
        break;
      case Ps:
        g(k, Q, Z, R);
        break;
      case _c:
        k == null && S(Q, Z, R, B);
        break;
      case Ze:
        N(
          k,
          Q,
          Z,
          R,
          ie,
          J,
          B,
          $,
          se
        );
        break;
      default:
        K & 1 ? C(
          k,
          Q,
          Z,
          R,
          ie,
          J,
          B,
          $,
          se
        ) : K & 6 ? D(
          k,
          Q,
          Z,
          R,
          ie,
          J,
          B,
          $,
          se
        ) : (K & 64 || K & 128) && U.process(
          k,
          Q,
          Z,
          R,
          ie,
          J,
          B,
          $,
          se,
          I
        );
    }
    z != null && ie ? Ra(z, k && k.ref, J, Q || k, !Q) : z == null && k && k.ref != null && Ra(k.ref, null, J, k, !0);
  }, v = (k, Q, Z, R) => {
    if (k == null)
      i(
        Q.el = l(Q.children),
        Z,
        R
      );
    else {
      const ie = Q.el = k.el;
      Q.children !== k.children && u(ie, Q.children);
    }
  }, g = (k, Q, Z, R) => {
    k == null ? i(
      Q.el = c(Q.children || ""),
      Z,
      R
    ) : Q.el = k.el;
  }, S = (k, Q, Z, R) => {
    [k.el, k.anchor] = y(
      k.children,
      Q,
      Z,
      R,
      k.el,
      k.anchor
    );
  }, w = ({ el: k, anchor: Q }, Z, R) => {
    let ie;
    for (; k && k !== Q; )
      ie = m(k), i(k, Z, R), k = ie;
    i(Q, Z, R);
  }, x = ({ el: k, anchor: Q }) => {
    let Z;
    for (; k && k !== Q; )
      Z = m(k), r(k), k = Z;
    r(Q);
  }, C = (k, Q, Z, R, ie, J, B, $, se) => {
    if (Q.type === "svg" ? B = "svg" : Q.type === "math" && (B = "mathml"), k == null)
      E(
        Q,
        Z,
        R,
        ie,
        J,
        B,
        $,
        se
      );
    else {
      const U = k.el && k.el._isVueCE ? k.el : null;
      try {
        U && U._beginPatch(), b(
          k,
          Q,
          ie,
          J,
          B,
          $,
          se
        );
      } finally {
        U && U._endPatch();
      }
    }
  }, E = (k, Q, Z, R, ie, J, B, $) => {
    let se, U;
    const { props: z, shapeFlag: K, transition: ue, dirs: me } = k;
    if (se = k.el = a(
      k.type,
      J,
      z && z.is,
      z
    ), K & 8 ? d(se, k.children) : K & 16 && T(
      k.children,
      se,
      null,
      R,
      ie,
      Nu(k, J),
      B,
      $
    ), me && or(k, null, R, "created"), P(se, k, k.scopeId, B, R), z) {
      for (const Me in z)
        Me !== "value" && !Ta(Me) && o(se, Me, null, z[Me], J, R);
      "value" in z && o(se, "value", null, z.value, J), (U = z.onVnodeBeforeMount) && ji(U, R, k);
    }
    me && or(k, null, R, "beforeMount");
    const ge = M_(ie, ue);
    ge && ue.beforeEnter(se), i(se, Q, Z), ((U = z && z.onVnodeMounted) || ge || me) && Jn(() => {
      U && ji(U, R, k), ge && ue.enter(se), me && or(k, null, R, "mounted");
    }, ie);
  }, P = (k, Q, Z, R, ie) => {
    if (Z && p(k, Z), R)
      for (let J = 0; J < R.length; J++)
        p(k, R[J]);
    if (ie) {
      let J = ie.subTree;
      if (Q === J || n0(J.type) && (J.ssContent === Q || J.ssFallback === Q)) {
        const B = ie.vnode;
        P(
          k,
          B,
          B.scopeId,
          B.slotScopeIds,
          ie.parent
        );
      }
    }
  }, T = (k, Q, Z, R, ie, J, B, $, se = 0) => {
    for (let U = se; U < k.length; U++) {
      const z = k[U] = $ ? qs(k[U]) : Ji(k[U]);
      _(
        null,
        z,
        Q,
        Z,
        R,
        ie,
        J,
        B,
        $
      );
    }
  }, b = (k, Q, Z, R, ie, J, B) => {
    const $ = Q.el = k.el;
    let { patchFlag: se, dynamicChildren: U, dirs: z } = Q;
    se |= k.patchFlag & 16;
    const K = k.props || Qt, ue = Q.props || Qt;
    let me;
    if (Z && ar(Z, !1), (me = ue.onVnodeBeforeUpdate) && ji(me, Z, Q, k), z && or(Q, k, Z, "beforeUpdate"), Z && ar(Z, !0), (K.innerHTML && ue.innerHTML == null || K.textContent && ue.textContent == null) && d($, ""), U ? M(
      k.dynamicChildren,
      U,
      $,
      Z,
      R,
      Nu(Q, ie),
      J
    ) : B || ee(
      k,
      Q,
      $,
      null,
      Z,
      R,
      Nu(Q, ie),
      J,
      !1
    ), se > 0) {
      if (se & 16)
        L($, K, ue, Z, ie);
      else if (se & 2 && K.class !== ue.class && o($, "class", null, ue.class, ie), se & 4 && o($, "style", K.style, ue.style, ie), se & 8) {
        const ge = Q.dynamicProps;
        for (let Me = 0; Me < ge.length; Me++) {
          const Te = ge[Me], Ae = K[Te], Xe = ue[Te];
          (Xe !== Ae || Te === "value") && o($, Te, Ae, Xe, ie, Z);
        }
      }
      se & 1 && k.children !== Q.children && d($, Q.children);
    } else !B && U == null && L($, K, ue, Z, ie);
    ((me = ue.onVnodeUpdated) || z) && Jn(() => {
      me && ji(me, Z, Q, k), z && or(Q, k, Z, "updated");
    }, R);
  }, M = (k, Q, Z, R, ie, J, B) => {
    for (let $ = 0; $ < Q.length; $++) {
      const se = k[$], U = Q[$], z = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        se.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (se.type === Ze || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ia(se, U) || // - In the case of a component, it could contain anything.
        se.shapeFlag & 198) ? h(se.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          Z
        )
      );
      _(
        se,
        U,
        z,
        null,
        R,
        ie,
        J,
        B,
        !0
      );
    }
  }, L = (k, Q, Z, R, ie) => {
    if (Q !== Z) {
      if (Q !== Qt)
        for (const J in Q)
          !Ta(J) && !(J in Z) && o(
            k,
            J,
            Q[J],
            null,
            ie,
            R
          );
      for (const J in Z) {
        if (Ta(J)) continue;
        const B = Z[J], $ = Q[J];
        B !== $ && J !== "value" && o(k, J, $, B, ie, R);
      }
      "value" in Z && o(k, "value", Q.value, Z.value, ie);
    }
  }, N = (k, Q, Z, R, ie, J, B, $, se) => {
    const U = Q.el = k ? k.el : l(""), z = Q.anchor = k ? k.anchor : l("");
    let { patchFlag: K, dynamicChildren: ue, slotScopeIds: me } = Q;
    me && ($ = $ ? $.concat(me) : me), k == null ? (i(U, Z, R), i(z, Z, R), T(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      Q.children || [],
      Z,
      z,
      ie,
      J,
      B,
      $,
      se
    )) : K > 0 && K & 64 && ue && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    k.dynamicChildren ? (M(
      k.dynamicChildren,
      ue,
      Z,
      ie,
      J,
      B,
      $
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (Q.key != null || ie && Q === ie.subTree) && cf(
      k,
      Q,
      !0
      /* shallow */
    )) : ee(
      k,
      Q,
      Z,
      z,
      ie,
      J,
      B,
      $,
      se
    );
  }, D = (k, Q, Z, R, ie, J, B, $, se) => {
    Q.slotScopeIds = $, k == null ? Q.shapeFlag & 512 ? ie.ctx.activate(
      Q,
      Z,
      R,
      B,
      se
    ) : O(
      Q,
      Z,
      R,
      ie,
      J,
      B,
      se
    ) : A(k, Q, se);
  }, O = (k, Q, Z, R, ie, J, B) => {
    const $ = k.component = k_(
      k,
      R,
      ie
    );
    if (Ug(k) && ($.ctx.renderer = I), L_($, !1, B), $.asyncDep) {
      if (ie && ie.registerDep($, G, B), !k.el) {
        const se = $.subTree = Ne(Ps);
        g(null, se, Q, Z), k.placeholder = se.el;
      }
    } else
      G(
        $,
        k,
        Q,
        Z,
        ie,
        J,
        B
      );
  }, A = (k, Q, Z) => {
    const R = Q.component = k.component;
    if (p_(k, Q, Z))
      if (R.asyncDep && !R.asyncResolved) {
        he(R, Q, Z);
        return;
      } else
        R.next = Q, R.update();
    else
      Q.el = k.el, R.vnode = Q;
  }, G = (k, Q, Z, R, ie, J, B) => {
    const $ = () => {
      if (k.isMounted) {
        let { next: K, bu: ue, u: me, parent: ge, vnode: Me } = k;
        {
          const He = t0(k);
          if (He) {
            K && (K.el = Me.el, he(k, K, B)), He.asyncDep.then(() => {
              k.isUnmounted || $();
            });
            return;
          }
        }
        let Te = K, Ae;
        ar(k, !1), K ? (K.el = Me.el, he(k, K, B)) : K = Me, ue && gc(ue), (Ae = K.props && K.props.onVnodeBeforeUpdate) && ji(Ae, ge, K, Me), ar(k, !0);
        const Xe = yp(k), Fe = k.subTree;
        k.subTree = Xe, _(
          Fe,
          Xe,
          // parent may have changed if it's in a teleport
          h(Fe.el),
          // anchor may have changed if it's in a fragment
          H(Fe),
          k,
          ie,
          J
        ), K.el = Xe.el, Te === null && m_(k, Xe.el), me && Jn(me, ie), (Ae = K.props && K.props.onVnodeUpdated) && Jn(
          () => ji(Ae, ge, K, Me),
          ie
        );
      } else {
        let K;
        const { el: ue, props: me } = Q, { bm: ge, m: Me, parent: Te, root: Ae, type: Xe } = k, Fe = Co(Q);
        ar(k, !1), ge && gc(ge), !Fe && (K = me && me.onVnodeBeforeMount) && ji(K, Te, Q), ar(k, !0);
        {
          Ae.ce && // @ts-expect-error _def is private
          Ae.ce._def.shadowRoot !== !1 && Ae.ce._injectChildStyle(Xe);
          const He = k.subTree = yp(k);
          _(
            null,
            He,
            Z,
            R,
            k,
            ie,
            J
          ), Q.el = He.el;
        }
        if (Me && Jn(Me, ie), !Fe && (K = me && me.onVnodeMounted)) {
          const He = Q;
          Jn(
            () => ji(K, Te, He),
            ie
          );
        }
        (Q.shapeFlag & 256 || Te && Co(Te.vnode) && Te.vnode.shapeFlag & 256) && k.a && Jn(k.a, ie), k.isMounted = !0, Q = Z = R = null;
      }
    };
    k.scope.on();
    const se = k.effect = new dg($);
    k.scope.off();
    const U = k.update = se.run.bind(se), z = k.job = se.runIfDirty.bind(se);
    z.i = k, z.id = k.uid, se.scheduler = () => sf(z), ar(k, !0), U();
  }, he = (k, Q, Z) => {
    Q.component = k;
    const R = k.vnode.props;
    k.vnode = Q, k.next = null, g_(k, Q.props, R, Z), b_(k, Q.children, Z), Es(), lp(k), Ts();
  }, ee = (k, Q, Z, R, ie, J, B, $, se = !1) => {
    const U = k && k.children, z = k ? k.shapeFlag : 0, K = Q.children, { patchFlag: ue, shapeFlag: me } = Q;
    if (ue > 0) {
      if (ue & 128) {
        oe(
          U,
          K,
          Z,
          R,
          ie,
          J,
          B,
          $,
          se
        );
        return;
      } else if (ue & 256) {
        le(
          U,
          K,
          Z,
          R,
          ie,
          J,
          B,
          $,
          se
        );
        return;
      }
    }
    me & 8 ? (z & 16 && de(U, ie, J), K !== U && d(Z, K)) : z & 16 ? me & 16 ? oe(
      U,
      K,
      Z,
      R,
      ie,
      J,
      B,
      $,
      se
    ) : de(U, ie, J, !0) : (z & 8 && d(Z, ""), me & 16 && T(
      K,
      Z,
      R,
      ie,
      J,
      B,
      $,
      se
    ));
  }, le = (k, Q, Z, R, ie, J, B, $, se) => {
    k = k || wo, Q = Q || wo;
    const U = k.length, z = Q.length, K = Math.min(U, z);
    let ue;
    for (ue = 0; ue < K; ue++) {
      const me = Q[ue] = se ? qs(Q[ue]) : Ji(Q[ue]);
      _(
        k[ue],
        me,
        Z,
        null,
        ie,
        J,
        B,
        $,
        se
      );
    }
    U > z ? de(
      k,
      ie,
      J,
      !0,
      !1,
      K
    ) : T(
      Q,
      Z,
      R,
      ie,
      J,
      B,
      $,
      se,
      K
    );
  }, oe = (k, Q, Z, R, ie, J, B, $, se) => {
    let U = 0;
    const z = Q.length;
    let K = k.length - 1, ue = z - 1;
    for (; U <= K && U <= ue; ) {
      const me = k[U], ge = Q[U] = se ? qs(Q[U]) : Ji(Q[U]);
      if (ia(me, ge))
        _(
          me,
          ge,
          Z,
          null,
          ie,
          J,
          B,
          $,
          se
        );
      else
        break;
      U++;
    }
    for (; U <= K && U <= ue; ) {
      const me = k[K], ge = Q[ue] = se ? qs(Q[ue]) : Ji(Q[ue]);
      if (ia(me, ge))
        _(
          me,
          ge,
          Z,
          null,
          ie,
          J,
          B,
          $,
          se
        );
      else
        break;
      K--, ue--;
    }
    if (U > K) {
      if (U <= ue) {
        const me = ue + 1, ge = me < z ? Q[me].el : R;
        for (; U <= ue; )
          _(
            null,
            Q[U] = se ? qs(Q[U]) : Ji(Q[U]),
            Z,
            ge,
            ie,
            J,
            B,
            $,
            se
          ), U++;
      }
    } else if (U > ue)
      for (; U <= K; )
        j(k[U], ie, J, !0), U++;
    else {
      const me = U, ge = U, Me = /* @__PURE__ */ new Map();
      for (U = ge; U <= ue; U++) {
        const ke = Q[U] = se ? qs(Q[U]) : Ji(Q[U]);
        ke.key != null && Me.set(ke.key, U);
      }
      let Te, Ae = 0;
      const Xe = ue - ge + 1;
      let Fe = !1, He = 0;
      const Ye = new Array(Xe);
      for (U = 0; U < Xe; U++) Ye[U] = 0;
      for (U = me; U <= K; U++) {
        const ke = k[U];
        if (Ae >= Xe) {
          j(ke, ie, J, !0);
          continue;
        }
        let nt;
        if (ke.key != null)
          nt = Me.get(ke.key);
        else
          for (Te = ge; Te <= ue; Te++)
            if (Ye[Te - ge] === 0 && ia(ke, Q[Te])) {
              nt = Te;
              break;
            }
        nt === void 0 ? j(ke, ie, J, !0) : (Ye[nt - ge] = U + 1, nt >= He ? He = nt : Fe = !0, _(
          ke,
          Q[nt],
          Z,
          null,
          ie,
          J,
          B,
          $,
          se
        ), Ae++);
      }
      const We = Fe ? C_(Ye) : wo;
      for (Te = We.length - 1, U = Xe - 1; U >= 0; U--) {
        const ke = ge + U, nt = Q[ke], Je = Q[ke + 1], _t = ke + 1 < z ? (
          // #13559, fallback to el placeholder for unresolved async component
          Je.el || Je.placeholder
        ) : R;
        Ye[U] === 0 ? _(
          null,
          nt,
          Z,
          _t,
          ie,
          J,
          B,
          $,
          se
        ) : Fe && (Te < 0 || U !== We[Te] ? Y(nt, Z, _t, 2) : Te--);
      }
    }
  }, Y = (k, Q, Z, R, ie = null) => {
    const { el: J, type: B, transition: $, children: se, shapeFlag: U } = k;
    if (U & 6) {
      Y(k.component.subTree, Q, Z, R);
      return;
    }
    if (U & 128) {
      k.suspense.move(Q, Z, R);
      return;
    }
    if (U & 64) {
      B.move(k, Q, Z, I);
      return;
    }
    if (B === Ze) {
      i(J, Q, Z);
      for (let K = 0; K < se.length; K++)
        Y(se[K], Q, Z, R);
      i(k.anchor, Q, Z);
      return;
    }
    if (B === _c) {
      w(k, Q, Z);
      return;
    }
    if (R !== 2 && U & 1 && $)
      if (R === 0)
        $.beforeEnter(J), i(J, Q, Z), Jn(() => $.enter(J), ie);
      else {
        const { leave: K, delayLeave: ue, afterLeave: me } = $, ge = () => {
          k.ctx.isUnmounted ? r(J) : i(J, Q, Z);
        }, Me = () => {
          J._isLeaving && J[F1](
            !0
            /* cancelled */
          ), K(J, () => {
            ge(), me && me();
          });
        };
        ue ? ue(J, ge, Me) : Me();
      }
    else
      i(J, Q, Z);
  }, j = (k, Q, Z, R = !1, ie = !1) => {
    const {
      type: J,
      props: B,
      ref: $,
      children: se,
      dynamicChildren: U,
      shapeFlag: z,
      patchFlag: K,
      dirs: ue,
      cacheIndex: me
    } = k;
    if (K === -2 && (ie = !1), $ != null && (Es(), Ra($, null, Z, k, !0), Ts()), me != null && (Q.renderCache[me] = void 0), z & 256) {
      Q.ctx.deactivate(k);
      return;
    }
    const ge = z & 1 && ue, Me = !Co(k);
    let Te;
    if (Me && (Te = B && B.onVnodeBeforeUnmount) && ji(Te, Q, k), z & 6)
      ne(k.component, Z, R);
    else {
      if (z & 128) {
        k.suspense.unmount(Z, R);
        return;
      }
      ge && or(k, null, Q, "beforeUnmount"), z & 64 ? k.type.remove(
        k,
        Q,
        Z,
        I,
        R
      ) : U && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !U.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (J !== Ze || K > 0 && K & 64) ? de(
        U,
        Q,
        Z,
        !1,
        !0
      ) : (J === Ze && K & 384 || !ie && z & 16) && de(se, Q, Z), R && q(k);
    }
    (Me && (Te = B && B.onVnodeUnmounted) || ge) && Jn(() => {
      Te && ji(Te, Q, k), ge && or(k, null, Q, "unmounted");
    }, Z);
  }, q = (k) => {
    const { type: Q, el: Z, anchor: R, transition: ie } = k;
    if (Q === Ze) {
      te(Z, R);
      return;
    }
    if (Q === _c) {
      x(k);
      return;
    }
    const J = () => {
      r(Z), ie && !ie.persisted && ie.afterLeave && ie.afterLeave();
    };
    if (k.shapeFlag & 1 && ie && !ie.persisted) {
      const { leave: B, delayLeave: $ } = ie, se = () => B(Z, J);
      $ ? $(k.el, J, se) : se();
    } else
      J();
  }, te = (k, Q) => {
    let Z;
    for (; k !== Q; )
      Z = m(k), r(k), k = Z;
    r(Q);
  }, ne = (k, Q, Z) => {
    const { bum: R, scope: ie, job: J, subTree: B, um: $, m: se, a: U } = k;
    bp(se), bp(U), R && gc(R), ie.stop(), J && (J.flags |= 8, j(B, k, Q, Z)), $ && Jn($, Q), Jn(() => {
      k.isUnmounted = !0;
    }, Q);
  }, de = (k, Q, Z, R = !1, ie = !1, J = 0) => {
    for (let B = J; B < k.length; B++)
      j(k[B], Q, Z, R, ie);
  }, H = (k) => {
    if (k.shapeFlag & 6)
      return H(k.component.subTree);
    if (k.shapeFlag & 128)
      return k.suspense.next();
    const Q = m(k.anchor || k.el), Z = Q && Q[Ig];
    return Z ? m(Z) : Q;
  };
  let X = !1;
  const V = (k, Q, Z) => {
    k == null ? Q._vnode && j(Q._vnode, null, null, !0) : _(
      Q._vnode || null,
      k,
      Q,
      null,
      null,
      null,
      Z
    ), Q._vnode = k, X || (X = !0, lp(), Pg(), X = !1);
  }, I = {
    p: _,
    um: j,
    m: Y,
    r: q,
    mt: O,
    mc: T,
    pc: ee,
    pbc: M,
    n: H,
    o: s
  };
  return {
    render: V,
    hydrate: void 0,
    createApp: s_(V)
  };
}
function Nu({ type: s, props: e }, n) {
  return n === "svg" && s === "foreignObject" || n === "mathml" && s === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : n;
}
function ar({ effect: s, job: e }, n) {
  n ? (s.flags |= 32, e.flags |= 4) : (s.flags &= -33, e.flags &= -5);
}
function M_(s, e) {
  return (!s || s && !s.pendingBranch) && e && !e.persisted;
}
function cf(s, e, n = !1) {
  const i = s.children, r = e.children;
  if (yt(i) && yt(r))
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      let l = r[o];
      l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[o] = qs(r[o]), l.el = a.el), !n && l.patchFlag !== -2 && cf(a, l)), l.type === cu && // avoid cached text nodes retaining detached dom nodes
      l.patchFlag !== -1 && (l.el = a.el), l.type === Ps && !l.el && (l.el = a.el);
    }
}
function C_(s) {
  const e = s.slice(), n = [0];
  let i, r, o, a, l;
  const c = s.length;
  for (i = 0; i < c; i++) {
    const u = s[i];
    if (u !== 0) {
      if (r = n[n.length - 1], s[r] < u) {
        e[i] = r, n.push(i);
        continue;
      }
      for (o = 0, a = n.length - 1; o < a; )
        l = o + a >> 1, s[n[l]] < u ? o = l + 1 : a = l;
      u < s[n[o]] && (o > 0 && (e[i] = n[o - 1]), n[o] = i);
    }
  }
  for (o = n.length, a = n[o - 1]; o-- > 0; )
    n[o] = a, a = e[a];
  return n;
}
function t0(s) {
  const e = s.subTree.component;
  if (e)
    return e.asyncDep && !e.asyncResolved ? e : t0(e);
}
function bp(s) {
  if (s)
    for (let e = 0; e < s.length; e++)
      s[e].flags |= 8;
}
const n0 = (s) => s.__isSuspense;
function E_(s, e) {
  e && e.pendingBranch ? yt(s) ? e.effects.push(...s) : e.effects.push(s) : I1(s);
}
const Ze = Symbol.for("v-fgt"), cu = Symbol.for("v-txt"), Ps = Symbol.for("v-cmt"), _c = Symbol.for("v-stc"), ka = [];
let _i = null;
function re(s = !1) {
  ka.push(_i = s ? null : []);
}
function T_() {
  ka.pop(), _i = ka[ka.length - 1] || null;
}
let Ya = 1;
function zc(s, e = !1) {
  Ya += s, s < 0 && _i && e && (_i.hasOnce = !0);
}
function i0(s) {
  return s.dynamicChildren = Ya > 0 ? _i || wo : null, T_(), Ya > 0 && _i && _i.push(s), s;
}
function ae(s, e, n, i, r, o) {
  return i0(
    f(
      s,
      e,
      n,
      i,
      r,
      o,
      !0
    )
  );
}
function St(s, e, n, i, r) {
  return i0(
    Ne(
      s,
      e,
      n,
      i,
      r,
      !0
    )
  );
}
function qa(s) {
  return s ? s.__v_isVNode === !0 : !1;
}
function ia(s, e) {
  return s.type === e.type && s.key === e.key;
}
const s0 = ({ key: s }) => s ?? null, xc = ({
  ref: s,
  ref_key: e,
  ref_for: n
}) => (typeof s == "number" && (s = "" + s), s != null ? gn(s) || vn(s) || Ct(s) ? { i: kn, r: s, k: e, f: !!n } : s : null);
function f(s, e = null, n = null, i = 0, r = null, o = s === Ze ? 0 : 1, a = !1, l = !1) {
  const c = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s,
    props: e,
    key: e && s0(e),
    ref: e && xc(e),
    scopeId: Rg,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: i,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
    ctx: kn
  };
  return l ? (uf(c, n), o & 128 && s.normalize(c)) : n && (c.shapeFlag |= gn(n) ? 8 : 16), Ya > 0 && // avoid a block node from tracking itself
  !a && // has current parent block
  _i && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (c.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  c.patchFlag !== 32 && _i.push(c), c;
}
const Ne = A_;
function A_(s, e = null, n = null, i = 0, r = null, o = !1) {
  if ((!s || s === zg) && (s = Ps), qa(s)) {
    const l = Do(
      s,
      e,
      !0
      /* mergeRef: true */
    );
    return n && uf(l, n), Ya > 0 && !o && _i && (l.shapeFlag & 6 ? _i[_i.indexOf(s)] = l : _i.push(l)), l.patchFlag = -2, l;
  }
  if (z_(s) && (s = s.__vccOpts), e) {
    e = P_(e);
    let { class: l, style: c } = e;
    l && !gn(l) && (e.class = Ue(l)), en(c) && (ru(c) && !yt(c) && (c = Xn({}, c)), e.style = bt(c));
  }
  const a = gn(s) ? 1 : n0(s) ? 128 : k1(s) ? 64 : en(s) ? 4 : Ct(s) ? 2 : 0;
  return f(
    s,
    e,
    n,
    i,
    r,
    a,
    o,
    !0
  );
}
function P_(s) {
  return s ? ru(s) || qg(s) ? Xn({}, s) : s : null;
}
function Do(s, e, n = !1, i = !1) {
  const { props: r, ref: o, patchFlag: a, children: l, transition: c } = s, u = e ? D_(r || {}, e) : r, d = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: s.type,
    props: u,
    key: u && s0(u),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && o ? yt(o) ? o.concat(xc(e)) : [o, xc(e)] : xc(e)
    ) : o,
    scopeId: s.scopeId,
    slotScopeIds: s.slotScopeIds,
    children: l,
    target: s.target,
    targetStart: s.targetStart,
    targetAnchor: s.targetAnchor,
    staticCount: s.staticCount,
    shapeFlag: s.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && s.type !== Ze ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: s.dynamicProps,
    dynamicChildren: s.dynamicChildren,
    appContext: s.appContext,
    dirs: s.dirs,
    transition: c,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: s.component,
    suspense: s.suspense,
    ssContent: s.ssContent && Do(s.ssContent),
    ssFallback: s.ssFallback && Do(s.ssFallback),
    placeholder: s.placeholder,
    el: s.el,
    anchor: s.anchor,
    ctx: s.ctx,
    ce: s.ce
  };
  return c && i && rf(
    d,
    c.clone(d)
  ), d;
}
function ft(s = " ", e = 0) {
  return Ne(cu, null, s, e);
}
function Or(s, e) {
  const n = Ne(_c, null, s);
  return n.staticCount = e, n;
}
function Pe(s = "", e = !1) {
  return e ? (re(), St(Ps, null, s)) : Ne(Ps, null, s);
}
function Ji(s) {
  return s == null || typeof s == "boolean" ? Ne(Ps) : yt(s) ? Ne(
    Ze,
    null,
    // #3666, avoid reference pollution when reusing vnode
    s.slice()
  ) : qa(s) ? qs(s) : Ne(cu, null, String(s));
}
function qs(s) {
  return s.el === null && s.patchFlag !== -1 || s.memo ? s : Do(s);
}
function uf(s, e) {
  let n = 0;
  const { shapeFlag: i } = s;
  if (e == null)
    e = null;
  else if (yt(e))
    n = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const r = e.default;
      r && (r._c && (r._d = !1), uf(s, r()), r._c && (r._d = !0));
      return;
    } else {
      n = 32;
      const r = e._;
      !r && !qg(e) ? e._ctx = kn : r === 3 && kn && (kn.slots._ === 1 ? e._ = 1 : (e._ = 2, s.patchFlag |= 1024));
    }
  else Ct(e) ? (e = { default: e, _ctx: kn }, n = 32) : (e = String(e), i & 64 ? (n = 16, e = [ft(e)]) : n = 8);
  s.children = e, s.shapeFlag |= n;
}
function D_(...s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = s[n];
    for (const r in i)
      if (r === "class")
        e.class !== i.class && (e.class = Ue([e.class, i.class]));
      else if (r === "style")
        e.style = bt([e.style, i.style]);
      else if (Jc(r)) {
        const o = e[r], a = i[r];
        a && o !== a && !(yt(o) && o.includes(a)) && (e[r] = o ? [].concat(o, a) : a);
      } else r !== "" && (e[r] = i[r]);
  }
  return e;
}
function ji(s, e, n, i = null) {
  ns(s, e, 7, [
    n,
    i
  ]);
}
const R_ = Hg();
let I_ = 0;
function k_(s, e, n) {
  const i = s.type, r = (e ? e.appContext : s.appContext) || R_, o = {
    uid: I_++,
    vnode: s,
    type: i,
    parent: e,
    appContext: r,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new lg(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(r.provides),
    ids: e ? e.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Kg(i, r),
    emitsOptions: Xg(i, r),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Qt,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: Qt,
    data: Qt,
    props: Qt,
    attrs: Qt,
    slots: Qt,
    refs: Qt,
    setupState: Qt,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = u_.bind(null, o), s.ce && s.ce(o), o;
}
let Wn = null;
const uu = () => Wn || kn;
let Nc, Yd;
{
  const s = iu(), e = (n, i) => {
    let r;
    return (r = s[n]) || (r = s[n] = []), r.push(i), (o) => {
      r.length > 1 ? r.forEach((a) => a(o)) : r[0](o);
    };
  };
  Nc = e(
    "__VUE_INSTANCE_SETTERS__",
    (n) => Wn = n
  ), Yd = e(
    "__VUE_SSR_SETTERS__",
    (n) => Za = n
  );
}
const fl = (s) => {
  const e = Wn;
  return Nc(s), s.scope.on(), () => {
    s.scope.off(), Nc(e);
  };
}, wp = () => {
  Wn && Wn.scope.off(), Nc(null);
};
function r0(s) {
  return s.vnode.shapeFlag & 4;
}
let Za = !1;
function L_(s, e = !1, n = !1) {
  e && Yd(e);
  const { props: i, children: r } = s.vnode, o = r0(s);
  v_(s, i, o, e), x_(s, r, n || e);
  const a = o ? F_(s, e) : void 0;
  return e && Yd(!1), a;
}
function F_(s, e) {
  const n = s.type;
  s.accessCache = /* @__PURE__ */ Object.create(null), s.proxy = new Proxy(s.ctx, q1);
  const { setup: i } = n;
  if (i) {
    Es();
    const r = s.setupContext = i.length > 1 ? a0(s) : null, o = fl(s), a = hl(
      i,
      s,
      0,
      [
        s.props,
        r
      ]
    ), l = tg(a);
    if (Ts(), o(), (l || s.sp) && !Co(s) && Fg(s), l) {
      if (a.then(wp, wp), e)
        return a.then((c) => {
          Sp(s, c);
        }).catch((c) => {
          ou(c, s, 0);
        });
      s.asyncDep = a;
    } else
      Sp(s, a);
  } else
    o0(s);
}
function Sp(s, e, n) {
  Ct(e) ? s.type.__ssrInlineRender ? s.ssrRender = e : s.render = e : en(e) && (s.setupState = Eg(e)), o0(s);
}
function o0(s, e, n) {
  const i = s.type;
  s.render || (s.render = i.render || es);
  {
    const r = fl(s);
    Es();
    try {
      J1(s);
    } finally {
      Ts(), r();
    }
  }
}
const U_ = {
  get(s, e) {
    return Hn(s, "get", ""), s[e];
  }
};
function a0(s) {
  const e = (n) => {
    s.exposed = n || {};
  };
  return {
    attrs: new Proxy(s.attrs, U_),
    slots: s.slots,
    emit: s.emit,
    expose: e
  };
}
function du(s) {
  return s.exposed ? s.exposeProxy || (s.exposeProxy = new Proxy(Eg(ys(s.exposed)), {
    get(e, n) {
      if (n in e)
        return e[n];
      if (n in Ia)
        return Ia[n](s);
    },
    has(e, n) {
      return n in e || n in Ia;
    }
  })) : s.proxy;
}
function O_(s, e = !0) {
  return Ct(s) ? s.displayName || s.name : s.name || e && s.__name;
}
function z_(s) {
  return Ct(s) && "__vccOpts" in s;
}
const Oe = (s, e) => T1(s, e, Za);
function N_(s, e, n) {
  try {
    zc(-1);
    const i = arguments.length;
    return i === 2 ? en(e) && !yt(e) ? qa(e) ? Ne(s, null, [e]) : Ne(s, e) : Ne(s, null, e) : (i > 3 ? n = Array.prototype.slice.call(arguments, 2) : i === 3 && qa(n) && (n = [n]), Ne(s, e, n));
  } finally {
    zc(1);
  }
}
const B_ = "3.5.25";
/**
* @vue/runtime-dom v3.5.25
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let qd;
const Mp = typeof window < "u" && window.trustedTypes;
if (Mp)
  try {
    qd = /* @__PURE__ */ Mp.createPolicy("vue", {
      createHTML: (s) => s
    });
  } catch {
  }
const l0 = qd ? (s) => qd.createHTML(s) : (s) => s, V_ = "http://www.w3.org/2000/svg", G_ = "http://www.w3.org/1998/Math/MathML", gs = typeof document < "u" ? document : null, Cp = gs && /* @__PURE__ */ gs.createElement("template"), H_ = {
  insert: (s, e, n) => {
    e.insertBefore(s, n || null);
  },
  remove: (s) => {
    const e = s.parentNode;
    e && e.removeChild(s);
  },
  createElement: (s, e, n, i) => {
    const r = e === "svg" ? gs.createElementNS(V_, s) : e === "mathml" ? gs.createElementNS(G_, s) : n ? gs.createElement(s, { is: n }) : gs.createElement(s);
    return s === "select" && i && i.multiple != null && r.setAttribute("multiple", i.multiple), r;
  },
  createText: (s) => gs.createTextNode(s),
  createComment: (s) => gs.createComment(s),
  setText: (s, e) => {
    s.nodeValue = e;
  },
  setElementText: (s, e) => {
    s.textContent = e;
  },
  parentNode: (s) => s.parentNode,
  nextSibling: (s) => s.nextSibling,
  querySelector: (s) => gs.querySelector(s),
  setScopeId(s, e) {
    s.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(s, e, n, i, r, o) {
    const a = n ? n.previousSibling : e.lastChild;
    if (r && (r === o || r.nextSibling))
      for (; e.insertBefore(r.cloneNode(!0), n), !(r === o || !(r = r.nextSibling)); )
        ;
    else {
      Cp.innerHTML = l0(
        i === "svg" ? `<svg>${s}</svg>` : i === "mathml" ? `<math>${s}</math>` : s
      );
      const l = Cp.content;
      if (i === "svg" || i === "mathml") {
        const c = l.firstChild;
        for (; c.firstChild; )
          l.appendChild(c.firstChild);
        l.removeChild(c);
      }
      e.insertBefore(l, n);
    }
    return [
      // first
      a ? a.nextSibling : e.firstChild,
      // last
      n ? n.previousSibling : e.lastChild
    ];
  }
}, W_ = Symbol("_vtc");
function $_(s, e, n) {
  const i = s[W_];
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? s.removeAttribute("class") : n ? s.setAttribute("class", e) : s.className = e;
}
const Bc = Symbol("_vod"), c0 = Symbol("_vsh"), lr = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(s, { value: e }, { transition: n }) {
    s[Bc] = s.style.display === "none" ? "" : s.style.display, n && e ? n.beforeEnter(s) : sa(s, e);
  },
  mounted(s, { value: e }, { transition: n }) {
    n && e && n.enter(s);
  },
  updated(s, { value: e, oldValue: n }, { transition: i }) {
    !e != !n && (i ? e ? (i.beforeEnter(s), sa(s, !0), i.enter(s)) : i.leave(s, () => {
      sa(s, !1);
    }) : sa(s, e));
  },
  beforeUnmount(s, { value: e }) {
    sa(s, e);
  }
};
function sa(s, e) {
  s.style.display = e ? s[Bc] : "none", s[c0] = !e;
}
const X_ = Symbol(""), j_ = /(?:^|;)\s*display\s*:/;
function Y_(s, e, n) {
  const i = s.style, r = gn(n);
  let o = !1;
  if (n && !r) {
    if (e)
      if (gn(e))
        for (const a of e.split(";")) {
          const l = a.slice(0, a.indexOf(":")).trim();
          n[l] == null && bc(i, l, "");
        }
      else
        for (const a in e)
          n[a] == null && bc(i, a, "");
    for (const a in n)
      a === "display" && (o = !0), bc(i, a, n[a]);
  } else if (r) {
    if (e !== n) {
      const a = i[X_];
      a && (n += ";" + a), i.cssText = n, o = j_.test(n);
    }
  } else e && s.removeAttribute("style");
  Bc in s && (s[Bc] = o ? i.display : "", s[c0] && (i.display = "none"));
}
const Ep = /\s*!important$/;
function bc(s, e, n) {
  if (yt(n))
    n.forEach((i) => bc(s, e, i));
  else if (n == null && (n = ""), e.startsWith("--"))
    s.setProperty(e, n);
  else {
    const i = q_(s, e);
    Ep.test(n) ? s.setProperty(
      ir(i),
      n.replace(Ep, ""),
      "important"
    ) : s[i] = n;
  }
}
const Tp = ["Webkit", "Moz", "ms"], Bu = {};
function q_(s, e) {
  const n = Bu[e];
  if (n)
    return n;
  let i = Ai(e);
  if (i !== "filter" && i in s)
    return Bu[e] = i;
  i = tu(i);
  for (let r = 0; r < Tp.length; r++) {
    const o = Tp[r] + i;
    if (o in s)
      return Bu[e] = o;
  }
  return e;
}
const Ap = "http://www.w3.org/1999/xlink";
function Pp(s, e, n, i, r, o = Ky(e)) {
  i && e.startsWith("xlink:") ? n == null ? s.removeAttributeNS(Ap, e.slice(6, e.length)) : s.setAttributeNS(Ap, e, n) : n == null || o && !rg(n) ? s.removeAttribute(e) : s.setAttribute(
    e,
    o ? "" : Vi(n) ? String(n) : n
  );
}
function Dp(s, e, n, i, r) {
  if (e === "innerHTML" || e === "textContent") {
    n != null && (s[e] = e === "innerHTML" ? l0(n) : n);
    return;
  }
  const o = s.tagName;
  if (e === "value" && o !== "PROGRESS" && // custom elements may use _value internally
  !o.includes("-")) {
    const l = o === "OPTION" ? s.getAttribute("value") || "" : s.value, c = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      s.type === "checkbox" ? "on" : ""
    ) : String(n);
    (l !== c || !("_value" in s)) && (s.value = c), n == null && s.removeAttribute(e), s._value = n;
    return;
  }
  let a = !1;
  if (n === "" || n == null) {
    const l = typeof s[e];
    l === "boolean" ? n = rg(n) : n == null && l === "string" ? (n = "", a = !0) : l === "number" && (n = 0, a = !0);
  }
  try {
    s[e] = n;
  } catch {
  }
  a && s.removeAttribute(r || e);
}
function Zs(s, e, n, i) {
  s.addEventListener(e, n, i);
}
function Z_(s, e, n, i) {
  s.removeEventListener(e, n, i);
}
const Rp = Symbol("_vei");
function K_(s, e, n, i, r = null) {
  const o = s[Rp] || (s[Rp] = {}), a = o[e];
  if (i && a)
    a.value = i;
  else {
    const [l, c] = J_(e);
    if (i) {
      const u = o[e] = tx(
        i,
        r
      );
      Zs(s, l, u, c);
    } else a && (Z_(s, l, a, c), o[e] = void 0);
  }
}
const Ip = /(?:Once|Passive|Capture)$/;
function J_(s) {
  let e;
  if (Ip.test(s)) {
    e = {};
    let i;
    for (; i = s.match(Ip); )
      s = s.slice(0, s.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [s[2] === ":" ? s.slice(3) : ir(s.slice(2)), e];
}
let Vu = 0;
const Q_ = /* @__PURE__ */ Promise.resolve(), ex = () => Vu || (Q_.then(() => Vu = 0), Vu = Date.now());
function tx(s, e) {
  const n = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= n.attached)
      return;
    ns(
      nx(i, n.value),
      e,
      5,
      [i]
    );
  };
  return n.value = s, n.attached = ex(), n;
}
function nx(s, e) {
  if (yt(e)) {
    const n = s.stopImmediatePropagation;
    return s.stopImmediatePropagation = () => {
      n.call(s), s._stopped = !0;
    }, e.map(
      (i) => (r) => !r._stopped && i && i(r)
    );
  } else
    return e;
}
const kp = (s) => s.charCodeAt(0) === 111 && s.charCodeAt(1) === 110 && // lowercase letter
s.charCodeAt(2) > 96 && s.charCodeAt(2) < 123, ix = (s, e, n, i, r, o) => {
  const a = r === "svg";
  e === "class" ? $_(s, i, a) : e === "style" ? Y_(s, n, i) : Jc(e) ? Yh(e) || K_(s, e, n, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : sx(s, e, i, a)) ? (Dp(s, e, i), !s.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && Pp(s, e, i, a, o, e !== "value")) : /* #11081 force set props for possible async custom element */ s._isVueCE && (/[A-Z]/.test(e) || !gn(i)) ? Dp(s, Ai(e), i, o, e) : (e === "true-value" ? s._trueValue = i : e === "false-value" && (s._falseValue = i), Pp(s, e, i, a));
};
function sx(s, e, n, i) {
  if (i)
    return !!(e === "innerHTML" || e === "textContent" || e in s && kp(e) && Ct(n));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "sandbox" && s.tagName === "IFRAME" || e === "form" || e === "list" && s.tagName === "INPUT" || e === "type" && s.tagName === "TEXTAREA")
    return !1;
  if (e === "width" || e === "height") {
    const r = s.tagName;
    if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE")
      return !1;
  }
  return kp(e) && gn(n) ? !1 : e in s;
}
const Ro = (s) => {
  const e = s.props["onUpdate:modelValue"] || !1;
  return yt(e) ? (n) => gc(e, n) : e;
};
function rx(s) {
  s.target.composing = !0;
}
function Lp(s) {
  const e = s.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const Ss = Symbol("_assign");
function Fp(s, e, n) {
  return e && (s = s.trim()), n && (s = nu(s)), s;
}
const $t = {
  created(s, { modifiers: { lazy: e, trim: n, number: i } }, r) {
    s[Ss] = Ro(r);
    const o = i || r.props && r.props.type === "number";
    Zs(s, e ? "change" : "input", (a) => {
      a.target.composing || s[Ss](Fp(s.value, n, o));
    }), (n || o) && Zs(s, "change", () => {
      s.value = Fp(s.value, n, o);
    }), e || (Zs(s, "compositionstart", rx), Zs(s, "compositionend", Lp), Zs(s, "change", Lp));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(s, { value: e }) {
    s.value = e ?? "";
  },
  beforeUpdate(s, { value: e, oldValue: n, modifiers: { lazy: i, trim: r, number: o } }, a) {
    if (s[Ss] = Ro(a), s.composing) return;
    const l = (o || s.type === "number") && !/^0\d/.test(s.value) ? nu(s.value) : s.value, c = e ?? "";
    l !== c && (document.activeElement === s && s.type !== "range" && (i && e === n || r && s.value.trim() === c) || (s.value = c));
  }
}, Ci = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(s, e, n) {
    s[Ss] = Ro(n), Zs(s, "change", () => {
      const i = s._modelValue, r = Ka(s), o = s.checked, a = s[Ss];
      if (yt(i)) {
        const l = Zh(i, r), c = l !== -1;
        if (o && !c)
          a(i.concat(r));
        else if (!o && c) {
          const u = [...i];
          u.splice(l, 1), a(u);
        }
      } else if (Vo(i)) {
        const l = new Set(i);
        o ? l.add(r) : l.delete(r), a(l);
      } else
        a(u0(s, o));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Up,
  beforeUpdate(s, e, n) {
    s[Ss] = Ro(n), Up(s, e, n);
  }
};
function Up(s, { value: e, oldValue: n }, i) {
  s._modelValue = e;
  let r;
  if (yt(e))
    r = Zh(e, i.props.value) > -1;
  else if (Vo(e))
    r = e.has(i.props.value);
  else {
    if (e === n) return;
    r = dl(e, u0(s, !0));
  }
  s.checked !== r && (s.checked = r);
}
const ti = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(s, { value: e, modifiers: { number: n } }, i) {
    const r = Vo(e);
    Zs(s, "change", () => {
      const o = Array.prototype.filter.call(s.options, (a) => a.selected).map(
        (a) => n ? nu(Ka(a)) : Ka(a)
      );
      s[Ss](
        s.multiple ? r ? new Set(o) : o : o[0]
      ), s._assigning = !0, Ti(() => {
        s._assigning = !1;
      });
    }), s[Ss] = Ro(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(s, { value: e }) {
    Op(s, e);
  },
  beforeUpdate(s, e, n) {
    s[Ss] = Ro(n);
  },
  updated(s, { value: e }) {
    s._assigning || Op(s, e);
  }
};
function Op(s, e) {
  const n = s.multiple, i = yt(e);
  if (!(n && !i && !Vo(e))) {
    for (let r = 0, o = s.options.length; r < o; r++) {
      const a = s.options[r], l = Ka(a);
      if (n)
        if (i) {
          const c = typeof l;
          c === "string" || c === "number" ? a.selected = e.some((u) => String(u) === String(l)) : a.selected = Zh(e, l) > -1;
        } else
          a.selected = e.has(l);
      else if (dl(Ka(a), e)) {
        s.selectedIndex !== r && (s.selectedIndex = r);
        return;
      }
    }
    !n && s.selectedIndex !== -1 && (s.selectedIndex = -1);
  }
}
function Ka(s) {
  return "_value" in s ? s._value : s.value;
}
function u0(s, e) {
  const n = e ? "_trueValue" : "_falseValue";
  return n in s ? s[n] : e;
}
const ox = ["ctrl", "shift", "alt", "meta"], ax = {
  stop: (s) => s.stopPropagation(),
  prevent: (s) => s.preventDefault(),
  self: (s) => s.target !== s.currentTarget,
  ctrl: (s) => !s.ctrlKey,
  shift: (s) => !s.shiftKey,
  alt: (s) => !s.altKey,
  meta: (s) => !s.metaKey,
  left: (s) => "button" in s && s.button !== 0,
  middle: (s) => "button" in s && s.button !== 1,
  right: (s) => "button" in s && s.button !== 2,
  exact: (s, e) => ox.some((n) => s[`${n}Key`] && !e.includes(n))
}, wt = (s, e) => {
  const n = s._withMods || (s._withMods = {}), i = e.join(".");
  return n[i] || (n[i] = (r, ...o) => {
    for (let a = 0; a < e.length; a++) {
      const l = ax[e[a]];
      if (l && l(r, e)) return;
    }
    return s(r, ...o);
  });
}, lx = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Ja = (s, e) => {
  const n = s._withKeys || (s._withKeys = {}), i = e.join(".");
  return n[i] || (n[i] = (r) => {
    if (!("key" in r))
      return;
    const o = ir(r.key);
    if (e.some(
      (a) => a === o || lx[a] === o
    ))
      return s(r);
  });
}, cx = /* @__PURE__ */ Xn({ patchProp: ix }, H_);
let zp;
function ux() {
  return zp || (zp = w_(cx));
}
const dx = (...s) => {
  const e = ux().createApp(...s), { mount: n } = e;
  return e.mount = (i) => {
    const r = fx(i);
    if (!r) return;
    const o = e._component;
    !Ct(o) && !o.render && !o.template && (o.template = r.innerHTML), r.nodeType === 1 && (r.textContent = "");
    const a = n(r, !1, hx(r));
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), a;
  }, e;
};
function hx(s) {
  if (s instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && s instanceof MathMLElement)
    return "mathml";
}
function fx(s) {
  return gn(s) ? document.querySelector(s) : s;
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let d0;
const hu = (s) => d0 = s, h0 = (
  /* istanbul ignore next */
  Symbol()
);
function Zd(s) {
  return s && typeof s == "object" && Object.prototype.toString.call(s) === "[object Object]" && typeof s.toJSON != "function";
}
var La;
(function(s) {
  s.direct = "direct", s.patchObject = "patch object", s.patchFunction = "patch function";
})(La || (La = {}));
function px() {
  const s = cg(!0), e = s.run(() => Se({}));
  let n = [], i = [];
  const r = ys({
    install(o) {
      hu(r), r._a = o, o.provide(h0, r), o.config.globalProperties.$pinia = r, i.forEach((a) => n.push(a)), i = [];
    },
    use(o) {
      return this._a ? n.push(o) : i.push(o), this;
    },
    _p: n,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: s,
    _s: /* @__PURE__ */ new Map(),
    state: e
  });
  return r;
}
const f0 = () => {
};
function Np(s, e, n, i = f0) {
  s.push(e);
  const r = () => {
    const o = s.indexOf(e);
    o > -1 && (s.splice(o, 1), i());
  };
  return !n && ug() && Qy(r), r;
}
function Xr(s, ...e) {
  s.slice().forEach((n) => {
    n(...e);
  });
}
const mx = (s) => s(), Bp = Symbol(), Gu = Symbol();
function Kd(s, e) {
  s instanceof Map && e instanceof Map ? e.forEach((n, i) => s.set(i, n)) : s instanceof Set && e instanceof Set && e.forEach(s.add, s);
  for (const n in e) {
    if (!e.hasOwnProperty(n))
      continue;
    const i = e[n], r = s[n];
    Zd(r) && Zd(i) && s.hasOwnProperty(n) && !vn(i) && !ws(i) ? s[n] = Kd(r, i) : s[n] = i;
  }
  return s;
}
const vx = (
  /* istanbul ignore next */
  Symbol()
);
function gx(s) {
  return !Zd(s) || !s.hasOwnProperty(vx);
}
const { assign: Xs } = Object;
function yx(s) {
  return !!(vn(s) && s.effect);
}
function _x(s, e, n, i) {
  const { state: r, actions: o, getters: a } = e, l = n.state.value[s];
  let c;
  function u() {
    l || (n.state.value[s] = r ? r() : {});
    const d = S1(n.state.value[s]);
    return Xs(d, o, Object.keys(a || {}).reduce((h, m) => (h[m] = ys(Oe(() => {
      hu(n);
      const p = n._s.get(s);
      return a[m].call(p, p);
    })), h), {}));
  }
  return c = p0(s, u, e, n, i, !0), c;
}
function p0(s, e, n = {}, i, r, o) {
  let a;
  const l = Xs({ actions: {} }, n), c = { deep: !0 };
  let u, d, h = [], m = [], p;
  const y = i.state.value[s];
  !o && !y && (i.state.value[s] = {}), Se({});
  let _;
  function v(T) {
    let b;
    u = d = !1, typeof T == "function" ? (T(i.state.value[s]), b = {
      type: La.patchFunction,
      storeId: s,
      events: p
    }) : (Kd(i.state.value[s], T), b = {
      type: La.patchObject,
      payload: T,
      storeId: s,
      events: p
    });
    const M = _ = Symbol();
    Ti().then(() => {
      _ === M && (u = !0);
    }), d = !0, Xr(h, b, i.state.value[s]);
  }
  const g = o ? function() {
    const { state: b } = n, M = b ? b() : {};
    this.$patch((L) => {
      Xs(L, M);
    });
  } : (
    /* istanbul ignore next */
    f0
  );
  function S() {
    a.stop(), h = [], m = [], i._s.delete(s);
  }
  const w = (T, b = "") => {
    if (Bp in T)
      return T[Gu] = b, T;
    const M = function() {
      hu(i);
      const L = Array.from(arguments), N = [], D = [];
      function O(he) {
        N.push(he);
      }
      function A(he) {
        D.push(he);
      }
      Xr(m, {
        args: L,
        name: M[Gu],
        store: C,
        after: O,
        onError: A
      });
      let G;
      try {
        G = T.apply(this && this.$id === s ? this : C, L);
      } catch (he) {
        throw Xr(D, he), he;
      }
      return G instanceof Promise ? G.then((he) => (Xr(N, he), he)).catch((he) => (Xr(D, he), Promise.reject(he))) : (Xr(N, G), G);
    };
    return M[Bp] = !0, M[Gu] = b, M;
  }, x = {
    _p: i,
    // _s: scope,
    $id: s,
    $onAction: Np.bind(null, m),
    $patch: v,
    $reset: g,
    $subscribe(T, b = {}) {
      const M = Np(h, T, b.detached, () => L()), L = a.run(() => Ft(() => i.state.value[s], (N) => {
        (b.flush === "sync" ? d : u) && T({
          storeId: s,
          type: La.direct,
          events: p
        }, N);
      }, Xs({}, c, b)));
      return M;
    },
    $dispose: S
  }, C = Go(x);
  i._s.set(s, C);
  const P = (i._a && i._a.runWithContext || mx)(() => i._e.run(() => (a = cg()).run(() => e({ action: w }))));
  for (const T in P) {
    const b = P[T];
    if (vn(b) && !yx(b) || ws(b))
      o || (y && gx(b) && (vn(b) ? b.value = y[T] : Kd(b, y[T])), i.state.value[s][T] = b);
    else if (typeof b == "function") {
      const M = w(b, T);
      P[T] = M, l.actions[T] = b;
    }
  }
  return Xs(C, P), Xs(zt(C), P), Object.defineProperty(C, "$state", {
    get: () => i.state.value[s],
    set: (T) => {
      v((b) => {
        Xs(b, T);
      });
    }
  }), i._p.forEach((T) => {
    Xs(C, a.run(() => T({
      store: C,
      app: i._a,
      pinia: i,
      options: l
    })));
  }), y && o && n.hydrate && n.hydrate(C.$state, y), u = !0, d = !0, C;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function xx(s, e, n) {
  let i, r;
  const o = typeof e == "function";
  i = s, r = o ? n : e;
  function a(l, c) {
    const u = r_();
    return l = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    l || (u ? Ui(h0, null) : null), l && hu(l), l = d0, l._s.has(i) || (o ? p0(i, e, r, l) : _x(i, r, l)), l._s.get(i);
  }
  return a.$id = i, a;
}
const Hu = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: !1 },
    pushOtherPanes: { type: Boolean, default: !0 },
    maximizePanes: { type: Boolean, default: !0 },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: !1 }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(s, { emit: e }) {
    const n = e, i = s, r = Z1(), o = Se([]), a = Oe(() => o.value.reduce((H, X) => (H[~~X.id] = X) && H, {})), l = Oe(() => o.value.length), c = Se(null), u = Se(!1), d = Se({
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), h = Se({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), m = Oe(() => ({
      [`splitpanes splitpanes--${i.horizontal ? "horizontal" : "vertical"}`]: !0,
      "splitpanes--dragging": d.value.dragging
    })), p = () => {
      document.addEventListener("mousemove", v, { passive: !1 }), document.addEventListener("mouseup", g), "ontouchstart" in window && (document.addEventListener("touchmove", v, { passive: !1 }), document.addEventListener("touchend", g));
    }, y = () => {
      document.removeEventListener("mousemove", v, { passive: !1 }), document.removeEventListener("mouseup", g), "ontouchstart" in window && (document.removeEventListener("touchmove", v, { passive: !1 }), document.removeEventListener("touchend", g));
    }, _ = (H, X) => {
      const V = H.target.closest(".splitpanes__splitter");
      if (V) {
        const { left: I, top: F } = V.getBoundingClientRect(), { clientX: k, clientY: Q } = "ontouchstart" in window && H.touches ? H.touches[0] : H;
        d.value.cursorOffset = i.horizontal ? Q - F : k - I;
      }
      p(), d.value.mouseDown = !0, d.value.activeSplitter = X;
    }, v = (H) => {
      d.value.mouseDown && (H.preventDefault(), d.value.dragging = !0, requestAnimationFrame(() => {
        P(C(H)), ne("resize", { event: H }, !0);
      }));
    }, g = (H) => {
      d.value.dragging && (window.getSelection().removeAllRanges(), ne("resized", { event: H }, !0)), d.value.mouseDown = !1, d.value.activeSplitter = null, setTimeout(() => {
        d.value.dragging = !1, y();
      }, 100);
    }, S = (H, X) => {
      "ontouchstart" in window && (H.preventDefault(), h.value.splitter === X ? (clearTimeout(h.value.timeoutId), h.value.timeoutId = null, w(H, X), h.value.splitter = null) : (h.value.splitter = X, h.value.timeoutId = setTimeout(() => h.value.splitter = null, 500))), d.value.dragging || ne("splitter-click", { event: H, index: X }, !0);
    }, w = (H, X) => {
      if (ne("splitter-dblclick", { event: H, index: X }, !0), i.maximizePanes) {
        let V = 0;
        o.value = o.value.map((I, F) => (I.size = F === X ? I.max : I.min, F !== X && (V += I.min), I)), o.value[X].size -= V, ne("pane-maximize", { event: H, index: X, pane: o.value[X] }), ne("resized", { event: H, index: X }, !0);
      }
    }, x = (H, X) => {
      ne("pane-click", {
        event: H,
        index: a.value[X].index,
        pane: a.value[X]
      });
    }, C = (H) => {
      const X = c.value.getBoundingClientRect(), { clientX: V, clientY: I } = "ontouchstart" in window && H.touches ? H.touches[0] : H;
      return {
        x: V - (i.horizontal ? 0 : d.value.cursorOffset) - X.left,
        y: I - (i.horizontal ? d.value.cursorOffset : 0) - X.top
      };
    }, E = (H) => {
      H = H[i.horizontal ? "y" : "x"];
      const X = c.value[i.horizontal ? "clientHeight" : "clientWidth"];
      return i.rtl && !i.horizontal && (H = X - H), H * 100 / X;
    }, P = (H) => {
      const X = d.value.activeSplitter;
      let V = {
        prevPanesSize: b(X),
        nextPanesSize: M(X),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const I = 0 + (i.pushOtherPanes ? 0 : V.prevPanesSize), F = 100 - (i.pushOtherPanes ? 0 : V.nextPanesSize), k = Math.max(Math.min(E(H), F), I);
      let Q = [X, X + 1], Z = o.value[Q[0]] || null, R = o.value[Q[1]] || null;
      const ie = Z.max < 100 && k >= Z.max + V.prevPanesSize, J = R.max < 100 && k <= 100 - (R.max + M(X + 1));
      if (ie || J) {
        ie ? (Z.size = Z.max, R.size = Math.max(100 - Z.max - V.prevPanesSize - V.nextPanesSize, 0)) : (Z.size = Math.max(100 - R.max - V.prevPanesSize - M(X + 1), 0), R.size = R.max);
        return;
      }
      if (i.pushOtherPanes) {
        const B = T(V, k);
        if (!B) return;
        ({ sums: V, panesToResize: Q } = B), Z = o.value[Q[0]] || null, R = o.value[Q[1]] || null;
      }
      Z !== null && (Z.size = Math.min(Math.max(k - V.prevPanesSize - V.prevReachedMinPanes, Z.min), Z.max)), R !== null && (R.size = Math.min(Math.max(100 - k - V.nextPanesSize - V.nextReachedMinPanes, R.min), R.max));
    }, T = (H, X) => {
      const V = d.value.activeSplitter, I = [V, V + 1];
      return X < H.prevPanesSize + o.value[I[0]].min && (I[0] = L(V).index, H.prevReachedMinPanes = 0, I[0] < V && o.value.forEach((F, k) => {
        k > I[0] && k <= V && (F.size = F.min, H.prevReachedMinPanes += F.min);
      }), H.prevPanesSize = b(I[0]), I[0] === void 0) ? (H.prevReachedMinPanes = 0, o.value[0].size = o.value[0].min, o.value.forEach((F, k) => {
        k > 0 && k <= V && (F.size = F.min, H.prevReachedMinPanes += F.min);
      }), o.value[I[1]].size = 100 - H.prevReachedMinPanes - o.value[0].min - H.prevPanesSize - H.nextPanesSize, null) : X > 100 - H.nextPanesSize - o.value[I[1]].min && (I[1] = N(V).index, H.nextReachedMinPanes = 0, I[1] > V + 1 && o.value.forEach((F, k) => {
        k > V && k < I[1] && (F.size = F.min, H.nextReachedMinPanes += F.min);
      }), H.nextPanesSize = M(I[1] - 1), I[1] === void 0) ? (H.nextReachedMinPanes = 0, o.value.forEach((F, k) => {
        k < l.value - 1 && k >= V + 1 && (F.size = F.min, H.nextReachedMinPanes += F.min);
      }), o.value[I[0]].size = 100 - H.prevPanesSize - M(I[0] - 1), null) : { sums: H, panesToResize: I };
    }, b = (H) => o.value.reduce((X, V, I) => X + (I < H ? V.size : 0), 0), M = (H) => o.value.reduce((X, V, I) => X + (I > H + 1 ? V.size : 0), 0), L = (H) => [...o.value].reverse().find((X) => X.index < H && X.size > X.min) || {}, N = (H) => o.value.find((X) => X.index > H + 1 && X.size > X.min) || {}, D = () => {
      var H;
      const X = Array.from(((H = c.value) == null ? void 0 : H.children) || []);
      for (const V of X) {
        const I = V.classList.contains("splitpanes__pane"), F = V.classList.contains("splitpanes__splitter");
        !I && !F && (V.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, O = (H, X, V = !1) => {
      const I = H - 1, F = document.createElement("div");
      F.classList.add("splitpanes__splitter"), V || (F.onmousedown = (k) => _(k, I), typeof window < "u" && "ontouchstart" in window && (F.ontouchstart = (k) => _(k, I)), F.onclick = (k) => S(k, I + 1)), F.ondblclick = (k) => w(k, I + 1), X.parentNode.insertBefore(F, X);
    }, A = (H) => {
      H.onmousedown = void 0, H.onclick = void 0, H.ondblclick = void 0, H.remove();
    }, G = () => {
      var H;
      const X = Array.from(((H = c.value) == null ? void 0 : H.children) || []);
      for (const I of X)
        I.className.includes("splitpanes__splitter") && A(I);
      let V = 0;
      for (const I of X)
        I.className.includes("splitpanes__pane") && (!V && i.firstSplitter ? O(V, I, !0) : V && O(V, I), V++);
    }, he = ({ uid: H, ...X }) => {
      const V = a.value[H];
      for (const [I, F] of Object.entries(X)) V[I] = F;
    }, ee = (H) => {
      var X;
      let V = -1;
      Array.from(((X = c.value) == null ? void 0 : X.children) || []).some((I) => (I.className.includes("splitpanes__pane") && V++, I.isSameNode(H.el))), o.value.splice(V, 0, { ...H, index: V }), o.value.forEach((I, F) => I.index = F), u.value && Ti(() => {
        G(), oe({ addedPane: o.value[V] }), ne("pane-add", { pane: o.value[V] });
      });
    }, le = (H) => {
      const X = o.value.findIndex((I) => I.id === H);
      o.value[X].el = null;
      const V = o.value.splice(X, 1)[0];
      o.value.forEach((I, F) => I.index = F), Ti(() => {
        G(), ne("pane-remove", { pane: V }), oe({ removedPane: { ...V } });
      });
    }, oe = (H = {}) => {
      !H.addedPane && !H.removedPane ? j() : o.value.some((X) => X.givenSize !== null || X.min || X.max < 100) ? q(H) : Y(), u.value && ne("resized");
    }, Y = () => {
      const H = 100 / l.value;
      let X = 0;
      const V = [], I = [];
      for (const F of o.value)
        F.size = Math.max(Math.min(H, F.max), F.min), X -= F.size, F.size >= F.max && V.push(F.id), F.size <= F.min && I.push(F.id);
      X > 0.1 && te(X, V, I);
    }, j = () => {
      let H = 100;
      const X = [], V = [];
      let I = 0;
      for (const k of o.value)
        H -= k.size, k.givenSize !== null && I++, k.size >= k.max && X.push(k.id), k.size <= k.min && V.push(k.id);
      let F = 100;
      if (H > 0.1) {
        for (const k of o.value)
          k.givenSize === null && (k.size = Math.max(Math.min(H / (l.value - I), k.max), k.min)), F -= k.size;
        F > 0.1 && te(F, X, V);
      }
    }, q = ({ addedPane: H, removedPane: X } = {}) => {
      let V = 100 / l.value, I = 0;
      const F = [], k = [];
      ((H == null ? void 0 : H.givenSize) ?? null) !== null && (V = (100 - H.givenSize) / (l.value - 1));
      for (const Q of o.value)
        I -= Q.size, Q.size >= Q.max && F.push(Q.id), Q.size <= Q.min && k.push(Q.id);
      if (!(Math.abs(I) < 0.1)) {
        for (const Q of o.value)
          (H == null ? void 0 : H.givenSize) !== null && (H == null ? void 0 : H.id) === Q.id || (Q.size = Math.max(Math.min(V, Q.max), Q.min)), I -= Q.size, Q.size >= Q.max && F.push(Q.id), Q.size <= Q.min && k.push(Q.id);
        I > 0.1 && te(I, F, k);
      }
    }, te = (H, X, V) => {
      let I;
      H > 0 ? I = H / (l.value - X.length) : I = H / (l.value - V.length), o.value.forEach((F, k) => {
        if (H > 0 && !X.includes(F.id)) {
          const Q = Math.max(Math.min(F.size + I, F.max), F.min), Z = Q - F.size;
          H -= Z, F.size = Q;
        } else if (!V.includes(F.id)) {
          const Q = Math.max(Math.min(F.size + I, F.max), F.min), Z = Q - F.size;
          H -= Z, F.size = Q;
        }
      }), Math.abs(H) > 0.1 && Ti(() => {
        u.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, ne = (H, X = void 0, V = !1) => {
      const I = (X == null ? void 0 : X.index) ?? d.value.activeSplitter ?? null;
      n(H, {
        ...X,
        ...I !== null && { index: I },
        ...V && I !== null && {
          prevPane: o.value[I - (i.firstSplitter ? 1 : 0)],
          nextPane: o.value[I + (i.firstSplitter ? 0 : 1)]
        },
        panes: o.value.map((F) => ({ min: F.min, max: F.max, size: F.size }))
      });
    };
    Ft(() => i.firstSplitter, () => G()), _n(() => {
      D(), G(), oe(), ne("ready"), u.value = !0;
    }), of(() => u.value = !1);
    const de = () => {
      var H;
      return N_(
        "div",
        { ref: c, class: m.value },
        (H = r.default) == null ? void 0 : H.call(r)
      );
    };
    return $s("panes", o), $s("indexedPanes", a), $s("horizontal", Oe(() => i.horizontal)), $s("requestUpdate", he), $s("onPaneAdd", ee), $s("onPaneRemove", le), $s("onPaneClick", x), (H, X) => (re(), St(Ng(de)));
  }
}, cr = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(s) {
    var e;
    const n = s, i = Ui("requestUpdate"), r = Ui("onPaneAdd"), o = Ui("horizontal"), a = Ui("onPaneRemove"), l = Ui("onPaneClick"), c = (e = uu()) == null ? void 0 : e.uid, u = Ui("indexedPanes"), d = Oe(() => u.value[c]), h = Se(null), m = Oe(() => {
      const v = isNaN(n.size) || n.size === void 0 ? 0 : parseFloat(n.size);
      return Math.max(Math.min(v, y.value), p.value);
    }), p = Oe(() => {
      const v = parseFloat(n.minSize);
      return isNaN(v) ? 0 : v;
    }), y = Oe(() => {
      const v = parseFloat(n.maxSize);
      return isNaN(v) ? 100 : v;
    }), _ = Oe(() => {
      var v;
      return `${o.value ? "height" : "width"}: ${(v = d.value) == null ? void 0 : v.size}%`;
    });
    return Ft(() => m.value, (v) => i({ uid: c, size: v })), Ft(() => p.value, (v) => i({ uid: c, min: v })), Ft(() => y.value, (v) => i({ uid: c, max: v })), _n(() => {
      r({
        id: c,
        el: h.value,
        min: p.value,
        max: y.value,
        // The given size (useful to know the user intention).
        givenSize: n.size === void 0 ? null : m.value,
        size: m.value
        // The computed current size at any time.
      });
    }), of(() => a(c)), (v, g) => (re(), ae("div", {
      ref_key: "paneEl",
      ref: h,
      class: "splitpanes__pane",
      onClick: g[0] || (g[0] = (S) => Ge(l)(S, v._.uid)),
      style: bt(_.value)
    }, [
      Y1(v.$slots, "default")
    ], 4));
  }
};
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const df = "170", bx = 0, Vp = 1, wx = 2, m0 = 1, v0 = 2, ms = 3, er = 0, di = 1, mn = 2, ts = 0, Ni = 1, Qa = 2, Jd = 3, Eo = 4, Cr = 5, Oi = 100, g0 = 101, Sx = 102, y0 = 103, _0 = 104, Mx = 200, vs = 201, Cx = 202, Qd = 203, Vc = 204, el = 205, Ex = 206, Tx = 207, Ax = 208, x0 = 209, Px = 210, Dx = 211, Rx = 212, Ix = 213, kx = 214, eh = 0, th = 1, nh = 2, Io = 3, ih = 4, sh = 5, rh = 6, oh = 7, b0 = 0, Lx = 1, Fx = 2, Qs = 0, w0 = 1, S0 = 2, M0 = 3, hf = 4, Ux = 5, C0 = 6, E0 = 7, T0 = 300, ko = 301, Lo = 302, ah = 303, lh = 304, fu = 306, ch = 1e3, Dr = 1001, uh = 1002, Ln = 1003, Ox = 1004, Dl = 1005, Xt = 1006, Wu = 1007, Rr = 1008, is = 1009, A0 = 1010, P0 = 1011, tl = 1012, ff = 1013, zr = 1014, ui = 1015, sr = 1016, pf = 1017, mf = 1018, Fo = 1020, D0 = 35902, R0 = 1021, I0 = 1022, $n = 1023, k0 = 1024, L0 = 1025, Lr = 1026, Uo = 1027, Gc = 1028, vf = 1029, F0 = 1030, gf = 1031, yf = 1033, wc = 33776, Sc = 33777, Mc = 33778, Cc = 33779, dh = 35840, hh = 35841, fh = 35842, ph = 35843, mh = 36196, vh = 37492, gh = 37496, yh = 37808, _h = 37809, xh = 37810, bh = 37811, wh = 37812, Sh = 37813, Mh = 37814, Ch = 37815, Eh = 37816, Th = 37817, Ah = 37818, Ph = 37819, Dh = 37820, Rh = 37821, Ec = 36492, Ih = 36494, kh = 36495, U0 = 36283, Lh = 36284, Fh = 36285, Uh = 36286, zx = 3200, _f = 3201, xf = 0, Nx = 1, Ks = "", pn = "srgb", Ho = "srgb-linear", pu = "linear", qt = "srgb", jr = 7680, Gp = 519, Bx = 512, Vx = 513, Gx = 514, O0 = 515, Hx = 516, Wx = 517, $x = 518, Xx = 519, Hp = 35044, Yr = 35048, Wp = "300 es", bs = 2e3, Hc = 2001;
class Br {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const o = r.indexOf(n);
      o !== -1 && r.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let o = 0, a = r.length; o < a; o++)
        r[o].call(this, e);
      e.target = null;
    }
  }
}
const Nn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let $p = 1234567;
const Fa = Math.PI / 180, Oo = 180 / Math.PI;
function Vr() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Nn[s & 255] + Nn[s >> 8 & 255] + Nn[s >> 16 & 255] + Nn[s >> 24 & 255] + "-" + Nn[e & 255] + Nn[e >> 8 & 255] + "-" + Nn[e >> 16 & 15 | 64] + Nn[e >> 24 & 255] + "-" + Nn[n & 63 | 128] + Nn[n >> 8 & 255] + "-" + Nn[n >> 16 & 255] + Nn[n >> 24 & 255] + Nn[i & 255] + Nn[i >> 8 & 255] + Nn[i >> 16 & 255] + Nn[i >> 24 & 255]).toLowerCase();
}
function In(s, e, n) {
  return Math.max(e, Math.min(n, s));
}
function bf(s, e) {
  return (s % e + e) % e;
}
function jx(s, e, n, i, r) {
  return i + (s - e) * (r - i) / (n - e);
}
function Yx(s, e, n) {
  return s !== e ? (n - s) / (e - s) : 0;
}
function Ua(s, e, n) {
  return (1 - n) * s + n * e;
}
function qx(s, e, n, i) {
  return Ua(s, e, 1 - Math.exp(-n * i));
}
function Zx(s, e = 1) {
  return e - Math.abs(bf(s, e * 2) - e);
}
function Kx(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * (3 - 2 * s));
}
function Jx(s, e, n) {
  return s <= e ? 0 : s >= n ? 1 : (s = (s - e) / (n - e), s * s * s * (s * (s * 6 - 15) + 10));
}
function Qx(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1));
}
function eb(s, e) {
  return s + Math.random() * (e - s);
}
function tb(s) {
  return s * (0.5 - Math.random());
}
function nb(s) {
  s !== void 0 && ($p = s);
  let e = $p += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function ib(s) {
  return s * Fa;
}
function sb(s) {
  return s * Oo;
}
function rb(s) {
  return (s & s - 1) === 0 && s !== 0;
}
function ob(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
}
function ab(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
}
function lb(s, e, n, i, r) {
  const o = Math.cos, a = Math.sin, l = o(n / 2), c = a(n / 2), u = o((e + i) / 2), d = a((e + i) / 2), h = o((e - i) / 2), m = a((e - i) / 2), p = o((i - e) / 2), y = a((i - e) / 2);
  switch (r) {
    case "XYX":
      s.set(l * d, c * h, c * m, l * u);
      break;
    case "YZY":
      s.set(c * m, l * d, c * h, l * u);
      break;
    case "ZXZ":
      s.set(c * h, c * m, l * d, l * u);
      break;
    case "XZX":
      s.set(l * d, c * y, c * p, l * u);
      break;
    case "YXY":
      s.set(c * p, l * d, c * y, l * u);
      break;
    case "ZYZ":
      s.set(c * y, c * p, l * d, l * u);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function po(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return s / 4294967295;
    case Uint16Array:
      return s / 65535;
    case Uint8Array:
      return s / 255;
    case Int32Array:
      return Math.max(s / 2147483647, -1);
    case Int16Array:
      return Math.max(s / 32767, -1);
    case Int8Array:
      return Math.max(s / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Zn(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s;
    case Uint32Array:
      return Math.round(s * 4294967295);
    case Uint16Array:
      return Math.round(s * 65535);
    case Uint8Array:
      return Math.round(s * 255);
    case Int32Array:
      return Math.round(s * 2147483647);
    case Int16Array:
      return Math.round(s * 32767);
    case Int8Array:
      return Math.round(s * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const fn = {
  DEG2RAD: Fa,
  RAD2DEG: Oo,
  generateUUID: Vr,
  clamp: In,
  euclideanModulo: bf,
  mapLinear: jx,
  inverseLerp: Yx,
  lerp: Ua,
  damp: qx,
  pingpong: Zx,
  smoothstep: Kx,
  smootherstep: Jx,
  randInt: Qx,
  randFloat: eb,
  randFloatSpread: tb,
  seededRandom: nb,
  degToRad: ib,
  radToDeg: sb,
  isPowerOfTwo: rb,
  ceilPowerOfTwo: ob,
  floorPowerOfTwo: ab,
  setQuaternionFromProperEuler: lb,
  normalize: Zn,
  denormalize: po
};
class st {
  constructor(e = 0, n = 0) {
    st.prototype.isVector2 = !0, this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * n + r[3] * i + r[6], this.y = r[1] * n + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(In(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n), r = Math.sin(n), o = this.x - e.x, a = this.y - e.y;
    return this.x = o * i - a * r + e.x, this.y = o * r + a * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Et {
  constructor(e, n, i, r, o, a, l, c, u) {
    Et.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, r, o, a, l, c, u);
  }
  set(e, n, i, r, o, a, l, c, u) {
    const d = this.elements;
    return d[0] = e, d[1] = r, d[2] = l, d[3] = n, d[4] = o, d[5] = c, d[6] = i, d[7] = a, d[8] = u, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[4],
      n[8],
      n[1],
      n[5],
      n[9],
      n[2],
      n[6],
      n[10]
    ), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, r = n.elements, o = this.elements, a = i[0], l = i[3], c = i[6], u = i[1], d = i[4], h = i[7], m = i[2], p = i[5], y = i[8], _ = r[0], v = r[3], g = r[6], S = r[1], w = r[4], x = r[7], C = r[2], E = r[5], P = r[8];
    return o[0] = a * _ + l * S + c * C, o[3] = a * v + l * w + c * E, o[6] = a * g + l * x + c * P, o[1] = u * _ + d * S + h * C, o[4] = u * v + d * w + h * E, o[7] = u * g + d * x + h * P, o[2] = m * _ + p * S + y * C, o[5] = m * v + p * w + y * E, o[8] = m * g + p * x + y * P, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8];
    return n * a * d - n * l * u - i * o * d + i * l * c + r * o * u - r * a * c;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = d * a - l * u, m = l * c - d * o, p = u * o - a * c, y = n * h + i * m + r * p;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _ = 1 / y;
    return e[0] = h * _, e[1] = (r * u - d * i) * _, e[2] = (l * i - r * a) * _, e[3] = m * _, e[4] = (d * n - r * c) * _, e[5] = (r * o - l * n) * _, e[6] = p * _, e[7] = (i * c - u * n) * _, e[8] = (a * n - i * o) * _, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, i, r, o, a, l) {
    const c = Math.cos(o), u = Math.sin(o);
    return this.set(
      i * c,
      i * u,
      -i * (c * a + u * l) + a + e,
      -r * u,
      r * c,
      -r * (-u * a + c * l) + l + n,
      0,
      0,
      1
    ), this;
  }
  //
  scale(e, n) {
    return this.premultiply($u.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply($u.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply($u.makeTranslation(e, n)), this;
  }
  // for 2D Transforms
  makeTranslation(e, n) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      n,
      0,
      0,
      1
    ), this;
  }
  makeRotation(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      i,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n) {
    return this.set(
      e,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++)
      if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const $u = /* @__PURE__ */ new Et();
function z0(s) {
  for (let e = s.length - 1; e >= 0; --e)
    if (s[e] >= 65535) return !0;
  return !1;
}
function nl(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s);
}
function cb() {
  const s = nl("canvas");
  return s.style.display = "block", s;
}
const Xp = {};
function wa(s) {
  s in Xp || (Xp[s] = !0, console.warn(s));
}
function ub(s, e, n) {
  return new Promise(function(i, r) {
    function o() {
      switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case s.WAIT_FAILED:
          r();
          break;
        case s.TIMEOUT_EXPIRED:
          setTimeout(o, n);
          break;
        default:
          i();
      }
    }
    setTimeout(o, n);
  });
}
function db(s) {
  const e = s.elements;
  e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
}
function hb(s) {
  const e = s.elements;
  e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
}
const kt = {
  enabled: !0,
  workingColorSpace: Ho,
  /**
   * Implementations of supported color spaces.
   *
   * Required:
   *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
   *	- whitePoint: reference white [ x y ]
   *	- transfer: transfer function (pre-defined)
   *	- toXYZ: Matrix3 RGB to XYZ transform
   *	- fromXYZ: Matrix3 XYZ to RGB transform
   *	- luminanceCoefficients: RGB luminance coefficients
   *
   * Optional:
   *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
   *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
   *
   * Reference:
   * - https://www.russellcottrell.com/photo/matrixCalculator.htm
   */
  spaces: {},
  convert: function(s, e, n) {
    return this.enabled === !1 || e === n || !e || !n || (this.spaces[e].transfer === qt && (s.r = Ms(s.r), s.g = Ms(s.g), s.b = Ms(s.b)), this.spaces[e].primaries !== this.spaces[n].primaries && (s.applyMatrix3(this.spaces[e].toXYZ), s.applyMatrix3(this.spaces[n].fromXYZ)), this.spaces[n].transfer === qt && (s.r = To(s.r), s.g = To(s.g), s.b = To(s.b))), s;
  },
  fromWorkingColorSpace: function(s, e) {
    return this.convert(s, this.workingColorSpace, e);
  },
  toWorkingColorSpace: function(s, e) {
    return this.convert(s, e, this.workingColorSpace);
  },
  getPrimaries: function(s) {
    return this.spaces[s].primaries;
  },
  getTransfer: function(s) {
    return s === Ks ? pu : this.spaces[s].transfer;
  },
  getLuminanceCoefficients: function(s, e = this.workingColorSpace) {
    return s.fromArray(this.spaces[e].luminanceCoefficients);
  },
  define: function(s) {
    Object.assign(this.spaces, s);
  },
  // Internal APIs
  _getMatrix: function(s, e, n) {
    return s.copy(this.spaces[e].toXYZ).multiply(this.spaces[n].fromXYZ);
  },
  _getDrawingBufferColorSpace: function(s) {
    return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace;
  },
  _getUnpackColorSpace: function(s = this.workingColorSpace) {
    return this.spaces[s].workingColorSpaceConfig.unpackColorSpace;
  }
};
function Ms(s) {
  return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
}
function To(s) {
  return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
}
const jp = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], Yp = [0.2126, 0.7152, 0.0722], qp = [0.3127, 0.329], Zp = /* @__PURE__ */ new Et().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), Kp = /* @__PURE__ */ new Et().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
kt.define({
  [Ho]: {
    primaries: jp,
    whitePoint: qp,
    transfer: pu,
    toXYZ: Zp,
    fromXYZ: Kp,
    luminanceCoefficients: Yp,
    workingColorSpaceConfig: { unpackColorSpace: pn },
    outputColorSpaceConfig: { drawingBufferColorSpace: pn }
  },
  [pn]: {
    primaries: jp,
    whitePoint: qp,
    transfer: qt,
    toXYZ: Zp,
    fromXYZ: Kp,
    luminanceCoefficients: Yp,
    outputColorSpaceConfig: { drawingBufferColorSpace: pn }
  }
});
let qr;
class fb {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      qr === void 0 && (qr = nl("canvas")), qr.width = e.width, qr.height = e.height;
      const i = qr.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = qr;
    }
    return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = nl("canvas");
      n.width = e.width, n.height = e.height;
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), o = r.data;
      for (let a = 0; a < o.length; a++)
        o[a] = Ms(o[a] / 255) * 255;
      return i.putImageData(r, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(Ms(n[i] / 255) * 255) : n[i] = Ms(n[i]);
      return {
        data: n,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let pb = 0;
class N0 {
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: pb++ }), this.uuid = Vr(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const i = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let o;
      if (Array.isArray(r)) {
        o = [];
        for (let a = 0, l = r.length; a < l; a++)
          r[a].isDataTexture ? o.push(Xu(r[a].image)) : o.push(Xu(r[a]));
      } else
        o = Xu(r);
      i.url = o;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function Xu(s) {
  return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? fb.getDataURL(s) : s.data ? {
    data: Array.from(s.data),
    width: s.width,
    height: s.height,
    type: s.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let mb = 0;
class yn extends Br {
  constructor(e = yn.DEFAULT_IMAGE, n = yn.DEFAULT_MAPPING, i = Dr, r = Dr, o = Xt, a = Rr, l = $n, c = is, u = yn.DEFAULT_ANISOTROPY, d = Ks) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: mb++ }), this.uuid = Vr(), this.name = "", this.source = new N0(e), this.mipmaps = [], this.mapping = n, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = o, this.minFilter = a, this.anisotropy = u, this.format = l, this.internalFormat = null, this.type = c, this.offset = new st(0, 0), this.repeat = new st(1, 1), this.center = new st(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Et(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), n || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== T0) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case ch:
          e.x = e.x - Math.floor(e.x);
          break;
        case Dr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case uh:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case ch:
          e.y = e.y - Math.floor(e.y);
          break;
        case Dr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case uh:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
yn.DEFAULT_IMAGE = null;
yn.DEFAULT_MAPPING = T0;
yn.DEFAULT_ANISOTROPY = 1;
class jt {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    jt.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, r) {
    return this.x = e, this.y = n, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, r = this.z, o = this.w, a = e.elements;
    return this.x = a[0] * n + a[4] * i + a[8] * r + a[12] * o, this.y = a[1] * n + a[5] * i + a[9] * r + a[13] * o, this.z = a[2] * n + a[6] * i + a[10] * r + a[14] * o, this.w = a[3] * n + a[7] * i + a[11] * r + a[15] * o, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, r, o;
    const c = e.elements, u = c[0], d = c[4], h = c[8], m = c[1], p = c[5], y = c[9], _ = c[2], v = c[6], g = c[10];
    if (Math.abs(d - m) < 0.01 && Math.abs(h - _) < 0.01 && Math.abs(y - v) < 0.01) {
      if (Math.abs(d + m) < 0.1 && Math.abs(h + _) < 0.1 && Math.abs(y + v) < 0.1 && Math.abs(u + p + g - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const w = (u + 1) / 2, x = (p + 1) / 2, C = (g + 1) / 2, E = (d + m) / 4, P = (h + _) / 4, T = (y + v) / 4;
      return w > x && w > C ? w < 0.01 ? (i = 0, r = 0.707106781, o = 0.707106781) : (i = Math.sqrt(w), r = E / i, o = P / i) : x > C ? x < 0.01 ? (i = 0.707106781, r = 0, o = 0.707106781) : (r = Math.sqrt(x), i = E / r, o = T / r) : C < 0.01 ? (i = 0.707106781, r = 0.707106781, o = 0) : (o = Math.sqrt(C), i = P / o, r = T / o), this.set(i, r, o, n), this;
    }
    let S = Math.sqrt((v - y) * (v - y) + (h - _) * (h - _) + (m - d) * (m - d));
    return Math.abs(S) < 1e-3 && (S = 1), this.x = (v - y) / S, this.y = (h - _) / S, this.z = (m - d) / S, this.w = Math.acos((u + p + g - 1) / 2), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this.w = n[15], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this.w = e.w + (n.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class vb extends Br {
  constructor(e = 1, n = 1, i = {}) {
    super(), this.isRenderTarget = !0, this.width = e, this.height = n, this.depth = 1, this.scissor = new jt(0, 0, e, n), this.scissorTest = !1, this.viewport = new jt(0, 0, e, n);
    const r = { width: e, height: n, depth: 1 };
    i = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Xt,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1
    }, i);
    const o = new yn(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
    o.flipY = !1, o.generateMipmaps = i.generateMipmaps, o.internalFormat = i.internalFormat, this.textures = [];
    const a = i.count;
    for (let l = 0; l < a; l++)
      this.textures[l] = o.clone(), this.textures[l].isRenderTargetTexture = !0;
    this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      this.width = e, this.height = n, this.depth = i;
      for (let r = 0, o = this.textures.length; r < o; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = n, this.textures[r].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let i = 0, r = e.textures.length; i < r; i++)
      this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = !0;
    const n = Object.assign({}, e.texture.image);
    return this.texture.source = new N0(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Hi extends vb {
  constructor(e = 1, n = 1, i = {}) {
    super(e, n, i), this.isWebGLRenderTarget = !0;
  }
}
class B0 extends yn {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: n, height: i, depth: r }, this.magFilter = Ln, this.minFilter = Ln, this.wrapR = Dr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class gb extends yn {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: n, height: i, depth: r }, this.magFilter = Ln, this.minFilter = Ln, this.wrapR = Dr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Qn {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = n, this._z = i, this._w = r;
  }
  static slerpFlat(e, n, i, r, o, a, l) {
    let c = i[r + 0], u = i[r + 1], d = i[r + 2], h = i[r + 3];
    const m = o[a + 0], p = o[a + 1], y = o[a + 2], _ = o[a + 3];
    if (l === 0) {
      e[n + 0] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
      return;
    }
    if (l === 1) {
      e[n + 0] = m, e[n + 1] = p, e[n + 2] = y, e[n + 3] = _;
      return;
    }
    if (h !== _ || c !== m || u !== p || d !== y) {
      let v = 1 - l;
      const g = c * m + u * p + d * y + h * _, S = g >= 0 ? 1 : -1, w = 1 - g * g;
      if (w > Number.EPSILON) {
        const C = Math.sqrt(w), E = Math.atan2(C, g * S);
        v = Math.sin(v * E) / C, l = Math.sin(l * E) / C;
      }
      const x = l * S;
      if (c = c * v + m * x, u = u * v + p * x, d = d * v + y * x, h = h * v + _ * x, v === 1 - l) {
        const C = 1 / Math.sqrt(c * c + u * u + d * d + h * h);
        c *= C, u *= C, d *= C, h *= C;
      }
    }
    e[n] = c, e[n + 1] = u, e[n + 2] = d, e[n + 3] = h;
  }
  static multiplyQuaternionsFlat(e, n, i, r, o, a) {
    const l = i[r], c = i[r + 1], u = i[r + 2], d = i[r + 3], h = o[a], m = o[a + 1], p = o[a + 2], y = o[a + 3];
    return e[n] = l * y + d * h + c * p - u * m, e[n + 1] = c * y + d * m + u * h - l * p, e[n + 2] = u * y + d * p + l * m - c * h, e[n + 3] = d * y - l * h - c * m - u * p, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, i, r) {
    return this._x = e, this._y = n, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n = !0) {
    const i = e._x, r = e._y, o = e._z, a = e._order, l = Math.cos, c = Math.sin, u = l(i / 2), d = l(r / 2), h = l(o / 2), m = c(i / 2), p = c(r / 2), y = c(o / 2);
    switch (a) {
      case "XYZ":
        this._x = m * d * h + u * p * y, this._y = u * p * h - m * d * y, this._z = u * d * y + m * p * h, this._w = u * d * h - m * p * y;
        break;
      case "YXZ":
        this._x = m * d * h + u * p * y, this._y = u * p * h - m * d * y, this._z = u * d * y - m * p * h, this._w = u * d * h + m * p * y;
        break;
      case "ZXY":
        this._x = m * d * h - u * p * y, this._y = u * p * h + m * d * y, this._z = u * d * y + m * p * h, this._w = u * d * h - m * p * y;
        break;
      case "ZYX":
        this._x = m * d * h - u * p * y, this._y = u * p * h + m * d * y, this._z = u * d * y - m * p * h, this._w = u * d * h + m * p * y;
        break;
      case "YZX":
        this._x = m * d * h + u * p * y, this._y = u * p * h + m * d * y, this._z = u * d * y - m * p * h, this._w = u * d * h - m * p * y;
        break;
      case "XZY":
        this._x = m * d * h - u * p * y, this._y = u * p * h - m * d * y, this._z = u * d * y + m * p * h, this._w = u * d * h + m * p * y;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, i = n[0], r = n[4], o = n[8], a = n[1], l = n[5], c = n[9], u = n[2], d = n[6], h = n[10], m = i + l + h;
    if (m > 0) {
      const p = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / p, this._x = (d - c) * p, this._y = (o - u) * p, this._z = (a - r) * p;
    } else if (i > l && i > h) {
      const p = 2 * Math.sqrt(1 + i - l - h);
      this._w = (d - c) / p, this._x = 0.25 * p, this._y = (r + a) / p, this._z = (o + u) / p;
    } else if (l > h) {
      const p = 2 * Math.sqrt(1 + l - i - h);
      this._w = (o - u) / p, this._x = (r + a) / p, this._y = 0.25 * p, this._z = (c + d) / p;
    } else {
      const p = 2 * Math.sqrt(1 + h - i - l);
      this._w = (a - r) / p, this._x = (o + u) / p, this._y = (c + d) / p, this._z = 0.25 * p;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(In(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, n / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x, r = e._y, o = e._z, a = e._w, l = n._x, c = n._y, u = n._z, d = n._w;
    return this._x = i * d + a * l + r * u - o * c, this._y = r * d + a * c + o * l - i * u, this._z = o * d + a * u + i * c - r * l, this._w = a * d - i * l - r * c - o * u, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x, r = this._y, o = this._z, a = this._w;
    let l = a * e._w + i * e._x + r * e._y + o * e._z;
    if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1)
      return this._w = a, this._x = i, this._y = r, this._z = o, this;
    const c = 1 - l * l;
    if (c <= Number.EPSILON) {
      const p = 1 - n;
      return this._w = p * a + n * this._w, this._x = p * i + n * this._x, this._y = p * r + n * this._y, this._z = p * o + n * this._z, this.normalize(), this;
    }
    const u = Math.sqrt(c), d = Math.atan2(u, l), h = Math.sin((1 - n) * d) / u, m = Math.sin(n * d) / u;
    return this._w = a * h + this._w * m, this._x = i * h + this._x * m, this._y = r * h + this._y * m, this._z = o * h + this._z * m, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(), n = 2 * Math.PI * Math.random(), i = Math.random(), r = Math.sqrt(1 - i), o = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      o * Math.sin(n),
      o * Math.cos(n)
    );
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class ce {
  constructor(e = 0, n = 0, i = 0) {
    ce.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = i;
  }
  set(e, n, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = n, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Jp.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(Jp.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * n + o[3] * i + o[6] * r, this.y = o[1] * n + o[4] * i + o[7] * r, this.z = o[2] * n + o[5] * i + o[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements, a = 1 / (o[3] * n + o[7] * i + o[11] * r + o[15]);
    return this.x = (o[0] * n + o[4] * i + o[8] * r + o[12]) * a, this.y = (o[1] * n + o[5] * i + o[9] * r + o[13]) * a, this.z = (o[2] * n + o[6] * i + o[10] * r + o[14]) * a, this;
  }
  applyQuaternion(e) {
    const n = this.x, i = this.y, r = this.z, o = e.x, a = e.y, l = e.z, c = e.w, u = 2 * (a * r - l * i), d = 2 * (l * n - o * r), h = 2 * (o * i - a * n);
    return this.x = n + c * u + a * h - l * d, this.y = i + c * d + l * u - o * h, this.z = r + c * h + o * d - a * u, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, i = this.y, r = this.z, o = e.elements;
    return this.x = o[0] * n + o[4] * i + o[8] * r, this.y = o[1] * n + o[5] * i + o[9] * r, this.z = o[2] * n + o[6] * i + o[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x, r = e.y, o = e.z, a = n.x, l = n.y, c = n.z;
    return this.x = r * c - o * l, this.y = o * a - i * c, this.z = i * l - r * a, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return ju.copy(this).projectOnVector(e), this.sub(ju);
  }
  reflect(e) {
    return this.sub(ju.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(In(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return n * n + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const r = Math.sin(n) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(n) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return this.x = e * Math.sin(n), this.y = i, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2, n = Math.random() * 2 - 1, i = Math.sqrt(1 - n * n);
    return this.x = i * Math.cos(e), this.y = n, this.z = i * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const ju = /* @__PURE__ */ new ce(), Jp = /* @__PURE__ */ new Qn();
class rr {
  constructor(e = new ce(1 / 0, 1 / 0, 1 / 0), n = new ce(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = n;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(Ii.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(Ii.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++)
      this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = Ii.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const o = i.getAttribute("position");
      if (n === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, l = o.count; a < l; a++)
          e.isMesh === !0 ? e.getVertexPosition(a, Ii) : Ii.fromBufferAttribute(o, a), Ii.applyMatrix4(e.matrixWorld), this.expandByPoint(Ii);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), Rl.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), Rl.copy(i.boundingBox)), Rl.applyMatrix4(e.matrixWorld), this.union(Rl);
    }
    const r = e.children;
    for (let o = 0, a = r.length; o < a; o++)
      this.expandByObject(r[o], n);
    return this;
  }
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Ii), Ii.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, i;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, i += e.normal.z * this.min.z), n <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(ra), Il.subVectors(this.max, ra), Zr.subVectors(e.a, ra), Kr.subVectors(e.b, ra), Jr.subVectors(e.c, ra), Fs.subVectors(Kr, Zr), Us.subVectors(Jr, Kr), ur.subVectors(Zr, Jr);
    let n = [
      0,
      -Fs.z,
      Fs.y,
      0,
      -Us.z,
      Us.y,
      0,
      -ur.z,
      ur.y,
      Fs.z,
      0,
      -Fs.x,
      Us.z,
      0,
      -Us.x,
      ur.z,
      0,
      -ur.x,
      -Fs.y,
      Fs.x,
      0,
      -Us.y,
      Us.x,
      0,
      -ur.y,
      ur.x,
      0
    ];
    return !Yu(n, Zr, Kr, Jr, Il) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Yu(n, Zr, Kr, Jr, Il)) ? !1 : (kl.crossVectors(Fs, Us), n = [kl.x, kl.y, kl.z], Yu(n, Zr, Kr, Jr, Il));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ii).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Ii).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (as[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), as[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), as[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), as[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), as[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), as[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), as[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), as[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(as), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const as = [
  /* @__PURE__ */ new ce(),
  /* @__PURE__ */ new ce(),
  /* @__PURE__ */ new ce(),
  /* @__PURE__ */ new ce(),
  /* @__PURE__ */ new ce(),
  /* @__PURE__ */ new ce(),
  /* @__PURE__ */ new ce(),
  /* @__PURE__ */ new ce()
], Ii = /* @__PURE__ */ new ce(), Rl = /* @__PURE__ */ new rr(), Zr = /* @__PURE__ */ new ce(), Kr = /* @__PURE__ */ new ce(), Jr = /* @__PURE__ */ new ce(), Fs = /* @__PURE__ */ new ce(), Us = /* @__PURE__ */ new ce(), ur = /* @__PURE__ */ new ce(), ra = /* @__PURE__ */ new ce(), Il = /* @__PURE__ */ new ce(), kl = /* @__PURE__ */ new ce(), dr = /* @__PURE__ */ new ce();
function Yu(s, e, n, i, r) {
  for (let o = 0, a = s.length - 3; o <= a; o += 3) {
    dr.fromArray(s, o);
    const l = r.x * Math.abs(dr.x) + r.y * Math.abs(dr.y) + r.z * Math.abs(dr.z), c = e.dot(dr), u = n.dot(dr), d = i.dot(dr);
    if (Math.max(-Math.max(c, u, d), Math.min(c, u, d)) > l)
      return !1;
  }
  return !0;
}
const yb = /* @__PURE__ */ new rr(), oa = /* @__PURE__ */ new ce(), qu = /* @__PURE__ */ new ce();
class pl {
  constructor(e = new ce(), n = -1) {
    this.isSphere = !0, this.center = e, this.radius = n;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : yb.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let o = 0, a = e.length; o < a; o++)
      r = Math.max(r, i.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    oa.subVectors(e, this.center);
    const n = oa.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n), r = (i - this.radius) * 0.5;
      this.center.addScaledVector(oa, r / i), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (qu.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(oa.copy(e.center).add(qu)), this.expandByPoint(oa.copy(e.center).sub(qu))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ls = /* @__PURE__ */ new ce(), Zu = /* @__PURE__ */ new ce(), Ll = /* @__PURE__ */ new ce(), Os = /* @__PURE__ */ new ce(), Ku = /* @__PURE__ */ new ce(), Fl = /* @__PURE__ */ new ce(), Ju = /* @__PURE__ */ new ce();
class wf {
  constructor(e = new ce(), n = new ce(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, ls)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0 ? n.copy(this.origin) : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = ls.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (ls.copy(this.origin).addScaledVector(this.direction, n), ls.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, r) {
    Zu.copy(e).add(n).multiplyScalar(0.5), Ll.copy(n).sub(e).normalize(), Os.copy(this.origin).sub(Zu);
    const o = e.distanceTo(n) * 0.5, a = -this.direction.dot(Ll), l = Os.dot(this.direction), c = -Os.dot(Ll), u = Os.lengthSq(), d = Math.abs(1 - a * a);
    let h, m, p, y;
    if (d > 0)
      if (h = a * c - l, m = a * l - c, y = o * d, h >= 0)
        if (m >= -y)
          if (m <= y) {
            const _ = 1 / d;
            h *= _, m *= _, p = h * (h + a * m + 2 * l) + m * (a * h + m + 2 * c) + u;
          } else
            m = o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
        else
          m = -o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
      else
        m <= -y ? (h = Math.max(0, -(-a * o + l)), m = h > 0 ? -o : Math.min(Math.max(-o, -c), o), p = -h * h + m * (m + 2 * c) + u) : m <= y ? (h = 0, m = Math.min(Math.max(-o, -c), o), p = m * (m + 2 * c) + u) : (h = Math.max(0, -(a * o + l)), m = h > 0 ? o : Math.min(Math.max(-o, -c), o), p = -h * h + m * (m + 2 * c) + u);
    else
      m = a > 0 ? -o : o, h = Math.max(0, -(a * m + l)), p = -h * h + m * (m + 2 * c) + u;
    return i && i.copy(this.origin).addScaledVector(this.direction, h), r && r.copy(Zu).addScaledVector(Ll, m), p;
  }
  intersectSphere(e, n) {
    ls.subVectors(e.center, this.origin);
    const i = ls.dot(this.direction), r = ls.dot(ls) - i * i, o = e.radius * e.radius;
    if (r > o) return null;
    const a = Math.sqrt(o - r), l = i - a, c = i + a;
    return c < 0 ? null : l < 0 ? this.at(c, n) : this.at(l, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, r, o, a, l, c;
    const u = 1 / this.direction.x, d = 1 / this.direction.y, h = 1 / this.direction.z, m = this.origin;
    return u >= 0 ? (i = (e.min.x - m.x) * u, r = (e.max.x - m.x) * u) : (i = (e.max.x - m.x) * u, r = (e.min.x - m.x) * u), d >= 0 ? (o = (e.min.y - m.y) * d, a = (e.max.y - m.y) * d) : (o = (e.max.y - m.y) * d, a = (e.min.y - m.y) * d), i > a || o > r || ((o > i || isNaN(i)) && (i = o), (a < r || isNaN(r)) && (r = a), h >= 0 ? (l = (e.min.z - m.z) * h, c = (e.max.z - m.z) * h) : (l = (e.max.z - m.z) * h, c = (e.min.z - m.z) * h), i > c || l > r) || ((l > i || i !== i) && (i = l), (c < r || r !== r) && (r = c), r < 0) ? null : this.at(i >= 0 ? i : r, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, ls) !== null;
  }
  intersectTriangle(e, n, i, r, o) {
    Ku.subVectors(n, e), Fl.subVectors(i, e), Ju.crossVectors(Ku, Fl);
    let a = this.direction.dot(Ju), l;
    if (a > 0) {
      if (r) return null;
      l = 1;
    } else if (a < 0)
      l = -1, a = -a;
    else
      return null;
    Os.subVectors(this.origin, e);
    const c = l * this.direction.dot(Fl.crossVectors(Os, Fl));
    if (c < 0)
      return null;
    const u = l * this.direction.dot(Ku.cross(Os));
    if (u < 0 || c + u > a)
      return null;
    const d = -l * Os.dot(Ju);
    return d < 0 ? null : this.at(d / a, o);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Zt {
  constructor(e, n, i, r, o, a, l, c, u, d, h, m, p, y, _, v) {
    Zt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, n, i, r, o, a, l, c, u, d, h, m, p, y, _, v);
  }
  set(e, n, i, r, o, a, l, c, u, d, h, m, p, y, _, v) {
    const g = this.elements;
    return g[0] = e, g[4] = n, g[8] = i, g[12] = r, g[1] = o, g[5] = a, g[9] = l, g[13] = c, g[2] = u, g[6] = d, g[10] = h, g[14] = m, g[3] = p, g[7] = y, g[11] = _, g[15] = v, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Zt().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
  }
  copyPosition(e) {
    const n = this.elements, i = e.elements;
    return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(
      n[0],
      n[3],
      n[6],
      0,
      n[1],
      n[4],
      n[7],
      0,
      n[2],
      n[5],
      n[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, i) {
    return this.set(
      e.x,
      n.x,
      i.x,
      0,
      e.y,
      n.y,
      i.y,
      0,
      e.z,
      n.z,
      i.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(e) {
    const n = this.elements, i = e.elements, r = 1 / Qr.setFromMatrixColumn(e, 0).length(), o = 1 / Qr.setFromMatrixColumn(e, 1).length(), a = 1 / Qr.setFromMatrixColumn(e, 2).length();
    return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[3] = 0, n[4] = i[4] * o, n[5] = i[5] * o, n[6] = i[6] * o, n[7] = 0, n[8] = i[8] * a, n[9] = i[9] * a, n[10] = i[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const n = this.elements, i = e.x, r = e.y, o = e.z, a = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r), d = Math.cos(o), h = Math.sin(o);
    if (e.order === "XYZ") {
      const m = a * d, p = a * h, y = l * d, _ = l * h;
      n[0] = c * d, n[4] = -c * h, n[8] = u, n[1] = p + y * u, n[5] = m - _ * u, n[9] = -l * c, n[2] = _ - m * u, n[6] = y + p * u, n[10] = a * c;
    } else if (e.order === "YXZ") {
      const m = c * d, p = c * h, y = u * d, _ = u * h;
      n[0] = m + _ * l, n[4] = y * l - p, n[8] = a * u, n[1] = a * h, n[5] = a * d, n[9] = -l, n[2] = p * l - y, n[6] = _ + m * l, n[10] = a * c;
    } else if (e.order === "ZXY") {
      const m = c * d, p = c * h, y = u * d, _ = u * h;
      n[0] = m - _ * l, n[4] = -a * h, n[8] = y + p * l, n[1] = p + y * l, n[5] = a * d, n[9] = _ - m * l, n[2] = -a * u, n[6] = l, n[10] = a * c;
    } else if (e.order === "ZYX") {
      const m = a * d, p = a * h, y = l * d, _ = l * h;
      n[0] = c * d, n[4] = y * u - p, n[8] = m * u + _, n[1] = c * h, n[5] = _ * u + m, n[9] = p * u - y, n[2] = -u, n[6] = l * c, n[10] = a * c;
    } else if (e.order === "YZX") {
      const m = a * c, p = a * u, y = l * c, _ = l * u;
      n[0] = c * d, n[4] = _ - m * h, n[8] = y * h + p, n[1] = h, n[5] = a * d, n[9] = -l * d, n[2] = -u * d, n[6] = p * h + y, n[10] = m - _ * h;
    } else if (e.order === "XZY") {
      const m = a * c, p = a * u, y = l * c, _ = l * u;
      n[0] = c * d, n[4] = -h, n[8] = u * d, n[1] = m * h + _, n[5] = a * d, n[9] = p * h - y, n[2] = y * h - p, n[6] = l * d, n[10] = _ * h + m;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_b, e, xb);
  }
  lookAt(e, n, i) {
    const r = this.elements;
    return gi.subVectors(e, n), gi.lengthSq() === 0 && (gi.z = 1), gi.normalize(), zs.crossVectors(i, gi), zs.lengthSq() === 0 && (Math.abs(i.z) === 1 ? gi.x += 1e-4 : gi.z += 1e-4, gi.normalize(), zs.crossVectors(i, gi)), zs.normalize(), Ul.crossVectors(gi, zs), r[0] = zs.x, r[4] = Ul.x, r[8] = gi.x, r[1] = zs.y, r[5] = Ul.y, r[9] = gi.y, r[2] = zs.z, r[6] = Ul.z, r[10] = gi.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, r = n.elements, o = this.elements, a = i[0], l = i[4], c = i[8], u = i[12], d = i[1], h = i[5], m = i[9], p = i[13], y = i[2], _ = i[6], v = i[10], g = i[14], S = i[3], w = i[7], x = i[11], C = i[15], E = r[0], P = r[4], T = r[8], b = r[12], M = r[1], L = r[5], N = r[9], D = r[13], O = r[2], A = r[6], G = r[10], he = r[14], ee = r[3], le = r[7], oe = r[11], Y = r[15];
    return o[0] = a * E + l * M + c * O + u * ee, o[4] = a * P + l * L + c * A + u * le, o[8] = a * T + l * N + c * G + u * oe, o[12] = a * b + l * D + c * he + u * Y, o[1] = d * E + h * M + m * O + p * ee, o[5] = d * P + h * L + m * A + p * le, o[9] = d * T + h * N + m * G + p * oe, o[13] = d * b + h * D + m * he + p * Y, o[2] = y * E + _ * M + v * O + g * ee, o[6] = y * P + _ * L + v * A + g * le, o[10] = y * T + _ * N + v * G + g * oe, o[14] = y * b + _ * D + v * he + g * Y, o[3] = S * E + w * M + x * O + C * ee, o[7] = S * P + w * L + x * A + C * le, o[11] = S * T + w * N + x * G + C * oe, o[15] = S * b + w * D + x * he + C * Y, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[4], r = e[8], o = e[12], a = e[1], l = e[5], c = e[9], u = e[13], d = e[2], h = e[6], m = e[10], p = e[14], y = e[3], _ = e[7], v = e[11], g = e[15];
    return y * (+o * c * h - r * u * h - o * l * m + i * u * m + r * l * p - i * c * p) + _ * (+n * c * p - n * u * m + o * a * m - r * a * p + r * u * d - o * c * d) + v * (+n * u * h - n * l * p - o * a * h + i * a * p + o * l * d - i * u * d) + g * (-r * l * d - n * c * h + n * l * m + r * a * h - i * a * m + i * c * d);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = n, r[14] = i), this;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], r = e[2], o = e[3], a = e[4], l = e[5], c = e[6], u = e[7], d = e[8], h = e[9], m = e[10], p = e[11], y = e[12], _ = e[13], v = e[14], g = e[15], S = h * v * u - _ * m * u + _ * c * p - l * v * p - h * c * g + l * m * g, w = y * m * u - d * v * u - y * c * p + a * v * p + d * c * g - a * m * g, x = d * _ * u - y * h * u + y * l * p - a * _ * p - d * l * g + a * h * g, C = y * h * c - d * _ * c - y * l * m + a * _ * m + d * l * v - a * h * v, E = n * S + i * w + r * x + o * C;
    if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const P = 1 / E;
    return e[0] = S * P, e[1] = (_ * m * o - h * v * o - _ * r * p + i * v * p + h * r * g - i * m * g) * P, e[2] = (l * v * o - _ * c * o + _ * r * u - i * v * u - l * r * g + i * c * g) * P, e[3] = (h * c * o - l * m * o - h * r * u + i * m * u + l * r * p - i * c * p) * P, e[4] = w * P, e[5] = (d * v * o - y * m * o + y * r * p - n * v * p - d * r * g + n * m * g) * P, e[6] = (y * c * o - a * v * o - y * r * u + n * v * u + a * r * g - n * c * g) * P, e[7] = (a * m * o - d * c * o + d * r * u - n * m * u - a * r * p + n * c * p) * P, e[8] = x * P, e[9] = (y * h * o - d * _ * o - y * i * p + n * _ * p + d * i * g - n * h * g) * P, e[10] = (a * _ * o - y * l * o + y * i * u - n * _ * u - a * i * g + n * l * g) * P, e[11] = (d * l * o - a * h * o - d * i * u + n * h * u + a * i * p - n * l * p) * P, e[12] = C * P, e[13] = (d * _ * r - y * h * r + y * i * m - n * _ * m - d * i * v + n * h * v) * P, e[14] = (y * l * r - a * _ * r - y * i * c + n * _ * c + a * i * v - n * l * v) * P, e[15] = (a * h * r - d * l * r + d * i * c - n * h * c - a * i * m + n * l * m) * P, this;
  }
  scale(e) {
    const n = this.elements, i = e.x, r = e.y, o = e.z;
    return n[0] *= i, n[4] *= r, n[8] *= o, n[1] *= i, n[5] *= r, n[9] *= o, n[2] *= i, n[6] *= r, n[10] *= o, n[3] *= i, n[7] *= r, n[11] *= o, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, r));
  }
  makeTranslation(e, n, i) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      n,
      0,
      0,
      1,
      i,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      0,
      i,
      0,
      0,
      1,
      0,
      0,
      -i,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(
      n,
      -i,
      0,
      0,
      i,
      n,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n), r = Math.sin(n), o = 1 - i, a = e.x, l = e.y, c = e.z, u = o * a, d = o * l;
    return this.set(
      u * a + i,
      u * l - r * c,
      u * c + r * l,
      0,
      u * l + r * c,
      d * l + i,
      d * c - r * a,
      0,
      u * c - r * l,
      d * c + r * a,
      o * c * c + i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(e, n, i) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      i,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(e, n, i, r, o, a) {
    return this.set(
      1,
      i,
      o,
      0,
      e,
      1,
      a,
      0,
      n,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(e, n, i) {
    const r = this.elements, o = n._x, a = n._y, l = n._z, c = n._w, u = o + o, d = a + a, h = l + l, m = o * u, p = o * d, y = o * h, _ = a * d, v = a * h, g = l * h, S = c * u, w = c * d, x = c * h, C = i.x, E = i.y, P = i.z;
    return r[0] = (1 - (_ + g)) * C, r[1] = (p + x) * C, r[2] = (y - w) * C, r[3] = 0, r[4] = (p - x) * E, r[5] = (1 - (m + g)) * E, r[6] = (v + S) * E, r[7] = 0, r[8] = (y + w) * P, r[9] = (v - S) * P, r[10] = (1 - (m + _)) * P, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, n, i) {
    const r = this.elements;
    let o = Qr.set(r[0], r[1], r[2]).length();
    const a = Qr.set(r[4], r[5], r[6]).length(), l = Qr.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (o = -o), e.x = r[12], e.y = r[13], e.z = r[14], ki.copy(this);
    const u = 1 / o, d = 1 / a, h = 1 / l;
    return ki.elements[0] *= u, ki.elements[1] *= u, ki.elements[2] *= u, ki.elements[4] *= d, ki.elements[5] *= d, ki.elements[6] *= d, ki.elements[8] *= h, ki.elements[9] *= h, ki.elements[10] *= h, n.setFromRotationMatrix(ki), i.x = o, i.y = a, i.z = l, this;
  }
  makePerspective(e, n, i, r, o, a, l = bs) {
    const c = this.elements, u = 2 * o / (n - e), d = 2 * o / (i - r), h = (n + e) / (n - e), m = (i + r) / (i - r);
    let p, y;
    if (l === bs)
      p = -(a + o) / (a - o), y = -2 * a * o / (a - o);
    else if (l === Hc)
      p = -a / (a - o), y = -a * o / (a - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
    return c[0] = u, c[4] = 0, c[8] = h, c[12] = 0, c[1] = 0, c[5] = d, c[9] = m, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = p, c[14] = y, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this;
  }
  makeOrthographic(e, n, i, r, o, a, l = bs) {
    const c = this.elements, u = 1 / (n - e), d = 1 / (i - r), h = 1 / (a - o), m = (n + e) * u, p = (i + r) * d;
    let y, _;
    if (l === bs)
      y = (a + o) * h, _ = -2 * h;
    else if (l === Hc)
      y = o * h, _ = -1 * h;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
    return c[0] = 2 * u, c[4] = 0, c[8] = 0, c[12] = -m, c[1] = 0, c[5] = 2 * d, c[9] = 0, c[13] = -p, c[2] = 0, c[6] = 0, c[10] = _, c[14] = -y, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++)
      if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++)
      this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e[n + 9] = i[9], e[n + 10] = i[10], e[n + 11] = i[11], e[n + 12] = i[12], e[n + 13] = i[13], e[n + 14] = i[14], e[n + 15] = i[15], e;
  }
}
const Qr = /* @__PURE__ */ new ce(), ki = /* @__PURE__ */ new Zt(), _b = /* @__PURE__ */ new ce(0, 0, 0), xb = /* @__PURE__ */ new ce(1, 1, 1), zs = /* @__PURE__ */ new ce(), Ul = /* @__PURE__ */ new ce(), gi = /* @__PURE__ */ new ce(), Qp = /* @__PURE__ */ new Zt(), em = /* @__PURE__ */ new Qn();
class wi {
  constructor(e = 0, n = 0, i = 0, r = wi.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = n, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, i, r = this._order) {
    return this._x = e, this._y = n, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const r = e.elements, o = r[0], a = r[4], l = r[8], c = r[1], u = r[5], d = r[9], h = r[2], m = r[6], p = r[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(In(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, p), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(m, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-In(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(l, p), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(In(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(c, o));
        break;
      case "ZYX":
        this._y = Math.asin(-In(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(m, p), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, u));
        break;
      case "YZX":
        this._z = Math.asin(In(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._x = Math.atan2(-d, u), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(l, p));
        break;
      case "XZY":
        this._z = Math.asin(-In(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(m, u), this._y = Math.atan2(l, o)) : (this._x = Math.atan2(-d, p), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return Qp.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Qp, n, i);
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return em.setFromEuler(this), this.setFromQuaternion(em, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
wi.DEFAULT_ORDER = "XYZ";
class Sf {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let bb = 0;
const tm = /* @__PURE__ */ new ce(), eo = /* @__PURE__ */ new Qn(), cs = /* @__PURE__ */ new Zt(), Ol = /* @__PURE__ */ new ce(), aa = /* @__PURE__ */ new ce(), wb = /* @__PURE__ */ new ce(), Sb = /* @__PURE__ */ new Qn(), nm = /* @__PURE__ */ new ce(1, 0, 0), im = /* @__PURE__ */ new ce(0, 1, 0), sm = /* @__PURE__ */ new ce(0, 0, 1), rm = { type: "added" }, Mb = { type: "removed" }, to = { type: "childadded", child: null }, Qu = { type: "childremoved", child: null };
class ln extends Br {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: bb++ }), this.uuid = Vr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ln.DEFAULT_UP.clone();
    const e = new ce(), n = new wi(), i = new Qn(), r = new ce(1, 1, 1);
    function o() {
      i.setFromEuler(n, !1);
    }
    function a() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(o), i._onChange(a), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      modelViewMatrix: {
        value: new Zt()
      },
      normalMatrix: {
        value: new Et()
      }
    }), this.matrix = new Zt(), this.matrixWorld = new Zt(), this.matrixAutoUpdate = ln.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Sf(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return eo.setFromAxisAngle(e, n), this.quaternion.multiply(eo), this;
  }
  rotateOnWorldAxis(e, n) {
    return eo.setFromAxisAngle(e, n), this.quaternion.premultiply(eo), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(nm, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(im, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(sm, e);
  }
  translateOnAxis(e, n) {
    return tm.copy(e).applyQuaternion(this.quaternion), this.position.add(tm.multiplyScalar(n)), this;
  }
  translateX(e) {
    return this.translateOnAxis(nm, e);
  }
  translateY(e) {
    return this.translateOnAxis(im, e);
  }
  translateZ(e) {
    return this.translateOnAxis(sm, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(cs.copy(this.matrixWorld).invert());
  }
  lookAt(e, n, i) {
    e.isVector3 ? Ol.copy(e) : Ol.set(e, n, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), aa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? cs.lookAt(aa, Ol, this.up) : cs.lookAt(Ol, aa, this.up), this.quaternion.setFromRotationMatrix(cs), r && (cs.extractRotation(r.matrixWorld), eo.setFromRotationMatrix(cs), this.quaternion.premultiply(eo.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(rm), to.child = e, this.dispatchEvent(to), to.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++)
        this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Mb), Qu.child = e, this.dispatchEvent(Qu), Qu.child = null), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(!0, !1), cs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), cs.multiply(e.parent.matrixWorld)), e.applyMatrix4(cs), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(rm), to.child = e, this.dispatchEvent(to), to.child = null, this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const a = this.children[i].getObjectByProperty(e, n);
      if (a !== void 0)
        return a;
    }
  }
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const r = this.children;
    for (let o = 0, a = r.length; o < a; o++)
      r[o].getObjectsByProperty(e, n, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(aa, e, wb), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(aa, Sb, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++)
      n[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), n === !0) {
      const r = this.children;
      for (let o = 0, a = r.length; o < a; o++)
        r[o].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", i = {};
    n && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, i.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((l) => ({
      boxInitialized: l.boxInitialized,
      boxMin: l.box.min.toArray(),
      boxMax: l.box.max.toArray(),
      sphereInitialized: l.sphereInitialized,
      sphereRadius: l.sphere.radius,
      sphereCenter: l.sphere.center.toArray()
    })), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = {
      center: r.boundingSphere.center.toArray(),
      radius: r.boundingSphere.radius
    }), this.boundingBox !== null && (r.boundingBox = {
      min: r.boundingBox.min.toArray(),
      max: r.boundingBox.max.toArray()
    }));
    function o(l, c) {
      return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = o(e.geometries, this.geometry);
      const l = this.geometry.parameters;
      if (l !== void 0 && l.shapes !== void 0) {
        const c = l.shapes;
        if (Array.isArray(c))
          for (let u = 0, d = c.length; u < d; u++) {
            const h = c[u];
            o(e.shapes, h);
          }
        else
          o(e.shapes, c);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const l = [];
        for (let c = 0, u = this.material.length; c < u; c++)
          l.push(o(e.materials, this.material[c]));
        r.material = l;
      } else
        r.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let l = 0; l < this.children.length; l++)
        r.children.push(this.children[l].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let l = 0; l < this.animations.length; l++) {
        const c = this.animations[l];
        r.animations.push(o(e.animations, c));
      }
    }
    if (n) {
      const l = a(e.geometries), c = a(e.materials), u = a(e.textures), d = a(e.images), h = a(e.shapes), m = a(e.skeletons), p = a(e.animations), y = a(e.nodes);
      l.length > 0 && (i.geometries = l), c.length > 0 && (i.materials = c), u.length > 0 && (i.textures = u), d.length > 0 && (i.images = d), h.length > 0 && (i.shapes = h), m.length > 0 && (i.skeletons = m), p.length > 0 && (i.animations = p), y.length > 0 && (i.nodes = y);
    }
    return i.object = r, i;
    function a(l) {
      const c = [];
      for (const u in l) {
        const d = l[u];
        delete d.metadata, c.push(d);
      }
      return c;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), n === !0)
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
ln.DEFAULT_UP = /* @__PURE__ */ new ce(0, 1, 0);
ln.DEFAULT_MATRIX_AUTO_UPDATE = !0;
ln.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Li = /* @__PURE__ */ new ce(), us = /* @__PURE__ */ new ce(), ed = /* @__PURE__ */ new ce(), ds = /* @__PURE__ */ new ce(), no = /* @__PURE__ */ new ce(), io = /* @__PURE__ */ new ce(), om = /* @__PURE__ */ new ce(), td = /* @__PURE__ */ new ce(), nd = /* @__PURE__ */ new ce(), id = /* @__PURE__ */ new ce(), sd = /* @__PURE__ */ new jt(), rd = /* @__PURE__ */ new jt(), od = /* @__PURE__ */ new jt();
class zi {
  constructor(e = new ce(), n = new ce(), i = new ce()) {
    this.a = e, this.b = n, this.c = i;
  }
  static getNormal(e, n, i, r) {
    r.subVectors(i, n), Li.subVectors(e, n), r.cross(Li);
    const o = r.lengthSq();
    return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(e, n, i, r, o) {
    Li.subVectors(r, n), us.subVectors(i, n), ed.subVectors(e, n);
    const a = Li.dot(Li), l = Li.dot(us), c = Li.dot(ed), u = us.dot(us), d = us.dot(ed), h = a * u - l * l;
    if (h === 0)
      return o.set(0, 0, 0), null;
    const m = 1 / h, p = (u * c - l * d) * m, y = (a * d - l * c) * m;
    return o.set(1 - p - y, y, p);
  }
  static containsPoint(e, n, i, r) {
    return this.getBarycoord(e, n, i, r, ds) === null ? !1 : ds.x >= 0 && ds.y >= 0 && ds.x + ds.y <= 1;
  }
  static getInterpolation(e, n, i, r, o, a, l, c) {
    return this.getBarycoord(e, n, i, r, ds) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(o, ds.x), c.addScaledVector(a, ds.y), c.addScaledVector(l, ds.z), c);
  }
  static getInterpolatedAttribute(e, n, i, r, o, a) {
    return sd.setScalar(0), rd.setScalar(0), od.setScalar(0), sd.fromBufferAttribute(e, n), rd.fromBufferAttribute(e, i), od.fromBufferAttribute(e, r), a.setScalar(0), a.addScaledVector(sd, o.x), a.addScaledVector(rd, o.y), a.addScaledVector(od, o.z), a;
  }
  static isFrontFacing(e, n, i, r) {
    return Li.subVectors(i, n), us.subVectors(e, n), Li.cross(us).dot(r) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, r) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, n, i, r) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Li.subVectors(this.c, this.b), us.subVectors(this.a, this.b), Li.cross(us).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return zi.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return zi.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, i, r, o) {
    return zi.getInterpolation(e, this.a, this.b, this.c, n, i, r, o);
  }
  containsPoint(e) {
    return zi.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return zi.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a, r = this.b, o = this.c;
    let a, l;
    no.subVectors(r, i), io.subVectors(o, i), td.subVectors(e, i);
    const c = no.dot(td), u = io.dot(td);
    if (c <= 0 && u <= 0)
      return n.copy(i);
    nd.subVectors(e, r);
    const d = no.dot(nd), h = io.dot(nd);
    if (d >= 0 && h <= d)
      return n.copy(r);
    const m = c * h - d * u;
    if (m <= 0 && c >= 0 && d <= 0)
      return a = c / (c - d), n.copy(i).addScaledVector(no, a);
    id.subVectors(e, o);
    const p = no.dot(id), y = io.dot(id);
    if (y >= 0 && p <= y)
      return n.copy(o);
    const _ = p * u - c * y;
    if (_ <= 0 && u >= 0 && y <= 0)
      return l = u / (u - y), n.copy(i).addScaledVector(io, l);
    const v = d * y - p * h;
    if (v <= 0 && h - d >= 0 && p - y >= 0)
      return om.subVectors(o, r), l = (h - d) / (h - d + (p - y)), n.copy(r).addScaledVector(om, l);
    const g = 1 / (v + _ + m);
    return a = _ * g, l = m * g, n.copy(i).addScaledVector(no, a).addScaledVector(io, l);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const V0 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Ns = { h: 0, s: 0, l: 0 }, zl = { h: 0, s: 0, l: 0 };
function ad(s, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? s + (e - s) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - n) : s;
}
class Mt {
  constructor(e, n, i) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, i);
  }
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, n, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, n = pn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, kt.toWorkingColorSpace(this, n), this;
  }
  setRGB(e, n, i, r = kt.workingColorSpace) {
    return this.r = e, this.g = n, this.b = i, kt.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, n, i, r = kt.workingColorSpace) {
    if (e = bf(e, 1), n = In(n, 0, 1), i = In(i, 0, 1), n === 0)
      this.r = this.g = this.b = i;
    else {
      const o = i <= 0.5 ? i * (1 + n) : i + n - i * n, a = 2 * i - o;
      this.r = ad(a, o, e + 1 / 3), this.g = ad(a, o, e), this.b = ad(a, o, e - 1 / 3);
    }
    return kt.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, n = pn) {
    function i(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const a = r[1], l = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              n
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              n
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l))
            return i(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              n
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = r[1], a = o.length;
      if (a === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          n
        );
      if (a === 6)
        return this.setHex(parseInt(o, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = pn) {
    const i = V0[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Ms(e.r), this.g = Ms(e.g), this.b = Ms(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = To(e.r), this.g = To(e.g), this.b = To(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = pn) {
    return kt.fromWorkingColorSpace(Bn.copy(this), e), Math.round(In(Bn.r * 255, 0, 255)) * 65536 + Math.round(In(Bn.g * 255, 0, 255)) * 256 + Math.round(In(Bn.b * 255, 0, 255));
  }
  getHexString(e = pn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = kt.workingColorSpace) {
    kt.fromWorkingColorSpace(Bn.copy(this), n);
    const i = Bn.r, r = Bn.g, o = Bn.b, a = Math.max(i, r, o), l = Math.min(i, r, o);
    let c, u;
    const d = (l + a) / 2;
    if (l === a)
      c = 0, u = 0;
    else {
      const h = a - l;
      switch (u = d <= 0.5 ? h / (a + l) : h / (2 - a - l), a) {
        case i:
          c = (r - o) / h + (r < o ? 6 : 0);
          break;
        case r:
          c = (o - i) / h + 2;
          break;
        case o:
          c = (i - r) / h + 4;
          break;
      }
      c /= 6;
    }
    return e.h = c, e.s = u, e.l = d, e;
  }
  getRGB(e, n = kt.workingColorSpace) {
    return kt.fromWorkingColorSpace(Bn.copy(this), n), e.r = Bn.r, e.g = Bn.g, e.b = Bn.b, e;
  }
  getStyle(e = pn) {
    kt.fromWorkingColorSpace(Bn.copy(this), e);
    const n = Bn.r, i = Bn.g, r = Bn.b;
    return e !== pn ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(Ns), this.setHSL(Ns.h + e, Ns.s + n, Ns.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpColors(e, n, i) {
    return this.r = e.r + (n.r - e.r) * i, this.g = e.g + (n.g - e.g) * i, this.b = e.b + (n.b - e.b) * i, this;
  }
  lerpHSL(e, n) {
    this.getHSL(Ns), e.getHSL(zl);
    const i = Ua(Ns.h, zl.h, n), r = Ua(Ns.s, zl.s, n), o = Ua(Ns.l, zl.l, n);
    return this.setHSL(i, r, o), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const n = this.r, i = this.g, r = this.b, o = e.elements;
    return this.r = o[0] * n + o[3] * i + o[6] * r, this.g = o[1] * n + o[4] * i + o[7] * r, this.b = o[2] * n + o[5] * i + o[8] * r, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Bn = /* @__PURE__ */ new Mt();
Mt.NAMES = V0;
let Cb = 0;
class Gr extends Br {
  static get type() {
    return "Material";
  }
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: Cb++ }), this.uuid = Vr(), this.name = "", this.blending = Ni, this.side = er, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Vc, this.blendDst = el, this.blendEquation = Oi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Mt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Io, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = Gp, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = jr, this.stencilZFail = jr, this.stencilZPass = jr, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const i = e[n];
        if (i === void 0) {
          console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);
          continue;
        }
        const r = this[n];
        if (r === void 0) {
          console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[n] = i;
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = {
      textures: {},
      images: {}
    });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Ni && (i.blending = this.blending), this.side !== er && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== Vc && (i.blendSrc = this.blendSrc), this.blendDst !== el && (i.blendDst = this.blendDst), this.blendEquation !== Oi && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Io && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== Gp && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== jr && (i.stencilFail = this.stencilFail), this.stencilZFail !== jr && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== jr && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(o) {
      const a = [];
      for (const l in o) {
        const c = o[l];
        delete c.metadata, a.push(c);
      }
      return a;
    }
    if (n) {
      const o = r(e.textures), a = r(e.images);
      o.length > 0 && (i.textures = o), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const r = n.length;
      i = new Array(r);
      for (let o = 0; o !== r; ++o)
        i[o] = n[o].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class Mn extends Gr {
  static get type() {
    return "MeshBasicMaterial";
  }
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new wi(), this.combine = b0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Sn = /* @__PURE__ */ new ce(), Nl = /* @__PURE__ */ new st();
class bi {
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = i, this.usage = Hp, this.updateRanges = [], this.gpuType = ui, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({ start: e, count: n });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, n, i) {
    e *= this.itemSize, i *= n.itemSize;
    for (let r = 0, o = this.itemSize; r < o; r++)
      this.array[e + r] = n.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        Nl.fromBufferAttribute(this, n), Nl.applyMatrix3(e), this.setXY(n, Nl.x, Nl.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        Sn.fromBufferAttribute(this, n), Sn.applyMatrix3(e), this.setXYZ(n, Sn.x, Sn.y, Sn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Sn.fromBufferAttribute(this, n), Sn.applyMatrix4(e), this.setXYZ(n, Sn.x, Sn.y, Sn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Sn.fromBufferAttribute(this, n), Sn.applyNormalMatrix(e), this.setXYZ(n, Sn.x, Sn.y, Sn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      Sn.fromBufferAttribute(this, n), Sn.transformDirection(e), this.setXYZ(n, Sn.x, Sn.y, Sn.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = po(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return this.normalized && (i = Zn(i, this.array)), this.array[e * this.itemSize + n] = i, this;
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = po(n, this.array)), n;
  }
  setX(e, n) {
    return this.normalized && (n = Zn(n, this.array)), this.array[e * this.itemSize] = n, this;
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = po(n, this.array)), n;
  }
  setY(e, n) {
    return this.normalized && (n = Zn(n, this.array)), this.array[e * this.itemSize + 1] = n, this;
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = po(n, this.array)), n;
  }
  setZ(e, n) {
    return this.normalized && (n = Zn(n, this.array)), this.array[e * this.itemSize + 2] = n, this;
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = po(n, this.array)), n;
  }
  setW(e, n) {
    return this.normalized && (n = Zn(n, this.array)), this.array[e * this.itemSize + 3] = n, this;
  }
  setXY(e, n, i) {
    return e *= this.itemSize, this.normalized && (n = Zn(n, this.array), i = Zn(i, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this;
  }
  setXYZ(e, n, i, r) {
    return e *= this.itemSize, this.normalized && (n = Zn(n, this.array), i = Zn(i, this.array), r = Zn(r, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, n, i, r, o) {
    return e *= this.itemSize, this.normalized && (n = Zn(n, this.array), i = Zn(i, this.array), r = Zn(r, this.array), o = Zn(o, this.array)), this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = o, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Hp && (e.usage = this.usage), e;
  }
}
class G0 extends bi {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class H0 extends bi {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class Pt extends bi {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let Eb = 0;
const Si = /* @__PURE__ */ new Zt(), ld = /* @__PURE__ */ new ln(), so = /* @__PURE__ */ new ce(), yi = /* @__PURE__ */ new rr(), la = /* @__PURE__ */ new rr(), Tn = /* @__PURE__ */ new ce();
class Nt extends Br {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: Eb++ }), this.uuid = Vr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (z0(e) ? H0 : G0)(e, 1) : this.index = e, this;
  }
  setIndirect(e) {
    return this.indirect = e, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: i
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = !0);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const o = new Et().getNormalMatrix(e);
      i.applyNormalMatrix(o), i.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Si.makeRotationFromQuaternion(e), this.applyMatrix4(Si), this;
  }
  rotateX(e) {
    return Si.makeRotationX(e), this.applyMatrix4(Si), this;
  }
  rotateY(e) {
    return Si.makeRotationY(e), this.applyMatrix4(Si), this;
  }
  rotateZ(e) {
    return Si.makeRotationZ(e), this.applyMatrix4(Si), this;
  }
  translate(e, n, i) {
    return Si.makeTranslation(e, n, i), this.applyMatrix4(Si), this;
  }
  scale(e, n, i) {
    return Si.makeScale(e, n, i), this.applyMatrix4(Si), this;
  }
  lookAt(e) {
    return ld.lookAt(e), ld.updateMatrix(), this.applyMatrix4(ld.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(so).negate(), this.translate(so.x, so.y, so.z), this;
  }
  setFromPoints(e) {
    const n = this.getAttribute("position");
    if (n === void 0) {
      const i = [];
      for (let r = 0, o = e.length; r < o; r++) {
        const a = e[r];
        i.push(a.x, a.y, a.z || 0);
      }
      this.setAttribute("position", new Pt(i, 3));
    } else {
      for (let i = 0, r = n.count; i < r; i++) {
        const o = e[i];
        n.setXYZ(i, o.x, o.y, o.z || 0);
      }
      e.length > n.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), n.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new rr());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new ce(-1 / 0, -1 / 0, -1 / 0),
        new ce(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n)
        for (let i = 0, r = n.length; i < r; i++) {
          const o = n[i];
          yi.setFromBufferAttribute(o), this.morphTargetsRelative ? (Tn.addVectors(this.boundingBox.min, yi.min), this.boundingBox.expandByPoint(Tn), Tn.addVectors(this.boundingBox.max, yi.max), this.boundingBox.expandByPoint(Tn)) : (this.boundingBox.expandByPoint(yi.min), this.boundingBox.expandByPoint(yi.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new pl());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new ce(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (yi.setFromBufferAttribute(e), n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o];
          la.setFromBufferAttribute(l), this.morphTargetsRelative ? (Tn.addVectors(yi.min, la.min), yi.expandByPoint(Tn), Tn.addVectors(yi.max, la.max), yi.expandByPoint(Tn)) : (yi.expandByPoint(la.min), yi.expandByPoint(la.max));
        }
      yi.getCenter(i);
      let r = 0;
      for (let o = 0, a = e.count; o < a; o++)
        Tn.fromBufferAttribute(e, o), r = Math.max(r, i.distanceToSquared(Tn));
      if (n)
        for (let o = 0, a = n.length; o < a; o++) {
          const l = n[o], c = this.morphTargetsRelative;
          for (let u = 0, d = l.count; u < d; u++)
            Tn.fromBufferAttribute(l, u), c && (so.fromBufferAttribute(e, u), Tn.add(so)), r = Math.max(r, i.distanceToSquared(Tn));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = n.position, r = n.normal, o = n.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new bi(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute("tangent"), l = [], c = [];
    for (let T = 0; T < i.count; T++)
      l[T] = new ce(), c[T] = new ce();
    const u = new ce(), d = new ce(), h = new ce(), m = new st(), p = new st(), y = new st(), _ = new ce(), v = new ce();
    function g(T, b, M) {
      u.fromBufferAttribute(i, T), d.fromBufferAttribute(i, b), h.fromBufferAttribute(i, M), m.fromBufferAttribute(o, T), p.fromBufferAttribute(o, b), y.fromBufferAttribute(o, M), d.sub(u), h.sub(u), p.sub(m), y.sub(m);
      const L = 1 / (p.x * y.y - y.x * p.y);
      isFinite(L) && (_.copy(d).multiplyScalar(y.y).addScaledVector(h, -p.y).multiplyScalar(L), v.copy(h).multiplyScalar(p.x).addScaledVector(d, -y.x).multiplyScalar(L), l[T].add(_), l[b].add(_), l[M].add(_), c[T].add(v), c[b].add(v), c[M].add(v));
    }
    let S = this.groups;
    S.length === 0 && (S = [{
      start: 0,
      count: e.count
    }]);
    for (let T = 0, b = S.length; T < b; ++T) {
      const M = S[T], L = M.start, N = M.count;
      for (let D = L, O = L + N; D < O; D += 3)
        g(
          e.getX(D + 0),
          e.getX(D + 1),
          e.getX(D + 2)
        );
    }
    const w = new ce(), x = new ce(), C = new ce(), E = new ce();
    function P(T) {
      C.fromBufferAttribute(r, T), E.copy(C);
      const b = l[T];
      w.copy(b), w.sub(C.multiplyScalar(C.dot(b))).normalize(), x.crossVectors(E, b);
      const L = x.dot(c[T]) < 0 ? -1 : 1;
      a.setXYZW(T, w.x, w.y, w.z, L);
    }
    for (let T = 0, b = S.length; T < b; ++T) {
      const M = S[T], L = M.start, N = M.count;
      for (let D = L, O = L + N; D < O; D += 3)
        P(e.getX(D + 0)), P(e.getX(D + 1)), P(e.getX(D + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        i = new bi(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
      else
        for (let m = 0, p = i.count; m < p; m++)
          i.setXYZ(m, 0, 0, 0);
      const r = new ce(), o = new ce(), a = new ce(), l = new ce(), c = new ce(), u = new ce(), d = new ce(), h = new ce();
      if (e)
        for (let m = 0, p = e.count; m < p; m += 3) {
          const y = e.getX(m + 0), _ = e.getX(m + 1), v = e.getX(m + 2);
          r.fromBufferAttribute(n, y), o.fromBufferAttribute(n, _), a.fromBufferAttribute(n, v), d.subVectors(a, o), h.subVectors(r, o), d.cross(h), l.fromBufferAttribute(i, y), c.fromBufferAttribute(i, _), u.fromBufferAttribute(i, v), l.add(d), c.add(d), u.add(d), i.setXYZ(y, l.x, l.y, l.z), i.setXYZ(_, c.x, c.y, c.z), i.setXYZ(v, u.x, u.y, u.z);
        }
      else
        for (let m = 0, p = n.count; m < p; m += 3)
          r.fromBufferAttribute(n, m + 0), o.fromBufferAttribute(n, m + 1), a.fromBufferAttribute(n, m + 2), d.subVectors(a, o), h.subVectors(r, o), d.cross(h), i.setXYZ(m + 0, d.x, d.y, d.z), i.setXYZ(m + 1, d.x, d.y, d.z), i.setXYZ(m + 2, d.x, d.y, d.z);
      this.normalizeNormals(), i.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      Tn.fromBufferAttribute(e, n), Tn.normalize(), e.setXYZ(n, Tn.x, Tn.y, Tn.z);
  }
  toNonIndexed() {
    function e(l, c) {
      const u = l.array, d = l.itemSize, h = l.normalized, m = new u.constructor(c.length * d);
      let p = 0, y = 0;
      for (let _ = 0, v = c.length; _ < v; _++) {
        l.isInterleavedBufferAttribute ? p = c[_] * l.data.stride + l.offset : p = c[_] * d;
        for (let g = 0; g < d; g++)
          m[y++] = u[p++];
      }
      return new bi(m, d, h);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new Nt(), i = this.index.array, r = this.attributes;
    for (const l in r) {
      const c = r[l], u = e(c, i);
      n.setAttribute(l, u);
    }
    const o = this.morphAttributes;
    for (const l in o) {
      const c = [], u = o[l];
      for (let d = 0, h = u.length; d < h; d++) {
        const m = u[d], p = e(m, i);
        c.push(p);
      }
      n.morphAttributes[l] = c;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let l = 0, c = a.length; l < c; l++) {
      const u = a[l];
      n.addGroup(u.start, u.count, u.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const c = this.parameters;
      for (const u in c)
        c[u] !== void 0 && (e[u] = c[u]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = {
      type: n.array.constructor.name,
      array: Array.prototype.slice.call(n.array)
    });
    const i = this.attributes;
    for (const c in i) {
      const u = i[c];
      e.data.attributes[c] = u.toJSON(e.data);
    }
    const r = {};
    let o = !1;
    for (const c in this.morphAttributes) {
      const u = this.morphAttributes[c], d = [];
      for (let h = 0, m = u.length; h < m; h++) {
        const p = u[h];
        d.push(p.toJSON(e.data));
      }
      d.length > 0 && (r[c] = d, o = !0);
    }
    o && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const l = this.boundingSphere;
    return l !== null && (e.data.boundingSphere = {
      center: l.center.toArray(),
      radius: l.radius
    }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const r = e.attributes;
    for (const u in r) {
      const d = r[u];
      this.setAttribute(u, d.clone(n));
    }
    const o = e.morphAttributes;
    for (const u in o) {
      const d = [], h = o[u];
      for (let m = 0, p = h.length; m < p; m++)
        d.push(h[m].clone(n));
      this.morphAttributes[u] = d;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let u = 0, d = a.length; u < d; u++) {
      const h = a[u];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const l = e.boundingBox;
    l !== null && (this.boundingBox = l.clone());
    const c = e.boundingSphere;
    return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const am = /* @__PURE__ */ new Zt(), hr = /* @__PURE__ */ new wf(), Bl = /* @__PURE__ */ new pl(), lm = /* @__PURE__ */ new ce(), Vl = /* @__PURE__ */ new ce(), Gl = /* @__PURE__ */ new ce(), Hl = /* @__PURE__ */ new ce(), cd = /* @__PURE__ */ new ce(), Wl = /* @__PURE__ */ new ce(), cm = /* @__PURE__ */ new ce(), $l = /* @__PURE__ */ new ce();
class qe extends ln {
  constructor(e = new Nt(), n = new Mn()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = r.length; o < a; o++) {
          const l = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const i = this.geometry, r = i.attributes.position, o = i.morphAttributes.position, a = i.morphTargetsRelative;
    n.fromBufferAttribute(r, e);
    const l = this.morphTargetInfluences;
    if (o && l) {
      Wl.set(0, 0, 0);
      for (let c = 0, u = o.length; c < u; c++) {
        const d = l[c], h = o[c];
        d !== 0 && (cd.fromBufferAttribute(h, e), a ? Wl.addScaledVector(cd, d) : Wl.addScaledVector(cd.sub(n), d));
      }
      n.add(Wl);
    }
    return n;
  }
  raycast(e, n) {
    const i = this.geometry, r = this.material, o = this.matrixWorld;
    r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Bl.copy(i.boundingSphere), Bl.applyMatrix4(o), hr.copy(e.ray).recast(e.near), !(Bl.containsPoint(hr.origin) === !1 && (hr.intersectSphere(Bl, lm) === null || hr.origin.distanceToSquared(lm) > (e.far - e.near) ** 2)) && (am.copy(o).invert(), hr.copy(e.ray).applyMatrix4(am), !(i.boundingBox !== null && hr.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, n, hr)));
  }
  _computeIntersections(e, n, i) {
    let r;
    const o = this.geometry, a = this.material, l = o.index, c = o.attributes.position, u = o.attributes.uv, d = o.attributes.uv1, h = o.attributes.normal, m = o.groups, p = o.drawRange;
    if (l !== null)
      if (Array.isArray(a))
        for (let y = 0, _ = m.length; y < _; y++) {
          const v = m[y], g = a[v.materialIndex], S = Math.max(v.start, p.start), w = Math.min(l.count, Math.min(v.start + v.count, p.start + p.count));
          for (let x = S, C = w; x < C; x += 3) {
            const E = l.getX(x), P = l.getX(x + 1), T = l.getX(x + 2);
            r = Xl(this, g, e, i, u, d, h, E, P, T), r && (r.faceIndex = Math.floor(x / 3), r.face.materialIndex = v.materialIndex, n.push(r));
          }
        }
      else {
        const y = Math.max(0, p.start), _ = Math.min(l.count, p.start + p.count);
        for (let v = y, g = _; v < g; v += 3) {
          const S = l.getX(v), w = l.getX(v + 1), x = l.getX(v + 2);
          r = Xl(this, a, e, i, u, d, h, S, w, x), r && (r.faceIndex = Math.floor(v / 3), n.push(r));
        }
      }
    else if (c !== void 0)
      if (Array.isArray(a))
        for (let y = 0, _ = m.length; y < _; y++) {
          const v = m[y], g = a[v.materialIndex], S = Math.max(v.start, p.start), w = Math.min(c.count, Math.min(v.start + v.count, p.start + p.count));
          for (let x = S, C = w; x < C; x += 3) {
            const E = x, P = x + 1, T = x + 2;
            r = Xl(this, g, e, i, u, d, h, E, P, T), r && (r.faceIndex = Math.floor(x / 3), r.face.materialIndex = v.materialIndex, n.push(r));
          }
        }
      else {
        const y = Math.max(0, p.start), _ = Math.min(c.count, p.start + p.count);
        for (let v = y, g = _; v < g; v += 3) {
          const S = v, w = v + 1, x = v + 2;
          r = Xl(this, a, e, i, u, d, h, S, w, x), r && (r.faceIndex = Math.floor(v / 3), n.push(r));
        }
      }
  }
}
function Tb(s, e, n, i, r, o, a, l) {
  let c;
  if (e.side === di ? c = i.intersectTriangle(a, o, r, !0, l) : c = i.intersectTriangle(r, o, a, e.side === er, l), c === null) return null;
  $l.copy(l), $l.applyMatrix4(s.matrixWorld);
  const u = n.ray.origin.distanceTo($l);
  return u < n.near || u > n.far ? null : {
    distance: u,
    point: $l.clone(),
    object: s
  };
}
function Xl(s, e, n, i, r, o, a, l, c, u) {
  s.getVertexPosition(l, Vl), s.getVertexPosition(c, Gl), s.getVertexPosition(u, Hl);
  const d = Tb(s, e, n, i, Vl, Gl, Hl, cm);
  if (d) {
    const h = new ce();
    zi.getBarycoord(cm, Vl, Gl, Hl, h), r && (d.uv = zi.getInterpolatedAttribute(r, l, c, u, h, new st())), o && (d.uv1 = zi.getInterpolatedAttribute(o, l, c, u, h, new st())), a && (d.normal = zi.getInterpolatedAttribute(a, l, c, u, h, new ce()), d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
    const m = {
      a: l,
      b: c,
      c: u,
      normal: new ce(),
      materialIndex: 0
    };
    zi.getNormal(Vl, Gl, Hl, m.normal), d.face = m, d.barycoord = h;
  }
  return d;
}
class hn extends Nt {
  constructor(e = 1, n = 1, i = 1, r = 1, o = 1, a = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: n,
      depth: i,
      widthSegments: r,
      heightSegments: o,
      depthSegments: a
    };
    const l = this;
    r = Math.floor(r), o = Math.floor(o), a = Math.floor(a);
    const c = [], u = [], d = [], h = [];
    let m = 0, p = 0;
    y("z", "y", "x", -1, -1, i, n, e, a, o, 0), y("z", "y", "x", 1, -1, i, n, -e, a, o, 1), y("x", "z", "y", 1, 1, e, i, n, r, a, 2), y("x", "z", "y", 1, -1, e, i, -n, r, a, 3), y("x", "y", "z", 1, -1, e, n, i, r, o, 4), y("x", "y", "z", -1, -1, e, n, -i, r, o, 5), this.setIndex(c), this.setAttribute("position", new Pt(u, 3)), this.setAttribute("normal", new Pt(d, 3)), this.setAttribute("uv", new Pt(h, 2));
    function y(_, v, g, S, w, x, C, E, P, T, b) {
      const M = x / P, L = C / T, N = x / 2, D = C / 2, O = E / 2, A = P + 1, G = T + 1;
      let he = 0, ee = 0;
      const le = new ce();
      for (let oe = 0; oe < G; oe++) {
        const Y = oe * L - D;
        for (let j = 0; j < A; j++) {
          const q = j * M - N;
          le[_] = q * S, le[v] = Y * w, le[g] = O, u.push(le.x, le.y, le.z), le[_] = 0, le[v] = 0, le[g] = E > 0 ? 1 : -1, d.push(le.x, le.y, le.z), h.push(j / P), h.push(1 - oe / T), he += 1;
        }
      }
      for (let oe = 0; oe < T; oe++)
        for (let Y = 0; Y < P; Y++) {
          const j = m + Y + A * oe, q = m + Y + A * (oe + 1), te = m + (Y + 1) + A * (oe + 1), ne = m + (Y + 1) + A * oe;
          c.push(j, q, ne), c.push(q, te, ne), ee += 6;
        }
      l.addGroup(p, ee, b), p += ee, m += he;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new hn(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function zo(s) {
  const e = {};
  for (const n in s) {
    e[n] = {};
    for (const i in s[n]) {
      const r = s[n][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[n][i] = null) : e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r;
    }
  }
  return e;
}
function Kn(s) {
  const e = {};
  for (let n = 0; n < s.length; n++) {
    const i = zo(s[n]);
    for (const r in i)
      e[r] = i[r];
  }
  return e;
}
function Ab(s) {
  const e = [];
  for (let n = 0; n < s.length; n++)
    e.push(s[n].clone());
  return e;
}
function W0(s) {
  const e = s.getRenderTarget();
  return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : kt.workingColorSpace;
}
const ml = { clone: zo, merge: Kn };
var Pb = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Db = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Fn extends Gr {
  static get type() {
    return "ShaderMaterial";
  }
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Pb, this.fragmentShader = Db, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = zo(e.uniforms), this.uniformsGroups = Ab(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    n.glslVersion = this.glslVersion, n.uniforms = {};
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture ? n.uniforms[r] = {
        type: "t",
        value: a.toJSON(e).uuid
      } : a && a.isColor ? n.uniforms[r] = {
        type: "c",
        value: a.getHex()
      } : a && a.isVector2 ? n.uniforms[r] = {
        type: "v2",
        value: a.toArray()
      } : a && a.isVector3 ? n.uniforms[r] = {
        type: "v3",
        value: a.toArray()
      } : a && a.isVector4 ? n.uniforms[r] = {
        type: "v4",
        value: a.toArray()
      } : a && a.isMatrix3 ? n.uniforms[r] = {
        type: "m3",
        value: a.toArray()
      } : a && a.isMatrix4 ? n.uniforms[r] = {
        type: "m4",
        value: a.toArray()
      } : n.uniforms[r] = {
        value: a
      };
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n.lights = this.lights, n.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class $0 extends ln {
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Zt(), this.projectionMatrix = new Zt(), this.projectionMatrixInverse = new Zt(), this.coordinateSystem = bs;
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Bs = /* @__PURE__ */ new ce(), um = /* @__PURE__ */ new st(), dm = /* @__PURE__ */ new st();
class ci extends $0 {
  constructor(e = 50, n = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = Oo * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const e = Math.tan(Fa * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Oo * 2 * Math.atan(
      Math.tan(Fa * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(e, n, i) {
    Bs.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Bs.x, Bs.y).multiplyScalar(-e / Bs.z), Bs.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Bs.x, Bs.y).multiplyScalar(-e / Bs.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(e, n) {
    return this.getViewBounds(e, um, dm), n.subVectors(dm, um);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(e, n, i, r, o, a) {
    this.aspect = e / n, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = r, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(Fa * 0.5 * this.fov) / this.zoom, i = 2 * n, r = this.aspect * i, o = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const c = a.fullWidth, u = a.fullHeight;
      o += a.offsetX * r / c, n -= a.offsetY * i / u, r *= a.width / c, i *= a.height / u;
    }
    const l = this.filmOffset;
    l !== 0 && (o += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, n, n - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
const ro = -90, oo = 1;
class Rb extends ln {
  constructor(e, n, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new ci(ro, oo, e, n);
    r.layers = this.layers, this.add(r);
    const o = new ci(ro, oo, e, n);
    o.layers = this.layers, this.add(o);
    const a = new ci(ro, oo, e, n);
    a.layers = this.layers, this.add(a);
    const l = new ci(ro, oo, e, n);
    l.layers = this.layers, this.add(l);
    const c = new ci(ro, oo, e, n);
    c.layers = this.layers, this.add(c);
    const u = new ci(ro, oo, e, n);
    u.layers = this.layers, this.add(u);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, n = this.children.concat(), [i, r, o, a, l, c] = n;
    for (const u of n) this.remove(u);
    if (e === bs)
      i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
    else if (e === Hc)
      i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const u of n)
      this.add(u), u.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, a, l, c, u, d] = this.children, h = e.getRenderTarget(), m = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), y = e.xr.enabled;
    e.xr.enabled = !1;
    const _ = i.texture.generateMipmaps;
    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, r), e.render(n, o), e.setRenderTarget(i, 1, r), e.render(n, a), e.setRenderTarget(i, 2, r), e.render(n, l), e.setRenderTarget(i, 3, r), e.render(n, c), e.setRenderTarget(i, 4, r), e.render(n, u), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, r), e.render(n, d), e.setRenderTarget(h, m, p), e.xr.enabled = y, i.texture.needsPMREMUpdate = !0;
  }
}
class X0 extends yn {
  constructor(e, n, i, r, o, a, l, c, u, d) {
    e = e !== void 0 ? e : [], n = n !== void 0 ? n : ko, super(e, n, i, r, o, a, l, c, u, d), this.isCubeTexture = !0, this.flipY = !1;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Ib extends Hi {
  constructor(e = 1, n = {}) {
    super(e, e, n), this.isWebGLCubeRenderTarget = !0;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    this.texture = new X0(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Xt;
  }
  fromEquirectangularTexture(e, n) {
    this.texture.type = n.type, this.texture.colorSpace = n.colorSpace, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
    const i = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new hn(5, 5, 5), o = new Fn({
      name: "CubemapFromEquirect",
      uniforms: zo(i.uniforms),
      vertexShader: i.vertexShader,
      fragmentShader: i.fragmentShader,
      side: di,
      blending: ts
    });
    o.uniforms.tEquirect.value = n;
    const a = new qe(r, o), l = n.minFilter;
    return n.minFilter === Rr && (n.minFilter = Xt), new Rb(1, 10, this).update(e, a), n.minFilter = l, a.geometry.dispose(), a.material.dispose(), this;
  }
  clear(e, n, i, r) {
    const o = e.getRenderTarget();
    for (let a = 0; a < 6; a++)
      e.setRenderTarget(this, a), e.clear(n, i, r);
    e.setRenderTarget(o);
  }
}
const ud = /* @__PURE__ */ new ce(), kb = /* @__PURE__ */ new ce(), Lb = /* @__PURE__ */ new Et();
class br {
  constructor(e = new ce(1, 0, 0), n = 0) {
    this.isPlane = !0, this.normal = e, this.constant = n;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, i, r) {
    return this.normal.set(e, n, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const r = ud.subVectors(i, n).cross(kb.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const i = e.delta(ud), r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / r;
    return o < 0 || o > 1 ? null : n.copy(e.start).addScaledVector(i, o);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return n < 0 && i > 0 || i < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || Lb.getNormalMatrix(e), r = this.coplanarPoint(ud).applyMatrix4(e), o = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(o), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const fr = /* @__PURE__ */ new pl(), jl = /* @__PURE__ */ new ce();
class Mf {
  constructor(e = new br(), n = new br(), i = new br(), r = new br(), o = new br(), a = new br()) {
    this.planes = [e, n, i, r, o, a];
  }
  set(e, n, i, r, o, a) {
    const l = this.planes;
    return l[0].copy(e), l[1].copy(n), l[2].copy(i), l[3].copy(r), l[4].copy(o), l[5].copy(a), this;
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, n = bs) {
    const i = this.planes, r = e.elements, o = r[0], a = r[1], l = r[2], c = r[3], u = r[4], d = r[5], h = r[6], m = r[7], p = r[8], y = r[9], _ = r[10], v = r[11], g = r[12], S = r[13], w = r[14], x = r[15];
    if (i[0].setComponents(c - o, m - u, v - p, x - g).normalize(), i[1].setComponents(c + o, m + u, v + p, x + g).normalize(), i[2].setComponents(c + a, m + d, v + y, x + S).normalize(), i[3].setComponents(c - a, m - d, v - y, x - S).normalize(), i[4].setComponents(c - l, m - h, v - _, x - w).normalize(), n === bs)
      i[5].setComponents(c + l, m + h, v + _, x + w).normalize();
    else if (n === Hc)
      i[5].setComponents(l, h, _, w).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + n);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), fr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(), fr.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(fr);
  }
  intersectsSprite(e) {
    return fr.center.set(0, 0, 0), fr.radius = 0.7071067811865476, fr.applyMatrix4(e.matrixWorld), this.intersectsSphere(fr);
  }
  intersectsSphere(e) {
    const n = this.planes, i = e.center, r = -e.radius;
    for (let o = 0; o < 6; o++)
      if (n[o].distanceToPoint(i) < r)
        return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = n[i];
      if (jl.x = r.normal.x > 0 ? e.max.x : e.min.x, jl.y = r.normal.y > 0 ? e.max.y : e.min.y, jl.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(jl) < 0)
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++)
      if (n[i].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function j0() {
  let s = null, e = !1, n = null, i = null;
  function r(o, a) {
    n(o, a), i = s.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && n !== null && (i = s.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      s.cancelAnimationFrame(i), e = !1;
    },
    setAnimationLoop: function(o) {
      n = o;
    },
    setContext: function(o) {
      s = o;
    }
  };
}
function Fb(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function n(l, c) {
    const u = l.array, d = l.usage, h = u.byteLength, m = s.createBuffer();
    s.bindBuffer(c, m), s.bufferData(c, u, d), l.onUploadCallback();
    let p;
    if (u instanceof Float32Array)
      p = s.FLOAT;
    else if (u instanceof Uint16Array)
      l.isFloat16BufferAttribute ? p = s.HALF_FLOAT : p = s.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      p = s.SHORT;
    else if (u instanceof Uint32Array)
      p = s.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      p = s.INT;
    else if (u instanceof Int8Array)
      p = s.BYTE;
    else if (u instanceof Uint8Array)
      p = s.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      p = s.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: m,
      type: p,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: l.version,
      size: h
    };
  }
  function i(l, c, u) {
    const d = c.array, h = c.updateRanges;
    if (s.bindBuffer(u, l), h.length === 0)
      s.bufferSubData(u, 0, d);
    else {
      h.sort((p, y) => p.start - y.start);
      let m = 0;
      for (let p = 1; p < h.length; p++) {
        const y = h[m], _ = h[p];
        _.start <= y.start + y.count + 1 ? y.count = Math.max(
          y.count,
          _.start + _.count - y.start
        ) : (++m, h[m] = _);
      }
      h.length = m + 1;
      for (let p = 0, y = h.length; p < y; p++) {
        const _ = h[p];
        s.bufferSubData(
          u,
          _.start * d.BYTES_PER_ELEMENT,
          d,
          _.start,
          _.count
        );
      }
      c.clearUpdateRanges();
    }
    c.onUploadCallback();
  }
  function r(l) {
    return l.isInterleavedBufferAttribute && (l = l.data), e.get(l);
  }
  function o(l) {
    l.isInterleavedBufferAttribute && (l = l.data);
    const c = e.get(l);
    c && (s.deleteBuffer(c.buffer), e.delete(l));
  }
  function a(l, c) {
    if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
      const d = e.get(l);
      (!d || d.version < l.version) && e.set(l, {
        buffer: l.buffer,
        type: l.type,
        bytesPerElement: l.elementSize,
        version: l.version
      });
      return;
    }
    const u = e.get(l);
    if (u === void 0)
      e.set(l, n(l, c));
    else if (u.version < l.version) {
      if (u.size !== l.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      i(u.buffer, l, c), u.version = l.version;
    }
  }
  return {
    get: r,
    remove: o,
    update: a
  };
}
class cn extends Nt {
  constructor(e = 1, n = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: n,
      widthSegments: i,
      heightSegments: r
    };
    const o = e / 2, a = n / 2, l = Math.floor(i), c = Math.floor(r), u = l + 1, d = c + 1, h = e / l, m = n / c, p = [], y = [], _ = [], v = [];
    for (let g = 0; g < d; g++) {
      const S = g * m - a;
      for (let w = 0; w < u; w++) {
        const x = w * h - o;
        y.push(x, -S, 0), _.push(0, 0, 1), v.push(w / l), v.push(1 - g / c);
      }
    }
    for (let g = 0; g < c; g++)
      for (let S = 0; S < l; S++) {
        const w = S + u * g, x = S + u * (g + 1), C = S + 1 + u * (g + 1), E = S + 1 + u * g;
        p.push(w, x, E), p.push(x, C, E);
      }
    this.setIndex(p), this.setAttribute("position", new Pt(y, 3)), this.setAttribute("normal", new Pt(_, 3)), this.setAttribute("uv", new Pt(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new cn(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var Ub = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, Ob = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, zb = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, Nb = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Bb = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, Vb = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, Gb = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, Hb = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, Wb = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, $b = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, Xb = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, jb = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, Yb = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, qb = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Zb = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Kb = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, Jb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Qb = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, ew = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, tw = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, nw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, iw = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, sw = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, rw = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, ow = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, aw = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, lw = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, cw = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, uw = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, dw = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, hw = "gl_FragColor = linearToOutputTexel( gl_FragColor );", fw = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, pw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, mw = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, vw = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, gw = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, yw = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, _w = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, xw = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, bw = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, ww = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Sw = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Mw = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Cw = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, Ew = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Tw = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Aw = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Pw = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Dw = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Rw = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Iw = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, kw = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Lw = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Fw = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Uw = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Ow = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, zw = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Nw = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Bw = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Vw = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Gw = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, Hw = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, Ww = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, $w = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Xw = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, jw = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, Yw = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, qw = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Zw = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Kw = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Jw = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Qw = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, eS = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, tS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, nS = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, iS = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, sS = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, rS = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, oS = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, aS = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, lS = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, cS = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, uS = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, dS = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, hS = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, fS = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, pS = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, mS = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, vS = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, gS = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, yS = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, _S = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, xS = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, bS = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, wS = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, SS = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, MS = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, CS = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, ES = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, TS = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, AS = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, PS = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, DS = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, RS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, IS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, kS = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, LS = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const FS = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, US = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, OS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, zS = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, NS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, BS = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, VS = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, GS = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, HS = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, WS = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, $S = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, XS = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, jS = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, YS = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, qS = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, ZS = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, KS = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, JS = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, QS = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, eM = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, tM = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, nM = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, iM = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, sM = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, rM = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, oM = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, aM = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, lM = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, cM = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, uM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, dM = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, hM = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, fM = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, pM = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Tt = {
  alphahash_fragment: Ub,
  alphahash_pars_fragment: Ob,
  alphamap_fragment: zb,
  alphamap_pars_fragment: Nb,
  alphatest_fragment: Bb,
  alphatest_pars_fragment: Vb,
  aomap_fragment: Gb,
  aomap_pars_fragment: Hb,
  batching_pars_vertex: Wb,
  batching_vertex: $b,
  begin_vertex: Xb,
  beginnormal_vertex: jb,
  bsdfs: Yb,
  iridescence_fragment: qb,
  bumpmap_pars_fragment: Zb,
  clipping_planes_fragment: Kb,
  clipping_planes_pars_fragment: Jb,
  clipping_planes_pars_vertex: Qb,
  clipping_planes_vertex: ew,
  color_fragment: tw,
  color_pars_fragment: nw,
  color_pars_vertex: iw,
  color_vertex: sw,
  common: rw,
  cube_uv_reflection_fragment: ow,
  defaultnormal_vertex: aw,
  displacementmap_pars_vertex: lw,
  displacementmap_vertex: cw,
  emissivemap_fragment: uw,
  emissivemap_pars_fragment: dw,
  colorspace_fragment: hw,
  colorspace_pars_fragment: fw,
  envmap_fragment: pw,
  envmap_common_pars_fragment: mw,
  envmap_pars_fragment: vw,
  envmap_pars_vertex: gw,
  envmap_physical_pars_fragment: Aw,
  envmap_vertex: yw,
  fog_vertex: _w,
  fog_pars_vertex: xw,
  fog_fragment: bw,
  fog_pars_fragment: ww,
  gradientmap_pars_fragment: Sw,
  lightmap_pars_fragment: Mw,
  lights_lambert_fragment: Cw,
  lights_lambert_pars_fragment: Ew,
  lights_pars_begin: Tw,
  lights_toon_fragment: Pw,
  lights_toon_pars_fragment: Dw,
  lights_phong_fragment: Rw,
  lights_phong_pars_fragment: Iw,
  lights_physical_fragment: kw,
  lights_physical_pars_fragment: Lw,
  lights_fragment_begin: Fw,
  lights_fragment_maps: Uw,
  lights_fragment_end: Ow,
  logdepthbuf_fragment: zw,
  logdepthbuf_pars_fragment: Nw,
  logdepthbuf_pars_vertex: Bw,
  logdepthbuf_vertex: Vw,
  map_fragment: Gw,
  map_pars_fragment: Hw,
  map_particle_fragment: Ww,
  map_particle_pars_fragment: $w,
  metalnessmap_fragment: Xw,
  metalnessmap_pars_fragment: jw,
  morphinstance_vertex: Yw,
  morphcolor_vertex: qw,
  morphnormal_vertex: Zw,
  morphtarget_pars_vertex: Kw,
  morphtarget_vertex: Jw,
  normal_fragment_begin: Qw,
  normal_fragment_maps: eS,
  normal_pars_fragment: tS,
  normal_pars_vertex: nS,
  normal_vertex: iS,
  normalmap_pars_fragment: sS,
  clearcoat_normal_fragment_begin: rS,
  clearcoat_normal_fragment_maps: oS,
  clearcoat_pars_fragment: aS,
  iridescence_pars_fragment: lS,
  opaque_fragment: cS,
  packing: uS,
  premultiplied_alpha_fragment: dS,
  project_vertex: hS,
  dithering_fragment: fS,
  dithering_pars_fragment: pS,
  roughnessmap_fragment: mS,
  roughnessmap_pars_fragment: vS,
  shadowmap_pars_fragment: gS,
  shadowmap_pars_vertex: yS,
  shadowmap_vertex: _S,
  shadowmask_pars_fragment: xS,
  skinbase_vertex: bS,
  skinning_pars_vertex: wS,
  skinning_vertex: SS,
  skinnormal_vertex: MS,
  specularmap_fragment: CS,
  specularmap_pars_fragment: ES,
  tonemapping_fragment: TS,
  tonemapping_pars_fragment: AS,
  transmission_fragment: PS,
  transmission_pars_fragment: DS,
  uv_pars_fragment: RS,
  uv_pars_vertex: IS,
  uv_vertex: kS,
  worldpos_vertex: LS,
  background_vert: FS,
  background_frag: US,
  backgroundCube_vert: OS,
  backgroundCube_frag: zS,
  cube_vert: NS,
  cube_frag: BS,
  depth_vert: VS,
  depth_frag: GS,
  distanceRGBA_vert: HS,
  distanceRGBA_frag: WS,
  equirect_vert: $S,
  equirect_frag: XS,
  linedashed_vert: jS,
  linedashed_frag: YS,
  meshbasic_vert: qS,
  meshbasic_frag: ZS,
  meshlambert_vert: KS,
  meshlambert_frag: JS,
  meshmatcap_vert: QS,
  meshmatcap_frag: eM,
  meshnormal_vert: tM,
  meshnormal_frag: nM,
  meshphong_vert: iM,
  meshphong_frag: sM,
  meshphysical_vert: rM,
  meshphysical_frag: oM,
  meshtoon_vert: aM,
  meshtoon_frag: lM,
  points_vert: cM,
  points_frag: uM,
  shadow_vert: dM,
  shadow_frag: hM,
  sprite_vert: fM,
  sprite_frag: pM
}, tt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Et() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Et() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Et() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Et() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Et() },
    normalScale: { value: /* @__PURE__ */ new st(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Et() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Et() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Mt(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Et() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Et() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Mt(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new st(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Et() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Et() },
    alphaTest: { value: 0 }
  }
}, Qi = {
  basic: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.fog
    ]),
    vertexShader: Tt.meshbasic_vert,
    fragmentShader: Tt.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: Tt.meshlambert_vert,
    fragmentShader: Tt.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.specularmap,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        specular: { value: /* @__PURE__ */ new Mt(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: Tt.meshphong_vert,
    fragmentShader: Tt.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.envmap,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.roughnessmap,
      tt.metalnessmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: Tt.meshphysical_vert,
    fragmentShader: Tt.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.aomap,
      tt.lightmap,
      tt.emissivemap,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.gradientmap,
      tt.fog,
      tt.lights,
      {
        emissive: { value: /* @__PURE__ */ new Mt(0) }
      }
    ]),
    vertexShader: Tt.meshtoon_vert,
    fragmentShader: Tt.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      tt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: Tt.meshmatcap_vert,
    fragmentShader: Tt.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ Kn([
      tt.points,
      tt.fog
    ]),
    vertexShader: Tt.points_vert,
    fragmentShader: Tt.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: Tt.linedashed_vert,
    fragmentShader: Tt.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.displacementmap
    ]),
    vertexShader: Tt.depth_vert,
    fragmentShader: Tt.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.bumpmap,
      tt.normalmap,
      tt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Tt.meshnormal_vert,
    fragmentShader: Tt.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ Kn([
      tt.sprite,
      tt.fog
    ]),
    vertexShader: Tt.sprite_vert,
    fragmentShader: Tt.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Et() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: Tt.background_vert,
    fragmentShader: Tt.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Et() }
    },
    vertexShader: Tt.backgroundCube_vert,
    fragmentShader: Tt.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: Tt.cube_vert,
    fragmentShader: Tt.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: Tt.equirect_vert,
    fragmentShader: Tt.equirect_frag
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ Kn([
      tt.common,
      tt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new ce() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: Tt.distanceRGBA_vert,
    fragmentShader: Tt.distanceRGBA_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ Kn([
      tt.lights,
      tt.fog,
      {
        color: { value: /* @__PURE__ */ new Mt(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: Tt.shadow_vert,
    fragmentShader: Tt.shadow_frag
  }
};
Qi.physical = {
  uniforms: /* @__PURE__ */ Kn([
    Qi.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Et() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Et() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new st(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Et() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Et() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Et() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Mt(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Et() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Et() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Et() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new st() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Et() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Mt(0) },
      specularColor: { value: /* @__PURE__ */ new Mt(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Et() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Et() },
      anisotropyVector: { value: /* @__PURE__ */ new st() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Et() }
    }
  ]),
  vertexShader: Tt.meshphysical_vert,
  fragmentShader: Tt.meshphysical_frag
};
const Yl = { r: 0, b: 0, g: 0 }, pr = /* @__PURE__ */ new wi(), mM = /* @__PURE__ */ new Zt();
function vM(s, e, n, i, r, o, a) {
  const l = new Mt(0);
  let c = o === !0 ? 0 : 1, u, d, h = null, m = 0, p = null;
  function y(S) {
    let w = S.isScene === !0 ? S.background : null;
    return w && w.isTexture && (w = (S.backgroundBlurriness > 0 ? n : e).get(w)), w;
  }
  function _(S) {
    let w = !1;
    const x = y(S);
    x === null ? g(l, c) : x && x.isColor && (g(x, 1), w = !0);
    const C = s.xr.getEnvironmentBlendMode();
    C === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : C === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (s.autoClear || w) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil));
  }
  function v(S, w) {
    const x = y(w);
    x && (x.isCubeTexture || x.mapping === fu) ? (d === void 0 && (d = new qe(
      new hn(1, 1, 1),
      new Fn({
        name: "BackgroundCubeMaterial",
        uniforms: zo(Qi.backgroundCube.uniforms),
        vertexShader: Qi.backgroundCube.vertexShader,
        fragmentShader: Qi.backgroundCube.fragmentShader,
        side: di,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), d.geometry.deleteAttribute("normal"), d.geometry.deleteAttribute("uv"), d.onBeforeRender = function(C, E, P) {
      this.matrixWorld.copyPosition(P.matrixWorld);
    }, Object.defineProperty(d.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(d)), pr.copy(w.backgroundRotation), pr.x *= -1, pr.y *= -1, pr.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === !1 && (pr.y *= -1, pr.z *= -1), d.material.uniforms.envMap.value = x, d.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, d.material.uniforms.backgroundBlurriness.value = w.backgroundBlurriness, d.material.uniforms.backgroundIntensity.value = w.backgroundIntensity, d.material.uniforms.backgroundRotation.value.setFromMatrix4(mM.makeRotationFromEuler(pr)), d.material.toneMapped = kt.getTransfer(x.colorSpace) !== qt, (h !== x || m !== x.version || p !== s.toneMapping) && (d.material.needsUpdate = !0, h = x, m = x.version, p = s.toneMapping), d.layers.enableAll(), S.unshift(d, d.geometry, d.material, 0, 0, null)) : x && x.isTexture && (u === void 0 && (u = new qe(
      new cn(2, 2),
      new Fn({
        name: "BackgroundMaterial",
        uniforms: zo(Qi.background.uniforms),
        vertexShader: Qi.background.vertexShader,
        fragmentShader: Qi.background.fragmentShader,
        side: er,
        depthTest: !1,
        depthWrite: !1,
        fog: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(u)), u.material.uniforms.t2D.value = x, u.material.uniforms.backgroundIntensity.value = w.backgroundIntensity, u.material.toneMapped = kt.getTransfer(x.colorSpace) !== qt, x.matrixAutoUpdate === !0 && x.updateMatrix(), u.material.uniforms.uvTransform.value.copy(x.matrix), (h !== x || m !== x.version || p !== s.toneMapping) && (u.material.needsUpdate = !0, h = x, m = x.version, p = s.toneMapping), u.layers.enableAll(), S.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function g(S, w) {
    S.getRGB(Yl, W0(s)), i.buffers.color.setClear(Yl.r, Yl.g, Yl.b, w, a);
  }
  return {
    getClearColor: function() {
      return l;
    },
    setClearColor: function(S, w = 1) {
      l.set(S), c = w, g(l, c);
    },
    getClearAlpha: function() {
      return c;
    },
    setClearAlpha: function(S) {
      c = S, g(l, c);
    },
    render: _,
    addToRenderList: v
  };
}
function gM(s, e) {
  const n = s.getParameter(s.MAX_VERTEX_ATTRIBS), i = {}, r = m(null);
  let o = r, a = !1;
  function l(M, L, N, D, O) {
    let A = !1;
    const G = h(D, N, L);
    o !== G && (o = G, u(o.object)), A = p(M, D, N, O), A && y(M, D, N, O), O !== null && e.update(O, s.ELEMENT_ARRAY_BUFFER), (A || a) && (a = !1, x(M, L, N, D), O !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(O).buffer));
  }
  function c() {
    return s.createVertexArray();
  }
  function u(M) {
    return s.bindVertexArray(M);
  }
  function d(M) {
    return s.deleteVertexArray(M);
  }
  function h(M, L, N) {
    const D = N.wireframe === !0;
    let O = i[M.id];
    O === void 0 && (O = {}, i[M.id] = O);
    let A = O[L.id];
    A === void 0 && (A = {}, O[L.id] = A);
    let G = A[D];
    return G === void 0 && (G = m(c()), A[D] = G), G;
  }
  function m(M) {
    const L = [], N = [], D = [];
    for (let O = 0; O < n; O++)
      L[O] = 0, N[O] = 0, D[O] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: L,
      enabledAttributes: N,
      attributeDivisors: D,
      object: M,
      attributes: {},
      index: null
    };
  }
  function p(M, L, N, D) {
    const O = o.attributes, A = L.attributes;
    let G = 0;
    const he = N.getAttributes();
    for (const ee in he)
      if (he[ee].location >= 0) {
        const oe = O[ee];
        let Y = A[ee];
        if (Y === void 0 && (ee === "instanceMatrix" && M.instanceMatrix && (Y = M.instanceMatrix), ee === "instanceColor" && M.instanceColor && (Y = M.instanceColor)), oe === void 0 || oe.attribute !== Y || Y && oe.data !== Y.data) return !0;
        G++;
      }
    return o.attributesNum !== G || o.index !== D;
  }
  function y(M, L, N, D) {
    const O = {}, A = L.attributes;
    let G = 0;
    const he = N.getAttributes();
    for (const ee in he)
      if (he[ee].location >= 0) {
        let oe = A[ee];
        oe === void 0 && (ee === "instanceMatrix" && M.instanceMatrix && (oe = M.instanceMatrix), ee === "instanceColor" && M.instanceColor && (oe = M.instanceColor));
        const Y = {};
        Y.attribute = oe, oe && oe.data && (Y.data = oe.data), O[ee] = Y, G++;
      }
    o.attributes = O, o.attributesNum = G, o.index = D;
  }
  function _() {
    const M = o.newAttributes;
    for (let L = 0, N = M.length; L < N; L++)
      M[L] = 0;
  }
  function v(M) {
    g(M, 0);
  }
  function g(M, L) {
    const N = o.newAttributes, D = o.enabledAttributes, O = o.attributeDivisors;
    N[M] = 1, D[M] === 0 && (s.enableVertexAttribArray(M), D[M] = 1), O[M] !== L && (s.vertexAttribDivisor(M, L), O[M] = L);
  }
  function S() {
    const M = o.newAttributes, L = o.enabledAttributes;
    for (let N = 0, D = L.length; N < D; N++)
      L[N] !== M[N] && (s.disableVertexAttribArray(N), L[N] = 0);
  }
  function w(M, L, N, D, O, A, G) {
    G === !0 ? s.vertexAttribIPointer(M, L, N, O, A) : s.vertexAttribPointer(M, L, N, D, O, A);
  }
  function x(M, L, N, D) {
    _();
    const O = D.attributes, A = N.getAttributes(), G = L.defaultAttributeValues;
    for (const he in A) {
      const ee = A[he];
      if (ee.location >= 0) {
        let le = O[he];
        if (le === void 0 && (he === "instanceMatrix" && M.instanceMatrix && (le = M.instanceMatrix), he === "instanceColor" && M.instanceColor && (le = M.instanceColor)), le !== void 0) {
          const oe = le.normalized, Y = le.itemSize, j = e.get(le);
          if (j === void 0) continue;
          const q = j.buffer, te = j.type, ne = j.bytesPerElement, de = te === s.INT || te === s.UNSIGNED_INT || le.gpuType === ff;
          if (le.isInterleavedBufferAttribute) {
            const H = le.data, X = H.stride, V = le.offset;
            if (H.isInstancedInterleavedBuffer) {
              for (let I = 0; I < ee.locationSize; I++)
                g(ee.location + I, H.meshPerAttribute);
              M.isInstancedMesh !== !0 && D._maxInstanceCount === void 0 && (D._maxInstanceCount = H.meshPerAttribute * H.count);
            } else
              for (let I = 0; I < ee.locationSize; I++)
                v(ee.location + I);
            s.bindBuffer(s.ARRAY_BUFFER, q);
            for (let I = 0; I < ee.locationSize; I++)
              w(
                ee.location + I,
                Y / ee.locationSize,
                te,
                oe,
                X * ne,
                (V + Y / ee.locationSize * I) * ne,
                de
              );
          } else {
            if (le.isInstancedBufferAttribute) {
              for (let H = 0; H < ee.locationSize; H++)
                g(ee.location + H, le.meshPerAttribute);
              M.isInstancedMesh !== !0 && D._maxInstanceCount === void 0 && (D._maxInstanceCount = le.meshPerAttribute * le.count);
            } else
              for (let H = 0; H < ee.locationSize; H++)
                v(ee.location + H);
            s.bindBuffer(s.ARRAY_BUFFER, q);
            for (let H = 0; H < ee.locationSize; H++)
              w(
                ee.location + H,
                Y / ee.locationSize,
                te,
                oe,
                Y * ne,
                Y / ee.locationSize * H * ne,
                de
              );
          }
        } else if (G !== void 0) {
          const oe = G[he];
          if (oe !== void 0)
            switch (oe.length) {
              case 2:
                s.vertexAttrib2fv(ee.location, oe);
                break;
              case 3:
                s.vertexAttrib3fv(ee.location, oe);
                break;
              case 4:
                s.vertexAttrib4fv(ee.location, oe);
                break;
              default:
                s.vertexAttrib1fv(ee.location, oe);
            }
        }
      }
    }
    S();
  }
  function C() {
    T();
    for (const M in i) {
      const L = i[M];
      for (const N in L) {
        const D = L[N];
        for (const O in D)
          d(D[O].object), delete D[O];
        delete L[N];
      }
      delete i[M];
    }
  }
  function E(M) {
    if (i[M.id] === void 0) return;
    const L = i[M.id];
    for (const N in L) {
      const D = L[N];
      for (const O in D)
        d(D[O].object), delete D[O];
      delete L[N];
    }
    delete i[M.id];
  }
  function P(M) {
    for (const L in i) {
      const N = i[L];
      if (N[M.id] === void 0) continue;
      const D = N[M.id];
      for (const O in D)
        d(D[O].object), delete D[O];
      delete N[M.id];
    }
  }
  function T() {
    b(), a = !0, o !== r && (o = r, u(o.object));
  }
  function b() {
    r.geometry = null, r.program = null, r.wireframe = !1;
  }
  return {
    setup: l,
    reset: T,
    resetDefaultState: b,
    dispose: C,
    releaseStatesOfGeometry: E,
    releaseStatesOfProgram: P,
    initAttributes: _,
    enableAttribute: v,
    disableUnusedAttributes: S
  };
}
function yM(s, e, n) {
  let i;
  function r(u) {
    i = u;
  }
  function o(u, d) {
    s.drawArrays(i, u, d), n.update(d, i, 1);
  }
  function a(u, d, h) {
    h !== 0 && (s.drawArraysInstanced(i, u, d, h), n.update(d, i, h));
  }
  function l(u, d, h) {
    if (h === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, u, 0, d, 0, h);
    let p = 0;
    for (let y = 0; y < h; y++)
      p += d[y];
    n.update(p, i, 1);
  }
  function c(u, d, h, m) {
    if (h === 0) return;
    const p = e.get("WEBGL_multi_draw");
    if (p === null)
      for (let y = 0; y < u.length; y++)
        a(u[y], d[y], m[y]);
    else {
      p.multiDrawArraysInstancedWEBGL(i, u, 0, d, 0, m, 0, h);
      let y = 0;
      for (let _ = 0; _ < h; _++)
        y += d[_] * m[_];
      n.update(y, i, 1);
    }
  }
  this.setMode = r, this.render = o, this.renderInstances = a, this.renderMultiDraw = l, this.renderMultiDrawInstances = c;
}
function _M(s, e, n, i) {
  let r;
  function o() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const P = e.get("EXT_texture_filter_anisotropic");
      r = s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function a(P) {
    return !(P !== $n && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function l(P) {
    const T = P === sr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(P !== is && i.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    P !== ui && !T);
  }
  function c(P) {
    if (P === "highp") {
      if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
        return "highp";
      P = "mediump";
    }
    return P === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = n.precision !== void 0 ? n.precision : "highp";
  const d = c(u);
  d !== u && (console.warn("THREE.WebGLRenderer:", u, "not supported, using", d, "instead."), u = d);
  const h = n.logarithmicDepthBuffer === !0, m = n.reverseDepthBuffer === !0 && e.has("EXT_clip_control"), p = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS), y = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = s.getParameter(s.MAX_TEXTURE_SIZE), v = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE), g = s.getParameter(s.MAX_VERTEX_ATTRIBS), S = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS), w = s.getParameter(s.MAX_VARYING_VECTORS), x = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS), C = y > 0, E = s.getParameter(s.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: o,
    getMaxPrecision: c,
    textureFormatReadable: a,
    textureTypeReadable: l,
    precision: u,
    logarithmicDepthBuffer: h,
    reverseDepthBuffer: m,
    maxTextures: p,
    maxVertexTextures: y,
    maxTextureSize: _,
    maxCubemapSize: v,
    maxAttributes: g,
    maxVertexUniforms: S,
    maxVaryings: w,
    maxFragmentUniforms: x,
    vertexTextures: C,
    maxSamples: E
  };
}
function xM(s) {
  const e = this;
  let n = null, i = 0, r = !1, o = !1;
  const a = new br(), l = new Et(), c = { value: null, needsUpdate: !1 };
  this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, m) {
    const p = h.length !== 0 || m || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    i !== 0 || r;
    return r = m, i = h.length, p;
  }, this.beginShadows = function() {
    o = !0, d(null);
  }, this.endShadows = function() {
    o = !1;
  }, this.setGlobalState = function(h, m) {
    n = d(h, m, 0);
  }, this.setState = function(h, m, p) {
    const y = h.clippingPlanes, _ = h.clipIntersection, v = h.clipShadows, g = s.get(h);
    if (!r || y === null || y.length === 0 || o && !v)
      o ? d(null) : u();
    else {
      const S = o ? 0 : i, w = S * 4;
      let x = g.clippingState || null;
      c.value = x, x = d(y, m, w, p);
      for (let C = 0; C !== w; ++C)
        x[C] = n[C];
      g.clippingState = x, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += S;
    }
  };
  function u() {
    c.value !== n && (c.value = n, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function d(h, m, p, y) {
    const _ = h !== null ? h.length : 0;
    let v = null;
    if (_ !== 0) {
      if (v = c.value, y !== !0 || v === null) {
        const g = p + _ * 4, S = m.matrixWorldInverse;
        l.getNormalMatrix(S), (v === null || v.length < g) && (v = new Float32Array(g));
        for (let w = 0, x = p; w !== _; ++w, x += 4)
          a.copy(h[w]).applyMatrix4(S, l), a.normal.toArray(v, x), v[x + 3] = a.constant;
      }
      c.value = v, c.needsUpdate = !0;
    }
    return e.numPlanes = _, e.numIntersection = 0, v;
  }
}
function bM(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(a, l) {
    return l === ah ? a.mapping = ko : l === lh && (a.mapping = Lo), a;
  }
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping;
      if (l === ah || l === lh)
        if (e.has(a)) {
          const c = e.get(a).texture;
          return n(c, a.mapping);
        } else {
          const c = a.image;
          if (c && c.height > 0) {
            const u = new Ib(c.height);
            return u.fromEquirectangularTexture(s, a), e.set(a, u), a.addEventListener("dispose", r), n(u.texture, a.mapping);
          } else
            return null;
        }
    }
    return a;
  }
  function r(a) {
    const l = a.target;
    l.removeEventListener("dispose", r);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: i,
    dispose: o
  };
}
class mu extends $0 {
  constructor(e = -1, n = 1, i = 1, r = -1, o = 0.1, a = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = i, this.bottom = r, this.near = o, this.far = a, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, n, i, r, o, a) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = r, this.view.width = o, this.view.height = a, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let o = i - e, a = i + e, l = r + n, c = r - n;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += u * this.view.offsetX, a = o + u * this.view.width, l -= d * this.view.offsetY, c = l - d * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, a, l, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const go = 4, hm = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Er = 20, dd = /* @__PURE__ */ new mu(), fm = /* @__PURE__ */ new Mt();
let hd = null, fd = 0, pd = 0, md = !1;
const wr = (1 + Math.sqrt(5)) / 2, ao = 1 / wr, pm = [
  /* @__PURE__ */ new ce(-wr, ao, 0),
  /* @__PURE__ */ new ce(wr, ao, 0),
  /* @__PURE__ */ new ce(-ao, 0, wr),
  /* @__PURE__ */ new ce(ao, 0, wr),
  /* @__PURE__ */ new ce(0, wr, -ao),
  /* @__PURE__ */ new ce(0, wr, ao),
  /* @__PURE__ */ new ce(-1, 1, -1),
  /* @__PURE__ */ new ce(1, 1, -1),
  /* @__PURE__ */ new ce(-1, 1, 1),
  /* @__PURE__ */ new ce(1, 1, 1)
];
class mm {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(e, n = 0, i = 0.1, r = 100) {
    hd = this._renderer.getRenderTarget(), fd = this._renderer.getActiveCubeFace(), pd = this._renderer.getActiveMipmapLevel(), md = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
    const o = this._allocateTargets();
    return o.depthBuffer = !0, this._sceneToCubeUV(e, i, r, o), n > 0 && this._blur(o, 0, 0, n), this._applyPMREM(o), this._cleanup(o), o;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = ym(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = gm(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(hd, fd, pd), this._renderer.xr.enabled = md, e.scissorTest = !1, ql(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === ko || e.mapping === Lo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), hd = this._renderer.getRenderTarget(), fd = this._renderer.getActiveCubeFace(), pd = this._renderer.getActiveMipmapLevel(), md = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const i = n || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, i = {
      magFilter: Xt,
      minFilter: Xt,
      generateMipmaps: !1,
      type: sr,
      format: $n,
      colorSpace: Ho,
      depthBuffer: !1
    }, r = vm(e, n, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== n) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = vm(e, n, i);
      const { _lodMax: o } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = wM(o)), this._blurMaterial = SM(o, e, n);
    }
    return r;
  }
  _compileMaterial(e) {
    const n = new qe(this._lodPlanes[0], e);
    this._renderer.compile(n, dd);
  }
  _sceneToCubeUV(e, n, i, r) {
    const l = new ci(90, 1, n, i), c = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], d = this._renderer, h = d.autoClear, m = d.toneMapping;
    d.getClearColor(fm), d.toneMapping = Qs, d.autoClear = !1;
    const p = new Mn({
      name: "PMREM.Background",
      side: di,
      depthWrite: !1,
      depthTest: !1
    }), y = new qe(new hn(), p);
    let _ = !1;
    const v = e.background;
    v ? v.isColor && (p.color.copy(v), e.background = null, _ = !0) : (p.color.copy(fm), _ = !0);
    for (let g = 0; g < 6; g++) {
      const S = g % 3;
      S === 0 ? (l.up.set(0, c[g], 0), l.lookAt(u[g], 0, 0)) : S === 1 ? (l.up.set(0, 0, c[g]), l.lookAt(0, u[g], 0)) : (l.up.set(0, c[g], 0), l.lookAt(0, 0, u[g]));
      const w = this._cubeSize;
      ql(r, S * w, g > 2 ? w : 0, w, w), d.setRenderTarget(r), _ && d.render(y, l), d.render(e, l);
    }
    y.geometry.dispose(), y.material.dispose(), d.toneMapping = m, d.autoClear = h, e.background = v;
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer, r = e.mapping === ko || e.mapping === Lo;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = ym()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = gm());
    const o = r ? this._cubemapMaterial : this._equirectMaterial, a = new qe(this._lodPlanes[0], o), l = o.uniforms;
    l.envMap.value = e;
    const c = this._cubeSize;
    ql(n, 0, 0, 3 * c, 2 * c), i.setRenderTarget(n), i.render(a, dd);
  }
  _applyPMREM(e) {
    const n = this._renderer, i = n.autoClear;
    n.autoClear = !1;
    const r = this._lodPlanes.length;
    for (let o = 1; o < r; o++) {
      const a = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), l = pm[(r - o - 1) % pm.length];
      this._blur(e, o - 1, o, a, l);
    }
    n.autoClear = i;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(e, n, i, r, o) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      a,
      n,
      i,
      r,
      "latitudinal",
      o
    ), this._halfBlur(
      a,
      e,
      i,
      i,
      r,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, n, i, r, o, a, l) {
    const c = this._renderer, u = this._blurMaterial;
    a !== "latitudinal" && a !== "longitudinal" && console.error(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const d = 3, h = new qe(this._lodPlanes[r], u), m = u.uniforms, p = this._sizeLods[i] - 1, y = isFinite(o) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * Er - 1), _ = o / y, v = isFinite(o) ? 1 + Math.floor(d * _) : Er;
    v > Er && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Er}`);
    const g = [];
    let S = 0;
    for (let P = 0; P < Er; ++P) {
      const T = P / _, b = Math.exp(-T * T / 2);
      g.push(b), P === 0 ? S += b : P < v && (S += 2 * b);
    }
    for (let P = 0; P < g.length; P++)
      g[P] = g[P] / S;
    m.envMap.value = e.texture, m.samples.value = v, m.weights.value = g, m.latitudinal.value = a === "latitudinal", l && (m.poleAxis.value = l);
    const { _lodMax: w } = this;
    m.dTheta.value = y, m.mipInt.value = w - i;
    const x = this._sizeLods[r], C = 3 * x * (r > w - go ? r - w + go : 0), E = 4 * (this._cubeSize - x);
    ql(n, C, E, 3 * x, 2 * x), c.setRenderTarget(n), c.render(h, dd);
  }
}
function wM(s) {
  const e = [], n = [], i = [];
  let r = s;
  const o = s - go + 1 + hm.length;
  for (let a = 0; a < o; a++) {
    const l = Math.pow(2, r);
    n.push(l);
    let c = 1 / l;
    a > s - go ? c = hm[a - s + go - 1] : a === 0 && (c = 0), i.push(c);
    const u = 1 / (l - 2), d = -u, h = 1 + u, m = [d, d, h, d, h, h, d, d, h, h, d, h], p = 6, y = 6, _ = 3, v = 2, g = 1, S = new Float32Array(_ * y * p), w = new Float32Array(v * y * p), x = new Float32Array(g * y * p);
    for (let E = 0; E < p; E++) {
      const P = E % 3 * 2 / 3 - 1, T = E > 2 ? 0 : -1, b = [
        P,
        T,
        0,
        P + 2 / 3,
        T,
        0,
        P + 2 / 3,
        T + 1,
        0,
        P,
        T,
        0,
        P + 2 / 3,
        T + 1,
        0,
        P,
        T + 1,
        0
      ];
      S.set(b, _ * y * E), w.set(m, v * y * E);
      const M = [E, E, E, E, E, E];
      x.set(M, g * y * E);
    }
    const C = new Nt();
    C.setAttribute("position", new bi(S, _)), C.setAttribute("uv", new bi(w, v)), C.setAttribute("faceIndex", new bi(x, g)), e.push(C), r > go && r--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i };
}
function vm(s, e, n) {
  const i = new Hi(s, e, n);
  return i.texture.mapping = fu, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i;
}
function ql(s, e, n, i, r) {
  s.viewport.set(e, n, i, r), s.scissor.set(e, n, i, r);
}
function SM(s, e, n) {
  const i = new Float32Array(Er), r = new ce(0, 1, 0);
  return new Fn({
    name: "SphericalGaussianBlur",
    defines: {
      n: Er,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${s}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: Cf(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: ts,
    depthTest: !1,
    depthWrite: !1
  });
}
function gm() {
  return new Fn({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: Cf(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: ts,
    depthTest: !1,
    depthWrite: !1
  });
}
function ym() {
  return new Fn({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: Cf(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: ts,
    depthTest: !1,
    depthWrite: !1
  });
}
function Cf() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function MM(s) {
  let e = /* @__PURE__ */ new WeakMap(), n = null;
  function i(l) {
    if (l && l.isTexture) {
      const c = l.mapping, u = c === ah || c === lh, d = c === ko || c === Lo;
      if (u || d) {
        let h = e.get(l);
        const m = h !== void 0 ? h.texture.pmremVersion : 0;
        if (l.isRenderTargetTexture && l.pmremVersion !== m)
          return n === null && (n = new mm(s)), h = u ? n.fromEquirectangular(l, h) : n.fromCubemap(l, h), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), h.texture;
        if (h !== void 0)
          return h.texture;
        {
          const p = l.image;
          return u && p && p.height > 0 || d && p && r(p) ? (n === null && (n = new mm(s)), h = u ? n.fromEquirectangular(l) : n.fromCubemap(l), h.texture.pmremVersion = l.pmremVersion, e.set(l, h), l.addEventListener("dispose", o), h.texture) : null;
        }
      }
    }
    return l;
  }
  function r(l) {
    let c = 0;
    const u = 6;
    for (let d = 0; d < u; d++)
      l[d] !== void 0 && c++;
    return c === u;
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o);
    const u = e.get(c);
    u !== void 0 && (e.delete(c), u.dispose());
  }
  function a() {
    e = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
  }
  return {
    get: i,
    dispose: a
  };
}
function CM(s) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0)
      return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = s.getExtension(i);
    }
    return e[i] = r, r;
  }
  return {
    has: function(i) {
      return n(i) !== null;
    },
    init: function() {
      n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent");
    },
    get: function(i) {
      const r = n(i);
      return r === null && wa("THREE.WebGLRenderer: " + i + " extension not supported."), r;
    }
  };
}
function EM(s, e, n, i) {
  const r = {}, o = /* @__PURE__ */ new WeakMap();
  function a(h) {
    const m = h.target;
    m.index !== null && e.remove(m.index);
    for (const y in m.attributes)
      e.remove(m.attributes[y]);
    for (const y in m.morphAttributes) {
      const _ = m.morphAttributes[y];
      for (let v = 0, g = _.length; v < g; v++)
        e.remove(_[v]);
    }
    m.removeEventListener("dispose", a), delete r[m.id];
    const p = o.get(m);
    p && (e.remove(p), o.delete(m)), i.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount, n.memory.geometries--;
  }
  function l(h, m) {
    return r[m.id] === !0 || (m.addEventListener("dispose", a), r[m.id] = !0, n.memory.geometries++), m;
  }
  function c(h) {
    const m = h.attributes;
    for (const y in m)
      e.update(m[y], s.ARRAY_BUFFER);
    const p = h.morphAttributes;
    for (const y in p) {
      const _ = p[y];
      for (let v = 0, g = _.length; v < g; v++)
        e.update(_[v], s.ARRAY_BUFFER);
    }
  }
  function u(h) {
    const m = [], p = h.index, y = h.attributes.position;
    let _ = 0;
    if (p !== null) {
      const S = p.array;
      _ = p.version;
      for (let w = 0, x = S.length; w < x; w += 3) {
        const C = S[w + 0], E = S[w + 1], P = S[w + 2];
        m.push(C, E, E, P, P, C);
      }
    } else if (y !== void 0) {
      const S = y.array;
      _ = y.version;
      for (let w = 0, x = S.length / 3 - 1; w < x; w += 3) {
        const C = w + 0, E = w + 1, P = w + 2;
        m.push(C, E, E, P, P, C);
      }
    } else
      return;
    const v = new (z0(m) ? H0 : G0)(m, 1);
    v.version = _;
    const g = o.get(h);
    g && e.remove(g), o.set(h, v);
  }
  function d(h) {
    const m = o.get(h);
    if (m) {
      const p = h.index;
      p !== null && m.version < p.version && u(h);
    } else
      u(h);
    return o.get(h);
  }
  return {
    get: l,
    update: c,
    getWireframeAttribute: d
  };
}
function TM(s, e, n) {
  let i;
  function r(m) {
    i = m;
  }
  let o, a;
  function l(m) {
    o = m.type, a = m.bytesPerElement;
  }
  function c(m, p) {
    s.drawElements(i, p, o, m * a), n.update(p, i, 1);
  }
  function u(m, p, y) {
    y !== 0 && (s.drawElementsInstanced(i, p, o, m * a, y), n.update(p, i, y));
  }
  function d(m, p, y) {
    if (y === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, o, m, 0, y);
    let v = 0;
    for (let g = 0; g < y; g++)
      v += p[g];
    n.update(v, i, 1);
  }
  function h(m, p, y, _) {
    if (y === 0) return;
    const v = e.get("WEBGL_multi_draw");
    if (v === null)
      for (let g = 0; g < m.length; g++)
        u(m[g] / a, p[g], _[g]);
    else {
      v.multiDrawElementsInstancedWEBGL(i, p, 0, o, m, 0, _, 0, y);
      let g = 0;
      for (let S = 0; S < y; S++)
        g += p[S] * _[S];
      n.update(g, i, 1);
    }
  }
  this.setMode = r, this.setIndex = l, this.render = c, this.renderInstances = u, this.renderMultiDraw = d, this.renderMultiDrawInstances = h;
}
function AM(s) {
  const e = {
    geometries: 0,
    textures: 0
  }, n = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function i(o, a, l) {
    switch (n.calls++, a) {
      case s.TRIANGLES:
        n.triangles += l * (o / 3);
        break;
      case s.LINES:
        n.lines += l * (o / 2);
        break;
      case s.LINE_STRIP:
        n.lines += l * (o - 1);
        break;
      case s.LINE_LOOP:
        n.lines += l * o;
        break;
      case s.POINTS:
        n.points += l * o;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function r() {
    n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i
  };
}
function PM(s, e, n) {
  const i = /* @__PURE__ */ new WeakMap(), r = new jt();
  function o(a, l, c) {
    const u = a.morphTargetInfluences, d = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color, h = d !== void 0 ? d.length : 0;
    let m = i.get(l);
    if (m === void 0 || m.count !== h) {
      let p = function() {
        T.dispose(), i.delete(l), l.removeEventListener("dispose", p);
      };
      m !== void 0 && m.texture.dispose();
      const y = l.morphAttributes.position !== void 0, _ = l.morphAttributes.normal !== void 0, v = l.morphAttributes.color !== void 0, g = l.morphAttributes.position || [], S = l.morphAttributes.normal || [], w = l.morphAttributes.color || [];
      let x = 0;
      y === !0 && (x = 1), _ === !0 && (x = 2), v === !0 && (x = 3);
      let C = l.attributes.position.count * x, E = 1;
      C > e.maxTextureSize && (E = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
      const P = new Float32Array(C * E * 4 * h), T = new B0(P, C, E, h);
      T.type = ui, T.needsUpdate = !0;
      const b = x * 4;
      for (let M = 0; M < h; M++) {
        const L = g[M], N = S[M], D = w[M], O = C * E * 4 * M;
        for (let A = 0; A < L.count; A++) {
          const G = A * b;
          y === !0 && (r.fromBufferAttribute(L, A), P[O + G + 0] = r.x, P[O + G + 1] = r.y, P[O + G + 2] = r.z, P[O + G + 3] = 0), _ === !0 && (r.fromBufferAttribute(N, A), P[O + G + 4] = r.x, P[O + G + 5] = r.y, P[O + G + 6] = r.z, P[O + G + 7] = 0), v === !0 && (r.fromBufferAttribute(D, A), P[O + G + 8] = r.x, P[O + G + 9] = r.y, P[O + G + 10] = r.z, P[O + G + 11] = D.itemSize === 4 ? r.w : 1);
        }
      }
      m = {
        count: h,
        texture: T,
        size: new st(C, E)
      }, i.set(l, m), l.addEventListener("dispose", p);
    }
    if (a.isInstancedMesh === !0 && a.morphTexture !== null)
      c.getUniforms().setValue(s, "morphTexture", a.morphTexture, n);
    else {
      let p = 0;
      for (let _ = 0; _ < u.length; _++)
        p += u[_];
      const y = l.morphTargetsRelative ? 1 : 1 - p;
      c.getUniforms().setValue(s, "morphTargetBaseInfluence", y), c.getUniforms().setValue(s, "morphTargetInfluences", u);
    }
    c.getUniforms().setValue(s, "morphTargetsTexture", m.texture, n), c.getUniforms().setValue(s, "morphTargetsTextureSize", m.size);
  }
  return {
    update: o
  };
}
function DM(s, e, n, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function o(c) {
    const u = i.render.frame, d = c.geometry, h = e.get(c, d);
    if (r.get(h) !== u && (e.update(h), r.set(h, u)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), r.get(c) !== u && (n.update(c.instanceMatrix, s.ARRAY_BUFFER), c.instanceColor !== null && n.update(c.instanceColor, s.ARRAY_BUFFER), r.set(c, u))), c.isSkinnedMesh) {
      const m = c.skeleton;
      r.get(m) !== u && (m.update(), r.set(m, u));
    }
    return h;
  }
  function a() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function l(c) {
    const u = c.target;
    u.removeEventListener("dispose", l), n.remove(u.instanceMatrix), u.instanceColor !== null && n.remove(u.instanceColor);
  }
  return {
    update: o,
    dispose: a
  };
}
class Ef extends yn {
  constructor(e, n, i, r, o, a, l, c, u, d = Lr) {
    if (d !== Lr && d !== Uo)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && d === Lr && (i = zr), i === void 0 && d === Uo && (i = Fo), super(null, r, o, a, l, c, d, i, u), this.isDepthTexture = !0, this.image = { width: e, height: n }, this.magFilter = l !== void 0 ? l : Ln, this.minFilter = c !== void 0 ? c : Ln, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.compareFunction !== null && (n.compareFunction = this.compareFunction), n;
  }
}
const Y0 = /* @__PURE__ */ new yn(), _m = /* @__PURE__ */ new Ef(1, 1), q0 = /* @__PURE__ */ new B0(), Z0 = /* @__PURE__ */ new gb(), K0 = /* @__PURE__ */ new X0(), xm = [], bm = [], wm = new Float32Array(16), Sm = new Float32Array(9), Mm = new Float32Array(4);
function Wo(s, e, n) {
  const i = s[0];
  if (i <= 0 || i > 0) return s;
  const r = e * n;
  let o = xm[r];
  if (o === void 0 && (o = new Float32Array(r), xm[r] = o), e !== 0) {
    i.toArray(o, 0);
    for (let a = 1, l = 0; a !== e; ++a)
      l += n, s[a].toArray(o, l);
  }
  return o;
}
function Cn(s, e) {
  if (s.length !== e.length) return !1;
  for (let n = 0, i = s.length; n < i; n++)
    if (s[n] !== e[n]) return !1;
  return !0;
}
function En(s, e) {
  for (let n = 0, i = e.length; n < i; n++)
    s[n] = e[n];
}
function vu(s, e) {
  let n = bm[e];
  n === void 0 && (n = new Int32Array(e), bm[e] = n);
  for (let i = 0; i !== e; ++i)
    n[i] = s.allocateTextureUnit();
  return n;
}
function RM(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1f(this.addr, e), n[0] = e);
}
function IM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Cn(n, e)) return;
    s.uniform2fv(this.addr, e), En(n, e);
  }
}
function kM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (Cn(n, e)) return;
    s.uniform3fv(this.addr, e), En(n, e);
  }
}
function LM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Cn(n, e)) return;
    s.uniform4fv(this.addr, e), En(n, e);
  }
}
function FM(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Cn(n, e)) return;
    s.uniformMatrix2fv(this.addr, !1, e), En(n, e);
  } else {
    if (Cn(n, i)) return;
    Mm.set(i), s.uniformMatrix2fv(this.addr, !1, Mm), En(n, i);
  }
}
function UM(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Cn(n, e)) return;
    s.uniformMatrix3fv(this.addr, !1, e), En(n, e);
  } else {
    if (Cn(n, i)) return;
    Sm.set(i), s.uniformMatrix3fv(this.addr, !1, Sm), En(n, i);
  }
}
function OM(s, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (Cn(n, e)) return;
    s.uniformMatrix4fv(this.addr, !1, e), En(n, e);
  } else {
    if (Cn(n, i)) return;
    wm.set(i), s.uniformMatrix4fv(this.addr, !1, wm), En(n, i);
  }
}
function zM(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1i(this.addr, e), n[0] = e);
}
function NM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Cn(n, e)) return;
    s.uniform2iv(this.addr, e), En(n, e);
  }
}
function BM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Cn(n, e)) return;
    s.uniform3iv(this.addr, e), En(n, e);
  }
}
function VM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Cn(n, e)) return;
    s.uniform4iv(this.addr, e), En(n, e);
  }
}
function GM(s, e) {
  const n = this.cache;
  n[0] !== e && (s.uniform1ui(this.addr, e), n[0] = e);
}
function HM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (Cn(n, e)) return;
    s.uniform2uiv(this.addr, e), En(n, e);
  }
}
function WM(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else {
    if (Cn(n, e)) return;
    s.uniform3uiv(this.addr, e), En(n, e);
  }
}
function $M(s, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (Cn(n, e)) return;
    s.uniform4uiv(this.addr, e), En(n, e);
  }
}
function XM(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r);
  let o;
  this.type === s.SAMPLER_2D_SHADOW ? (_m.compareFunction = O0, o = _m) : o = Y0, n.setTexture2D(e || o, r);
}
function jM(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Z0, r);
}
function YM(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(e || K0, r);
}
function qM(s, e, n) {
  const i = this.cache, r = n.allocateTextureUnit();
  i[0] !== r && (s.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || q0, r);
}
function ZM(s) {
  switch (s) {
    case 5126:
      return RM;
    case 35664:
      return IM;
    case 35665:
      return kM;
    case 35666:
      return LM;
    case 35674:
      return FM;
    case 35675:
      return UM;
    case 35676:
      return OM;
    case 5124:
    case 35670:
      return zM;
    case 35667:
    case 35671:
      return NM;
    case 35668:
    case 35672:
      return BM;
    case 35669:
    case 35673:
      return VM;
    case 5125:
      return GM;
    case 36294:
      return HM;
    case 36295:
      return WM;
    case 36296:
      return $M;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return XM;
    case 35679:
    case 36299:
    case 36307:
      return jM;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return YM;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return qM;
  }
}
function KM(s, e) {
  s.uniform1fv(this.addr, e);
}
function JM(s, e) {
  const n = Wo(e, this.size, 2);
  s.uniform2fv(this.addr, n);
}
function QM(s, e) {
  const n = Wo(e, this.size, 3);
  s.uniform3fv(this.addr, n);
}
function eC(s, e) {
  const n = Wo(e, this.size, 4);
  s.uniform4fv(this.addr, n);
}
function tC(s, e) {
  const n = Wo(e, this.size, 4);
  s.uniformMatrix2fv(this.addr, !1, n);
}
function nC(s, e) {
  const n = Wo(e, this.size, 9);
  s.uniformMatrix3fv(this.addr, !1, n);
}
function iC(s, e) {
  const n = Wo(e, this.size, 16);
  s.uniformMatrix4fv(this.addr, !1, n);
}
function sC(s, e) {
  s.uniform1iv(this.addr, e);
}
function rC(s, e) {
  s.uniform2iv(this.addr, e);
}
function oC(s, e) {
  s.uniform3iv(this.addr, e);
}
function aC(s, e) {
  s.uniform4iv(this.addr, e);
}
function lC(s, e) {
  s.uniform1uiv(this.addr, e);
}
function cC(s, e) {
  s.uniform2uiv(this.addr, e);
}
function uC(s, e) {
  s.uniform3uiv(this.addr, e);
}
function dC(s, e) {
  s.uniform4uiv(this.addr, e);
}
function hC(s, e, n) {
  const i = this.cache, r = e.length, o = vu(n, r);
  Cn(i, o) || (s.uniform1iv(this.addr, o), En(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture2D(e[a] || Y0, o[a]);
}
function fC(s, e, n) {
  const i = this.cache, r = e.length, o = vu(n, r);
  Cn(i, o) || (s.uniform1iv(this.addr, o), En(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture3D(e[a] || Z0, o[a]);
}
function pC(s, e, n) {
  const i = this.cache, r = e.length, o = vu(n, r);
  Cn(i, o) || (s.uniform1iv(this.addr, o), En(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTextureCube(e[a] || K0, o[a]);
}
function mC(s, e, n) {
  const i = this.cache, r = e.length, o = vu(n, r);
  Cn(i, o) || (s.uniform1iv(this.addr, o), En(i, o));
  for (let a = 0; a !== r; ++a)
    n.setTexture2DArray(e[a] || q0, o[a]);
}
function vC(s) {
  switch (s) {
    case 5126:
      return KM;
    case 35664:
      return JM;
    case 35665:
      return QM;
    case 35666:
      return eC;
    case 35674:
      return tC;
    case 35675:
      return nC;
    case 35676:
      return iC;
    case 5124:
    case 35670:
      return sC;
    case 35667:
    case 35671:
      return rC;
    case 35668:
    case 35672:
      return oC;
    case 35669:
    case 35673:
      return aC;
    case 5125:
      return lC;
    case 36294:
      return cC;
    case 36295:
      return uC;
    case 36296:
      return dC;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return hC;
    case 35679:
    case 36299:
    case 36307:
      return fC;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return pC;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return mC;
  }
}
class gC {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.setValue = ZM(n.type);
  }
}
class yC {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = n.type, this.size = n.size, this.setValue = vC(n.type);
  }
}
class _C {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, n, i) {
    const r = this.seq;
    for (let o = 0, a = r.length; o !== a; ++o) {
      const l = r[o];
      l.setValue(e, n[l.id], i);
    }
  }
}
const vd = /(\w+)(\])?(\[|\.)?/g;
function Cm(s, e) {
  s.seq.push(e), s.map[e.id] = e;
}
function xC(s, e, n) {
  const i = s.name, r = i.length;
  for (vd.lastIndex = 0; ; ) {
    const o = vd.exec(i), a = vd.lastIndex;
    let l = o[1];
    const c = o[2] === "]", u = o[3];
    if (c && (l = l | 0), u === void 0 || u === "[" && a + 2 === r) {
      Cm(n, u === void 0 ? new gC(l, s, e) : new yC(l, s, e));
      break;
    } else {
      let h = n.map[l];
      h === void 0 && (h = new _C(l), Cm(n, h)), n = h;
    }
  }
}
class Tc {
  constructor(e, n) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const o = e.getActiveUniform(n, r), a = e.getUniformLocation(n, o.name);
      xC(o, a, this);
    }
  }
  setValue(e, n, i, r) {
    const o = this.map[n];
    o !== void 0 && o.setValue(e, i, r);
  }
  setOptional(e, n, i) {
    const r = n[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, n, i, r) {
    for (let o = 0, a = n.length; o !== a; ++o) {
      const l = n[o], c = i[l.id];
      c.needsUpdate !== !1 && l.setValue(e, c.value, r);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let r = 0, o = e.length; r !== o; ++r) {
      const a = e[r];
      a.id in n && i.push(a);
    }
    return i;
  }
}
function Em(s, e, n) {
  const i = s.createShader(e);
  return s.shaderSource(i, n), s.compileShader(i), i;
}
const bC = 37297;
let wC = 0;
function SC(s, e) {
  const n = s.split(`
`), i = [], r = Math.max(e - 6, 0), o = Math.min(e + 6, n.length);
  for (let a = r; a < o; a++) {
    const l = a + 1;
    i.push(`${l === e ? ">" : " "} ${l}: ${n[a]}`);
  }
  return i.join(`
`);
}
const Tm = /* @__PURE__ */ new Et();
function MC(s) {
  kt._getMatrix(Tm, kt.workingColorSpace, s);
  const e = `mat3( ${Tm.elements.map((n) => n.toFixed(4))} )`;
  switch (kt.getTransfer(s)) {
    case pu:
      return [e, "LinearTransferOETF"];
    case qt:
      return [e, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space: ", s), [e, "LinearTransferOETF"];
  }
}
function Am(s, e, n) {
  const i = s.getShaderParameter(e, s.COMPILE_STATUS), r = s.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(r);
  if (o) {
    const a = parseInt(o[1]);
    return n.toUpperCase() + `

` + r + `

` + SC(s.getShaderSource(e), a);
  } else
    return r;
}
function CC(s, e) {
  const n = MC(e);
  return [
    `vec4 ${s}( vec4 value ) {`,
    `	return ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
function EC(s, e) {
  let n;
  switch (e) {
    case w0:
      n = "Linear";
      break;
    case S0:
      n = "Reinhard";
      break;
    case M0:
      n = "Cineon";
      break;
    case hf:
      n = "ACESFilmic";
      break;
    case C0:
      n = "AgX";
      break;
    case E0:
      n = "Neutral";
      break;
    case Ux:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + s + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
const Zl = /* @__PURE__ */ new ce();
function TC() {
  kt.getLuminanceCoefficients(Zl);
  const s = Zl.x.toFixed(4), e = Zl.y.toFixed(4), n = Zl.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${s}, ${e}, ${n} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function AC(s) {
  return [
    s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(Sa).join(`
`);
}
function PC(s) {
  const e = [];
  for (const n in s) {
    const i = s[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function DC(s, e) {
  const n = {}, i = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const o = s.getActiveAttrib(e, r), a = o.name;
    let l = 1;
    o.type === s.FLOAT_MAT2 && (l = 2), o.type === s.FLOAT_MAT3 && (l = 3), o.type === s.FLOAT_MAT4 && (l = 4), n[a] = {
      type: o.type,
      location: s.getAttribLocation(e, a),
      locationSize: l
    };
  }
  return n;
}
function Sa(s) {
  return s !== "";
}
function Pm(s, e) {
  const n = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Dm(s, e) {
  return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const RC = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Oh(s) {
  return s.replace(RC, kC);
}
const IC = /* @__PURE__ */ new Map();
function kC(s, e) {
  let n = Tt[e];
  if (n === void 0) {
    const i = IC.get(e);
    if (i !== void 0)
      n = Tt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return Oh(n);
}
const LC = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Rm(s) {
  return s.replace(LC, FC);
}
function FC(s, e, n, i) {
  let r = "";
  for (let o = parseInt(e); o < parseInt(n); o++)
    r += i.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
  return r;
}
function Im(s) {
  let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
  return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function UC(s) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return s.shadowMapType === m0 ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === v0 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === ms && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function OC(s) {
  let e = "ENVMAP_TYPE_CUBE";
  if (s.envMap)
    switch (s.envMapMode) {
      case ko:
      case Lo:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case fu:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function zC(s) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (s.envMap)
    switch (s.envMapMode) {
      case Lo:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function NC(s) {
  let e = "ENVMAP_BLENDING_NONE";
  if (s.envMap)
    switch (s.combine) {
      case b0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case Lx:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case Fx:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function BC(s) {
  const e = s.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: i, maxMip: n };
}
function VC(s, e, n, i) {
  const r = s.getContext(), o = n.defines;
  let a = n.vertexShader, l = n.fragmentShader;
  const c = UC(n), u = OC(n), d = zC(n), h = NC(n), m = BC(n), p = AC(n), y = PC(o), _ = r.createProgram();
  let v, g, S = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (v = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    y
  ].filter(Sa).join(`
`), v.length > 0 && (v += `
`), g = [
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    y
  ].filter(Sa).join(`
`), g.length > 0 && (g += `
`)) : (v = [
    Im(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    y,
    n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    n.batching ? "#define USE_BATCHING" : "",
    n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    n.instancing ? "#define USE_INSTANCING" : "",
    n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.map ? "#define USE_MAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + d : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    n.mapUv ? "#define MAP_UV " + n.mapUv : "",
    n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
    n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
    n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
    n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
    n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
    n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
    n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "",
    n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
    n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
    n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "",
    n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
    n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "",
    n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "",
    n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "",
    n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "",
    n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "",
    n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "",
    n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
    n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "",
    n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "",
    n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "",
    n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
    //
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.skinning ? "#define USE_SKINNING" : "",
    n.morphTargets ? "#define USE_MORPHTARGETS" : "",
    n.morphNormals && n.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    n.morphColors ? "#define USE_MORPHCOLORS" : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "",
    n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(Sa).join(`
`), g = [
    Im(n),
    "#define SHADER_TYPE " + n.shaderType,
    "#define SHADER_NAME " + n.shaderName,
    y,
    n.useFog && n.fog ? "#define USE_FOG" : "",
    n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
    n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    n.map ? "#define USE_MAP" : "",
    n.matcap ? "#define USE_MATCAP" : "",
    n.envMap ? "#define USE_ENVMAP" : "",
    n.envMap ? "#define " + u : "",
    n.envMap ? "#define " + d : "",
    n.envMap ? "#define " + h : "",
    m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
    m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
    m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
    n.lightMap ? "#define USE_LIGHTMAP" : "",
    n.aoMap ? "#define USE_AOMAP" : "",
    n.bumpMap ? "#define USE_BUMPMAP" : "",
    n.normalMap ? "#define USE_NORMALMAP" : "",
    n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    n.anisotropy ? "#define USE_ANISOTROPY" : "",
    n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    n.clearcoat ? "#define USE_CLEARCOAT" : "",
    n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    n.dispersion ? "#define USE_DISPERSION" : "",
    n.iridescence ? "#define USE_IRIDESCENCE" : "",
    n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    n.specularMap ? "#define USE_SPECULARMAP" : "",
    n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    n.metalnessMap ? "#define USE_METALNESSMAP" : "",
    n.alphaMap ? "#define USE_ALPHAMAP" : "",
    n.alphaTest ? "#define USE_ALPHATEST" : "",
    n.alphaHash ? "#define USE_ALPHAHASH" : "",
    n.sheen ? "#define USE_SHEEN" : "",
    n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    n.transmission ? "#define USE_TRANSMISSION" : "",
    n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
    n.vertexColors || n.instancingColor || n.batchingColor ? "#define USE_COLOR" : "",
    n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    n.vertexUv1s ? "#define USE_UV1" : "",
    n.vertexUv2s ? "#define USE_UV2" : "",
    n.vertexUv3s ? "#define USE_UV3" : "",
    n.pointsUvs ? "#define USE_POINTS_UV" : "",
    n.gradientMap ? "#define USE_GRADIENTMAP" : "",
    n.flatShading ? "#define FLAT_SHADED" : "",
    n.doubleSided ? "#define DOUBLE_SIDED" : "",
    n.flipSided ? "#define FLIP_SIDED" : "",
    n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    n.shadowMapEnabled ? "#define " + c : "",
    n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    n.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
    n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    n.toneMapping !== Qs ? "#define TONE_MAPPING" : "",
    n.toneMapping !== Qs ? Tt.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    n.toneMapping !== Qs ? EC("toneMapping", n.toneMapping) : "",
    n.dithering ? "#define DITHERING" : "",
    n.opaque ? "#define OPAQUE" : "",
    Tt.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    CC("linearToOutputTexel", n.outputColorSpace),
    TC(),
    n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
    `
`
  ].filter(Sa).join(`
`)), a = Oh(a), a = Pm(a, n), a = Dm(a, n), l = Oh(l), l = Pm(l, n), l = Dm(l, n), a = Rm(a), l = Rm(l), n.isRawShaderMaterial !== !0 && (S = `#version 300 es
`, v = [
    p,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + v, g = [
    "#define varying in",
    n.glslVersion === Wp ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    n.glslVersion === Wp ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + g);
  const w = S + v + a, x = S + g + l, C = Em(r, r.VERTEX_SHADER, w), E = Em(r, r.FRAGMENT_SHADER, x);
  r.attachShader(_, C), r.attachShader(_, E), n.index0AttributeName !== void 0 ? r.bindAttribLocation(_, 0, n.index0AttributeName) : n.morphTargets === !0 && r.bindAttribLocation(_, 0, "position"), r.linkProgram(_);
  function P(L) {
    if (s.debug.checkShaderErrors) {
      const N = r.getProgramInfoLog(_).trim(), D = r.getShaderInfoLog(C).trim(), O = r.getShaderInfoLog(E).trim();
      let A = !0, G = !0;
      if (r.getProgramParameter(_, r.LINK_STATUS) === !1)
        if (A = !1, typeof s.debug.onShaderError == "function")
          s.debug.onShaderError(r, _, C, E);
        else {
          const he = Am(r, C, "vertex"), ee = Am(r, E, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(_, r.VALIDATE_STATUS) + `

Material Name: ` + L.name + `
Material Type: ` + L.type + `

Program Info Log: ` + N + `
` + he + `
` + ee
          );
        }
      else N !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", N) : (D === "" || O === "") && (G = !1);
      G && (L.diagnostics = {
        runnable: A,
        programLog: N,
        vertexShader: {
          log: D,
          prefix: v
        },
        fragmentShader: {
          log: O,
          prefix: g
        }
      });
    }
    r.deleteShader(C), r.deleteShader(E), T = new Tc(r, _), b = DC(r, _);
  }
  let T;
  this.getUniforms = function() {
    return T === void 0 && P(this), T;
  };
  let b;
  this.getAttributes = function() {
    return b === void 0 && P(this), b;
  };
  let M = n.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return M === !1 && (M = r.getProgramParameter(_, bC)), M;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(_), this.program = void 0;
  }, this.type = n.shaderType, this.name = n.shaderName, this.id = wC++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = C, this.fragmentShader = E, this;
}
let GC = 0;
class HC {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const n = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(n), o = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
    return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(o) === !1 && (a.add(o), o.usedTimes++), this;
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let i = n.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let i = n.get(e);
    return i === void 0 && (i = new WC(e), n.set(e, i)), i;
  }
}
class WC {
  constructor(e) {
    this.id = GC++, this.code = e, this.usedTimes = 0;
  }
}
function $C(s, e, n, i, r, o, a) {
  const l = new Sf(), c = new HC(), u = /* @__PURE__ */ new Set(), d = [], h = r.logarithmicDepthBuffer, m = r.vertexTextures;
  let p = r.precision;
  const y = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function _(b) {
    return u.add(b), b === 0 ? "uv" : `uv${b}`;
  }
  function v(b, M, L, N, D) {
    const O = N.fog, A = D.geometry, G = b.isMeshStandardMaterial ? N.environment : null, he = (b.isMeshStandardMaterial ? n : e).get(b.envMap || G), ee = he && he.mapping === fu ? he.image.height : null, le = y[b.type];
    b.precision !== null && (p = r.getMaxPrecision(b.precision), p !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", p, "instead."));
    const oe = A.morphAttributes.position || A.morphAttributes.normal || A.morphAttributes.color, Y = oe !== void 0 ? oe.length : 0;
    let j = 0;
    A.morphAttributes.position !== void 0 && (j = 1), A.morphAttributes.normal !== void 0 && (j = 2), A.morphAttributes.color !== void 0 && (j = 3);
    let q, te, ne, de;
    if (le) {
      const pt = Qi[le];
      q = pt.vertexShader, te = pt.fragmentShader;
    } else
      q = b.vertexShader, te = b.fragmentShader, c.update(b), ne = c.getVertexShaderID(b), de = c.getFragmentShaderID(b);
    const H = s.getRenderTarget(), X = s.state.buffers.depth.getReversed(), V = D.isInstancedMesh === !0, I = D.isBatchedMesh === !0, F = !!b.map, k = !!b.matcap, Q = !!he, Z = !!b.aoMap, R = !!b.lightMap, ie = !!b.bumpMap, J = !!b.normalMap, B = !!b.displacementMap, $ = !!b.emissiveMap, se = !!b.metalnessMap, U = !!b.roughnessMap, z = b.anisotropy > 0, K = b.clearcoat > 0, ue = b.dispersion > 0, me = b.iridescence > 0, ge = b.sheen > 0, Me = b.transmission > 0, Te = z && !!b.anisotropyMap, Ae = K && !!b.clearcoatMap, Xe = K && !!b.clearcoatNormalMap, Fe = K && !!b.clearcoatRoughnessMap, He = me && !!b.iridescenceMap, Ye = me && !!b.iridescenceThicknessMap, We = ge && !!b.sheenColorMap, ke = ge && !!b.sheenRoughnessMap, nt = !!b.specularMap, Je = !!b.specularColorMap, _t = !!b.specularIntensityMap, we = Me && !!b.transmissionMap, ze = Me && !!b.thicknessMap, De = !!b.gradientMap, Be = !!b.alphaMap, je = b.alphaTest > 0, Ve = !!b.alphaHash, lt = !!b.extensions;
    let rt = Qs;
    b.toneMapped && (H === null || H.isXRRenderTarget === !0) && (rt = s.toneMapping);
    const ut = {
      shaderID: le,
      shaderType: b.type,
      shaderName: b.name,
      vertexShader: q,
      fragmentShader: te,
      defines: b.defines,
      customVertexShaderID: ne,
      customFragmentShaderID: de,
      isRawShaderMaterial: b.isRawShaderMaterial === !0,
      glslVersion: b.glslVersion,
      precision: p,
      batching: I,
      batchingColor: I && D._colorsTexture !== null,
      instancing: V,
      instancingColor: V && D.instanceColor !== null,
      instancingMorph: V && D.morphTexture !== null,
      supportsVertexTextures: m,
      outputColorSpace: H === null ? s.outputColorSpace : H.isXRRenderTarget === !0 ? H.texture.colorSpace : Ho,
      alphaToCoverage: !!b.alphaToCoverage,
      map: F,
      matcap: k,
      envMap: Q,
      envMapMode: Q && he.mapping,
      envMapCubeUVHeight: ee,
      aoMap: Z,
      lightMap: R,
      bumpMap: ie,
      normalMap: J,
      displacementMap: m && B,
      emissiveMap: $,
      normalMapObjectSpace: J && b.normalMapType === Nx,
      normalMapTangentSpace: J && b.normalMapType === xf,
      metalnessMap: se,
      roughnessMap: U,
      anisotropy: z,
      anisotropyMap: Te,
      clearcoat: K,
      clearcoatMap: Ae,
      clearcoatNormalMap: Xe,
      clearcoatRoughnessMap: Fe,
      dispersion: ue,
      iridescence: me,
      iridescenceMap: He,
      iridescenceThicknessMap: Ye,
      sheen: ge,
      sheenColorMap: We,
      sheenRoughnessMap: ke,
      specularMap: nt,
      specularColorMap: Je,
      specularIntensityMap: _t,
      transmission: Me,
      transmissionMap: we,
      thicknessMap: ze,
      gradientMap: De,
      opaque: b.transparent === !1 && b.blending === Ni && b.alphaToCoverage === !1,
      alphaMap: Be,
      alphaTest: je,
      alphaHash: Ve,
      combine: b.combine,
      //
      mapUv: F && _(b.map.channel),
      aoMapUv: Z && _(b.aoMap.channel),
      lightMapUv: R && _(b.lightMap.channel),
      bumpMapUv: ie && _(b.bumpMap.channel),
      normalMapUv: J && _(b.normalMap.channel),
      displacementMapUv: B && _(b.displacementMap.channel),
      emissiveMapUv: $ && _(b.emissiveMap.channel),
      metalnessMapUv: se && _(b.metalnessMap.channel),
      roughnessMapUv: U && _(b.roughnessMap.channel),
      anisotropyMapUv: Te && _(b.anisotropyMap.channel),
      clearcoatMapUv: Ae && _(b.clearcoatMap.channel),
      clearcoatNormalMapUv: Xe && _(b.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Fe && _(b.clearcoatRoughnessMap.channel),
      iridescenceMapUv: He && _(b.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ye && _(b.iridescenceThicknessMap.channel),
      sheenColorMapUv: We && _(b.sheenColorMap.channel),
      sheenRoughnessMapUv: ke && _(b.sheenRoughnessMap.channel),
      specularMapUv: nt && _(b.specularMap.channel),
      specularColorMapUv: Je && _(b.specularColorMap.channel),
      specularIntensityMapUv: _t && _(b.specularIntensityMap.channel),
      transmissionMapUv: we && _(b.transmissionMap.channel),
      thicknessMapUv: ze && _(b.thicknessMap.channel),
      alphaMapUv: Be && _(b.alphaMap.channel),
      //
      vertexTangents: !!A.attributes.tangent && (J || z),
      vertexColors: b.vertexColors,
      vertexAlphas: b.vertexColors === !0 && !!A.attributes.color && A.attributes.color.itemSize === 4,
      pointsUvs: D.isPoints === !0 && !!A.attributes.uv && (F || Be),
      fog: !!O,
      useFog: b.fog === !0,
      fogExp2: !!O && O.isFogExp2,
      flatShading: b.flatShading === !0,
      sizeAttenuation: b.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      reverseDepthBuffer: X,
      skinning: D.isSkinnedMesh === !0,
      morphTargets: A.morphAttributes.position !== void 0,
      morphNormals: A.morphAttributes.normal !== void 0,
      morphColors: A.morphAttributes.color !== void 0,
      morphTargetsCount: Y,
      morphTextureStride: j,
      numDirLights: M.directional.length,
      numPointLights: M.point.length,
      numSpotLights: M.spot.length,
      numSpotLightMaps: M.spotLightMap.length,
      numRectAreaLights: M.rectArea.length,
      numHemiLights: M.hemi.length,
      numDirLightShadows: M.directionalShadowMap.length,
      numPointLightShadows: M.pointShadowMap.length,
      numSpotLightShadows: M.spotShadowMap.length,
      numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps,
      numLightProbes: M.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: b.dithering,
      shadowMapEnabled: s.shadowMap.enabled && L.length > 0,
      shadowMapType: s.shadowMap.type,
      toneMapping: rt,
      decodeVideoTexture: F && b.map.isVideoTexture === !0 && kt.getTransfer(b.map.colorSpace) === qt,
      decodeVideoTextureEmissive: $ && b.emissiveMap.isVideoTexture === !0 && kt.getTransfer(b.emissiveMap.colorSpace) === qt,
      premultipliedAlpha: b.premultipliedAlpha,
      doubleSided: b.side === mn,
      flipSided: b.side === di,
      useDepthPacking: b.depthPacking >= 0,
      depthPacking: b.depthPacking || 0,
      index0AttributeName: b.index0AttributeName,
      extensionClipCullDistance: lt && b.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (lt && b.extensions.multiDraw === !0 || I) && i.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: b.customProgramCacheKey()
    };
    return ut.vertexUv1s = u.has(1), ut.vertexUv2s = u.has(2), ut.vertexUv3s = u.has(3), u.clear(), ut;
  }
  function g(b) {
    const M = [];
    if (b.shaderID ? M.push(b.shaderID) : (M.push(b.customVertexShaderID), M.push(b.customFragmentShaderID)), b.defines !== void 0)
      for (const L in b.defines)
        M.push(L), M.push(b.defines[L]);
    return b.isRawShaderMaterial === !1 && (S(M, b), w(M, b), M.push(s.outputColorSpace)), M.push(b.customProgramCacheKey), M.join();
  }
  function S(b, M) {
    b.push(M.precision), b.push(M.outputColorSpace), b.push(M.envMapMode), b.push(M.envMapCubeUVHeight), b.push(M.mapUv), b.push(M.alphaMapUv), b.push(M.lightMapUv), b.push(M.aoMapUv), b.push(M.bumpMapUv), b.push(M.normalMapUv), b.push(M.displacementMapUv), b.push(M.emissiveMapUv), b.push(M.metalnessMapUv), b.push(M.roughnessMapUv), b.push(M.anisotropyMapUv), b.push(M.clearcoatMapUv), b.push(M.clearcoatNormalMapUv), b.push(M.clearcoatRoughnessMapUv), b.push(M.iridescenceMapUv), b.push(M.iridescenceThicknessMapUv), b.push(M.sheenColorMapUv), b.push(M.sheenRoughnessMapUv), b.push(M.specularMapUv), b.push(M.specularColorMapUv), b.push(M.specularIntensityMapUv), b.push(M.transmissionMapUv), b.push(M.thicknessMapUv), b.push(M.combine), b.push(M.fogExp2), b.push(M.sizeAttenuation), b.push(M.morphTargetsCount), b.push(M.morphAttributeCount), b.push(M.numDirLights), b.push(M.numPointLights), b.push(M.numSpotLights), b.push(M.numSpotLightMaps), b.push(M.numHemiLights), b.push(M.numRectAreaLights), b.push(M.numDirLightShadows), b.push(M.numPointLightShadows), b.push(M.numSpotLightShadows), b.push(M.numSpotLightShadowsWithMaps), b.push(M.numLightProbes), b.push(M.shadowMapType), b.push(M.toneMapping), b.push(M.numClippingPlanes), b.push(M.numClipIntersection), b.push(M.depthPacking);
  }
  function w(b, M) {
    l.disableAll(), M.supportsVertexTextures && l.enable(0), M.instancing && l.enable(1), M.instancingColor && l.enable(2), M.instancingMorph && l.enable(3), M.matcap && l.enable(4), M.envMap && l.enable(5), M.normalMapObjectSpace && l.enable(6), M.normalMapTangentSpace && l.enable(7), M.clearcoat && l.enable(8), M.iridescence && l.enable(9), M.alphaTest && l.enable(10), M.vertexColors && l.enable(11), M.vertexAlphas && l.enable(12), M.vertexUv1s && l.enable(13), M.vertexUv2s && l.enable(14), M.vertexUv3s && l.enable(15), M.vertexTangents && l.enable(16), M.anisotropy && l.enable(17), M.alphaHash && l.enable(18), M.batching && l.enable(19), M.dispersion && l.enable(20), M.batchingColor && l.enable(21), b.push(l.mask), l.disableAll(), M.fog && l.enable(0), M.useFog && l.enable(1), M.flatShading && l.enable(2), M.logarithmicDepthBuffer && l.enable(3), M.reverseDepthBuffer && l.enable(4), M.skinning && l.enable(5), M.morphTargets && l.enable(6), M.morphNormals && l.enable(7), M.morphColors && l.enable(8), M.premultipliedAlpha && l.enable(9), M.shadowMapEnabled && l.enable(10), M.doubleSided && l.enable(11), M.flipSided && l.enable(12), M.useDepthPacking && l.enable(13), M.dithering && l.enable(14), M.transmission && l.enable(15), M.sheen && l.enable(16), M.opaque && l.enable(17), M.pointsUvs && l.enable(18), M.decodeVideoTexture && l.enable(19), M.decodeVideoTextureEmissive && l.enable(20), M.alphaToCoverage && l.enable(21), b.push(l.mask);
  }
  function x(b) {
    const M = y[b.type];
    let L;
    if (M) {
      const N = Qi[M];
      L = ml.clone(N.uniforms);
    } else
      L = b.uniforms;
    return L;
  }
  function C(b, M) {
    let L;
    for (let N = 0, D = d.length; N < D; N++) {
      const O = d[N];
      if (O.cacheKey === M) {
        L = O, ++L.usedTimes;
        break;
      }
    }
    return L === void 0 && (L = new VC(s, M, b, o), d.push(L)), L;
  }
  function E(b) {
    if (--b.usedTimes === 0) {
      const M = d.indexOf(b);
      d[M] = d[d.length - 1], d.pop(), b.destroy();
    }
  }
  function P(b) {
    c.remove(b);
  }
  function T() {
    c.dispose();
  }
  return {
    getParameters: v,
    getProgramCacheKey: g,
    getUniforms: x,
    acquireProgram: C,
    releaseProgram: E,
    releaseShaderCache: P,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: d,
    dispose: T
  };
}
function XC() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(a) {
    return s.has(a);
  }
  function n(a) {
    let l = s.get(a);
    return l === void 0 && (l = {}, s.set(a, l)), l;
  }
  function i(a) {
    s.delete(a);
  }
  function r(a, l, c) {
    s.get(a)[l] = c;
  }
  function o() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: n,
    remove: i,
    update: r,
    dispose: o
  };
}
function jC(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
}
function km(s, e) {
  return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
}
function Lm() {
  const s = [];
  let e = 0;
  const n = [], i = [], r = [];
  function o() {
    e = 0, n.length = 0, i.length = 0, r.length = 0;
  }
  function a(h, m, p, y, _, v) {
    let g = s[e];
    return g === void 0 ? (g = {
      id: h.id,
      object: h,
      geometry: m,
      material: p,
      groupOrder: y,
      renderOrder: h.renderOrder,
      z: _,
      group: v
    }, s[e] = g) : (g.id = h.id, g.object = h, g.geometry = m, g.material = p, g.groupOrder = y, g.renderOrder = h.renderOrder, g.z = _, g.group = v), e++, g;
  }
  function l(h, m, p, y, _, v) {
    const g = a(h, m, p, y, _, v);
    p.transmission > 0 ? i.push(g) : p.transparent === !0 ? r.push(g) : n.push(g);
  }
  function c(h, m, p, y, _, v) {
    const g = a(h, m, p, y, _, v);
    p.transmission > 0 ? i.unshift(g) : p.transparent === !0 ? r.unshift(g) : n.unshift(g);
  }
  function u(h, m) {
    n.length > 1 && n.sort(h || jC), i.length > 1 && i.sort(m || km), r.length > 1 && r.sort(m || km);
  }
  function d() {
    for (let h = e, m = s.length; h < m; h++) {
      const p = s[h];
      if (p.id === null) break;
      p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: r,
    init: o,
    push: l,
    unshift: c,
    finish: d,
    sort: u
  };
}
function YC() {
  let s = /* @__PURE__ */ new WeakMap();
  function e(i, r) {
    const o = s.get(i);
    let a;
    return o === void 0 ? (a = new Lm(), s.set(i, [a])) : r >= o.length ? (a = new Lm(), o.push(a)) : a = o[r], a;
  }
  function n() {
    s = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: n
  };
}
function qC() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new ce(),
            color: new Mt()
          };
          break;
        case "SpotLight":
          n = {
            position: new ce(),
            direction: new ce(),
            color: new Mt(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          n = {
            position: new ce(),
            color: new Mt(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new ce(),
            skyColor: new Mt(),
            groundColor: new Mt()
          };
          break;
        case "RectAreaLight":
          n = {
            color: new Mt(),
            position: new ce(),
            halfWidth: new ce(),
            halfHeight: new ce()
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
function ZC() {
  const s = {};
  return {
    get: function(e) {
      if (s[e.id] !== void 0)
        return s[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new st()
          };
          break;
        case "SpotLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new st()
          };
          break;
        case "PointLight":
          n = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new st(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return s[e.id] = n, n;
    }
  };
}
let KC = 0;
function JC(s, e) {
  return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
}
function QC(s) {
  const e = new qC(), n = ZC(), i = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++) i.probe.push(new ce());
  const r = new ce(), o = new Zt(), a = new Zt();
  function l(u) {
    let d = 0, h = 0, m = 0;
    for (let b = 0; b < 9; b++) i.probe[b].set(0, 0, 0);
    let p = 0, y = 0, _ = 0, v = 0, g = 0, S = 0, w = 0, x = 0, C = 0, E = 0, P = 0;
    u.sort(JC);
    for (let b = 0, M = u.length; b < M; b++) {
      const L = u[b], N = L.color, D = L.intensity, O = L.distance, A = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
      if (L.isAmbientLight)
        d += N.r * D, h += N.g * D, m += N.b * D;
      else if (L.isLightProbe) {
        for (let G = 0; G < 9; G++)
          i.probe[G].addScaledVector(L.sh.coefficients[G], D);
        P++;
      } else if (L.isDirectionalLight) {
        const G = e.get(L);
        if (G.color.copy(L.color).multiplyScalar(L.intensity), L.castShadow) {
          const he = L.shadow, ee = n.get(L);
          ee.shadowIntensity = he.intensity, ee.shadowBias = he.bias, ee.shadowNormalBias = he.normalBias, ee.shadowRadius = he.radius, ee.shadowMapSize = he.mapSize, i.directionalShadow[p] = ee, i.directionalShadowMap[p] = A, i.directionalShadowMatrix[p] = L.shadow.matrix, S++;
        }
        i.directional[p] = G, p++;
      } else if (L.isSpotLight) {
        const G = e.get(L);
        G.position.setFromMatrixPosition(L.matrixWorld), G.color.copy(N).multiplyScalar(D), G.distance = O, G.coneCos = Math.cos(L.angle), G.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), G.decay = L.decay, i.spot[_] = G;
        const he = L.shadow;
        if (L.map && (i.spotLightMap[C] = L.map, C++, he.updateMatrices(L), L.castShadow && E++), i.spotLightMatrix[_] = he.matrix, L.castShadow) {
          const ee = n.get(L);
          ee.shadowIntensity = he.intensity, ee.shadowBias = he.bias, ee.shadowNormalBias = he.normalBias, ee.shadowRadius = he.radius, ee.shadowMapSize = he.mapSize, i.spotShadow[_] = ee, i.spotShadowMap[_] = A, x++;
        }
        _++;
      } else if (L.isRectAreaLight) {
        const G = e.get(L);
        G.color.copy(N).multiplyScalar(D), G.halfWidth.set(L.width * 0.5, 0, 0), G.halfHeight.set(0, L.height * 0.5, 0), i.rectArea[v] = G, v++;
      } else if (L.isPointLight) {
        const G = e.get(L);
        if (G.color.copy(L.color).multiplyScalar(L.intensity), G.distance = L.distance, G.decay = L.decay, L.castShadow) {
          const he = L.shadow, ee = n.get(L);
          ee.shadowIntensity = he.intensity, ee.shadowBias = he.bias, ee.shadowNormalBias = he.normalBias, ee.shadowRadius = he.radius, ee.shadowMapSize = he.mapSize, ee.shadowCameraNear = he.camera.near, ee.shadowCameraFar = he.camera.far, i.pointShadow[y] = ee, i.pointShadowMap[y] = A, i.pointShadowMatrix[y] = L.shadow.matrix, w++;
        }
        i.point[y] = G, y++;
      } else if (L.isHemisphereLight) {
        const G = e.get(L);
        G.skyColor.copy(L.color).multiplyScalar(D), G.groundColor.copy(L.groundColor).multiplyScalar(D), i.hemi[g] = G, g++;
      }
    }
    v > 0 && (s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = tt.LTC_FLOAT_1, i.rectAreaLTC2 = tt.LTC_FLOAT_2) : (i.rectAreaLTC1 = tt.LTC_HALF_1, i.rectAreaLTC2 = tt.LTC_HALF_2)), i.ambient[0] = d, i.ambient[1] = h, i.ambient[2] = m;
    const T = i.hash;
    (T.directionalLength !== p || T.pointLength !== y || T.spotLength !== _ || T.rectAreaLength !== v || T.hemiLength !== g || T.numDirectionalShadows !== S || T.numPointShadows !== w || T.numSpotShadows !== x || T.numSpotMaps !== C || T.numLightProbes !== P) && (i.directional.length = p, i.spot.length = _, i.rectArea.length = v, i.point.length = y, i.hemi.length = g, i.directionalShadow.length = S, i.directionalShadowMap.length = S, i.pointShadow.length = w, i.pointShadowMap.length = w, i.spotShadow.length = x, i.spotShadowMap.length = x, i.directionalShadowMatrix.length = S, i.pointShadowMatrix.length = w, i.spotLightMatrix.length = x + C - E, i.spotLightMap.length = C, i.numSpotLightShadowsWithMaps = E, i.numLightProbes = P, T.directionalLength = p, T.pointLength = y, T.spotLength = _, T.rectAreaLength = v, T.hemiLength = g, T.numDirectionalShadows = S, T.numPointShadows = w, T.numSpotShadows = x, T.numSpotMaps = C, T.numLightProbes = P, i.version = KC++);
  }
  function c(u, d) {
    let h = 0, m = 0, p = 0, y = 0, _ = 0;
    const v = d.matrixWorldInverse;
    for (let g = 0, S = u.length; g < S; g++) {
      const w = u[g];
      if (w.isDirectionalLight) {
        const x = i.directional[h];
        x.direction.setFromMatrixPosition(w.matrixWorld), r.setFromMatrixPosition(w.target.matrixWorld), x.direction.sub(r), x.direction.transformDirection(v), h++;
      } else if (w.isSpotLight) {
        const x = i.spot[p];
        x.position.setFromMatrixPosition(w.matrixWorld), x.position.applyMatrix4(v), x.direction.setFromMatrixPosition(w.matrixWorld), r.setFromMatrixPosition(w.target.matrixWorld), x.direction.sub(r), x.direction.transformDirection(v), p++;
      } else if (w.isRectAreaLight) {
        const x = i.rectArea[y];
        x.position.setFromMatrixPosition(w.matrixWorld), x.position.applyMatrix4(v), a.identity(), o.copy(w.matrixWorld), o.premultiply(v), a.extractRotation(o), x.halfWidth.set(w.width * 0.5, 0, 0), x.halfHeight.set(0, w.height * 0.5, 0), x.halfWidth.applyMatrix4(a), x.halfHeight.applyMatrix4(a), y++;
      } else if (w.isPointLight) {
        const x = i.point[m];
        x.position.setFromMatrixPosition(w.matrixWorld), x.position.applyMatrix4(v), m++;
      } else if (w.isHemisphereLight) {
        const x = i.hemi[_];
        x.direction.setFromMatrixPosition(w.matrixWorld), x.direction.transformDirection(v), _++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: i
  };
}
function Fm(s) {
  const e = new QC(s), n = [], i = [];
  function r(d) {
    u.camera = d, n.length = 0, i.length = 0;
  }
  function o(d) {
    n.push(d);
  }
  function a(d) {
    i.push(d);
  }
  function l() {
    e.setup(n);
  }
  function c(d) {
    e.setupView(n, d);
  }
  const u = {
    lightsArray: n,
    shadowsArray: i,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: r,
    state: u,
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a
  };
}
function eE(s) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(r, o = 0) {
    const a = e.get(r);
    let l;
    return a === void 0 ? (l = new Fm(s), e.set(r, [l])) : o >= a.length ? (l = new Fm(s), a.push(l)) : l = a[o], l;
  }
  function i() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: i
  };
}
class Tf extends Gr {
  static get type() {
    return "MeshDepthMaterial";
  }
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.depthPacking = zx, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class J0 extends Gr {
  static get type() {
    return "MeshDistanceMaterial";
  }
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const tE = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, nE = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function iE(s, e, n) {
  let i = new Mf();
  const r = new st(), o = new st(), a = new jt(), l = new Tf({ depthPacking: _f }), c = new J0(), u = {}, d = n.maxTextureSize, h = { [er]: di, [di]: er, [mn]: mn }, m = new Fn({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new st() },
      radius: { value: 4 }
    },
    vertexShader: tE,
    fragmentShader: nE
  }), p = m.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const y = new Nt();
  y.setAttribute(
    "position",
    new bi(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const _ = new qe(y, m), v = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = m0;
  let g = this.type;
  this.render = function(E, P, T) {
    if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || E.length === 0) return;
    const b = s.getRenderTarget(), M = s.getActiveCubeFace(), L = s.getActiveMipmapLevel(), N = s.state;
    N.setBlending(ts), N.buffers.color.setClear(1, 1, 1, 1), N.buffers.depth.setTest(!0), N.setScissorTest(!1);
    const D = g !== ms && this.type === ms, O = g === ms && this.type !== ms;
    for (let A = 0, G = E.length; A < G; A++) {
      const he = E[A], ee = he.shadow;
      if (ee === void 0) {
        console.warn("THREE.WebGLShadowMap:", he, "has no shadow.");
        continue;
      }
      if (ee.autoUpdate === !1 && ee.needsUpdate === !1) continue;
      r.copy(ee.mapSize);
      const le = ee.getFrameExtents();
      if (r.multiply(le), o.copy(ee.mapSize), (r.x > d || r.y > d) && (r.x > d && (o.x = Math.floor(d / le.x), r.x = o.x * le.x, ee.mapSize.x = o.x), r.y > d && (o.y = Math.floor(d / le.y), r.y = o.y * le.y, ee.mapSize.y = o.y)), ee.map === null || D === !0 || O === !0) {
        const Y = this.type !== ms ? { minFilter: Ln, magFilter: Ln } : {};
        ee.map !== null && ee.map.dispose(), ee.map = new Hi(r.x, r.y, Y), ee.map.texture.name = he.name + ".shadowMap", ee.camera.updateProjectionMatrix();
      }
      s.setRenderTarget(ee.map), s.clear();
      const oe = ee.getViewportCount();
      for (let Y = 0; Y < oe; Y++) {
        const j = ee.getViewport(Y);
        a.set(
          o.x * j.x,
          o.y * j.y,
          o.x * j.z,
          o.y * j.w
        ), N.viewport(a), ee.updateMatrices(he, Y), i = ee.getFrustum(), x(P, T, ee.camera, he, this.type);
      }
      ee.isPointLightShadow !== !0 && this.type === ms && S(ee, T), ee.needsUpdate = !1;
    }
    g = this.type, v.needsUpdate = !1, s.setRenderTarget(b, M, L);
  };
  function S(E, P) {
    const T = e.update(_);
    m.defines.VSM_SAMPLES !== E.blurSamples && (m.defines.VSM_SAMPLES = E.blurSamples, p.defines.VSM_SAMPLES = E.blurSamples, m.needsUpdate = !0, p.needsUpdate = !0), E.mapPass === null && (E.mapPass = new Hi(r.x, r.y)), m.uniforms.shadow_pass.value = E.map.texture, m.uniforms.resolution.value = E.mapSize, m.uniforms.radius.value = E.radius, s.setRenderTarget(E.mapPass), s.clear(), s.renderBufferDirect(P, null, T, m, _, null), p.uniforms.shadow_pass.value = E.mapPass.texture, p.uniforms.resolution.value = E.mapSize, p.uniforms.radius.value = E.radius, s.setRenderTarget(E.map), s.clear(), s.renderBufferDirect(P, null, T, p, _, null);
  }
  function w(E, P, T, b) {
    let M = null;
    const L = T.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
    if (L !== void 0)
      M = L;
    else if (M = T.isPointLight === !0 ? c : l, s.localClippingEnabled && P.clipShadows === !0 && Array.isArray(P.clippingPlanes) && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0 || P.map && P.alphaTest > 0) {
      const N = M.uuid, D = P.uuid;
      let O = u[N];
      O === void 0 && (O = {}, u[N] = O);
      let A = O[D];
      A === void 0 && (A = M.clone(), O[D] = A, P.addEventListener("dispose", C)), M = A;
    }
    if (M.visible = P.visible, M.wireframe = P.wireframe, b === ms ? M.side = P.shadowSide !== null ? P.shadowSide : P.side : M.side = P.shadowSide !== null ? P.shadowSide : h[P.side], M.alphaMap = P.alphaMap, M.alphaTest = P.alphaTest, M.map = P.map, M.clipShadows = P.clipShadows, M.clippingPlanes = P.clippingPlanes, M.clipIntersection = P.clipIntersection, M.displacementMap = P.displacementMap, M.displacementScale = P.displacementScale, M.displacementBias = P.displacementBias, M.wireframeLinewidth = P.wireframeLinewidth, M.linewidth = P.linewidth, T.isPointLight === !0 && M.isMeshDistanceMaterial === !0) {
      const N = s.properties.get(M);
      N.light = T;
    }
    return M;
  }
  function x(E, P, T, b, M) {
    if (E.visible === !1) return;
    if (E.layers.test(P.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && M === ms) && (!E.frustumCulled || i.intersectsObject(E))) {
      E.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse, E.matrixWorld);
      const D = e.update(E), O = E.material;
      if (Array.isArray(O)) {
        const A = D.groups;
        for (let G = 0, he = A.length; G < he; G++) {
          const ee = A[G], le = O[ee.materialIndex];
          if (le && le.visible) {
            const oe = w(E, le, b, M);
            E.onBeforeShadow(s, E, P, T, D, oe, ee), s.renderBufferDirect(T, null, D, oe, E, ee), E.onAfterShadow(s, E, P, T, D, oe, ee);
          }
        }
      } else if (O.visible) {
        const A = w(E, O, b, M);
        E.onBeforeShadow(s, E, P, T, D, A, null), s.renderBufferDirect(T, null, D, A, E, null), E.onAfterShadow(s, E, P, T, D, A, null);
      }
    }
    const N = E.children;
    for (let D = 0, O = N.length; D < O; D++)
      x(N[D], P, T, b, M);
  }
  function C(E) {
    E.target.removeEventListener("dispose", C);
    for (const T in u) {
      const b = u[T], M = E.target.uuid;
      M in b && (b[M].dispose(), delete b[M]);
    }
  }
}
const sE = {
  [eh]: th,
  [nh]: rh,
  [ih]: oh,
  [Io]: sh,
  [th]: eh,
  [rh]: nh,
  [oh]: ih,
  [sh]: Io
};
function rE(s, e) {
  function n() {
    let we = !1;
    const ze = new jt();
    let De = null;
    const Be = new jt(0, 0, 0, 0);
    return {
      setMask: function(je) {
        De !== je && !we && (s.colorMask(je, je, je, je), De = je);
      },
      setLocked: function(je) {
        we = je;
      },
      setClear: function(je, Ve, lt, rt, ut) {
        ut === !0 && (je *= rt, Ve *= rt, lt *= rt), ze.set(je, Ve, lt, rt), Be.equals(ze) === !1 && (s.clearColor(je, Ve, lt, rt), Be.copy(ze));
      },
      reset: function() {
        we = !1, De = null, Be.set(-1, 0, 0, 0);
      }
    };
  }
  function i() {
    let we = !1, ze = !1, De = null, Be = null, je = null;
    return {
      setReversed: function(Ve) {
        if (ze !== Ve) {
          const lt = e.get("EXT_clip_control");
          ze ? lt.clipControlEXT(lt.LOWER_LEFT_EXT, lt.ZERO_TO_ONE_EXT) : lt.clipControlEXT(lt.LOWER_LEFT_EXT, lt.NEGATIVE_ONE_TO_ONE_EXT);
          const rt = je;
          je = null, this.setClear(rt);
        }
        ze = Ve;
      },
      getReversed: function() {
        return ze;
      },
      setTest: function(Ve) {
        Ve ? H(s.DEPTH_TEST) : X(s.DEPTH_TEST);
      },
      setMask: function(Ve) {
        De !== Ve && !we && (s.depthMask(Ve), De = Ve);
      },
      setFunc: function(Ve) {
        if (ze && (Ve = sE[Ve]), Be !== Ve) {
          switch (Ve) {
            case eh:
              s.depthFunc(s.NEVER);
              break;
            case th:
              s.depthFunc(s.ALWAYS);
              break;
            case nh:
              s.depthFunc(s.LESS);
              break;
            case Io:
              s.depthFunc(s.LEQUAL);
              break;
            case ih:
              s.depthFunc(s.EQUAL);
              break;
            case sh:
              s.depthFunc(s.GEQUAL);
              break;
            case rh:
              s.depthFunc(s.GREATER);
              break;
            case oh:
              s.depthFunc(s.NOTEQUAL);
              break;
            default:
              s.depthFunc(s.LEQUAL);
          }
          Be = Ve;
        }
      },
      setLocked: function(Ve) {
        we = Ve;
      },
      setClear: function(Ve) {
        je !== Ve && (ze && (Ve = 1 - Ve), s.clearDepth(Ve), je = Ve);
      },
      reset: function() {
        we = !1, De = null, Be = null, je = null, ze = !1;
      }
    };
  }
  function r() {
    let we = !1, ze = null, De = null, Be = null, je = null, Ve = null, lt = null, rt = null, ut = null;
    return {
      setTest: function(pt) {
        we || (pt ? H(s.STENCIL_TEST) : X(s.STENCIL_TEST));
      },
      setMask: function(pt) {
        ze !== pt && !we && (s.stencilMask(pt), ze = pt);
      },
      setFunc: function(pt, Ot, Kt) {
        (De !== pt || Be !== Ot || je !== Kt) && (s.stencilFunc(pt, Ot, Kt), De = pt, Be = Ot, je = Kt);
      },
      setOp: function(pt, Ot, Kt) {
        (Ve !== pt || lt !== Ot || rt !== Kt) && (s.stencilOp(pt, Ot, Kt), Ve = pt, lt = Ot, rt = Kt);
      },
      setLocked: function(pt) {
        we = pt;
      },
      setClear: function(pt) {
        ut !== pt && (s.clearStencil(pt), ut = pt);
      },
      reset: function() {
        we = !1, ze = null, De = null, Be = null, je = null, Ve = null, lt = null, rt = null, ut = null;
      }
    };
  }
  const o = new n(), a = new i(), l = new r(), c = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let d = {}, h = {}, m = /* @__PURE__ */ new WeakMap(), p = [], y = null, _ = !1, v = null, g = null, S = null, w = null, x = null, C = null, E = null, P = new Mt(0, 0, 0), T = 0, b = !1, M = null, L = null, N = null, D = null, O = null;
  const A = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let G = !1, he = 0;
  const ee = s.getParameter(s.VERSION);
  ee.indexOf("WebGL") !== -1 ? (he = parseFloat(/^WebGL (\d)/.exec(ee)[1]), G = he >= 1) : ee.indexOf("OpenGL ES") !== -1 && (he = parseFloat(/^OpenGL ES (\d)/.exec(ee)[1]), G = he >= 2);
  let le = null, oe = {};
  const Y = s.getParameter(s.SCISSOR_BOX), j = s.getParameter(s.VIEWPORT), q = new jt().fromArray(Y), te = new jt().fromArray(j);
  function ne(we, ze, De, Be) {
    const je = new Uint8Array(4), Ve = s.createTexture();
    s.bindTexture(we, Ve), s.texParameteri(we, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(we, s.TEXTURE_MAG_FILTER, s.NEAREST);
    for (let lt = 0; lt < De; lt++)
      we === s.TEXTURE_3D || we === s.TEXTURE_2D_ARRAY ? s.texImage3D(ze, 0, s.RGBA, 1, 1, Be, 0, s.RGBA, s.UNSIGNED_BYTE, je) : s.texImage2D(ze + lt, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, je);
    return Ve;
  }
  const de = {};
  de[s.TEXTURE_2D] = ne(s.TEXTURE_2D, s.TEXTURE_2D, 1), de[s.TEXTURE_CUBE_MAP] = ne(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), de[s.TEXTURE_2D_ARRAY] = ne(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), de[s.TEXTURE_3D] = ne(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1), o.setClear(0, 0, 0, 1), a.setClear(1), l.setClear(0), H(s.DEPTH_TEST), a.setFunc(Io), ie(!1), J(Vp), H(s.CULL_FACE), Z(ts);
  function H(we) {
    d[we] !== !0 && (s.enable(we), d[we] = !0);
  }
  function X(we) {
    d[we] !== !1 && (s.disable(we), d[we] = !1);
  }
  function V(we, ze) {
    return h[we] !== ze ? (s.bindFramebuffer(we, ze), h[we] = ze, we === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = ze), we === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = ze), !0) : !1;
  }
  function I(we, ze) {
    let De = p, Be = !1;
    if (we) {
      De = m.get(ze), De === void 0 && (De = [], m.set(ze, De));
      const je = we.textures;
      if (De.length !== je.length || De[0] !== s.COLOR_ATTACHMENT0) {
        for (let Ve = 0, lt = je.length; Ve < lt; Ve++)
          De[Ve] = s.COLOR_ATTACHMENT0 + Ve;
        De.length = je.length, Be = !0;
      }
    } else
      De[0] !== s.BACK && (De[0] = s.BACK, Be = !0);
    Be && s.drawBuffers(De);
  }
  function F(we) {
    return y !== we ? (s.useProgram(we), y = we, !0) : !1;
  }
  const k = {
    [Oi]: s.FUNC_ADD,
    [g0]: s.FUNC_SUBTRACT,
    [Sx]: s.FUNC_REVERSE_SUBTRACT
  };
  k[y0] = s.MIN, k[_0] = s.MAX;
  const Q = {
    [Mx]: s.ZERO,
    [vs]: s.ONE,
    [Cx]: s.SRC_COLOR,
    [Vc]: s.SRC_ALPHA,
    [Px]: s.SRC_ALPHA_SATURATE,
    [Ax]: s.DST_COLOR,
    [Ex]: s.DST_ALPHA,
    [Qd]: s.ONE_MINUS_SRC_COLOR,
    [el]: s.ONE_MINUS_SRC_ALPHA,
    [x0]: s.ONE_MINUS_DST_COLOR,
    [Tx]: s.ONE_MINUS_DST_ALPHA,
    [Dx]: s.CONSTANT_COLOR,
    [Rx]: s.ONE_MINUS_CONSTANT_COLOR,
    [Ix]: s.CONSTANT_ALPHA,
    [kx]: s.ONE_MINUS_CONSTANT_ALPHA
  };
  function Z(we, ze, De, Be, je, Ve, lt, rt, ut, pt) {
    if (we === ts) {
      _ === !0 && (X(s.BLEND), _ = !1);
      return;
    }
    if (_ === !1 && (H(s.BLEND), _ = !0), we !== Cr) {
      if (we !== v || pt !== b) {
        if ((g !== Oi || x !== Oi) && (s.blendEquation(s.FUNC_ADD), g = Oi, x = Oi), pt)
          switch (we) {
            case Ni:
              s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case Qa:
              s.blendFunc(s.ONE, s.ONE);
              break;
            case Jd:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Eo:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", we);
              break;
          }
        else
          switch (we) {
            case Ni:
              s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
              break;
            case Qa:
              s.blendFunc(s.SRC_ALPHA, s.ONE);
              break;
            case Jd:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
              break;
            case Eo:
              s.blendFunc(s.ZERO, s.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", we);
              break;
          }
        S = null, w = null, C = null, E = null, P.set(0, 0, 0), T = 0, v = we, b = pt;
      }
      return;
    }
    je = je || ze, Ve = Ve || De, lt = lt || Be, (ze !== g || je !== x) && (s.blendEquationSeparate(k[ze], k[je]), g = ze, x = je), (De !== S || Be !== w || Ve !== C || lt !== E) && (s.blendFuncSeparate(Q[De], Q[Be], Q[Ve], Q[lt]), S = De, w = Be, C = Ve, E = lt), (rt.equals(P) === !1 || ut !== T) && (s.blendColor(rt.r, rt.g, rt.b, ut), P.copy(rt), T = ut), v = we, b = !1;
  }
  function R(we, ze) {
    we.side === mn ? X(s.CULL_FACE) : H(s.CULL_FACE);
    let De = we.side === di;
    ze && (De = !De), ie(De), we.blending === Ni && we.transparent === !1 ? Z(ts) : Z(we.blending, we.blendEquation, we.blendSrc, we.blendDst, we.blendEquationAlpha, we.blendSrcAlpha, we.blendDstAlpha, we.blendColor, we.blendAlpha, we.premultipliedAlpha), a.setFunc(we.depthFunc), a.setTest(we.depthTest), a.setMask(we.depthWrite), o.setMask(we.colorWrite);
    const Be = we.stencilWrite;
    l.setTest(Be), Be && (l.setMask(we.stencilWriteMask), l.setFunc(we.stencilFunc, we.stencilRef, we.stencilFuncMask), l.setOp(we.stencilFail, we.stencilZFail, we.stencilZPass)), $(we.polygonOffset, we.polygonOffsetFactor, we.polygonOffsetUnits), we.alphaToCoverage === !0 ? H(s.SAMPLE_ALPHA_TO_COVERAGE) : X(s.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function ie(we) {
    M !== we && (we ? s.frontFace(s.CW) : s.frontFace(s.CCW), M = we);
  }
  function J(we) {
    we !== bx ? (H(s.CULL_FACE), we !== L && (we === Vp ? s.cullFace(s.BACK) : we === wx ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : X(s.CULL_FACE), L = we;
  }
  function B(we) {
    we !== N && (G && s.lineWidth(we), N = we);
  }
  function $(we, ze, De) {
    we ? (H(s.POLYGON_OFFSET_FILL), (D !== ze || O !== De) && (s.polygonOffset(ze, De), D = ze, O = De)) : X(s.POLYGON_OFFSET_FILL);
  }
  function se(we) {
    we ? H(s.SCISSOR_TEST) : X(s.SCISSOR_TEST);
  }
  function U(we) {
    we === void 0 && (we = s.TEXTURE0 + A - 1), le !== we && (s.activeTexture(we), le = we);
  }
  function z(we, ze, De) {
    De === void 0 && (le === null ? De = s.TEXTURE0 + A - 1 : De = le);
    let Be = oe[De];
    Be === void 0 && (Be = { type: void 0, texture: void 0 }, oe[De] = Be), (Be.type !== we || Be.texture !== ze) && (le !== De && (s.activeTexture(De), le = De), s.bindTexture(we, ze || de[we]), Be.type = we, Be.texture = ze);
  }
  function K() {
    const we = oe[le];
    we !== void 0 && we.type !== void 0 && (s.bindTexture(we.type, null), we.type = void 0, we.texture = void 0);
  }
  function ue() {
    try {
      s.compressedTexImage2D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function me() {
    try {
      s.compressedTexImage3D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function ge() {
    try {
      s.texSubImage2D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function Me() {
    try {
      s.texSubImage3D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function Te() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function Ae() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function Xe() {
    try {
      s.texStorage2D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function Fe() {
    try {
      s.texStorage3D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function He() {
    try {
      s.texImage2D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function Ye() {
    try {
      s.texImage3D.apply(s, arguments);
    } catch (we) {
      console.error("THREE.WebGLState:", we);
    }
  }
  function We(we) {
    q.equals(we) === !1 && (s.scissor(we.x, we.y, we.z, we.w), q.copy(we));
  }
  function ke(we) {
    te.equals(we) === !1 && (s.viewport(we.x, we.y, we.z, we.w), te.copy(we));
  }
  function nt(we, ze) {
    let De = u.get(ze);
    De === void 0 && (De = /* @__PURE__ */ new WeakMap(), u.set(ze, De));
    let Be = De.get(we);
    Be === void 0 && (Be = s.getUniformBlockIndex(ze, we.name), De.set(we, Be));
  }
  function Je(we, ze) {
    const Be = u.get(ze).get(we);
    c.get(ze) !== Be && (s.uniformBlockBinding(ze, Be, we.__bindingPointIndex), c.set(ze, Be));
  }
  function _t() {
    s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), a.setReversed(!1), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), d = {}, le = null, oe = {}, h = {}, m = /* @__PURE__ */ new WeakMap(), p = [], y = null, _ = !1, v = null, g = null, S = null, w = null, x = null, C = null, E = null, P = new Mt(0, 0, 0), T = 0, b = !1, M = null, L = null, N = null, D = null, O = null, q.set(0, 0, s.canvas.width, s.canvas.height), te.set(0, 0, s.canvas.width, s.canvas.height), o.reset(), a.reset(), l.reset();
  }
  return {
    buffers: {
      color: o,
      depth: a,
      stencil: l
    },
    enable: H,
    disable: X,
    bindFramebuffer: V,
    drawBuffers: I,
    useProgram: F,
    setBlending: Z,
    setMaterial: R,
    setFlipSided: ie,
    setCullFace: J,
    setLineWidth: B,
    setPolygonOffset: $,
    setScissorTest: se,
    activeTexture: U,
    bindTexture: z,
    unbindTexture: K,
    compressedTexImage2D: ue,
    compressedTexImage3D: me,
    texImage2D: He,
    texImage3D: Ye,
    updateUBOMapping: nt,
    uniformBlockBinding: Je,
    texStorage2D: Xe,
    texStorage3D: Fe,
    texSubImage2D: ge,
    texSubImage3D: Me,
    compressedTexSubImage2D: Te,
    compressedTexSubImage3D: Ae,
    scissor: We,
    viewport: ke,
    reset: _t
  };
}
function Um(s, e, n, i) {
  const r = oE(i);
  switch (n) {
    case R0:
      return s * e;
    case k0:
      return s * e;
    case L0:
      return s * e * 2;
    case Gc:
      return s * e / r.components * r.byteLength;
    case vf:
      return s * e / r.components * r.byteLength;
    case F0:
      return s * e * 2 / r.components * r.byteLength;
    case gf:
      return s * e * 2 / r.components * r.byteLength;
    case I0:
      return s * e * 3 / r.components * r.byteLength;
    case $n:
      return s * e * 4 / r.components * r.byteLength;
    case yf:
      return s * e * 4 / r.components * r.byteLength;
    case wc:
    case Sc:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Mc:
    case Cc:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case hh:
    case ph:
      return Math.max(s, 16) * Math.max(e, 8) / 4;
    case dh:
    case fh:
      return Math.max(s, 8) * Math.max(e, 8) / 2;
    case mh:
    case vh:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case gh:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case yh:
      return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case _h:
      return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case xh:
      return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case bh:
      return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case wh:
      return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Sh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Mh:
      return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Ch:
      return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Eh:
      return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Th:
      return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Ah:
      return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Ph:
      return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Dh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Rh:
      return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case Ec:
    case Ih:
    case kh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case U0:
    case Lh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case Fh:
    case Uh:
      return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${n} format.`
  );
}
function oE(s) {
  switch (s) {
    case is:
    case A0:
      return { byteLength: 1, components: 1 };
    case tl:
    case P0:
    case sr:
      return { byteLength: 2, components: 1 };
    case pf:
    case mf:
      return { byteLength: 2, components: 4 };
    case zr:
    case ff:
    case ui:
      return { byteLength: 4, components: 1 };
    case D0:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${s}.`);
}
function aE(s, e, n, i, r, o, a) {
  const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new st(), d = /* @__PURE__ */ new WeakMap();
  let h;
  const m = /* @__PURE__ */ new WeakMap();
  let p = !1;
  try {
    p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function y(U, z) {
    return p ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(U, z)
    ) : nl("canvas");
  }
  function _(U, z, K) {
    let ue = 1;
    const me = se(U);
    if ((me.width > K || me.height > K) && (ue = K / Math.max(me.width, me.height)), ue < 1)
      if (typeof HTMLImageElement < "u" && U instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && U instanceof ImageBitmap || typeof VideoFrame < "u" && U instanceof VideoFrame) {
        const ge = Math.floor(ue * me.width), Me = Math.floor(ue * me.height);
        h === void 0 && (h = y(ge, Me));
        const Te = z ? y(ge, Me) : h;
        return Te.width = ge, Te.height = Me, Te.getContext("2d").drawImage(U, 0, 0, ge, Me), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + me.width + "x" + me.height + ") to (" + ge + "x" + Me + ")."), Te;
      } else
        return "data" in U && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + me.width + "x" + me.height + ")."), U;
    return U;
  }
  function v(U) {
    return U.generateMipmaps;
  }
  function g(U) {
    s.generateMipmap(U);
  }
  function S(U) {
    return U.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : U.isWebGL3DRenderTarget ? s.TEXTURE_3D : U.isWebGLArrayRenderTarget || U.isCompressedArrayTexture ? s.TEXTURE_2D_ARRAY : s.TEXTURE_2D;
  }
  function w(U, z, K, ue, me = !1) {
    if (U !== null) {
      if (s[U] !== void 0) return s[U];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + U + "'");
    }
    let ge = z;
    if (z === s.RED && (K === s.FLOAT && (ge = s.R32F), K === s.HALF_FLOAT && (ge = s.R16F), K === s.UNSIGNED_BYTE && (ge = s.R8)), z === s.RED_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.R8UI), K === s.UNSIGNED_SHORT && (ge = s.R16UI), K === s.UNSIGNED_INT && (ge = s.R32UI), K === s.BYTE && (ge = s.R8I), K === s.SHORT && (ge = s.R16I), K === s.INT && (ge = s.R32I)), z === s.RG && (K === s.FLOAT && (ge = s.RG32F), K === s.HALF_FLOAT && (ge = s.RG16F), K === s.UNSIGNED_BYTE && (ge = s.RG8)), z === s.RG_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RG8UI), K === s.UNSIGNED_SHORT && (ge = s.RG16UI), K === s.UNSIGNED_INT && (ge = s.RG32UI), K === s.BYTE && (ge = s.RG8I), K === s.SHORT && (ge = s.RG16I), K === s.INT && (ge = s.RG32I)), z === s.RGB_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RGB8UI), K === s.UNSIGNED_SHORT && (ge = s.RGB16UI), K === s.UNSIGNED_INT && (ge = s.RGB32UI), K === s.BYTE && (ge = s.RGB8I), K === s.SHORT && (ge = s.RGB16I), K === s.INT && (ge = s.RGB32I)), z === s.RGBA_INTEGER && (K === s.UNSIGNED_BYTE && (ge = s.RGBA8UI), K === s.UNSIGNED_SHORT && (ge = s.RGBA16UI), K === s.UNSIGNED_INT && (ge = s.RGBA32UI), K === s.BYTE && (ge = s.RGBA8I), K === s.SHORT && (ge = s.RGBA16I), K === s.INT && (ge = s.RGBA32I)), z === s.RGB && K === s.UNSIGNED_INT_5_9_9_9_REV && (ge = s.RGB9_E5), z === s.RGBA) {
      const Me = me ? pu : kt.getTransfer(ue);
      K === s.FLOAT && (ge = s.RGBA32F), K === s.HALF_FLOAT && (ge = s.RGBA16F), K === s.UNSIGNED_BYTE && (ge = Me === qt ? s.SRGB8_ALPHA8 : s.RGBA8), K === s.UNSIGNED_SHORT_4_4_4_4 && (ge = s.RGBA4), K === s.UNSIGNED_SHORT_5_5_5_1 && (ge = s.RGB5_A1);
    }
    return (ge === s.R16F || ge === s.R32F || ge === s.RG16F || ge === s.RG32F || ge === s.RGBA16F || ge === s.RGBA32F) && e.get("EXT_color_buffer_float"), ge;
  }
  function x(U, z) {
    let K;
    return U ? z === null || z === zr || z === Fo ? K = s.DEPTH24_STENCIL8 : z === ui ? K = s.DEPTH32F_STENCIL8 : z === tl && (K = s.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : z === null || z === zr || z === Fo ? K = s.DEPTH_COMPONENT24 : z === ui ? K = s.DEPTH_COMPONENT32F : z === tl && (K = s.DEPTH_COMPONENT16), K;
  }
  function C(U, z) {
    return v(U) === !0 || U.isFramebufferTexture && U.minFilter !== Ln && U.minFilter !== Xt ? Math.log2(Math.max(z.width, z.height)) + 1 : U.mipmaps !== void 0 && U.mipmaps.length > 0 ? U.mipmaps.length : U.isCompressedTexture && Array.isArray(U.image) ? z.mipmaps.length : 1;
  }
  function E(U) {
    const z = U.target;
    z.removeEventListener("dispose", E), T(z), z.isVideoTexture && d.delete(z);
  }
  function P(U) {
    const z = U.target;
    z.removeEventListener("dispose", P), M(z);
  }
  function T(U) {
    const z = i.get(U);
    if (z.__webglInit === void 0) return;
    const K = U.source, ue = m.get(K);
    if (ue) {
      const me = ue[z.__cacheKey];
      me.usedTimes--, me.usedTimes === 0 && b(U), Object.keys(ue).length === 0 && m.delete(K);
    }
    i.remove(U);
  }
  function b(U) {
    const z = i.get(U);
    s.deleteTexture(z.__webglTexture);
    const K = U.source, ue = m.get(K);
    delete ue[z.__cacheKey], a.memory.textures--;
  }
  function M(U) {
    const z = i.get(U);
    if (U.depthTexture && (U.depthTexture.dispose(), i.remove(U.depthTexture)), U.isWebGLCubeRenderTarget)
      for (let ue = 0; ue < 6; ue++) {
        if (Array.isArray(z.__webglFramebuffer[ue]))
          for (let me = 0; me < z.__webglFramebuffer[ue].length; me++) s.deleteFramebuffer(z.__webglFramebuffer[ue][me]);
        else
          s.deleteFramebuffer(z.__webglFramebuffer[ue]);
        z.__webglDepthbuffer && s.deleteRenderbuffer(z.__webglDepthbuffer[ue]);
      }
    else {
      if (Array.isArray(z.__webglFramebuffer))
        for (let ue = 0; ue < z.__webglFramebuffer.length; ue++) s.deleteFramebuffer(z.__webglFramebuffer[ue]);
      else
        s.deleteFramebuffer(z.__webglFramebuffer);
      if (z.__webglDepthbuffer && s.deleteRenderbuffer(z.__webglDepthbuffer), z.__webglMultisampledFramebuffer && s.deleteFramebuffer(z.__webglMultisampledFramebuffer), z.__webglColorRenderbuffer)
        for (let ue = 0; ue < z.__webglColorRenderbuffer.length; ue++)
          z.__webglColorRenderbuffer[ue] && s.deleteRenderbuffer(z.__webglColorRenderbuffer[ue]);
      z.__webglDepthRenderbuffer && s.deleteRenderbuffer(z.__webglDepthRenderbuffer);
    }
    const K = U.textures;
    for (let ue = 0, me = K.length; ue < me; ue++) {
      const ge = i.get(K[ue]);
      ge.__webglTexture && (s.deleteTexture(ge.__webglTexture), a.memory.textures--), i.remove(K[ue]);
    }
    i.remove(U);
  }
  let L = 0;
  function N() {
    L = 0;
  }
  function D() {
    const U = L;
    return U >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + U + " texture units while this GPU supports only " + r.maxTextures), L += 1, U;
  }
  function O(U) {
    const z = [];
    return z.push(U.wrapS), z.push(U.wrapT), z.push(U.wrapR || 0), z.push(U.magFilter), z.push(U.minFilter), z.push(U.anisotropy), z.push(U.internalFormat), z.push(U.format), z.push(U.type), z.push(U.generateMipmaps), z.push(U.premultiplyAlpha), z.push(U.flipY), z.push(U.unpackAlignment), z.push(U.colorSpace), z.join();
  }
  function A(U, z) {
    const K = i.get(U);
    if (U.isVideoTexture && B(U), U.isRenderTargetTexture === !1 && U.version > 0 && K.__version !== U.version) {
      const ue = U.image;
      if (ue === null)
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (ue.complete === !1)
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        te(K, U, z);
        return;
      }
    }
    n.bindTexture(s.TEXTURE_2D, K.__webglTexture, s.TEXTURE0 + z);
  }
  function G(U, z) {
    const K = i.get(U);
    if (U.version > 0 && K.__version !== U.version) {
      te(K, U, z);
      return;
    }
    n.bindTexture(s.TEXTURE_2D_ARRAY, K.__webglTexture, s.TEXTURE0 + z);
  }
  function he(U, z) {
    const K = i.get(U);
    if (U.version > 0 && K.__version !== U.version) {
      te(K, U, z);
      return;
    }
    n.bindTexture(s.TEXTURE_3D, K.__webglTexture, s.TEXTURE0 + z);
  }
  function ee(U, z) {
    const K = i.get(U);
    if (U.version > 0 && K.__version !== U.version) {
      ne(K, U, z);
      return;
    }
    n.bindTexture(s.TEXTURE_CUBE_MAP, K.__webglTexture, s.TEXTURE0 + z);
  }
  const le = {
    [ch]: s.REPEAT,
    [Dr]: s.CLAMP_TO_EDGE,
    [uh]: s.MIRRORED_REPEAT
  }, oe = {
    [Ln]: s.NEAREST,
    [Ox]: s.NEAREST_MIPMAP_NEAREST,
    [Dl]: s.NEAREST_MIPMAP_LINEAR,
    [Xt]: s.LINEAR,
    [Wu]: s.LINEAR_MIPMAP_NEAREST,
    [Rr]: s.LINEAR_MIPMAP_LINEAR
  }, Y = {
    [Bx]: s.NEVER,
    [Xx]: s.ALWAYS,
    [Vx]: s.LESS,
    [O0]: s.LEQUAL,
    [Gx]: s.EQUAL,
    [$x]: s.GEQUAL,
    [Hx]: s.GREATER,
    [Wx]: s.NOTEQUAL
  };
  function j(U, z) {
    if (z.type === ui && e.has("OES_texture_float_linear") === !1 && (z.magFilter === Xt || z.magFilter === Wu || z.magFilter === Dl || z.magFilter === Rr || z.minFilter === Xt || z.minFilter === Wu || z.minFilter === Dl || z.minFilter === Rr) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), s.texParameteri(U, s.TEXTURE_WRAP_S, le[z.wrapS]), s.texParameteri(U, s.TEXTURE_WRAP_T, le[z.wrapT]), (U === s.TEXTURE_3D || U === s.TEXTURE_2D_ARRAY) && s.texParameteri(U, s.TEXTURE_WRAP_R, le[z.wrapR]), s.texParameteri(U, s.TEXTURE_MAG_FILTER, oe[z.magFilter]), s.texParameteri(U, s.TEXTURE_MIN_FILTER, oe[z.minFilter]), z.compareFunction && (s.texParameteri(U, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(U, s.TEXTURE_COMPARE_FUNC, Y[z.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (z.magFilter === Ln || z.minFilter !== Dl && z.minFilter !== Rr || z.type === ui && e.has("OES_texture_float_linear") === !1) return;
      if (z.anisotropy > 1 || i.get(z).__currentAnisotropy) {
        const K = e.get("EXT_texture_filter_anisotropic");
        s.texParameterf(U, K.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(z.anisotropy, r.getMaxAnisotropy())), i.get(z).__currentAnisotropy = z.anisotropy;
      }
    }
  }
  function q(U, z) {
    let K = !1;
    U.__webglInit === void 0 && (U.__webglInit = !0, z.addEventListener("dispose", E));
    const ue = z.source;
    let me = m.get(ue);
    me === void 0 && (me = {}, m.set(ue, me));
    const ge = O(z);
    if (ge !== U.__cacheKey) {
      me[ge] === void 0 && (me[ge] = {
        texture: s.createTexture(),
        usedTimes: 0
      }, a.memory.textures++, K = !0), me[ge].usedTimes++;
      const Me = me[U.__cacheKey];
      Me !== void 0 && (me[U.__cacheKey].usedTimes--, Me.usedTimes === 0 && b(z)), U.__cacheKey = ge, U.__webglTexture = me[ge].texture;
    }
    return K;
  }
  function te(U, z, K) {
    let ue = s.TEXTURE_2D;
    (z.isDataArrayTexture || z.isCompressedArrayTexture) && (ue = s.TEXTURE_2D_ARRAY), z.isData3DTexture && (ue = s.TEXTURE_3D);
    const me = q(U, z), ge = z.source;
    n.bindTexture(ue, U.__webglTexture, s.TEXTURE0 + K);
    const Me = i.get(ge);
    if (ge.version !== Me.__version || me === !0) {
      n.activeTexture(s.TEXTURE0 + K);
      const Te = kt.getPrimaries(kt.workingColorSpace), Ae = z.colorSpace === Ks ? null : kt.getPrimaries(z.colorSpace), Xe = z.colorSpace === Ks || Te === Ae ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, z.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, z.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Xe);
      let Fe = _(z.image, !1, r.maxTextureSize);
      Fe = $(z, Fe);
      const He = o.convert(z.format, z.colorSpace), Ye = o.convert(z.type);
      let We = w(z.internalFormat, He, Ye, z.colorSpace, z.isVideoTexture);
      j(ue, z);
      let ke;
      const nt = z.mipmaps, Je = z.isVideoTexture !== !0, _t = Me.__version === void 0 || me === !0, we = ge.dataReady, ze = C(z, Fe);
      if (z.isDepthTexture)
        We = x(z.format === Uo, z.type), _t && (Je ? n.texStorage2D(s.TEXTURE_2D, 1, We, Fe.width, Fe.height) : n.texImage2D(s.TEXTURE_2D, 0, We, Fe.width, Fe.height, 0, He, Ye, null));
      else if (z.isDataTexture)
        if (nt.length > 0) {
          Je && _t && n.texStorage2D(s.TEXTURE_2D, ze, We, nt[0].width, nt[0].height);
          for (let De = 0, Be = nt.length; De < Be; De++)
            ke = nt[De], Je ? we && n.texSubImage2D(s.TEXTURE_2D, De, 0, 0, ke.width, ke.height, He, Ye, ke.data) : n.texImage2D(s.TEXTURE_2D, De, We, ke.width, ke.height, 0, He, Ye, ke.data);
          z.generateMipmaps = !1;
        } else
          Je ? (_t && n.texStorage2D(s.TEXTURE_2D, ze, We, Fe.width, Fe.height), we && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Fe.width, Fe.height, He, Ye, Fe.data)) : n.texImage2D(s.TEXTURE_2D, 0, We, Fe.width, Fe.height, 0, He, Ye, Fe.data);
      else if (z.isCompressedTexture)
        if (z.isCompressedArrayTexture) {
          Je && _t && n.texStorage3D(s.TEXTURE_2D_ARRAY, ze, We, nt[0].width, nt[0].height, Fe.depth);
          for (let De = 0, Be = nt.length; De < Be; De++)
            if (ke = nt[De], z.format !== $n)
              if (He !== null)
                if (Je) {
                  if (we)
                    if (z.layerUpdates.size > 0) {
                      const je = Um(ke.width, ke.height, z.format, z.type);
                      for (const Ve of z.layerUpdates) {
                        const lt = ke.data.subarray(
                          Ve * je / ke.data.BYTES_PER_ELEMENT,
                          (Ve + 1) * je / ke.data.BYTES_PER_ELEMENT
                        );
                        n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, De, 0, 0, Ve, ke.width, ke.height, 1, He, lt);
                      }
                      z.clearLayerUpdates();
                    } else
                      n.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, De, 0, 0, 0, ke.width, ke.height, Fe.depth, He, ke.data);
                } else
                  n.compressedTexImage3D(s.TEXTURE_2D_ARRAY, De, We, ke.width, ke.height, Fe.depth, 0, ke.data, 0, 0);
              else
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              Je ? we && n.texSubImage3D(s.TEXTURE_2D_ARRAY, De, 0, 0, 0, ke.width, ke.height, Fe.depth, He, Ye, ke.data) : n.texImage3D(s.TEXTURE_2D_ARRAY, De, We, ke.width, ke.height, Fe.depth, 0, He, Ye, ke.data);
        } else {
          Je && _t && n.texStorage2D(s.TEXTURE_2D, ze, We, nt[0].width, nt[0].height);
          for (let De = 0, Be = nt.length; De < Be; De++)
            ke = nt[De], z.format !== $n ? He !== null ? Je ? we && n.compressedTexSubImage2D(s.TEXTURE_2D, De, 0, 0, ke.width, ke.height, He, ke.data) : n.compressedTexImage2D(s.TEXTURE_2D, De, We, ke.width, ke.height, 0, ke.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Je ? we && n.texSubImage2D(s.TEXTURE_2D, De, 0, 0, ke.width, ke.height, He, Ye, ke.data) : n.texImage2D(s.TEXTURE_2D, De, We, ke.width, ke.height, 0, He, Ye, ke.data);
        }
      else if (z.isDataArrayTexture)
        if (Je) {
          if (_t && n.texStorage3D(s.TEXTURE_2D_ARRAY, ze, We, Fe.width, Fe.height, Fe.depth), we)
            if (z.layerUpdates.size > 0) {
              const De = Um(Fe.width, Fe.height, z.format, z.type);
              for (const Be of z.layerUpdates) {
                const je = Fe.data.subarray(
                  Be * De / Fe.data.BYTES_PER_ELEMENT,
                  (Be + 1) * De / Fe.data.BYTES_PER_ELEMENT
                );
                n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, Be, Fe.width, Fe.height, 1, He, Ye, je);
              }
              z.clearLayerUpdates();
            } else
              n.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Fe.width, Fe.height, Fe.depth, He, Ye, Fe.data);
        } else
          n.texImage3D(s.TEXTURE_2D_ARRAY, 0, We, Fe.width, Fe.height, Fe.depth, 0, He, Ye, Fe.data);
      else if (z.isData3DTexture)
        Je ? (_t && n.texStorage3D(s.TEXTURE_3D, ze, We, Fe.width, Fe.height, Fe.depth), we && n.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, Fe.width, Fe.height, Fe.depth, He, Ye, Fe.data)) : n.texImage3D(s.TEXTURE_3D, 0, We, Fe.width, Fe.height, Fe.depth, 0, He, Ye, Fe.data);
      else if (z.isFramebufferTexture) {
        if (_t)
          if (Je)
            n.texStorage2D(s.TEXTURE_2D, ze, We, Fe.width, Fe.height);
          else {
            let De = Fe.width, Be = Fe.height;
            for (let je = 0; je < ze; je++)
              n.texImage2D(s.TEXTURE_2D, je, We, De, Be, 0, He, Ye, null), De >>= 1, Be >>= 1;
          }
      } else if (nt.length > 0) {
        if (Je && _t) {
          const De = se(nt[0]);
          n.texStorage2D(s.TEXTURE_2D, ze, We, De.width, De.height);
        }
        for (let De = 0, Be = nt.length; De < Be; De++)
          ke = nt[De], Je ? we && n.texSubImage2D(s.TEXTURE_2D, De, 0, 0, He, Ye, ke) : n.texImage2D(s.TEXTURE_2D, De, We, He, Ye, ke);
        z.generateMipmaps = !1;
      } else if (Je) {
        if (_t) {
          const De = se(Fe);
          n.texStorage2D(s.TEXTURE_2D, ze, We, De.width, De.height);
        }
        we && n.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, He, Ye, Fe);
      } else
        n.texImage2D(s.TEXTURE_2D, 0, We, He, Ye, Fe);
      v(z) && g(ue), Me.__version = ge.version, z.onUpdate && z.onUpdate(z);
    }
    U.__version = z.version;
  }
  function ne(U, z, K) {
    if (z.image.length !== 6) return;
    const ue = q(U, z), me = z.source;
    n.bindTexture(s.TEXTURE_CUBE_MAP, U.__webglTexture, s.TEXTURE0 + K);
    const ge = i.get(me);
    if (me.version !== ge.__version || ue === !0) {
      n.activeTexture(s.TEXTURE0 + K);
      const Me = kt.getPrimaries(kt.workingColorSpace), Te = z.colorSpace === Ks ? null : kt.getPrimaries(z.colorSpace), Ae = z.colorSpace === Ks || Me === Te ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
      s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, z.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, z.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
      const Xe = z.isCompressedTexture || z.image[0].isCompressedTexture, Fe = z.image[0] && z.image[0].isDataTexture, He = [];
      for (let Be = 0; Be < 6; Be++)
        !Xe && !Fe ? He[Be] = _(z.image[Be], !0, r.maxCubemapSize) : He[Be] = Fe ? z.image[Be].image : z.image[Be], He[Be] = $(z, He[Be]);
      const Ye = He[0], We = o.convert(z.format, z.colorSpace), ke = o.convert(z.type), nt = w(z.internalFormat, We, ke, z.colorSpace), Je = z.isVideoTexture !== !0, _t = ge.__version === void 0 || ue === !0, we = me.dataReady;
      let ze = C(z, Ye);
      j(s.TEXTURE_CUBE_MAP, z);
      let De;
      if (Xe) {
        Je && _t && n.texStorage2D(s.TEXTURE_CUBE_MAP, ze, nt, Ye.width, Ye.height);
        for (let Be = 0; Be < 6; Be++) {
          De = He[Be].mipmaps;
          for (let je = 0; je < De.length; je++) {
            const Ve = De[je];
            z.format !== $n ? We !== null ? Je ? we && n.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, 0, 0, Ve.width, Ve.height, We, Ve.data) : n.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, nt, Ve.width, Ve.height, 0, Ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Je ? we && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, 0, 0, Ve.width, Ve.height, We, ke, Ve.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je, nt, Ve.width, Ve.height, 0, We, ke, Ve.data);
          }
        }
      } else {
        if (De = z.mipmaps, Je && _t) {
          De.length > 0 && ze++;
          const Be = se(He[0]);
          n.texStorage2D(s.TEXTURE_CUBE_MAP, ze, nt, Be.width, Be.height);
        }
        for (let Be = 0; Be < 6; Be++)
          if (Fe) {
            Je ? we && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, He[Be].width, He[Be].height, We, ke, He[Be].data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, nt, He[Be].width, He[Be].height, 0, We, ke, He[Be].data);
            for (let je = 0; je < De.length; je++) {
              const lt = De[je].image[Be].image;
              Je ? we && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, 0, 0, lt.width, lt.height, We, ke, lt.data) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, nt, lt.width, lt.height, 0, We, ke, lt.data);
            }
          } else {
            Je ? we && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, 0, 0, We, ke, He[Be]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, 0, nt, We, ke, He[Be]);
            for (let je = 0; je < De.length; je++) {
              const Ve = De[je];
              Je ? we && n.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, 0, 0, We, ke, Ve.image[Be]) : n.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Be, je + 1, nt, We, ke, Ve.image[Be]);
            }
          }
      }
      v(z) && g(s.TEXTURE_CUBE_MAP), ge.__version = me.version, z.onUpdate && z.onUpdate(z);
    }
    U.__version = z.version;
  }
  function de(U, z, K, ue, me, ge) {
    const Me = o.convert(K.format, K.colorSpace), Te = o.convert(K.type), Ae = w(K.internalFormat, Me, Te, K.colorSpace), Xe = i.get(z), Fe = i.get(K);
    if (Fe.__renderTarget = z, !Xe.__hasExternalTextures) {
      const He = Math.max(1, z.width >> ge), Ye = Math.max(1, z.height >> ge);
      me === s.TEXTURE_3D || me === s.TEXTURE_2D_ARRAY ? n.texImage3D(me, ge, Ae, He, Ye, z.depth, 0, Me, Te, null) : n.texImage2D(me, ge, Ae, He, Ye, 0, Me, Te, null);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, U), J(z) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, ue, me, Fe.__webglTexture, 0, ie(z)) : (me === s.TEXTURE_2D || me >= s.TEXTURE_CUBE_MAP_POSITIVE_X && me <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, ue, me, Fe.__webglTexture, ge), n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function H(U, z, K) {
    if (s.bindRenderbuffer(s.RENDERBUFFER, U), z.depthBuffer) {
      const ue = z.depthTexture, me = ue && ue.isDepthTexture ? ue.type : null, ge = x(z.stencilBuffer, me), Me = z.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Te = ie(z);
      J(z) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Te, ge, z.width, z.height) : K ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Te, ge, z.width, z.height) : s.renderbufferStorage(s.RENDERBUFFER, ge, z.width, z.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, Me, s.RENDERBUFFER, U);
    } else {
      const ue = z.textures;
      for (let me = 0; me < ue.length; me++) {
        const ge = ue[me], Me = o.convert(ge.format, ge.colorSpace), Te = o.convert(ge.type), Ae = w(ge.internalFormat, Me, Te, ge.colorSpace), Xe = ie(z);
        K && J(z) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Xe, Ae, z.width, z.height) : J(z) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Xe, Ae, z.width, z.height) : s.renderbufferStorage(s.RENDERBUFFER, Ae, z.width, z.height);
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  function X(U, z) {
    if (z && z.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (n.bindFramebuffer(s.FRAMEBUFFER, U), !(z.depthTexture && z.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const ue = i.get(z.depthTexture);
    ue.__renderTarget = z, (!ue.__webglTexture || z.depthTexture.image.width !== z.width || z.depthTexture.image.height !== z.height) && (z.depthTexture.image.width = z.width, z.depthTexture.image.height = z.height, z.depthTexture.needsUpdate = !0), A(z.depthTexture, 0);
    const me = ue.__webglTexture, ge = ie(z);
    if (z.depthTexture.format === Lr)
      J(z) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, me, 0, ge) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, me, 0);
    else if (z.depthTexture.format === Uo)
      J(z) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, me, 0, ge) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, me, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function V(U) {
    const z = i.get(U), K = U.isWebGLCubeRenderTarget === !0;
    if (z.__boundDepthTexture !== U.depthTexture) {
      const ue = U.depthTexture;
      if (z.__depthDisposeCallback && z.__depthDisposeCallback(), ue) {
        const me = () => {
          delete z.__boundDepthTexture, delete z.__depthDisposeCallback, ue.removeEventListener("dispose", me);
        };
        ue.addEventListener("dispose", me), z.__depthDisposeCallback = me;
      }
      z.__boundDepthTexture = ue;
    }
    if (U.depthTexture && !z.__autoAllocateDepthBuffer) {
      if (K) throw new Error("target.depthTexture not supported in Cube render targets");
      X(z.__webglFramebuffer, U);
    } else if (K) {
      z.__webglDepthbuffer = [];
      for (let ue = 0; ue < 6; ue++)
        if (n.bindFramebuffer(s.FRAMEBUFFER, z.__webglFramebuffer[ue]), z.__webglDepthbuffer[ue] === void 0)
          z.__webglDepthbuffer[ue] = s.createRenderbuffer(), H(z.__webglDepthbuffer[ue], U, !1);
        else {
          const me = U.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, ge = z.__webglDepthbuffer[ue];
          s.bindRenderbuffer(s.RENDERBUFFER, ge), s.framebufferRenderbuffer(s.FRAMEBUFFER, me, s.RENDERBUFFER, ge);
        }
    } else if (n.bindFramebuffer(s.FRAMEBUFFER, z.__webglFramebuffer), z.__webglDepthbuffer === void 0)
      z.__webglDepthbuffer = s.createRenderbuffer(), H(z.__webglDepthbuffer, U, !1);
    else {
      const ue = U.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, me = z.__webglDepthbuffer;
      s.bindRenderbuffer(s.RENDERBUFFER, me), s.framebufferRenderbuffer(s.FRAMEBUFFER, ue, s.RENDERBUFFER, me);
    }
    n.bindFramebuffer(s.FRAMEBUFFER, null);
  }
  function I(U, z, K) {
    const ue = i.get(U);
    z !== void 0 && de(ue.__webglFramebuffer, U, U.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), K !== void 0 && V(U);
  }
  function F(U) {
    const z = U.texture, K = i.get(U), ue = i.get(z);
    U.addEventListener("dispose", P);
    const me = U.textures, ge = U.isWebGLCubeRenderTarget === !0, Me = me.length > 1;
    if (Me || (ue.__webglTexture === void 0 && (ue.__webglTexture = s.createTexture()), ue.__version = z.version, a.memory.textures++), ge) {
      K.__webglFramebuffer = [];
      for (let Te = 0; Te < 6; Te++)
        if (z.mipmaps && z.mipmaps.length > 0) {
          K.__webglFramebuffer[Te] = [];
          for (let Ae = 0; Ae < z.mipmaps.length; Ae++)
            K.__webglFramebuffer[Te][Ae] = s.createFramebuffer();
        } else
          K.__webglFramebuffer[Te] = s.createFramebuffer();
    } else {
      if (z.mipmaps && z.mipmaps.length > 0) {
        K.__webglFramebuffer = [];
        for (let Te = 0; Te < z.mipmaps.length; Te++)
          K.__webglFramebuffer[Te] = s.createFramebuffer();
      } else
        K.__webglFramebuffer = s.createFramebuffer();
      if (Me)
        for (let Te = 0, Ae = me.length; Te < Ae; Te++) {
          const Xe = i.get(me[Te]);
          Xe.__webglTexture === void 0 && (Xe.__webglTexture = s.createTexture(), a.memory.textures++);
        }
      if (U.samples > 0 && J(U) === !1) {
        K.__webglMultisampledFramebuffer = s.createFramebuffer(), K.__webglColorRenderbuffer = [], n.bindFramebuffer(s.FRAMEBUFFER, K.__webglMultisampledFramebuffer);
        for (let Te = 0; Te < me.length; Te++) {
          const Ae = me[Te];
          K.__webglColorRenderbuffer[Te] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, K.__webglColorRenderbuffer[Te]);
          const Xe = o.convert(Ae.format, Ae.colorSpace), Fe = o.convert(Ae.type), He = w(Ae.internalFormat, Xe, Fe, Ae.colorSpace, U.isXRRenderTarget === !0), Ye = ie(U);
          s.renderbufferStorageMultisample(s.RENDERBUFFER, Ye, He, U.width, U.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Te, s.RENDERBUFFER, K.__webglColorRenderbuffer[Te]);
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null), U.depthBuffer && (K.__webglDepthRenderbuffer = s.createRenderbuffer(), H(K.__webglDepthRenderbuffer, U, !0)), n.bindFramebuffer(s.FRAMEBUFFER, null);
      }
    }
    if (ge) {
      n.bindTexture(s.TEXTURE_CUBE_MAP, ue.__webglTexture), j(s.TEXTURE_CUBE_MAP, z);
      for (let Te = 0; Te < 6; Te++)
        if (z.mipmaps && z.mipmaps.length > 0)
          for (let Ae = 0; Ae < z.mipmaps.length; Ae++)
            de(K.__webglFramebuffer[Te][Ae], U, z, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Te, Ae);
        else
          de(K.__webglFramebuffer[Te], U, z, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + Te, 0);
      v(z) && g(s.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (Me) {
      for (let Te = 0, Ae = me.length; Te < Ae; Te++) {
        const Xe = me[Te], Fe = i.get(Xe);
        n.bindTexture(s.TEXTURE_2D, Fe.__webglTexture), j(s.TEXTURE_2D, Xe), de(K.__webglFramebuffer, U, Xe, s.COLOR_ATTACHMENT0 + Te, s.TEXTURE_2D, 0), v(Xe) && g(s.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let Te = s.TEXTURE_2D;
      if ((U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) && (Te = U.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY), n.bindTexture(Te, ue.__webglTexture), j(Te, z), z.mipmaps && z.mipmaps.length > 0)
        for (let Ae = 0; Ae < z.mipmaps.length; Ae++)
          de(K.__webglFramebuffer[Ae], U, z, s.COLOR_ATTACHMENT0, Te, Ae);
      else
        de(K.__webglFramebuffer, U, z, s.COLOR_ATTACHMENT0, Te, 0);
      v(z) && g(Te), n.unbindTexture();
    }
    U.depthBuffer && V(U);
  }
  function k(U) {
    const z = U.textures;
    for (let K = 0, ue = z.length; K < ue; K++) {
      const me = z[K];
      if (v(me)) {
        const ge = S(U), Me = i.get(me).__webglTexture;
        n.bindTexture(ge, Me), g(ge), n.unbindTexture();
      }
    }
  }
  const Q = [], Z = [];
  function R(U) {
    if (U.samples > 0) {
      if (J(U) === !1) {
        const z = U.textures, K = U.width, ue = U.height;
        let me = s.COLOR_BUFFER_BIT;
        const ge = U.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT, Me = i.get(U), Te = z.length > 1;
        if (Te)
          for (let Ae = 0; Ae < z.length; Ae++)
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, null), n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, null, 0);
        n.bindFramebuffer(s.READ_FRAMEBUFFER, Me.__webglMultisampledFramebuffer), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglFramebuffer);
        for (let Ae = 0; Ae < z.length; Ae++) {
          if (U.resolveDepthBuffer && (U.depthBuffer && (me |= s.DEPTH_BUFFER_BIT), U.stencilBuffer && U.resolveStencilBuffer && (me |= s.STENCIL_BUFFER_BIT)), Te) {
            s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Me.__webglColorRenderbuffer[Ae]);
            const Xe = i.get(z[Ae]).__webglTexture;
            s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Xe, 0);
          }
          s.blitFramebuffer(0, 0, K, ue, 0, 0, K, ue, me, s.NEAREST), c === !0 && (Q.length = 0, Z.length = 0, Q.push(s.COLOR_ATTACHMENT0 + Ae), U.depthBuffer && U.resolveDepthBuffer === !1 && (Q.push(ge), Z.push(ge), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, Z)), s.invalidateFramebuffer(s.READ_FRAMEBUFFER, Q));
        }
        if (n.bindFramebuffer(s.READ_FRAMEBUFFER, null), n.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), Te)
          for (let Ae = 0; Ae < z.length; Ae++) {
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.RENDERBUFFER, Me.__webglColorRenderbuffer[Ae]);
            const Xe = i.get(z[Ae]).__webglTexture;
            n.bindFramebuffer(s.FRAMEBUFFER, Me.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Ae, s.TEXTURE_2D, Xe, 0);
          }
        n.bindFramebuffer(s.DRAW_FRAMEBUFFER, Me.__webglMultisampledFramebuffer);
      } else if (U.depthBuffer && U.resolveDepthBuffer === !1 && c) {
        const z = U.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
        s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [z]);
      }
    }
  }
  function ie(U) {
    return Math.min(r.maxSamples, U.samples);
  }
  function J(U) {
    const z = i.get(U);
    return U.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && z.__useRenderToTexture !== !1;
  }
  function B(U) {
    const z = a.render.frame;
    d.get(U) !== z && (d.set(U, z), U.update());
  }
  function $(U, z) {
    const K = U.colorSpace, ue = U.format, me = U.type;
    return U.isCompressedTexture === !0 || U.isVideoTexture === !0 || K !== Ho && K !== Ks && (kt.getTransfer(K) === qt ? (ue !== $n || me !== is) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", K)), z;
  }
  function se(U) {
    return typeof HTMLImageElement < "u" && U instanceof HTMLImageElement ? (u.width = U.naturalWidth || U.width, u.height = U.naturalHeight || U.height) : typeof VideoFrame < "u" && U instanceof VideoFrame ? (u.width = U.displayWidth, u.height = U.displayHeight) : (u.width = U.width, u.height = U.height), u;
  }
  this.allocateTextureUnit = D, this.resetTextureUnits = N, this.setTexture2D = A, this.setTexture2DArray = G, this.setTexture3D = he, this.setTextureCube = ee, this.rebindTextures = I, this.setupRenderTarget = F, this.updateRenderTargetMipmap = k, this.updateMultisampleRenderTarget = R, this.setupDepthRenderbuffer = V, this.setupFrameBufferTexture = de, this.useMultisampledRTT = J;
}
function lE(s, e) {
  function n(i, r = Ks) {
    let o;
    const a = kt.getTransfer(r);
    if (i === is) return s.UNSIGNED_BYTE;
    if (i === pf) return s.UNSIGNED_SHORT_4_4_4_4;
    if (i === mf) return s.UNSIGNED_SHORT_5_5_5_1;
    if (i === D0) return s.UNSIGNED_INT_5_9_9_9_REV;
    if (i === A0) return s.BYTE;
    if (i === P0) return s.SHORT;
    if (i === tl) return s.UNSIGNED_SHORT;
    if (i === ff) return s.INT;
    if (i === zr) return s.UNSIGNED_INT;
    if (i === ui) return s.FLOAT;
    if (i === sr) return s.HALF_FLOAT;
    if (i === R0) return s.ALPHA;
    if (i === I0) return s.RGB;
    if (i === $n) return s.RGBA;
    if (i === k0) return s.LUMINANCE;
    if (i === L0) return s.LUMINANCE_ALPHA;
    if (i === Lr) return s.DEPTH_COMPONENT;
    if (i === Uo) return s.DEPTH_STENCIL;
    if (i === Gc) return s.RED;
    if (i === vf) return s.RED_INTEGER;
    if (i === F0) return s.RG;
    if (i === gf) return s.RG_INTEGER;
    if (i === yf) return s.RGBA_INTEGER;
    if (i === wc || i === Sc || i === Mc || i === Cc)
      if (a === qt)
        if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (i === wc) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === Sc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === Mc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === Cc) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (i === wc) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (i === Sc) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (i === Mc) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (i === Cc) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (i === dh || i === hh || i === fh || i === ph)
      if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (i === dh) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (i === hh) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === fh) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (i === ph) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (i === mh || i === vh || i === gh)
      if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (i === mh || i === vh) return a === qt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (i === gh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (i === yh || i === _h || i === xh || i === bh || i === wh || i === Sh || i === Mh || i === Ch || i === Eh || i === Th || i === Ah || i === Ph || i === Dh || i === Rh)
      if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (i === yh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (i === _h) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (i === xh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (i === bh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === wh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (i === Sh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (i === Mh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (i === Ch) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (i === Eh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (i === Th) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (i === Ah) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (i === Ph) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (i === Dh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (i === Rh) return a === qt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (i === Ec || i === Ih || i === kh)
      if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
        if (i === Ec) return a === qt ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (i === Ih) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (i === kh) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (i === U0 || i === Lh || i === Fh || i === Uh)
      if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
        if (i === Ec) return o.COMPRESSED_RED_RGTC1_EXT;
        if (i === Lh) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (i === Fh) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (i === Uh) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return i === Fo ? s.UNSIGNED_INT_24_8 : s[i] !== void 0 ? s[i] : null;
  }
  return { convert: n };
}
class cE extends ci {
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.cameras = e;
  }
}
class Ei extends ln {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const uE = { type: "move" };
class gd {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Ei(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Ei(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ce(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ce()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Ei(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ce(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ce()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n)
        for (const i of e.hand.values())
          this._getHandJoint(n, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  update(e, n, i) {
    let r = null, o = null, a = null;
    const l = this._targetRay, c = this._grip, u = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        a = !0;
        for (const _ of e.hand.values()) {
          const v = n.getJointPose(_, i), g = this._getHandJoint(u, _);
          v !== null && (g.matrix.fromArray(v.transform.matrix), g.matrix.decompose(g.position, g.rotation, g.scale), g.matrixWorldNeedsUpdate = !0, g.jointRadius = v.radius), g.visible = v !== null;
        }
        const d = u.joints["index-finger-tip"], h = u.joints["thumb-tip"], m = d.position.distanceTo(h.position), p = 0.02, y = 5e-3;
        u.inputState.pinching && m > p + y ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !u.inputState.pinching && m <= p - y && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        c !== null && e.gripSpace && (o = n.getPose(e.gripSpace, i), o !== null && (c.matrix.fromArray(o.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(o.linearVelocity)) : c.hasLinearVelocity = !1, o.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(o.angularVelocity)) : c.hasAngularVelocity = !1));
      l !== null && (r = n.getPose(e.targetRaySpace, i), r === null && o !== null && (r = o), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent(uE)));
    }
    return l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), u !== null && (u.visible = a !== null), this;
  }
  // private method
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const i = new Ei();
      i.matrixAutoUpdate = !1, i.visible = !1, e.joints[n.jointName] = i, e.add(i);
    }
    return e.joints[n.jointName];
  }
}
const dE = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, hE = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class fE {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, n, i) {
    if (this.texture === null) {
      const r = new yn(), o = e.properties.get(r);
      o.__webglTexture = n.texture, (n.depthNear != i.depthNear || n.depthFar != i.depthFar) && (this.depthNear = n.depthNear, this.depthFar = n.depthFar), this.texture = r;
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const n = e.cameras[0].viewport, i = new Fn({
        vertexShader: dE,
        fragmentShader: hE,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: n.z },
          depthHeight: { value: n.w }
        }
      });
      this.mesh = new qe(new cn(20, 20), i);
    }
    return this.mesh;
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
  getDepthTexture() {
    return this.texture;
  }
}
class pE extends Br {
  constructor(e, n) {
    super();
    const i = this;
    let r = null, o = 1, a = null, l = "local-floor", c = 1, u = null, d = null, h = null, m = null, p = null, y = null;
    const _ = new fE(), v = n.getContextAttributes();
    let g = null, S = null;
    const w = [], x = [], C = new st();
    let E = null;
    const P = new ci();
    P.viewport = new jt();
    const T = new ci();
    T.viewport = new jt();
    const b = [P, T], M = new cE();
    let L = null, N = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(te) {
      let ne = w[te];
      return ne === void 0 && (ne = new gd(), w[te] = ne), ne.getTargetRaySpace();
    }, this.getControllerGrip = function(te) {
      let ne = w[te];
      return ne === void 0 && (ne = new gd(), w[te] = ne), ne.getGripSpace();
    }, this.getHand = function(te) {
      let ne = w[te];
      return ne === void 0 && (ne = new gd(), w[te] = ne), ne.getHandSpace();
    };
    function D(te) {
      const ne = x.indexOf(te.inputSource);
      if (ne === -1)
        return;
      const de = w[ne];
      de !== void 0 && (de.update(te.inputSource, te.frame, u || a), de.dispatchEvent({ type: te.type, data: te.inputSource }));
    }
    function O() {
      r.removeEventListener("select", D), r.removeEventListener("selectstart", D), r.removeEventListener("selectend", D), r.removeEventListener("squeeze", D), r.removeEventListener("squeezestart", D), r.removeEventListener("squeezeend", D), r.removeEventListener("end", O), r.removeEventListener("inputsourceschange", A);
      for (let te = 0; te < w.length; te++) {
        const ne = x[te];
        ne !== null && (x[te] = null, w[te].disconnect(ne));
      }
      L = null, N = null, _.reset(), e.setRenderTarget(g), p = null, m = null, h = null, r = null, S = null, q.stop(), i.isPresenting = !1, e.setPixelRatio(E), e.setSize(C.width, C.height, !1), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(te) {
      o = te, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(te) {
      l = te, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || a;
    }, this.setReferenceSpace = function(te) {
      u = te;
    }, this.getBaseLayer = function() {
      return m !== null ? m : p;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return y;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(te) {
      if (r = te, r !== null) {
        if (g = e.getRenderTarget(), r.addEventListener("select", D), r.addEventListener("selectstart", D), r.addEventListener("selectend", D), r.addEventListener("squeeze", D), r.addEventListener("squeezestart", D), r.addEventListener("squeezeend", D), r.addEventListener("end", O), r.addEventListener("inputsourceschange", A), v.xrCompatible !== !0 && await n.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(C), r.renderState.layers === void 0) {
          const ne = {
            antialias: v.antialias,
            alpha: !0,
            depth: v.depth,
            stencil: v.stencil,
            framebufferScaleFactor: o
          };
          p = new XRWebGLLayer(r, n, ne), r.updateRenderState({ baseLayer: p }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, !1), S = new Hi(
            p.framebufferWidth,
            p.framebufferHeight,
            {
              format: $n,
              type: is,
              colorSpace: e.outputColorSpace,
              stencilBuffer: v.stencil
            }
          );
        } else {
          let ne = null, de = null, H = null;
          v.depth && (H = v.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24, ne = v.stencil ? Uo : Lr, de = v.stencil ? Fo : zr);
          const X = {
            colorFormat: n.RGBA8,
            depthFormat: H,
            scaleFactor: o
          };
          h = new XRWebGLBinding(r, n), m = h.createProjectionLayer(X), r.updateRenderState({ layers: [m] }), e.setPixelRatio(1), e.setSize(m.textureWidth, m.textureHeight, !1), S = new Hi(
            m.textureWidth,
            m.textureHeight,
            {
              format: $n,
              type: is,
              depthTexture: new Ef(m.textureWidth, m.textureHeight, de, void 0, void 0, void 0, void 0, void 0, void 0, ne),
              stencilBuffer: v.stencil,
              colorSpace: e.outputColorSpace,
              samples: v.antialias ? 4 : 0,
              resolveDepthBuffer: m.ignoreDepthValues === !1
            }
          );
        }
        S.isXRRenderTarget = !0, this.setFoveation(c), u = null, a = await r.requestReferenceSpace(l), q.setContext(r), q.start(), i.isPresenting = !0, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return _.getDepthTexture();
    };
    function A(te) {
      for (let ne = 0; ne < te.removed.length; ne++) {
        const de = te.removed[ne], H = x.indexOf(de);
        H >= 0 && (x[H] = null, w[H].disconnect(de));
      }
      for (let ne = 0; ne < te.added.length; ne++) {
        const de = te.added[ne];
        let H = x.indexOf(de);
        if (H === -1) {
          for (let V = 0; V < w.length; V++)
            if (V >= x.length) {
              x.push(de), H = V;
              break;
            } else if (x[V] === null) {
              x[V] = de, H = V;
              break;
            }
          if (H === -1) break;
        }
        const X = w[H];
        X && X.connect(de);
      }
    }
    const G = new ce(), he = new ce();
    function ee(te, ne, de) {
      G.setFromMatrixPosition(ne.matrixWorld), he.setFromMatrixPosition(de.matrixWorld);
      const H = G.distanceTo(he), X = ne.projectionMatrix.elements, V = de.projectionMatrix.elements, I = X[14] / (X[10] - 1), F = X[14] / (X[10] + 1), k = (X[9] + 1) / X[5], Q = (X[9] - 1) / X[5], Z = (X[8] - 1) / X[0], R = (V[8] + 1) / V[0], ie = I * Z, J = I * R, B = H / (-Z + R), $ = B * -Z;
      if (ne.matrixWorld.decompose(te.position, te.quaternion, te.scale), te.translateX($), te.translateZ(B), te.matrixWorld.compose(te.position, te.quaternion, te.scale), te.matrixWorldInverse.copy(te.matrixWorld).invert(), X[10] === -1)
        te.projectionMatrix.copy(ne.projectionMatrix), te.projectionMatrixInverse.copy(ne.projectionMatrixInverse);
      else {
        const se = I + B, U = F + B, z = ie - $, K = J + (H - $), ue = k * F / U * se, me = Q * F / U * se;
        te.projectionMatrix.makePerspective(z, K, ue, me, se, U), te.projectionMatrixInverse.copy(te.projectionMatrix).invert();
      }
    }
    function le(te, ne) {
      ne === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(ne.matrixWorld, te.matrix), te.matrixWorldInverse.copy(te.matrixWorld).invert();
    }
    this.updateCamera = function(te) {
      if (r === null) return;
      let ne = te.near, de = te.far;
      _.texture !== null && (_.depthNear > 0 && (ne = _.depthNear), _.depthFar > 0 && (de = _.depthFar)), M.near = T.near = P.near = ne, M.far = T.far = P.far = de, (L !== M.near || N !== M.far) && (r.updateRenderState({
        depthNear: M.near,
        depthFar: M.far
      }), L = M.near, N = M.far), P.layers.mask = te.layers.mask | 2, T.layers.mask = te.layers.mask | 4, M.layers.mask = P.layers.mask | T.layers.mask;
      const H = te.parent, X = M.cameras;
      le(M, H);
      for (let V = 0; V < X.length; V++)
        le(X[V], H);
      X.length === 2 ? ee(M, P, T) : M.projectionMatrix.copy(P.projectionMatrix), oe(te, M, H);
    };
    function oe(te, ne, de) {
      de === null ? te.matrix.copy(ne.matrixWorld) : (te.matrix.copy(de.matrixWorld), te.matrix.invert(), te.matrix.multiply(ne.matrixWorld)), te.matrix.decompose(te.position, te.quaternion, te.scale), te.updateMatrixWorld(!0), te.projectionMatrix.copy(ne.projectionMatrix), te.projectionMatrixInverse.copy(ne.projectionMatrixInverse), te.isPerspectiveCamera && (te.fov = Oo * 2 * Math.atan(1 / te.projectionMatrix.elements[5]), te.zoom = 1);
    }
    this.getCamera = function() {
      return M;
    }, this.getFoveation = function() {
      if (!(m === null && p === null))
        return c;
    }, this.setFoveation = function(te) {
      c = te, m !== null && (m.fixedFoveation = te), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = te);
    }, this.hasDepthSensing = function() {
      return _.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return _.getMesh(M);
    };
    let Y = null;
    function j(te, ne) {
      if (d = ne.getViewerPose(u || a), y = ne, d !== null) {
        const de = d.views;
        p !== null && (e.setRenderTargetFramebuffer(S, p.framebuffer), e.setRenderTarget(S));
        let H = !1;
        de.length !== M.cameras.length && (M.cameras.length = 0, H = !0);
        for (let V = 0; V < de.length; V++) {
          const I = de[V];
          let F = null;
          if (p !== null)
            F = p.getViewport(I);
          else {
            const Q = h.getViewSubImage(m, I);
            F = Q.viewport, V === 0 && (e.setRenderTargetTextures(
              S,
              Q.colorTexture,
              m.ignoreDepthValues ? void 0 : Q.depthStencilTexture
            ), e.setRenderTarget(S));
          }
          let k = b[V];
          k === void 0 && (k = new ci(), k.layers.enable(V), k.viewport = new jt(), b[V] = k), k.matrix.fromArray(I.transform.matrix), k.matrix.decompose(k.position, k.quaternion, k.scale), k.projectionMatrix.fromArray(I.projectionMatrix), k.projectionMatrixInverse.copy(k.projectionMatrix).invert(), k.viewport.set(F.x, F.y, F.width, F.height), V === 0 && (M.matrix.copy(k.matrix), M.matrix.decompose(M.position, M.quaternion, M.scale)), H === !0 && M.cameras.push(k);
        }
        const X = r.enabledFeatures;
        if (X && X.includes("depth-sensing")) {
          const V = h.getDepthInformation(de[0]);
          V && V.isValid && V.texture && _.init(e, V, r.renderState);
        }
      }
      for (let de = 0; de < w.length; de++) {
        const H = x[de], X = w[de];
        H !== null && X !== void 0 && X.update(H, ne, u || a);
      }
      Y && Y(te, ne), ne.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: ne }), y = null;
    }
    const q = new j0();
    q.setAnimationLoop(j), this.setAnimationLoop = function(te) {
      Y = te;
    }, this.dispose = function() {
    };
  }
}
const mr = /* @__PURE__ */ new wi(), mE = /* @__PURE__ */ new Zt();
function vE(s, e) {
  function n(v, g) {
    v.matrixAutoUpdate === !0 && v.updateMatrix(), g.value.copy(v.matrix);
  }
  function i(v, g) {
    g.color.getRGB(v.fogColor.value, W0(s)), g.isFog ? (v.fogNear.value = g.near, v.fogFar.value = g.far) : g.isFogExp2 && (v.fogDensity.value = g.density);
  }
  function r(v, g, S, w, x) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial ? o(v, g) : g.isMeshToonMaterial ? (o(v, g), h(v, g)) : g.isMeshPhongMaterial ? (o(v, g), d(v, g)) : g.isMeshStandardMaterial ? (o(v, g), m(v, g), g.isMeshPhysicalMaterial && p(v, g, x)) : g.isMeshMatcapMaterial ? (o(v, g), y(v, g)) : g.isMeshDepthMaterial ? o(v, g) : g.isMeshDistanceMaterial ? (o(v, g), _(v, g)) : g.isMeshNormalMaterial ? o(v, g) : g.isLineBasicMaterial ? (a(v, g), g.isLineDashedMaterial && l(v, g)) : g.isPointsMaterial ? c(v, g, S, w) : g.isSpriteMaterial ? u(v, g) : g.isShadowMaterial ? (v.color.value.copy(g.color), v.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function o(v, g) {
    v.opacity.value = g.opacity, g.color && v.diffuse.value.copy(g.color), g.emissive && v.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (v.map.value = g.map, n(g.map, v.mapTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, n(g.alphaMap, v.alphaMapTransform)), g.bumpMap && (v.bumpMap.value = g.bumpMap, n(g.bumpMap, v.bumpMapTransform), v.bumpScale.value = g.bumpScale, g.side === di && (v.bumpScale.value *= -1)), g.normalMap && (v.normalMap.value = g.normalMap, n(g.normalMap, v.normalMapTransform), v.normalScale.value.copy(g.normalScale), g.side === di && v.normalScale.value.negate()), g.displacementMap && (v.displacementMap.value = g.displacementMap, n(g.displacementMap, v.displacementMapTransform), v.displacementScale.value = g.displacementScale, v.displacementBias.value = g.displacementBias), g.emissiveMap && (v.emissiveMap.value = g.emissiveMap, n(g.emissiveMap, v.emissiveMapTransform)), g.specularMap && (v.specularMap.value = g.specularMap, n(g.specularMap, v.specularMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
    const S = e.get(g), w = S.envMap, x = S.envMapRotation;
    w && (v.envMap.value = w, mr.copy(x), mr.x *= -1, mr.y *= -1, mr.z *= -1, w.isCubeTexture && w.isRenderTargetTexture === !1 && (mr.y *= -1, mr.z *= -1), v.envMapRotation.value.setFromMatrix4(mE.makeRotationFromEuler(mr)), v.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = g.reflectivity, v.ior.value = g.ior, v.refractionRatio.value = g.refractionRatio), g.lightMap && (v.lightMap.value = g.lightMap, v.lightMapIntensity.value = g.lightMapIntensity, n(g.lightMap, v.lightMapTransform)), g.aoMap && (v.aoMap.value = g.aoMap, v.aoMapIntensity.value = g.aoMapIntensity, n(g.aoMap, v.aoMapTransform));
  }
  function a(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, g.map && (v.map.value = g.map, n(g.map, v.mapTransform));
  }
  function l(v, g) {
    v.dashSize.value = g.dashSize, v.totalSize.value = g.dashSize + g.gapSize, v.scale.value = g.scale;
  }
  function c(v, g, S, w) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.size.value = g.size * S, v.scale.value = w * 0.5, g.map && (v.map.value = g.map, n(g.map, v.uvTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, n(g.alphaMap, v.alphaMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
  }
  function u(v, g) {
    v.diffuse.value.copy(g.color), v.opacity.value = g.opacity, v.rotation.value = g.rotation, g.map && (v.map.value = g.map, n(g.map, v.mapTransform)), g.alphaMap && (v.alphaMap.value = g.alphaMap, n(g.alphaMap, v.alphaMapTransform)), g.alphaTest > 0 && (v.alphaTest.value = g.alphaTest);
  }
  function d(v, g) {
    v.specular.value.copy(g.specular), v.shininess.value = Math.max(g.shininess, 1e-4);
  }
  function h(v, g) {
    g.gradientMap && (v.gradientMap.value = g.gradientMap);
  }
  function m(v, g) {
    v.metalness.value = g.metalness, g.metalnessMap && (v.metalnessMap.value = g.metalnessMap, n(g.metalnessMap, v.metalnessMapTransform)), v.roughness.value = g.roughness, g.roughnessMap && (v.roughnessMap.value = g.roughnessMap, n(g.roughnessMap, v.roughnessMapTransform)), g.envMap && (v.envMapIntensity.value = g.envMapIntensity);
  }
  function p(v, g, S) {
    v.ior.value = g.ior, g.sheen > 0 && (v.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), v.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (v.sheenColorMap.value = g.sheenColorMap, n(g.sheenColorMap, v.sheenColorMapTransform)), g.sheenRoughnessMap && (v.sheenRoughnessMap.value = g.sheenRoughnessMap, n(g.sheenRoughnessMap, v.sheenRoughnessMapTransform))), g.clearcoat > 0 && (v.clearcoat.value = g.clearcoat, v.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (v.clearcoatMap.value = g.clearcoatMap, n(g.clearcoatMap, v.clearcoatMapTransform)), g.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap, n(g.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), g.clearcoatNormalMap && (v.clearcoatNormalMap.value = g.clearcoatNormalMap, n(g.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), g.side === di && v.clearcoatNormalScale.value.negate())), g.dispersion > 0 && (v.dispersion.value = g.dispersion), g.iridescence > 0 && (v.iridescence.value = g.iridescence, v.iridescenceIOR.value = g.iridescenceIOR, v.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (v.iridescenceMap.value = g.iridescenceMap, n(g.iridescenceMap, v.iridescenceMapTransform)), g.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = g.iridescenceThicknessMap, n(g.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), g.transmission > 0 && (v.transmission.value = g.transmission, v.transmissionSamplerMap.value = S.texture, v.transmissionSamplerSize.value.set(S.width, S.height), g.transmissionMap && (v.transmissionMap.value = g.transmissionMap, n(g.transmissionMap, v.transmissionMapTransform)), v.thickness.value = g.thickness, g.thicknessMap && (v.thicknessMap.value = g.thicknessMap, n(g.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = g.attenuationDistance, v.attenuationColor.value.copy(g.attenuationColor)), g.anisotropy > 0 && (v.anisotropyVector.value.set(g.anisotropy * Math.cos(g.anisotropyRotation), g.anisotropy * Math.sin(g.anisotropyRotation)), g.anisotropyMap && (v.anisotropyMap.value = g.anisotropyMap, n(g.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = g.specularIntensity, v.specularColor.value.copy(g.specularColor), g.specularColorMap && (v.specularColorMap.value = g.specularColorMap, n(g.specularColorMap, v.specularColorMapTransform)), g.specularIntensityMap && (v.specularIntensityMap.value = g.specularIntensityMap, n(g.specularIntensityMap, v.specularIntensityMapTransform));
  }
  function y(v, g) {
    g.matcap && (v.matcap.value = g.matcap);
  }
  function _(v, g) {
    const S = e.get(g).light;
    v.referencePosition.value.setFromMatrixPosition(S.matrixWorld), v.nearDistance.value = S.shadow.camera.near, v.farDistance.value = S.shadow.camera.far;
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: r
  };
}
function gE(s, e, n, i) {
  let r = {}, o = {}, a = [];
  const l = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
  function c(S, w) {
    const x = w.program;
    i.uniformBlockBinding(S, x);
  }
  function u(S, w) {
    let x = r[S.id];
    x === void 0 && (y(S), x = d(S), r[S.id] = x, S.addEventListener("dispose", v));
    const C = w.program;
    i.updateUBOMapping(S, C);
    const E = e.render.frame;
    o[S.id] !== E && (m(S), o[S.id] = E);
  }
  function d(S) {
    const w = h();
    S.__bindingPointIndex = w;
    const x = s.createBuffer(), C = S.__size, E = S.usage;
    return s.bindBuffer(s.UNIFORM_BUFFER, x), s.bufferData(s.UNIFORM_BUFFER, C, E), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, w, x), x;
  }
  function h() {
    for (let S = 0; S < l; S++)
      if (a.indexOf(S) === -1)
        return a.push(S), S;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function m(S) {
    const w = r[S.id], x = S.uniforms, C = S.__cache;
    s.bindBuffer(s.UNIFORM_BUFFER, w);
    for (let E = 0, P = x.length; E < P; E++) {
      const T = Array.isArray(x[E]) ? x[E] : [x[E]];
      for (let b = 0, M = T.length; b < M; b++) {
        const L = T[b];
        if (p(L, E, b, C) === !0) {
          const N = L.__offset, D = Array.isArray(L.value) ? L.value : [L.value];
          let O = 0;
          for (let A = 0; A < D.length; A++) {
            const G = D[A], he = _(G);
            typeof G == "number" || typeof G == "boolean" ? (L.__data[0] = G, s.bufferSubData(s.UNIFORM_BUFFER, N + O, L.__data)) : G.isMatrix3 ? (L.__data[0] = G.elements[0], L.__data[1] = G.elements[1], L.__data[2] = G.elements[2], L.__data[3] = 0, L.__data[4] = G.elements[3], L.__data[5] = G.elements[4], L.__data[6] = G.elements[5], L.__data[7] = 0, L.__data[8] = G.elements[6], L.__data[9] = G.elements[7], L.__data[10] = G.elements[8], L.__data[11] = 0) : (G.toArray(L.__data, O), O += he.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          s.bufferSubData(s.UNIFORM_BUFFER, N, L.__data);
        }
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null);
  }
  function p(S, w, x, C) {
    const E = S.value, P = w + "_" + x;
    if (C[P] === void 0)
      return typeof E == "number" || typeof E == "boolean" ? C[P] = E : C[P] = E.clone(), !0;
    {
      const T = C[P];
      if (typeof E == "number" || typeof E == "boolean") {
        if (T !== E)
          return C[P] = E, !0;
      } else if (T.equals(E) === !1)
        return T.copy(E), !0;
    }
    return !1;
  }
  function y(S) {
    const w = S.uniforms;
    let x = 0;
    const C = 16;
    for (let P = 0, T = w.length; P < T; P++) {
      const b = Array.isArray(w[P]) ? w[P] : [w[P]];
      for (let M = 0, L = b.length; M < L; M++) {
        const N = b[M], D = Array.isArray(N.value) ? N.value : [N.value];
        for (let O = 0, A = D.length; O < A; O++) {
          const G = D[O], he = _(G), ee = x % C, le = ee % he.boundary, oe = ee + le;
          x += le, oe !== 0 && C - oe < he.storage && (x += C - oe), N.__data = new Float32Array(he.storage / Float32Array.BYTES_PER_ELEMENT), N.__offset = x, x += he.storage;
        }
      }
    }
    const E = x % C;
    return E > 0 && (x += C - E), S.__size = x, S.__cache = {}, this;
  }
  function _(S) {
    const w = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof S == "number" || typeof S == "boolean" ? (w.boundary = 4, w.storage = 4) : S.isVector2 ? (w.boundary = 8, w.storage = 8) : S.isVector3 || S.isColor ? (w.boundary = 16, w.storage = 12) : S.isVector4 ? (w.boundary = 16, w.storage = 16) : S.isMatrix3 ? (w.boundary = 48, w.storage = 48) : S.isMatrix4 ? (w.boundary = 64, w.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), w;
  }
  function v(S) {
    const w = S.target;
    w.removeEventListener("dispose", v);
    const x = a.indexOf(w.__bindingPointIndex);
    a.splice(x, 1), s.deleteBuffer(r[w.id]), delete r[w.id], delete o[w.id];
  }
  function g() {
    for (const S in r)
      s.deleteBuffer(r[S]);
    a = [], r = {}, o = {};
  }
  return {
    bind: c,
    update: u,
    dispose: g
  };
}
class yE {
  constructor(e = {}) {
    const {
      canvas: n = cb(),
      context: i = null,
      depth: r = !0,
      stencil: o = !1,
      alpha: a = !1,
      antialias: l = !1,
      premultipliedAlpha: c = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: h = !1,
      reverseDepthBuffer: m = !1
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    if (i !== null) {
      if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      p = i.getContextAttributes().alpha;
    } else
      p = a;
    const y = new Uint32Array(4), _ = new Int32Array(4);
    let v = null, g = null;
    const S = [], w = [];
    this.domElement = n, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = pn, this.toneMapping = Qs, this.toneMappingExposure = 1;
    const x = this;
    let C = !1, E = 0, P = 0, T = null, b = -1, M = null;
    const L = new jt(), N = new jt();
    let D = null;
    const O = new Mt(0);
    let A = 0, G = n.width, he = n.height, ee = 1, le = null, oe = null;
    const Y = new jt(0, 0, G, he), j = new jt(0, 0, G, he);
    let q = !1;
    const te = new Mf();
    let ne = !1, de = !1;
    const H = new Zt(), X = new Zt(), V = new ce(), I = new jt(), F = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let k = !1;
    function Q() {
      return T === null ? ee : 1;
    }
    let Z = i;
    function R(W, ve) {
      return n.getContext(W, ve);
    }
    try {
      const W = {
        alpha: !0,
        depth: r,
        stencil: o,
        antialias: l,
        premultipliedAlpha: c,
        preserveDrawingBuffer: u,
        powerPreference: d,
        failIfMajorPerformanceCaveat: h
      };
      if ("setAttribute" in n && n.setAttribute("data-engine", `three.js r${df}`), n.addEventListener("webglcontextlost", Be, !1), n.addEventListener("webglcontextrestored", je, !1), n.addEventListener("webglcontextcreationerror", Ve, !1), Z === null) {
        const ve = "webgl2";
        if (Z = R(ve, W), Z === null)
          throw R(ve) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (W) {
      throw console.error("THREE.WebGLRenderer: " + W.message), W;
    }
    let ie, J, B, $, se, U, z, K, ue, me, ge, Me, Te, Ae, Xe, Fe, He, Ye, We, ke, nt, Je, _t, we;
    function ze() {
      ie = new CM(Z), ie.init(), Je = new lE(Z, ie), J = new _M(Z, ie, e, Je), B = new rE(Z, ie), J.reverseDepthBuffer && m && B.buffers.depth.setReversed(!0), $ = new AM(Z), se = new XC(), U = new aE(Z, ie, B, se, J, Je, $), z = new bM(x), K = new MM(x), ue = new Fb(Z), _t = new gM(Z, ue), me = new EM(Z, ue, $, _t), ge = new DM(Z, me, ue, $), We = new PM(Z, J, U), Fe = new xM(se), Me = new $C(x, z, K, ie, J, _t, Fe), Te = new vE(x, se), Ae = new YC(), Xe = new eE(ie), Ye = new vM(x, z, K, B, ge, p, c), He = new iE(x, ge, J), we = new gE(Z, $, J, B), ke = new yM(Z, ie, $), nt = new TM(Z, ie, $), $.programs = Me.programs, x.capabilities = J, x.extensions = ie, x.properties = se, x.renderLists = Ae, x.shadowMap = He, x.state = B, x.info = $;
    }
    ze();
    const De = new pE(x, Z);
    this.xr = De, this.getContext = function() {
      return Z;
    }, this.getContextAttributes = function() {
      return Z.getContextAttributes();
    }, this.forceContextLoss = function() {
      const W = ie.get("WEBGL_lose_context");
      W && W.loseContext();
    }, this.forceContextRestore = function() {
      const W = ie.get("WEBGL_lose_context");
      W && W.restoreContext();
    }, this.getPixelRatio = function() {
      return ee;
    }, this.setPixelRatio = function(W) {
      W !== void 0 && (ee = W, this.setSize(G, he, !1));
    }, this.getSize = function(W) {
      return W.set(G, he);
    }, this.setSize = function(W, ve, ye = !0) {
      if (De.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      G = W, he = ve, n.width = Math.floor(W * ee), n.height = Math.floor(ve * ee), ye === !0 && (n.style.width = W + "px", n.style.height = ve + "px"), this.setViewport(0, 0, W, ve);
    }, this.getDrawingBufferSize = function(W) {
      return W.set(G * ee, he * ee).floor();
    }, this.setDrawingBufferSize = function(W, ve, ye) {
      G = W, he = ve, ee = ye, n.width = Math.floor(W * ye), n.height = Math.floor(ve * ye), this.setViewport(0, 0, W, ve);
    }, this.getCurrentViewport = function(W) {
      return W.copy(L);
    }, this.getViewport = function(W) {
      return W.copy(Y);
    }, this.setViewport = function(W, ve, ye, Ce) {
      W.isVector4 ? Y.set(W.x, W.y, W.z, W.w) : Y.set(W, ve, ye, Ce), B.viewport(L.copy(Y).multiplyScalar(ee).round());
    }, this.getScissor = function(W) {
      return W.copy(j);
    }, this.setScissor = function(W, ve, ye, Ce) {
      W.isVector4 ? j.set(W.x, W.y, W.z, W.w) : j.set(W, ve, ye, Ce), B.scissor(N.copy(j).multiplyScalar(ee).round());
    }, this.getScissorTest = function() {
      return q;
    }, this.setScissorTest = function(W) {
      B.setScissorTest(q = W);
    }, this.setOpaqueSort = function(W) {
      le = W;
    }, this.setTransparentSort = function(W) {
      oe = W;
    }, this.getClearColor = function(W) {
      return W.copy(Ye.getClearColor());
    }, this.setClearColor = function() {
      Ye.setClearColor.apply(Ye, arguments);
    }, this.getClearAlpha = function() {
      return Ye.getClearAlpha();
    }, this.setClearAlpha = function() {
      Ye.setClearAlpha.apply(Ye, arguments);
    }, this.clear = function(W = !0, ve = !0, ye = !0) {
      let Ce = 0;
      if (W) {
        let xe = !1;
        if (T !== null) {
          const Ie = T.texture.format;
          xe = Ie === yf || Ie === gf || Ie === vf;
        }
        if (xe) {
          const Ie = T.texture.type, Re = Ie === is || Ie === zr || Ie === tl || Ie === Fo || Ie === pf || Ie === mf, Qe = Ye.getClearColor(), it = Ye.getClearAlpha(), mt = Qe.r, gt = Qe.g, ot = Qe.b;
          Re ? (y[0] = mt, y[1] = gt, y[2] = ot, y[3] = it, Z.clearBufferuiv(Z.COLOR, 0, y)) : (_[0] = mt, _[1] = gt, _[2] = ot, _[3] = it, Z.clearBufferiv(Z.COLOR, 0, _));
        } else
          Ce |= Z.COLOR_BUFFER_BIT;
      }
      ve && (Ce |= Z.DEPTH_BUFFER_BIT), ye && (Ce |= Z.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), Z.clear(Ce);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      n.removeEventListener("webglcontextlost", Be, !1), n.removeEventListener("webglcontextrestored", je, !1), n.removeEventListener("webglcontextcreationerror", Ve, !1), Ae.dispose(), Xe.dispose(), se.dispose(), z.dispose(), K.dispose(), ge.dispose(), _t.dispose(), we.dispose(), Me.dispose(), De.dispose(), De.removeEventListener("sessionstart", sn), De.removeEventListener("sessionend", Un), xn.stop();
    };
    function Be(W) {
      W.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0;
    }
    function je() {
      console.log("THREE.WebGLRenderer: Context Restored."), C = !1;
      const W = $.autoReset, ve = He.enabled, ye = He.autoUpdate, Ce = He.needsUpdate, xe = He.type;
      ze(), $.autoReset = W, He.enabled = ve, He.autoUpdate = ye, He.needsUpdate = Ce, He.type = xe;
    }
    function Ve(W) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", W.statusMessage);
    }
    function lt(W) {
      const ve = W.target;
      ve.removeEventListener("dispose", lt), rt(ve);
    }
    function rt(W) {
      ut(W), se.remove(W);
    }
    function ut(W) {
      const ve = se.get(W).programs;
      ve !== void 0 && (ve.forEach(function(ye) {
        Me.releaseProgram(ye);
      }), W.isShaderMaterial && Me.releaseShaderCache(W));
    }
    this.renderBufferDirect = function(W, ve, ye, Ce, xe, Ie) {
      ve === null && (ve = F);
      const Re = xe.isMesh && xe.matrixWorld.determinant() < 0, Qe = _e(W, ve, ye, Ce, xe);
      B.setMaterial(Ce, Re);
      let it = ye.index, mt = 1;
      if (Ce.wireframe === !0) {
        if (it = me.getWireframeAttribute(ye), it === void 0) return;
        mt = 2;
      }
      const gt = ye.drawRange, ot = ye.attributes.position;
      let Dt = gt.start * mt, Vt = (gt.start + gt.count) * mt;
      Ie !== null && (Dt = Math.max(Dt, Ie.start * mt), Vt = Math.min(Vt, (Ie.start + Ie.count) * mt)), it !== null ? (Dt = Math.max(Dt, 0), Vt = Math.min(Vt, it.count)) : ot != null && (Dt = Math.max(Dt, 0), Vt = Math.min(Vt, ot.count));
      const Gt = Vt - Dt;
      if (Gt < 0 || Gt === 1 / 0) return;
      _t.setup(xe, Ce, Qe, ye, it);
      let An, It = ke;
      if (it !== null && (An = ue.get(it), It = nt, It.setIndex(An)), xe.isMesh)
        Ce.wireframe === !0 ? (B.setLineWidth(Ce.wireframeLinewidth * Q()), It.setMode(Z.LINES)) : It.setMode(Z.TRIANGLES);
      else if (xe.isLine) {
        let dt = Ce.linewidth;
        dt === void 0 && (dt = 1), B.setLineWidth(dt * Q()), xe.isLineSegments ? It.setMode(Z.LINES) : xe.isLineLoop ? It.setMode(Z.LINE_LOOP) : It.setMode(Z.LINE_STRIP);
      } else xe.isPoints ? It.setMode(Z.POINTS) : xe.isSprite && It.setMode(Z.TRIANGLES);
      if (xe.isBatchedMesh)
        if (xe._multiDrawInstances !== null)
          It.renderMultiDrawInstances(xe._multiDrawStarts, xe._multiDrawCounts, xe._multiDrawCount, xe._multiDrawInstances);
        else if (ie.get("WEBGL_multi_draw"))
          It.renderMultiDraw(xe._multiDrawStarts, xe._multiDrawCounts, xe._multiDrawCount);
        else {
          const dt = xe._multiDrawStarts, pi = xe._multiDrawCounts, Lt = xe._multiDrawCount, Pn = it ? ue.get(it).bytesPerElement : 1, Xi = se.get(Ce).currentProgram.getUniforms();
          for (let wn = 0; wn < Lt; wn++)
            Xi.setValue(Z, "_gl_DrawID", wn), It.render(dt[wn] / Pn, pi[wn]);
        }
      else if (xe.isInstancedMesh)
        It.renderInstances(Dt, Gt, xe.count);
      else if (ye.isInstancedBufferGeometry) {
        const dt = ye._maxInstanceCount !== void 0 ? ye._maxInstanceCount : 1 / 0, pi = Math.min(ye.instanceCount, dt);
        It.renderInstances(Dt, Gt, pi);
      } else
        It.render(Dt, Gt);
    };
    function pt(W, ve, ye) {
      W.transparent === !0 && W.side === mn && W.forceSinglePass === !1 ? (W.side = di, W.needsUpdate = !0, ni(W, ve, ye), W.side = er, W.needsUpdate = !0, ni(W, ve, ye), W.side = mn) : ni(W, ve, ye);
    }
    this.compile = function(W, ve, ye = null) {
      ye === null && (ye = W), g = Xe.get(ye), g.init(ve), w.push(g), ye.traverseVisible(function(xe) {
        xe.isLight && xe.layers.test(ve.layers) && (g.pushLight(xe), xe.castShadow && g.pushShadow(xe));
      }), W !== ye && W.traverseVisible(function(xe) {
        xe.isLight && xe.layers.test(ve.layers) && (g.pushLight(xe), xe.castShadow && g.pushShadow(xe));
      }), g.setupLights();
      const Ce = /* @__PURE__ */ new Set();
      return W.traverse(function(xe) {
        if (!(xe.isMesh || xe.isPoints || xe.isLine || xe.isSprite))
          return;
        const Ie = xe.material;
        if (Ie)
          if (Array.isArray(Ie))
            for (let Re = 0; Re < Ie.length; Re++) {
              const Qe = Ie[Re];
              pt(Qe, ye, xe), Ce.add(Qe);
            }
          else
            pt(Ie, ye, xe), Ce.add(Ie);
      }), w.pop(), g = null, Ce;
    }, this.compileAsync = function(W, ve, ye = null) {
      const Ce = this.compile(W, ve, ye);
      return new Promise((xe) => {
        function Ie() {
          if (Ce.forEach(function(Re) {
            se.get(Re).currentProgram.isReady() && Ce.delete(Re);
          }), Ce.size === 0) {
            xe(W);
            return;
          }
          setTimeout(Ie, 10);
        }
        ie.get("KHR_parallel_shader_compile") !== null ? Ie() : setTimeout(Ie, 10);
      });
    };
    let Ot = null;
    function Kt(W) {
      Ot && Ot(W);
    }
    function sn() {
      xn.stop();
    }
    function Un() {
      xn.start();
    }
    const xn = new j0();
    xn.setAnimationLoop(Kt), typeof self < "u" && xn.setContext(self), this.setAnimationLoop = function(W) {
      Ot = W, De.setAnimationLoop(W), W === null ? xn.stop() : xn.start();
    }, De.addEventListener("sessionstart", sn), De.addEventListener("sessionend", Un), this.render = function(W, ve) {
      if (ve !== void 0 && ve.isCamera !== !0) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (C === !0) return;
      if (W.matrixWorldAutoUpdate === !0 && W.updateMatrixWorld(), ve.parent === null && ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), De.enabled === !0 && De.isPresenting === !0 && (De.cameraAutoUpdate === !0 && De.updateCamera(ve), ve = De.getCamera()), W.isScene === !0 && W.onBeforeRender(x, W, ve, T), g = Xe.get(W, w.length), g.init(ve), w.push(g), X.multiplyMatrices(ve.projectionMatrix, ve.matrixWorldInverse), te.setFromProjectionMatrix(X), de = this.localClippingEnabled, ne = Fe.init(this.clippingPlanes, de), v = Ae.get(W, S.length), v.init(), S.push(v), De.enabled === !0 && De.isPresenting === !0) {
        const Ie = x.xr.getDepthSensingMesh();
        Ie !== null && Yn(Ie, ve, -1 / 0, x.sortObjects);
      }
      Yn(W, ve, 0, x.sortObjects), v.finish(), x.sortObjects === !0 && v.sort(le, oe), k = De.enabled === !1 || De.isPresenting === !1 || De.hasDepthSensing() === !1, k && Ye.addToRenderList(v, W), this.info.render.frame++, ne === !0 && Fe.beginShadows();
      const ye = g.state.shadowsArray;
      He.render(ye, W, ve), ne === !0 && Fe.endShadows(), this.info.autoReset === !0 && this.info.reset();
      const Ce = v.opaque, xe = v.transmissive;
      if (g.setupLights(), ve.isArrayCamera) {
        const Ie = ve.cameras;
        if (xe.length > 0)
          for (let Re = 0, Qe = Ie.length; Re < Qe; Re++) {
            const it = Ie[Re];
            fi(Ce, xe, W, it);
          }
        k && Ye.render(W);
        for (let Re = 0, Qe = Ie.length; Re < Qe; Re++) {
          const it = Ie[Re];
          hi(v, W, it, it.viewport);
        }
      } else
        xe.length > 0 && fi(Ce, xe, W, ve), k && Ye.render(W), hi(v, W, ve);
      T !== null && (U.updateMultisampleRenderTarget(T), U.updateRenderTargetMipmap(T)), W.isScene === !0 && W.onAfterRender(x, W, ve), _t.resetDefaultState(), b = -1, M = null, w.pop(), w.length > 0 ? (g = w[w.length - 1], ne === !0 && Fe.setGlobalState(x.clippingPlanes, g.state.camera)) : g = null, S.pop(), S.length > 0 ? v = S[S.length - 1] : v = null;
    };
    function Yn(W, ve, ye, Ce) {
      if (W.visible === !1) return;
      if (W.layers.test(ve.layers)) {
        if (W.isGroup)
          ye = W.renderOrder;
        else if (W.isLOD)
          W.autoUpdate === !0 && W.update(ve);
        else if (W.isLight)
          g.pushLight(W), W.castShadow && g.pushShadow(W);
        else if (W.isSprite) {
          if (!W.frustumCulled || te.intersectsSprite(W)) {
            Ce && I.setFromMatrixPosition(W.matrixWorld).applyMatrix4(X);
            const Re = ge.update(W), Qe = W.material;
            Qe.visible && v.push(W, Re, Qe, ye, I.z, null);
          }
        } else if ((W.isMesh || W.isLine || W.isPoints) && (!W.frustumCulled || te.intersectsObject(W))) {
          const Re = ge.update(W), Qe = W.material;
          if (Ce && (W.boundingSphere !== void 0 ? (W.boundingSphere === null && W.computeBoundingSphere(), I.copy(W.boundingSphere.center)) : (Re.boundingSphere === null && Re.computeBoundingSphere(), I.copy(Re.boundingSphere.center)), I.applyMatrix4(W.matrixWorld).applyMatrix4(X)), Array.isArray(Qe)) {
            const it = Re.groups;
            for (let mt = 0, gt = it.length; mt < gt; mt++) {
              const ot = it[mt], Dt = Qe[ot.materialIndex];
              Dt && Dt.visible && v.push(W, Re, Dt, ye, I.z, ot);
            }
          } else Qe.visible && v.push(W, Re, Qe, ye, I.z, null);
        }
      }
      const Ie = W.children;
      for (let Re = 0, Qe = Ie.length; Re < Qe; Re++)
        Yn(Ie[Re], ve, ye, Ce);
    }
    function hi(W, ve, ye, Ce) {
      const xe = W.opaque, Ie = W.transmissive, Re = W.transparent;
      g.setupLightsView(ye), ne === !0 && Fe.setGlobalState(x.clippingPlanes, ye), Ce && B.viewport(L.copy(Ce)), xe.length > 0 && On(xe, ve, ye), Ie.length > 0 && On(Ie, ve, ye), Re.length > 0 && On(Re, ve, ye), B.buffers.depth.setTest(!0), B.buffers.depth.setMask(!0), B.buffers.color.setMask(!0), B.setPolygonOffset(!1);
    }
    function fi(W, ve, ye, Ce) {
      if ((ye.isScene === !0 ? ye.overrideMaterial : null) !== null)
        return;
      g.state.transmissionRenderTarget[Ce.id] === void 0 && (g.state.transmissionRenderTarget[Ce.id] = new Hi(1, 1, {
        generateMipmaps: !0,
        type: ie.has("EXT_color_buffer_half_float") || ie.has("EXT_color_buffer_float") ? sr : is,
        minFilter: Rr,
        samples: 4,
        stencilBuffer: o,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1,
        colorSpace: kt.workingColorSpace
      }));
      const Ie = g.state.transmissionRenderTarget[Ce.id], Re = Ce.viewport || L;
      Ie.setSize(Re.z, Re.w);
      const Qe = x.getRenderTarget();
      x.setRenderTarget(Ie), x.getClearColor(O), A = x.getClearAlpha(), A < 1 && x.setClearColor(16777215, 0.5), x.clear(), k && Ye.render(ye);
      const it = x.toneMapping;
      x.toneMapping = Qs;
      const mt = Ce.viewport;
      if (Ce.viewport !== void 0 && (Ce.viewport = void 0), g.setupLightsView(Ce), ne === !0 && Fe.setGlobalState(x.clippingPlanes, Ce), On(W, ye, Ce), U.updateMultisampleRenderTarget(Ie), U.updateRenderTargetMipmap(Ie), ie.has("WEBGL_multisampled_render_to_texture") === !1) {
        let gt = !1;
        for (let ot = 0, Dt = ve.length; ot < Dt; ot++) {
          const Vt = ve[ot], Gt = Vt.object, An = Vt.geometry, It = Vt.material, dt = Vt.group;
          if (It.side === mn && Gt.layers.test(Ce.layers)) {
            const pi = It.side;
            It.side = di, It.needsUpdate = !0, bn(Gt, ye, Ce, An, It, dt), It.side = pi, It.needsUpdate = !0, gt = !0;
          }
        }
        gt === !0 && (U.updateMultisampleRenderTarget(Ie), U.updateRenderTargetMipmap(Ie));
      }
      x.setRenderTarget(Qe), x.setClearColor(O, A), mt !== void 0 && (Ce.viewport = mt), x.toneMapping = it;
    }
    function On(W, ve, ye) {
      const Ce = ve.isScene === !0 ? ve.overrideMaterial : null;
      for (let xe = 0, Ie = W.length; xe < Ie; xe++) {
        const Re = W[xe], Qe = Re.object, it = Re.geometry, mt = Ce === null ? Re.material : Ce, gt = Re.group;
        Qe.layers.test(ye.layers) && bn(Qe, ve, ye, it, mt, gt);
      }
    }
    function bn(W, ve, ye, Ce, xe, Ie) {
      W.onBeforeRender(x, ve, ye, Ce, xe, Ie), W.modelViewMatrix.multiplyMatrices(ye.matrixWorldInverse, W.matrixWorld), W.normalMatrix.getNormalMatrix(W.modelViewMatrix), xe.onBeforeRender(x, ve, ye, Ce, W, Ie), xe.transparent === !0 && xe.side === mn && xe.forceSinglePass === !1 ? (xe.side = di, xe.needsUpdate = !0, x.renderBufferDirect(ye, ve, Ce, xe, W, Ie), xe.side = er, xe.needsUpdate = !0, x.renderBufferDirect(ye, ve, Ce, xe, W, Ie), xe.side = mn) : x.renderBufferDirect(ye, ve, Ce, xe, W, Ie), W.onAfterRender(x, ve, ye, Ce, xe, Ie);
    }
    function ni(W, ve, ye) {
      ve.isScene !== !0 && (ve = F);
      const Ce = se.get(W), xe = g.state.lights, Ie = g.state.shadowsArray, Re = xe.state.version, Qe = Me.getParameters(W, xe.state, Ie, ve, ye), it = Me.getProgramCacheKey(Qe);
      let mt = Ce.programs;
      Ce.environment = W.isMeshStandardMaterial ? ve.environment : null, Ce.fog = ve.fog, Ce.envMap = (W.isMeshStandardMaterial ? K : z).get(W.envMap || Ce.environment), Ce.envMapRotation = Ce.environment !== null && W.envMap === null ? ve.environmentRotation : W.envMapRotation, mt === void 0 && (W.addEventListener("dispose", lt), mt = /* @__PURE__ */ new Map(), Ce.programs = mt);
      let gt = mt.get(it);
      if (gt !== void 0) {
        if (Ce.currentProgram === gt && Ce.lightsStateVersion === Re)
          return fe(W, Qe), gt;
      } else
        Qe.uniforms = Me.getUniforms(W), W.onBeforeCompile(Qe, x), gt = Me.acquireProgram(Qe, it), mt.set(it, gt), Ce.uniforms = Qe.uniforms;
      const ot = Ce.uniforms;
      return (!W.isShaderMaterial && !W.isRawShaderMaterial || W.clipping === !0) && (ot.clippingPlanes = Fe.uniform), fe(W, Qe), Ce.needsLights = Le(W), Ce.lightsStateVersion = Re, Ce.needsLights && (ot.ambientLightColor.value = xe.state.ambient, ot.lightProbe.value = xe.state.probe, ot.directionalLights.value = xe.state.directional, ot.directionalLightShadows.value = xe.state.directionalShadow, ot.spotLights.value = xe.state.spot, ot.spotLightShadows.value = xe.state.spotShadow, ot.rectAreaLights.value = xe.state.rectArea, ot.ltc_1.value = xe.state.rectAreaLTC1, ot.ltc_2.value = xe.state.rectAreaLTC2, ot.pointLights.value = xe.state.point, ot.pointLightShadows.value = xe.state.pointShadow, ot.hemisphereLights.value = xe.state.hemi, ot.directionalShadowMap.value = xe.state.directionalShadowMap, ot.directionalShadowMatrix.value = xe.state.directionalShadowMatrix, ot.spotShadowMap.value = xe.state.spotShadowMap, ot.spotLightMatrix.value = xe.state.spotLightMatrix, ot.spotLightMap.value = xe.state.spotLightMap, ot.pointShadowMap.value = xe.state.pointShadowMap, ot.pointShadowMatrix.value = xe.state.pointShadowMatrix), Ce.currentProgram = gt, Ce.uniformsList = null, gt;
    }
    function Pi(W) {
      if (W.uniformsList === null) {
        const ve = W.currentProgram.getUniforms();
        W.uniformsList = Tc.seqWithValue(ve.seq, W.uniforms);
      }
      return W.uniformsList;
    }
    function fe(W, ve) {
      const ye = se.get(W);
      ye.outputColorSpace = ve.outputColorSpace, ye.batching = ve.batching, ye.batchingColor = ve.batchingColor, ye.instancing = ve.instancing, ye.instancingColor = ve.instancingColor, ye.instancingMorph = ve.instancingMorph, ye.skinning = ve.skinning, ye.morphTargets = ve.morphTargets, ye.morphNormals = ve.morphNormals, ye.morphColors = ve.morphColors, ye.morphTargetsCount = ve.morphTargetsCount, ye.numClippingPlanes = ve.numClippingPlanes, ye.numIntersection = ve.numClipIntersection, ye.vertexAlphas = ve.vertexAlphas, ye.vertexTangents = ve.vertexTangents, ye.toneMapping = ve.toneMapping;
    }
    function _e(W, ve, ye, Ce, xe) {
      ve.isScene !== !0 && (ve = F), U.resetTextureUnits();
      const Ie = ve.fog, Re = Ce.isMeshStandardMaterial ? ve.environment : null, Qe = T === null ? x.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : Ho, it = (Ce.isMeshStandardMaterial ? K : z).get(Ce.envMap || Re), mt = Ce.vertexColors === !0 && !!ye.attributes.color && ye.attributes.color.itemSize === 4, gt = !!ye.attributes.tangent && (!!Ce.normalMap || Ce.anisotropy > 0), ot = !!ye.morphAttributes.position, Dt = !!ye.morphAttributes.normal, Vt = !!ye.morphAttributes.color;
      let Gt = Qs;
      Ce.toneMapped && (T === null || T.isXRRenderTarget === !0) && (Gt = x.toneMapping);
      const An = ye.morphAttributes.position || ye.morphAttributes.normal || ye.morphAttributes.color, It = An !== void 0 ? An.length : 0, dt = se.get(Ce), pi = g.state.lights;
      if (ne === !0 && (de === !0 || W !== M)) {
        const si = W === M && Ce.id === b;
        Fe.setState(Ce, W, si);
      }
      let Lt = !1;
      Ce.version === dt.__version ? (dt.needsLights && dt.lightsStateVersion !== pi.state.version || dt.outputColorSpace !== Qe || xe.isBatchedMesh && dt.batching === !1 || !xe.isBatchedMesh && dt.batching === !0 || xe.isBatchedMesh && dt.batchingColor === !0 && xe.colorTexture === null || xe.isBatchedMesh && dt.batchingColor === !1 && xe.colorTexture !== null || xe.isInstancedMesh && dt.instancing === !1 || !xe.isInstancedMesh && dt.instancing === !0 || xe.isSkinnedMesh && dt.skinning === !1 || !xe.isSkinnedMesh && dt.skinning === !0 || xe.isInstancedMesh && dt.instancingColor === !0 && xe.instanceColor === null || xe.isInstancedMesh && dt.instancingColor === !1 && xe.instanceColor !== null || xe.isInstancedMesh && dt.instancingMorph === !0 && xe.morphTexture === null || xe.isInstancedMesh && dt.instancingMorph === !1 && xe.morphTexture !== null || dt.envMap !== it || Ce.fog === !0 && dt.fog !== Ie || dt.numClippingPlanes !== void 0 && (dt.numClippingPlanes !== Fe.numPlanes || dt.numIntersection !== Fe.numIntersection) || dt.vertexAlphas !== mt || dt.vertexTangents !== gt || dt.morphTargets !== ot || dt.morphNormals !== Dt || dt.morphColors !== Vt || dt.toneMapping !== Gt || dt.morphTargetsCount !== It) && (Lt = !0) : (Lt = !0, dt.__version = Ce.version);
      let Pn = dt.currentProgram;
      Lt === !0 && (Pn = ni(Ce, ve, xe));
      let Xi = !1, wn = !1, rs = !1;
      const Yt = Pn.getUniforms(), ii = dt.uniforms;
      if (B.useProgram(Pn.program) && (Xi = !0, wn = !0, rs = !0), Ce.id !== b && (b = Ce.id, wn = !0), Xi || M !== W) {
        B.buffers.depth.getReversed() ? (H.copy(W.projectionMatrix), db(H), hb(H), Yt.setValue(Z, "projectionMatrix", H)) : Yt.setValue(Z, "projectionMatrix", W.projectionMatrix), Yt.setValue(Z, "viewMatrix", W.matrixWorldInverse);
        const mi = Yt.map.cameraPosition;
        mi !== void 0 && mi.setValue(Z, V.setFromMatrixPosition(W.matrixWorld)), J.logarithmicDepthBuffer && Yt.setValue(
          Z,
          "logDepthBufFC",
          2 / (Math.log(W.far + 1) / Math.LN2)
        ), (Ce.isMeshPhongMaterial || Ce.isMeshToonMaterial || Ce.isMeshLambertMaterial || Ce.isMeshBasicMaterial || Ce.isMeshStandardMaterial || Ce.isShaderMaterial) && Yt.setValue(Z, "isOrthographic", W.isOrthographicCamera === !0), M !== W && (M = W, wn = !0, rs = !0);
      }
      if (xe.isSkinnedMesh) {
        Yt.setOptional(Z, xe, "bindMatrix"), Yt.setOptional(Z, xe, "bindMatrixInverse");
        const si = xe.skeleton;
        si && (si.boneTexture === null && si.computeBoneTexture(), Yt.setValue(Z, "boneTexture", si.boneTexture, U));
      }
      xe.isBatchedMesh && (Yt.setOptional(Z, xe, "batchingTexture"), Yt.setValue(Z, "batchingTexture", xe._matricesTexture, U), Yt.setOptional(Z, xe, "batchingIdTexture"), Yt.setValue(Z, "batchingIdTexture", xe._indirectTexture, U), Yt.setOptional(Z, xe, "batchingColorTexture"), xe._colorsTexture !== null && Yt.setValue(Z, "batchingColorTexture", xe._colorsTexture, U));
      const zn = ye.morphAttributes;
      if ((zn.position !== void 0 || zn.normal !== void 0 || zn.color !== void 0) && We.update(xe, ye, Pn), (wn || dt.receiveShadow !== xe.receiveShadow) && (dt.receiveShadow = xe.receiveShadow, Yt.setValue(Z, "receiveShadow", xe.receiveShadow)), Ce.isMeshGouraudMaterial && Ce.envMap !== null && (ii.envMap.value = it, ii.flipEnvMap.value = it.isCubeTexture && it.isRenderTargetTexture === !1 ? -1 : 1), Ce.isMeshStandardMaterial && Ce.envMap === null && ve.environment !== null && (ii.envMapIntensity.value = ve.environmentIntensity), wn && (Yt.setValue(Z, "toneMappingExposure", x.toneMappingExposure), dt.needsLights && Ee(ii, rs), Ie && Ce.fog === !0 && Te.refreshFogUniforms(ii, Ie), Te.refreshMaterialUniforms(ii, Ce, ee, he, g.state.transmissionRenderTarget[W.id]), Tc.upload(Z, Pi(dt), ii, U)), Ce.isShaderMaterial && Ce.uniformsNeedUpdate === !0 && (Tc.upload(Z, Pi(dt), ii, U), Ce.uniformsNeedUpdate = !1), Ce.isSpriteMaterial && Yt.setValue(Z, "center", xe.center), Yt.setValue(Z, "modelViewMatrix", xe.modelViewMatrix), Yt.setValue(Z, "normalMatrix", xe.normalMatrix), Yt.setValue(Z, "modelMatrix", xe.matrixWorld), Ce.isShaderMaterial || Ce.isRawShaderMaterial) {
        const si = Ce.uniformsGroups;
        for (let mi = 0, ri = si.length; mi < ri; mi++) {
          const Yo = si[mi];
          we.update(Yo, Pn), we.bind(Yo, Pn);
        }
      }
      return Pn;
    }
    function Ee(W, ve) {
      W.ambientLightColor.needsUpdate = ve, W.lightProbe.needsUpdate = ve, W.directionalLights.needsUpdate = ve, W.directionalLightShadows.needsUpdate = ve, W.pointLights.needsUpdate = ve, W.pointLightShadows.needsUpdate = ve, W.spotLights.needsUpdate = ve, W.spotLightShadows.needsUpdate = ve, W.rectAreaLights.needsUpdate = ve, W.hemisphereLights.needsUpdate = ve;
    }
    function Le(W) {
      return W.isMeshLambertMaterial || W.isMeshToonMaterial || W.isMeshPhongMaterial || W.isMeshStandardMaterial || W.isShadowMaterial || W.isShaderMaterial && W.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return E;
    }, this.getActiveMipmapLevel = function() {
      return P;
    }, this.getRenderTarget = function() {
      return T;
    }, this.setRenderTargetTextures = function(W, ve, ye) {
      se.get(W.texture).__webglTexture = ve, se.get(W.depthTexture).__webglTexture = ye;
      const Ce = se.get(W);
      Ce.__hasExternalTextures = !0, Ce.__autoAllocateDepthBuffer = ye === void 0, Ce.__autoAllocateDepthBuffer || ie.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), Ce.__useRenderToTexture = !1);
    }, this.setRenderTargetFramebuffer = function(W, ve) {
      const ye = se.get(W);
      ye.__webglFramebuffer = ve, ye.__useDefaultFramebuffer = ve === void 0;
    }, this.setRenderTarget = function(W, ve = 0, ye = 0) {
      T = W, E = ve, P = ye;
      let Ce = !0, xe = null, Ie = !1, Re = !1;
      if (W) {
        const it = se.get(W);
        if (it.__useDefaultFramebuffer !== void 0)
          B.bindFramebuffer(Z.FRAMEBUFFER, null), Ce = !1;
        else if (it.__webglFramebuffer === void 0)
          U.setupRenderTarget(W);
        else if (it.__hasExternalTextures)
          U.rebindTextures(W, se.get(W.texture).__webglTexture, se.get(W.depthTexture).__webglTexture);
        else if (W.depthBuffer) {
          const ot = W.depthTexture;
          if (it.__boundDepthTexture !== ot) {
            if (ot !== null && se.has(ot) && (W.width !== ot.image.width || W.height !== ot.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            U.setupDepthRenderbuffer(W);
          }
        }
        const mt = W.texture;
        (mt.isData3DTexture || mt.isDataArrayTexture || mt.isCompressedArrayTexture) && (Re = !0);
        const gt = se.get(W).__webglFramebuffer;
        W.isWebGLCubeRenderTarget ? (Array.isArray(gt[ve]) ? xe = gt[ve][ye] : xe = gt[ve], Ie = !0) : W.samples > 0 && U.useMultisampledRTT(W) === !1 ? xe = se.get(W).__webglMultisampledFramebuffer : Array.isArray(gt) ? xe = gt[ye] : xe = gt, L.copy(W.viewport), N.copy(W.scissor), D = W.scissorTest;
      } else
        L.copy(Y).multiplyScalar(ee).floor(), N.copy(j).multiplyScalar(ee).floor(), D = q;
      if (B.bindFramebuffer(Z.FRAMEBUFFER, xe) && Ce && B.drawBuffers(W, xe), B.viewport(L), B.scissor(N), B.setScissorTest(D), Ie) {
        const it = se.get(W.texture);
        Z.framebufferTexture2D(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, Z.TEXTURE_CUBE_MAP_POSITIVE_X + ve, it.__webglTexture, ye);
      } else if (Re) {
        const it = se.get(W.texture), mt = ve || 0;
        Z.framebufferTextureLayer(Z.FRAMEBUFFER, Z.COLOR_ATTACHMENT0, it.__webglTexture, ye || 0, mt);
      }
      b = -1;
    }, this.readRenderTargetPixels = function(W, ve, ye, Ce, xe, Ie, Re) {
      if (!(W && W.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Qe = se.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && Re !== void 0 && (Qe = Qe[Re]), Qe) {
        B.bindFramebuffer(Z.FRAMEBUFFER, Qe);
        try {
          const it = W.texture, mt = it.format, gt = it.type;
          if (!J.textureFormatReadable(mt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!J.textureTypeReadable(gt)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ve >= 0 && ve <= W.width - Ce && ye >= 0 && ye <= W.height - xe && Z.readPixels(ve, ye, Ce, xe, Je.convert(mt), Je.convert(gt), Ie);
        } finally {
          const it = T !== null ? se.get(T).__webglFramebuffer : null;
          B.bindFramebuffer(Z.FRAMEBUFFER, it);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(W, ve, ye, Ce, xe, Ie, Re) {
      if (!(W && W.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Qe = se.get(W).__webglFramebuffer;
      if (W.isWebGLCubeRenderTarget && Re !== void 0 && (Qe = Qe[Re]), Qe) {
        const it = W.texture, mt = it.format, gt = it.type;
        if (!J.textureFormatReadable(mt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
        if (!J.textureTypeReadable(gt))
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
        if (ve >= 0 && ve <= W.width - Ce && ye >= 0 && ye <= W.height - xe) {
          B.bindFramebuffer(Z.FRAMEBUFFER, Qe);
          const ot = Z.createBuffer();
          Z.bindBuffer(Z.PIXEL_PACK_BUFFER, ot), Z.bufferData(Z.PIXEL_PACK_BUFFER, Ie.byteLength, Z.STREAM_READ), Z.readPixels(ve, ye, Ce, xe, Je.convert(mt), Je.convert(gt), 0);
          const Dt = T !== null ? se.get(T).__webglFramebuffer : null;
          B.bindFramebuffer(Z.FRAMEBUFFER, Dt);
          const Vt = Z.fenceSync(Z.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return Z.flush(), await ub(Z, Vt, 4), Z.bindBuffer(Z.PIXEL_PACK_BUFFER, ot), Z.getBufferSubData(Z.PIXEL_PACK_BUFFER, 0, Ie), Z.deleteBuffer(ot), Z.deleteSync(Vt), Ie;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
      }
    }, this.copyFramebufferToTexture = function(W, ve = null, ye = 0) {
      W.isTexture !== !0 && (wa("WebGLRenderer: copyFramebufferToTexture function signature has changed."), ve = arguments[0] || null, W = arguments[1]);
      const Ce = Math.pow(2, -ye), xe = Math.floor(W.image.width * Ce), Ie = Math.floor(W.image.height * Ce), Re = ve !== null ? ve.x : 0, Qe = ve !== null ? ve.y : 0;
      U.setTexture2D(W, 0), Z.copyTexSubImage2D(Z.TEXTURE_2D, ye, 0, 0, Re, Qe, xe, Ie), B.unbindTexture();
    }, this.copyTextureToTexture = function(W, ve, ye = null, Ce = null, xe = 0) {
      W.isTexture !== !0 && (wa("WebGLRenderer: copyTextureToTexture function signature has changed."), Ce = arguments[0] || null, W = arguments[1], ve = arguments[2], xe = arguments[3] || 0, ye = null);
      let Ie, Re, Qe, it, mt, gt, ot, Dt, Vt;
      const Gt = W.isCompressedTexture ? W.mipmaps[xe] : W.image;
      ye !== null ? (Ie = ye.max.x - ye.min.x, Re = ye.max.y - ye.min.y, Qe = ye.isBox3 ? ye.max.z - ye.min.z : 1, it = ye.min.x, mt = ye.min.y, gt = ye.isBox3 ? ye.min.z : 0) : (Ie = Gt.width, Re = Gt.height, Qe = Gt.depth || 1, it = 0, mt = 0, gt = 0), Ce !== null ? (ot = Ce.x, Dt = Ce.y, Vt = Ce.z) : (ot = 0, Dt = 0, Vt = 0);
      const An = Je.convert(ve.format), It = Je.convert(ve.type);
      let dt;
      ve.isData3DTexture ? (U.setTexture3D(ve, 0), dt = Z.TEXTURE_3D) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? (U.setTexture2DArray(ve, 0), dt = Z.TEXTURE_2D_ARRAY) : (U.setTexture2D(ve, 0), dt = Z.TEXTURE_2D), Z.pixelStorei(Z.UNPACK_FLIP_Y_WEBGL, ve.flipY), Z.pixelStorei(Z.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha), Z.pixelStorei(Z.UNPACK_ALIGNMENT, ve.unpackAlignment);
      const pi = Z.getParameter(Z.UNPACK_ROW_LENGTH), Lt = Z.getParameter(Z.UNPACK_IMAGE_HEIGHT), Pn = Z.getParameter(Z.UNPACK_SKIP_PIXELS), Xi = Z.getParameter(Z.UNPACK_SKIP_ROWS), wn = Z.getParameter(Z.UNPACK_SKIP_IMAGES);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, Gt.width), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Gt.height), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, it), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, mt), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, gt);
      const rs = W.isDataArrayTexture || W.isData3DTexture, Yt = ve.isDataArrayTexture || ve.isData3DTexture;
      if (W.isRenderTargetTexture || W.isDepthTexture) {
        const ii = se.get(W), zn = se.get(ve), si = se.get(ii.__renderTarget), mi = se.get(zn.__renderTarget);
        B.bindFramebuffer(Z.READ_FRAMEBUFFER, si.__webglFramebuffer), B.bindFramebuffer(Z.DRAW_FRAMEBUFFER, mi.__webglFramebuffer);
        for (let ri = 0; ri < Qe; ri++)
          rs && Z.framebufferTextureLayer(Z.READ_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, se.get(W).__webglTexture, xe, gt + ri), W.isDepthTexture ? (Yt && Z.framebufferTextureLayer(Z.DRAW_FRAMEBUFFER, Z.COLOR_ATTACHMENT0, se.get(ve).__webglTexture, xe, Vt + ri), Z.blitFramebuffer(it, mt, Ie, Re, ot, Dt, Ie, Re, Z.DEPTH_BUFFER_BIT, Z.NEAREST)) : Yt ? Z.copyTexSubImage3D(dt, xe, ot, Dt, Vt + ri, it, mt, Ie, Re) : Z.copyTexSubImage2D(dt, xe, ot, Dt, Vt + ri, it, mt, Ie, Re);
        B.bindFramebuffer(Z.READ_FRAMEBUFFER, null), B.bindFramebuffer(Z.DRAW_FRAMEBUFFER, null);
      } else
        Yt ? W.isDataTexture || W.isData3DTexture ? Z.texSubImage3D(dt, xe, ot, Dt, Vt, Ie, Re, Qe, An, It, Gt.data) : ve.isCompressedArrayTexture ? Z.compressedTexSubImage3D(dt, xe, ot, Dt, Vt, Ie, Re, Qe, An, Gt.data) : Z.texSubImage3D(dt, xe, ot, Dt, Vt, Ie, Re, Qe, An, It, Gt) : W.isDataTexture ? Z.texSubImage2D(Z.TEXTURE_2D, xe, ot, Dt, Ie, Re, An, It, Gt.data) : W.isCompressedTexture ? Z.compressedTexSubImage2D(Z.TEXTURE_2D, xe, ot, Dt, Gt.width, Gt.height, An, Gt.data) : Z.texSubImage2D(Z.TEXTURE_2D, xe, ot, Dt, Ie, Re, An, It, Gt);
      Z.pixelStorei(Z.UNPACK_ROW_LENGTH, pi), Z.pixelStorei(Z.UNPACK_IMAGE_HEIGHT, Lt), Z.pixelStorei(Z.UNPACK_SKIP_PIXELS, Pn), Z.pixelStorei(Z.UNPACK_SKIP_ROWS, Xi), Z.pixelStorei(Z.UNPACK_SKIP_IMAGES, wn), xe === 0 && ve.generateMipmaps && Z.generateMipmap(dt), B.unbindTexture();
    }, this.copyTextureToTexture3D = function(W, ve, ye = null, Ce = null, xe = 0) {
      return W.isTexture !== !0 && (wa("WebGLRenderer: copyTextureToTexture3D function signature has changed."), ye = arguments[0] || null, Ce = arguments[1] || null, W = arguments[2], ve = arguments[3], xe = arguments[4] || 0), wa('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(W, ve, ye, Ce, xe);
    }, this.initRenderTarget = function(W) {
      se.get(W).__webglFramebuffer === void 0 && U.setupRenderTarget(W);
    }, this.initTexture = function(W) {
      W.isCubeTexture ? U.setTextureCube(W, 0) : W.isData3DTexture ? U.setTexture3D(W, 0) : W.isDataArrayTexture || W.isCompressedArrayTexture ? U.setTexture2DArray(W, 0) : U.setTexture2D(W, 0), B.unbindTexture();
    }, this.resetState = function() {
      E = 0, P = 0, T = null, B.reset(), _t.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return bs;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    n.drawingBufferColorspace = kt._getDrawingBufferColorSpace(e), n.unpackColorSpace = kt._getUnpackColorSpace();
  }
}
class _E extends ln {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new wi(), this.environmentIntensity = 1, this.environmentRotation = new wi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (n.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (n.object.backgroundIntensity = this.backgroundIntensity), n.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (n.object.environmentIntensity = this.environmentIntensity), n.object.environmentRotation = this.environmentRotation.toArray(), n;
  }
}
class Oa extends yn {
  constructor(e = null, n = 1, i = 1, r, o, a, l, c, u = Ln, d = Ln, h, m) {
    super(null, a, l, c, u, d, r, o, h, m), this.isDataTexture = !0, this.image = { data: e, width: n, height: i }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class Sr extends bi {
  constructor(e, n, i, r = 1) {
    super(e, n, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class Wi extends Gr {
  static get type() {
    return "LineBasicMaterial";
  }
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.color = new Mt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const Wc = /* @__PURE__ */ new ce(), $c = /* @__PURE__ */ new ce(), Om = /* @__PURE__ */ new Zt(), ca = /* @__PURE__ */ new wf(), Kl = /* @__PURE__ */ new pl(), yd = /* @__PURE__ */ new ce(), zm = /* @__PURE__ */ new ce();
class an extends ln {
  constructor(e = new Nt(), n = new Wi()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [0];
      for (let r = 1, o = n.count; r < o; r++)
        Wc.fromBufferAttribute(n, r - 1), $c.fromBufferAttribute(n, r), i[r] = i[r - 1], i[r] += Wc.distanceTo($c);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, n) {
    const i = this.geometry, r = this.matrixWorld, o = e.params.Line.threshold, a = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Kl.copy(i.boundingSphere), Kl.applyMatrix4(r), Kl.radius += o, e.ray.intersectsSphere(Kl) === !1) return;
    Om.copy(r).invert(), ca.copy(e.ray).applyMatrix4(Om);
    const l = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, u = this.isLineSegments ? 2 : 1, d = i.index, m = i.attributes.position;
    if (d !== null) {
      const p = Math.max(0, a.start), y = Math.min(d.count, a.start + a.count);
      for (let _ = p, v = y - 1; _ < v; _ += u) {
        const g = d.getX(_), S = d.getX(_ + 1), w = Jl(this, e, ca, c, g, S);
        w && n.push(w);
      }
      if (this.isLineLoop) {
        const _ = d.getX(y - 1), v = d.getX(p), g = Jl(this, e, ca, c, _, v);
        g && n.push(g);
      }
    } else {
      const p = Math.max(0, a.start), y = Math.min(m.count, a.start + a.count);
      for (let _ = p, v = y - 1; _ < v; _ += u) {
        const g = Jl(this, e, ca, c, _, _ + 1);
        g && n.push(g);
      }
      if (this.isLineLoop) {
        const _ = Jl(this, e, ca, c, y - 1, p);
        _ && n.push(_);
      }
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes, i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, a = r.length; o < a; o++) {
          const l = r[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = o;
        }
      }
    }
  }
}
function Jl(s, e, n, i, r, o) {
  const a = s.geometry.attributes.position;
  if (Wc.fromBufferAttribute(a, r), $c.fromBufferAttribute(a, o), n.distanceSqToSegment(Wc, $c, yd, zm) > i) return;
  yd.applyMatrix4(s.matrixWorld);
  const c = e.ray.origin.distanceTo(yd);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: zm.clone().applyMatrix4(s.matrixWorld),
      index: r,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: s
    };
}
const Nm = /* @__PURE__ */ new ce(), Bm = /* @__PURE__ */ new ce();
class Af extends an {
  constructor(e, n) {
    super(e, n), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const n = e.attributes.position, i = [];
      for (let r = 0, o = n.count; r < o; r += 2)
        Nm.fromBufferAttribute(n, r), Bm.fromBufferAttribute(n, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + Nm.distanceTo(Bm);
      e.setAttribute("lineDistance", new Pt(i, 1));
    } else
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class xE extends an {
  constructor(e, n) {
    super(e, n), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class bE extends yn {
  constructor(e, n, i, r, o, a, l, c, u) {
    super(e, n, i, r, o, a, l, c, u), this.isVideoTexture = !0, this.minFilter = a !== void 0 ? a : Xt, this.magFilter = o !== void 0 ? o : Xt, this.generateMipmaps = !1;
    const d = this;
    function h() {
      d.needsUpdate = !0, e.requestVideoFrameCallback(h);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(h);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
}
class Vm extends yn {
  constructor(e, n, i, r, o, a, l, c, u) {
    super(e, n, i, r, o, a, l, c, u), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class ss {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, n);
  }
  // Get sequence of points using getPoint( t )
  getPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return n;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(e = 5) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPointAt(i / e));
    return n;
  }
  // Get total curve arc length
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const n = [];
    let i, r = this.getPoint(0), o = 0;
    n.push(0);
    for (let a = 1; a <= e; a++)
      i = this.getPoint(a / e), o += i.distanceTo(r), n.push(o), r = i;
    return this.cacheArcLengths = n, n;
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(e, n) {
    const i = this.getLengths();
    let r = 0;
    const o = i.length;
    let a;
    n ? a = n : a = e * i[o - 1];
    let l = 0, c = o - 1, u;
    for (; l <= c; )
      if (r = Math.floor(l + (c - l) / 2), u = i[r] - a, u < 0)
        l = r + 1;
      else if (u > 0)
        c = r - 1;
      else {
        c = r;
        break;
      }
    if (r = c, i[r] === a)
      return r / (o - 1);
    const d = i[r], m = i[r + 1] - d, p = (a - d) / m;
    return (r + p) / (o - 1);
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(e, n) {
    let r = e - 1e-4, o = e + 1e-4;
    r < 0 && (r = 0), o > 1 && (o = 1);
    const a = this.getPoint(r), l = this.getPoint(o), c = n || (a.isVector2 ? new st() : new ce());
    return c.copy(l).sub(a).normalize(), c;
  }
  getTangentAt(e, n) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, n);
  }
  computeFrenetFrames(e, n) {
    const i = new ce(), r = [], o = [], a = [], l = new ce(), c = new Zt();
    for (let p = 0; p <= e; p++) {
      const y = p / e;
      r[p] = this.getTangentAt(y, new ce());
    }
    o[0] = new ce(), a[0] = new ce();
    let u = Number.MAX_VALUE;
    const d = Math.abs(r[0].x), h = Math.abs(r[0].y), m = Math.abs(r[0].z);
    d <= u && (u = d, i.set(1, 0, 0)), h <= u && (u = h, i.set(0, 1, 0)), m <= u && i.set(0, 0, 1), l.crossVectors(r[0], i).normalize(), o[0].crossVectors(r[0], l), a[0].crossVectors(r[0], o[0]);
    for (let p = 1; p <= e; p++) {
      if (o[p] = o[p - 1].clone(), a[p] = a[p - 1].clone(), l.crossVectors(r[p - 1], r[p]), l.length() > Number.EPSILON) {
        l.normalize();
        const y = Math.acos(In(r[p - 1].dot(r[p]), -1, 1));
        o[p].applyMatrix4(c.makeRotationAxis(l, y));
      }
      a[p].crossVectors(r[p], o[p]);
    }
    if (n === !0) {
      let p = Math.acos(In(o[0].dot(o[e]), -1, 1));
      p /= e, r[0].dot(l.crossVectors(o[0], o[e])) > 0 && (p = -p);
      for (let y = 1; y <= e; y++)
        o[y].applyMatrix4(c.makeRotationAxis(r[y], p * y)), a[y].crossVectors(r[y], o[y]);
    }
    return {
      tangents: r,
      normals: o,
      binormals: a
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Pf extends ss {
  constructor(e = 0, n = 0, i = 1, r = 1, o = 0, a = Math.PI * 2, l = !1, c = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = n, this.xRadius = i, this.yRadius = r, this.aStartAngle = o, this.aEndAngle = a, this.aClockwise = l, this.aRotation = c;
  }
  getPoint(e, n = new st()) {
    const i = n, r = Math.PI * 2;
    let o = this.aEndAngle - this.aStartAngle;
    const a = Math.abs(o) < Number.EPSILON;
    for (; o < 0; ) o += r;
    for (; o > r; ) o -= r;
    o < Number.EPSILON && (a ? o = 0 : o = r), this.aClockwise === !0 && !a && (o === r ? o = -r : o = o - r);
    const l = this.aStartAngle + e * o;
    let c = this.aX + this.xRadius * Math.cos(l), u = this.aY + this.yRadius * Math.sin(l);
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation), h = Math.sin(this.aRotation), m = c - this.aX, p = u - this.aY;
      c = m * d - p * h + this.aX, u = m * h + p * d + this.aY;
    }
    return i.set(c, u);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class wE extends Pf {
  constructor(e, n, i, r, o, a) {
    super(e, n, i, i, r, o, a), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function Df() {
  let s = 0, e = 0, n = 0, i = 0;
  function r(o, a, l, c) {
    s = o, e = l, n = -3 * o + 3 * a - 2 * l - c, i = 2 * o - 2 * a + l + c;
  }
  return {
    initCatmullRom: function(o, a, l, c, u) {
      r(a, l, u * (l - o), u * (c - a));
    },
    initNonuniformCatmullRom: function(o, a, l, c, u, d, h) {
      let m = (a - o) / u - (l - o) / (u + d) + (l - a) / d, p = (l - a) / d - (c - a) / (d + h) + (c - l) / h;
      m *= d, p *= d, r(a, l, m, p);
    },
    calc: function(o) {
      const a = o * o, l = a * o;
      return s + e * o + n * a + i * l;
    }
  };
}
const Ql = /* @__PURE__ */ new ce(), _d = /* @__PURE__ */ new Df(), xd = /* @__PURE__ */ new Df(), bd = /* @__PURE__ */ new Df();
class SE extends ss {
  constructor(e = [], n = !1, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = n, this.curveType = i, this.tension = r;
  }
  getPoint(e, n = new ce()) {
    const i = n, r = this.points, o = r.length, a = (o - (this.closed ? 0 : 1)) * e;
    let l = Math.floor(a), c = a - l;
    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o : c === 0 && l === o - 1 && (l = o - 2, c = 1);
    let u, d;
    this.closed || l > 0 ? u = r[(l - 1) % o] : (Ql.subVectors(r[0], r[1]).add(r[0]), u = Ql);
    const h = r[l % o], m = r[(l + 1) % o];
    if (this.closed || l + 2 < o ? d = r[(l + 2) % o] : (Ql.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), d = Ql), this.curveType === "centripetal" || this.curveType === "chordal") {
      const p = this.curveType === "chordal" ? 0.5 : 0.25;
      let y = Math.pow(u.distanceToSquared(h), p), _ = Math.pow(h.distanceToSquared(m), p), v = Math.pow(m.distanceToSquared(d), p);
      _ < 1e-4 && (_ = 1), y < 1e-4 && (y = _), v < 1e-4 && (v = _), _d.initNonuniformCatmullRom(u.x, h.x, m.x, d.x, y, _, v), xd.initNonuniformCatmullRom(u.y, h.y, m.y, d.y, y, _, v), bd.initNonuniformCatmullRom(u.z, h.z, m.z, d.z, y, _, v);
    } else this.curveType === "catmullrom" && (_d.initCatmullRom(u.x, h.x, m.x, d.x, this.tension), xd.initCatmullRom(u.y, h.y, m.y, d.y, this.tension), bd.initCatmullRom(u.z, h.z, m.z, d.z, this.tension));
    return i.set(
      _d.calc(c),
      xd.calc(c),
      bd.calc(c)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(new ce().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function Gm(s, e, n, i, r) {
  const o = (i - e) * 0.5, a = (r - n) * 0.5, l = s * s, c = s * l;
  return (2 * n - 2 * i + o + a) * c + (-3 * n + 3 * i - 2 * o - a) * l + o * s + n;
}
function ME(s, e) {
  const n = 1 - s;
  return n * n * e;
}
function CE(s, e) {
  return 2 * (1 - s) * s * e;
}
function EE(s, e) {
  return s * s * e;
}
function za(s, e, n, i) {
  return ME(s, e) + CE(s, n) + EE(s, i);
}
function TE(s, e) {
  const n = 1 - s;
  return n * n * n * e;
}
function AE(s, e) {
  const n = 1 - s;
  return 3 * n * n * s * e;
}
function PE(s, e) {
  return 3 * (1 - s) * s * s * e;
}
function DE(s, e) {
  return s * s * s * e;
}
function Na(s, e, n, i, r) {
  return TE(s, e) + AE(s, n) + PE(s, i) + DE(s, r);
}
class Q0 extends ss {
  constructor(e = new st(), n = new st(), i = new st(), r = new st()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = r;
  }
  getPoint(e, n = new st()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      Na(e, r.x, o.x, a.x, l.x),
      Na(e, r.y, o.y, a.y, l.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class il extends ss {
  constructor(e = new ce(), n = new ce(), i = new ce(), r = new ce()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i, this.v3 = r;
  }
  getPoint(e, n = new ce()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2, l = this.v3;
    return i.set(
      Na(e, r.x, o.x, a.x, l.x),
      Na(e, r.y, o.y, a.y, l.y),
      Na(e, r.z, o.z, a.z, l.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class ey extends ss {
  constructor(e = new st(), n = new st()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new st()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new st()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class RE extends ss {
  constructor(e = new ce(), n = new ce()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = n;
  }
  getPoint(e, n = new ce()) {
    const i = n;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, n) {
    return this.getPoint(e, n);
  }
  getTangent(e, n = new ce()) {
    return n.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, n) {
    return this.getTangent(e, n);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class ty extends ss {
  constructor(e = new st(), n = new st(), i = new st()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new st()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2;
    return i.set(
      za(e, r.x, o.x, a.x),
      za(e, r.y, o.y, a.y)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class IE extends ss {
  constructor(e = new ce(), n = new ce(), i = new ce()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = n, this.v2 = i;
  }
  getPoint(e, n = new ce()) {
    const i = n, r = this.v0, o = this.v1, a = this.v2;
    return i.set(
      za(e, r.x, o.x, a.x),
      za(e, r.y, o.y, a.y),
      za(e, r.z, o.z, a.z)
    ), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class ny extends ss {
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, n = new st()) {
    const i = n, r = this.points, o = (r.length - 1) * e, a = Math.floor(o), l = o - a, c = r[a === 0 ? a : a - 1], u = r[a], d = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2];
    return i.set(
      Gm(l, c.x, u.x, d.x, h.x),
      Gm(l, c.y, u.y, d.y, h.y)
    ), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let n = 0, i = this.points.length; n < i; n++) {
      const r = this.points[n];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let n = 0, i = e.points.length; n < i; n++) {
      const r = e.points[n];
      this.points.push(new st().fromArray(r));
    }
    return this;
  }
}
var Hm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: wE,
  CatmullRomCurve3: SE,
  CubicBezierCurve: Q0,
  CubicBezierCurve3: il,
  EllipseCurve: Pf,
  LineCurve: ey,
  LineCurve3: RE,
  QuadraticBezierCurve: ty,
  QuadraticBezierCurve3: IE,
  SplineCurve: ny
});
class Rf extends ss {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), n = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(n)) {
      const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new Hm[i](n, e));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(e, n) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let o = 0;
    for (; o < r.length; ) {
      if (r[o] >= i) {
        const a = r[o] - i, l = this.curves[o], c = l.getLength(), u = c === 0 ? 0 : 1 - a / c;
        return l.getPointAt(u, n);
      }
      o++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let n = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      n += this.curves[i].getLength(), e.push(n);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const n = [];
    for (let i = 0; i <= e; i++)
      n.push(this.getPoint(i / e));
    return this.autoClose && n.push(n[0]), n;
  }
  getPoints(e = 12) {
    const n = [];
    let i;
    for (let r = 0, o = this.curves; r < o.length; r++) {
      const a = o[r], l = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, c = a.getPoints(l);
      for (let u = 0; u < c.length; u++) {
        const d = c[u];
        i && i.equals(d) || (n.push(d), i = d);
      }
    }
    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const r = e.curves[n];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let n = 0, i = this.curves.length; n < i; n++) {
      const r = this.curves[n];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let n = 0, i = e.curves.length; n < i; n++) {
      const r = e.curves[n];
      this.curves.push(new Hm[r.type]().fromJSON(r));
    }
    return this;
  }
}
class Wm extends Rf {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new st(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let n = 1, i = e.length; n < i; n++)
      this.lineTo(e[n].x, e[n].y);
    return this;
  }
  moveTo(e, n) {
    return this.currentPoint.set(e, n), this;
  }
  lineTo(e, n) {
    const i = new ey(this.currentPoint.clone(), new st(e, n));
    return this.curves.push(i), this.currentPoint.set(e, n), this;
  }
  quadraticCurveTo(e, n, i, r) {
    const o = new ty(
      this.currentPoint.clone(),
      new st(e, n),
      new st(i, r)
    );
    return this.curves.push(o), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, n, i, r, o, a) {
    const l = new Q0(
      this.currentPoint.clone(),
      new st(e, n),
      new st(i, r),
      new st(o, a)
    );
    return this.curves.push(l), this.currentPoint.set(o, a), this;
  }
  splineThru(e) {
    const n = [this.currentPoint.clone()].concat(e), i = new ny(n);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, n, i, r, o, a) {
    const l = this.currentPoint.x, c = this.currentPoint.y;
    return this.absarc(
      e + l,
      n + c,
      i,
      r,
      o,
      a
    ), this;
  }
  absarc(e, n, i, r, o, a) {
    return this.absellipse(e, n, i, i, r, o, a), this;
  }
  ellipse(e, n, i, r, o, a, l, c) {
    const u = this.currentPoint.x, d = this.currentPoint.y;
    return this.absellipse(e + u, n + d, i, r, o, a, l, c), this;
  }
  absellipse(e, n, i, r, o, a, l, c) {
    const u = new Pf(e, n, i, r, o, a, l, c);
    if (this.curves.length > 0) {
      const h = u.getPoint(0);
      h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
    }
    this.curves.push(u);
    const d = u.getPoint(1);
    return this.currentPoint.copy(d), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class gu extends Nt {
  constructor(e = 1, n = 32, i = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: n,
      thetaStart: i,
      thetaLength: r
    }, n = Math.max(3, n);
    const o = [], a = [], l = [], c = [], u = new ce(), d = new st();
    a.push(0, 0, 0), l.push(0, 0, 1), c.push(0.5, 0.5);
    for (let h = 0, m = 3; h <= n; h++, m += 3) {
      const p = i + h / n * r;
      u.x = e * Math.cos(p), u.y = e * Math.sin(p), a.push(u.x, u.y, u.z), l.push(0, 0, 1), d.x = (a[m] / e + 1) / 2, d.y = (a[m + 1] / e + 1) / 2, c.push(d.x, d.y);
    }
    for (let h = 1; h <= n; h++)
      o.push(h, h + 1, 0);
    this.setIndex(o), this.setAttribute("position", new Pt(a, 3)), this.setAttribute("normal", new Pt(l, 3)), this.setAttribute("uv", new Pt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new gu(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Rn extends Nt {
  constructor(e = 1, n = 1, i = 1, r = 32, o = 1, a = !1, l = 0, c = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: n,
      height: i,
      radialSegments: r,
      heightSegments: o,
      openEnded: a,
      thetaStart: l,
      thetaLength: c
    };
    const u = this;
    r = Math.floor(r), o = Math.floor(o);
    const d = [], h = [], m = [], p = [];
    let y = 0;
    const _ = [], v = i / 2;
    let g = 0;
    S(), a === !1 && (e > 0 && w(!0), n > 0 && w(!1)), this.setIndex(d), this.setAttribute("position", new Pt(h, 3)), this.setAttribute("normal", new Pt(m, 3)), this.setAttribute("uv", new Pt(p, 2));
    function S() {
      const x = new ce(), C = new ce();
      let E = 0;
      const P = (n - e) / i;
      for (let T = 0; T <= o; T++) {
        const b = [], M = T / o, L = M * (n - e) + e;
        for (let N = 0; N <= r; N++) {
          const D = N / r, O = D * c + l, A = Math.sin(O), G = Math.cos(O);
          C.x = L * A, C.y = -M * i + v, C.z = L * G, h.push(C.x, C.y, C.z), x.set(A, P, G).normalize(), m.push(x.x, x.y, x.z), p.push(D, 1 - M), b.push(y++);
        }
        _.push(b);
      }
      for (let T = 0; T < r; T++)
        for (let b = 0; b < o; b++) {
          const M = _[b][T], L = _[b + 1][T], N = _[b + 1][T + 1], D = _[b][T + 1];
          (e > 0 || b !== 0) && (d.push(M, L, D), E += 3), (n > 0 || b !== o - 1) && (d.push(L, N, D), E += 3);
        }
      u.addGroup(g, E, 0), g += E;
    }
    function w(x) {
      const C = y, E = new st(), P = new ce();
      let T = 0;
      const b = x === !0 ? e : n, M = x === !0 ? 1 : -1;
      for (let N = 1; N <= r; N++)
        h.push(0, v * M, 0), m.push(0, M, 0), p.push(0.5, 0.5), y++;
      const L = y;
      for (let N = 0; N <= r; N++) {
        const O = N / r * c + l, A = Math.cos(O), G = Math.sin(O);
        P.x = b * G, P.y = v * M, P.z = b * A, h.push(P.x, P.y, P.z), m.push(0, M, 0), E.x = A * 0.5 + 0.5, E.y = G * 0.5 * M + 0.5, p.push(E.x, E.y), y++;
      }
      for (let N = 0; N < r; N++) {
        const D = C + N, O = L + N;
        x === !0 ? d.push(O, O + 1, D) : d.push(O + 1, O, D), T += 3;
      }
      u.addGroup(g, T, x === !0 ? 1 : 2), g += T;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Rn(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class If extends Rn {
  constructor(e = 1, n = 1, i = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(0, e, n, i, r, o, a, l), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: n,
      radialSegments: i,
      heightSegments: r,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
  }
  static fromJSON(e) {
    return new If(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class kf extends Nt {
  constructor(e = [], n = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: n,
      radius: i,
      detail: r
    };
    const o = [], a = [];
    l(r), u(i), d(), this.setAttribute("position", new Pt(o, 3)), this.setAttribute("normal", new Pt(o.slice(), 3)), this.setAttribute("uv", new Pt(a, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function l(S) {
      const w = new ce(), x = new ce(), C = new ce();
      for (let E = 0; E < n.length; E += 3)
        p(n[E + 0], w), p(n[E + 1], x), p(n[E + 2], C), c(w, x, C, S);
    }
    function c(S, w, x, C) {
      const E = C + 1, P = [];
      for (let T = 0; T <= E; T++) {
        P[T] = [];
        const b = S.clone().lerp(x, T / E), M = w.clone().lerp(x, T / E), L = E - T;
        for (let N = 0; N <= L; N++)
          N === 0 && T === E ? P[T][N] = b : P[T][N] = b.clone().lerp(M, N / L);
      }
      for (let T = 0; T < E; T++)
        for (let b = 0; b < 2 * (E - T) - 1; b++) {
          const M = Math.floor(b / 2);
          b % 2 === 0 ? (m(P[T][M + 1]), m(P[T + 1][M]), m(P[T][M])) : (m(P[T][M + 1]), m(P[T + 1][M + 1]), m(P[T + 1][M]));
        }
    }
    function u(S) {
      const w = new ce();
      for (let x = 0; x < o.length; x += 3)
        w.x = o[x + 0], w.y = o[x + 1], w.z = o[x + 2], w.normalize().multiplyScalar(S), o[x + 0] = w.x, o[x + 1] = w.y, o[x + 2] = w.z;
    }
    function d() {
      const S = new ce();
      for (let w = 0; w < o.length; w += 3) {
        S.x = o[w + 0], S.y = o[w + 1], S.z = o[w + 2];
        const x = v(S) / 2 / Math.PI + 0.5, C = g(S) / Math.PI + 0.5;
        a.push(x, 1 - C);
      }
      y(), h();
    }
    function h() {
      for (let S = 0; S < a.length; S += 6) {
        const w = a[S + 0], x = a[S + 2], C = a[S + 4], E = Math.max(w, x, C), P = Math.min(w, x, C);
        E > 0.9 && P < 0.1 && (w < 0.2 && (a[S + 0] += 1), x < 0.2 && (a[S + 2] += 1), C < 0.2 && (a[S + 4] += 1));
      }
    }
    function m(S) {
      o.push(S.x, S.y, S.z);
    }
    function p(S, w) {
      const x = S * 3;
      w.x = e[x + 0], w.y = e[x + 1], w.z = e[x + 2];
    }
    function y() {
      const S = new ce(), w = new ce(), x = new ce(), C = new ce(), E = new st(), P = new st(), T = new st();
      for (let b = 0, M = 0; b < o.length; b += 9, M += 6) {
        S.set(o[b + 0], o[b + 1], o[b + 2]), w.set(o[b + 3], o[b + 4], o[b + 5]), x.set(o[b + 6], o[b + 7], o[b + 8]), E.set(a[M + 0], a[M + 1]), P.set(a[M + 2], a[M + 3]), T.set(a[M + 4], a[M + 5]), C.copy(S).add(w).add(x).divideScalar(3);
        const L = v(C);
        _(E, M + 0, S, L), _(P, M + 2, w, L), _(T, M + 4, x, L);
      }
    }
    function _(S, w, x, C) {
      C < 0 && S.x === 1 && (a[w] = S.x - 1), x.x === 0 && x.z === 0 && (a[w] = C / 2 / Math.PI + 0.5);
    }
    function v(S) {
      return Math.atan2(S.z, -S.x);
    }
    function g(S) {
      return Math.atan2(-S.y, Math.sqrt(S.x * S.x + S.z * S.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new kf(e.vertices, e.indices, e.radius, e.details);
  }
}
class iy extends Wm {
  constructor(e) {
    super(e), this.uuid = Vr(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const n = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      n[i] = this.holes[i].getPoints(e);
    return n;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const r = e.holes[n];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let n = 0, i = this.holes.length; n < i; n++) {
      const r = this.holes[n];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let n = 0, i = e.holes.length; n < i; n++) {
      const r = e.holes[n];
      this.holes.push(new Wm().fromJSON(r));
    }
    return this;
  }
}
const kE = {
  triangulate: function(s, e, n = 2) {
    const i = e && e.length, r = i ? e[0] * n : s.length;
    let o = sy(s, 0, r, n, !0);
    const a = [];
    if (!o || o.next === o.prev) return a;
    let l, c, u, d, h, m, p;
    if (i && (o = zE(s, e, o, n)), s.length > 80 * n) {
      l = u = s[0], c = d = s[1];
      for (let y = n; y < r; y += n)
        h = s[y], m = s[y + 1], h < l && (l = h), m < c && (c = m), h > u && (u = h), m > d && (d = m);
      p = Math.max(u - l, d - c), p = p !== 0 ? 32767 / p : 0;
    }
    return sl(o, a, n, l, c, p, 0), a;
  }
};
function sy(s, e, n, i, r) {
  let o, a;
  if (r === qE(s, e, n, i) > 0)
    for (o = e; o < n; o += i) a = $m(o, s[o], s[o + 1], a);
  else
    for (o = n - i; o >= e; o -= i) a = $m(o, s[o], s[o + 1], a);
  return a && yu(a, a.next) && (ol(a), a = a.next), a;
}
function Nr(s, e) {
  if (!s) return s;
  e || (e = s);
  let n = s, i;
  do
    if (i = !1, !n.steiner && (yu(n, n.next) || un(n.prev, n, n.next) === 0)) {
      if (ol(n), n = e = n.prev, n === n.next) break;
      i = !0;
    } else
      n = n.next;
  while (i || n !== e);
  return e;
}
function sl(s, e, n, i, r, o, a) {
  if (!s) return;
  !a && o && HE(s, i, r, o);
  let l = s, c, u;
  for (; s.prev !== s.next; ) {
    if (c = s.prev, u = s.next, o ? FE(s, i, r, o) : LE(s)) {
      e.push(c.i / n | 0), e.push(s.i / n | 0), e.push(u.i / n | 0), ol(s), s = u.next, l = u.next;
      continue;
    }
    if (s = u, s === l) {
      a ? a === 1 ? (s = UE(Nr(s), e, n), sl(s, e, n, i, r, o, 2)) : a === 2 && OE(s, e, n, i, r, o) : sl(Nr(s), e, n, i, r, o, 1);
      break;
    }
  }
}
function LE(s) {
  const e = s.prev, n = s, i = s.next;
  if (un(e, n, i) >= 0) return !1;
  const r = e.x, o = n.x, a = i.x, l = e.y, c = n.y, u = i.y, d = r < o ? r < a ? r : a : o < a ? o : a, h = l < c ? l < u ? l : u : c < u ? c : u, m = r > o ? r > a ? r : a : o > a ? o : a, p = l > c ? l > u ? l : u : c > u ? c : u;
  let y = i.next;
  for (; y !== e; ) {
    if (y.x >= d && y.x <= m && y.y >= h && y.y <= p && yo(r, l, o, c, a, u, y.x, y.y) && un(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function FE(s, e, n, i) {
  const r = s.prev, o = s, a = s.next;
  if (un(r, o, a) >= 0) return !1;
  const l = r.x, c = o.x, u = a.x, d = r.y, h = o.y, m = a.y, p = l < c ? l < u ? l : u : c < u ? c : u, y = d < h ? d < m ? d : m : h < m ? h : m, _ = l > c ? l > u ? l : u : c > u ? c : u, v = d > h ? d > m ? d : m : h > m ? h : m, g = zh(p, y, e, n, i), S = zh(_, v, e, n, i);
  let w = s.prevZ, x = s.nextZ;
  for (; w && w.z >= g && x && x.z <= S; ) {
    if (w.x >= p && w.x <= _ && w.y >= y && w.y <= v && w !== r && w !== a && yo(l, d, c, h, u, m, w.x, w.y) && un(w.prev, w, w.next) >= 0 || (w = w.prevZ, x.x >= p && x.x <= _ && x.y >= y && x.y <= v && x !== r && x !== a && yo(l, d, c, h, u, m, x.x, x.y) && un(x.prev, x, x.next) >= 0)) return !1;
    x = x.nextZ;
  }
  for (; w && w.z >= g; ) {
    if (w.x >= p && w.x <= _ && w.y >= y && w.y <= v && w !== r && w !== a && yo(l, d, c, h, u, m, w.x, w.y) && un(w.prev, w, w.next) >= 0) return !1;
    w = w.prevZ;
  }
  for (; x && x.z <= S; ) {
    if (x.x >= p && x.x <= _ && x.y >= y && x.y <= v && x !== r && x !== a && yo(l, d, c, h, u, m, x.x, x.y) && un(x.prev, x, x.next) >= 0) return !1;
    x = x.nextZ;
  }
  return !0;
}
function UE(s, e, n) {
  let i = s;
  do {
    const r = i.prev, o = i.next.next;
    !yu(r, o) && ry(r, i, i.next, o) && rl(r, o) && rl(o, r) && (e.push(r.i / n | 0), e.push(i.i / n | 0), e.push(o.i / n | 0), ol(i), ol(i.next), i = s = o), i = i.next;
  } while (i !== s);
  return Nr(i);
}
function OE(s, e, n, i, r, o) {
  let a = s;
  do {
    let l = a.next.next;
    for (; l !== a.prev; ) {
      if (a.i !== l.i && XE(a, l)) {
        let c = oy(a, l);
        a = Nr(a, a.next), c = Nr(c, c.next), sl(a, e, n, i, r, o, 0), sl(c, e, n, i, r, o, 0);
        return;
      }
      l = l.next;
    }
    a = a.next;
  } while (a !== s);
}
function zE(s, e, n, i) {
  const r = [];
  let o, a, l, c, u;
  for (o = 0, a = e.length; o < a; o++)
    l = e[o] * i, c = o < a - 1 ? e[o + 1] * i : s.length, u = sy(s, l, c, i, !1), u === u.next && (u.steiner = !0), r.push($E(u));
  for (r.sort(NE), o = 0; o < r.length; o++)
    n = BE(r[o], n);
  return n;
}
function NE(s, e) {
  return s.x - e.x;
}
function BE(s, e) {
  const n = VE(s, e);
  if (!n)
    return e;
  const i = oy(n, s);
  return Nr(i, i.next), Nr(n, n.next);
}
function VE(s, e) {
  let n = e, i = -1 / 0, r;
  const o = s.x, a = s.y;
  do {
    if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
      const m = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
      if (m <= o && m > i && (i = m, r = n.x < n.next.x ? n : n.next, m === o))
        return r;
    }
    n = n.next;
  } while (n !== e);
  if (!r) return null;
  const l = r, c = r.x, u = r.y;
  let d = 1 / 0, h;
  n = r;
  do
    o >= n.x && n.x >= c && o !== n.x && yo(a < u ? o : i, a, c, u, a < u ? i : o, a, n.x, n.y) && (h = Math.abs(a - n.y) / (o - n.x), rl(n, s) && (h < d || h === d && (n.x > r.x || n.x === r.x && GE(r, n))) && (r = n, d = h)), n = n.next;
  while (n !== l);
  return r;
}
function GE(s, e) {
  return un(s.prev, s, e.prev) < 0 && un(e.next, s, s.next) < 0;
}
function HE(s, e, n, i) {
  let r = s;
  do
    r.z === 0 && (r.z = zh(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== s);
  r.prevZ.nextZ = null, r.prevZ = null, WE(r);
}
function WE(s) {
  let e, n, i, r, o, a, l, c, u = 1;
  do {
    for (n = s, s = null, o = null, a = 0; n; ) {
      for (a++, i = n, l = 0, e = 0; e < u && (l++, i = i.nextZ, !!i); e++)
        ;
      for (c = u; l > 0 || c > 0 && i; )
        l !== 0 && (c === 0 || !i || n.z <= i.z) ? (r = n, n = n.nextZ, l--) : (r = i, i = i.nextZ, c--), o ? o.nextZ = r : s = r, r.prevZ = o, o = r;
      n = i;
    }
    o.nextZ = null, u *= 2;
  } while (a > 1);
  return s;
}
function zh(s, e, n, i, r) {
  return s = (s - n) * r | 0, e = (e - i) * r | 0, s = (s | s << 8) & 16711935, s = (s | s << 4) & 252645135, s = (s | s << 2) & 858993459, s = (s | s << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, s | e << 1;
}
function $E(s) {
  let e = s, n = s;
  do
    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next;
  while (e !== s);
  return n;
}
function yo(s, e, n, i, r, o, a, l) {
  return (r - a) * (e - l) >= (s - a) * (o - l) && (s - a) * (i - l) >= (n - a) * (e - l) && (n - a) * (o - l) >= (r - a) * (i - l);
}
function XE(s, e) {
  return s.next.i !== e.i && s.prev.i !== e.i && !jE(s, e) && // dones't intersect other edges
  (rl(s, e) && rl(e, s) && YE(s, e) && // locally visible
  (un(s.prev, s, e.prev) || un(s, e.prev, e)) || // does not create opposite-facing sectors
  yu(s, e) && un(s.prev, s, s.next) > 0 && un(e.prev, e, e.next) > 0);
}
function un(s, e, n) {
  return (e.y - s.y) * (n.x - e.x) - (e.x - s.x) * (n.y - e.y);
}
function yu(s, e) {
  return s.x === e.x && s.y === e.y;
}
function ry(s, e, n, i) {
  const r = tc(un(s, e, n)), o = tc(un(s, e, i)), a = tc(un(n, i, s)), l = tc(un(n, i, e));
  return !!(r !== o && a !== l || r === 0 && ec(s, n, e) || o === 0 && ec(s, i, e) || a === 0 && ec(n, s, i) || l === 0 && ec(n, e, i));
}
function ec(s, e, n) {
  return e.x <= Math.max(s.x, n.x) && e.x >= Math.min(s.x, n.x) && e.y <= Math.max(s.y, n.y) && e.y >= Math.min(s.y, n.y);
}
function tc(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0;
}
function jE(s, e) {
  let n = s;
  do {
    if (n.i !== s.i && n.next.i !== s.i && n.i !== e.i && n.next.i !== e.i && ry(n, n.next, s, e)) return !0;
    n = n.next;
  } while (n !== s);
  return !1;
}
function rl(s, e) {
  return un(s.prev, s, s.next) < 0 ? un(s, e, s.next) >= 0 && un(s, s.prev, e) >= 0 : un(s, e, s.prev) < 0 || un(s, s.next, e) < 0;
}
function YE(s, e) {
  let n = s, i = !1;
  const r = (s.x + e.x) / 2, o = (s.y + e.y) / 2;
  do
    n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next;
  while (n !== s);
  return i;
}
function oy(s, e) {
  const n = new Nh(s.i, s.x, s.y), i = new Nh(e.i, e.x, e.y), r = s.next, o = e.prev;
  return s.next = e, e.prev = s, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i;
}
function $m(s, e, n, i) {
  const r = new Nh(s, e, n);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function ol(s) {
  s.next.prev = s.prev, s.prev.next = s.next, s.prevZ && (s.prevZ.nextZ = s.nextZ), s.nextZ && (s.nextZ.prevZ = s.prevZ);
}
function Nh(s, e, n) {
  this.i = s, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
function qE(s, e, n, i) {
  let r = 0;
  for (let o = e, a = n - i; o < n; o += i)
    r += (s[a] - s[o]) * (s[o + 1] + s[a + 1]), a = o;
  return r;
}
class Ba {
  // calculate area of the contour polygon
  static area(e) {
    const n = e.length;
    let i = 0;
    for (let r = n - 1, o = 0; o < n; r = o++)
      i += e[r].x * e[o].y - e[o].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Ba.area(e) < 0;
  }
  static triangulateShape(e, n) {
    const i = [], r = [], o = [];
    Xm(e), jm(i, e);
    let a = e.length;
    n.forEach(Xm);
    for (let c = 0; c < n.length; c++)
      r.push(a), a += n[c].length, jm(i, n[c]);
    const l = kE.triangulate(i, r);
    for (let c = 0; c < l.length; c += 3)
      o.push(l.slice(c, c + 3));
    return o;
  }
}
function Xm(s) {
  const e = s.length;
  e > 2 && s[e - 1].equals(s[0]) && s.pop();
}
function jm(s, e) {
  for (let n = 0; n < e.length; n++)
    s.push(e[n].x), s.push(e[n].y);
}
class _o extends kf {
  constructor(e = 1, n = 0) {
    const i = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(i, r, e, n), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: n
    };
  }
  static fromJSON(e) {
    return new _o(e.radius, e.detail);
  }
}
class Lf extends Nt {
  constructor(e = new iy([new st(0, 0.5), new st(-0.5, -0.5), new st(0.5, -0.5)]), n = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: n
    };
    const i = [], r = [], o = [], a = [];
    let l = 0, c = 0;
    if (Array.isArray(e) === !1)
      u(e);
    else
      for (let d = 0; d < e.length; d++)
        u(e[d]), this.addGroup(l, c, d), l += c, c = 0;
    this.setIndex(i), this.setAttribute("position", new Pt(r, 3)), this.setAttribute("normal", new Pt(o, 3)), this.setAttribute("uv", new Pt(a, 2));
    function u(d) {
      const h = r.length / 3, m = d.extractPoints(n);
      let p = m.shape;
      const y = m.holes;
      Ba.isClockWise(p) === !1 && (p = p.reverse());
      for (let v = 0, g = y.length; v < g; v++) {
        const S = y[v];
        Ba.isClockWise(S) === !0 && (y[v] = S.reverse());
      }
      const _ = Ba.triangulateShape(p, y);
      for (let v = 0, g = y.length; v < g; v++) {
        const S = y[v];
        p = p.concat(S);
      }
      for (let v = 0, g = p.length; v < g; v++) {
        const S = p[v];
        r.push(S.x, S.y, 0), o.push(0, 0, 1), a.push(S.x, S.y);
      }
      for (let v = 0, g = _.length; v < g; v++) {
        const S = _[v], w = S[0] + h, x = S[1] + h, C = S[2] + h;
        i.push(w, x, C), c += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), n = this.parameters.shapes;
    return ZE(n, e);
  }
  static fromJSON(e, n) {
    const i = [];
    for (let r = 0, o = e.shapes.length; r < o; r++) {
      const a = n[e.shapes[r]];
      i.push(a);
    }
    return new Lf(i, e.curveSegments);
  }
}
function ZE(s, e) {
  if (e.shapes = [], Array.isArray(s))
    for (let n = 0, i = s.length; n < i; n++) {
      const r = s[n];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(s.uuid);
  return e;
}
class _u extends Nt {
  constructor(e = 1, n = 32, i = 16, r = 0, o = Math.PI * 2, a = 0, l = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: n,
      heightSegments: i,
      phiStart: r,
      phiLength: o,
      thetaStart: a,
      thetaLength: l
    }, n = Math.max(3, Math.floor(n)), i = Math.max(2, Math.floor(i));
    const c = Math.min(a + l, Math.PI);
    let u = 0;
    const d = [], h = new ce(), m = new ce(), p = [], y = [], _ = [], v = [];
    for (let g = 0; g <= i; g++) {
      const S = [], w = g / i;
      let x = 0;
      g === 0 && a === 0 ? x = 0.5 / n : g === i && c === Math.PI && (x = -0.5 / n);
      for (let C = 0; C <= n; C++) {
        const E = C / n;
        h.x = -e * Math.cos(r + E * o) * Math.sin(a + w * l), h.y = e * Math.cos(a + w * l), h.z = e * Math.sin(r + E * o) * Math.sin(a + w * l), y.push(h.x, h.y, h.z), m.copy(h).normalize(), _.push(m.x, m.y, m.z), v.push(E + x, 1 - w), S.push(u++);
      }
      d.push(S);
    }
    for (let g = 0; g < i; g++)
      for (let S = 0; S < n; S++) {
        const w = d[g][S + 1], x = d[g][S], C = d[g + 1][S], E = d[g + 1][S + 1];
        (g !== 0 || a > 0) && p.push(w, x, E), (g !== i - 1 || c < Math.PI) && p.push(x, C, E);
      }
    this.setIndex(p), this.setAttribute("position", new Pt(y, 3)), this.setAttribute("normal", new Pt(_, 3)), this.setAttribute("uv", new Pt(v, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new _u(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Tr extends Nt {
  constructor(e = 1, n = 0.4, i = 12, r = 48, o = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: n,
      radialSegments: i,
      tubularSegments: r,
      arc: o
    }, i = Math.floor(i), r = Math.floor(r);
    const a = [], l = [], c = [], u = [], d = new ce(), h = new ce(), m = new ce();
    for (let p = 0; p <= i; p++)
      for (let y = 0; y <= r; y++) {
        const _ = y / r * o, v = p / i * Math.PI * 2;
        h.x = (e + n * Math.cos(v)) * Math.cos(_), h.y = (e + n * Math.cos(v)) * Math.sin(_), h.z = n * Math.sin(v), l.push(h.x, h.y, h.z), d.x = e * Math.cos(_), d.y = e * Math.sin(_), m.subVectors(h, d).normalize(), c.push(m.x, m.y, m.z), u.push(y / r), u.push(p / i);
      }
    for (let p = 1; p <= i; p++)
      for (let y = 1; y <= r; y++) {
        const _ = (r + 1) * p + y - 1, v = (r + 1) * (p - 1) + y - 1, g = (r + 1) * (p - 1) + y, S = (r + 1) * p + y;
        a.push(_, v, S), a.push(v, g, S);
      }
    this.setIndex(a), this.setAttribute("position", new Pt(l, 3)), this.setAttribute("normal", new Pt(c, 3)), this.setAttribute("uv", new Pt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Tr(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class KE extends Fn {
  static get type() {
    return "RawShaderMaterial";
  }
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0;
  }
}
class JE extends Gr {
  static get type() {
    return "MeshStandardMaterial";
  }
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.defines = { STANDARD: "" }, this.color = new Mt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Mt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xf, this.normalScale = new st(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new wi(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class QE extends Gr {
  static get type() {
    return "MeshNormalMaterial";
  }
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xf, this.normalScale = new st(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
const Ym = {
  enabled: !1,
  files: {},
  add: function(s, e) {
    this.enabled !== !1 && (this.files[s] = e);
  },
  get: function(s) {
    if (this.enabled !== !1)
      return this.files[s];
  },
  remove: function(s) {
    delete this.files[s];
  },
  clear: function() {
    this.files = {};
  }
};
class e2 {
  constructor(e, n, i) {
    const r = this;
    let o = !1, a = 0, l = 0, c;
    const u = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = n, this.onError = i, this.itemStart = function(d) {
      l++, o === !1 && r.onStart !== void 0 && r.onStart(d, a, l), o = !0;
    }, this.itemEnd = function(d) {
      a++, r.onProgress !== void 0 && r.onProgress(d, a, l), a === l && (o = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(d) {
      r.onError !== void 0 && r.onError(d);
    }, this.resolveURL = function(d) {
      return c ? c(d) : d;
    }, this.setURLModifier = function(d) {
      return c = d, this;
    }, this.addHandler = function(d, h) {
      return u.push(d, h), this;
    }, this.removeHandler = function(d) {
      const h = u.indexOf(d);
      return h !== -1 && u.splice(h, 2), this;
    }, this.getHandler = function(d) {
      for (let h = 0, m = u.length; h < m; h += 2) {
        const p = u[h], y = u[h + 1];
        if (p.global && (p.lastIndex = 0), p.test(d))
          return y;
      }
      return null;
    };
  }
}
const t2 = /* @__PURE__ */ new e2();
class Ff {
  constructor(e) {
    this.manager = e !== void 0 ? e : t2, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, n) {
    const i = this;
    return new Promise(function(r, o) {
      i.load(e, r, n, o);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Ff.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class n2 extends Ff {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const o = this, a = Ym.get(e);
    if (a !== void 0)
      return o.manager.itemStart(e), setTimeout(function() {
        n && n(a), o.manager.itemEnd(e);
      }, 0), a;
    const l = nl("img");
    function c() {
      d(), Ym.add(e, this), n && n(this), o.manager.itemEnd(e);
    }
    function u(h) {
      d(), r && r(h), o.manager.itemError(e), o.manager.itemEnd(e);
    }
    function d() {
      l.removeEventListener("load", c, !1), l.removeEventListener("error", u, !1);
    }
    return l.addEventListener("load", c, !1), l.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), o.manager.itemStart(e), l.src = e, l;
  }
}
class i2 extends Ff {
  constructor(e) {
    super(e);
  }
  load(e, n, i, r) {
    const o = new yn(), a = new n2(this.manager);
    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(l) {
      o.image = l, o.needsUpdate = !0, n !== void 0 && n(o);
    }, i, r), o;
  }
}
class xu extends ln {
  constructor(e, n = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new Mt(e), this.intensity = n;
  }
  dispose() {
  }
  copy(e, n) {
    return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (n.object.target = this.target.uuid), n;
  }
}
const wd = /* @__PURE__ */ new Zt(), qm = /* @__PURE__ */ new ce(), Zm = /* @__PURE__ */ new ce();
class Uf {
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new st(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Mf(), this._frameExtents = new st(1, 1), this._viewportCount = 1, this._viewports = [
      new jt(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera, i = this.matrix;
    qm.setFromMatrixPosition(e.matrixWorld), n.position.copy(qm), Zm.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(Zm), n.updateMatrixWorld(), wd.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(wd), i.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), i.multiply(wd);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class s2 extends Uf {
  constructor() {
    super(new ci(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1;
  }
  updateMatrices(e) {
    const n = this.camera, i = Oo * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, o = e.distance || n.far;
    (i !== n.fov || r !== n.aspect || o !== n.far) && (n.fov = i, n.aspect = r, n.far = o, n.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class Vs extends xu {
  constructor(e, n, i = 0, r = Math.PI / 3, o = 0, a = 2) {
    super(e, n), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ln.DEFAULT_UP), this.updateMatrix(), this.target = new ln(), this.distance = i, this.angle = r, this.penumbra = o, this.decay = a, this.map = null, this.shadow = new s2();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const Km = /* @__PURE__ */ new Zt(), ua = /* @__PURE__ */ new ce(), Sd = /* @__PURE__ */ new ce();
class r2 extends Uf {
  constructor() {
    super(new ci(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new st(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new jt(2, 1, 1, 1),
      // negative X
      new jt(0, 1, 1, 1),
      // positive Z
      new jt(3, 1, 1, 1),
      // negative Z
      new jt(1, 1, 1, 1),
      // positive Y
      new jt(3, 0, 1, 1),
      // negative Y
      new jt(1, 0, 1, 1)
    ], this._cubeDirections = [
      new ce(1, 0, 0),
      new ce(-1, 0, 0),
      new ce(0, 0, 1),
      new ce(0, 0, -1),
      new ce(0, 1, 0),
      new ce(0, -1, 0)
    ], this._cubeUps = [
      new ce(0, 1, 0),
      new ce(0, 1, 0),
      new ce(0, 1, 0),
      new ce(0, 1, 0),
      new ce(0, 0, 1),
      new ce(0, 0, -1)
    ];
  }
  updateMatrices(e, n = 0) {
    const i = this.camera, r = this.matrix, o = e.distance || i.far;
    o !== i.far && (i.far = o, i.updateProjectionMatrix()), ua.setFromMatrixPosition(e.matrixWorld), i.position.copy(ua), Sd.copy(i.position), Sd.add(this._cubeDirections[n]), i.up.copy(this._cubeUps[n]), i.lookAt(Sd), i.updateMatrixWorld(), r.makeTranslation(-ua.x, -ua.y, -ua.z), Km.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Km);
  }
}
class da extends xu {
  constructor(e, n, i = 0, r = 2) {
    super(e, n), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new r2();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class o2 extends Uf {
  constructor() {
    super(new mu(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class xo extends xu {
  constructor(e, n) {
    super(e, n), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ln.DEFAULT_UP), this.updateMatrix(), this.target = new ln(), this.shadow = new o2();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class ay extends xu {
  constructor(e, n) {
    super(e, n), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class ly extends Nt {
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class a2 {
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  start() {
    this.startTime = Jm(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const n = Jm();
      e = (n - this.oldTime) / 1e3, this.oldTime = n, this.elapsedTime += e;
    }
    return e;
  }
}
function Jm() {
  return performance.now();
}
const Qm = /* @__PURE__ */ new Zt();
class Of {
  constructor(e, n, i = 0, r = 1 / 0) {
    this.ray = new wf(e, n), this.near = i, this.far = r, this.camera = null, this.layers = new Sf(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(e, n) {
    this.ray.set(e, n);
  }
  setFromCamera(e, n) {
    n.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(n).sub(this.ray.origin).normalize(), this.camera = n) : n.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (n.near + n.far) / (n.near - n.far)).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld), this.camera = n) : console.error("THREE.Raycaster: Unsupported camera type: " + n.type);
  }
  setFromXRController(e) {
    return Qm.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(Qm), this;
  }
  intersectObject(e, n = !0, i = []) {
    return Bh(e, this, i, n), i.sort(ev), i;
  }
  intersectObjects(e, n = !0, i = []) {
    for (let r = 0, o = e.length; r < o; r++)
      Bh(e[r], this, i, n);
    return i.sort(ev), i;
  }
}
function ev(s, e) {
  return s.distance - e.distance;
}
function Bh(s, e, n, i) {
  let r = !0;
  if (s.layers.test(e.layers) && s.raycast(e, n) === !1 && (r = !1), r === !0 && i === !0) {
    const o = s.children;
    for (let a = 0, l = o.length; a < l; a++)
      Bh(o[a], e, n, !0);
  }
}
const tv = /* @__PURE__ */ new ce();
class Md extends ln {
  constructor(e, n) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = n, this.type = "SpotLightHelper";
    const i = new Nt(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
      const u = a / c * Math.PI * 2, d = l / c * Math.PI * 2;
      r.push(
        Math.cos(u),
        Math.sin(u),
        1,
        Math.cos(d),
        Math.sin(d),
        1
      );
    }
    i.setAttribute("position", new Pt(r, 3));
    const o = new Wi({ fog: !1, toneMapped: !1 });
    this.cone = new Af(i, o), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, n = e * Math.tan(this.light.angle);
    this.cone.scale.set(n, n, e), tv.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(tv), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
class l2 extends qe {
  constructor(e, n, i) {
    const r = new _u(n, 4, 2), o = new Mn({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, o), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
class c2 extends Af {
  constructor(e = 10, n = 10, i = 4473924, r = 8947848) {
    i = new Mt(i), r = new Mt(r);
    const o = n / 2, a = e / n, l = e / 2, c = [], u = [];
    for (let m = 0, p = 0, y = -l; m <= n; m++, y += a) {
      c.push(-l, 0, y, l, 0, y), c.push(y, 0, -l, y, 0, l);
      const _ = m === o ? i : r;
      _.toArray(u, p), p += 3, _.toArray(u, p), p += 3, _.toArray(u, p), p += 3, _.toArray(u, p), p += 3;
    }
    const d = new Nt();
    d.setAttribute("position", new Pt(c, 3)), d.setAttribute("color", new Pt(u, 3));
    const h = new Wi({ vertexColors: !0, toneMapped: !1 });
    super(d, h), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const nv = /* @__PURE__ */ new ce(), nc = /* @__PURE__ */ new ce(), iv = /* @__PURE__ */ new ce();
class u2 extends ln {
  constructor(e, n, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", n === void 0 && (n = 1);
    let r = new Nt();
    r.setAttribute("position", new Pt([
      -n,
      n,
      0,
      n,
      n,
      0,
      n,
      -n,
      0,
      -n,
      -n,
      0,
      -n,
      n,
      0
    ], 3));
    const o = new Wi({ fog: !1, toneMapped: !1 });
    this.lightPlane = new an(r, o), this.add(this.lightPlane), r = new Nt(), r.setAttribute("position", new Pt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new an(r, o), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), nv.setFromMatrixPosition(this.light.matrixWorld), nc.setFromMatrixPosition(this.light.target.matrixWorld), iv.subVectors(nc, nv), this.lightPlane.lookAt(nc), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(nc), this.targetLine.scale.z = iv.length();
  }
}
class d2 extends Af {
  constructor(e = 1) {
    const n = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], i = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new Nt();
    r.setAttribute("position", new Pt(n, 3)), r.setAttribute("color", new Pt(i, 3));
    const o = new Wi({ vertexColors: !0, toneMapped: !1 });
    super(r, o), this.type = "AxesHelper";
  }
  setColors(e, n, i) {
    const r = new Mt(), o = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(o, 0), r.toArray(o, 3), r.set(n), r.toArray(o, 6), r.toArray(o, 9), r.set(i), r.toArray(o, 12), r.toArray(o, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class h2 extends Br {
  constructor(e, n = null) {
    super(), this.object = e, this.domElement = n, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  connect() {
  }
  disconnect() {
  }
  dispose() {
  }
  update() {
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: df
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = df);
const Ac = {
  // ============================================================================
  // LINEAR
  // ============================================================================
  linear: (s) => s,
  // ============================================================================
  // SINE
  // ============================================================================
  easeInSine: (s) => 1 - Math.cos(s * Math.PI / 2),
  easeOutSine: (s) => Math.sin(s * Math.PI / 2),
  easeInOutSine: (s) => -(Math.cos(Math.PI * s) - 1) / 2,
  // ============================================================================
  // QUADRATIC
  // ============================================================================
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // ============================================================================
  // CUBIC
  // ============================================================================
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // ============================================================================
  // QUARTIC
  // ============================================================================
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // ============================================================================
  // QUINTIC
  // ============================================================================
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // ============================================================================
  // EXPONENTIAL
  // ============================================================================
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // ============================================================================
  // CIRCULAR
  // ============================================================================
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // ============================================================================
  // BACK (OVERSHOOT)
  // ============================================================================
  easeInBack: (s) => 2.70158 * s * s * s - 1.70158 * s * s,
  easeOutBack: (s) => 1 + 2.70158 * Math.pow(s - 1, 3) + 1.70158 * Math.pow(s - 1, 2),
  easeInOutBack: (s) => {
    const n = 2.5949095;
    return s < 0.5 ? Math.pow(2 * s, 2) * ((n + 1) * 2 * s - n) / 2 : (Math.pow(2 * s - 2, 2) * ((n + 1) * (s * 2 - 2) + n) + 2) / 2;
  },
  // ============================================================================
  // ELASTIC
  // ============================================================================
  easeInElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * e);
  },
  easeOutElastic: (s) => {
    const e = 2 * Math.PI / 3;
    return s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * e) + 1;
  },
  easeInOutElastic: (s) => {
    const e = 2 * Math.PI / 4.5;
    return s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * e)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * e) / 2 + 1;
  },
  // ============================================================================
  // BOUNCE
  // ============================================================================
  easeInBounce: (s) => 1 - Ac.easeOutBounce(1 - s),
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInOutBounce: (s) => s < 0.5 ? (1 - Ac.easeOutBounce(1 - 2 * s)) / 2 : (1 + Ac.easeOutBounce(2 * s - 1)) / 2
};
class vl {
  constructor() {
    // Cache for recent evaluations (cleared per frame batch)
    pe(this, "cache", /* @__PURE__ */ new Map());
  }
  /**
   * Evaluate an animatable property at a given frame
   */
  evaluate(e, n) {
    const i = e.id, r = this.cache.get(i);
    if (r && r.frame === n)
      return r.value;
    let o;
    return !e.animated || !e.keyframes || e.keyframes.length === 0 ? o = e.value : o = this.evaluateKeyframes(e.keyframes, n, e.value), this.cache.set(i, { frame: n, value: o }), o;
  }
  /**
   * Evaluate keyframes at a given frame
   */
  evaluateKeyframes(e, n, i) {
    const r = [...e].sort((d, h) => d.frame - h.frame);
    if (n <= r[0].frame)
      return r[0].value;
    if (n >= r[r.length - 1].frame)
      return r[r.length - 1].value;
    let o = r[0], a = r[r.length - 1];
    for (let d = 0; d < r.length - 1; d++)
      if (r[d].frame <= n && r[d + 1].frame > n) {
        o = r[d], a = r[d + 1];
        break;
      }
    const l = a.frame - o.frame, c = l > 0 ? (n - o.frame) / l : 0, u = this.applyEasing(c, o.interpolation, o, a);
    return this.interpolateValue(o.value, a.value, u, i);
  }
  /**
   * Apply easing function to raw t value
   */
  applyEasing(e, n, i, r) {
    switch (n) {
      case "hold":
        return 0;
      case "linear":
        return e;
      case "bezier":
        return this.evaluateBezier(e, i, r);
      default:
        const o = Ac[n];
        return o ? o(e) : e;
    }
  }
  /**
   * Evaluate bezier curve using keyframe handles
   */
  evaluateBezier(e, n, i) {
    const r = n.outHandle, o = i.inHandle;
    if (!(r != null && r.enabled) && !(o != null && o.enabled))
      return e;
    const a = i.frame - n.frame, l = { x: 0, y: 0 }, c = {
      x: r != null && r.enabled ? Math.min(1, Math.max(0, r.frame / a)) : 0.33,
      y: r != null && r.enabled ? r.value : 0
    }, u = {
      x: o != null && o.enabled ? Math.min(1, Math.max(0, 1 + o.frame / a)) : 0.67,
      y: o != null && o.enabled ? 1 + o.value : 1
    }, d = { x: 1, y: 1 };
    return this.solveCubicBezier(e, l.x, c.x, u.x, d.x, l.y, c.y, u.y, d.y);
  }
  /**
   * Solve cubic bezier curve for Y given X
   */
  solveCubicBezier(e, n, i, r, o, a, l, c, u) {
    let d = e;
    const h = 1e-4;
    for (let m = 0; m < 10; m++) {
      const y = this.cubicBezier(d, n, i, r, o) - e;
      if (Math.abs(y) < h)
        break;
      const _ = this.cubicBezierDerivative(d, n, i, r, o);
      if (Math.abs(_) < h)
        break;
      d -= y / _, d = Math.max(0, Math.min(1, d));
    }
    return this.cubicBezier(d, a, l, c, u);
  }
  /**
   * Evaluate cubic bezier at t
   */
  cubicBezier(e, n, i, r, o) {
    const a = 1 - e;
    return a * a * a * n + 3 * a * a * e * i + 3 * a * e * e * r + e * e * e * o;
  }
  /**
   * Evaluate cubic bezier derivative at t
   */
  cubicBezierDerivative(e, n, i, r, o) {
    const a = 1 - e;
    return 3 * a * a * (i - n) + 6 * a * e * (r - i) + 3 * e * e * (o - r);
  }
  /**
   * Interpolate between two values
   */
  interpolateValue(e, n, i, r) {
    return typeof e == "number" && typeof n == "number" ? e + (n - e) * i : this.isPositionLike(e) && this.isPositionLike(n) ? this.interpolatePosition(e, n, i) : typeof e == "string" && typeof n == "string" && e.startsWith("#") && n.startsWith("#") ? this.interpolateColor(e, n, i) : Array.isArray(e) && Array.isArray(n) ? this.interpolateArray(e, n, i) : i < 0.5 ? e : n;
  }
  /**
   * Check if value is position-like (has x, y properties)
   */
  isPositionLike(e) {
    return e !== null && typeof e == "object" && "x" in e && "y" in e;
  }
  /**
   * Interpolate position/vector values
   */
  interpolatePosition(e, n, i) {
    const r = {
      x: e.x + (n.x - e.x) * i,
      y: e.y + (n.y - e.y) * i
    };
    return ("z" in e || "z" in n) && (r.z = (e.z ?? 0) + ((n.z ?? 0) - (e.z ?? 0)) * i), r;
  }
  /**
   * Interpolate hex color strings
   */
  interpolateColor(e, n, i) {
    const r = this.hexToRGB(e), o = this.hexToRGB(n), a = Math.round(r.r + (o.r - r.r) * i), l = Math.round(r.g + (o.g - r.g) * i), c = Math.round(r.b + (o.b - r.b) * i);
    return this.rgbToHex(a, l, c);
  }
  /**
   * Interpolate arrays
   */
  interpolateArray(e, n, i) {
    const r = Math.max(e.length, n.length), o = [];
    for (let a = 0; a < r; a++) {
      const l = e[a] ?? 0, c = n[a] ?? 0;
      o.push(l + (c - l) * i);
    }
    return o;
  }
  /**
   * Convert hex color to RGB
   */
  hexToRGB(e) {
    const n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
    return n ? {
      r: parseInt(n[1], 16),
      g: parseInt(n[2], 16),
      b: parseInt(n[3], 16)
    } : { r: 0, g: 0, b: 0 };
  }
  /**
   * Convert RGB to hex color
   */
  rgbToHex(e, n, i) {
    return "#" + [e, n, i].map((r) => Math.max(0, Math.min(255, r)).toString(16).padStart(2, "0")).join("");
  }
  /**
   * Clear the evaluation cache
   */
  clearCache() {
    this.cache.clear();
  }
}
const Va = Math.PI, Xc = 1.70158, ic = Xc * 1.525, sv = Xc + 1, rv = 2 * Va / 3, ov = 2 * Va / 4.5, Fr = {
  // Linear - no easing
  linear: (s) => s,
  // Sine easing
  easeInSine: (s) => 1 - Math.cos(s * Va / 2),
  easeOutSine: (s) => Math.sin(s * Va / 2),
  easeInOutSine: (s) => -(Math.cos(Va * s) - 1) / 2,
  // Quad (power of 2)
  easeInQuad: (s) => s * s,
  easeOutQuad: (s) => 1 - (1 - s) * (1 - s),
  easeInOutQuad: (s) => s < 0.5 ? 2 * s * s : 1 - Math.pow(-2 * s + 2, 2) / 2,
  // Cubic (power of 3)
  easeInCubic: (s) => s * s * s,
  easeOutCubic: (s) => 1 - Math.pow(1 - s, 3),
  easeInOutCubic: (s) => s < 0.5 ? 4 * s * s * s : 1 - Math.pow(-2 * s + 2, 3) / 2,
  // Quart (power of 4)
  easeInQuart: (s) => s * s * s * s,
  easeOutQuart: (s) => 1 - Math.pow(1 - s, 4),
  easeInOutQuart: (s) => s < 0.5 ? 8 * s * s * s * s : 1 - Math.pow(-2 * s + 2, 4) / 2,
  // Quint (power of 5)
  easeInQuint: (s) => s * s * s * s * s,
  easeOutQuint: (s) => 1 - Math.pow(1 - s, 5),
  easeInOutQuint: (s) => s < 0.5 ? 16 * s * s * s * s * s : 1 - Math.pow(-2 * s + 2, 5) / 2,
  // Expo (exponential)
  easeInExpo: (s) => s === 0 ? 0 : Math.pow(2, 10 * s - 10),
  easeOutExpo: (s) => s === 1 ? 1 : 1 - Math.pow(2, -10 * s),
  easeInOutExpo: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? Math.pow(2, 20 * s - 10) / 2 : (2 - Math.pow(2, -20 * s + 10)) / 2,
  // Circ (circular)
  easeInCirc: (s) => 1 - Math.sqrt(1 - Math.pow(s, 2)),
  easeOutCirc: (s) => Math.sqrt(1 - Math.pow(s - 1, 2)),
  easeInOutCirc: (s) => s < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * s, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * s + 2, 2)) + 1) / 2,
  // Back (overshoot)
  easeInBack: (s) => sv * s * s * s - Xc * s * s,
  easeOutBack: (s) => 1 + sv * Math.pow(s - 1, 3) + Xc * Math.pow(s - 1, 2),
  easeInOutBack: (s) => s < 0.5 ? Math.pow(2 * s, 2) * ((ic + 1) * 2 * s - ic) / 2 : (Math.pow(2 * s - 2, 2) * ((ic + 1) * (s * 2 - 2) + ic) + 2) / 2,
  // Elastic
  easeInElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : -Math.pow(2, 10 * s - 10) * Math.sin((s * 10 - 10.75) * rv),
  easeOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : Math.pow(2, -10 * s) * Math.sin((s * 10 - 0.75) * rv) + 1,
  easeInOutElastic: (s) => s === 0 ? 0 : s === 1 ? 1 : s < 0.5 ? -(Math.pow(2, 20 * s - 10) * Math.sin((20 * s - 11.125) * ov)) / 2 : Math.pow(2, -20 * s + 10) * Math.sin((20 * s - 11.125) * ov) / 2 + 1,
  // Bounce
  easeOutBounce: (s) => s < 1 / 2.75 ? 7.5625 * s * s : s < 2 / 2.75 ? 7.5625 * (s -= 1.5 / 2.75) * s + 0.75 : s < 2.5 / 2.75 ? 7.5625 * (s -= 2.25 / 2.75) * s + 0.9375 : 7.5625 * (s -= 2.625 / 2.75) * s + 0.984375,
  easeInBounce: (s) => 1 - Fr.easeOutBounce(1 - s),
  easeInOutBounce: (s) => s < 0.5 ? (1 - Fr.easeOutBounce(1 - 2 * s)) / 2 : (1 + Fr.easeOutBounce(2 * s - 1)) / 2
};
function f2(s) {
  return s in Fr ? Fr[s] : Fr.linear;
}
function p2(s, e) {
  if (typeof s == "number" && typeof e == "number")
    return e - s;
  if (typeof s == "object" && s !== null && "x" in s && "y" in s && typeof e == "object" && e !== null && "x" in e && "y" in e) {
    const n = e.x - s.x, i = e.y - s.y;
    return Math.sqrt(n * n + i * i) || 1;
  }
  return 1;
}
function on(s, e) {
  if (!s.animated || s.keyframes.length === 0)
    return s.value;
  const n = s.keyframes;
  if (e <= n[0].frame)
    return n[0].value;
  if (e >= n[n.length - 1].frame)
    return n[n.length - 1].value;
  let i = n[0], r = n[1];
  for (let u = 0; u < n.length - 1; u++)
    if (e >= n[u].frame && e <= n[u + 1].frame) {
      i = n[u], r = n[u + 1];
      break;
    }
  const o = r.frame - i.frame, a = e - i.frame;
  let l = o > 0 ? a / o : 0;
  const c = i.interpolation || "linear";
  if (c === "hold")
    return i.value;
  if (c === "bezier") {
    const u = p2(i.value, r.value);
    l = m2(l, i.outHandle, r.inHandle, o, u);
  } else c === "linear" || (c in Fr ? l = f2(c)(l) : console.warn(`Unknown interpolation type: ${c}, using linear`));
  return g2(i.value, r.value, l);
}
function m2(s, e, n, i = 1, r = 1) {
  if (!e.enabled && !n.enabled)
    return s;
  const o = i > 0 ? Math.abs(e.frame) / i : 0.33, a = r !== 0 ? e.value / r : 0.33, l = i > 0 ? 1 - Math.abs(n.frame) / i : 0.67, c = r !== 0 ? 1 - n.value / r : 0.67;
  let u = s;
  for (let d = 0; d < 8; d++) {
    const h = jc(u, 0, o, l, 1), m = v2(u, 0, o, l, 1);
    if (Math.abs(m) < 1e-6) break;
    const p = h - s;
    u -= p / m, u = Math.max(0, Math.min(1, u));
  }
  return jc(u, 0, a, c, 1);
}
function jc(s, e, n, i, r) {
  const o = 1 - s;
  return o * o * o * e + 3 * o * o * s * n + 3 * o * s * s * i + s * s * s * r;
}
function v2(s, e, n, i, r) {
  const o = 1 - s;
  return 3 * o * o * (n - e) + 6 * o * s * (i - n) + 3 * s * s * (r - i);
}
function g2(s, e, n) {
  if (typeof s == "number" && typeof e == "number")
    return s + (e - s) * n;
  if (typeof s == "object" && s !== null && typeof e == "object" && e !== null && "x" in s && "y" in s && "x" in e && "y" in e) {
    const i = s, r = e, o = {
      x: i.x + (r.x - i.x) * n,
      y: i.y + (r.y - i.y) * n
    };
    return "z" in i && "z" in r ? o.z = i.z + (r.z - i.z) * n : "z" in i ? o.z = i.z * (1 - n) : "z" in r && (o.z = r.z * n), o;
  }
  return typeof s == "string" && typeof e == "string" && s.startsWith("#") && e.startsWith("#") ? y2(s, e, n) : n < 0.5 ? s : e;
}
function y2(s, e, n) {
  const i = parseInt(s.slice(1, 3), 16), r = parseInt(s.slice(3, 5), 16), o = parseInt(s.slice(5, 7), 16), a = parseInt(e.slice(1, 3), 16), l = parseInt(e.slice(3, 5), 16), c = parseInt(e.slice(5, 7), 16), u = Math.round(i + (a - i) * n), d = Math.round(r + (l - r) * n), h = Math.round(o + (c - o) * n);
  return `#${u.toString(16).padStart(2, "0")}${d.toString(16).padStart(2, "0")}${h.toString(16).padStart(2, "0")}`;
}
const _2 = {
  linear: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeIn: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.33, y: 0.33 }
  },
  easeOut: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeInOut: {
    outHandle: { x: 0.42, y: 0 },
    inHandle: { x: 0.58, y: 1 }
  },
  easeOutBack: {
    outHandle: { x: 0.33, y: 0.33 },
    inHandle: { x: 0.34, y: 1.56 }
    // Overshoot
  }
}, Yc = _2;
function x2(s, e, n) {
  const i = e.x, r = e.y, o = 1 - n.x, a = 1 - n.y;
  return {
    x: jc(s, 0, i, o, 1),
    y: jc(s, 0, r, a, 1)
  };
}
function b2(s, e) {
  const n = Math.max(0, Math.min(1, s));
  return x2(n, e.outHandle, e.inHandle).y;
}
const cy = /* @__PURE__ */ new Map();
function mo(s, e) {
  cy.set(s, e);
}
function w2(s, e) {
  const n = {};
  for (const [i, r] of Object.entries(s.parameters)) {
    const o = r;
    n[i] = on(o, e);
  }
  return n;
}
function S2(s, e, n) {
  const i = document.createElement("canvas");
  i.width = e.width, i.height = e.height;
  const r = i.getContext("2d");
  r.drawImage(e, 0, 0);
  let o = {
    canvas: i,
    ctx: r
  };
  for (const a of s) {
    if (!a.enabled)
      continue;
    const l = cy.get(a.effectKey);
    if (!l) {
      console.warn(`No renderer registered for effect: ${a.effectKey}`);
      continue;
    }
    const c = w2(a, n);
    try {
      o = l(o, c);
    } catch (u) {
      console.error(`Error applying effect ${a.name}:`, u);
    }
  }
  return o;
}
function $o(s) {
  const e = document.createElement("canvas");
  e.width = s.width, e.height = s.height;
  const n = e.getContext("2d");
  return { canvas: e, ctx: n };
}
function M2(s) {
  return s.some((e) => e.enabled);
}
class $i {
  constructor(e) {
    /** Unique layer identifier */
    pe(this, "id");
    /** Layer type */
    pe(this, "type");
    /** The Three.js group containing this layer's content */
    pe(this, "group");
    /** Keyframe evaluator for animated properties */
    pe(this, "evaluator");
    /** Layer visibility */
    pe(this, "visible");
    /** Layer locked state */
    pe(this, "locked");
    /** In point (start frame) */
    pe(this, "inPoint");
    /** Out point (end frame) */
    pe(this, "outPoint");
    /** Layer opacity (0-100) */
    pe(this, "opacity");
    /** Layer transform */
    pe(this, "transform");
    /** 3D layer flag */
    pe(this, "threeD");
    /** Blend mode */
    pe(this, "blendMode");
    /** Parent layer ID (for parenting hierarchy) */
    pe(this, "parentId");
    /** Reference to parent layer (set by LayerManager) */
    pe(this, "parentLayer", null);
    /** Driven values override (from property drivers/expressions) */
    pe(this, "drivenValues", /* @__PURE__ */ new Map());
    /** Audio reactive values (from audio analysis mapping) */
    pe(this, "audioReactiveValues", /* @__PURE__ */ new Map());
    /** Effects stack for this layer */
    pe(this, "effects", []);
    /** Source canvas for effect processing (lazy initialized) */
    pe(this, "effectSourceCanvas", null);
    /** Flag to track if effects need processing */
    pe(this, "effectsDirty", !1);
    this.id = e.id, this.type = e.type, this.group = new Ei(), this.group.name = `layer_${this.id}`, this.group.userData.layerId = this.id, this.group.userData.layerType = this.type, this.evaluator = new vl(), this.visible = e.visible, this.locked = e.locked, this.inPoint = e.inPoint, this.outPoint = e.outPoint, this.opacity = e.opacity, this.transform = e.transform, this.threeD = e.threeD ?? !1, this.blendMode = e.blendMode ?? "normal", this.parentId = e.parentId ?? null, this.effects = e.effects ?? [];
  }
  /** Three.js object representing this layer (from LayerInstance) */
  get object() {
    return this.group;
  }
  /**
   * Initialize blend mode after subclass creates mesh
   * Subclasses should call this at the end of their constructor
   */
  initializeBlendMode() {
    this.blendMode !== "normal" && this.applyBlendMode(this.blendMode);
  }
  // ============================================================================
  // OBJECT ACCESS
  // ============================================================================
  /**
   * Get the Three.js object representing this layer
   */
  getObject() {
    return this.group;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all animated properties at the given frame
   */
  evaluateFrame(e) {
    const n = e >= this.inPoint && e <= this.outPoint;
    if (this.group.visible = this.visible && n, !this.group.visible)
      return;
    let i = this.evaluator.evaluate(this.opacity, e);
    i = this.getDrivenOrBase("opacity", i);
    const r = this.applyAudioModulation(i, "layer.opacity", "multiply", { min: 0, max: 100 });
    this.applyOpacity(r), this.evaluateTransform(e), this.onEvaluateFrame(e);
  }
  /**
   * Evaluate and apply transform at the given frame
   */
  evaluateTransform(e) {
    const n = this.evaluator.evaluate(this.transform.position, e);
    let i = this.getDrivenOrBase("transform.position.x", n.x), r = this.getDrivenOrBase("transform.position.y", n.y);
    const o = this.getDrivenOrBase("transform.position.z", n.z ?? 0);
    i = this.applyAudioModulation(i, "layer.x", "add"), r = this.applyAudioModulation(r, "layer.y", "add");
    const a = { x: i, y: r, z: o }, l = this.evaluator.evaluate(this.transform.scale, e);
    let c = this.getDrivenOrBase("transform.scale.x", l.x ?? 100), u = this.getDrivenOrBase("transform.scale.y", l.y ?? 100);
    const d = this.getDrivenOrBase("transform.scale.z", l.z ?? 100), h = this.getAudioReactiveValue("layer.scale");
    if (h !== 0) {
      const w = 0.5 + h;
      c *= w, u *= w;
    }
    const m = { x: c, y: u, z: d }, p = this.evaluator.evaluate(this.transform.anchorPoint, e), y = {
      x: this.getDrivenOrBase("transform.anchorPoint.x", p.x ?? 0),
      y: this.getDrivenOrBase("transform.anchorPoint.y", p.y ?? 0),
      z: this.getDrivenOrBase("transform.anchorPoint.z", p.z ?? 0)
    };
    let _ = 0, v = 0, g = 0;
    if (this.threeD) {
      const w = this.transform.rotationX ? this.evaluator.evaluate(this.transform.rotationX, e) : 0;
      v = this.getDrivenOrBase("transform.rotationX", w);
      const x = this.transform.rotationY ? this.evaluator.evaluate(this.transform.rotationY, e) : 0;
      g = this.getDrivenOrBase("transform.rotationY", x);
      const C = this.transform.rotationZ ? this.evaluator.evaluate(this.transform.rotationZ, e) : 0;
      _ = this.getDrivenOrBase("transform.rotationZ", C);
    } else {
      const w = this.evaluator.evaluate(this.transform.rotation, e);
      _ = this.getDrivenOrBase("transform.rotation", w);
    }
    const S = this.getAudioReactiveValue("layer.rotation");
    S !== 0 && (_ += S * 360), this.applyTransform({
      position: {
        x: a.x,
        y: a.y,
        z: a.z
      },
      rotation: {
        x: v,
        y: g,
        z: _
      },
      scale: {
        x: m.x / 100,
        y: m.y / 100,
        z: m.z / 100
      },
      anchorPoint: {
        x: y.x,
        y: y.y,
        z: y.z
      }
    });
  }
  /**
   * Apply transform to the group
   */
  applyTransform(e) {
    const { position: n, rotation: i, scale: r, anchorPoint: o } = e;
    this.group.position.set(
      n.x - o.x,
      -(n.y - o.y),
      // Negate for screen coords
      n.z - o.z
    ), this.group.rotation.set(
      fn.degToRad(i.x),
      fn.degToRad(i.y),
      fn.degToRad(-i.z)
    ), this.group.scale.set(r.x, r.y, r.z), this.group.updateMatrix();
  }
  /**
   * Apply opacity to layer materials
   */
  applyOpacity(e) {
    const n = Math.max(0, Math.min(100, e)) / 100;
    this.group.traverse((i) => {
      if (i instanceof qe && i.material) {
        const r = i.material;
        "opacity" in r && (r.opacity = n, r.transparent = n < 1, r.needsUpdate = !0);
      }
    });
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Update layer properties
   */
  update(e) {
    e.visible !== void 0 && (this.visible = e.visible, this.group.visible = this.visible), e.locked !== void 0 && (this.locked = e.locked), e.inPoint !== void 0 && (this.inPoint = e.inPoint), e.outPoint !== void 0 && (this.outPoint = e.outPoint), e.opacity !== void 0 && (this.opacity = e.opacity), e.transform !== void 0 && (this.transform = e.transform), e.threeD !== void 0 && (this.threeD = e.threeD), e.blendMode !== void 0 && (this.blendMode = e.blendMode, this.applyBlendMode(this.blendMode)), e.effects !== void 0 && this.setEffects(e.effects), this.onUpdate(e);
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setVisible(e) {
    this.visible = e, this.group.visible = e;
  }
  /**
   * Get layer visibility
   */
  isVisible() {
    return this.visible;
  }
  // ============================================================================
  // DRIVEN VALUES (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values from property drivers
   * These override the base animated values during transform evaluation
   * @param values Map of property path to driven value
   */
  setDrivenValues(e) {
    this.drivenValues = e;
  }
  /**
   * Clear driven values
   */
  clearDrivenValues() {
    this.drivenValues.clear();
  }
  /**
   * Get a driven value if it exists, otherwise return the base value
   */
  getDrivenOrBase(e, n) {
    return this.drivenValues.get(e) ?? n;
  }
  // ============================================================================
  // AUDIO REACTIVE VALUES
  // ============================================================================
  /**
   * Set audio reactive values from audio analysis
   * These are applied additively/multiplicatively to animated properties
   * @param values Map of target parameter to audio-derived value (0-1 range typically)
   */
  setAudioReactiveValues(e) {
    this.audioReactiveValues = e;
  }
  /**
   * Clear audio reactive values
   */
  clearAudioReactiveValues() {
    this.audioReactiveValues.clear();
  }
  /**
   * Get audio reactive modulation for a property
   * Returns 0 if no mapping exists (additive identity)
   */
  getAudioReactiveValue(e) {
    return this.audioReactiveValues.get(e) ?? 0;
  }
  /**
   * Apply audio reactive modulation to a base value
   * Mode determines how the modulation is applied
   */
  applyAudioModulation(e, n, i = "add", r = {}) {
    const o = this.getAudioReactiveValue(n);
    if (o === 0) return e;
    let a;
    switch (i) {
      case "multiply":
        a = e * (0.5 + o);
        break;
      case "replace":
        a = o;
        break;
      case "add":
      default:
        a = e + o * 100;
        break;
    }
    return r.min !== void 0 && (a = Math.max(r.min, a)), r.max !== void 0 && (a = Math.min(r.max, a)), a;
  }
  // ============================================================================
  // EFFECTS
  // ============================================================================
  /**
   * Update the effects stack for this layer
   * @param effects - Array of effect instances
   */
  setEffects(e) {
    this.effects = e, this.effectsDirty = !0;
  }
  /**
   * Get the current effects stack
   */
  getEffects() {
    return this.effects;
  }
  /**
   * Check if this layer has any enabled effects
   */
  hasEnabledEffects() {
    return M2(this.effects);
  }
  /**
   * Process effects on a source canvas
   * Subclasses that support effects should override getSourceCanvas()
   * @param frame - Current frame for animated effect parameters
   * @returns Processed canvas or null if no effects to apply
   */
  processEffects(e) {
    if (!this.hasEnabledEffects())
      return null;
    const n = this.getSourceCanvas();
    if (!n)
      return null;
    try {
      return S2(this.effects, n, e).canvas;
    } catch (i) {
      return console.error(`[BaseLayer] Error processing effects for layer ${this.id}:`, i), null;
    }
  }
  /**
   * Get the source canvas for effect processing
   * Override in subclasses that support effects (ImageLayer, VideoLayer, TextLayer)
   * @returns Canvas with the layer's visual content, or null if not supported
   */
  getSourceCanvas() {
    return null;
  }
  /**
   * Apply processed effects back to the layer
   * Override in subclasses to update their texture from the processed canvas
   * @param processedCanvas - Canvas with effects applied
   */
  applyProcessedEffects(e) {
  }
  /**
   * Called after frame evaluation to apply effects
   * This should be called by subclasses after their content is rendered
   */
  evaluateEffects(e) {
    if (!this.hasEnabledEffects())
      return;
    const n = this.processEffects(e);
    n && this.applyProcessedEffects(n);
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Set parent layer reference
   */
  setParent(e) {
    this.parentLayer && this.parentLayer.getObject().remove(this.group), this.parentLayer = e, e && e.getObject().add(this.group);
  }
  /**
   * Get parent layer reference
   */
  getParent() {
    return this.parentLayer;
  }
  /**
   * Get parent layer ID
   */
  getParentId() {
    return this.parentId;
  }
  /**
   * Check if this layer has a parent
   */
  hasParent() {
    return this.parentId !== null;
  }
  // ============================================================================
  // BLEND MODES
  // ============================================================================
  /**
   * Apply blend mode to layer materials
   * Supports: normal, add, multiply, screen, overlay, soft-light, hard-light,
   * color-dodge, color-burn, difference, exclusion, darken, lighten
   */
  applyBlendMode(e) {
    this.group.traverse((n) => {
      if (n instanceof qe && n.material) {
        const i = n.material;
        this.setMaterialBlendMode(i, e), i.needsUpdate = !0;
      }
    });
  }
  /**
   * Configure a material's blend mode
   */
  setMaterialBlendMode(e, n) {
    switch (e.blending = Ni, e.blendEquation = Oi, e.blendSrc = Vc, e.blendDst = el, e.blendEquationAlpha = Oi, e.blendSrcAlpha = vs, e.blendDstAlpha = el, n) {
      case "normal":
        e.blending = Ni;
        break;
      case "add":
        e.blending = Qa;
        break;
      case "multiply":
        e.blending = Eo;
        break;
      case "screen":
        e.blending = Cr, e.blendEquation = Oi, e.blendSrc = vs, e.blendDst = Qd;
        break;
      case "overlay":
        e.blending = Eo;
        break;
      case "soft-light":
        e.blending = Ni;
        break;
      case "hard-light":
        e.blending = Eo;
        break;
      case "color-dodge":
        e.blending = Qa;
        break;
      case "color-burn":
        e.blending = Jd;
        break;
      case "difference":
        e.blending = Cr, e.blendEquation = g0, e.blendSrc = vs, e.blendDst = vs;
        break;
      case "exclusion":
        e.blending = Cr, e.blendEquation = Oi, e.blendSrc = x0, e.blendDst = Qd;
        break;
      case "darken":
        e.blending = Cr, e.blendEquation = y0, e.blendSrc = vs, e.blendDst = vs;
        break;
      case "lighten":
        e.blending = Cr, e.blendEquation = _0, e.blendSrc = vs, e.blendDst = vs;
        break;
      default:
        e.blending = Ni;
        break;
    }
  }
  // ============================================================================
  // BOUNDS
  // ============================================================================
  /**
   * Get the bounding box of this layer
   */
  getBoundingBox() {
    const e = new rr();
    return e.setFromObject(this.group), e;
  }
  /**
   * Get the center point of this layer
   */
  getCenter() {
    const e = this.getBoundingBox(), n = new ce();
    return e.getCenter(n), n;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose layer resources
   */
  dispose() {
    this.group.traverse((e) => {
      var n;
      e instanceof qe && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => i.dispose()) : e.material && e.material.dispose());
    }), this.group.clear(), this.onDispose();
  }
  /**
   * Override in subclasses for type-specific cleanup
   */
  onDispose() {
  }
}
class C2 extends $i {
  constructor(n, i) {
    super(n);
    pe(this, "resources");
    // Video elements
    pe(this, "videoElement", null);
    pe(this, "videoTexture", null);
    pe(this, "mesh", null);
    pe(this, "material", null);
    // Video data
    pe(this, "videoData");
    pe(this, "assetRef", null);
    // Metadata (populated after video loads)
    pe(this, "metadata", null);
    // Animation evaluator
    pe(this, "videoEvaluator");
    // Playback state
    pe(this, "lastEvaluatedFrame", -1);
    pe(this, "isPlaying", !1);
    // Callbacks for composition auto-resize
    pe(this, "onMetadataLoaded");
    // Composition FPS for time calculation
    pe(this, "compositionFPS", 30);
    // Canvas for effect processing
    pe(this, "effectCanvas", null);
    pe(this, "effectCanvasCtx", null);
    this.resources = i, this.videoEvaluator = new vl(), this.videoData = this.extractVideoData(n), this.createPlaceholderMesh(), this.videoData.assetId && this.loadVideo(this.videoData.assetId), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract video data with defaults
   */
  extractVideoData(n) {
    const i = n.data;
    return {
      assetId: (i == null ? void 0 : i.assetId) ?? null,
      loop: (i == null ? void 0 : i.loop) ?? !1,
      pingPong: (i == null ? void 0 : i.pingPong) ?? !1,
      startTime: (i == null ? void 0 : i.startTime) ?? 0,
      endTime: i == null ? void 0 : i.endTime,
      speed: (i == null ? void 0 : i.speed) ?? 1,
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      frameBlending: (i == null ? void 0 : i.frameBlending) ?? "none",
      audioEnabled: (i == null ? void 0 : i.audioEnabled) ?? !0,
      audioLevel: (i == null ? void 0 : i.audioLevel) ?? 100,
      posterFrame: (i == null ? void 0 : i.posterFrame) ?? 0
    };
  }
  /**
   * Create placeholder mesh before video loads
   */
  createPlaceholderMesh() {
    const n = new cn(1, 1);
    this.material = new Mn({
      color: 3355443,
      transparent: !0,
      side: mn
    }), this.mesh = new qe(n, this.material), this.mesh.name = `video_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // VIDEO LOADING
  // ============================================================================
  /**
   * Load video from asset
   */
  async loadVideo(n) {
    const i = this.resources.getAsset(n);
    if (!i || i.type !== "video") {
      console.warn(`[VideoLayer] Asset ${n} not found or not a video`);
      return;
    }
    this.assetRef = i, this.videoData.assetId = n, this.videoElement = document.createElement("video"), this.videoElement.crossOrigin = "anonymous", this.videoElement.playsInline = !0, this.videoElement.muted = !this.videoData.audioEnabled, this.videoElement.loop = !1, this.videoElement.preload = "auto", i.data && (this.videoElement.src = i.data), await this.waitForMetadata(), this.createVideoTexture(), this.seekToFrame(this.videoData.posterFrame);
  }
  /**
   * Wait for video metadata to load
   */
  waitForMetadata() {
    return new Promise((n, i) => {
      if (!this.videoElement) {
        i(new Error("No video element"));
        return;
      }
      const r = () => {
        this.extractMetadata(), a(), n();
      }, o = (l) => {
        a(), i(new Error(`Video load error: ${l}`));
      }, a = () => {
        var l, c;
        (l = this.videoElement) == null || l.removeEventListener("loadedmetadata", r), (c = this.videoElement) == null || c.removeEventListener("error", o);
      };
      this.videoElement.addEventListener("loadedmetadata", r), this.videoElement.addEventListener("error", o), this.videoElement.load();
    });
  }
  /**
   * Extract metadata from loaded video
   */
  extractMetadata() {
    var l, c;
    if (!this.videoElement) return;
    const n = this.videoElement.duration, i = this.videoElement.videoWidth, r = this.videoElement.videoHeight, o = ((l = this.assetRef) == null ? void 0 : l.fps) ?? 30, a = Math.ceil(n * o);
    this.metadata = {
      duration: n,
      frameCount: a,
      fps: o,
      width: i,
      height: r,
      hasAudio: this.hasAudioTrack()
    }, this.assetRef && (this.assetRef.duration = n, this.assetRef.frameCount = a, this.assetRef.fps = o, this.assetRef.hasAudio = this.metadata.hasAudio), (c = this.onMetadataLoaded) == null || c.call(this, this.metadata), console.log(`[VideoLayer] Loaded: ${i}x${r}, ${a} frames @ ${o}fps, ${n.toFixed(2)}s`);
  }
  /**
   * Check if video has audio track
   */
  hasAudioTrack() {
    if (!this.videoElement) return !1;
    const n = this.videoElement.audioTracks;
    return n ? n.length > 0 : !0;
  }
  /**
   * Create Three.js texture from video element
   */
  createVideoTexture() {
    !this.videoElement || !this.metadata || (this.videoTexture = new bE(this.videoElement), this.videoTexture.minFilter = Xt, this.videoTexture.magFilter = Xt, this.videoTexture.format = $n, this.videoTexture.colorSpace = pn, this.material && (this.material.map = this.videoTexture, this.material.color.setHex(16777215), this.material.needsUpdate = !0), this.resizeMesh(this.metadata.width, this.metadata.height));
  }
  /**
   * Resize mesh to match video dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new cn(n, i));
  }
  // ============================================================================
  // PLAYBACK CONTROL
  // ============================================================================
  /**
   * Seek to a specific composition frame
   */
  seekToFrame(n) {
    if (!this.videoElement || !this.metadata) return;
    const i = this.calculateVideoTime(n), r = Math.max(0, Math.min(i, this.videoElement.duration));
    this.videoElement.currentTime = r;
  }
  /**
   * Calculate video time from composition frame
   * Handles speed, time remapping, loop, and ping-pong
   */
  calculateVideoTime(n) {
    var l;
    if (!this.metadata) return 0;
    if (this.videoData.timeRemapEnabled && ((l = this.videoData.timeRemap) != null && l.animated))
      return this.videoEvaluator.evaluate(this.videoData.timeRemap, n);
    const i = this.compositionFPS;
    let o = n / i * this.videoData.speed;
    o += this.videoData.startTime;
    const a = this.videoData.endTime ? this.videoData.endTime - this.videoData.startTime : this.metadata.duration - this.videoData.startTime;
    if (this.videoData.loop && a > 0) {
      if (this.videoData.pingPong) {
        const c = Math.floor(o / a), u = o % a;
        o = c % 2 === 0 ? u : a - u;
      } else
        o = o % a;
      o += this.videoData.startTime;
    }
    return o;
  }
  /**
   * Set audio volume
   */
  setAudioLevel(n) {
    this.videoData.audioLevel = n, this.videoElement && (this.videoElement.volume = Math.max(0, Math.min(1, n / 100)));
  }
  /**
   * Enable/disable audio
   */
  setAudioEnabled(n) {
    this.videoData.audioEnabled = n, this.videoElement && (this.videoElement.muted = !n);
  }
  // ============================================================================
  // METADATA CALLBACK
  // ============================================================================
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.compositionFPS = n;
  }
  /**
   * Register callback for when video metadata is loaded
   * Used by LayerManager to auto-resize composition
   */
  setMetadataCallback(n) {
    this.onMetadataLoaded = n, this.metadata && n(this.metadata);
  }
  /**
   * Get video metadata
   */
  getMetadata() {
    return this.metadata;
  }
  /**
   * Get video data
   */
  getVideoData() {
    return { ...this.videoData };
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setLoop(n) {
    this.videoData.loop = n;
  }
  setPingPong(n) {
    this.videoData.pingPong = n;
  }
  setSpeed(n) {
    this.videoData.speed = n, this.videoElement && (this.videoElement.playbackRate = n);
  }
  setStartTime(n) {
    this.videoData.startTime = n;
  }
  setEndTime(n) {
    this.videoData.endTime = n;
  }
  setFrameBlending(n) {
    this.videoData.frameBlending = n;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the current video frame to a 2D canvas
   */
  getSourceCanvas() {
    if (!this.videoElement || !this.metadata)
      return null;
    const n = this.metadata.width, i = this.metadata.height;
    return (!this.effectCanvas || this.effectCanvas.width !== n || this.effectCanvas.height !== i) && (this.effectCanvas = document.createElement("canvas"), this.effectCanvas.width = n, this.effectCanvas.height = i, this.effectCanvasCtx = this.effectCanvas.getContext("2d")), this.effectCanvasCtx ? (this.effectCanvasCtx.clearRect(0, 0, n, i), this.effectCanvasCtx.drawImage(this.videoElement, 0, 0, n, i), this.effectCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    if (!this.material || !this.metadata) return;
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Xt,
        magFilter: Xt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    n !== this.lastEvaluatedFrame && (this.lastEvaluatedFrame = n, this.seekToFrame(n), this.videoTexture && (this.videoTexture.needsUpdate = !0), this.hasEnabledEffects() ? this.evaluateEffects(n) : this.material && this.videoTexture && (this.material.map = this.videoTexture, this.material.needsUpdate = !0));
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.assetId !== void 0 && i.assetId !== this.videoData.assetId && (i.assetId ? this.loadVideo(i.assetId) : this.clearVideo()), i.loop !== void 0 && this.setLoop(i.loop), i.pingPong !== void 0 && this.setPingPong(i.pingPong), i.speed !== void 0 && this.setSpeed(i.speed), i.startTime !== void 0 && this.setStartTime(i.startTime), i.endTime !== void 0 && this.setEndTime(i.endTime), i.frameBlending !== void 0 && this.setFrameBlending(i.frameBlending), i.audioEnabled !== void 0 && this.setAudioEnabled(i.audioEnabled), i.audioLevel !== void 0 && this.setAudioLevel(i.audioLevel));
  }
  /**
   * Clear current video
   */
  clearVideo() {
    this.videoElement && (this.videoElement.pause(), this.videoElement.src = "", this.videoElement = null), this.videoTexture && (this.videoTexture.dispose(), this.videoTexture = null), this.material && (this.material.map = null, this.material.color.setHex(3355443)), this.metadata = null, this.videoData.assetId = null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.clearVideo(), this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh));
  }
}
async function E2(s) {
  return new Promise((e, n) => {
    const i = document.createElement("video");
    i.crossOrigin = "anonymous", i.preload = "metadata";
    const r = () => {
      i.removeEventListener("loadedmetadata", o), i.removeEventListener("error", a), URL.revokeObjectURL(i.src);
    }, o = () => {
      const l = {
        duration: i.duration,
        frameCount: Math.ceil(i.duration * 30),
        // Estimate at 30fps
        fps: 30,
        // Browser doesn't expose this
        width: i.videoWidth,
        height: i.videoHeight,
        hasAudio: !0
        // Assume true
      };
      r(), e(l);
    }, a = () => {
      r(), n(new Error("Failed to load video metadata"));
    };
    i.addEventListener("loadedmetadata", o), i.addEventListener("error", a), typeof s == "string" ? i.src = s : i.src = URL.createObjectURL(s);
  });
}
function T2(s, e = 16) {
  const n = Math.round(s.width / 8) * 8, i = Math.round(s.height / 8) * 8, r = Math.ceil(s.duration * e);
  return { width: n, height: i, frameCount: r };
}
const A2 = [
  { name: "15mm", focalLength: 15, angleOfView: 100.4, zoom: 533 },
  { name: "20mm", focalLength: 20, angleOfView: 84, zoom: 711 },
  { name: "24mm", focalLength: 24, angleOfView: 73.7, zoom: 853 },
  { name: "28mm", focalLength: 28, angleOfView: 65.5, zoom: 996 },
  { name: "35mm", focalLength: 35, angleOfView: 54.4, zoom: 1244 },
  { name: "50mm", focalLength: 50, angleOfView: 39.6, zoom: 1778 },
  { name: "80mm", focalLength: 80, angleOfView: 25.4, zoom: 2844 },
  { name: "135mm", focalLength: 135, angleOfView: 15.2, zoom: 4800 }
];
function uy(s, e, n) {
  const i = e / 2, r = n / 2;
  return {
    id: s,
    name: "Camera 1",
    type: "two-node",
    position: { x: i, y: r, z: -1500 },
    pointOfInterest: { x: i, y: r, z: 0 },
    orientation: { x: 0, y: 0, z: 0 },
    xRotation: 0,
    yRotation: 0,
    zRotation: 0,
    zoom: 1778,
    // 50mm equivalent
    focalLength: 50,
    angleOfView: 39.6,
    filmSize: 36,
    measureFilmSize: "horizontal",
    depthOfField: {
      enabled: !1,
      focusDistance: 1500,
      aperture: 50,
      fStop: 2.8,
      blurLevel: 1,
      lockToZoom: !1
    },
    iris: {
      shape: 7,
      // Heptagon by default
      rotation: 0,
      roundness: 0,
      aspectRatio: 1,
      diffractionFringe: 0
    },
    highlight: {
      gain: 0,
      threshold: 1,
      saturation: 1
    },
    autoOrient: "off",
    nearClip: 1,
    farClip: 1e4
  };
}
function dy() {
  return {
    layout: "1-view",
    views: ["active-camera"],
    customViews: {
      "custom-1": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-2": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 90,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      },
      "custom-3": {
        orbitCenter: { x: 0, y: 0, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 0,
        orbitTheta: 0,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      }
    },
    activeViewIndex: 0
  };
}
function P2() {
  return {
    cameraWireframes: "selected",
    lightWireframes: "selected",
    showMotionPaths: !0,
    showLayerHandles: !0,
    showSafeZones: !1,
    showGrid: !1,
    showRulers: !0,
    show3DReferenceAxes: !0,
    showCompositionBounds: !0,
    showFocalPlane: !1
  };
}
function xt(s, e, n) {
  return { x: s, y: e, z: n };
}
function At(s, e) {
  return { x: s.x + e.x, y: s.y + e.y, z: s.z + e.z };
}
function zf(s, e) {
  return { x: s.x - e.x, y: s.y - e.y, z: s.z - e.z };
}
function Rt(s, e) {
  return { x: s.x * e, y: s.y * e, z: s.z * e };
}
function D2(s) {
  return Math.sqrt(s.x * s.x + s.y * s.y + s.z * s.z);
}
function Cs(s) {
  const e = D2(s);
  return e === 0 ? { x: 0, y: 0, z: 0 } : { x: s.x / e, y: s.y / e, z: s.z / e };
}
function No(s, e) {
  return {
    x: s.y * e.z - s.z * e.y,
    y: s.z * e.x - s.x * e.z,
    z: s.x * e.y - s.y * e.x
  };
}
function Cd(s, e) {
  return s.x * e.x + s.y * e.y + s.z * e.z;
}
function R2(s, e, n, i) {
  const r = new Float32Array(16), o = 1 / Math.tan(s / 2), a = 1 / (n - i);
  return r[0] = o / e, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = (i + n) * a, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = 2 * i * n * a, r[15] = 0, { elements: r };
}
function I2(s, e, n, i, r, o) {
  const a = new Float32Array(16), l = 1 / (e - s), c = 1 / (i - n), u = 1 / (o - r);
  return a[0] = 2 * l, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 2 * c, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = -2 * u, a[11] = 0, a[12] = -(e + s) * l, a[13] = -(i + n) * c, a[14] = -10001 * u, a[15] = 1, { elements: a };
}
function Zi(s, e, n) {
  const i = new Float32Array(16);
  let r = s.x - e.x, o = s.y - e.y, a = s.z - e.z, l = Math.sqrt(r * r + o * o + a * a);
  l === 0 ? a = 1 : (l = 1 / l, r *= l, o *= l, a *= l);
  let c = n.y * a - n.z * o, u = n.z * r - n.x * a, d = n.x * o - n.y * r;
  l = Math.sqrt(c * c + u * u + d * d), l === 0 ? (c = 0, u = 0, d = 0) : (l = 1 / l, c *= l, u *= l, d *= l);
  let h = o * d - a * u, m = a * c - r * d, p = r * u - o * c;
  return l = Math.sqrt(h * h + m * m + p * p), l === 0 ? (h = 0, m = 0, p = 0) : (l = 1 / l, h *= l, m *= l, p *= l), i[0] = c, i[4] = u, i[8] = d, i[12] = -Cd({ x: c, y: u, z: d }, s), i[1] = h, i[5] = m, i[9] = p, i[13] = -Cd({ x: h, y: m, z: p }, s), i[2] = r, i[6] = o, i[10] = a, i[14] = -Cd({ x: r, y: o, z: a }, s), i[3] = 0, i[7] = 0, i[11] = 0, i[15] = 1, { elements: i };
}
function k2(s, e) {
  const n = s.elements, i = n[3] * e.x + n[7] * e.y + n[11] * e.z + n[15];
  return {
    x: (n[0] * e.x + n[4] * e.y + n[8] * e.z + n[12]) / i,
    y: (n[1] * e.x + n[5] * e.y + n[9] * e.z + n[13]) / i,
    z: (n[2] * e.x + n[6] * e.y + n[10] * e.z + n[14]) / i
  };
}
function gl(s, e) {
  return 2 * Math.atan(e / (2 * s));
}
function L2(s, e) {
  return e / (2 * Math.tan(s / 2));
}
function al(s, e, n) {
  if (!e || e.length === 0)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  let i = null, r = null;
  for (const _ of e)
    _.frame <= n && (i = _), _.frame >= n && !r && (r = _);
  if (!i && !r)
    return {
      position: s.position,
      rotation: s.orientation,
      focalLength: s.focalLength,
      zoom: s.zoom,
      focusDistance: s.depthOfField.focusDistance
    };
  i || (i = r), r || (r = i);
  const o = (_) => (_ == null ? void 0 : _.position) ?? s.position, a = (_) => (_ == null ? void 0 : _.orientation) ?? s.orientation, l = (_) => (_ == null ? void 0 : _.focalLength) ?? s.focalLength, c = (_) => (_ == null ? void 0 : _.zoom) ?? s.zoom, u = (_) => (_ == null ? void 0 : _.focusDistance) ?? s.depthOfField.focusDistance;
  if (i.frame === r.frame)
    return {
      position: o(i),
      rotation: a(i),
      focalLength: l(i),
      zoom: c(i),
      focusDistance: u(i)
    };
  const d = (n - i.frame) / (r.frame - i.frame), h = o(i), m = o(r), p = a(i), y = a(r);
  return {
    position: {
      x: lo(h.x, m.x, d),
      y: lo(h.y, m.y, d),
      z: lo(h.z, m.z, d)
    },
    rotation: {
      x: Ed(p.x, y.x, d),
      y: Ed(p.y, y.y, d),
      z: Ed(p.z, y.z, d)
    },
    focalLength: lo(l(i), l(r), d),
    zoom: lo(c(i), c(r), d),
    focusDistance: lo(u(i), u(r), d)
  };
}
function lo(s, e, n) {
  return s + (e - s) * n;
}
function Ed(s, e, n) {
  let i = e - s;
  return i > 180 && (i -= 360), i < -180 && (i += 360), s + i * n;
}
function hy(s) {
  const { position: e, rotation: n } = s, i = n.x * Math.PI / 180, r = n.y * Math.PI / 180, o = n.z * Math.PI / 180, a = Math.cos(i), l = Math.sin(i), c = Math.cos(r), u = Math.sin(r), d = Math.cos(o), h = Math.sin(o), m = c * d + u * l * h, p = -c * h + u * l * d, y = u * a, _ = a * h, v = a * d, g = -l, S = -u * d + c * l * h, w = u * h + c * l * d, x = c * a, C = -(m * e.x + _ * e.y + S * e.z), E = -(p * e.x + v * e.y + w * e.z), P = -(y * e.x + g * e.y + x * e.z);
  return [
    [m, p, y, C],
    [_, v, g, E],
    [S, w, x, P],
    [0, 0, 0, 1]
  ];
}
function F2(s, e, n = 0.1, i = 1e3) {
  const o = gl(s.focalLength, 36) * Math.PI / 180, l = 1 / Math.tan(o / 2), c = 1 / (n - i);
  return [
    [l / e, 0, 0, 0],
    [0, l, 0, 0],
    [0, 0, (i + n) * c, 2 * i * n * c],
    [0, 0, -1, 0]
  ];
}
function fy(s, e, n) {
  const i = [];
  for (let r = 0; r < n; r++) {
    const o = al(s, e, r), a = hy(o);
    i.push({
      RT: a
    });
  }
  return { camera_poses: i };
}
function U2(s) {
  if (!s || s.length < 2) return "static";
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, r = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = r.x - i.x, c = r.y - i.y, u = r.z - i.z, d = a.y - o.y, h = 50;
  return Math.abs(u) > h ? u < 0 ? "zoom_in" : "zoom_out" : Math.abs(d) > 15 ? d > 0 ? "rotate_cw" : "rotate_ccw" : Math.abs(l) > h ? l > 0 ? "pan_right" : "pan_left" : Math.abs(c) > h ? c > 0 ? "pan_down" : "pan_up" : "static";
}
function O2(s, e, n) {
  const i = U2(e);
  if (i !== "static" && e.length <= 2)
    return { motion_camera: i };
  const r = fy(s, e, n);
  return {
    motion_camera: i,
    camera_poses: JSON.stringify(r.camera_poses)
  };
}
function bu(s) {
  if (!s || s.length < 2)
    return {
      hasPan: !1,
      panMagnitude: 0,
      hasZoom: !1,
      zoomMagnitude: 0,
      hasOrbit: !1,
      orbitMagnitude: 0,
      hasRotation: !1,
      rotationMagnitude: 0
    };
  const e = s[0], n = s[s.length - 1], i = e.position ?? { x: 0, y: 0, z: 0 }, r = n.position ?? { x: 0, y: 0, z: 0 }, o = e.orientation ?? { y: 0 }, a = n.orientation ?? { y: 0 }, l = r.x - i.x, c = r.y - i.y, u = r.z - i.z, d = a.y - o.y, h = 30, m = 50, p = 20;
  let y;
  const _ = Math.abs(l), v = Math.abs(c);
  (_ > h || v > h) && (_ > v ? y = l > 0 ? "right" : "left" : y = c > 0 ? "down" : "up");
  let g;
  Math.abs(u) > m && (g = u < 0 ? "in" : "out");
  let S;
  return Math.abs(d) > p && Math.abs(l) > h && (S = d > 0 ? "right" : "left"), {
    hasPan: !!y,
    panDirection: y,
    panMagnitude: Math.max(_, v),
    hasZoom: !!g,
    zoomDirection: g,
    zoomMagnitude: Math.abs(u),
    hasOrbit: !!S,
    orbitDirection: S,
    orbitMagnitude: Math.abs(d),
    hasRotation: Math.abs(d) > 5,
    rotationMagnitude: Math.abs(d)
  };
}
function z2(s) {
  const e = bu(s);
  let n = "Static";
  if (e.hasOrbit)
    n = e.orbitDirection === "left" ? "Orbital Left" : "Orbital Right";
  else if (e.hasZoom && e.hasPan) {
    const i = av(e.panDirection || "up"), r = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out";
    n = `Pan ${i} + ${r}`;
  } else e.hasZoom ? n = e.zoomDirection === "in" ? "Zoom In" : "Zoom Out" : e.hasPan && (n = `Pan ${av(e.panDirection || "up")}`);
  return { camera_motion: n };
}
function av(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function N2(s) {
  const e = bu(s);
  return e.hasOrbit && e.orbitMagnitude > 45 ? "orbit" : e.hasPan && e.hasZoom ? "custom" : !e.hasPan && !e.hasZoom && !e.hasOrbit ? "free1" : "custom";
}
function B2(s, e, n, i, r) {
  const o = N2(e);
  if (o !== "custom")
    return { traj_type: o };
  const a = [], l = al(s, e, 0);
  for (let c = 0; c < n; c++) {
    const u = al(s, e, c);
    a.push({
      zoom: u.zoom / l.zoom,
      x_offset: (u.position.x - l.position.x) / i,
      y_offset: (u.position.y - l.position.y) / r,
      z_offset: (u.position.z - l.position.z) / 1e3,
      pitch: u.rotation.x,
      yaw: u.rotation.y,
      roll: u.rotation.z
    });
  }
  return {
    traj_type: "custom",
    custom_trajectory: a
  };
}
function V2(s) {
  const e = bu(s);
  if (!e.hasPan && !e.hasZoom && !e.hasRotation)
    return "Static";
  if (e.hasZoom)
    return e.zoomDirection === "in" ? "Move Forward" : "Move Backward";
  if (e.hasPan)
    switch (e.panDirection) {
      case "left":
        return "Move Left";
      case "right":
        return "Move Right";
      case "up":
        return "Move Up";
      case "down":
        return "Move Down";
    }
  if (e.hasRotation) {
    const n = s[0], i = s[s.length - 1], r = n.orientation ?? { x: 0, y: 0, z: 0 }, o = i.orientation ?? { x: 0, y: 0, z: 0 }, a = o.x - r.x, l = o.y - r.y, c = o.z - r.z;
    return Math.abs(l) > Math.abs(a) && Math.abs(l) > Math.abs(c) ? l > 0 ? "Rotate Right" : "Rotate Left" : Math.abs(a) > Math.abs(c) ? a > 0 ? "Rotate Down" : "Rotate Up" : c > 0 ? "Roll Right" : "Roll Left";
  }
  return "Static";
}
function G2(s, e) {
  const n = V2(s), i = bu(s);
  let r = 0;
  return i.hasZoom ? r = Math.min(100, i.zoomMagnitude / 5) : i.hasPan ? r = Math.min(100, i.panMagnitude / 3) : i.hasRotation && (r = Math.min(100, i.rotationMagnitude * 2)), {
    motion_type: n,
    speed: Math.round(r),
    frame_length: e
  };
}
function H2(s, e, n) {
  const i = [], r = n.width / n.height;
  for (let o = 0; o < n.frameCount; o++) {
    const a = al(s, e, o), l = hy(a), c = F2(a, r);
    i.push({
      frame: o,
      timestamp: o / n.fps,
      view_matrix: l,
      projection_matrix: c,
      position: [a.position.x, a.position.y, a.position.z],
      rotation: [a.rotation.x, a.rotation.y, a.rotation.z],
      fov: gl(a.focalLength, s.filmSize),
      focal_length: a.focalLength,
      focus_distance: a.focusDistance
    });
  }
  return {
    frames: i,
    metadata: {
      width: n.width,
      height: n.height,
      fps: n.fps,
      total_frames: n.frameCount,
      camera_type: s.type,
      film_size: s.filmSize
    }
  };
}
function W2(s, e, n, i, r = 1920, o = 1080, a = 24) {
  switch (s) {
    case "motionctrl":
      return fy(e, n, i);
    case "motionctrl-svd":
      return O2(e, n, i);
    case "wan22-fun-camera":
      return z2(n);
    case "uni3c-camera":
    case "uni3c-motion":
      return B2(e, n, i, r, o);
    case "animatediff-cameractrl":
      return G2(n, i);
    default:
      return H2(e, n, {
        frameCount: i,
        width: r,
        height: o,
        fps: a
      });
  }
}
function ll(s, e, n) {
  const i = Math.max(0, Math.min(n, s.frameCount - 1));
  switch (e) {
    case "amplitude":
      return s.amplitudeEnvelope[i] ?? 0;
    case "rms":
      return s.rmsEnergy[i] ?? 0;
    case "spectralCentroid":
      return s.spectralCentroid[i] ?? 0;
    case "sub":
      return s.frequencyBands.sub[i] ?? 0;
    case "bass":
      return s.frequencyBands.bass[i] ?? 0;
    case "lowMid":
      return s.frequencyBands.lowMid[i] ?? 0;
    case "mid":
      return s.frequencyBands.mid[i] ?? 0;
    case "highMid":
      return s.frequencyBands.highMid[i] ?? 0;
    case "high":
      return s.frequencyBands.high[i] ?? 0;
    case "onsets":
      return s.onsets.includes(i) ? 1 : 0;
    default:
      return 0;
  }
}
function py(s, e) {
  const { threshold: n, minPeaksDistance: i, multiply: r } = e, o = s.map((d) => Math.min(1, d * r)), a = [];
  for (let d = 1; d < o.length - 1; d++) {
    const h = o[d - 1], m = o[d], p = o[d + 1];
    m > h && m > p && m >= n && a.push({ index: d, value: m });
  }
  const l = [];
  for (const d of a) {
    const h = l.findIndex(
      (m) => Math.abs(m.index - d.index) < i
    );
    h === -1 ? l.push(d) : d.value > l[h].value && (l[h] = d);
  }
  l.sort((d, h) => d.index - h.index);
  const c = new Array(s.length).fill(0);
  let u = 0;
  for (let d = 0; d < s.length; d++)
    l.some((m) => m.index === d) && (u = 1 - u), c[d] = u;
  return {
    indices: l.map((d) => d.index),
    values: l.map((d) => d.value),
    count: l.length,
    alternating: c
  };
}
function lv(s, e) {
  return s.onsets.includes(e);
}
function $2(s, e) {
  return s.indices.includes(e);
}
let Ar = null, cl = null, bo = null, qc = null;
function X2() {
  return Ar || (Ar = new Worker(
    new URL(
      /* @vite-ignore */
      "/assets/audioWorker-DAB3gMSK.js",
      import.meta.url
    ),
    { type: "module" }
  ), Ar.onmessage = (s) => {
    const e = s.data;
    switch (e.type) {
      case "progress":
        qc && qc({
          phase: e.payload.phase,
          progress: e.payload.progress,
          message: e.payload.message
        });
        break;
      case "complete":
        cl && (cl(e.payload), Td());
        break;
      case "error":
        bo && (bo(new Error(e.payload.message)), Td());
        break;
    }
  }, Ar.onerror = (s) => {
    console.error("[AudioWorker] Worker error:", s), bo && (bo(new Error(`Worker error: ${s.message}`)), Td());
  }), Ar;
}
function Td() {
  cl = null, bo = null, qc = null;
}
function j2() {
  Ar && Ar.postMessage({ type: "cancel" });
}
async function Y2(s, e, n = {}) {
  const i = X2();
  if (cl)
    throw new Error("Analysis already in progress. Cancel it first.");
  const r = s.getChannelData(0), o = new Float32Array(r);
  return new Promise((a, l) => {
    cl = a, bo = l, qc = n.onProgress || null, i.postMessage(
      {
        type: "analyze",
        payload: {
          channelData: o,
          sampleRate: s.sampleRate,
          fps: e
        }
      },
      [o.buffer]
      // Transfer the buffer for performance
    );
  });
}
async function q2(s, e, n = {}) {
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 0,
    message: "Decoding audio file..."
  });
  const i = await s.arrayBuffer(), r = new AudioContext();
  let o;
  try {
    o = await r.decodeAudioData(i);
  } finally {
    await r.close();
  }
  n.onProgress && n.onProgress({
    phase: "decoding",
    progress: 1,
    message: "Audio decoded successfully"
  });
  const a = await Y2(o, e, n);
  return { buffer: o, analysis: a };
}
function Ht(s, e, n = "number", i) {
  return {
    id: `prop_${s}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
    name: s,
    type: n,
    value: e,
    animated: !1,
    keyframes: [],
    group: i
  };
}
function Ad() {
  return {
    position: Ht("position", { x: 0, y: 0 }, "position"),
    anchorPoint: Ht("anchorPoint", { x: 0, y: 0 }, "position"),
    scale: Ht("scale", { x: 100, y: 100 }, "position"),
    rotation: Ht("rotation", 0, "number")
  };
}
function Z2(s, e) {
  const n = "main", i = {
    width: s,
    height: e,
    frameCount: 81,
    fps: 16,
    duration: 5.0625,
    backgroundColor: "#000000",
    autoResizeToContent: !0
  };
  return {
    version: "1.0.0",
    meta: {
      name: "Untitled",
      created: (/* @__PURE__ */ new Date()).toISOString(),
      modified: (/* @__PURE__ */ new Date()).toISOString()
    },
    // Multi-composition support
    compositions: {
      [n]: {
        id: n,
        name: "Main Comp",
        settings: i,
        layers: [],
        currentFrame: 0,
        isPrecomp: !1
      }
    },
    mainCompositionId: n,
    // Legacy alias
    composition: i,
    assets: {},
    layers: [],
    currentFrame: 0
  };
}
function K2(s, e = "amplitude", n = "particle.emissionRate") {
  return {
    id: s || `mapping_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    feature: e,
    target: n,
    targetLayerId: void 0,
    targetEmitterId: void 0,
    sensitivity: 1,
    offset: 0,
    min: 0,
    max: 1,
    smoothing: 0.3,
    invert: !1,
    threshold: 0,
    enabled: !0
  };
}
class J2 {
  constructor(e) {
    pe(this, "analysis");
    pe(this, "mappings", /* @__PURE__ */ new Map());
    pe(this, "smoothedValues", /* @__PURE__ */ new Map());
    pe(this, "peakData", null);
    this.analysis = e;
  }
  /**
   * Set peak data for peak-based features
   */
  setPeakData(e) {
    this.peakData = e;
  }
  /**
   * Add a new mapping
   */
  addMapping(e) {
    this.mappings.set(e.id, e), this.smoothedValues.set(e.id, 0);
  }
  /**
   * Remove a mapping
   */
  removeMapping(e) {
    this.mappings.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update an existing mapping
   */
  updateMapping(e, n) {
    const i = this.mappings.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a specific mapping
   */
  getMapping(e) {
    return this.mappings.get(e);
  }
  /**
   * Get all mappings
   */
  getAllMappings() {
    return Array.from(this.mappings.values());
  }
  /**
   * Get mappings for a specific layer
   */
  getMappingsForLayer(e) {
    return Array.from(this.mappings.values()).filter(
      (n) => n.targetLayerId === e || n.targetLayerId === void 0
    );
  }
  /**
   * Get mappings for a specific target parameter
   */
  getMappingsForTarget(e) {
    return Array.from(this.mappings.values()).filter((n) => n.target === e);
  }
  /**
   * Get raw feature value at frame (before mapping transforms)
   */
  getFeatureAtFrame(e, n) {
    return e === "peaks" ? this.peakData && $2(this.peakData, n) ? 1 : 0 : ll(this.analysis, e, n);
  }
  /**
   * Get the mapped value for a specific mapping at a frame
   */
  getValueAtFrame(e, n) {
    const i = this.mappings.get(e);
    if (!i || !i.enabled) return 0;
    let r = this.getFeatureAtFrame(i.feature, n);
    r < i.threshold && (r = 0), i.invert && (r = 1 - r), r *= i.sensitivity, r += i.offset, r = Math.max(i.min, Math.min(i.max, r));
    const a = (this.smoothedValues.get(e) || 0) * i.smoothing + r * (1 - i.smoothing);
    return this.smoothedValues.set(e, a), a;
  }
  /**
   * Get ALL mapped values at a frame, organized by target
   */
  getAllValuesAtFrame(e) {
    const n = /* @__PURE__ */ new Map();
    for (const i of this.mappings.values()) {
      if (!i.enabled) continue;
      const r = this.getValueAtFrame(i.id, e), o = n.get(i.target);
      o !== void 0 ? n.set(i.target, o + r) : n.set(i.target, r);
    }
    return n;
  }
  /**
   * Get mapped values for a specific layer at a frame
   */
  getValuesForLayerAtFrame(e, n) {
    const i = /* @__PURE__ */ new Map();
    for (const r of this.mappings.values()) {
      if (!r.enabled || r.targetLayerId && r.targetLayerId !== e) continue;
      const o = this.getValueAtFrame(r.id, n), a = i.get(r.target);
      a !== void 0 ? i.set(r.target, a + o) : i.set(r.target, o);
    }
    return i;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
    for (const e of this.mappings.values())
      this.smoothedValues.set(e.id, 0);
  }
  /**
   * Update analysis data
   */
  setAnalysis(e) {
    this.analysis = e, this.resetSmoothing();
  }
  /**
   * Clear all mappings
   */
  clear() {
    this.mappings.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize mappings for storage
   */
  serialize() {
    return Array.from(this.mappings.values());
  }
  /**
   * Load mappings from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addMapping(n);
  }
}
function Pd(s) {
  return {
    amplitude: "Amplitude",
    rms: "RMS Energy",
    spectralCentroid: "Brightness",
    sub: "Sub Bass (20-60Hz)",
    bass: "Bass (60-250Hz)",
    lowMid: "Low Mid (250-500Hz)",
    mid: "Mid (500-2kHz)",
    highMid: "High Mid (2-4kHz)",
    high: "High (4-20kHz)",
    onsets: "Beat Onsets",
    peaks: "Detected Peaks"
  }[s] || s;
}
function cv(s) {
  return {
    "particle.emissionRate": "Particle: Emission Rate",
    "particle.speed": "Particle: Speed",
    "particle.size": "Particle: Size",
    "particle.gravity": "Particle: Gravity",
    "particle.windStrength": "Particle: Wind Strength",
    "particle.windDirection": "Particle: Wind Direction",
    "depthflow.zoom": "Depthflow: Zoom",
    "depthflow.offsetX": "Depthflow: Offset X",
    "depthflow.offsetY": "Depthflow: Offset Y",
    "depthflow.rotation": "Depthflow: Rotation",
    "depthflow.depthScale": "Depthflow: Depth Scale",
    "path.position": "Path: Position",
    "layer.opacity": "Layer: Opacity",
    "layer.scale": "Layer: Scale",
    "layer.rotation": "Layer: Rotation",
    "layer.x": "Layer: X Position",
    "layer.y": "Layer: Y Position"
  }[s] || s;
}
function Q2() {
  return [
    "amplitude",
    "rms",
    "spectralCentroid",
    "sub",
    "bass",
    "lowMid",
    "mid",
    "highMid",
    "high",
    "onsets",
    "peaks"
  ];
}
function eT() {
  return {
    Particle: [
      "particle.emissionRate",
      "particle.speed",
      "particle.size",
      "particle.gravity",
      "particle.windStrength",
      "particle.windDirection"
    ],
    Depthflow: [
      "depthflow.zoom",
      "depthflow.offsetX",
      "depthflow.offsetY",
      "depthflow.rotation",
      "depthflow.depthScale"
    ],
    Path: ["path.position"],
    Layer: [
      "layer.opacity",
      "layer.scale",
      "layer.rotation",
      "layer.x",
      "layer.y"
    ]
  };
}
const tT = {
  movementMode: "amplitude",
  sensitivity: 1,
  smoothing: 0.3,
  release: 0.5,
  amplitudeCurve: 1,
  flipOnBeat: !0,
  beatThreshold: 0.05,
  motionBlur: !1,
  motionBlurStrength: 0.5
};
class nT {
  // For amplitude mode release tracking
  constructor(e = {}) {
    pe(this, "config");
    pe(this, "state");
    pe(this, "pathSegments", []);
    pe(this, "totalLength", 0);
    pe(this, "releaseState", 0);
    this.config = { ...tT, ...e }, this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    };
  }
  /**
   * Set the SVG path data to animate along
   */
  setPath(e) {
    this.pathSegments = this.parsePath(e), this.calculateSegmentLengths();
  }
  /**
   * Parse SVG path data into segments
   */
  parsePath(e) {
    const n = [], i = e.match(/[MLCQZ][^MLCQZ]*/gi) || [];
    let r = 0, o = 0;
    for (const a of i) {
      const l = a[0].toUpperCase(), c = a.slice(1).trim().split(/[\s,]+/).map(Number).filter((u) => !isNaN(u));
      switch (l) {
        case "M":
          r = c[0] || 0, o = c[1] || 0, n.push({
            type: "M",
            points: [r, o],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
        case "L":
          n.push({
            type: "L",
            points: [r, o, c[0], c[1]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[0], o = c[1];
          break;
        case "C":
          n.push({
            type: "C",
            points: [r, o, c[0], c[1], c[2], c[3], c[4], c[5]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[4], o = c[5];
          break;
        case "Q":
          n.push({
            type: "Q",
            points: [r, o, c[0], c[1], c[2], c[3]],
            length: 0,
            startT: 0,
            endT: 0
          }), r = c[2], o = c[3];
          break;
        case "Z":
          const u = n.find((d) => d.type === "M");
          u && n.push({
            type: "L",
            points: [r, o, u.points[0], u.points[1]],
            length: 0,
            startT: 0,
            endT: 0
          });
          break;
      }
    }
    return n;
  }
  /**
   * Calculate lengths for each segment
   */
  calculateSegmentLengths() {
    let e = 0;
    for (const n of this.pathSegments) {
      switch (n.type) {
        case "M":
          n.length = 0;
          break;
        case "L":
          n.length = this.lineLength(n.points);
          break;
        case "C":
          n.length = this.bezierLength(n.points, 3);
          break;
        case "Q":
          n.length = this.bezierLength(n.points, 2);
          break;
      }
      n.startT = e, e += n.length, n.endT = e;
    }
    if (this.totalLength = e, this.totalLength > 0)
      for (const n of this.pathSegments)
        n.startT /= this.totalLength, n.endT /= this.totalLength;
  }
  lineLength(e) {
    const n = e[2] - e[0], i = e[3] - e[1];
    return Math.sqrt(n * n + i * i);
  }
  bezierLength(e, n) {
    let r = 0, o = e[0], a = e[1];
    for (let l = 1; l <= 20; l++) {
      const c = l / 20, { x: u, y: d } = this.getBezierPoint(e, c, n), h = u - o, m = d - a;
      r += Math.sqrt(h * h + m * m), o = u, a = d;
    }
    return r;
  }
  getBezierPoint(e, n, i) {
    if (i === 2) {
      const r = 1 - n;
      return {
        x: r * r * e[0] + 2 * r * n * e[2] + n * n * e[4],
        y: r * r * e[1] + 2 * r * n * e[3] + n * n * e[5]
      };
    } else {
      const r = 1 - n, o = r * r, a = n * n;
      return {
        x: o * r * e[0] + 3 * o * n * e[2] + 3 * r * a * e[4] + a * n * e[6],
        y: o * r * e[1] + 3 * o * n * e[3] + 3 * r * a * e[5] + a * n * e[7]
      };
    }
  }
  /**
   * Update position based on audio value
   */
  update(e, n) {
    this.state.previousPosition = this.state.position;
    const i = this.state.smoothedValue * this.config.smoothing + e * (1 - this.config.smoothing);
    this.state.smoothedValue = i, this.config.movementMode === "amplitude" ? this.updateAmplitudeMode(i) : this.updateAccumulateMode(i, n);
    const r = this.getPositionOnPath(this.state.position);
    return this.state.x = r.x, this.state.y = r.y, this.state.angle = r.angle, { ...this.state };
  }
  updateAmplitudeMode(e) {
    let n = Math.pow(e, this.config.amplitudeCurve);
    if (n > this.releaseState)
      this.releaseState = n;
    else {
      const r = 1 - this.config.release * 0.95;
      this.releaseState *= r;
    }
    const i = Math.max(n, this.releaseState);
    this.state.position = Math.max(0, Math.min(1, i * this.config.sensitivity));
  }
  updateAccumulateMode(e, n) {
    this.config.flipOnBeat && n && e > this.config.beatThreshold && (this.state.direction *= -1);
    const i = e * this.config.sensitivity * 0.02 * this.state.direction;
    let r = this.state.position + i;
    r > 1 ? (r = 2 - r, this.state.direction = -1) : r < 0 && (r = -r, this.state.direction = 1), this.state.position = Math.max(0, Math.min(1, r));
  }
  /**
   * Get x, y, angle at position t along path
   */
  getPositionOnPath(e) {
    if (e = Math.max(0, Math.min(1, e)), this.pathSegments.length === 0)
      return { x: 0, y: 0, angle: 0 };
    let n = this.pathSegments[0];
    for (const u of this.pathSegments)
      if (u.type !== "M" && e >= u.startT && e <= u.endT) {
        n = u;
        break;
      }
    if (n.type === "M")
      return { x: n.points[0], y: n.points[1], angle: 0 };
    const i = n.endT > n.startT ? (e - n.startT) / (n.endT - n.startT) : 0;
    let r, o, a, l;
    switch (n.type) {
      case "L":
        r = n.points[0] + (n.points[2] - n.points[0]) * i, o = n.points[1] + (n.points[3] - n.points[1]) * i, a = n.points[2] - n.points[0], l = n.points[3] - n.points[1];
        break;
      case "Q": {
        const u = this.getBezierPoint(n.points, i, 2);
        r = u.x, o = u.y;
        const d = 1 - i;
        a = 2 * d * (n.points[2] - n.points[0]) + 2 * i * (n.points[4] - n.points[2]), l = 2 * d * (n.points[3] - n.points[1]) + 2 * i * (n.points[5] - n.points[3]);
        break;
      }
      case "C": {
        const u = this.getBezierPoint(n.points, i, 3);
        r = u.x, o = u.y;
        const d = 1 - i, h = d * d, m = i * i;
        a = 3 * h * (n.points[2] - n.points[0]) + 6 * d * i * (n.points[4] - n.points[2]) + 3 * m * (n.points[6] - n.points[4]), l = 3 * h * (n.points[3] - n.points[1]) + 6 * d * i * (n.points[5] - n.points[3]) + 3 * m * (n.points[7] - n.points[5]);
        break;
      }
      default:
        r = 0, o = 0, a = 1, l = 0;
    }
    const c = Math.atan2(l, a);
    return { x: r, y: o, angle: c };
  }
  /**
   * Get motion blur trail points
   */
  getMotionBlurTrail(e = 5) {
    if (!this.config.motionBlur) return [];
    const n = [], i = this.state.previousPosition, r = this.state.position;
    for (let o = 0; o <= e; o++) {
      const a = i + (r - i) * (o / e), l = this.getPositionOnPath(a), c = o / e * this.config.motionBlurStrength;
      n.push({ x: l.x, y: l.y, opacity: c });
    }
    return n;
  }
  /**
   * Reset animator state
   */
  reset() {
    this.state = {
      position: 0,
      direction: 1,
      previousPosition: 0,
      smoothedValue: 0,
      x: 0,
      y: 0,
      angle: 0
    }, this.releaseState = 0;
  }
  /**
   * Get current config
   */
  getConfig() {
    return { ...this.config };
  }
  /**
   * Update config
   */
  setConfig(e) {
    Object.assign(this.config, e);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
}
function iT(s) {
  switch (s) {
    case "number":
    case "angle":
      return "number";
    case "point":
      return "position";
    case "color":
      return "color";
    case "checkbox":
    case "dropdown":
    case "layer":
      return "enum";
    default:
      return "number";
  }
}
const Zc = {
  // Blur & Sharpen
  "gaussian-blur": {
    name: "Gaussian Blur",
    category: "blur-sharpen",
    description: "Smooth, bell-curve blur",
    parameters: [
      { name: "Blurriness", type: "number", defaultValue: 10, min: 0, max: 250, animatable: !0 },
      { name: "Blur Dimensions", type: "dropdown", defaultValue: "both", options: [
        { label: "Horizontal and Vertical", value: "both" },
        { label: "Horizontal", value: "horizontal" },
        { label: "Vertical", value: "vertical" }
      ], animatable: !1 },
      { name: "Repeat Edge Pixels", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  "directional-blur": {
    name: "Directional Blur",
    category: "blur-sharpen",
    description: "Blur in a specific direction",
    parameters: [
      { name: "Direction", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Blur Length", type: "number", defaultValue: 10, min: 0, max: 500, animatable: !0 }
    ]
  },
  "radial-blur": {
    name: "Radial Blur",
    category: "blur-sharpen",
    description: "Spin or zoom blur effect",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 10, min: 0, max: 100, animatable: !0 },
      { name: "Center", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Type", type: "dropdown", defaultValue: "spin", options: [
        { label: "Spin", value: "spin" },
        { label: "Zoom", value: "zoom" }
      ], animatable: !1 },
      { name: "Antialiasing", type: "dropdown", defaultValue: "high", options: [
        { label: "Low", value: "low" },
        { label: "Medium", value: "medium" },
        { label: "High", value: "high" }
      ], animatable: !1 }
    ]
  },
  sharpen: {
    name: "Sharpen",
    category: "blur-sharpen",
    description: "Increase image contrast at edges",
    parameters: [
      { name: "Sharpen Amount", type: "number", defaultValue: 50, min: 0, max: 500, animatable: !0 }
    ]
  },
  "unsharp-mask": {
    name: "Unsharp Mask",
    category: "blur-sharpen",
    description: "Professional sharpening with radius control",
    parameters: [
      { name: "Amount", type: "number", defaultValue: 100, min: 1, max: 500, animatable: !0 },
      { name: "Radius", type: "number", defaultValue: 1, min: 0.1, max: 250, step: 0.1, animatable: !0 },
      { name: "Threshold", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 }
    ]
  },
  // Color Correction
  "brightness-contrast": {
    name: "Brightness & Contrast",
    category: "color-correction",
    description: "Adjust brightness and contrast",
    parameters: [
      { name: "Brightness", type: "number", defaultValue: 0, min: -150, max: 150, animatable: !0 },
      { name: "Contrast", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Use Legacy", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  "hue-saturation": {
    name: "Hue/Saturation",
    category: "color-correction",
    description: "Adjust hue, saturation, and lightness",
    parameters: [
      { name: "Channel Control", type: "dropdown", defaultValue: "master", options: [
        { label: "Master", value: "master" },
        { label: "Reds", value: "reds" },
        { label: "Yellows", value: "yellows" },
        { label: "Greens", value: "greens" },
        { label: "Cyans", value: "cyans" },
        { label: "Blues", value: "blues" },
        { label: "Magentas", value: "magentas" }
      ], animatable: !1 },
      { name: "Master Hue", type: "angle", defaultValue: 0, animatable: !0, group: "Master" },
      { name: "Master Saturation", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Master Lightness", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Master" },
      { name: "Colorize", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  curves: {
    name: "Curves",
    category: "color-correction",
    description: "Precise tonal adjustment with curves",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" }
      ], animatable: !1 }
      // Note: Actual curve control would be a custom component
    ]
  },
  levels: {
    name: "Levels",
    category: "color-correction",
    description: "Adjust input/output levels",
    parameters: [
      { name: "Channel", type: "dropdown", defaultValue: "rgb", options: [
        { label: "RGB", value: "rgb" },
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" }
      ], animatable: !1 },
      { name: "Input Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Input White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 },
      { name: "Gamma", type: "number", defaultValue: 1, min: 0.1, max: 10, step: 0.01, animatable: !0 },
      { name: "Output Black", type: "number", defaultValue: 0, min: 0, max: 255, animatable: !0 },
      { name: "Output White", type: "number", defaultValue: 255, min: 0, max: 255, animatable: !0 }
    ]
  },
  "color-balance": {
    name: "Color Balance",
    category: "color-correction",
    description: "Adjust color balance by tonal range",
    parameters: [
      { name: "Shadow Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Shadow Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Shadows" },
      { name: "Midtone Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Midtone Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Midtones" },
      { name: "Highlight Red", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Green", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Highlight Blue", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0, group: "Highlights" },
      { name: "Preserve Luminosity", type: "checkbox", defaultValue: !0, animatable: !1 }
    ]
  },
  tint: {
    name: "Tint",
    category: "color-correction",
    description: "Map black and white to colors",
    parameters: [
      { name: "Map Black To", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Map White To", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Amount to Tint", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Distort
  transform: {
    name: "Transform",
    category: "distort",
    description: "Transform layer with anchor point control",
    parameters: [
      { name: "Anchor Point", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Position", type: "point", defaultValue: { x: 0.5, y: 0.5 }, animatable: !0 },
      { name: "Scale Height", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Scale Width", type: "number", defaultValue: 100, min: -1e4, max: 1e4, animatable: !0 },
      { name: "Skew", type: "number", defaultValue: 0, min: -85, max: 85, animatable: !0 },
      { name: "Skew Axis", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Rotation", type: "angle", defaultValue: 0, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  warp: {
    name: "Warp",
    category: "distort",
    description: "Apply warp distortion",
    parameters: [
      { name: "Warp Style", type: "dropdown", defaultValue: "arc", options: [
        { label: "Arc", value: "arc" },
        { label: "Arc Lower", value: "arc-lower" },
        { label: "Arc Upper", value: "arc-upper" },
        { label: "Arch", value: "arch" },
        { label: "Bulge", value: "bulge" },
        { label: "Shell Lower", value: "shell-lower" },
        { label: "Shell Upper", value: "shell-upper" },
        { label: "Flag", value: "flag" },
        { label: "Wave", value: "wave" },
        { label: "Fish", value: "fish" },
        { label: "Rise", value: "rise" },
        { label: "Fisheye", value: "fisheye" },
        { label: "Inflate", value: "inflate" },
        { label: "Squeeze", value: "squeeze" },
        { label: "Twist", value: "twist" }
      ], animatable: !1 },
      { name: "Bend", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Horizontal Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 },
      { name: "Vertical Distortion", type: "number", defaultValue: 0, min: -100, max: 100, animatable: !0 }
    ]
  },
  "displacement-map": {
    name: "Displacement Map",
    category: "distort",
    description: "Displace pixels using a map layer",
    parameters: [
      { name: "Displacement Map Layer", type: "layer", defaultValue: null, animatable: !1 },
      { name: "Use For Horizontal", type: "dropdown", defaultValue: "red", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Horizontal", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 },
      { name: "Use For Vertical", type: "dropdown", defaultValue: "green", options: [
        { label: "Red", value: "red" },
        { label: "Green", value: "green" },
        { label: "Blue", value: "blue" },
        { label: "Alpha", value: "alpha" },
        { label: "Luminance", value: "luminance" }
      ], animatable: !1 },
      { name: "Max Vertical", type: "number", defaultValue: 0, min: -4e3, max: 4e3, animatable: !0 }
    ]
  },
  // Generate
  fill: {
    name: "Fill",
    category: "generate",
    description: "Fill layer with a solid color",
    parameters: [
      { name: "Fill Mask", type: "dropdown", defaultValue: "all", options: [
        { label: "All Masks", value: "all" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Color", type: "color", defaultValue: { r: 255, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Horizontal Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Vertical Feather", type: "number", defaultValue: 0, min: 0, max: 500, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 100, min: 0, max: 100, animatable: !0 }
    ]
  },
  "gradient-ramp": {
    name: "Gradient Ramp",
    category: "generate",
    description: "Generate a color gradient",
    parameters: [
      { name: "Start of Ramp", type: "point", defaultValue: { x: 0, y: 0.5 }, animatable: !0 },
      { name: "Start Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 1 }, animatable: !0 },
      { name: "End of Ramp", type: "point", defaultValue: { x: 1, y: 0.5 }, animatable: !0 },
      { name: "End Color", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Ramp Shape", type: "dropdown", defaultValue: "linear", options: [
        { label: "Linear Ramp", value: "linear" },
        { label: "Radial Ramp", value: "radial" }
      ], animatable: !1 },
      { name: "Ramp Scatter", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 },
      { name: "Blend With Original", type: "number", defaultValue: 0, min: 0, max: 100, animatable: !0 }
    ]
  },
  // Stylize
  glow: {
    name: "Glow",
    category: "stylize",
    description: "Add a glow effect",
    parameters: [
      { name: "Glow Threshold", type: "number", defaultValue: 60, min: 0, max: 100, animatable: !0 },
      { name: "Glow Radius", type: "number", defaultValue: 25, min: 0, max: 500, animatable: !0 },
      { name: "Glow Intensity", type: "number", defaultValue: 1, min: 0, max: 10, step: 0.1, animatable: !0 },
      { name: "Composite Original", type: "dropdown", defaultValue: "on-top", options: [
        { label: "On Top", value: "on-top" },
        { label: "Behind", value: "behind" },
        { label: "None", value: "none" }
      ], animatable: !1 },
      { name: "Glow Colors", type: "dropdown", defaultValue: "original", options: [
        { label: "Original Colors", value: "original" },
        { label: "A & B Colors", value: "ab" }
      ], animatable: !1 },
      { name: "Color A", type: "color", defaultValue: { r: 255, g: 255, b: 255, a: 1 }, animatable: !0 },
      { name: "Color B", type: "color", defaultValue: { r: 255, g: 128, b: 0, a: 1 }, animatable: !0 }
    ]
  },
  "drop-shadow": {
    name: "Drop Shadow",
    category: "stylize",
    description: "Add a drop shadow",
    parameters: [
      { name: "Shadow Color", type: "color", defaultValue: { r: 0, g: 0, b: 0, a: 0.5 }, animatable: !0 },
      { name: "Opacity", type: "number", defaultValue: 50, min: 0, max: 100, animatable: !0 },
      { name: "Direction", type: "angle", defaultValue: 135, animatable: !0 },
      { name: "Distance", type: "number", defaultValue: 5, min: 0, max: 1e3, animatable: !0 },
      { name: "Softness", type: "number", defaultValue: 5, min: 0, max: 250, animatable: !0 },
      { name: "Shadow Only", type: "checkbox", defaultValue: !1, animatable: !1 }
    ]
  },
  // Noise & Grain
  "fractal-noise": {
    name: "Fractal Noise",
    category: "noise-grain",
    description: "Generate fractal noise pattern",
    parameters: [
      { name: "Fractal Type", type: "dropdown", defaultValue: "basic", options: [
        { label: "Basic", value: "basic" },
        { label: "Turbulent Basic", value: "turbulent-basic" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Turbulent Soft", value: "turbulent-soft" }
      ], animatable: !1 },
      { name: "Noise Type", type: "dropdown", defaultValue: "block", options: [
        { label: "Block", value: "block" },
        { label: "Linear", value: "linear" },
        { label: "Soft Linear", value: "soft-linear" },
        { label: "Spline", value: "spline" }
      ], animatable: !1 },
      { name: "Invert", type: "checkbox", defaultValue: !1, animatable: !1 },
      { name: "Contrast", type: "number", defaultValue: 100, min: 0, max: 400, animatable: !0 },
      { name: "Brightness", type: "number", defaultValue: 0, min: -200, max: 200, animatable: !0 },
      { name: "Scale", type: "number", defaultValue: 100, min: 10, max: 1e4, animatable: !0 },
      { name: "Complexity", type: "number", defaultValue: 6, min: 1, max: 20, animatable: !0 },
      { name: "Evolution", type: "angle", defaultValue: 0, animatable: !0 }
    ]
  }
}, Vh = {
  "blur-sharpen": { label: "Blur & Sharpen", icon: "B", description: "Blur and sharpen effects" },
  "color-correction": { label: "Color Correction", icon: "C", description: "Color adjustment effects" },
  distort: { label: "Distort", icon: "D", description: "Distortion effects" },
  generate: { label: "Generate", icon: "G", description: "Generate patterns and fills" },
  keying: { label: "Keying", icon: "K", description: "Chromakey and luma key" },
  matte: { label: "Matte", icon: "M", description: "Matte manipulation" },
  "noise-grain": { label: "Noise & Grain", icon: "N", description: "Add or remove noise" },
  perspective: { label: "Perspective", icon: "P", description: "3D perspective effects" },
  stylize: { label: "Stylize", icon: "S", description: "Stylization effects" },
  time: { label: "Time", icon: "T", description: "Time-based effects" },
  transition: { label: "Transition", icon: "Tr", description: "Transition effects" },
  utility: { label: "Utility", icon: "U", description: "Utility effects" }
};
function sT(s) {
  const e = Zc[s];
  if (!e) return null;
  const n = {};
  return e.parameters.forEach((i, r) => {
    const o = i.name.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    n[o] = {
      id: `${s}-${o}-${r}`,
      name: i.name,
      type: iT(i.type),
      value: i.defaultValue,
      animated: !1,
      keyframes: []
    };
  }), {
    id: `effect-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    effectKey: s,
    name: e.name,
    category: e.category,
    enabled: !0,
    expanded: !0,
    parameters: n
  };
}
const rT = [
  {
    id: "fade-in",
    name: "Fade In",
    category: "Fade",
    description: "Fade from transparent to opaque",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 0, outHandle: { x: 0.4, y: 0 } },
        { time: 1, value: 100, inHandle: { x: 0.6, y: 1 } }
      ]
    }]
  },
  {
    id: "fade-out",
    name: "Fade Out",
    category: "Fade",
    description: "Fade from opaque to transparent",
    keyframes: [{
      property: "opacity",
      keyframes: [
        { time: 0, value: 100, outHandle: { x: 0.4, y: 1 } },
        { time: 1, value: 0, inHandle: { x: 0.6, y: 0 } }
      ]
    }]
  },
  {
    id: "scale-up",
    name: "Scale Up",
    category: "Scale",
    description: "Scale from small to full size",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 100, y: 100 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "bounce-in",
    name: "Bounce In",
    category: "Scale",
    description: "Scale up with bounce effect",
    keyframes: [{
      property: "scale",
      keyframes: [
        { time: 0, value: { x: 0, y: 0 } },
        { time: 0.6, value: { x: 110, y: 110 } },
        { time: 0.8, value: { x: 95, y: 95 } },
        { time: 1, value: { x: 100, y: 100 } }
      ]
    }]
  },
  {
    id: "slide-left",
    name: "Slide Left",
    category: "Position",
    description: "Slide in from right",
    keyframes: [{
      property: "position",
      keyframes: [
        { time: 0, value: { x: 1.5, y: 0.5 }, outHandle: { x: 0.25, y: 0.1 } },
        { time: 1, value: { x: 0.5, y: 0.5 }, inHandle: { x: 0.25, y: 1 } }
      ]
    }]
  },
  {
    id: "rotate-in",
    name: "Rotate In",
    category: "Rotation",
    description: "Rotate from 0 to 360 degrees",
    keyframes: [{
      property: "rotation",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 360 }
      ]
    }]
  },
  {
    id: "typewriter",
    name: "Typewriter",
    category: "Text",
    description: "Reveal text character by character",
    keyframes: [{
      property: "textReveal",
      keyframes: [
        { time: 0, value: 0 },
        { time: 1, value: 100 }
      ]
    }]
  }
];
class oT {
  constructor() {
    pe(this, "drivers", /* @__PURE__ */ new Map());
    pe(this, "smoothedValues", /* @__PURE__ */ new Map());
    pe(this, "audioAnalysis", null);
    pe(this, "propertyGetter", null);
  }
  /**
   * Set the audio analysis data for audio-driven properties
   */
  setAudioAnalysis(e) {
    this.audioAnalysis = e;
  }
  /**
   * Set the property getter function (provided by store/engine)
   */
  setPropertyGetter(e) {
    this.propertyGetter = e;
  }
  /**
   * Add a new driver
   * Returns false if adding would create a circular dependency
   */
  addDriver(e) {
    return e.sourceType === "property" && e.sourceLayerId && e.sourceProperty && this.wouldCreateCycle(e) ? (console.warn("[PropertyDriverSystem] Cannot add driver: would create circular dependency"), !1) : (this.drivers.set(e.id, e), this.smoothedValues.set(e.id, 0), !0);
  }
  /**
   * Check if adding a driver would create a circular dependency
   */
  wouldCreateCycle(e) {
    if (e.sourceType !== "property" || !e.sourceLayerId || !e.sourceProperty) return !1;
    const n = /* @__PURE__ */ new Set(), i = `${e.targetLayerId}:${e.targetProperty}`, r = (o, a) => {
      const l = `${o}:${a}`;
      if (l === i) return !0;
      if (n.has(l)) return !1;
      n.add(l);
      for (const c of this.drivers.values())
        if (c.sourceType === "property" && !(c.targetLayerId !== o || c.targetProperty !== a) && !(!c.sourceLayerId || !c.sourceProperty) && r(c.sourceLayerId, c.sourceProperty))
          return !0;
      return !1;
    };
    return r(e.sourceLayerId, e.sourceProperty);
  }
  /**
   * Remove a driver
   */
  removeDriver(e) {
    this.drivers.delete(e), this.smoothedValues.delete(e);
  }
  /**
   * Update a driver
   */
  updateDriver(e, n) {
    const i = this.drivers.get(e);
    i && Object.assign(i, n);
  }
  /**
   * Get a driver by ID
   */
  getDriver(e) {
    return this.drivers.get(e);
  }
  /**
   * Get all drivers
   */
  getAllDrivers() {
    return Array.from(this.drivers.values());
  }
  /**
   * Get drivers for a specific target layer
   */
  getDriversForLayer(e) {
    return Array.from(this.drivers.values()).filter((n) => n.targetLayerId === e);
  }
  /**
   * Get drivers for a specific target property
   */
  getDriversForProperty(e, n) {
    return Array.from(this.drivers.values()).filter(
      (i) => i.targetLayerId === e && i.targetProperty === n && i.enabled
    );
  }
  /**
   * Evaluate a driver at a given frame
   */
  evaluateDriver(e, n, i) {
    if (!e.enabled) return i;
    let r = this.getSourceValue(e, n);
    return r === null ? i : (r = this.applyTransforms(e, r), this.blendValue(i, r, e.blendMode, e.blendAmount));
  }
  /**
   * Get the source value for a driver
   */
  getSourceValue(e, n) {
    switch (e.sourceType) {
      case "property":
        return this.getPropertySourceValue(e, n);
      case "audio":
        return this.getAudioSourceValue(e, n);
      case "time":
        return n;
      default:
        return null;
    }
  }
  /**
   * Get value from another property
   */
  getPropertySourceValue(e, n) {
    return !this.propertyGetter || !e.sourceLayerId || !e.sourceProperty ? null : this.propertyGetter(e.sourceLayerId, e.sourceProperty, n);
  }
  /**
   * Get value from audio analysis
   */
  getAudioSourceValue(e, n) {
    if (!this.audioAnalysis || !e.audioFeature)
      return null;
    let i = ll(this.audioAnalysis, e.audioFeature, n);
    return e.audioThreshold !== void 0 && (e.audioAboveThreshold ? i = i > e.audioThreshold ? i : 0 : i = i >= e.audioThreshold ? i : 0), i;
  }
  /**
   * Apply the transform chain to a value
   */
  applyTransforms(e, n) {
    for (const i of e.transforms)
      n = this.applyTransform(e.id, i, n);
    return n;
  }
  /**
   * Apply a single transform
   */
  applyTransform(e, n, i) {
    switch (n.type) {
      case "scale":
        return i * (n.factor ?? 1);
      case "offset":
        return i + (n.amount ?? 0);
      case "clamp":
        return Math.max(n.min ?? -1 / 0, Math.min(n.max ?? 1 / 0, i));
      case "smooth": {
        const r = this.smoothedValues.get(e) ?? i, o = n.smoothing ?? 0.5, a = r * o + i * (1 - o);
        return this.smoothedValues.set(e, a), a;
      }
      case "invert":
        return 1 - i;
      case "remap": {
        const r = n.inMin ?? 0, o = n.inMax ?? 1, a = n.outMin ?? 0, l = n.outMax ?? 1, c = (i - r) / (o - r);
        return a + c * (l - a);
      }
      case "threshold":
        return i > (n.threshold ?? 0.5) ? 1 : 0;
      case "oscillate": {
        const r = n.frequency ?? 1, o = n.amplitude ?? 1, a = n.phase ?? 0;
        return Math.sin((i * r + a) * Math.PI * 2) * o;
      }
      default:
        return i;
    }
  }
  /**
   * Blend driven value with base value
   */
  blendValue(e, n, i, r) {
    let o;
    switch (i) {
      case "replace":
        o = n;
        break;
      case "add":
        o = e + n;
        break;
      case "multiply":
        o = e * n;
        break;
      default:
        o = n;
    }
    return e * (1 - r) + o * r;
  }
  /**
   * Evaluate ALL drivers for a layer at a frame
   * Returns a map of property -> driven value
   */
  evaluateLayerDrivers(e, n, i) {
    const r = /* @__PURE__ */ new Map(), o = this.getDriversForLayer(e);
    for (const a of o) {
      if (!a.enabled) continue;
      const l = i.get(a.targetProperty) ?? 0, c = this.evaluateDriver(a, n, l), u = r.get(a.targetProperty);
      u !== void 0 ? r.set(a.targetProperty, u + c - l) : r.set(a.targetProperty, c);
    }
    return r;
  }
  /**
   * Reset smoothing state
   */
  resetSmoothing() {
    this.smoothedValues.clear();
  }
  /**
   * Clear all drivers
   */
  clear() {
    this.drivers.clear(), this.smoothedValues.clear();
  }
  /**
   * Serialize drivers for storage
   */
  serialize() {
    return Array.from(this.drivers.values());
  }
  /**
   * Load drivers from serialized data
   */
  deserialize(e) {
    this.clear();
    for (const n of e)
      this.addDriver(n);
  }
}
function my(s, e, n = "property") {
  return {
    id: `driver_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    name: "New Driver",
    enabled: !0,
    targetLayerId: s,
    targetProperty: e,
    sourceType: n,
    transforms: [],
    blendMode: "add",
    blendAmount: 1
  };
}
function aT(s, e, n, i = {}) {
  const r = my(s, e, "audio");
  return r.audioFeature = n, r.audioThreshold = i.threshold ?? 0, r.audioAboveThreshold = i.threshold !== void 0, i.scale !== void 0 && i.scale !== 1 && r.transforms.push({ type: "scale", factor: i.scale }), i.offset !== void 0 && i.offset !== 0 && r.transforms.push({ type: "offset", amount: i.offset }), i.smoothing !== void 0 && i.smoothing > 0 && r.transforms.push({ type: "smooth", smoothing: i.smoothing }), r;
}
function lT(s, e, n, i, r = {}) {
  const o = my(s, e, "property");
  return o.sourceLayerId = n, o.sourceProperty = i, o.blendMode = r.blendMode ?? "add", r.scale !== void 0 && r.scale !== 1 && o.transforms.push({ type: "scale", factor: r.scale }), r.offset !== void 0 && r.offset !== 0 && o.transforms.push({ type: "offset", amount: r.offset }), o;
}
const cT = {
  enabled: !0,
  snapToGrid: !0,
  snapToKeyframes: !0,
  snapToBeats: !0,
  snapToPeaks: !0,
  snapToLayerBounds: !0,
  snapToPlayhead: !0,
  threshold: 8,
  // 8 pixels snap threshold
  gridInterval: 5
  // Snap to every 5 frames by default
};
function uT(s, e, n, i) {
  var l, c;
  if (!e.enabled)
    return null;
  const r = [], o = e.threshold / n;
  if (e.snapToGrid) {
    const u = Math.round(s / e.gridInterval) * e.gridInterval, d = Math.abs(s - u);
    d <= o && r.push({
      frame: u,
      type: "frame",
      distance: d * n
    });
  }
  if (e.snapToKeyframes && i.layers)
    for (const u of i.layers)
      u.id !== i.selectedLayerId && dT(u, s, o, n, r);
  if (e.snapToBeats && ((l = i.audioAnalysis) != null && l.onsets))
    for (const u of i.audioAnalysis.onsets) {
      const d = Math.abs(s - u);
      d <= o && r.push({
        frame: u,
        type: "beat",
        distance: d * n
      });
    }
  if (e.snapToPeaks && ((c = i.peakData) != null && c.indices))
    for (const u of i.peakData.indices) {
      const d = Math.abs(s - u);
      d <= o && r.push({
        frame: u,
        type: "peak",
        distance: d * n
      });
    }
  if (e.snapToLayerBounds && i.layers)
    for (const u of i.layers) {
      if (u.id === i.selectedLayerId) continue;
      const d = Math.abs(s - u.inPoint), h = Math.abs(s - u.outPoint);
      d <= o && r.push({
        frame: u.inPoint,
        type: "layer-in",
        distance: d * n
      }), h <= o && r.push({
        frame: u.outPoint,
        type: "layer-out",
        distance: h * n
      });
    }
  if (e.snapToPlayhead && i.currentFrame !== void 0) {
    const u = Math.abs(s - i.currentFrame);
    u <= o && u > 0 && r.push({
      frame: i.currentFrame,
      type: "playhead",
      distance: u * n
    });
  }
  if (r.length === 0)
    return null;
  const a = {
    playhead: 5,
    beat: 4,
    peak: 4,
    keyframe: 3,
    "layer-in": 2,
    "layer-out": 2,
    frame: 1
  };
  return r.sort((u, d) => {
    const h = u.distance - d.distance;
    return Math.abs(h) < 0.5 ? a[d.type] - a[u.type] : h;
  }), r[0];
}
function dT(s, e, n, i, r) {
  const o = [
    s.transform.position,
    s.transform.scale,
    s.transform.rotation,
    s.opacity,
    ...s.properties
  ];
  for (const a of o)
    if (!(!a.animated || !a.keyframes))
      for (const l of a.keyframes) {
        const c = Math.abs(e - l.frame);
        c <= n && (r.some((u) => u.frame === l.frame && u.type === "keyframe") || r.push({
          frame: l.frame,
          type: "keyframe",
          distance: c * i
        }));
      }
}
function hT(s) {
  return (s == null ? void 0 : s.onsets) ?? [];
}
function fT(s) {
  return (s == null ? void 0 : s.indices) ?? [];
}
const nn = /* @__PURE__ */ xx("compositor", {
  state: () => ({
    project: Z2(1024, 1024),
    activeCompositionId: "main",
    openCompositionIds: ["main"],
    comfyuiNodeId: null,
    sourceImage: null,
    depthMap: null,
    isPlaying: !1,
    playbackRequestId: null,
    playbackStartTime: null,
    playbackStartFrame: 0,
    selectedLayerIds: [],
    selectedKeyframeIds: [],
    selectedPropertyPath: null,
    currentTool: "select",
    graphEditorVisible: !1,
    historyStack: [],
    historyIndex: -1,
    audioBuffer: null,
    audioAnalysis: null,
    audioFile: null,
    audioLoadingState: "idle",
    audioLoadingProgress: 0,
    audioLoadingPhase: "",
    audioLoadingError: null,
    audioMappings: /* @__PURE__ */ new Map(),
    peakData: null,
    audioReactiveMappings: [],
    audioReactiveMapper: null,
    pathAnimators: /* @__PURE__ */ new Map(),
    // Camera system
    cameras: /* @__PURE__ */ new Map(),
    cameraKeyframes: /* @__PURE__ */ new Map(),
    activeCameraId: null,
    viewportState: dy(),
    viewOptions: P2(),
    // Property driver system
    propertyDriverSystem: null,
    propertyDrivers: [],
    // Timeline snapping
    snapConfig: { ...cT }
  }),
  getters: {
    // Active composition helper
    activeComposition: (s) => s.project.compositions[s.activeCompositionId] || null,
    // Project info - now uses active composition
    hasProject: (s) => s.sourceImage !== null,
    width(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.width) || 1024;
    },
    height(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.height) || 1024;
    },
    frameCount(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.frameCount) || 81;
    },
    fps(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.fps) || 16;
    },
    duration(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.settings.duration) || 5;
    },
    // Current frame - per composition
    currentFrame(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.currentFrame) || 0;
    },
    currentTime(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return e ? e.currentFrame / e.settings.fps : 0;
    },
    // Layers - from active composition
    layers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return (e == null ? void 0 : e.layers) || [];
    },
    visibleLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.visible);
    },
    // Selection
    selectedLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => s.selectedLayerIds.includes(n.id));
    },
    selectedLayer(s) {
      if (s.selectedLayerIds.length !== 1) return null;
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).find((n) => n.id === s.selectedLayerIds[0]) || null;
    },
    // All compositions for tabs
    allCompositions: (s) => Object.values(s.project.compositions),
    openCompositions(s) {
      return s.openCompositionIds.map((e) => s.project.compositions[e]).filter(Boolean);
    },
    // Assets
    assets: (s) => s.project.assets,
    // History
    canUndo: (s) => s.historyIndex > 0,
    canRedo: (s) => s.historyIndex < s.historyStack.length - 1,
    // Camera
    activeCamera: (s) => s.activeCameraId && s.cameras.get(s.activeCameraId) || null,
    allCameras: (s) => Array.from(s.cameras.values()),
    cameraLayers(s) {
      const e = s.project.compositions[s.activeCompositionId];
      return ((e == null ? void 0 : e.layers) || []).filter((n) => n.type === "camera");
    }
  },
  actions: {
    // ============================================================
    // HELPER METHODS
    // ============================================================
    /**
     * Get the layers array for the active composition (mutable reference)
     */
    getActiveCompLayers() {
      const s = this.project.compositions[this.activeCompositionId];
      return (s == null ? void 0 : s.layers) || [];
    },
    /**
     * Get the active composition (mutable reference)
     */
    getActiveComp() {
      return this.project.compositions[this.activeCompositionId] || null;
    },
    // ============================================================
    // COMPOSITION MANAGEMENT
    // ============================================================
    /**
     * Create a new composition
     */
    createComposition(s, e, n = !1) {
      const i = `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, r = this.project.compositions[this.activeCompositionId], o = {
        width: (e == null ? void 0 : e.width) ?? (r == null ? void 0 : r.settings.width) ?? 1024,
        height: (e == null ? void 0 : e.height) ?? (r == null ? void 0 : r.settings.height) ?? 1024,
        frameCount: (e == null ? void 0 : e.frameCount) ?? (r == null ? void 0 : r.settings.frameCount) ?? 81,
        fps: (e == null ? void 0 : e.fps) ?? (r == null ? void 0 : r.settings.fps) ?? 16,
        duration: 0,
        backgroundColor: (e == null ? void 0 : e.backgroundColor) ?? "#000000",
        autoResizeToContent: (e == null ? void 0 : e.autoResizeToContent) ?? !0
      };
      o.duration = o.frameCount / o.fps;
      const a = {
        id: i,
        name: s,
        settings: o,
        layers: [],
        currentFrame: 0,
        isPrecomp: n
      };
      return this.project.compositions[i] = a, this.openCompositionIds.includes(i) || this.openCompositionIds.push(i), this.activeCompositionId = i, console.log("[Weyl] Created composition:", s, i), a;
    },
    /**
     * Delete a composition
     */
    deleteComposition(s) {
      if (s === this.project.mainCompositionId)
        return console.warn("[Weyl] Cannot delete main composition"), !1;
      if (!this.project.compositions[s]) return !1;
      delete this.project.compositions[s];
      const n = this.openCompositionIds.indexOf(s);
      return n >= 0 && this.openCompositionIds.splice(n, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[0] || this.project.mainCompositionId), console.log("[Weyl] Deleted composition:", s), !0;
    },
    /**
     * Switch to a different composition (tab)
     */
    switchComposition(s) {
      if (!this.project.compositions[s]) {
        console.warn("[Weyl] Composition not found:", s);
        return;
      }
      this.openCompositionIds.includes(s) || this.openCompositionIds.push(s), this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.activeCompositionId = s, console.log("[Weyl] Switched to composition:", s);
    },
    /**
     * Close a composition tab
     */
    closeCompositionTab(s) {
      if (this.openCompositionIds.length <= 1) {
        console.warn("[Weyl] Cannot close the last tab");
        return;
      }
      const e = this.openCompositionIds.indexOf(s);
      e >= 0 && this.openCompositionIds.splice(e, 1), this.activeCompositionId === s && (this.activeCompositionId = this.openCompositionIds[Math.max(0, e - 1)]);
    },
    /**
     * Rename a composition
     */
    renameComposition(s, e) {
      const n = this.project.compositions[s];
      n && (n.name = e);
    },
    /**
     * Update composition settings
     */
    updateCompositionSettings(s, e) {
      const n = this.project.compositions[s];
      if (!n) return;
      const i = n.settings.frameCount;
      if (Object.assign(n.settings, e), n.settings.duration = n.settings.frameCount / n.settings.fps, e.frameCount && e.frameCount > i)
        for (const r of n.layers)
          r.outPoint === i - 1 && (r.outPoint = e.frameCount - 1);
      s === this.project.mainCompositionId && Object.assign(this.project.composition, n.settings);
    },
    /**
     * Get a composition by ID
     */
    getComposition(s) {
      return this.project.compositions[s] || null;
    },
    /**
     * Pre-compose selected layers into a new composition
     */
    precomposeSelectedLayers(s) {
      if (this.selectedLayerIds.length === 0)
        return console.warn("[Weyl] No layers selected for pre-compose"), null;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return null;
      const n = this.createComposition(
        s || "Pre-comp",
        e.settings,
        !0
      ), i = e.layers.filter(
        (l) => this.selectedLayerIds.includes(l.id)
      ), r = Math.min(...i.map((l) => l.inPoint));
      for (const l of i) {
        l.inPoint -= r, l.outPoint -= r;
        const c = e.layers.indexOf(l);
        c >= 0 && e.layers.splice(c, 1), n.layers.push(l);
      }
      const o = Math.max(...n.layers.map((l) => l.outPoint));
      n.settings.frameCount = o + 1, n.settings.duration = n.settings.frameCount / n.settings.fps;
      const a = {
        id: `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        name: n.name,
        type: "precomp",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        inPoint: r,
        outPoint: r + n.settings.frameCount - 1,
        parentId: null,
        transform: Ad(),
        opacity: Ht("opacity", 100, "number"),
        properties: [],
        effects: [],
        blendMode: "normal",
        motionBlur: !1,
        data: {
          compositionId: n.id,
          timeRemapEnabled: !1,
          collapseTransformations: !1
        }
      };
      return e.layers.push(a), this.selectedLayerIds = [], this.activeCompositionId = e.id, console.log("[Weyl] Pre-composed layers into:", n.name), n;
    },
    // ============================================================
    // COMFYUI INTEGRATION
    // ============================================================
    /**
     * Load inputs from ComfyUI node
     */
    loadInputs(s) {
      this.comfyuiNodeId = s.node_id, this.sourceImage = s.source_image, this.depthMap = s.depth_map;
      const e = this.project.compositions[this.activeCompositionId];
      if (!e) return;
      const n = e.settings.frameCount;
      if (e.settings.width = s.width, e.settings.height = s.height, e.settings.frameCount = s.frame_count, e.settings.duration = s.frame_count / e.settings.fps, this.project.composition.width = s.width, this.project.composition.height = s.height, this.project.composition.frameCount = s.frame_count, this.project.composition.duration = s.frame_count / this.project.composition.fps, s.frame_count > n)
        for (const i of e.layers)
          i.outPoint === n - 1 && (i.outPoint = s.frame_count - 1);
      s.source_image && (this.project.assets.source_image = {
        id: "source_image",
        type: "image",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.source_image
      }), s.depth_map && (this.project.assets.depth_map = {
        id: "depth_map",
        type: "depth_map",
        source: "comfyui_node",
        nodeId: s.node_id,
        width: s.width,
        height: s.height,
        data: s.depth_map
      }), e && (e.currentFrame = 0), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), console.log("[Weyl] Loaded inputs from ComfyUI:", {
        width: s.width,
        height: s.height,
        frameCount: s.frame_count
      }), this.pushHistory();
    },
    /**
     * Create a new layer
     */
    createLayer(s, e) {
      const n = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      let i = null;
      switch (s) {
        case "text":
          i = {
            text: "Text",
            fontFamily: "Arial",
            fontSize: 72,
            fontWeight: "400",
            fontStyle: "normal",
            fill: "#ffffff",
            stroke: "",
            strokeWidth: 0,
            tracking: 0,
            letterSpacing: 0,
            lineHeight: 1.2,
            textAlign: "left",
            pathLayerId: null,
            pathReversed: !1,
            pathPerpendicularToPath: !0,
            pathForceAlignment: !1,
            pathFirstMargin: 0,
            pathLastMargin: 0,
            pathOffset: 0,
            pathAlign: "left"
          };
          break;
        case "solid":
          i = {
            color: "#808080",
            width: this.project.composition.width,
            height: this.project.composition.height
          };
          break;
        case "null":
          i = {
            size: 40
          };
          break;
        case "spline":
          i = {
            pathData: "",
            controlPoints: [],
            closed: !1,
            stroke: "#00ff00",
            strokeWidth: 2,
            fill: ""
          };
          break;
        case "particles":
          i = {
            systemConfig: {
              maxParticles: 1e3,
              gravity: 0,
              windStrength: 0,
              windDirection: 0,
              warmupPeriod: 0,
              respectMaskBoundary: !1,
              boundaryBehavior: "kill",
              friction: 0.01
            },
            emitters: [{
              id: "emitter_1",
              name: "Emitter 1",
              x: this.project.composition.width / 2,
              y: this.project.composition.height / 2,
              direction: -90,
              spread: 30,
              speed: 5,
              speedVariance: 0.2,
              size: 10,
              sizeVariance: 0.3,
              color: [255, 255, 255],
              emissionRate: 10,
              initialBurst: 0,
              particleLifetime: 60,
              lifetimeVariance: 0.2,
              enabled: !0,
              burstOnBeat: !1,
              burstCount: 20
            }],
            gravityWells: [],
            vortices: [],
            modulations: [],
            renderOptions: {
              blendMode: "additive",
              renderTrails: !1,
              trailLength: 10,
              trailOpacityFalloff: 0.9,
              particleShape: "circle",
              glowEnabled: !1,
              glowRadius: 5,
              glowIntensity: 0.5,
              motionBlur: !1,
              motionBlurStrength: 0.5,
              motionBlurSamples: 4,
              connections: {
                enabled: !1,
                maxDistance: 100,
                maxConnections: 3,
                lineWidth: 1,
                lineOpacity: 0.5,
                fadeByDistance: !0
              }
            }
          };
          break;
        case "depthflow":
          i = {
            sourceLayerId: null,
            depthLayerId: null,
            config: {
              preset: "static",
              zoom: 1,
              offsetX: 0,
              offsetY: 0,
              rotation: 0,
              depthScale: 1,
              focusDepth: 0.5,
              dollyZoom: 0,
              orbitRadius: 0,
              orbitSpeed: 1,
              swingAmplitude: 0,
              swingFrequency: 1,
              edgeDilation: 0,
              inpaintEdges: !1
            }
          };
          break;
        case "light":
          i = {
            lightType: "point",
            color: "#ffffff",
            intensity: 100,
            radius: 500,
            falloff: "none",
            falloffDistance: 500,
            castShadows: !1,
            shadowDarkness: 100,
            shadowDiffusion: 0
          };
          break;
        case "camera":
          i = {
            cameraId: null,
            isActiveCamera: !1
          };
          break;
        case "image":
          i = {
            assetId: null,
            fit: "contain"
          };
          break;
        case "video":
          i = {
            assetId: null,
            loop: !1,
            startTime: 0,
            speed: 1
          };
          break;
      }
      let r;
      (s === "video" || s === "audio") && (r = {
        level: Ht("Audio Levels", 0, "number")
        // 0dB default
      });
      const o = this.getActiveComp(), a = this.getActiveCompLayers(), l = {
        id: n,
        name: e || `${s.charAt(0).toUpperCase() + s.slice(1)} ${a.length + 1}`,
        type: s,
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !1,
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((o == null ? void 0 : o.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Ht("opacity", 100, "number"),
        transform: Ad(),
        audio: r,
        properties: [],
        effects: [],
        data: i
      };
      return s === "camera" && console.warn("Use createCameraLayer() for camera layers"), a.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), l;
    },
    /**
     * Delete a layer
     */
    deleteLayer(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex((i) => i.id === s);
      n !== -1 && (e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((i) => i !== s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Duplicate a layer
     */
    duplicateLayer(s) {
      const e = this.getActiveCompLayers(), n = e.find((o) => o.id === s);
      if (!n) return null;
      const i = JSON.parse(JSON.stringify(n));
      if (i.id = crypto.randomUUID(), i.name = n.name + " Copy", i.transform)
        for (const o of Object.keys(i.transform)) {
          const a = i.transform[o];
          a != null && a.keyframes && (a.keyframes = a.keyframes.map((l) => ({
            ...l,
            id: crypto.randomUUID()
          })));
        }
      if (i.properties)
        for (const o of i.properties)
          o.keyframes && (o.keyframes = o.keyframes.map((a) => ({
            ...a,
            id: crypto.randomUUID()
          })));
      const r = e.findIndex((o) => o.id === s);
      return e.splice(r, 0, i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), i;
    },
    /**
     * Update layer properties
     */
    updateLayer(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update layer-specific data (e.g., text content, image path, etc.)
     */
    updateLayerData(s, e) {
      const n = this.getActiveCompLayers().find((i) => i.id === s);
      !n || !n.data || (Object.assign(n.data, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Add a control point to a spline layer
     */
    addSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      i.controlPoints || (i.controlPoints = []), i.controlPoints.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update a spline control point
     */
    updateSplineControlPoint(s, e, n) {
      var a;
      const i = this.getActiveCompLayers().find((l) => l.id === s);
      if (!i || i.type !== "spline" || !i.data) return;
      const o = (a = i.data.controlPoints) == null ? void 0 : a.find((l) => l.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Delete a spline control point
     */
    deleteSplineControlPoint(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "spline" || !n.data) return;
      const i = n.data;
      if (!i.controlPoints) return;
      const r = i.controlPoints.findIndex((o) => o.id === e);
      r >= 0 && (i.controlPoints.splice(r, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle 3D mode for a layer
     */
    toggleLayer3D(s) {
      const e = this.getActiveCompLayers().find((n) => n.id === s);
      if (e) {
        if (e.threeD = !e.threeD, e.threeD) {
          const n = e.transform, i = n.position.value;
          n.position.value = { x: i.x, y: i.y, z: i.z ?? 0 }, n.position.type = "vector3";
          const r = n.anchorPoint.value;
          n.anchorPoint.value = { x: r.x, y: r.y, z: r.z ?? 0 }, n.anchorPoint.type = "vector3";
          const o = n.scale.value;
          n.scale.value = { x: o.x, y: o.y, z: o.z ?? 100 }, n.scale.type = "vector3", n.orientation || (n.orientation = Ht("orientation", { x: 0, y: 0, z: 0 }, "vector3")), n.rotationX || (n.rotationX = Ht("rotationX", 0, "number")), n.rotationY || (n.rotationY = Ht("rotationY", 0, "number")), n.rotationZ || (n.rotationZ = Ht("rotationZ", 0, "number"), n.rotationZ.value = n.rotation.value);
        } else
          e.transform.rotationZ && (e.transform.rotation.value = e.transform.rotationZ.value);
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Reorder layers
     */
    moveLayer(s, e) {
      const n = this.getActiveCompLayers(), i = n.findIndex((o) => o.id === s);
      if (i === -1) return;
      const [r] = n.splice(i, 1);
      n.splice(e, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Selection
     */
    selectLayer(s, e = !1) {
      e ? this.selectedLayerIds.includes(s) || this.selectedLayerIds.push(s) : this.selectedLayerIds = [s];
    },
    deselectLayer(s) {
      this.selectedLayerIds = this.selectedLayerIds.filter((e) => e !== s);
    },
    /**
     * Set a layer's parent for parenting/hierarchy
     */
    setLayerParent(s, e) {
      const n = this.getActiveCompLayers(), i = n.find((r) => r.id === s);
      if (i && e !== s) {
        if (e) {
          const r = (a) => {
            const l = n.filter((u) => u.parentId === a);
            let c = l.map((u) => u.id);
            for (const u of l)
              c = c.concat(r(u.id));
            return c;
          };
          if (new Set(r(s)).has(e)) {
            console.warn("[Store] Cannot set parent: would create circular reference");
            return;
          }
        }
        i.parentId = e, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
      }
    },
    clearSelection() {
      this.selectedLayerIds = [], this.selectedKeyframeIds = [], this.selectedPropertyPath = null;
    },
    /**
     * Select a property path for graph editor focus
     */
    selectProperty(s) {
      this.selectedPropertyPath = s;
    },
    /**
     * Playback controls
     */
    play() {
      if (this.isPlaying) return;
      const s = this.getActiveComp();
      s && (this.isPlaying = !0, this.playbackStartTime = performance.now(), this.playbackStartFrame = s.currentFrame, this.playbackLoop());
    },
    pause() {
      this.isPlaying = !1, this.playbackRequestId !== null && (cancelAnimationFrame(this.playbackRequestId), this.playbackRequestId = null);
    },
    togglePlayback() {
      this.isPlaying ? this.pause() : this.play();
    },
    /**
     * Animation loop for playback
     */
    playbackLoop() {
      if (!this.isPlaying) return;
      const s = this.getActiveComp();
      if (!s) return;
      const e = performance.now() - (this.playbackStartTime || 0), n = s.settings.fps, i = s.settings.frameCount, r = Math.floor(e / 1e3 * n);
      let o = this.playbackStartFrame + r;
      o >= i && (o = 0, this.playbackStartFrame = 0, this.playbackStartTime = performance.now()), s.currentFrame = o, this.playbackRequestId = requestAnimationFrame(() => this.playbackLoop());
    },
    setFrame(s) {
      const e = this.getActiveComp();
      e && (e.currentFrame = Math.max(0, Math.min(s, e.settings.frameCount - 1)));
    },
    nextFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame < s.settings.frameCount - 1 && s.currentFrame++;
    },
    prevFrame() {
      const s = this.getActiveComp();
      s && s.currentFrame > 0 && s.currentFrame--;
    },
    goToStart() {
      const s = this.getActiveComp();
      s && (s.currentFrame = 0);
    },
    goToEnd() {
      const s = this.getActiveComp();
      s && (s.currentFrame = s.settings.frameCount - 1);
    },
    /**
     * Tool selection
     */
    setTool(s) {
      this.currentTool = s;
    },
    /**
     * History management
     */
    pushHistory() {
      this.historyIndex < this.historyStack.length - 1 && (this.historyStack = this.historyStack.slice(0, this.historyIndex + 1));
      const s = JSON.parse(JSON.stringify(this.project));
      this.historyStack.push(s), this.historyIndex = this.historyStack.length - 1;
      const e = 50;
      this.historyStack.length > e && (this.historyStack = this.historyStack.slice(-e), this.historyIndex = this.historyStack.length - 1);
    },
    undo() {
      this.historyIndex <= 0 || (this.historyIndex--, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    redo() {
      this.historyIndex >= this.historyStack.length - 1 || (this.historyIndex++, this.project = JSON.parse(JSON.stringify(this.historyStack[this.historyIndex])));
    },
    /**
     * Project serialization
     */
    exportProject() {
      return JSON.stringify(this.project, null, 2);
    },
    importProject(s) {
      try {
        const e = JSON.parse(s);
        this.project = e, this.pushHistory();
      } catch (e) {
        console.error("[Weyl] Failed to import project:", e);
      }
    },
    /**
     * Toggle graph editor visibility
     */
    toggleGraphEditor() {
      this.graphEditorVisible = !this.graphEditorVisible;
    },
    /**
     * Get interpolated value for any animatable property at current frame
     */
    getInterpolatedValue(s) {
      var e;
      return on(s, ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0);
    },
    /**
     * Add a keyframe to a property
     */
    addKeyframe(s, e, n, i) {
      var u, d, h;
      const r = i ?? ((u = this.getActiveComp()) == null ? void 0 : u.currentFrame) ?? 0;
      console.log("[Store] addKeyframe called:", { layerId: s, propertyName: e, value: n, frame: r });
      const o = this.getActiveCompLayers().find((m) => m.id === s);
      if (!o)
        return console.log("[Store] addKeyframe: layer not found"), null;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : e === "opacity" ? a = o.opacity : a = o.properties.find((m) => m.name === e), !a)
        return console.log("[Store] addKeyframe: property not found:", e), null;
      a.animated = !0;
      const l = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: r,
        value: n,
        interpolation: "linear",
        inHandle: { frame: 0, value: 0, enabled: !1 },
        outHandle: { frame: 0, value: 0, enabled: !1 },
        controlMode: "smooth"
      }, c = a.keyframes.findIndex((m) => m.frame === r);
      return c >= 0 ? (a.keyframes[c] = l, console.log("[Store] addKeyframe: replaced existing keyframe at frame", ((d = this.getActiveComp()) == null ? void 0 : d.currentFrame) ?? 0)) : (a.keyframes.push(l), a.keyframes.sort((m, p) => m.frame - p.frame), console.log("[Store] addKeyframe: added new keyframe at frame", ((h = this.getActiveComp()) == null ? void 0 : h.currentFrame) ?? 0, "total keyframes:", a.keyframes.length)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), l;
    },
    /**
     * Remove a keyframe
     */
    removeKeyframe(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((a) => a.name === e), !r) return;
      const o = r.keyframes.findIndex((a) => a.id === n);
      o >= 0 && (r.keyframes.splice(o, 1), r.keyframes.length === 0 && (r.animated = !1)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set a property's value (for direct editing in timeline)
     */
    setPropertyValue(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return;
      let r;
      if (e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((o) => o.name === e), !!r) {
        if (r.value = n, r.animated && r.keyframes.length > 0) {
          const o = r.keyframes.find((a) => {
            var l;
            return a.frame === (((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0);
          });
          o && (o.value = n);
        }
        this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
      }
    },
    /**
     * Set a property's animated state
     */
    setPropertyAnimated(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return;
      let r;
      e === "position" || e === "transform.position" ? r = i.transform.position : e === "scale" || e === "transform.scale" ? r = i.transform.scale : e === "rotation" || e === "transform.rotation" ? r = i.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? r = i.transform.anchorPoint : e === "opacity" ? r = i.opacity : r = i.properties.find((o) => o.name === e), r && (r.animated = n, n && r.keyframes.length === 0 && this.addKeyframe(s, e, r.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Move a keyframe to a new frame
     */
    moveKeyframe(s, e, n, i) {
      const r = this.getActiveCompLayers().find((c) => c.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((c) => c.name === e), !o) return;
      const a = o.keyframes.find((c) => c.id === n);
      if (!a) return;
      const l = o.keyframes.find((c) => c.frame === i && c.id !== n);
      l && (o.keyframes = o.keyframes.filter((c) => c.id !== l.id)), a.frame = i, o.keyframes.sort((c, u) => c.frame - u.frame), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Set keyframe interpolation type
     */
    setKeyframeInterpolation(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : e === "opacity" ? o = r.opacity : o = r.properties.find((l) => l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (a.interpolation = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Update keyframe frame position and/or value
     */
    updateKeyframe(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r) return;
      let o;
      if (e === "position" || e === "transform.position" ? o = r.transform.position : e === "scale" || e === "transform.scale" ? o = r.transform.scale : e === "rotation" || e === "transform.rotation" ? o = r.transform.rotation : e === "opacity" ? o = r.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? o = r.transform.anchorPoint : o = r.properties.find((l) => l.id === e || l.name === e), !o) return;
      const a = o.keyframes.find((l) => l.id === n);
      a && (i.frame !== void 0 && (a.frame = i.frame, o.keyframes.sort((l, c) => l.frame - c.frame)), i.value !== void 0 && (a.value = i.value), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set keyframe bezier handle
     */
    setKeyframeHandle(s, e, n, i, r) {
      const o = this.getActiveCompLayers().find((c) => c.id === s);
      if (!o) return;
      let a;
      if (e === "position" || e === "transform.position" ? a = o.transform.position : e === "scale" || e === "transform.scale" ? a = o.transform.scale : e === "rotation" || e === "transform.rotation" ? a = o.transform.rotation : e === "opacity" ? a = o.opacity : e === "anchorPoint" || e === "transform.anchorPoint" ? a = o.transform.anchorPoint : a = o.properties.find((c) => c.id === e || c.name === e), !a) return;
      const l = a.keyframes.find((c) => c.id === n);
      l && (i === "in" ? l.inHandle = { ...r } : l.outHandle = { ...r }, r.enabled && l.interpolation === "linear" && (l.interpolation = "bezier"), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Create a text layer with proper data structure
     */
    createTextLayer(s = "Text") {
      const e = this.createLayer("text", s.substring(0, 20)), n = {
        text: s,
        fontFamily: "Arial",
        fontSize: 72,
        fontWeight: "400",
        fontStyle: "normal",
        fill: "#ffffff",
        stroke: "",
        strokeWidth: 0,
        // Character Properties (AE Animator defaults)
        tracking: 0,
        lineSpacing: 0,
        lineAnchor: 0,
        characterOffset: 0,
        characterValue: 0,
        blur: { x: 0, y: 0 },
        // Paragraph (legacy aliases)
        letterSpacing: 0,
        lineHeight: 1.2,
        textAlign: "left",
        // Path Options (Full AE Parity)
        pathLayerId: null,
        pathReversed: !1,
        pathPerpendicularToPath: !0,
        pathForceAlignment: !1,
        pathFirstMargin: 0,
        pathLastMargin: 0,
        pathOffset: 0,
        pathAlign: "left",
        // More Options (AE Advanced)
        anchorPointGrouping: "character",
        groupingAlignment: { x: 0, y: 0 },
        fillAndStroke: "fill-over-stroke",
        interCharacterBlending: "normal",
        // 3D Text
        perCharacter3D: !1
      };
      return e.data = n, e.properties.push(Ht("Font Size", 72, "number", "Text")), e.properties.push(Ht("Fill Color", "#ffffff", "color", "Text")), e.properties.push(Ht("Stroke Color", "#000000", "color", "Text")), e.properties.push(Ht("Stroke Width", 0, "number", "Text")), e.properties.push(Ht("Path Offset", 0, "number", "Path Options")), e.properties.push(Ht("First Margin", 0, "number", "Path Options")), e.properties.push(Ht("Last Margin", 0, "number", "Path Options")), e.properties.push(Ht("Grouping Alignment", { x: 0, y: 0 }, "position", "More Options")), e.properties.push(Ht("Tracking", 0, "number", "Advanced")), e.properties.push(Ht("Line Spacing", 0, "number", "Advanced")), e.properties.push(Ht("Character Offset", 0, "number", "Advanced")), e.properties.push(Ht("Character Value", 0, "number", "Advanced")), e.properties.push(Ht("Blur", { x: 0, y: 0 }, "position", "Advanced")), e;
    },
    /**
     * Create a spline layer with proper data structure
     */
    createSplineLayer() {
      const s = this.createLayer("spline"), e = {
        pathData: "",
        controlPoints: [],
        closed: !1,
        stroke: "#00ff00",
        strokeWidth: 2,
        fill: ""
      };
      return s.data = e, s;
    },
    // ============================================================
    // PARTICLE SYSTEM LAYER ACTIONS
    // ============================================================
    /**
     * Create a particle system layer
     */
    createParticleLayer() {
      const s = this.createLayer("particles", "Particle System"), e = {
        systemConfig: {
          maxParticles: 1e4,
          gravity: 0,
          windStrength: 0,
          windDirection: 0,
          warmupPeriod: 0,
          respectMaskBoundary: !1,
          boundaryBehavior: "kill",
          friction: 0.01
        },
        emitters: [{
          id: `emitter_${Date.now()}`,
          name: "Emitter 1",
          x: 0.5,
          y: 0.5,
          direction: 270,
          spread: 30,
          speed: 330,
          speedVariance: 50,
          size: 17,
          sizeVariance: 5,
          color: [255, 255, 255],
          emissionRate: 10,
          initialBurst: 0,
          particleLifetime: 60,
          lifetimeVariance: 10,
          enabled: !0,
          burstOnBeat: !1,
          burstCount: 20
        }],
        gravityWells: [],
        vortices: [],
        modulations: [{
          id: `mod_${Date.now()}`,
          emitterId: "*",
          property: "opacity",
          startValue: 1,
          endValue: 0,
          easing: "linear"
        }],
        renderOptions: {
          blendMode: "additive",
          renderTrails: !1,
          trailLength: 5,
          trailOpacityFalloff: 0.7,
          particleShape: "circle",
          glowEnabled: !1,
          glowRadius: 10,
          glowIntensity: 0.5,
          motionBlur: !1,
          motionBlurStrength: 0.5,
          motionBlurSamples: 8,
          connections: {
            enabled: !1,
            maxDistance: 100,
            maxConnections: 3,
            lineWidth: 1,
            lineOpacity: 0.5,
            fadeByDistance: !0
          }
        },
        turbulenceFields: [],
        subEmitters: []
      };
      return s.data = e, s;
    },
    /**
     * Update particle layer data
     */
    updateParticleLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Add emitter to particle layer
     */
    addParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      n.data.emitters.push(e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Update particle emitter
     */
    updateParticleEmitter(s, e, n) {
      const i = this.getActiveCompLayers().find((a) => a.id === s);
      if (!i || i.type !== "particles") return;
      const o = i.data.emitters.find((a) => a.id === e);
      o && (Object.assign(o, n), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Remove particle emitter
     */
    removeParticleEmitter(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "particles") return;
      const i = n.data;
      i.emitters = i.emitters.filter((r) => r.id !== e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // DEPTHFLOW LAYER ACTIONS
    // ============================================================
    /**
     * Create a depthflow parallax layer
     */
    createDepthflowLayer(s = "", e = "") {
      const n = this.createLayer("depthflow", "Depthflow"), i = {
        sourceLayerId: s,
        depthLayerId: e,
        config: {
          preset: "zoom_in",
          zoom: 1,
          offsetX: 0,
          offsetY: 0,
          rotation: 0,
          depthScale: 1,
          focusDepth: 0.5,
          dollyZoom: 0,
          orbitRadius: 0.1,
          orbitSpeed: 360,
          swingAmplitude: 0.1,
          swingFrequency: 1,
          edgeDilation: 5,
          inpaintEdges: !0
        },
        animatedZoom: Ht("zoom", 1, "number"),
        animatedOffsetX: Ht("offsetX", 0, "number"),
        animatedOffsetY: Ht("offsetY", 0, "number"),
        animatedRotation: Ht("rotation", 0, "number"),
        animatedDepthScale: Ht("depthScale", 1, "number")
      };
      return n.data = i, n;
    },
    /**
     * Update depthflow config
     */
    updateDepthflowConfig(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "depthflow") return;
      const i = n.data;
      Object.assign(i.config, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // VIDEO LAYER ACTIONS
    // ============================================================
    /**
     * Create a video layer from a file
     * Automatically resizes composition to match video dimensions and duration
     *
     * @param file - Video file to import
     * @param autoResizeComposition - If true, resize composition to match video (default: true for first video)
     * @returns The created layer
     */
    async createVideoLayer(s, e = !0) {
      let n;
      try {
        n = URL.createObjectURL(s);
      } catch {
        throw new Error("Failed to create URL for video file");
      }
      let i;
      try {
        i = await E2(n);
      } catch (c) {
        throw URL.revokeObjectURL(n), new Error(`Failed to load video metadata: ${c.message}`);
      }
      const r = `video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, o = {
        id: r,
        type: "video",
        source: "file",
        width: i.width,
        height: i.height,
        data: n,
        // Video-specific metadata
        duration: i.duration,
        frameCount: i.frameCount,
        fps: i.fps,
        hasAudio: i.hasAudio
      };
      if (this.project.assets[r] = o, e) {
        const c = T2(i, this.project.composition.fps);
        console.log("[Weyl] Auto-resizing composition for video:", {
          originalWidth: this.project.composition.width,
          originalHeight: this.project.composition.height,
          originalFrameCount: this.project.composition.frameCount,
          newWidth: c.width,
          newHeight: c.height,
          newFrameCount: c.frameCount,
          videoDuration: i.duration
        }), this.project.composition.width = c.width, this.project.composition.height = c.height, this.project.composition.frameCount = c.frameCount, this.project.composition.duration = c.frameCount / this.project.composition.fps;
      }
      const a = this.createLayer("video", s.name.replace(/\.[^.]+$/, "")), l = {
        assetId: r,
        loop: !1,
        pingPong: !1,
        startTime: 0,
        endTime: void 0,
        speed: 1,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        frameBlending: "none",
        audioEnabled: i.hasAudio,
        audioLevel: 100,
        posterFrame: 0
      };
      if (a.data = l, !e) {
        const c = Math.ceil(i.duration * this.project.composition.fps);
        a.outPoint = Math.min(c - 1, this.project.composition.frameCount - 1);
      }
      return this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), console.log("[Weyl] Created video layer:", {
        layerId: a.id,
        assetId: r,
        dimensions: `${i.width}x${i.height}`,
        duration: `${i.duration.toFixed(2)}s`,
        frameCount: i.frameCount,
        hasAudio: i.hasAudio
      }), a;
    },
    /**
     * Update video layer data
     */
    updateVideoLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Handle video metadata loaded callback from engine
     * Called by LayerManager when a video finishes loading
     */
    onVideoMetadataLoaded(s, e) {
      const n = this.getActiveCompLayers().find((o) => o.id === s);
      if (!n || n.type !== "video") return;
      const i = n.data;
      if (!i.assetId) return;
      const r = this.project.assets[i.assetId];
      r && (r.width = e.width, r.height = e.height, r.duration = e.duration, r.frameCount = e.frameCount, r.fps = e.fps, r.hasAudio = e.hasAudio), console.log("[Weyl] Video metadata loaded:", { layerId: s, metadata: e });
    },
    /**
     * Resize composition settings
     * Used for manual resize or when importing video
     */
    resizeComposition(s, e, n) {
      const i = this.getActiveComp();
      if (!i) return;
      const r = i.settings.frameCount;
      if (i.settings.width = s, i.settings.height = e, this.project.composition.width = s, this.project.composition.height = e, n !== void 0 && (i.settings.frameCount = n, i.settings.duration = n / i.settings.fps, this.project.composition.frameCount = n, this.project.composition.duration = n / this.project.composition.fps, n > r))
        for (const o of i.layers)
          o.outPoint === r - 1 && (o.outPoint = n - 1);
      i.currentFrame >= i.settings.frameCount && (i.currentFrame = i.settings.frameCount - 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), console.log("[Weyl] Composition resized:", {
        width: s,
        height: e,
        frameCount: i.settings.frameCount
      });
    },
    // ============================================================
    // PRECOMP LAYER ACTIONS
    // ============================================================
    /**
     * Create a precomp layer referencing another composition
     * (For future multi-composition architecture)
     */
    createPrecompLayer(s, e) {
      const n = this.createLayer("precomp", e || "Precomp"), i = {
        compositionId: s,
        timeRemapEnabled: !1,
        timeRemap: void 0,
        collapseTransformations: !1,
        overrideFrameRate: !1,
        frameRate: void 0
      };
      return n.data = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), n;
    },
    /**
     * Update precomp layer data
     */
    updatePrecompLayerData(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || n.type !== "precomp") return;
      const i = n.data;
      Object.assign(i, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    // ============================================================
    // EFFECT ACTIONS
    // ============================================================
    /**
     * Add effect to layer
     */
    addEffectToLayer(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n) return;
      const i = sT(e);
      i && (n.effects || (n.effects = []), n.effects.push(i), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Remove effect from layer
     */
    removeEffectFromLayer(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.findIndex((r) => r.id === e);
      i >= 0 && (n.effects.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory());
    },
    /**
     * Update effect parameter value
     */
    updateEffectParameter(s, e, n, i) {
      const r = this.getActiveCompLayers().find((a) => a.id === s);
      if (!r || !r.effects) return;
      const o = r.effects.find((a) => a.id === e);
      !o || !o.parameters[n] || (o.parameters[n].value = i, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Toggle effect parameter animation state
     */
    setEffectParamAnimated(s, e, n, i) {
      const r = this.getActiveCompLayers().find((l) => l.id === s);
      if (!r || !r.effects) return;
      const o = r.effects.find((l) => l.id === e);
      if (!o || !o.parameters[n]) return;
      const a = o.parameters[n];
      a.animated = i, i && (!a.keyframes || a.keyframes.length === 0) && (a.keyframes = [{
        id: `kf_${Date.now()}`,
        frame: this.currentFrame,
        value: a.value,
        interpolation: "linear",
        inHandle: { frame: -5, value: 0, enabled: !1 },
        outHandle: { frame: 5, value: 0, enabled: !1 },
        controlMode: "smooth"
      }]), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Toggle effect enabled state
     */
    toggleEffect(s, e) {
      const n = this.getActiveCompLayers().find((r) => r.id === s);
      if (!n || !n.effects) return;
      const i = n.effects.find((r) => r.id === e);
      i && (i.enabled = !i.enabled, this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Reorder effects in stack
     */
    reorderEffects(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i || !i.effects || e < 0 || e >= i.effects.length || n < 0 || n >= i.effects.length) return;
      const [r] = i.effects.splice(e, 1);
      i.effects.splice(n, 0, r), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get evaluated effect parameter value at a given frame
     */
    getEffectParameterValue(s, e, n, i) {
      var c;
      const r = this.getActiveCompLayers().find((u) => u.id === s);
      if (!r || !r.effects) return null;
      const o = r.effects.find((u) => u.id === e);
      if (!o || !o.parameters[n]) return null;
      const a = o.parameters[n], l = i ?? ((c = this.getActiveComp()) == null ? void 0 : c.currentFrame) ?? 0;
      return a.animated && a.keyframes.length > 0 ? on(a, l) : a.value;
    },
    // ============================================================
    // CAMERA ACTIONS
    // ============================================================
    /**
     * Create a new camera and corresponding layer
     * Returns both the camera and the layer
     */
    createCameraLayer(s) {
      const e = this.getActiveComp(), n = this.getActiveCompLayers(), i = `camera_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, r = s || `Camera ${this.cameras.size + 1}`, o = uy(
        i,
        (e == null ? void 0 : e.settings.width) || 1024,
        (e == null ? void 0 : e.settings.height) || 1024
      );
      o.name = r, this.cameras.set(i, o), this.activeCameraId || (this.activeCameraId = i);
      const a = `layer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, l = {
        id: a,
        name: r,
        type: "camera",
        visible: !0,
        locked: !1,
        solo: !1,
        threeD: !0,
        // Cameras are always 3D
        motionBlur: !1,
        inPoint: 0,
        outPoint: ((e == null ? void 0 : e.settings.frameCount) || 81) - 1,
        // Last frame index (0-indexed)
        parentId: null,
        blendMode: "normal",
        opacity: Ht("opacity", 100, "number"),
        transform: Ad(),
        properties: [],
        effects: [],
        data: {
          cameraId: i,
          isActiveCamera: !this.activeCameraId || this.activeCameraId === i
        }
      };
      return n.unshift(l), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), this.selectLayer(a), { camera: o, layer: l };
    },
    /**
     * Get a camera by ID
     */
    getCamera(s) {
      return this.cameras.get(s) || null;
    },
    /**
     * Update camera properties
     */
    updateCamera(s, e) {
      const n = this.cameras.get(s);
      n && (Object.assign(n, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Set the active camera
     */
    setActiveCamera(s) {
      if (!this.cameras.has(s)) return;
      this.activeCameraId = s;
      const e = this.getActiveCompLayers();
      for (const n of e)
        if (n.type === "camera" && n.data) {
          const i = n.data;
          i.isActiveCamera = i.cameraId === s;
        }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Delete a camera (and its layer)
     */
    deleteCamera(s) {
      const e = this.getActiveCompLayers(), n = e.findIndex(
        (i) => {
          var r;
          return i.type === "camera" && ((r = i.data) == null ? void 0 : r.cameraId) === s;
        }
      );
      if (n !== -1) {
        const i = e[n].id;
        e.splice(n, 1), this.selectedLayerIds = this.selectedLayerIds.filter((r) => r !== i);
      }
      if (this.cameras.delete(s), this.activeCameraId === s) {
        const i = Array.from(this.cameras.keys());
        this.activeCameraId = i.length > 0 ? i[0] : null, this.activeCameraId && this.setActiveCamera(this.activeCameraId);
      }
      this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Get camera keyframes for a specific camera
     */
    getCameraKeyframes(s) {
      return this.cameraKeyframes.get(s) || [];
    },
    /**
     * Add a keyframe to a camera
     */
    addCameraKeyframe(s, e) {
      let n = this.cameraKeyframes.get(s);
      n || (n = [], this.cameraKeyframes.set(s, n));
      const i = n.findIndex((r) => r.frame === e.frame);
      i >= 0 ? n[i] = e : (n.push(e), n.sort((r, o) => r.frame - o.frame)), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Remove a keyframe from a camera
     */
    removeCameraKeyframe(s, e) {
      const n = this.cameraKeyframes.get(s);
      if (!n) return;
      const i = n.findIndex((r) => r.frame === e);
      i >= 0 && (n.splice(i, 1), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    },
    /**
     * Get camera with keyframe interpolation applied at a specific frame
     * This is the main method for getting animated camera values
     */
    getCameraAtFrame(s, e) {
      const n = this.cameras.get(s);
      if (!n) return null;
      const i = this.cameraKeyframes.get(s);
      if (!i || i.length === 0)
        return n;
      const r = al(n, i, e);
      return {
        ...n,
        position: r.position,
        orientation: r.rotation,
        focalLength: r.focalLength,
        zoom: r.zoom,
        depthOfField: {
          ...n.depthOfField,
          focusDistance: r.focusDistance
        }
      };
    },
    /**
     * Get the active camera with interpolation at current frame
     */
    getActiveCameraAtFrame(s) {
      return this.activeCameraId ? this.getCameraAtFrame(this.activeCameraId, s ?? this.currentFrame) : null;
    },
    /**
     * Update viewport state
     */
    updateViewportState(s) {
      Object.assign(this.viewportState, s);
    },
    /**
     * Update view options
     */
    updateViewOptions(s) {
      Object.assign(this.viewOptions, s);
    },
    // ============================================================
    // AUDIO ACTIONS
    // ============================================================
    /**
     * Load audio file using Web Worker (non-blocking)
     */
    async loadAudio(s) {
      this.audioFile = s, this.audioBuffer = null, this.audioAnalysis = null, this.audioLoadingState = "decoding", this.audioLoadingProgress = 0, this.audioLoadingPhase = "Preparing...", this.audioLoadingError = null;
      try {
        const e = await q2(
          s,
          this.project.composition.fps,
          {
            onProgress: (n) => {
              n.phase === "decoding" ? this.audioLoadingState = "decoding" : this.audioLoadingState = "analyzing", this.audioLoadingProgress = n.progress, this.audioLoadingPhase = n.message;
            }
          }
        );
        this.audioBuffer = e.buffer, this.audioAnalysis = e.analysis, this.audioLoadingState = "complete", this.audioLoadingProgress = 1, this.audioLoadingPhase = "Complete", this.initializeAudioReactiveMapper(), this.propertyDriverSystem && this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis), console.log("[Weyl] Audio loaded:", {
          duration: this.audioBuffer.duration,
          bpm: this.audioAnalysis.bpm,
          frameCount: this.audioAnalysis.frameCount
        });
      } catch (e) {
        console.error("[Weyl] Failed to load audio:", e), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioReactiveMapper = null, this.audioLoadingState = "error", this.audioLoadingError = e.message;
      }
    },
    /**
     * Cancel ongoing audio analysis
     */
    cancelAudioLoad() {
      j2(), this.audioLoadingState = "idle", this.audioLoadingProgress = 0, this.audioLoadingPhase = "", this.audioLoadingError = null;
    },
    /**
     * Clear loaded audio
     */
    clearAudio() {
      this.cancelAudioLoad(), this.audioFile = null, this.audioBuffer = null, this.audioAnalysis = null, this.audioMappings.clear();
    },
    /**
     * Get audio feature value at current frame
     */
    getAudioFeatureAtFrame(s, e) {
      var n;
      return this.audioAnalysis ? ll(this.audioAnalysis, s, e ?? ((n = this.getActiveComp()) == null ? void 0 : n.currentFrame) ?? 0) : 0;
    },
    /**
     * Apply audio reactivity mapping to particle layer
     */
    applyAudioToParticles(s, e) {
      const n = this.audioMappings.get(s) || [];
      n.push(e), this.audioMappings.set(s, n);
    },
    /**
     * Remove audio mapping (legacy)
     */
    removeLegacyAudioMapping(s, e) {
      const n = this.audioMappings.get(s);
      n && (n.splice(e, 1), n.length === 0 && this.audioMappings.delete(s));
    },
    /**
     * Get audio mappings for a layer (legacy)
     */
    getAudioMappingsForLayer(s) {
      return this.audioMappings.get(s) || [];
    },
    // ============================================================
    // NEW AUDIO REACTIVE SYSTEM
    // ============================================================
    /**
     * Set peak data
     */
    setPeakData(s) {
      this.peakData = s, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(s);
    },
    /**
     * Detect peaks with config
     */
    detectAudioPeaks(s) {
      if (!this.audioAnalysis) return null;
      const e = this.audioAnalysis.amplitudeEnvelope, n = py(e, s);
      return this.peakData = n, this.audioReactiveMapper && this.audioReactiveMapper.setPeakData(n), n;
    },
    /**
     * Add new audio mapping
     */
    addAudioMapping(s) {
      this.audioReactiveMappings.push(s), this.audioReactiveMapper && this.audioReactiveMapper.addMapping(s);
    },
    /**
     * Remove audio mapping by ID
     */
    removeAudioMapping(s) {
      const e = this.audioReactiveMappings.findIndex((n) => n.id === s);
      e >= 0 && this.audioReactiveMappings.splice(e, 1), this.audioReactiveMapper && this.audioReactiveMapper.removeMapping(s);
    },
    /**
     * Update audio mapping
     */
    updateAudioMapping(s, e) {
      const n = this.audioReactiveMappings.find((i) => i.id === s);
      n && Object.assign(n, e), this.audioReactiveMapper && this.audioReactiveMapper.updateMapping(s, e);
    },
    /**
     * Get all audio mappings
     */
    getAudioMappings() {
      return this.audioReactiveMappings;
    },
    /**
     * Get mapped value at frame
     */
    getMappedValueAtFrame(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValueAtFrame(s, e) : 0;
    },
    /**
     * Get all mapped values at current frame
     */
    getAllMappedValuesAtFrame(s) {
      var e;
      return this.audioReactiveMapper ? this.audioReactiveMapper.getAllValuesAtFrame(s ?? ((e = this.getActiveComp()) == null ? void 0 : e.currentFrame) ?? 0) : /* @__PURE__ */ new Map();
    },
    /**
     * Get active mappings for a specific layer
     */
    getActiveMappingsForLayer(s) {
      return this.audioReactiveMappings.filter(
        (e) => e.enabled && (e.targetLayerId === s || e.targetLayerId === void 0)
      );
    },
    /**
     * Get audio reactive values for a specific layer at a specific frame
     * This is called by the engine during frame evaluation
     */
    getAudioReactiveValuesForLayer(s, e) {
      return this.audioReactiveMapper ? this.audioReactiveMapper.getValuesForLayerAtFrame(s, e) : /* @__PURE__ */ new Map();
    },
    /**
     * Check if current frame is a beat
     */
    isBeatAtCurrentFrame() {
      var s;
      return this.audioAnalysis ? lv(this.audioAnalysis, ((s = this.getActiveComp()) == null ? void 0 : s.currentFrame) ?? 0) : !1;
    },
    // ============================================================
    // TIMELINE SNAPPING
    // ============================================================
    /**
     * Find nearest snap point for a given frame
     * @param frame - The frame to snap
     * @param pixelsPerFrame - Current zoom level
     * @param selectedLayerId - Currently selected layer (excluded from keyframe snapping)
     */
    findSnapPoint(s, e, n) {
      var i;
      return uT(s, this.snapConfig, e, {
        layers: this.layers,
        selectedLayerId: n,
        currentFrame: ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0,
        audioAnalysis: this.audioAnalysis,
        peakData: this.peakData
      });
    },
    /**
     * Get all beat frames from audio analysis
     */
    getAudioBeatFrames() {
      return hT(this.audioAnalysis);
    },
    /**
     * Get all peak frames from peak data
     */
    getAudioPeakFrames() {
      return fT(this.peakData);
    },
    /**
     * Update snap configuration
     */
    setSnapConfig(s) {
      this.snapConfig = { ...this.snapConfig, ...s };
    },
    /**
     * Toggle snapping enabled
     */
    toggleSnapping() {
      this.snapConfig.enabled = !this.snapConfig.enabled;
    },
    /**
     * Toggle specific snap type
     */
    toggleSnapType(s) {
      const n = {
        grid: "snapToGrid",
        keyframes: "snapToKeyframes",
        beats: "snapToBeats",
        peaks: "snapToPeaks",
        layerBounds: "snapToLayerBounds",
        playhead: "snapToPlayhead"
      }[s];
      n && typeof this.snapConfig[n] == "boolean" && (this.snapConfig[n] = !this.snapConfig[n]);
    },
    // ============================================================
    // PATH ANIMATOR ACTIONS
    // ============================================================
    /**
     * Create path animator for a layer
     */
    createPathAnimator(s, e = {}) {
      const n = new nT(e);
      this.pathAnimators.set(s, n);
    },
    /**
     * Set path for an animator
     */
    setPathAnimatorPath(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setPath(e);
    },
    /**
     * Update path animator config
     */
    updatePathAnimatorConfig(s, e) {
      const n = this.pathAnimators.get(s);
      n && n.setConfig(e);
    },
    /**
     * Remove path animator
     */
    removePathAnimator(s) {
      this.pathAnimators.delete(s);
    },
    /**
     * Get path animator for layer
     */
    getPathAnimator(s) {
      return this.pathAnimators.get(s);
    },
    /**
     * Update all path animators for current frame
     */
    updatePathAnimators() {
      var i;
      if (!this.audioAnalysis) return;
      const s = ((i = this.getActiveComp()) == null ? void 0 : i.currentFrame) ?? 0, e = ll(this.audioAnalysis, "amplitude", s), n = lv(this.audioAnalysis, s);
      for (const [r, o] of this.pathAnimators)
        o.update(e, n);
    },
    /**
     * Reset all path animators
     */
    resetPathAnimators() {
      for (const s of this.pathAnimators.values())
        s.reset();
    },
    /**
     * Initialize audio reactive mapper when audio is loaded
     */
    initializeAudioReactiveMapper() {
      if (this.audioAnalysis) {
        this.audioReactiveMapper = new J2(this.audioAnalysis);
        for (const s of this.audioReactiveMappings)
          this.audioReactiveMapper.addMapping(s);
        this.peakData && this.audioReactiveMapper.setPeakData(this.peakData);
      }
    },
    // ============================================================
    // PROPERTY DRIVER SYSTEM (Expressions/Links)
    // ============================================================
    /**
     * Initialize the property driver system
     */
    initializePropertyDriverSystem() {
      this.propertyDriverSystem = new oT(), this.propertyDriverSystem.setPropertyGetter((s, e, n) => this.getPropertyValueAtFrame(s, e, n)), this.audioAnalysis && this.propertyDriverSystem.setAudioAnalysis(this.audioAnalysis);
      for (const s of this.propertyDrivers)
        this.propertyDriverSystem.addDriver(s);
    },
    /**
     * Get a property value at a specific frame
     * Used by the driver system to read source properties
     */
    getPropertyValueAtFrame(s, e, n) {
      const i = this.getActiveCompLayers().find((o) => o.id === s);
      if (!i) return null;
      const r = e.split(".");
      if (r[0] === "transform") {
        const o = i.transform;
        if (r[1] === "position") {
          const a = on(o.position, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 0;
        }
        if (r[1] === "anchorPoint") {
          const a = on(o.anchorPoint, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 0;
        }
        if (r[1] === "scale") {
          const a = on(o.scale, n);
          if (r[2] === "x") return a.x;
          if (r[2] === "y") return a.y;
          if (r[2] === "z") return a.z ?? 100;
        }
        if (r[1] === "rotation")
          return on(o.rotation, n);
        if (r[1] === "rotationX" && o.rotationX)
          return on(o.rotationX, n);
        if (r[1] === "rotationY" && o.rotationY)
          return on(o.rotationY, n);
        if (r[1] === "rotationZ" && o.rotationZ)
          return on(o.rotationZ, n);
      }
      return r[0] === "opacity" ? on(i.opacity, n) : null;
    },
    /**
     * Get driven property values for a layer at current frame
     */
    getDrivenValuesForLayer(s) {
      var l;
      if (!this.propertyDriverSystem)
        return /* @__PURE__ */ new Map();
      const e = this.getActiveCompLayers().find((c) => c.id === s);
      if (!e) return /* @__PURE__ */ new Map();
      const n = /* @__PURE__ */ new Map(), i = ((l = this.getActiveComp()) == null ? void 0 : l.currentFrame) ?? 0, r = on(e.transform.position, i);
      n.set("transform.position.x", r.x), n.set("transform.position.y", r.y), n.set("transform.position.z", r.z ?? 0);
      const o = on(e.transform.anchorPoint, i);
      n.set("transform.anchorPoint.x", o.x), n.set("transform.anchorPoint.y", o.y), n.set("transform.anchorPoint.z", o.z ?? 0);
      const a = on(e.transform.scale, i);
      return n.set("transform.scale.x", a.x), n.set("transform.scale.y", a.y), n.set("transform.scale.z", a.z ?? 100), n.set("transform.rotation", on(e.transform.rotation, i)), e.transform.rotationX && n.set("transform.rotationX", on(e.transform.rotationX, i)), e.transform.rotationY && n.set("transform.rotationY", on(e.transform.rotationY, i)), e.transform.rotationZ && n.set("transform.rotationZ", on(e.transform.rotationZ, i)), n.set("opacity", on(e.opacity, i)), this.propertyDriverSystem.evaluateLayerDrivers(s, i, n);
    },
    /**
     * Add a property driver
     * Returns false if adding would create a circular dependency
     */
    addPropertyDriver(s) {
      return this.propertyDriverSystem && !this.propertyDriverSystem.addDriver(s) ? (console.warn("[Store] Cannot add property driver: would create circular dependency"), !1) : (this.propertyDrivers.push(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory(), !0);
    },
    /**
     * Create and add an audio-driven property driver
     */
    createAudioPropertyDriver(s, e, n, i = {}) {
      const r = aT(s, e, n, i);
      return this.addPropertyDriver(r), r;
    },
    /**
     * Create and add a property-to-property link
     * Returns null if creating would cause a circular dependency
     */
    createPropertyLink(s, e, n, i, r = {}) {
      const o = lT(
        s,
        e,
        n,
        i,
        r
      );
      return this.addPropertyDriver(o) ? o : null;
    },
    /**
     * Remove a property driver
     */
    removePropertyDriver(s) {
      const e = this.propertyDrivers.findIndex((n) => n.id === s);
      e >= 0 && this.propertyDrivers.splice(e, 1), this.propertyDriverSystem && this.propertyDriverSystem.removeDriver(s), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString(), this.pushHistory();
    },
    /**
     * Update a property driver
     */
    updatePropertyDriver(s, e) {
      const n = this.propertyDrivers.find((i) => i.id === s);
      n && Object.assign(n, e), this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, e), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString();
    },
    /**
     * Get all drivers for a layer
     */
    getDriversForLayer(s) {
      return this.propertyDrivers.filter((e) => e.targetLayerId === s);
    },
    /**
     * Toggle driver enabled state
     */
    togglePropertyDriver(s) {
      const e = this.propertyDrivers.find((n) => n.id === s);
      e && (e.enabled = !e.enabled, this.propertyDriverSystem && this.propertyDriverSystem.updateDriver(s, { enabled: e.enabled }), this.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
  }
});
async function uv(s) {
  try {
    const e = await s.requestDevice(), n = e.limits.maxBufferSize;
    return e.destroy(), Math.round(n * 4 / (1024 * 1024 * 1024));
  } catch {
    return 0;
  }
}
async function pT() {
  if ("gpu" in navigator)
    try {
      const i = await navigator.gpu.requestAdapter({
        powerPreference: "high-performance"
      });
      if (i) {
        let r = "";
        if ("info" in i) {
          const o = i.info;
          r = (o == null ? void 0 : o.device) || (o == null ? void 0 : o.description) || "";
        }
        return r.includes("RTX 50") || r.toLowerCase().includes("blackwell") || r.includes("B100") || r.includes("B200") ? {
          tier: "blackwell",
          vram: await uv(i),
          features: ["fp4_tensor", "webgpu", "cuda_12"]
        } : {
          tier: "webgpu",
          vram: await uv(i),
          features: ["webgpu"]
        };
      }
    } catch (n) {
      console.warn("[Weyl] WebGPU detection failed:", n);
    }
  const e = document.createElement("canvas").getContext("webgl2");
  if (e) {
    const n = e.getExtension("WEBGL_debug_renderer_info"), i = n ? e.getParameter(n.UNMASKED_RENDERER_WEBGL) : "Unknown";
    return console.log("[Weyl] WebGL renderer:", i), {
      tier: "webgl",
      vram: 0,
      // Can't detect in WebGL
      features: ["webgl2"]
    };
  }
  return {
    tier: "cpu",
    vram: 0,
    features: []
  };
}
const mT = { class: "project-panel" }, vT = { class: "panel-header" }, gT = { class: "header-actions" }, yT = { class: "dropdown-container" }, _T = {
  key: 0,
  class: "dropdown-menu"
}, xT = {
  key: 0,
  class: "search-bar"
}, bT = { class: "panel-content" }, wT = { class: "folder-tree" }, ST = ["onClick", "onDblclick"], MT = ["onClick"], CT = { class: "folder-name" }, ET = { class: "item-count" }, TT = {
  key: 0,
  class: "folder-contents"
}, AT = ["onClick", "onDblclick", "onDragstart"], PT = { class: "item-icon" }, DT = { class: "item-name" }, RT = { class: "item-info" }, IT = ["onClick", "onDblclick", "onDragstart"], kT = { class: "item-icon" }, LT = { class: "item-name" }, FT = { class: "item-info" }, UT = {
  key: 0,
  class: "empty-state"
}, OT = {
  key: 1,
  class: "panel-footer"
}, zT = { class: "item-details" }, NT = { class: "detail-label" }, BT = { class: "detail-info" }, VT = /* @__PURE__ */ Ut({
  __name: "ProjectPanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = nn(), r = Se(null), o = Se(!1), a = Se(!1), l = Se(""), c = Se(null), u = Se(["compositions", "footage"]), d = Se([
      {
        id: "compositions",
        name: "Compositions",
        items: [
          { id: "comp-1", name: "Main Comp", type: "composition", width: 1920, height: 1080, fps: 30, duration: 300 }
        ]
      },
      {
        id: "footage",
        name: "Footage",
        items: []
      },
      {
        id: "solids",
        name: "Solids",
        items: []
      }
    ]), h = Se([]), m = Oe(() => {
      if (!l.value) return d.value;
      const D = l.value.toLowerCase();
      return d.value.map((O) => ({
        ...O,
        items: O.items.filter(
          (A) => A.name.toLowerCase().includes(D)
        )
      })).filter((O) => O.items.length > 0 || O.name.toLowerCase().includes(D));
    }), p = Oe(() => {
      if (!l.value) return h.value;
      const D = l.value.toLowerCase();
      return h.value.filter(
        (O) => O.name.toLowerCase().includes(D)
      );
    }), y = Oe(() => {
      if (!c.value) return null;
      for (const O of d.value) {
        const A = O.items.find((G) => G.id === c.value);
        if (A)
          return {
            name: A.name,
            info: L(A)
          };
      }
      const D = h.value.find((O) => O.id === c.value);
      return D ? {
        name: D.name,
        info: L(D)
      } : null;
    });
    function _(D) {
      const O = u.value.indexOf(D);
      O >= 0 ? u.value.splice(O, 1) : u.value.push(D);
    }
    function v(D) {
      c.value = D;
    }
    function g(D) {
      D.type === "composition" && console.log("Opening composition:", D.name);
    }
    function S() {
      a.value = !1, n("openCompositionSettings");
    }
    function w() {
      a.value = !1;
      const D = i.createLayer("solid", "Solid");
      console.log("[ProjectPanel] Created solid layer:", D.id);
    }
    function x() {
      a.value = !1;
      const D = i.createTextLayer("Text");
      console.log("[ProjectPanel] Created text layer:", D.id);
    }
    function C() {
      a.value = !1;
      const D = i.createLayer("null", "Null");
      console.log("[ProjectPanel] Created null layer:", D.id);
    }
    function E() {
      a.value = !1;
      const D = i.createSplineLayer();
      console.log("[ProjectPanel] Created spline layer:", D.id);
    }
    function P() {
      var D;
      (D = r.value) == null || D.click();
    }
    async function T(D) {
      const O = D.target, A = O.files;
      if (!(!A || A.length === 0)) {
        for (const G of Array.from(A)) {
          const he = b(G), ee = {
            id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            name: G.name,
            type: he
          };
          if (he === "audio")
            i.loadAudio(G);
          else if (G.type.startsWith("video/"))
            try {
              const oe = await i.createVideoLayer(G, !0);
              ee.id = oe.id, ee.width = i.width, ee.height = i.height, ee.duration = i.frameCount, ee.fps = i.fps, console.log("[ProjectPanel] Video layer created:", oe.id, oe.name);
            } catch (oe) {
              console.error("[ProjectPanel] Failed to import video:", oe);
              continue;
            }
          else if (G.type.startsWith("image/")) {
            const oe = URL.createObjectURL(G), Y = `image_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            i.project.assets[Y] = {
              id: Y,
              type: "image",
              source: "file",
              width: 0,
              // Will be updated when image loads
              height: 0,
              data: oe
            };
            const j = i.createLayer("image", G.name.replace(/\.[^.]+$/, ""));
            j.data = { assetId: Y }, ee.id = j.id;
          }
          const le = d.value.find((oe) => oe.id === "footage");
          le ? le.items.push(ee) : h.value.push(ee), console.log("[ProjectPanel] Imported:", G.name, he);
        }
        O.value = "";
      }
    }
    function b(D) {
      const O = D.type;
      return O.startsWith("audio/") ? "audio" : (O.startsWith("video/") || O.startsWith("image/"), "footage");
    }
    function M(D) {
      return {
        composition: "",
        footage: "",
        solid: "",
        audio: "",
        folder: ""
      }[D] || "";
    }
    function L(D) {
      if (D.type === "composition" || D.type === "footage") {
        const O = [];
        if (D.width && D.height && O.push(`${D.width}${D.height}`), D.fps && O.push(`${D.fps}fps`), D.duration) {
          const A = D.duration / (D.fps || 30);
          O.push(`${A.toFixed(1)}s`);
        }
        return O.join("  ");
      }
      return "";
    }
    function N(D, O) {
      var A;
      (A = O.dataTransfer) == null || A.setData("application/project-item", JSON.stringify(D));
    }
    return (D, O) => (re(), ae("div", mT, [
      f("div", vT, [
        O[3] || (O[3] = f("span", { class: "panel-title" }, "Project", -1)),
        f("div", gT, [
          f("button", {
            onClick: P,
            title: "Import File (Ctrl+I)"
          }, ""),
          f("div", yT, [
            f("button", {
              onClick: O[0] || (O[0] = (A) => a.value = !a.value),
              title: "New Item"
            }, "+"),
            a.value ? (re(), ae("div", _T, [
              f("button", { onClick: S }, " New Composition"),
              f("button", { onClick: w }, " New Solid"),
              f("button", { onClick: x }, "T New Text"),
              f("button", { onClick: C }, " New Null"),
              f("button", { onClick: E }, " New Spline")
            ])) : Pe("", !0)
          ]),
          f("button", {
            onClick: O[1] || (O[1] = (A) => o.value = !o.value),
            title: "Search"
          }, "")
        ])
      ]),
      f("input", {
        ref_key: "fileInputRef",
        ref: r,
        type: "file",
        multiple: "",
        accept: "image/*,video/*,audio/*,.json",
        style: { display: "none" },
        onChange: T
      }, null, 544),
      o.value ? (re(), ae("div", xT, [
        ct(f("input", {
          type: "text",
          "onUpdate:modelValue": O[2] || (O[2] = (A) => l.value = A),
          placeholder: "Search project...",
          class: "search-input"
        }, null, 512), [
          [$t, l.value]
        ])
      ])) : Pe("", !0),
      f("div", bT, [
        f("div", wT, [
          (re(!0), ae(Ze, null, at(m.value, (A) => (re(), ae("div", {
            key: A.id,
            class: "folder-item"
          }, [
            f("div", {
              class: Ue(["folder-header", { selected: c.value === A.id }]),
              onClick: (G) => v(A.id),
              onDblclick: (G) => _(A.id)
            }, [
              f("span", {
                class: "expand-icon",
                onClick: wt((G) => _(A.id), ["stop"])
              }, be(u.value.includes(A.id) ? "" : ""), 9, MT),
              O[4] || (O[4] = f("span", { class: "folder-icon" }, "", -1)),
              f("span", CT, be(A.name), 1),
              f("span", ET, be(A.items.length), 1)
            ], 42, ST),
            u.value.includes(A.id) ? (re(), ae("div", TT, [
              (re(!0), ae(Ze, null, at(A.items, (G) => (re(), ae("div", {
                key: G.id,
                class: Ue(["project-item", { selected: c.value === G.id }]),
                onClick: (he) => v(G.id),
                onDblclick: (he) => g(G),
                draggable: "true",
                onDragstart: (he) => N(G, he)
              }, [
                f("span", PT, be(M(G.type)), 1),
                f("span", DT, be(G.name), 1),
                f("span", RT, be(L(G)), 1)
              ], 42, AT))), 128))
            ])) : Pe("", !0)
          ]))), 128)),
          (re(!0), ae(Ze, null, at(p.value, (A) => (re(), ae("div", {
            key: A.id,
            class: Ue(["project-item", { selected: c.value === A.id }]),
            onClick: (G) => v(A.id),
            onDblclick: (G) => g(A),
            draggable: "true",
            onDragstart: (G) => N(A, G)
          }, [
            f("span", kT, be(M(A.type)), 1),
            f("span", LT, be(A.name), 1),
            f("span", FT, be(L(A)), 1)
          ], 42, IT))), 128))
        ]),
        h.value.length === 0 ? (re(), ae("div", UT, [...O[5] || (O[5] = [
          f("p", null, "No items in project", -1),
          f("p", { class: "hint" }, "Import footage or create compositions", -1)
        ])])) : Pe("", !0)
      ]),
      y.value ? (re(), ae("div", OT, [
        f("div", zT, [
          f("span", NT, be(y.value.name), 1),
          f("span", BT, be(y.value.info), 1)
        ])
      ])) : Pe("", !0)
    ]));
  }
}), Bt = (s, e) => {
  const n = s.__vccOpts || s;
  for (const [i, r] of e)
    n[i] = r;
  return n;
}, GT = /* @__PURE__ */ Bt(VT, [["__scopeId", "data-v-8f208c83"]]), HT = { class: "effects-panel" }, WT = { class: "panel-header" }, $T = { class: "header-actions" }, XT = { class: "panel-content" }, jT = { class: "tabs" }, YT = {
  key: 0,
  class: "effects-list"
}, qT = ["onClick"], ZT = { class: "expand-icon" }, KT = { class: "category-icon" }, JT = { class: "category-name" }, QT = { class: "effect-count" }, eA = {
  key: 0,
  class: "category-effects"
}, tA = ["onDblclick", "onDragstart"], nA = { class: "effect-name" }, iA = ["onClick", "title"], sA = {
  key: 1,
  class: "presets-list"
}, rA = ["onClick"], oA = { class: "expand-icon" }, aA = { class: "category-name" }, lA = { class: "preset-count" }, cA = {
  key: 0,
  class: "category-presets"
}, uA = ["onDblclick", "onDragstart"], dA = { class: "preset-info" }, hA = { class: "preset-name" }, fA = { class: "preset-description" }, pA = {
  key: 2,
  class: "favorites-list"
}, mA = {
  key: 0,
  class: "empty-favorites"
}, vA = ["onDblclick", "onDragstart"], gA = { class: "category-badge" }, yA = { class: "effect-name" }, _A = ["onClick"], xA = /* @__PURE__ */ Ut({
  __name: "EffectsPanel",
  setup(s) {
    const e = nn(), n = Se("effects"), i = Se(""), r = Se(["blur-sharpen", "color-correction"]), o = Se(["Fade", "Scale"]), a = Se([]);
    _n(() => {
      const x = localStorage.getItem("effect-favorites");
      if (x)
        try {
          a.value = JSON.parse(x);
        } catch {
          a.value = [];
        }
    });
    function l() {
      localStorage.setItem("effect-favorites", JSON.stringify(a.value));
    }
    const c = Oe(() => Object.entries(Zc).map(([x, C]) => ({
      key: x,
      name: C.name,
      category: C.category,
      description: C.description
    }))), u = Oe(() => {
      const x = i.value.toLowerCase();
      return Object.entries(Vh).map(([C, E]) => {
        const P = c.value.filter((T) => !(T.category !== C || x && !T.name.toLowerCase().includes(x)));
        return {
          key: C,
          label: E.label,
          icon: E.icon,
          effects: P
        };
      }).filter((C) => C.effects.length > 0);
    }), d = Oe(() => {
      const x = i.value.toLowerCase(), C = {};
      for (const E of rT)
        x && !E.name.toLowerCase().includes(x) || (C[E.category] || (C[E.category] = []), C[E.category].push(E));
      return Object.entries(C).map(([E, P]) => ({
        category: E,
        presets: P
      }));
    }), h = Oe(() => c.value.filter((x) => a.value.includes(x.key)));
    function m(x) {
      const C = r.value.indexOf(x);
      C >= 0 ? r.value.splice(C, 1) : r.value.push(x);
    }
    function p(x) {
      const C = o.value.indexOf(x);
      C >= 0 ? o.value.splice(C, 1) : o.value.push(x);
    }
    function y(x) {
      const C = a.value.indexOf(x);
      C >= 0 ? a.value.splice(C, 1) : a.value.push(x), l();
    }
    function _(x) {
      var C;
      return ((C = Vh[x]) == null ? void 0 : C.icon) || "?";
    }
    function v(x) {
      const C = e.selectedLayer;
      if (!C) {
        console.warn("No layer selected to apply effect");
        return;
      }
      e.addEffectToLayer(C.id, x);
    }
    function g(x) {
      if (!e.selectedLayer) {
        console.warn("No layer selected to apply preset");
        return;
      }
      console.log("Applying preset:", x.name);
    }
    function S(x, C) {
      var E;
      (E = C.dataTransfer) == null || E.setData("application/effect", x);
    }
    function w(x, C) {
      var E;
      (E = C.dataTransfer) == null || E.setData("application/preset", JSON.stringify(x));
    }
    return (x, C) => (re(), ae("div", HT, [
      f("div", WT, [
        C[4] || (C[4] = f("span", { class: "panel-title" }, "Effects & Presets", -1)),
        f("div", $T, [
          ct(f("input", {
            type: "text",
            "onUpdate:modelValue": C[0] || (C[0] = (E) => i.value = E),
            placeholder: "Search...",
            class: "search-input"
          }, null, 512), [
            [$t, i.value]
          ])
        ])
      ]),
      f("div", XT, [
        f("div", jT, [
          f("button", {
            class: Ue({ active: n.value === "effects" }),
            onClick: C[1] || (C[1] = (E) => n.value = "effects")
          }, " Effects ", 2),
          f("button", {
            class: Ue({ active: n.value === "presets" }),
            onClick: C[2] || (C[2] = (E) => n.value = "presets")
          }, " Presets ", 2),
          f("button", {
            class: Ue({ active: n.value === "favorites" }),
            onClick: C[3] || (C[3] = (E) => n.value = "favorites")
          }, " Favorites ", 2)
        ]),
        n.value === "effects" ? (re(), ae("div", YT, [
          (re(!0), ae(Ze, null, at(u.value, (E) => (re(), ae("div", {
            key: E.key,
            class: "effect-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (P) => m(E.key)
            }, [
              f("span", ZT, be(r.value.includes(E.key) ? "" : ""), 1),
              f("span", KT, be(E.icon), 1),
              f("span", JT, be(E.label), 1),
              f("span", QT, be(E.effects.length), 1)
            ], 8, qT),
            r.value.includes(E.key) ? (re(), ae("div", eA, [
              (re(!0), ae(Ze, null, at(E.effects, (P) => (re(), ae("div", {
                key: P.key,
                class: Ue(["effect-item", { favorite: a.value.includes(P.key) }]),
                onDblclick: (T) => v(P.key),
                onDragstart: (T) => S(P.key, T),
                draggable: "true"
              }, [
                f("span", nA, be(P.name), 1),
                f("button", {
                  class: "favorite-btn",
                  onClick: wt((T) => y(P.key), ["stop"]),
                  title: a.value.includes(P.key) ? "Remove from favorites" : "Add to favorites"
                }, be(a.value.includes(P.key) ? "" : ""), 9, iA)
              ], 42, tA))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : n.value === "presets" ? (re(), ae("div", sA, [
          (re(!0), ae(Ze, null, at(d.value, (E) => (re(), ae("div", {
            key: E.category,
            class: "preset-category"
          }, [
            f("div", {
              class: "category-header",
              onClick: (P) => p(E.category)
            }, [
              f("span", oA, be(o.value.includes(E.category) ? "" : ""), 1),
              f("span", aA, be(E.category), 1),
              f("span", lA, be(E.presets.length), 1)
            ], 8, rA),
            o.value.includes(E.category) ? (re(), ae("div", cA, [
              (re(!0), ae(Ze, null, at(E.presets, (P) => (re(), ae("div", {
                key: P.id,
                class: "preset-item",
                onDblclick: (T) => g(P),
                onDragstart: (T) => w(P, T),
                draggable: "true"
              }, [
                C[5] || (C[5] = f("div", { class: "preset-preview" }, [
                  f("span", { class: "preview-icon" }, "")
                ], -1)),
                f("div", dA, [
                  f("span", hA, be(P.name), 1),
                  f("span", fA, be(P.description), 1)
                ])
              ], 40, uA))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : n.value === "favorites" ? (re(), ae("div", pA, [
          h.value.length === 0 ? (re(), ae("div", mA, [...C[6] || (C[6] = [
            f("p", null, "No favorites yet", -1),
            f("p", { class: "hint" }, "Click the star icon on effects to add them here", -1)
          ])])) : Pe("", !0),
          (re(!0), ae(Ze, null, at(h.value, (E) => (re(), ae("div", {
            key: E.key,
            class: "effect-item",
            onDblclick: (P) => v(E.key),
            onDragstart: (P) => S(E.key, P),
            draggable: "true"
          }, [
            f("span", gA, be(_(E.category)), 1),
            f("span", yA, be(E.name), 1),
            f("button", {
              class: "favorite-btn active",
              onClick: wt((P) => y(E.key), ["stop"])
            }, "  ", 8, _A)
          ], 40, vA))), 128))
        ])) : Pe("", !0)
      ]),
      C[7] || (C[7] = f("div", { class: "panel-footer" }, [
        f("span", { class: "info-text" }, "Double-click or drag to apply")
      ], -1))
    ]));
  }
}), bA = /* @__PURE__ */ Bt(xA, [["__scopeId", "data-v-5ceccb10"]]), wA = ["value", "min", "max", "step", "disabled"], SA = {
  key: 1,
  class: "scrub-unit"
}, MA = /* @__PURE__ */ Ut({
  __name: "ScrubableNumber",
  props: {
    modelValue: {},
    label: {},
    min: { default: -1 / 0 },
    max: { default: 1 / 0 },
    step: { default: 1 },
    precision: { default: 2 },
    unit: {},
    default: {},
    sensitivity: { default: 1 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = Se(!1), o = Se(0), a = Se(0), l = Oe(() => n.default ?? n.modelValue), c = Oe(() => n.default !== void 0), u = Oe(() => Number.isInteger(n.modelValue) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function d(w) {
      return Math.max(n.min, Math.min(n.max, w));
    }
    function h(w) {
      const x = Math.pow(10, n.precision);
      return Math.round(w * x) / x;
    }
    function m(w) {
      n.disabled || (r.value = !0, o.value = w.clientX, a.value = n.modelValue, document.addEventListener("mousemove", p), document.addEventListener("mouseup", y), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function p(w) {
      const x = w.clientX - o.value;
      let C = n.sensitivity;
      w.shiftKey && (C *= 10), (w.ctrlKey || w.metaKey) && (C *= 0.1);
      const E = x * n.step * C * 0.5, P = h(d(a.value + E));
      P !== n.modelValue && i("update:modelValue", P);
    }
    function y() {
      r.value = !1, document.removeEventListener("mousemove", p), document.removeEventListener("mouseup", y), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function _(w) {
      const x = w.target, C = parseFloat(x.value);
      isNaN(C) || i("update:modelValue", h(d(C)));
    }
    function v(w) {
      if (n.disabled) return;
      let x = 0;
      w.key === "ArrowUp" ? x = n.step : w.key === "ArrowDown" && (x = -n.step), x !== 0 && (w.preventDefault(), w.shiftKey && (x *= 10), (w.ctrlKey || w.metaKey) && (x *= 0.1), i("update:modelValue", h(d(n.modelValue + x))));
    }
    function g(w) {
      const x = w.target, C = parseFloat(x.value);
      isNaN(C) && (x.value = u.value.toString());
    }
    function S() {
      n.default !== void 0 && i("update:modelValue", n.default);
    }
    return (w, x) => (re(), ae("div", {
      class: Ue(["scrubable-number", { disabled: s.disabled }])
    }, [
      s.label ? (re(), ae("label", {
        key: 0,
        class: Ue(["scrub-label", { scrubbing: r.value }]),
        onMousedown: m
      }, be(s.label), 35)) : Pe("", !0),
      f("input", {
        type: "number",
        class: "scrub-input",
        value: u.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: _,
        onKeydown: v,
        onBlur: g
      }, null, 40, wA),
      s.unit ? (re(), ae("span", SA, be(s.unit), 1)) : Pe("", !0),
      c.value && s.modelValue !== l.value ? (re(), ae("button", {
        key: 2,
        class: "reset-btn",
        onClick: S,
        title: "Reset to default"
      }, [...x[0] || (x[0] = [
        f("i", { class: "pi pi-refresh" }, null, -1)
      ])])) : Pe("", !0)
    ], 2));
  }
}), et = /* @__PURE__ */ Bt(MA, [["__scopeId", "data-v-2a930cf0"]]), CA = ["value", "min", "max", "step", "disabled"], EA = {
  key: 2,
  class: "slider-unit"
}, TA = /* @__PURE__ */ Ut({
  __name: "SliderInput",
  props: {
    modelValue: {},
    label: {},
    min: {},
    max: {},
    step: { default: 1 },
    unit: {},
    showValue: { type: Boolean, default: !0 },
    gradient: {},
    disabled: { type: Boolean, default: !1 },
    precision: { default: 2 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = Se(null), o = Se(!1), a = Se(!1), l = Se(0), c = Se(0), u = Oe(() => {
      const E = n.max - n.min;
      return E === 0 ? 0 : (n.modelValue - n.min) / E * 100;
    }), d = Oe(() => Number.isInteger(n.step) && n.precision === 0 ? n.modelValue : Number(n.modelValue.toFixed(n.precision)));
    function h(E) {
      return Math.max(n.min, Math.min(n.max, E));
    }
    function m(E) {
      const P = Math.pow(10, n.precision);
      return Math.round(E * P) / P;
    }
    function p(E) {
      n.disabled || (o.value = !0, l.value = E.clientX, c.value = n.modelValue, document.addEventListener("mousemove", y), document.addEventListener("mouseup", _), document.body.style.cursor = "ew-resize", document.body.style.userSelect = "none");
    }
    function y(E) {
      const P = E.clientX - l.value, T = n.max - n.min;
      let b = 1;
      E.shiftKey && (b *= 10), (E.ctrlKey || E.metaKey) && (b *= 0.1);
      const M = P / 200 * T * b, L = m(h(c.value + M));
      L !== n.modelValue && i("update:modelValue", L);
    }
    function _() {
      o.value = !1, document.removeEventListener("mousemove", y), document.removeEventListener("mouseup", _), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function v(E) {
      if (n.disabled || !r.value) return;
      const P = r.value.getBoundingClientRect(), T = (E.clientX - P.left) / P.width, b = n.min + T * (n.max - n.min);
      i("update:modelValue", m(h(b)));
    }
    function g(E) {
      n.disabled || (a.value = !0, document.addEventListener("mousemove", S), document.addEventListener("mouseup", w), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function S(E) {
      if (!r.value) return;
      const P = r.value.getBoundingClientRect(), T = (E.clientX - P.left) / P.width, b = n.min + Math.max(0, Math.min(1, T)) * (n.max - n.min);
      i("update:modelValue", m(h(b)));
    }
    function w() {
      a.value = !1, document.removeEventListener("mousemove", S), document.removeEventListener("mouseup", w), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function x(E) {
      const P = E.target, T = parseFloat(P.value);
      isNaN(T) || i("update:modelValue", m(h(T)));
    }
    function C(E) {
      const P = E.target, T = parseFloat(P.value);
      isNaN(T) && (P.value = d.value.toString());
    }
    return (E, P) => (re(), ae("div", {
      class: Ue(["slider-input", { disabled: s.disabled }])
    }, [
      s.label ? (re(), ae("label", {
        key: 0,
        class: Ue(["slider-label", { scrubbing: o.value }]),
        onMousedown: p
      }, be(s.label), 35)) : Pe("", !0),
      f("div", {
        class: "slider-track",
        ref_key: "trackRef",
        ref: r,
        onMousedown: v
      }, [
        f("div", {
          class: "slider-fill",
          style: bt({ width: u.value + "%", background: s.gradient || void 0 })
        }, null, 4),
        f("div", {
          class: "slider-thumb",
          style: bt({ left: u.value + "%" }),
          onMousedown: wt(g, ["stop"])
        }, null, 36)
      ], 544),
      s.showValue ? (re(), ae("input", {
        key: 1,
        type: "number",
        class: "slider-value",
        value: d.value,
        min: s.min,
        max: s.max,
        step: s.step,
        disabled: s.disabled,
        onInput: x,
        onBlur: C
      }, null, 40, CA)) : Pe("", !0),
      s.unit ? (re(), ae("span", EA, be(s.unit), 1)) : Pe("", !0)
    ], 2));
  }
}), li = /* @__PURE__ */ Bt(TA, [["__scopeId", "data-v-9dd40416"]]), AA = { class: "dial-marks" }, PA = {
  key: 0,
  class: "angle-value"
}, DA = ["value", "disabled"], RA = /* @__PURE__ */ Ut({
  __name: "AngleDial",
  props: {
    modelValue: {},
    size: { default: 48 },
    showValue: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = Se(null), o = Se(!1), a = Oe(() => Math.round(n.modelValue * 10) / 10);
    function l(y) {
      return (y % 360 + 360) % 360;
    }
    function c(y) {
      n.disabled || (o.value = !0, d(y), document.addEventListener("mousemove", u), document.addEventListener("mouseup", h), document.body.style.cursor = "grabbing", document.body.style.userSelect = "none");
    }
    function u(y) {
      o.value && d(y);
    }
    function d(y) {
      if (!r.value) return;
      const _ = r.value.getBoundingClientRect(), v = _.left + _.width / 2, g = _.top + _.height / 2, S = y.clientX - v, w = y.clientY - g;
      let x = Math.atan2(S, -w) * (180 / Math.PI);
      x = l(x), y.shiftKey && (x = Math.round(x / 45) * 45), i("update:modelValue", x);
    }
    function h() {
      o.value = !1, document.removeEventListener("mousemove", u), document.removeEventListener("mouseup", h), document.body.style.cursor = "", document.body.style.userSelect = "";
    }
    function m(y) {
      const _ = y.target, v = parseFloat(_.value);
      isNaN(v) || i("update:modelValue", l(v));
    }
    function p(y) {
      const _ = y.target, v = parseFloat(_.value);
      isNaN(v) && (_.value = a.value.toString());
    }
    return (y, _) => (re(), ae("div", {
      class: Ue(["angle-dial", { disabled: s.disabled }])
    }, [
      f("div", {
        class: "dial",
        ref_key: "dialRef",
        ref: r,
        style: bt({ width: s.size + "px", height: s.size + "px" }),
        onMousedown: c
      }, [
        _[0] || (_[0] = f("div", { class: "dial-ring" }, null, -1)),
        _[1] || (_[1] = f("div", { class: "dial-center" }, null, -1)),
        f("div", {
          class: "dial-indicator",
          style: bt({ transform: `rotate(${s.modelValue}deg)` })
        }, null, 4),
        f("div", AA, [
          (re(), ae(Ze, null, at(8, (v) => f("div", {
            class: "dial-mark",
            key: v,
            style: bt({ transform: `rotate(${v * 45}deg)` })
          }, null, 4)), 64))
        ])
      ], 36),
      s.showValue ? (re(), ae("div", PA, [
        f("input", {
          type: "number",
          class: "angle-input",
          value: a.value,
          disabled: s.disabled,
          onInput: m,
          onBlur: p
        }, null, 40, DA),
        _[2] || (_[2] = f("span", { class: "angle-unit" }, "", -1))
      ])) : Pe("", !0)
    ], 2));
  }
}), Nf = /* @__PURE__ */ Bt(RA, [["__scopeId", "data-v-04a5caf6"]]);
function dv(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = n * e, r = i * (1 - Math.abs(s / 60 % 2 - 1)), o = n - i;
  let a = 0, l = 0, c = 0;
  return s < 60 ? (a = i, l = r, c = 0) : s < 120 ? (a = r, l = i, c = 0) : s < 180 ? (a = 0, l = i, c = r) : s < 240 ? (a = 0, l = r, c = i) : s < 300 ? (a = r, l = 0, c = i) : (a = i, l = 0, c = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function hs(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = i - r;
  let a = 0;
  const l = i === 0 ? 0 : o / i, c = i;
  if (o !== 0)
    switch (i) {
      case s:
        a = ((e - n) / o + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - s) / o + 2) * 60;
        break;
      case n:
        a = ((s - e) / o + 4) * 60;
        break;
    }
  return [a, l, c];
}
function sc(s, e, n) {
  s = (s % 360 + 360) % 360;
  const i = (1 - Math.abs(2 * n - 1)) * e, r = i * (1 - Math.abs(s / 60 % 2 - 1)), o = n - i / 2;
  let a = 0, l = 0, c = 0;
  return s < 60 ? (a = i, l = r, c = 0) : s < 120 ? (a = r, l = i, c = 0) : s < 180 ? (a = 0, l = i, c = r) : s < 240 ? (a = 0, l = r, c = i) : s < 300 ? (a = r, l = 0, c = i) : (a = i, l = 0, c = r), [
    Math.round((a + o) * 255),
    Math.round((l + o) * 255),
    Math.round((c + o) * 255)
  ];
}
function vr(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = (i + r) / 2;
  let a = 0, l = 0;
  if (i !== r) {
    const c = i - r;
    switch (l = o > 0.5 ? c / (2 - i - r) : c / (i + r), i) {
      case s:
        a = ((e - n) / c + (e < n ? 6 : 0)) * 60;
        break;
      case e:
        a = ((n - s) / c + 2) * 60;
        break;
      case n:
        a = ((s - e) / c + 4) * 60;
        break;
    }
  }
  return [a, l, o];
}
function IA(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2]), s.length === 6 || s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16);
    if (!isNaN(e) && !isNaN(n) && !isNaN(i))
      return [e, n, i];
  }
  return null;
}
function kA(s) {
  if (s = s.replace(/^#/, ""), s.length === 3 && (s = s[0] + s[0] + s[1] + s[1] + s[2] + s[2] + "ff"), s.length === 6 && (s = s + "ff"), s.length === 8) {
    const e = parseInt(s.slice(0, 2), 16), n = parseInt(s.slice(2, 4), 16), i = parseInt(s.slice(4, 6), 16), r = parseInt(s.slice(6, 8), 16) / 255;
    if (!isNaN(e) && !isNaN(n) && !isNaN(i) && !isNaN(r))
      return [e, n, i, r];
  }
  return null;
}
function LA(s, e, n) {
  const i = (r) => Math.max(0, Math.min(255, Math.round(r))).toString(16).padStart(2, "0");
  return `#${i(s)}${i(e)}${i(n)}`;
}
function FA(s, e, n, i) {
  const r = (o) => Math.max(0, Math.min(255, Math.round(o))).toString(16).padStart(2, "0");
  return `#${r(s)}${r(e)}${r(n)}${r(i * 255)}`;
}
const UA = [
  "#ff0000",
  "#ff8000",
  "#ffff00",
  "#80ff00",
  "#00ff00",
  "#00ff80",
  "#00ffff",
  "#0080ff",
  "#0000ff",
  "#8000ff",
  "#ff00ff",
  "#ff0080",
  "#ffffff",
  "#c0c0c0",
  "#808080",
  "#404040",
  "#000000"
], OA = {
  key: 0,
  class: "checkerboard"
}, zA = ["value"], NA = { class: "mode-tabs" }, BA = ["onClick"], VA = {
  key: 1,
  class: "rgb-sliders"
}, GA = { class: "color-slider" }, HA = ["value"], WA = { class: "color-slider" }, $A = ["value"], XA = { class: "color-slider" }, jA = ["value"], YA = {
  key: 2,
  class: "hsl-sliders"
}, qA = { class: "color-slider" }, ZA = ["value"], KA = { class: "color-slider" }, JA = ["value"], QA = { class: "color-slider" }, e3 = ["value"], t3 = {
  key: 3,
  class: "alpha-slider"
}, n3 = ["value"], i3 = { class: "swatches-section" }, s3 = { class: "swatches-grid" }, r3 = ["onClick"], o3 = {
  key: 4,
  class: "recent-section"
}, a3 = { class: "swatches-grid" }, l3 = ["onClick"], c3 = /* @__PURE__ */ Ut({
  __name: "ColorPicker",
  props: {
    modelValue: {},
    alpha: { type: Boolean, default: !1 },
    swatches: {},
    recentCount: { default: 8 },
    teleport: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = ["hsv", "rgb", "hsl"], o = Se(null), a = Se(null), l = Se(null), c = Se(null), u = Se(null), d = Se(!1), h = Se("hsv"), m = Se(1), p = Se([]), y = Se([255, 255, 255]), _ = Se([0, 0, 1]), v = Se([0, 0, 1]), g = Oe(() => n.swatches || UA), S = Oe(() => {
      if (!o.value || !n.teleport) return {};
      const ie = o.value.getBoundingClientRect();
      return {
        top: `${ie.bottom + 4}px`,
        left: `${ie.left}px`
      };
    });
    function w(ie) {
      const J = IA(ie);
      J && (y.value = J, _.value = hs(J[0], J[1], J[2]), v.value = vr(J[0], J[1], J[2]));
    }
    function x() {
      const ie = LA(y.value[0], y.value[1], y.value[2]);
      i("update:modelValue", ie);
    }
    function C() {
      d.value = !d.value;
    }
    function E() {
      d.value && (d.value = !1, P(n.modelValue));
    }
    function P(ie) {
      const J = p.value.indexOf(ie);
      J !== -1 && p.value.splice(J, 1), p.value.unshift(ie), p.value.length > n.recentCount && p.value.pop();
    }
    function T(ie) {
      i("update:modelValue", ie);
    }
    let b = !1;
    function M(ie) {
      b = !0, N(ie), document.addEventListener("mousemove", L), document.addEventListener("mouseup", D);
    }
    function L(ie) {
      b && N(ie);
    }
    function N(ie) {
      if (!l.value) return;
      const J = l.value.getBoundingClientRect(), B = Math.max(0, Math.min(1, (ie.clientX - J.left) / J.width)), $ = Math.max(0, Math.min(1, 1 - (ie.clientY - J.top) / J.height));
      _.value = [_.value[0], B, $], y.value = dv(_.value[0], _.value[1], _.value[2]), v.value = vr(y.value[0], y.value[1], y.value[2]), x();
    }
    function D() {
      b = !1, document.removeEventListener("mousemove", L), document.removeEventListener("mouseup", D);
    }
    let O = !1;
    function A(ie) {
      O = !0, he(ie), document.addEventListener("mousemove", G), document.addEventListener("mouseup", ee);
    }
    function G(ie) {
      O && he(ie);
    }
    function he(ie) {
      if (!c.value) return;
      const J = c.value.getBoundingClientRect(), B = Math.max(0, Math.min(360, (ie.clientX - J.left) / J.width * 360));
      _.value = [B, _.value[1], _.value[2]], y.value = dv(_.value[0], _.value[1], _.value[2]), v.value = vr(y.value[0], y.value[1], y.value[2]), x();
    }
    function ee() {
      O = !1, document.removeEventListener("mousemove", G), document.removeEventListener("mouseup", ee);
    }
    let le = null, oe = null;
    function Y(ie, J) {
      le = ie;
      const B = J.target.closest(".slider-track");
      B && (oe = B.getBoundingClientRect(), q(J), document.addEventListener("mousemove", j), document.addEventListener("mouseup", te));
    }
    function j(ie) {
      le && q(ie);
    }
    function q(ie) {
      if (!oe || !le) return;
      const J = Math.max(0, Math.min(1, (ie.clientX - oe.left) / oe.width));
      switch (le) {
        case "r":
          y.value = [Math.round(J * 255), y.value[1], y.value[2]], _.value = hs(y.value[0], y.value[1], y.value[2]), v.value = vr(y.value[0], y.value[1], y.value[2]);
          break;
        case "g":
          y.value = [y.value[0], Math.round(J * 255), y.value[2]], _.value = hs(y.value[0], y.value[1], y.value[2]), v.value = vr(y.value[0], y.value[1], y.value[2]);
          break;
        case "b":
          y.value = [y.value[0], y.value[1], Math.round(J * 255)], _.value = hs(y.value[0], y.value[1], y.value[2]), v.value = vr(y.value[0], y.value[1], y.value[2]);
          break;
        case "h":
          v.value = [J * 360, v.value[1], v.value[2]], y.value = sc(v.value[0], v.value[1], v.value[2]), _.value = hs(y.value[0], y.value[1], y.value[2]);
          break;
        case "s":
          v.value = [v.value[0], J, v.value[2]], y.value = sc(v.value[0], v.value[1], v.value[2]), _.value = hs(y.value[0], y.value[1], y.value[2]);
          break;
        case "l":
          v.value = [v.value[0], v.value[1], J], y.value = sc(v.value[0], v.value[1], v.value[2]), _.value = hs(y.value[0], y.value[1], y.value[2]);
          break;
      }
      x();
    }
    function te() {
      le = null, oe = null, document.removeEventListener("mousemove", j), document.removeEventListener("mouseup", te);
    }
    let ne = !1;
    function de(ie) {
      ne = !0, X(ie), document.addEventListener("mousemove", H), document.addEventListener("mouseup", V);
    }
    function H(ie) {
      ne && X(ie);
    }
    function X(ie) {
      if (!u.value) return;
      const J = u.value.getBoundingClientRect();
      m.value = Math.max(0, Math.min(1, (ie.clientX - J.left) / J.width));
    }
    function V() {
      ne = !1, document.removeEventListener("mousemove", H), document.removeEventListener("mouseup", V);
    }
    function I(ie) {
      let B = ie.target.value.trim();
      B.startsWith("#") || (B = "#" + B), /^#[0-9a-f]{6}$/i.test(B) && i("update:modelValue", B.toLowerCase());
    }
    function F(ie) {
      const J = ie.target;
      J.value = n.modelValue;
    }
    function k(ie, J) {
      const B = J.target, $ = Math.max(0, Math.min(255, parseInt(B.value) || 0)), se = [...y.value];
      se[ie] = $, y.value = se, _.value = hs(y.value[0], y.value[1], y.value[2]), v.value = vr(y.value[0], y.value[1], y.value[2]), x();
    }
    function Q(ie, J) {
      const B = J.target;
      let $ = parseFloat(B.value) || 0;
      ie === 0 ? ($ = Math.max(0, Math.min(360, $)), v.value = [$, v.value[1], v.value[2]]) : ($ = Math.max(0, Math.min(100, $)) / 100, ie === 1 ? v.value = [v.value[0], $, v.value[2]] : v.value = [v.value[0], v.value[1], $]), y.value = sc(v.value[0], v.value[1], v.value[2]), _.value = hs(y.value[0], y.value[1], y.value[2]), x();
    }
    function Z(ie) {
      const J = ie.target;
      m.value = Math.max(0, Math.min(100, parseInt(J.value) || 0)) / 100;
    }
    function R(ie) {
      o.value && !o.value.contains(ie.target) && a.value && !a.value.contains(ie.target) && E();
    }
    return Ft(() => n.modelValue, (ie) => {
      w(ie);
    }, { immediate: !0 }), _n(() => {
      document.addEventListener("mousedown", R);
    }), jn(() => {
      document.removeEventListener("mousedown", R);
    }), (ie, J) => (re(), ae("div", {
      class: "color-picker",
      ref_key: "containerRef",
      ref: o
    }, [
      f("button", {
        class: "color-swatch",
        style: bt({ backgroundColor: s.modelValue }),
        onClick: C
      }, [
        s.alpha ? (re(), ae("span", OA)) : Pe("", !0)
      ], 4),
      f("input", {
        type: "text",
        class: "hex-input",
        value: s.modelValue,
        onInput: I,
        onBlur: F,
        onKeydown: J[0] || (J[0] = Ja((B) => B.target.blur(), ["enter"]))
      }, null, 40, zA),
      (re(), St(Po, {
        to: "body",
        disabled: !s.teleport
      }, [
        d.value ? (re(), ae("div", {
          key: 0,
          class: "picker-panel",
          style: bt(S.value),
          ref_key: "panelRef",
          ref: a
        }, [
          f("div", NA, [
            (re(), ae(Ze, null, at(r, (B) => f("button", {
              key: B,
              class: Ue({ active: h.value === B }),
              onClick: ($) => h.value = B
            }, be(B.toUpperCase()), 11, BA)), 64))
          ]),
          h.value === "hsv" ? (re(), ae(Ze, { key: 0 }, [
            f("div", {
              class: "sv-square",
              style: bt({ backgroundColor: `hsl(${_.value[0]}, 100%, 50%)` }),
              onMousedown: M,
              ref_key: "svSquareRef",
              ref: l
            }, [
              J[13] || (J[13] = f("div", { class: "sv-white" }, null, -1)),
              J[14] || (J[14] = f("div", { class: "sv-black" }, null, -1)),
              f("div", {
                class: "sv-cursor",
                style: bt({ left: _.value[1] * 100 + "%", top: (1 - _.value[2]) * 100 + "%" })
              }, null, 4)
            ], 36),
            f("div", {
              class: "hue-slider",
              onMousedown: A,
              ref_key: "hueSliderRef",
              ref: c
            }, [
              f("div", {
                class: "hue-cursor",
                style: bt({ left: _.value[0] / 360 * 100 + "%" })
              }, null, 4)
            ], 544)
          ], 64)) : h.value === "rgb" ? (re(), ae("div", VA, [
            f("div", GA, [
              J[15] || (J[15] = f("label", null, "R", -1)),
              f("div", {
                class: "slider-track r-track",
                onMousedown: J[1] || (J[1] = (B) => Y("r", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: bt({ left: y.value[0] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: y.value[0],
                min: "0",
                max: "255",
                onInput: J[2] || (J[2] = (B) => k(0, B))
              }, null, 40, HA)
            ]),
            f("div", WA, [
              J[16] || (J[16] = f("label", null, "G", -1)),
              f("div", {
                class: "slider-track g-track",
                onMousedown: J[3] || (J[3] = (B) => Y("g", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: bt({ left: y.value[1] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: y.value[1],
                min: "0",
                max: "255",
                onInput: J[4] || (J[4] = (B) => k(1, B))
              }, null, 40, $A)
            ]),
            f("div", XA, [
              J[17] || (J[17] = f("label", null, "B", -1)),
              f("div", {
                class: "slider-track b-track",
                onMousedown: J[5] || (J[5] = (B) => Y("b", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: bt({ left: y.value[2] / 255 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: y.value[2],
                min: "0",
                max: "255",
                onInput: J[6] || (J[6] = (B) => k(2, B))
              }, null, 40, jA)
            ])
          ])) : h.value === "hsl" ? (re(), ae("div", YA, [
            f("div", qA, [
              J[18] || (J[18] = f("label", null, "H", -1)),
              f("div", {
                class: "slider-track hue-track",
                onMousedown: J[7] || (J[7] = (B) => Y("h", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: bt({ left: v.value[0] / 360 * 100 + "%" })
                }, null, 4)
              ], 32),
              f("input", {
                type: "number",
                value: Math.round(v.value[0]),
                min: "0",
                max: "360",
                onInput: J[8] || (J[8] = (B) => Q(0, B))
              }, null, 40, ZA)
            ]),
            f("div", KA, [
              J[19] || (J[19] = f("label", null, "S", -1)),
              f("div", {
                class: "slider-track sat-track",
                style: bt({ "--hue": v.value[0] }),
                onMousedown: J[9] || (J[9] = (B) => Y("s", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: bt({ left: v.value[1] * 100 + "%" })
                }, null, 4)
              ], 36),
              f("input", {
                type: "number",
                value: Math.round(v.value[1] * 100),
                min: "0",
                max: "100",
                onInput: J[10] || (J[10] = (B) => Q(1, B))
              }, null, 40, JA)
            ]),
            f("div", QA, [
              J[20] || (J[20] = f("label", null, "L", -1)),
              f("div", {
                class: "slider-track light-track",
                style: bt({ "--hue": v.value[0] }),
                onMousedown: J[11] || (J[11] = (B) => Y("l", B))
              }, [
                f("div", {
                  class: "slider-cursor",
                  style: bt({ left: v.value[2] * 100 + "%" })
                }, null, 4)
              ], 36),
              f("input", {
                type: "number",
                value: Math.round(v.value[2] * 100),
                min: "0",
                max: "100",
                onInput: J[12] || (J[12] = (B) => Q(2, B))
              }, null, 40, e3)
            ])
          ])) : Pe("", !0),
          s.alpha ? (re(), ae("div", t3, [
            J[21] || (J[21] = f("label", null, "A", -1)),
            f("div", {
              class: "slider-track alpha-track",
              style: bt({ "--color": s.modelValue }),
              onMousedown: de,
              ref_key: "alphaSliderRef",
              ref: u
            }, [
              f("div", {
                class: "slider-cursor",
                style: bt({ left: m.value * 100 + "%" })
              }, null, 4)
            ], 36),
            f("input", {
              type: "number",
              value: Math.round(m.value * 100),
              min: "0",
              max: "100",
              onInput: Z
            }, null, 40, n3)
          ])) : Pe("", !0),
          f("div", i3, [
            J[22] || (J[22] = f("div", { class: "swatches-label" }, "Swatches", -1)),
            f("div", s3, [
              (re(!0), ae(Ze, null, at(g.value, (B) => (re(), ae("button", {
                key: B,
                class: "swatch",
                style: bt({ backgroundColor: B }),
                onClick: ($) => T(B)
              }, null, 12, r3))), 128))
            ])
          ]),
          p.value.length > 0 ? (re(), ae("div", o3, [
            J[23] || (J[23] = f("div", { class: "swatches-label" }, "Recent", -1)),
            f("div", a3, [
              (re(!0), ae(Ze, null, at(p.value, (B) => (re(), ae("button", {
                key: B,
                class: "swatch",
                style: bt({ backgroundColor: B }),
                onClick: ($) => T(B)
              }, null, 12, l3))), 128))
            ])
          ])) : Pe("", !0)
        ], 4)) : Pe("", !0)
      ], 8, ["disabled"]))
    ], 512));
  }
}), Kc = /* @__PURE__ */ Bt(c3, [["__scopeId", "data-v-05165efb"]]), u3 = { class: "effect-controls" }, d3 = { class: "panel-header" }, h3 = { class: "header-row" }, f3 = {
  key: 0,
  class: "layer-badge"
}, p3 = { class: "layer-type-icon" }, m3 = ["disabled"], v3 = {
  key: 0,
  class: "effect-menu"
}, g3 = { class: "category-label" }, y3 = { class: "cat-icon" }, _3 = { class: "category-items" }, x3 = ["onClick"], b3 = { class: "panel-content" }, w3 = {
  key: 0,
  class: "empty-state"
}, S3 = {
  key: 1,
  class: "empty-state"
}, M3 = {
  key: 2,
  class: "effects-list"
}, C3 = ["onClick"], E3 = { class: "header-left" }, T3 = { class: "arrow" }, A3 = ["onClick"], P3 = { class: "effect-name" }, D3 = { class: "header-right" }, R3 = ["onClick"], I3 = {
  key: 0,
  class: "effect-params"
}, k3 = { class: "param-header" }, L3 = ["title"], F3 = ["onClick"], U3 = { class: "param-control" }, O3 = {
  key: 0,
  class: "control-group"
}, z3 = {
  key: 1,
  class: "control-group"
}, N3 = {
  key: 2,
  class: "control-group point-group"
}, B3 = ["checked", "onChange"], V3 = ["value", "onChange"], G3 = ["value"], H3 = /* @__PURE__ */ Ut({
  __name: "EffectControlsPanel",
  setup(s) {
    const e = nn(), n = Se(!1), i = Se(null), r = Oe(() => e.selectedLayer), o = Vh;
    function a(T) {
      return Object.entries(Zc).filter(([b, M]) => M.category === T).map(([b, M]) => ({ key: b, ...M }));
    }
    function l(T, b) {
      const M = Zc[T];
      return M == null ? void 0 : M.parameters.find((L) => c(L.name) === b);
    }
    function c(T) {
      return T.toLowerCase().replace(/[^a-z0-9]+/g, "_").replace(/^_|_$/g, "");
    }
    function u(T, b) {
      const M = l(T, b);
      return M && (M.min !== void 0 || M.max !== void 0);
    }
    function d(T, b) {
      const M = l(T, b);
      return (M == null ? void 0 : M.type) === "checkbox";
    }
    function h(T, b) {
      const M = l(T, b);
      return (M == null ? void 0 : M.type) === "angle";
    }
    function m(T, b) {
      const M = l(T, b);
      return (M == null ? void 0 : M.options) || [];
    }
    function p(T) {
      return {
        solid: "",
        text: "T",
        spline: "~",
        null: "",
        camera: "",
        light: "",
        particles: "",
        image: ""
      }[T] || "";
    }
    function y(T) {
      r.value && (e.addEffectToLayer(r.value.id, T), n.value = !1);
    }
    function _(T) {
      r.value && e.removeEffectFromLayer(r.value.id, T.id);
    }
    function v(T) {
      r.value && e.toggleEffect(r.value.id, T.id);
    }
    function g(T) {
      T.expanded = !T.expanded;
    }
    function S(T, b, M) {
      r.value && e.updateEffectParameter(r.value.id, T, b, M);
    }
    function w(T, b, M, L) {
      if (!r.value) return;
      const N = r.value.effects.find((A) => A.id === T);
      if (!N) return;
      const O = { ...N.parameters[b].value, [M]: L };
      e.updateEffectParameter(r.value.id, T, b, O);
    }
    function x(T) {
      return typeof T == "string" ? T : FA(T.r, T.g, T.b, T.a ?? 1);
    }
    function C(T, b, M) {
      const L = kA(M);
      if (L && r.value) {
        const N = { r: L[0], g: L[1], b: L[2], a: L[3] };
        e.updateEffectParameter(r.value.id, T, b, N);
      }
    }
    function E(T, b) {
      if (!r.value) return;
      const M = r.value.effects.find((N) => N.id === T), L = M == null ? void 0 : M.parameters[b];
      L && e.setEffectParamAnimated(r.value.id, T, b, !L.animated);
    }
    function P(T) {
      i.value && !i.value.contains(T.target) && (n.value = !1);
    }
    return _n(() => window.addEventListener("mousedown", P)), jn(() => window.removeEventListener("mousedown", P)), (T, b) => (re(), ae("div", u3, [
      f("div", d3, [
        f("div", h3, [
          b[1] || (b[1] = f("h3", null, "Effect Controls", -1)),
          r.value ? (re(), ae("div", f3, [
            f("span", p3, be(p(r.value.type)), 1),
            ft(" " + be(r.value.name), 1)
          ])) : Pe("", !0)
        ]),
        f("div", {
          class: "add-effect-wrapper",
          ref_key: "menuRef",
          ref: i
        }, [
          f("button", {
            class: "add-btn",
            onClick: b[0] || (b[0] = (M) => n.value = !n.value),
            disabled: !r.value
          }, [...b[2] || (b[2] = [
            f("span", { class: "icon" }, "+", -1),
            ft(" Add Effect ", -1)
          ])], 8, m3),
          n.value ? (re(), ae("div", v3, [
            (re(!0), ae(Ze, null, at(Ge(o), (M, L) => (re(), ae("div", {
              key: L,
              class: "effect-category"
            }, [
              f("div", g3, [
                f("span", y3, be(M.icon), 1),
                ft(" " + be(M.label), 1)
              ]),
              f("div", _3, [
                (re(!0), ae(Ze, null, at(a(L), (N) => (re(), ae("button", {
                  key: N.key,
                  onClick: (D) => y(N.key)
                }, be(N.name), 9, x3))), 128))
              ])
            ]))), 128))
          ])) : Pe("", !0)
        ], 512)
      ]),
      f("div", b3, [
        r.value ? !r.value.effects || r.value.effects.length === 0 ? (re(), ae("div", S3, " No effects applied ")) : (re(), ae("div", M3, [
          (re(!0), ae(Ze, null, at(r.value.effects, (M, L) => (re(), ae("div", {
            key: M.id,
            class: Ue(["effect-item", { collapsed: !M.expanded }])
          }, [
            f("div", {
              class: "effect-header",
              onClick: (N) => g(M)
            }, [
              f("div", E3, [
                f("span", T3, be(M.expanded ? "" : ""), 1),
                f("button", {
                  class: "icon-btn",
                  onClick: wt((N) => v(M), ["stop"])
                }, [
                  f("span", {
                    class: Ue(["fx-icon", { disabled: !M.enabled }])
                  }, "fx", 2)
                ], 8, A3),
                f("span", P3, be(M.name), 1)
              ]),
              f("div", D3, [
                f("button", {
                  class: "icon-btn delete",
                  onClick: wt((N) => _(M), ["stop"]),
                  title: "Remove Effect"
                }, "", 8, R3)
              ])
            ], 8, C3),
            M.expanded ? (re(), ae("div", I3, [
              (re(!0), ae(Ze, null, at(M.parameters, (N, D) => {
                var O, A, G, he;
                return re(), ae("div", {
                  key: D,
                  class: "param-row"
                }, [
                  f("div", k3, [
                    f("span", {
                      class: "param-name",
                      title: String(D)
                    }, be(N.name), 9, L3),
                    f("button", {
                      class: Ue(["stopwatch", { active: N.animated }]),
                      onClick: (ee) => E(M.id, String(D)),
                      title: "Toggle Animation"
                    }, "", 10, F3)
                  ]),
                  f("div", U3, [
                    N.type === "number" && h(M.effectKey, String(D)) ? (re(), ae("div", O3, [
                      Ne(Nf, {
                        modelValue: N.value,
                        "onUpdate:modelValue": (ee) => S(M.id, String(D), ee),
                        size: 32,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ne(et, {
                        modelValue: N.value,
                        "onUpdate:modelValue": (ee) => S(M.id, String(D), ee),
                        unit: ""
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : N.type === "number" ? (re(), ae("div", z3, [
                      u(M.effectKey, String(D)) ? (re(), St(li, {
                        key: 0,
                        modelValue: N.value,
                        "onUpdate:modelValue": (ee) => S(M.id, String(D), ee),
                        min: ((O = l(M.effectKey, String(D))) == null ? void 0 : O.min) ?? 0,
                        max: ((A = l(M.effectKey, String(D))) == null ? void 0 : A.max) ?? 100,
                        step: ((G = l(M.effectKey, String(D))) == null ? void 0 : G.step) ?? 1,
                        showValue: !1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "min", "max", "step"])) : Pe("", !0),
                      Ne(et, {
                        modelValue: N.value,
                        "onUpdate:modelValue": (ee) => S(M.id, String(D), ee),
                        step: ((he = l(M.effectKey, String(D))) == null ? void 0 : he.step) ?? 0.1
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "step"])
                    ])) : N.type === "position" ? (re(), ae("div", N3, [
                      Ne(et, {
                        modelValue: N.value.x,
                        "onUpdate:modelValue": (ee) => w(M.id, String(D), "x", ee),
                        label: "X"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                      Ne(et, {
                        modelValue: N.value.y,
                        "onUpdate:modelValue": (ee) => w(M.id, String(D), "y", ee),
                        label: "Y"
                      }, null, 8, ["modelValue", "onUpdate:modelValue"])
                    ])) : N.type === "color" ? (re(), St(Kc, {
                      key: 3,
                      modelValue: x(N.value),
                      "onUpdate:modelValue": (ee) => C(M.id, String(D), ee),
                      alpha: !0
                    }, null, 8, ["modelValue", "onUpdate:modelValue"])) : N.type === "enum" && d(M.effectKey, String(D)) ? (re(), ae("input", {
                      key: 4,
                      type: "checkbox",
                      checked: N.value,
                      onChange: (ee) => S(M.id, String(D), ee.target.checked)
                    }, null, 40, B3)) : N.type === "enum" ? (re(), ae("select", {
                      key: 5,
                      value: N.value,
                      onChange: (ee) => S(M.id, String(D), ee.target.value),
                      class: "param-select"
                    }, [
                      (re(!0), ae(Ze, null, at(m(M.effectKey, String(D)), (ee) => (re(), ae("option", {
                        key: ee.value,
                        value: ee.value
                      }, be(ee.label), 9, G3))), 128))
                    ], 40, V3)) : Pe("", !0)
                  ])
                ]);
              }), 128))
            ])) : Pe("", !0)
          ], 2))), 128))
        ])) : (re(), ae("div", w3, " Select a layer to edit effects "))
      ])
    ]));
  }
}), W3 = /* @__PURE__ */ Bt(H3, [["__scopeId", "data-v-8ac57c6b"]]), rc = [
  { family: "Arial", fullName: "Arial", style: "normal", source: "websafe" },
  { family: "Arial Black", fullName: "Arial Black", style: "normal", source: "websafe" },
  { family: "Verdana", fullName: "Verdana", style: "normal", source: "websafe" },
  { family: "Tahoma", fullName: "Tahoma", style: "normal", source: "websafe" },
  { family: "Trebuchet MS", fullName: "Trebuchet MS", style: "normal", source: "websafe" },
  { family: "Times New Roman", fullName: "Times New Roman", style: "normal", source: "websafe" },
  { family: "Georgia", fullName: "Georgia", style: "normal", source: "websafe" },
  { family: "Courier New", fullName: "Courier New", style: "normal", source: "websafe" },
  { family: "Impact", fullName: "Impact", style: "normal", source: "websafe" },
  { family: "Comic Sans MS", fullName: "Comic Sans MS", style: "normal", source: "websafe" }
], oc = [
  "Roboto",
  "Open Sans",
  "Lato",
  "Montserrat",
  "Oswald",
  "Raleway",
  "Poppins",
  "Nunito",
  "Playfair Display",
  "Merriweather",
  "Ubuntu",
  "PT Sans",
  "Roboto Mono",
  "Bebas Neue",
  "Source Sans Pro",
  "Inter",
  "Fira Sans",
  "Quicksand",
  "Work Sans",
  "Barlow"
];
class $3 {
  constructor() {
    pe(this, "systemFonts", []);
    pe(this, "loadedGoogleFonts", /* @__PURE__ */ new Set());
    pe(this, "initialized", !1);
  }
  /**
   * Initialize font service and attempt to load system fonts
   */
  async initialize() {
    this.initialized || ("queryLocalFonts" in window && await this.loadSystemFonts(), this.initialized = !0);
  }
  /**
   * Load system fonts using Local Font Access API
   * Requires user permission
   */
  async loadSystemFonts() {
    try {
      const e = await window.queryLocalFonts(), n = /* @__PURE__ */ new Map();
      for (const i of e)
        (!n.has(i.family) || i.style === "Regular") && n.set(i.family, {
          family: i.family,
          fullName: i.fullName,
          style: i.style,
          source: "system"
        });
      this.systemFonts = Array.from(n.values()).sort((i, r) => i.family.localeCompare(r.family)), console.log(`[FontService] Loaded ${this.systemFonts.length} system fonts`);
    } catch (e) {
      e.name === "NotAllowedError" ? console.log("[FontService] User denied font access permission") : console.error("[FontService] Error loading system fonts:", e);
    }
  }
  /**
   * Get all available fonts organized by category
   */
  getFontCategories() {
    const e = [];
    return this.systemFonts.length > 0 && e.push({
      name: "System Fonts",
      fonts: this.systemFonts
    }), e.push({
      name: "Web Safe",
      fonts: rc
    }), e.push({
      name: "Google Fonts",
      fonts: oc.map((n) => ({
        family: n,
        fullName: n,
        style: "normal",
        source: "google"
      }))
    }), e;
  }
  /**
   * Get flat list of all font families
   */
  getAllFontFamilies() {
    const e = /* @__PURE__ */ new Set();
    return rc.forEach((n) => e.add(n.family)), oc.forEach((n) => e.add(n)), this.systemFonts.forEach((n) => e.add(n.family)), Array.from(e).sort();
  }
  /**
   * Load a Google Font dynamically
   */
  async loadGoogleFont(e, n = ["400", "700"]) {
    if (this.loadedGoogleFonts.has(e)) return;
    const i = n.join(";"), r = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(e)}:wght@${i}&display=swap`, o = document.createElement("link");
    o.rel = "stylesheet", o.href = r, document.head.appendChild(o);
    try {
      await document.fonts.load(`400 16px "${e}"`), this.loadedGoogleFonts.add(e), console.log(`[FontService] Loaded Google Font: ${e}`);
    } catch (a) {
      console.error(`[FontService] Failed to load Google Font: ${e}`, a);
    }
  }
  /**
   * Ensure a font is available before using it
   */
  async ensureFont(e) {
    return rc.some((n) => n.family === e) ? !0 : oc.includes(e) ? (await this.loadGoogleFont(e), !0) : this.systemFonts.some((n) => n.family === e) ? !0 : this.isFontAvailable(e);
  }
  /**
   * Check if a font is available by measuring text
   */
  isFontAvailable(e) {
    const n = "mmmmmmmmmmlli", r = document.createElement("canvas").getContext("2d");
    r.font = "72px monospace";
    const o = r.measureText(n).width;
    r.font = `72px "${e}", monospace`;
    const a = r.measureText(n).width;
    return o !== a;
  }
  /**
   * Get web-safe fonts list
   */
  getWebSafeFonts() {
    return rc;
  }
  /**
   * Get Google fonts list
   */
  getGoogleFonts() {
    return oc;
  }
  /**
   * Check if system fonts are available
   */
  hasSystemFonts() {
    return this.systemFonts.length > 0;
  }
  /**
   * Request system font access (must be triggered by user action)
   */
  async requestSystemFontAccess() {
    return "queryLocalFonts" in window ? (await this.loadSystemFonts(), this.systemFonts.length > 0) : (console.log("[FontService] Local Font Access API not available"), !1);
  }
}
const co = new $3(), X3 = { class: "text-properties" }, j3 = { class: "prop-section" }, Y3 = ["value"], q3 = { class: "prop-section" }, Z3 = { class: "row font-row" }, K3 = ["value"], J3 = ["label"], Q3 = ["value"], eP = { class: "style-toggles" }, tP = {
  key: 0,
  class: "row"
}, nP = ["disabled"], iP = { class: "row" }, sP = { class: "row color-row" }, rP = { class: "color-item" }, oP = ["value"], aP = { class: "color-item" }, lP = ["value"], cP = { class: "row" }, uP = { class: "row" }, dP = { class: "align-buttons" }, hP = { class: "prop-section" }, fP = { class: "row" }, pP = { class: "vec2" }, mP = { class: "row" }, vP = { class: "vec2" }, gP = { class: "row" }, yP = { class: "vec2" }, _P = { class: "row" }, xP = { class: "row" }, bP = { class: "prop-section" }, wP = { class: "row" }, SP = ["value"], MP = ["value"], CP = { class: "row" }, EP = { class: "row" }, TP = { class: "row" }, AP = { class: "row checkbox-row" }, PP = ["checked"], DP = { class: "row checkbox-row" }, RP = ["checked"], IP = { class: "row checkbox-row" }, kP = ["checked"], LP = { class: "prop-section" }, FP = { class: "row" }, UP = { class: "row" }, OP = { class: "row" }, zP = { class: "prop-section checkbox" }, NP = ["checked"], BP = /* @__PURE__ */ Ut({
  __name: "TextProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Se([]), a = Se(!1), l = Se(!1);
    _n(async () => {
      await co.initialize(), o.value = co.getFontCategories(), a.value = co.hasSystemFonts();
    });
    async function c() {
      l.value = !0;
      try {
        await co.requestSystemFontAccess() && (o.value = co.getFontCategories(), a.value = !0);
      } finally {
        l.value = !1;
      }
    }
    const u = Oe(() => n.layer.data), d = Oe(() => n.layer.transform), h = Oe(() => r.layers.filter((T) => T.type === "spline"));
    function m(T) {
      var b;
      return (b = n.layer.properties) == null ? void 0 : b.find((M) => M.name === T);
    }
    function p(T) {
      const b = m(T);
      return b ? b.value : null;
    }
    function y(T) {
      r.setPropertyValue(n.layer.id, "Source Text", T), r.updateLayerData(n.layer.id, { text: T }), i("update");
    }
    function _(T, b) {
      r.updateLayerData(n.layer.id, { [T]: b });
      const M = {
        fill: "Fill Color",
        stroke: "Stroke Color",
        fontSize: "Font Size",
        strokeWidth: "Stroke Width"
      };
      M[T] && r.setPropertyValue(n.layer.id, M[T], b), i("update");
    }
    function v(T, b) {
      r.setPropertyValue(n.layer.id, T, b);
      const M = {
        "Font Size": "fontSize",
        "Stroke Width": "strokeWidth",
        Tracking: "tracking",
        "Line Spacing": "lineSpacing",
        "Character Offset": "characterOffset",
        "Path Offset": "pathOffset",
        "First Margin": "pathFirstMargin",
        "Last Margin": "pathLastMargin"
      };
      M[T] && r.updateLayerData(n.layer.id, { [M[T]]: b }), i("update");
    }
    function g(T) {
      const b = m(T);
      return (b == null ? void 0 : b.animated) ?? !1;
    }
    function S(T) {
      var N;
      const b = m(T);
      if (!b) return;
      const M = r.currentFrame, L = (N = b.keyframes) == null ? void 0 : N.find((D) => D.frame === M);
      L ? r.removeKeyframe(n.layer.id, T, L.id) : r.addKeyframe(n.layer.id, T, b.value, M), i("update");
    }
    function w(T, b, M) {
      const L = d.value[T];
      let N;
      b ? N = { ...L.value, [b]: M } : N = M, r.setPropertyValue(n.layer.id, `transform.${T}`, N), i("update");
    }
    function x(T) {
      r.setPropertyValue(n.layer.id, "opacity", T), i("update");
    }
    function C() {
      _("fontWeight", u.value.fontWeight === "bold" ? "400" : "bold");
    }
    function E() {
      _("fontStyle", u.value.fontStyle === "italic" ? "normal" : "italic");
    }
    async function P(T) {
      await co.ensureFont(T), _("fontFamily", T);
    }
    return (T, b) => {
      var M;
      return re(), ae("div", X3, [
        f("div", j3, [
          b[29] || (b[29] = f("div", { class: "section-title" }, "Source Text", -1)),
          f("textarea", {
            value: u.value.text,
            onInput: b[0] || (b[0] = (L) => y(L.target.value)),
            class: "text-area",
            rows: "3"
          }, null, 40, Y3)
        ]),
        f("div", q3, [
          b[35] || (b[35] = f("div", { class: "section-title" }, "Character", -1)),
          f("div", Z3, [
            f("select", {
              value: u.value.fontFamily,
              onChange: b[1] || (b[1] = (L) => P(L.target.value)),
              class: "font-select"
            }, [
              (re(!0), ae(Ze, null, at(o.value, (L) => (re(), ae("optgroup", {
                key: L.name,
                label: L.name
              }, [
                (re(!0), ae(Ze, null, at(L.fonts, (N) => (re(), ae("option", {
                  key: N.family,
                  value: N.family
                }, be(N.family), 9, Q3))), 128))
              ], 8, J3))), 128))
            ], 40, K3),
            f("div", eP, [
              f("button", {
                class: Ue({ active: u.value.fontWeight === "bold" }),
                onClick: C
              }, "B", 2),
              f("button", {
                class: Ue({ active: u.value.fontStyle === "italic" }),
                onClick: E
              }, "I", 2)
            ])
          ]),
          a.value ? Pe("", !0) : (re(), ae("div", tP, [
            f("button", {
              class: "font-access-btn",
              onClick: c,
              disabled: l.value
            }, be(l.value ? "Loading..." : "+ Load System Fonts"), 9, nP)
          ])),
          f("div", iP, [
            b[30] || (b[30] = f("label", null, "Size", -1)),
            Ne(Ge(et), {
              modelValue: p("Font Size") || u.value.fontSize,
              "onUpdate:modelValue": b[2] || (b[2] = (L) => v("Font Size", L))
            }, null, 8, ["modelValue"])
          ]),
          f("div", sP, [
            f("div", rP, [
              f("input", {
                type: "color",
                value: u.value.fill,
                onInput: b[3] || (b[3] = (L) => _("fill", L.target.value))
              }, null, 40, oP),
              b[31] || (b[31] = f("span", null, "Fill", -1))
            ]),
            f("div", aP, [
              f("input", {
                type: "color",
                value: u.value.stroke || "#000000",
                onInput: b[4] || (b[4] = (L) => _("stroke", L.target.value))
              }, null, 40, lP),
              b[32] || (b[32] = f("span", null, "Stroke", -1))
            ])
          ]),
          f("div", cP, [
            b[33] || (b[33] = f("label", null, "Stroke Width", -1)),
            Ne(Ge(et), {
              modelValue: p("Stroke Width") || u.value.strokeWidth || 0,
              "onUpdate:modelValue": b[5] || (b[5] = (L) => v("Stroke Width", L)),
              min: 0,
              max: 50
            }, null, 8, ["modelValue"])
          ]),
          f("div", uP, [
            b[34] || (b[34] = f("label", null, "Alignment", -1)),
            f("div", dP, [
              f("button", {
                class: Ue({ active: u.value.textAlign === "left" }),
                onClick: b[6] || (b[6] = (L) => _("textAlign", "left"))
              }, "", 2),
              f("button", {
                class: Ue({ active: u.value.textAlign === "center" }),
                onClick: b[7] || (b[7] = (L) => _("textAlign", "center"))
              }, "", 2),
              f("button", {
                class: Ue({ active: u.value.textAlign === "right" }),
                onClick: b[8] || (b[8] = (L) => _("textAlign", "right"))
              }, "", 2)
            ])
          ])
        ]),
        f("div", hP, [
          b[41] || (b[41] = f("div", { class: "section-title" }, "Transform", -1)),
          f("div", fP, [
            b[36] || (b[36] = f("label", null, "Position", -1)),
            f("div", pP, [
              Ne(Ge(et), {
                modelValue: d.value.position.value.x,
                "onUpdate:modelValue": b[9] || (b[9] = (L) => w("position", "x", L))
              }, null, 8, ["modelValue"]),
              Ne(Ge(et), {
                modelValue: d.value.position.value.y,
                "onUpdate:modelValue": b[10] || (b[10] = (L) => w("position", "y", L))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", mP, [
            b[37] || (b[37] = f("label", null, "Anchor Pt", -1)),
            f("div", vP, [
              Ne(Ge(et), {
                modelValue: d.value.anchorPoint.value.x,
                "onUpdate:modelValue": b[11] || (b[11] = (L) => w("anchorPoint", "x", L))
              }, null, 8, ["modelValue"]),
              Ne(Ge(et), {
                modelValue: d.value.anchorPoint.value.y,
                "onUpdate:modelValue": b[12] || (b[12] = (L) => w("anchorPoint", "y", L))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", gP, [
            b[38] || (b[38] = f("label", null, "Scale %", -1)),
            f("div", yP, [
              Ne(Ge(et), {
                modelValue: d.value.scale.value.x,
                "onUpdate:modelValue": b[13] || (b[13] = (L) => w("scale", "x", L))
              }, null, 8, ["modelValue"]),
              Ne(Ge(et), {
                modelValue: d.value.scale.value.y,
                "onUpdate:modelValue": b[14] || (b[14] = (L) => w("scale", "y", L))
              }, null, 8, ["modelValue"])
            ])
          ]),
          f("div", _P, [
            b[39] || (b[39] = f("label", null, "Rotation", -1)),
            Ne(Ge(et), {
              modelValue: d.value.rotation.value,
              "onUpdate:modelValue": b[15] || (b[15] = (L) => w("rotation", null, L))
            }, null, 8, ["modelValue"])
          ]),
          f("div", xP, [
            b[40] || (b[40] = f("label", null, "Opacity", -1)),
            Ne(Ge(et), {
              modelValue: ((M = s.layer.opacity) == null ? void 0 : M.value) ?? 100,
              "onUpdate:modelValue": b[16] || (b[16] = (L) => x(L)),
              min: 0,
              max: 100
            }, null, 8, ["modelValue"])
          ])
        ]),
        f("div", bP, [
          b[50] || (b[50] = f("div", { class: "section-title" }, "Path Options", -1)),
          f("div", wP, [
            b[43] || (b[43] = f("label", null, "Path", -1)),
            f("select", {
              value: u.value.pathLayerId || "",
              onChange: b[17] || (b[17] = (L) => _("pathLayerId", L.target.value || null)),
              class: "full-select"
            }, [
              b[42] || (b[42] = f("option", { value: "" }, "None", -1)),
              (re(!0), ae(Ze, null, at(h.value, (L) => (re(), ae("option", {
                key: L.id,
                value: L.id
              }, be(L.name), 9, MP))), 128))
            ], 40, SP)
          ]),
          u.value.pathLayerId ? (re(), ae(Ze, { key: 0 }, [
            f("div", CP, [
              b[44] || (b[44] = f("label", null, "Path Offset %", -1)),
              Ne(Ge(et), {
                modelValue: p("Path Offset") ?? u.value.pathOffset ?? 0,
                "onUpdate:modelValue": b[18] || (b[18] = (L) => v("Path Offset", L)),
                min: -100,
                max: 200,
                precision: 1
              }, null, 8, ["modelValue"]),
              f("button", {
                class: Ue(["keyframe-btn", { active: g("Path Offset") }]),
                onClick: b[19] || (b[19] = (L) => S("Path Offset")),
                title: "Add keyframe"
              }, "", 2)
            ]),
            f("div", EP, [
              b[45] || (b[45] = f("label", null, "First Margin", -1)),
              Ne(Ge(et), {
                modelValue: p("First Margin") ?? u.value.pathFirstMargin ?? 0,
                "onUpdate:modelValue": b[20] || (b[20] = (L) => v("First Margin", L)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            f("div", TP, [
              b[46] || (b[46] = f("label", null, "Last Margin", -1)),
              Ne(Ge(et), {
                modelValue: p("Last Margin") ?? u.value.pathLastMargin ?? 0,
                "onUpdate:modelValue": b[21] || (b[21] = (L) => v("Last Margin", L)),
                min: 0
              }, null, 8, ["modelValue"])
            ]),
            f("div", AP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathReversed,
                  onChange: b[22] || (b[22] = (L) => _("pathReversed", !u.value.pathReversed))
                }, null, 40, PP),
                b[47] || (b[47] = ft(" Reverse Path ", -1))
              ])
            ]),
            f("div", DP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathPerpendicularToPath ?? !0,
                  onChange: b[23] || (b[23] = (L) => _("pathPerpendicularToPath", !u.value.pathPerpendicularToPath))
                }, null, 40, RP),
                b[48] || (b[48] = ft(" Perpendicular to Path ", -1))
              ])
            ]),
            f("div", IP, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: u.value.pathForceAlignment,
                  onChange: b[24] || (b[24] = (L) => _("pathForceAlignment", !u.value.pathForceAlignment))
                }, null, 40, kP),
                b[49] || (b[49] = ft(" Force Alignment ", -1))
              ])
            ])
          ], 64)) : Pe("", !0)
        ]),
        f("div", LP, [
          b[54] || (b[54] = f("div", { class: "section-title" }, "Advanced", -1)),
          f("div", FP, [
            b[51] || (b[51] = f("label", null, "Tracking", -1)),
            Ne(Ge(et), {
              modelValue: p("Tracking") || u.value.tracking || 0,
              "onUpdate:modelValue": b[25] || (b[25] = (L) => v("Tracking", L))
            }, null, 8, ["modelValue"])
          ]),
          f("div", UP, [
            b[52] || (b[52] = f("label", null, "Line Spacing", -1)),
            Ne(Ge(et), {
              modelValue: p("Line Spacing") || u.value.lineSpacing || 0,
              "onUpdate:modelValue": b[26] || (b[26] = (L) => v("Line Spacing", L))
            }, null, 8, ["modelValue"])
          ]),
          f("div", OP, [
            b[53] || (b[53] = f("label", null, "Char Offset", -1)),
            Ne(Ge(et), {
              modelValue: p("Character Offset") || u.value.characterOffset || 0,
              "onUpdate:modelValue": b[27] || (b[27] = (L) => v("Character Offset", L)),
              precision: 0
            }, null, 8, ["modelValue"])
          ])
        ]),
        f("div", zP, [
          f("label", null, [
            f("input", {
              type: "checkbox",
              checked: u.value.perCharacter3D,
              onChange: b[28] || (b[28] = (L) => _("perCharacter3D", !u.value.perCharacter3D))
            }, null, 40, NP),
            b[55] || (b[55] = ft(" Enable Per-Character 3D ", -1))
          ])
        ])
      ]);
    };
  }
}), VP = /* @__PURE__ */ Bt(BP, [["__scopeId", "data-v-947c42b2"]]), GP = { class: "particle-properties" }, HP = { class: "property-section" }, WP = {
  key: 0,
  class: "section-content"
}, $P = { class: "property-row" }, XP = ["value"], jP = { class: "value-display" }, YP = { class: "property-row" }, qP = ["value"], ZP = { class: "value-display" }, KP = { class: "property-row" }, JP = ["value"], QP = { class: "value-display" }, eD = { class: "property-row" }, tD = ["value"], nD = { class: "value-display" }, iD = { class: "property-row" }, sD = ["value"], rD = { class: "value-display" }, oD = { class: "property-row" }, aD = ["value"], lD = { class: "property-section" }, cD = {
  key: 0,
  class: "section-content"
}, uD = ["onClick"], dD = ["value", "onInput"], hD = { class: "enabled-toggle" }, fD = ["checked", "onChange"], pD = ["onClick"], mD = {
  key: 0,
  class: "emitter-content"
}, vD = { class: "property-row" }, gD = ["value", "onInput"], yD = { class: "value-display" }, _D = { class: "property-row" }, xD = ["value", "onInput"], bD = { class: "value-display" }, wD = { class: "property-row" }, SD = ["value", "onInput"], MD = { class: "value-display" }, CD = { class: "property-row" }, ED = ["value", "onInput"], TD = { class: "value-display" }, AD = { class: "property-row" }, PD = ["value", "onInput"], DD = { class: "value-display" }, RD = { class: "property-row" }, ID = ["value", "onInput"], kD = { class: "value-display" }, LD = { class: "property-row" }, FD = ["value", "onInput"], UD = { class: "value-display" }, OD = { class: "property-row" }, zD = ["value", "onInput"], ND = { class: "value-display" }, BD = { class: "property-row" }, VD = ["value", "onInput"], GD = { class: "property-row" }, HD = ["value", "onInput"], WD = { class: "value-display" }, $D = { class: "property-row" }, XD = ["value", "onInput"], jD = { class: "value-display" }, YD = { class: "property-row" }, qD = ["value", "onInput"], ZD = { class: "value-display" }, KD = { class: "property-row checkbox-row" }, JD = ["checked", "onChange"], QD = {
  key: 0,
  class: "property-row"
}, eR = ["value", "onInput"], tR = { class: "value-display" }, nR = {
  key: 0,
  class: "empty-message"
}, iR = { class: "property-section" }, sR = {
  key: 0,
  class: "section-content"
}, rR = { class: "force-tabs" }, oR = {
  key: 0,
  class: "force-list"
}, aR = { class: "force-header" }, lR = ["value", "onInput"], cR = { class: "enabled-toggle" }, uR = ["checked", "onChange"], dR = ["onClick"], hR = { class: "property-row" }, fR = ["value", "onInput"], pR = { class: "value-display" }, mR = { class: "property-row" }, vR = ["value", "onInput"], gR = { class: "value-display" }, yR = { class: "property-row" }, _R = ["value", "onInput"], xR = { class: "value-display" }, bR = { class: "property-row" }, wR = ["value", "onInput"], SR = { class: "value-display" }, MR = { class: "property-row" }, CR = ["value", "onChange"], ER = {
  key: 1,
  class: "force-list"
}, TR = { class: "force-header" }, AR = ["value", "onInput"], PR = { class: "enabled-toggle" }, DR = ["checked", "onChange"], RR = ["onClick"], IR = { class: "property-row" }, kR = ["value", "onInput"], LR = { class: "value-display" }, FR = { class: "property-row" }, UR = ["value", "onInput"], OR = { class: "value-display" }, zR = { class: "property-row" }, NR = ["value", "onInput"], BR = { class: "value-display" }, VR = { class: "property-row" }, GR = ["value", "onInput"], HR = { class: "value-display" }, WR = { class: "property-row" }, $R = ["value", "onInput"], XR = { class: "value-display" }, jR = { class: "property-row" }, YR = ["value", "onInput"], qR = { class: "value-display" }, ZR = { class: "property-section" }, KR = {
  key: 0,
  class: "section-content"
}, JR = { class: "force-header" }, QR = { class: "enabled-toggle" }, eI = ["checked", "onChange"], tI = ["onClick"], nI = { class: "property-row" }, iI = ["value", "onInput"], sI = { class: "value-display" }, rI = { class: "property-row" }, oI = ["value", "onInput"], aI = { class: "value-display" }, lI = { class: "property-row" }, cI = ["value", "onInput"], uI = { class: "value-display" }, dI = {
  key: 0,
  class: "empty-message"
}, hI = { class: "property-section" }, fI = {
  key: 0,
  class: "section-content"
}, pI = { class: "force-header" }, mI = ["value", "onChange"], vI = ["value"], gI = { class: "enabled-toggle" }, yI = ["checked", "onChange"], _I = ["onClick"], xI = { class: "property-row" }, bI = ["value", "onChange"], wI = { class: "property-row" }, SI = ["value", "onInput"], MI = { class: "value-display" }, CI = { class: "property-row" }, EI = ["value", "onInput"], TI = { class: "value-display" }, AI = { class: "property-row" }, PI = ["value", "onInput"], DI = { class: "value-display" }, RI = { class: "property-row" }, II = ["value", "onInput"], kI = { class: "value-display" }, LI = { class: "property-row" }, FI = ["value", "onInput"], UI = { class: "value-display" }, OI = { class: "property-row" }, zI = ["value", "onInput"], NI = { class: "value-display" }, BI = { class: "property-row" }, VI = ["value", "onInput"], GI = {
  key: 0,
  class: "empty-message"
}, HI = { class: "property-section" }, WI = {
  key: 0,
  class: "section-content"
}, $I = { class: "modulation-header" }, XI = ["value", "onChange"], jI = ["value"], YI = ["onClick"], qI = { class: "property-row" }, ZI = ["value", "onChange"], KI = { class: "property-row" }, JI = ["value", "onInput"], QI = { class: "property-row" }, ek = ["value", "onInput"], tk = { class: "property-row" }, nk = ["value", "onChange"], ik = {
  key: 0,
  class: "empty-message"
}, sk = { class: "property-section" }, rk = {
  key: 0,
  class: "section-content"
}, ok = { class: "property-row" }, ak = ["value"], lk = { class: "property-row" }, ck = ["value"], uk = { class: "property-row checkbox-row" }, dk = ["checked"], hk = {
  key: 0,
  class: "property-row"
}, fk = ["value"], pk = { class: "value-display" }, mk = { class: "property-row checkbox-row" }, vk = ["checked"], gk = {
  key: 1,
  class: "property-row"
}, yk = ["value"], _k = { class: "value-display" }, xk = {
  key: 2,
  class: "property-row"
}, bk = ["value"], wk = { class: "value-display" }, Sk = { class: "property-row checkbox-row" }, Mk = ["checked"], Ck = {
  key: 3,
  class: "property-row"
}, Ek = ["value"], Tk = { class: "value-display" }, Ak = {
  key: 4,
  class: "property-row"
}, Pk = ["value"], Dk = { class: "value-display" }, Rk = {
  key: 5,
  class: "property-row"
}, Ik = ["value"], kk = { class: "value-display" }, Lk = {
  key: 6,
  class: "property-row"
}, Fk = ["value"], Uk = { class: "value-display" }, Ok = {
  key: 7,
  class: "property-row checkbox-row"
}, zk = ["checked"], Nk = { class: "particle-count" }, Bk = /* @__PURE__ */ Ut({
  __name: "ParticleProperties",
  props: {
    layer: {},
    particleCount: { default: 0 }
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = Se(/* @__PURE__ */ new Set(["system", "emitters"])), o = Se(/* @__PURE__ */ new Set()), a = Se("wells"), l = Oe(() => n.layer.data || {
      systemConfig: {
        maxParticles: 1e4,
        gravity: 0,
        windStrength: 0,
        windDirection: 0,
        warmupPeriod: 0,
        respectMaskBoundary: !1,
        boundaryBehavior: "kill",
        friction: 0.01
      },
      emitters: [],
      gravityWells: [],
      vortices: [],
      modulations: [],
      renderOptions: {
        blendMode: "additive",
        renderTrails: !1,
        trailLength: 5,
        trailOpacityFalloff: 0.7,
        particleShape: "circle",
        glowEnabled: !1,
        glowRadius: 10,
        glowIntensity: 0.5,
        motionBlur: !1,
        motionBlurStrength: 0.5,
        motionBlurSamples: 8,
        connections: {
          enabled: !1,
          maxDistance: 100,
          maxConnections: 3,
          lineWidth: 1,
          lineOpacity: 0.5,
          fadeByDistance: !0
        }
      },
      turbulenceFields: [],
      subEmitters: []
    }), c = Oe(() => l.value.systemConfig), u = Oe(() => l.value.emitters), d = Oe(() => l.value.gravityWells), h = Oe(() => l.value.vortices), m = Oe(() => l.value.modulations), p = Oe(() => l.value.renderOptions), y = Oe(() => l.value.turbulenceFields || []), _ = Oe(() => l.value.subEmitters || []), v = Oe(() => p.value.connections || {
      enabled: !1,
      maxDistance: 100,
      maxConnections: 3,
      lineWidth: 1,
      lineOpacity: 0.5,
      fadeByDistance: !0
    }), g = Oe(() => n.particleCount);
    function S(V) {
      r.value.has(V) ? r.value.delete(V) : r.value.add(V);
    }
    function w(V) {
      o.value.has(V) ? o.value.delete(V) : o.value.add(V);
    }
    function x(V, I) {
      i("update", {
        systemConfig: { ...c.value, [V]: I }
      });
    }
    function C(V, I, F) {
      const k = u.value.map(
        (Q) => Q.id === V ? { ...Q, [I]: F } : Q
      );
      i("update", { emitters: k });
    }
    function E(V, I) {
      const F = X(I);
      C(V, "color", F);
    }
    function P() {
      const V = {
        id: `emitter_${Date.now()}`,
        name: `Emitter ${u.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        direction: 270,
        spread: 30,
        speed: 330,
        speedVariance: 50,
        size: 17,
        sizeVariance: 5,
        color: [255, 255, 255],
        emissionRate: 10,
        initialBurst: 0,
        particleLifetime: 60,
        lifetimeVariance: 10,
        enabled: !0,
        burstOnBeat: !1,
        burstCount: 20
      };
      i("update", { emitters: [...u.value, V] }), o.value.add(V.id);
    }
    function T(V) {
      i("update", { emitters: u.value.filter((I) => I.id !== V) });
    }
    function b(V, I, F) {
      const k = d.value.map(
        (Q) => Q.id === V ? { ...Q, [I]: F } : Q
      );
      i("update", { gravityWells: k });
    }
    function M() {
      const V = {
        id: `well_${Date.now()}`,
        name: `Gravity Well ${d.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 100,
        radius: 0.3,
        falloff: "quadratic",
        enabled: !0
      };
      i("update", { gravityWells: [...d.value, V] });
    }
    function L(V) {
      i("update", { gravityWells: d.value.filter((I) => I.id !== V) });
    }
    function N(V, I, F) {
      const k = h.value.map(
        (Q) => Q.id === V ? { ...Q, [I]: F } : Q
      );
      i("update", { vortices: k });
    }
    function D() {
      const V = {
        id: `vortex_${Date.now()}`,
        name: `Vortex ${h.value.length + 1}`,
        x: 0.5,
        y: 0.5,
        strength: 200,
        radius: 0.3,
        rotationSpeed: 5,
        inwardPull: 10,
        enabled: !0
      };
      i("update", { vortices: [...h.value, V] });
    }
    function O(V) {
      i("update", { vortices: h.value.filter((I) => I.id !== V) });
    }
    function A(V, I, F) {
      const k = m.value.map(
        (Q) => Q.id === V ? { ...Q, [I]: F } : Q
      );
      i("update", { modulations: k });
    }
    function G() {
      const V = {
        id: `mod_${Date.now()}`,
        emitterId: "*",
        property: "opacity",
        startValue: 1,
        endValue: 0,
        easing: "linear"
      };
      i("update", { modulations: [...m.value, V] });
    }
    function he(V) {
      i("update", { modulations: m.value.filter((I) => I.id !== V) });
    }
    function ee(V, I) {
      i("update", {
        renderOptions: { ...p.value, [V]: I }
      });
    }
    function le(V, I) {
      i("update", {
        renderOptions: {
          ...p.value,
          connections: { ...v.value, [V]: I }
        }
      });
    }
    function oe(V, I, F) {
      const k = y.value.map(
        (Q) => Q.id === V ? { ...Q, [I]: F } : Q
      );
      i("update", { turbulenceFields: k });
    }
    function Y() {
      const V = {
        id: `turb_${Date.now()}`,
        enabled: !0,
        scale: 5e-3,
        strength: 100,
        evolutionSpeed: 0.1
      };
      i("update", { turbulenceFields: [...y.value, V] });
    }
    function j(V) {
      i("update", { turbulenceFields: y.value.filter((I) => I.id !== V) });
    }
    function q(V, I, F) {
      const k = _.value.map(
        (Q) => Q.id === V ? { ...Q, [I]: F } : Q
      );
      i("update", { subEmitters: k });
    }
    function te(V, I) {
      const F = X(I);
      q(V, "color", F);
    }
    function ne() {
      const V = {
        id: `sub_${Date.now()}`,
        parentEmitterId: "*",
        trigger: "death",
        spawnCount: 3,
        inheritVelocity: 0.5,
        size: 5,
        sizeVariance: 2,
        lifetime: 30,
        speed: 50,
        spread: 360,
        color: [255, 200, 100],
        enabled: !0
      };
      i("update", { subEmitters: [..._.value, V] });
    }
    function de(V) {
      i("update", { subEmitters: _.value.filter((I) => I.id !== V) });
    }
    function H(V) {
      return "#" + V.map((I) => I.toString(16).padStart(2, "0")).join("");
    }
    function X(V) {
      const I = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(V);
      return I ? [parseInt(I[1], 16), parseInt(I[2], 16), parseInt(I[3], 16)] : [255, 255, 255];
    }
    return (V, I) => (re(), ae("div", GP, [
      f("div", HP, [
        f("div", {
          class: "section-header",
          onClick: I[0] || (I[0] = (F) => S("system"))
        }, [
          f("i", {
            class: Ue(["pi", r.value.has("system") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[30] || (I[30] = f("span", null, "System Settings", -1))
        ]),
        r.value.has("system") ? (re(), ae("div", WP, [
          f("div", $P, [
            I[31] || (I[31] = f("label", null, "Max Particles", -1)),
            f("input", {
              type: "range",
              value: c.value.maxParticles,
              min: "100",
              max: "50000",
              step: "100",
              onInput: I[1] || (I[1] = (F) => x("maxParticles", Number(F.target.value)))
            }, null, 40, XP),
            f("span", jP, be(c.value.maxParticles), 1)
          ]),
          f("div", YP, [
            I[32] || (I[32] = f("label", null, "Gravity", -1)),
            f("input", {
              type: "range",
              value: c.value.gravity,
              min: "-1000",
              max: "1000",
              step: "10",
              onInput: I[2] || (I[2] = (F) => x("gravity", Number(F.target.value)))
            }, null, 40, qP),
            f("span", ZP, be(c.value.gravity), 1)
          ]),
          f("div", KP, [
            I[33] || (I[33] = f("label", null, "Wind Strength", -1)),
            f("input", {
              type: "range",
              value: c.value.windStrength,
              min: "0",
              max: "1000",
              step: "10",
              onInput: I[3] || (I[3] = (F) => x("windStrength", Number(F.target.value)))
            }, null, 40, JP),
            f("span", QP, be(c.value.windStrength), 1)
          ]),
          f("div", eD, [
            I[34] || (I[34] = f("label", null, "Wind Direction", -1)),
            f("input", {
              type: "range",
              value: c.value.windDirection,
              min: "0",
              max: "360",
              step: "5",
              onInput: I[4] || (I[4] = (F) => x("windDirection", Number(F.target.value)))
            }, null, 40, tD),
            f("span", nD, be(c.value.windDirection) + "", 1)
          ]),
          f("div", iD, [
            I[35] || (I[35] = f("label", null, "Friction", -1)),
            f("input", {
              type: "range",
              value: c.value.friction,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: I[5] || (I[5] = (F) => x("friction", Number(F.target.value)))
            }, null, 40, sD),
            f("span", rD, be(c.value.friction.toFixed(2)), 1)
          ]),
          f("div", oD, [
            I[37] || (I[37] = f("label", null, "Boundary", -1)),
            f("select", {
              value: c.value.boundaryBehavior,
              onChange: I[6] || (I[6] = (F) => x("boundaryBehavior", F.target.value))
            }, [...I[36] || (I[36] = [
              f("option", { value: "kill" }, "Kill", -1),
              f("option", { value: "bounce" }, "Bounce", -1),
              f("option", { value: "wrap" }, "Wrap", -1)
            ])], 40, aD)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", lD, [
        f("div", {
          class: "section-header",
          onClick: I[7] || (I[7] = (F) => S("emitters"))
        }, [
          f("i", {
            class: Ue(["pi", r.value.has("emitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[39] || (I[39] = f("span", null, "Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: wt(P, ["stop"]),
            title: "Add Emitter"
          }, [...I[38] || (I[38] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("emitters") ? (re(), ae("div", cD, [
          (re(!0), ae(Ze, null, at(u.value, (F) => (re(), ae("div", {
            key: F.id,
            class: "emitter-item"
          }, [
            f("div", {
              class: "emitter-header",
              onClick: (k) => w(F.id)
            }, [
              f("i", {
                class: Ue(["pi", o.value.has(F.id) ? "pi-chevron-down" : "pi-chevron-right"])
              }, null, 2),
              f("input", {
                type: "text",
                value: F.name,
                onInput: (k) => C(F.id, "name", k.target.value),
                onClick: I[8] || (I[8] = wt(() => {
                }, ["stop"])),
                class: "emitter-name"
              }, null, 40, dD),
              f("label", hD, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (k) => C(F.id, "enabled", k.target.checked),
                  onClick: I[9] || (I[9] = wt(() => {
                  }, ["stop"]))
                }, null, 40, fD)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: wt((k) => T(F.id), ["stop"]),
                title: "Remove"
              }, [...I[40] || (I[40] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, pD)
            ], 8, uD),
            o.value.has(F.id) ? (re(), ae("div", mD, [
              f("div", vD, [
                I[41] || (I[41] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => C(F.id, "x", Number(k.target.value))
                }, null, 40, gD),
                f("span", yD, be(F.x.toFixed(2)), 1)
              ]),
              f("div", _D, [
                I[42] || (I[42] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => C(F.id, "y", Number(k.target.value))
                }, null, 40, xD),
                f("span", bD, be(F.y.toFixed(2)), 1)
              ]),
              f("div", wD, [
                I[43] || (I[43] = f("label", null, "Direction", -1)),
                f("input", {
                  type: "range",
                  value: F.direction,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (k) => C(F.id, "direction", Number(k.target.value))
                }, null, 40, SD),
                f("span", MD, be(F.direction) + "", 1)
              ]),
              f("div", CD, [
                I[44] || (I[44] = f("label", null, "Spread", -1)),
                f("input", {
                  type: "range",
                  value: F.spread,
                  min: "0",
                  max: "360",
                  step: "5",
                  onInput: (k) => C(F.id, "spread", Number(k.target.value))
                }, null, 40, ED),
                f("span", TD, be(F.spread) + "", 1)
              ]),
              f("div", AD, [
                I[45] || (I[45] = f("label", null, "Speed", -1)),
                f("input", {
                  type: "range",
                  value: F.speed,
                  min: "1",
                  max: "1000",
                  step: "10",
                  onInput: (k) => C(F.id, "speed", Number(k.target.value))
                }, null, 40, PD),
                f("span", DD, be(F.speed), 1)
              ]),
              f("div", RD, [
                I[46] || (I[46] = f("label", null, "Speed Variance", -1)),
                f("input", {
                  type: "range",
                  value: F.speedVariance,
                  min: "0",
                  max: "500",
                  step: "10",
                  onInput: (k) => C(F.id, "speedVariance", Number(k.target.value))
                }, null, 40, ID),
                f("span", kD, be(F.speedVariance), 1)
              ]),
              f("div", LD, [
                I[47] || (I[47] = f("label", null, "Size", -1)),
                f("input", {
                  type: "range",
                  value: F.size,
                  min: "1",
                  max: "400",
                  step: "1",
                  onInput: (k) => C(F.id, "size", Number(k.target.value))
                }, null, 40, FD),
                f("span", UD, be(F.size) + "px", 1)
              ]),
              f("div", OD, [
                I[48] || (I[48] = f("label", null, "Size Variance", -1)),
                f("input", {
                  type: "range",
                  value: F.sizeVariance,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (k) => C(F.id, "sizeVariance", Number(k.target.value))
                }, null, 40, zD),
                f("span", ND, be(F.sizeVariance), 1)
              ]),
              f("div", BD, [
                I[49] || (I[49] = f("label", null, "Color", -1)),
                f("input", {
                  type: "color",
                  value: H(F.color),
                  onInput: (k) => E(F.id, k.target.value)
                }, null, 40, VD)
              ]),
              f("div", GD, [
                I[50] || (I[50] = f("label", null, "Emission Rate", -1)),
                f("input", {
                  type: "range",
                  value: F.emissionRate,
                  min: "0.1",
                  max: "100",
                  step: "0.1",
                  onInput: (k) => C(F.id, "emissionRate", Number(k.target.value))
                }, null, 40, HD),
                f("span", WD, be(F.emissionRate.toFixed(1)) + "/s", 1)
              ]),
              f("div", $D, [
                I[51] || (I[51] = f("label", null, "Lifetime", -1)),
                f("input", {
                  type: "range",
                  value: F.particleLifetime,
                  min: "1",
                  max: "300",
                  step: "1",
                  onInput: (k) => C(F.id, "particleLifetime", Number(k.target.value))
                }, null, 40, XD),
                f("span", jD, be(F.particleLifetime) + "f", 1)
              ]),
              f("div", YD, [
                I[52] || (I[52] = f("label", null, "Initial Burst", -1)),
                f("input", {
                  type: "range",
                  value: F.initialBurst,
                  min: "0",
                  max: "1",
                  step: "0.1",
                  onInput: (k) => C(F.id, "initialBurst", Number(k.target.value))
                }, null, 40, qD),
                f("span", ZD, be((F.initialBurst * 100).toFixed(0)) + "%", 1)
              ]),
              f("div", KD, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: F.burstOnBeat,
                    onChange: (k) => C(F.id, "burstOnBeat", k.target.checked)
                  }, null, 40, JD),
                  I[53] || (I[53] = ft(" Burst on Beat ", -1))
                ])
              ]),
              F.burstOnBeat ? (re(), ae("div", QD, [
                I[54] || (I[54] = f("label", null, "Burst Count", -1)),
                f("input", {
                  type: "range",
                  value: F.burstCount,
                  min: "1",
                  max: "100",
                  step: "1",
                  onInput: (k) => C(F.id, "burstCount", Number(k.target.value))
                }, null, 40, eR),
                f("span", tR, be(F.burstCount), 1)
              ])) : Pe("", !0)
            ])) : Pe("", !0)
          ]))), 128)),
          u.value.length === 0 ? (re(), ae("div", nR, " No emitters. Click + to add one. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", iR, [
        f("div", {
          class: "section-header",
          onClick: I[10] || (I[10] = (F) => S("forces"))
        }, [
          f("i", {
            class: Ue(["pi", r.value.has("forces") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[55] || (I[55] = f("span", null, "Force Fields", -1))
        ]),
        r.value.has("forces") ? (re(), ae("div", sR, [
          f("div", rR, [
            f("button", {
              class: Ue({ active: a.value === "wells" }),
              onClick: I[11] || (I[11] = (F) => a.value = "wells")
            }, " Gravity Wells ", 2),
            f("button", {
              class: Ue({ active: a.value === "vortices" }),
              onClick: I[12] || (I[12] = (F) => a.value = "vortices")
            }, " Vortices ", 2)
          ]),
          a.value === "wells" ? (re(), ae("div", oR, [
            f("button", {
              class: "add-btn full-width",
              onClick: M
            }, [...I[56] || (I[56] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              ft(" Add Gravity Well ", -1)
            ])]),
            (re(!0), ae(Ze, null, at(d.value, (F) => (re(), ae("div", {
              key: F.id,
              class: "force-item"
            }, [
              f("div", aR, [
                f("input", {
                  type: "text",
                  value: F.name,
                  onInput: (k) => b(F.id, "name", k.target.value),
                  class: "force-name"
                }, null, 40, lR),
                f("label", cR, [
                  f("input", {
                    type: "checkbox",
                    checked: F.enabled,
                    onChange: (k) => b(F.id, "enabled", k.target.checked)
                  }, null, 40, uR)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (k) => L(F.id)
                }, [...I[57] || (I[57] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, dR)
              ]),
              f("div", hR, [
                I[58] || (I[58] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => b(F.id, "x", Number(k.target.value))
                }, null, 40, fR),
                f("span", pR, be(F.x.toFixed(2)), 1)
              ]),
              f("div", mR, [
                I[59] || (I[59] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => b(F.id, "y", Number(k.target.value))
                }, null, 40, vR),
                f("span", gR, be(F.y.toFixed(2)), 1)
              ]),
              f("div", yR, [
                I[60] || (I[60] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: F.strength,
                  min: "-1000",
                  max: "1000",
                  step: "10",
                  onInput: (k) => b(F.id, "strength", Number(k.target.value))
                }, null, 40, _R),
                f("span", xR, be(F.strength), 1)
              ]),
              f("div", bR, [
                I[61] || (I[61] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: F.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => b(F.id, "radius", Number(k.target.value))
                }, null, 40, wR),
                f("span", SR, be(F.radius.toFixed(2)), 1)
              ]),
              f("div", MR, [
                I[63] || (I[63] = f("label", null, "Falloff", -1)),
                f("select", {
                  value: F.falloff,
                  onChange: (k) => b(F.id, "falloff", k.target.value)
                }, [...I[62] || (I[62] = [
                  f("option", { value: "linear" }, "Linear", -1),
                  f("option", { value: "quadratic" }, "Quadratic", -1),
                  f("option", { value: "constant" }, "Constant", -1)
                ])], 40, CR)
              ])
            ]))), 128))
          ])) : Pe("", !0),
          a.value === "vortices" ? (re(), ae("div", ER, [
            f("button", {
              class: "add-btn full-width",
              onClick: D
            }, [...I[64] || (I[64] = [
              f("i", { class: "pi pi-plus" }, null, -1),
              ft(" Add Vortex ", -1)
            ])]),
            (re(!0), ae(Ze, null, at(h.value, (F) => (re(), ae("div", {
              key: F.id,
              class: "force-item"
            }, [
              f("div", TR, [
                f("input", {
                  type: "text",
                  value: F.name,
                  onInput: (k) => N(F.id, "name", k.target.value),
                  class: "force-name"
                }, null, 40, AR),
                f("label", PR, [
                  f("input", {
                    type: "checkbox",
                    checked: F.enabled,
                    onChange: (k) => N(F.id, "enabled", k.target.checked)
                  }, null, 40, DR)
                ]),
                f("button", {
                  class: "remove-btn",
                  onClick: (k) => O(F.id)
                }, [...I[65] || (I[65] = [
                  f("i", { class: "pi pi-trash" }, null, -1)
                ])], 8, RR)
              ]),
              f("div", IR, [
                I[66] || (I[66] = f("label", null, "Position X", -1)),
                f("input", {
                  type: "range",
                  value: F.x,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => N(F.id, "x", Number(k.target.value))
                }, null, 40, kR),
                f("span", LR, be(F.x.toFixed(2)), 1)
              ]),
              f("div", FR, [
                I[67] || (I[67] = f("label", null, "Position Y", -1)),
                f("input", {
                  type: "range",
                  value: F.y,
                  min: "0",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => N(F.id, "y", Number(k.target.value))
                }, null, 40, UR),
                f("span", OR, be(F.y.toFixed(2)), 1)
              ]),
              f("div", zR, [
                I[68] || (I[68] = f("label", null, "Strength", -1)),
                f("input", {
                  type: "range",
                  value: F.strength,
                  min: "0",
                  max: "1000",
                  step: "10",
                  onInput: (k) => N(F.id, "strength", Number(k.target.value))
                }, null, 40, NR),
                f("span", BR, be(F.strength), 1)
              ]),
              f("div", VR, [
                I[69] || (I[69] = f("label", null, "Radius", -1)),
                f("input", {
                  type: "range",
                  value: F.radius,
                  min: "0.01",
                  max: "1",
                  step: "0.01",
                  onInput: (k) => N(F.id, "radius", Number(k.target.value))
                }, null, 40, GR),
                f("span", HR, be(F.radius.toFixed(2)), 1)
              ]),
              f("div", WR, [
                I[70] || (I[70] = f("label", null, "Rotation Speed", -1)),
                f("input", {
                  type: "range",
                  value: F.rotationSpeed,
                  min: "0",
                  max: "50",
                  step: "1",
                  onInput: (k) => N(F.id, "rotationSpeed", Number(k.target.value))
                }, null, 40, $R),
                f("span", XR, be(F.rotationSpeed) + "/f", 1)
              ]),
              f("div", jR, [
                I[71] || (I[71] = f("label", null, "Inward Pull", -1)),
                f("input", {
                  type: "range",
                  value: F.inwardPull,
                  min: "0",
                  max: "100",
                  step: "1",
                  onInput: (k) => N(F.id, "inwardPull", Number(k.target.value))
                }, null, 40, YR),
                f("span", qR, be(F.inwardPull), 1)
              ])
            ]))), 128))
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", ZR, [
        f("div", {
          class: "section-header",
          onClick: I[13] || (I[13] = (F) => S("turbulence"))
        }, [
          f("i", {
            class: Ue(["pi", r.value.has("turbulence") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[73] || (I[73] = f("span", null, "Turbulence", -1)),
          f("button", {
            class: "add-btn",
            onClick: wt(Y, ["stop"]),
            title: "Add Turbulence Field"
          }, [...I[72] || (I[72] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("turbulence") ? (re(), ae("div", KR, [
          (re(!0), ae(Ze, null, at(y.value, (F) => (re(), ae("div", {
            key: F.id,
            class: "force-item"
          }, [
            f("div", JR, [
              I[75] || (I[75] = f("span", { class: "force-label" }, "Turbulence Field", -1)),
              f("label", QR, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (k) => oe(F.id, "enabled", k.target.checked)
                }, null, 40, eI)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (k) => j(F.id)
              }, [...I[74] || (I[74] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, tI)
            ]),
            f("div", nI, [
              I[76] || (I[76] = f("label", null, "Scale", -1)),
              f("input", {
                type: "range",
                value: F.scale,
                min: "0.001",
                max: "0.02",
                step: "0.001",
                onInput: (k) => oe(F.id, "scale", Number(k.target.value))
              }, null, 40, iI),
              f("span", sI, be(F.scale.toFixed(3)), 1)
            ]),
            f("div", rI, [
              I[77] || (I[77] = f("label", null, "Strength", -1)),
              f("input", {
                type: "range",
                value: F.strength,
                min: "0",
                max: "500",
                step: "10",
                onInput: (k) => oe(F.id, "strength", Number(k.target.value))
              }, null, 40, oI),
              f("span", aI, be(F.strength), 1)
            ]),
            f("div", lI, [
              I[78] || (I[78] = f("label", null, "Evolution", -1)),
              f("input", {
                type: "range",
                value: F.evolutionSpeed,
                min: "0",
                max: "1",
                step: "0.01",
                onInput: (k) => oe(F.id, "evolutionSpeed", Number(k.target.value))
              }, null, 40, cI),
              f("span", uI, be(F.evolutionSpeed.toFixed(2)), 1)
            ])
          ]))), 128)),
          y.value.length === 0 ? (re(), ae("div", dI, " No turbulence fields. Add one for organic particle motion. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", hI, [
        f("div", {
          class: "section-header",
          onClick: I[14] || (I[14] = (F) => S("subEmitters"))
        }, [
          f("i", {
            class: Ue(["pi", r.value.has("subEmitters") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[80] || (I[80] = f("span", null, "Sub-Emitters", -1)),
          f("button", {
            class: "add-btn",
            onClick: wt(ne, ["stop"]),
            title: "Add Sub-Emitter"
          }, [...I[79] || (I[79] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("subEmitters") ? (re(), ae("div", fI, [
          (re(!0), ae(Ze, null, at(_.value, (F) => (re(), ae("div", {
            key: F.id,
            class: "force-item"
          }, [
            f("div", pI, [
              f("select", {
                value: F.parentEmitterId,
                onChange: (k) => q(F.id, "parentEmitterId", k.target.value),
                class: "sub-emitter-parent"
              }, [
                I[81] || (I[81] = f("option", { value: "*" }, "All Emitters", -1)),
                (re(!0), ae(Ze, null, at(u.value, (k) => (re(), ae("option", {
                  key: k.id,
                  value: k.id
                }, be(k.name), 9, vI))), 128))
              ], 40, mI),
              f("label", gI, [
                f("input", {
                  type: "checkbox",
                  checked: F.enabled,
                  onChange: (k) => q(F.id, "enabled", k.target.checked)
                }, null, 40, yI)
              ]),
              f("button", {
                class: "remove-btn",
                onClick: (k) => de(F.id)
              }, [...I[82] || (I[82] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, _I)
            ]),
            f("div", xI, [
              I[84] || (I[84] = f("label", null, "Trigger", -1)),
              f("select", {
                value: F.trigger,
                onChange: (k) => q(F.id, "trigger", k.target.value)
              }, [...I[83] || (I[83] = [
                f("option", { value: "death" }, "On Death", -1)
              ])], 40, bI)
            ]),
            f("div", wI, [
              I[85] || (I[85] = f("label", null, "Spawn Count", -1)),
              f("input", {
                type: "range",
                value: F.spawnCount,
                min: "1",
                max: "10",
                step: "1",
                onInput: (k) => q(F.id, "spawnCount", Number(k.target.value))
              }, null, 40, SI),
              f("span", MI, be(F.spawnCount), 1)
            ]),
            f("div", CI, [
              I[86] || (I[86] = f("label", null, "Inherit Velocity", -1)),
              f("input", {
                type: "range",
                value: F.inheritVelocity,
                min: "0",
                max: "1",
                step: "0.1",
                onInput: (k) => q(F.id, "inheritVelocity", Number(k.target.value))
              }, null, 40, EI),
              f("span", TI, be((F.inheritVelocity * 100).toFixed(0)) + "%", 1)
            ]),
            f("div", AI, [
              I[87] || (I[87] = f("label", null, "Size", -1)),
              f("input", {
                type: "range",
                value: F.size,
                min: "1",
                max: "100",
                step: "1",
                onInput: (k) => q(F.id, "size", Number(k.target.value))
              }, null, 40, PI),
              f("span", DI, be(F.size) + "px", 1)
            ]),
            f("div", RI, [
              I[88] || (I[88] = f("label", null, "Lifetime", -1)),
              f("input", {
                type: "range",
                value: F.lifetime,
                min: "1",
                max: "120",
                step: "1",
                onInput: (k) => q(F.id, "lifetime", Number(k.target.value))
              }, null, 40, II),
              f("span", kI, be(F.lifetime) + "f", 1)
            ]),
            f("div", LI, [
              I[89] || (I[89] = f("label", null, "Speed", -1)),
              f("input", {
                type: "range",
                value: F.speed,
                min: "1",
                max: "500",
                step: "10",
                onInput: (k) => q(F.id, "speed", Number(k.target.value))
              }, null, 40, FI),
              f("span", UI, be(F.speed), 1)
            ]),
            f("div", OI, [
              I[90] || (I[90] = f("label", null, "Spread", -1)),
              f("input", {
                type: "range",
                value: F.spread,
                min: "0",
                max: "360",
                step: "5",
                onInput: (k) => q(F.id, "spread", Number(k.target.value))
              }, null, 40, zI),
              f("span", NI, be(F.spread) + "", 1)
            ]),
            f("div", BI, [
              I[91] || (I[91] = f("label", null, "Color", -1)),
              f("input", {
                type: "color",
                value: H(F.color),
                onInput: (k) => te(F.id, k.target.value)
              }, null, 40, VI)
            ])
          ]))), 128)),
          _.value.length === 0 ? (re(), ae("div", GI, " No sub-emitters. Add one for particle death effects. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", HI, [
        f("div", {
          class: "section-header",
          onClick: I[15] || (I[15] = (F) => S("modulations"))
        }, [
          f("i", {
            class: Ue(["pi", r.value.has("modulations") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[93] || (I[93] = f("span", null, "Modulations", -1)),
          f("button", {
            class: "add-btn",
            onClick: wt(G, ["stop"]),
            title: "Add Modulation"
          }, [...I[92] || (I[92] = [
            f("i", { class: "pi pi-plus" }, null, -1)
          ])])
        ]),
        r.value.has("modulations") ? (re(), ae("div", WI, [
          (re(!0), ae(Ze, null, at(m.value, (F) => (re(), ae("div", {
            key: F.id,
            class: "modulation-item"
          }, [
            f("div", $I, [
              f("select", {
                value: F.emitterId,
                onChange: (k) => A(F.id, "emitterId", k.target.value)
              }, [
                I[94] || (I[94] = f("option", { value: "*" }, "All Emitters", -1)),
                (re(!0), ae(Ze, null, at(u.value, (k) => (re(), ae("option", {
                  key: k.id,
                  value: k.id
                }, be(k.name), 9, jI))), 128))
              ], 40, XI),
              f("button", {
                class: "remove-btn",
                onClick: (k) => he(F.id)
              }, [...I[95] || (I[95] = [
                f("i", { class: "pi pi-trash" }, null, -1)
              ])], 8, YI)
            ]),
            f("div", qI, [
              I[97] || (I[97] = f("label", null, "Property", -1)),
              f("select", {
                value: F.property,
                onChange: (k) => A(F.id, "property", k.target.value)
              }, [...I[96] || (I[96] = [
                Or('<option value="size" data-v-60b9bdc8>Size</option><option value="speed" data-v-60b9bdc8>Speed</option><option value="opacity" data-v-60b9bdc8>Opacity</option><option value="colorR" data-v-60b9bdc8>Color R</option><option value="colorG" data-v-60b9bdc8>Color G</option><option value="colorB" data-v-60b9bdc8>Color B</option>', 6)
              ])], 40, ZI)
            ]),
            f("div", KI, [
              I[98] || (I[98] = f("label", null, "Start Value", -1)),
              f("input", {
                type: "number",
                value: F.startValue,
                step: "0.1",
                onInput: (k) => A(F.id, "startValue", Number(k.target.value))
              }, null, 40, JI)
            ]),
            f("div", QI, [
              I[99] || (I[99] = f("label", null, "End Value", -1)),
              f("input", {
                type: "number",
                value: F.endValue,
                step: "0.1",
                onInput: (k) => A(F.id, "endValue", Number(k.target.value))
              }, null, 40, ek)
            ]),
            f("div", tk, [
              I[101] || (I[101] = f("label", null, "Easing", -1)),
              f("select", {
                value: F.easing,
                onChange: (k) => A(F.id, "easing", k.target.value)
              }, [...I[100] || (I[100] = [
                Or('<option value="linear" data-v-60b9bdc8>Linear</option><option value="easeIn" data-v-60b9bdc8>Ease In</option><option value="easeOut" data-v-60b9bdc8>Ease Out</option><option value="easeInOut" data-v-60b9bdc8>Ease In Out</option><option value="bounce" data-v-60b9bdc8>Bounce</option><option value="elastic" data-v-60b9bdc8>Elastic</option>', 6)
              ])], 40, nk)
            ])
          ]))), 128)),
          m.value.length === 0 ? (re(), ae("div", ik, " No modulations. Add one to animate particle properties over lifetime. ")) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", sk, [
        f("div", {
          class: "section-header",
          onClick: I[16] || (I[16] = (F) => S("render"))
        }, [
          f("i", {
            class: Ue(["pi", r.value.has("render") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          I[102] || (I[102] = f("span", null, "Render Options", -1))
        ]),
        r.value.has("render") ? (re(), ae("div", rk, [
          f("div", ok, [
            I[104] || (I[104] = f("label", null, "Blend Mode", -1)),
            f("select", {
              value: p.value.blendMode,
              onChange: I[17] || (I[17] = (F) => ee("blendMode", F.target.value))
            }, [...I[103] || (I[103] = [
              f("option", { value: "normal" }, "Normal", -1),
              f("option", { value: "additive" }, "Additive", -1),
              f("option", { value: "multiply" }, "Multiply", -1),
              f("option", { value: "screen" }, "Screen", -1)
            ])], 40, ak)
          ]),
          f("div", lk, [
            I[106] || (I[106] = f("label", null, "Shape", -1)),
            f("select", {
              value: p.value.particleShape,
              onChange: I[18] || (I[18] = (F) => ee("particleShape", F.target.value))
            }, [...I[105] || (I[105] = [
              f("option", { value: "circle" }, "Circle", -1),
              f("option", { value: "square" }, "Square", -1),
              f("option", { value: "triangle" }, "Triangle", -1),
              f("option", { value: "star" }, "Star", -1)
            ])], 40, ck)
          ]),
          f("div", uk, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.renderTrails,
                onChange: I[19] || (I[19] = (F) => ee("renderTrails", F.target.checked))
              }, null, 40, dk),
              I[107] || (I[107] = ft(" Render Trails ", -1))
            ])
          ]),
          p.value.renderTrails ? (re(), ae("div", hk, [
            I[108] || (I[108] = f("label", null, "Trail Length", -1)),
            f("input", {
              type: "range",
              value: p.value.trailLength,
              min: "1",
              max: "20",
              step: "1",
              onInput: I[20] || (I[20] = (F) => ee("trailLength", Number(F.target.value)))
            }, null, 40, fk),
            f("span", pk, be(p.value.trailLength), 1)
          ])) : Pe("", !0),
          f("div", mk, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.glowEnabled,
                onChange: I[21] || (I[21] = (F) => ee("glowEnabled", F.target.checked))
              }, null, 40, vk),
              I[109] || (I[109] = ft(" Enable Glow ", -1))
            ])
          ]),
          p.value.glowEnabled ? (re(), ae("div", gk, [
            I[110] || (I[110] = f("label", null, "Glow Radius", -1)),
            f("input", {
              type: "range",
              value: p.value.glowRadius,
              min: "1",
              max: "50",
              step: "1",
              onInput: I[22] || (I[22] = (F) => ee("glowRadius", Number(F.target.value)))
            }, null, 40, yk),
            f("span", _k, be(p.value.glowRadius) + "px", 1)
          ])) : Pe("", !0),
          p.value.glowEnabled ? (re(), ae("div", xk, [
            I[111] || (I[111] = f("label", null, "Glow Intensity", -1)),
            f("input", {
              type: "range",
              value: p.value.glowIntensity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: I[23] || (I[23] = (F) => ee("glowIntensity", Number(F.target.value)))
            }, null, 40, bk),
            f("span", wk, be(p.value.glowIntensity.toFixed(2)), 1)
          ])) : Pe("", !0),
          I[118] || (I[118] = f("div", { class: "subsection-divider" }, "Particle Connections", -1)),
          f("div", Sk, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: v.value.enabled,
                onChange: I[24] || (I[24] = (F) => le("enabled", F.target.checked))
              }, null, 40, Mk),
              I[112] || (I[112] = ft(" Enable Connections ", -1))
            ])
          ]),
          v.value.enabled ? (re(), ae("div", Ck, [
            I[113] || (I[113] = f("label", null, "Max Distance", -1)),
            f("input", {
              type: "range",
              value: v.value.maxDistance,
              min: "10",
              max: "300",
              step: "10",
              onInput: I[25] || (I[25] = (F) => le("maxDistance", Number(F.target.value)))
            }, null, 40, Ek),
            f("span", Tk, be(v.value.maxDistance) + "px", 1)
          ])) : Pe("", !0),
          v.value.enabled ? (re(), ae("div", Ak, [
            I[114] || (I[114] = f("label", null, "Max Connections", -1)),
            f("input", {
              type: "range",
              value: v.value.maxConnections,
              min: "1",
              max: "5",
              step: "1",
              onInput: I[26] || (I[26] = (F) => le("maxConnections", Number(F.target.value)))
            }, null, 40, Pk),
            f("span", Dk, be(v.value.maxConnections), 1)
          ])) : Pe("", !0),
          v.value.enabled ? (re(), ae("div", Rk, [
            I[115] || (I[115] = f("label", null, "Line Width", -1)),
            f("input", {
              type: "range",
              value: v.value.lineWidth,
              min: "0.5",
              max: "3",
              step: "0.1",
              onInput: I[27] || (I[27] = (F) => le("lineWidth", Number(F.target.value)))
            }, null, 40, Ik),
            f("span", kk, be(v.value.lineWidth.toFixed(1)), 1)
          ])) : Pe("", !0),
          v.value.enabled ? (re(), ae("div", Lk, [
            I[116] || (I[116] = f("label", null, "Line Opacity", -1)),
            f("input", {
              type: "range",
              value: v.value.lineOpacity,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: I[28] || (I[28] = (F) => le("lineOpacity", Number(F.target.value)))
            }, null, 40, Fk),
            f("span", Uk, be(v.value.lineOpacity.toFixed(2)), 1)
          ])) : Pe("", !0),
          v.value.enabled ? (re(), ae("div", Ok, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: v.value.fadeByDistance,
                onChange: I[29] || (I[29] = (F) => le("fadeByDistance", F.target.checked))
              }, null, 40, zk),
              I[117] || (I[117] = ft(" Fade by Distance ", -1))
            ])
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", Nk, [
        I[119] || (I[119] = f("i", { class: "pi pi-circle-fill" }, null, -1)),
        f("span", null, be(g.value) + " particles", 1)
      ])
    ]));
  }
}), Vk = /* @__PURE__ */ Bt(Bk, [["__scopeId", "data-v-60b9bdc8"]]), Gk = ["title"], Hk = /* @__PURE__ */ Ut({
  __name: "KeyframeToggle",
  props: {
    property: {},
    layerId: {}
  },
  emits: ["keyframeAdded", "keyframeRemoved", "animationToggled"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Oe(() => n.property.animated ? n.property.keyframes.some((m) => m.frame === r.currentFrame) : !1), a = Oe(() => n.property.animated && n.property.keyframes.find((m) => m.frame === r.currentFrame) || null), l = Oe(() => o.value ? "pi-circle-fill" : n.property.animated ? "pi-circle" : "pi-stopwatch"), c = Oe(() => o.value ? "Remove keyframe at current frame" : n.property.animated ? "Add keyframe at current frame" : "Enable animation (add keyframe)");
    function u() {
      o.value ? h() : d();
    }
    function d() {
      const m = { frame: 0, value: 0, enabled: !1 }, p = {
        id: `kf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        frame: r.currentFrame,
        value: n.property.value,
        interpolation: "linear",
        inHandle: { ...m },
        outHandle: { ...m },
        controlMode: "smooth"
      };
      n.property.animated || (n.property.animated = !0, i("animationToggled", !0)), n.property.keyframes.push(p), n.property.keyframes.sort((y, _) => y.frame - _.frame), i("keyframeAdded", p);
    }
    function h() {
      const m = a.value;
      if (!m) return;
      const p = n.property.keyframes.findIndex((y) => y.id === m.id);
      p >= 0 && (n.property.keyframes.splice(p, 1), i("keyframeRemoved", m.id)), n.property.keyframes.length === 0 && (n.property.animated = !1, i("animationToggled", !1));
    }
    return (m, p) => (re(), ae("button", {
      class: Ue(["keyframe-toggle", {
        animated: s.property.animated,
        "has-keyframe": o.value
      }]),
      onClick: u,
      title: c.value
    }, [
      f("i", {
        class: Ue(["pi", l.value])
      }, null, 2)
    ], 10, Gk));
  }
}), Pr = /* @__PURE__ */ Bt(Hk, [["__scopeId", "data-v-b9271c8f"]]), Wk = { class: "depthflow-properties" }, $k = { class: "property-section" }, Xk = {
  key: 0,
  class: "section-content"
}, jk = { class: "property-row" }, Yk = ["value"], qk = ["value"], Zk = { class: "property-row" }, Kk = ["value"], Jk = ["value"], Qk = { class: "property-section" }, eL = {
  key: 0,
  class: "section-content"
}, tL = { class: "preset-grid" }, nL = ["onClick"], iL = {
  key: 0,
  class: "property-row"
}, sL = ["value"], rL = { class: "value-display" }, oL = { class: "property-section" }, aL = {
  key: 0,
  class: "section-content"
}, lL = { class: "property-row" }, cL = ["value"], uL = { class: "value-display" }, dL = { class: "property-row" }, hL = ["value"], fL = { class: "value-display" }, pL = { class: "property-row" }, mL = ["value"], vL = { class: "value-display" }, gL = { class: "property-row" }, yL = ["value"], _L = { class: "value-display" }, xL = { class: "property-section" }, bL = {
  key: 0,
  class: "section-content"
}, wL = { class: "property-row" }, SL = ["value"], ML = { class: "value-display" }, CL = { class: "property-row" }, EL = ["value"], TL = { class: "value-display" }, AL = {
  key: 0,
  class: "property-section"
}, PL = {
  key: 0,
  class: "section-content"
}, DL = { class: "property-row" }, RL = ["value"], IL = { class: "value-display" }, kL = { class: "property-row" }, LL = ["value"], FL = { class: "value-display" }, UL = { class: "property-row" }, OL = ["value"], zL = { class: "value-display" }, NL = { class: "property-row" }, BL = ["value"], VL = { class: "value-display" }, GL = {
  key: 2,
  class: "property-row"
}, HL = ["value"], WL = { class: "value-display" }, $L = { class: "property-section" }, XL = {
  key: 0,
  class: "section-content"
}, jL = { class: "property-row" }, YL = ["value"], qL = { class: "value-display" }, ZL = { class: "property-row checkbox-row" }, KL = ["checked"], JL = { class: "property-section" }, QL = {
  key: 0,
  class: "section-content"
}, e4 = { class: "preview-container" }, t4 = { class: "preview-controls" }, n4 = { class: "frame-indicator" }, Yi = 200, i4 = /* @__PURE__ */ Ut({
  __name: "DepthflowProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Se(null), a = Se(!1), l = Se(0), c = Se(null), u = Se(/* @__PURE__ */ new Set(["source", "preset", "camera"])), d = Se(1), h = [
      { value: "static", label: "Static", icon: "pi pi-stop" },
      { value: "zoom_in", label: "Zoom In", icon: "pi pi-search-plus" },
      { value: "zoom_out", label: "Zoom Out", icon: "pi pi-search-minus" },
      { value: "dolly_zoom_in", label: "Dolly In", icon: "pi pi-video" },
      { value: "dolly_zoom_out", label: "Dolly Out", icon: "pi pi-video" },
      { value: "pan_left", label: "Pan Left", icon: "pi pi-arrow-left" },
      { value: "pan_right", label: "Pan Right", icon: "pi pi-arrow-right" },
      { value: "pan_up", label: "Pan Up", icon: "pi pi-arrow-up" },
      { value: "pan_down", label: "Pan Down", icon: "pi pi-arrow-down" },
      { value: "circle_cw", label: "Circle CW", icon: "pi pi-replay" },
      { value: "circle_ccw", label: "Circle CCW", icon: "pi pi-refresh" },
      { value: "horizontal_swing", label: "H Swing", icon: "pi pi-arrows-h" },
      { value: "vertical_swing", label: "V Swing", icon: "pi pi-arrows-v" },
      { value: "custom", label: "Custom", icon: "pi pi-sliders-h" }
    ], m = Oe(() => n.layer.data || {
      sourceLayerId: "",
      depthLayerId: "",
      config: {
        preset: "static",
        zoom: 1,
        offsetX: 0,
        offsetY: 0,
        rotation: 0,
        depthScale: 1,
        focusDepth: 0.5,
        dollyZoom: 0,
        orbitRadius: 0.1,
        orbitSpeed: 360,
        swingAmplitude: 0.1,
        swingFrequency: 1,
        edgeDilation: 5,
        inpaintEdges: !0
      }
    }), p = Oe(() => m.value.config), y = Oe(() => r.frameCount), _ = Oe(
      () => r.layers.filter((O) => O.type === "image" || O.type === "generated")
    ), v = Oe(
      () => r.layers.filter((O) => O.type === "depth" || O.type === "generated")
    ), g = Oe(
      () => ["circle_cw", "circle_ccw"].includes(p.value.preset)
    ), S = Oe(
      () => ["horizontal_swing", "vertical_swing"].includes(p.value.preset)
    ), w = Oe(
      () => ["dolly_zoom_in", "dolly_zoom_out"].includes(p.value.preset)
    ), x = Oe(
      () => g.value || S.value || w.value
    ), C = Oe(() => g.value ? "Orbit Settings" : S.value ? "Swing Settings" : w.value ? "Dolly Zoom Settings" : "Preset Settings");
    function E(O) {
      u.value.has(O) ? u.value.delete(O) : u.value.add(O);
    }
    function P(O, A) {
      i("update", { [O]: A });
    }
    function T(O, A) {
      i("update", {
        config: { ...p.value, [O]: A }
      });
    }
    function b(O) {
      T("preset", O);
    }
    function M(O) {
      d.value = O, g.value ? T("orbitRadius", 0.1 * O) : S.value ? T("swingAmplitude", 0.1 * O) : T("depthScale", 1 * O);
    }
    function L() {
      a.value = !a.value, a.value ? N() : c.value !== null && (cancelAnimationFrame(c.value), c.value = null);
    }
    function N() {
      a.value && (l.value = (l.value + 1) % y.value, D(), c.value = requestAnimationFrame(() => {
        setTimeout(N, 1e3 / r.fps);
      }));
    }
    function D() {
      const O = o.value;
      if (!O) return;
      const A = O.getContext("2d");
      A && (A.fillStyle = "#1e1e1e", A.fillRect(0, 0, Yi, Yi), A.fillStyle = "#333", A.fillRect(10, 10, Yi - 20, Yi - 20), A.fillStyle = "#666", A.font = "12px sans-serif", A.textAlign = "center", A.fillText("Depthflow Preview", Yi / 2, Yi / 2), A.fillText(`Frame ${l.value}`, Yi / 2, Yi / 2 + 16));
    }
    return _n(() => {
      D();
    }), jn(() => {
      c.value !== null && cancelAnimationFrame(c.value);
    }), (O, A) => (re(), ae("div", Wk, [
      f("div", $k, [
        f("div", {
          class: "section-header",
          onClick: A[0] || (A[0] = (G) => E("source"))
        }, [
          f("i", {
            class: Ue(["pi", u.value.has("source") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[23] || (A[23] = f("span", null, "Source Selection", -1))
        ]),
        u.value.has("source") ? (re(), ae("div", Xk, [
          f("div", jk, [
            A[25] || (A[25] = f("label", null, "Source Layer", -1)),
            f("select", {
              value: m.value.sourceLayerId,
              onChange: A[1] || (A[1] = (G) => P("sourceLayerId", G.target.value))
            }, [
              A[24] || (A[24] = f("option", { value: "" }, "Select source...", -1)),
              (re(!0), ae(Ze, null, at(_.value, (G) => (re(), ae("option", {
                key: G.id,
                value: G.id
              }, be(G.name), 9, qk))), 128))
            ], 40, Yk)
          ]),
          f("div", Zk, [
            A[27] || (A[27] = f("label", null, "Depth Layer", -1)),
            f("select", {
              value: m.value.depthLayerId,
              onChange: A[2] || (A[2] = (G) => P("depthLayerId", G.target.value))
            }, [
              A[26] || (A[26] = f("option", { value: "" }, "Select depth map...", -1)),
              (re(!0), ae(Ze, null, at(v.value, (G) => (re(), ae("option", {
                key: G.id,
                value: G.id
              }, be(G.name), 9, Jk))), 128))
            ], 40, Kk)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", Qk, [
        f("div", {
          class: "section-header",
          onClick: A[3] || (A[3] = (G) => E("preset"))
        }, [
          f("i", {
            class: Ue(["pi", u.value.has("preset") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[28] || (A[28] = f("span", null, "Motion Preset", -1))
        ]),
        u.value.has("preset") ? (re(), ae("div", eL, [
          f("div", tL, [
            (re(), ae(Ze, null, at(h, (G) => f("button", {
              key: G.value,
              class: Ue(["preset-btn", { active: p.value.preset === G.value }]),
              onClick: (he) => b(G.value)
            }, [
              f("i", {
                class: Ue(G.icon)
              }, null, 2),
              f("span", null, be(G.label), 1)
            ], 10, nL)), 64))
          ]),
          p.value.preset !== "static" ? (re(), ae("div", iL, [
            A[29] || (A[29] = f("label", null, "Intensity", -1)),
            f("input", {
              type: "range",
              value: d.value,
              min: "0.1",
              max: "2",
              step: "0.1",
              onInput: A[4] || (A[4] = (G) => M(Number(G.target.value)))
            }, null, 40, sL),
            f("span", rL, be(d.value.toFixed(1)) + "x", 1)
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ]),
      f("div", oL, [
        f("div", {
          class: "section-header",
          onClick: A[5] || (A[5] = (G) => E("camera"))
        }, [
          f("i", {
            class: Ue(["pi", u.value.has("camera") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[30] || (A[30] = f("span", null, "Camera Controls", -1))
        ]),
        u.value.has("camera") ? (re(), ae("div", aL, [
          f("div", lL, [
            A[31] || (A[31] = f("label", null, "Zoom", -1)),
            m.value.animatedZoom ? (re(), St(Pr, {
              key: 0,
              property: m.value.animatedZoom,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.zoom,
              min: "0.5",
              max: "2",
              step: "0.01",
              onInput: A[6] || (A[6] = (G) => T("zoom", Number(G.target.value)))
            }, null, 40, cL),
            f("span", uL, be(p.value.zoom.toFixed(2)), 1)
          ]),
          f("div", dL, [
            A[32] || (A[32] = f("label", null, "Offset X", -1)),
            m.value.animatedOffsetX ? (re(), St(Pr, {
              key: 0,
              property: m.value.animatedOffsetX,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.offsetX,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: A[7] || (A[7] = (G) => T("offsetX", Number(G.target.value)))
            }, null, 40, hL),
            f("span", fL, be(p.value.offsetX.toFixed(2)), 1)
          ]),
          f("div", pL, [
            A[33] || (A[33] = f("label", null, "Offset Y", -1)),
            m.value.animatedOffsetY ? (re(), St(Pr, {
              key: 0,
              property: m.value.animatedOffsetY,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.offsetY,
              min: "-1",
              max: "1",
              step: "0.01",
              onInput: A[8] || (A[8] = (G) => T("offsetY", Number(G.target.value)))
            }, null, 40, mL),
            f("span", vL, be(p.value.offsetY.toFixed(2)), 1)
          ]),
          f("div", gL, [
            A[34] || (A[34] = f("label", null, "Rotation", -1)),
            m.value.animatedRotation ? (re(), St(Pr, {
              key: 0,
              property: m.value.animatedRotation,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.rotation,
              min: "-180",
              max: "180",
              step: "1",
              onInput: A[9] || (A[9] = (G) => T("rotation", Number(G.target.value)))
            }, null, 40, yL),
            f("span", _L, be(p.value.rotation) + "", 1)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", xL, [
        f("div", {
          class: "section-header",
          onClick: A[10] || (A[10] = (G) => E("depth"))
        }, [
          f("i", {
            class: Ue(["pi", u.value.has("depth") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[35] || (A[35] = f("span", null, "Depth Settings", -1))
        ]),
        u.value.has("depth") ? (re(), ae("div", bL, [
          f("div", wL, [
            A[36] || (A[36] = f("label", null, "Depth Scale", -1)),
            m.value.animatedDepthScale ? (re(), St(Pr, {
              key: 0,
              property: m.value.animatedDepthScale,
              "layer-id": s.layer.id
            }, null, 8, ["property", "layer-id"])) : Pe("", !0),
            f("input", {
              type: "range",
              value: p.value.depthScale,
              min: "0",
              max: "2",
              step: "0.05",
              onInput: A[11] || (A[11] = (G) => T("depthScale", Number(G.target.value)))
            }, null, 40, SL),
            f("span", ML, be(p.value.depthScale.toFixed(2)), 1)
          ]),
          f("div", CL, [
            A[37] || (A[37] = f("label", null, "Focus Depth", -1)),
            f("input", {
              type: "range",
              value: p.value.focusDepth,
              min: "0",
              max: "1",
              step: "0.01",
              onInput: A[12] || (A[12] = (G) => T("focusDepth", Number(G.target.value)))
            }, null, 40, EL),
            f("span", TL, be(p.value.focusDepth.toFixed(2)), 1)
          ]),
          A[38] || (A[38] = f("div", { class: "depth-hint" }, [
            ft(" Objects at focus depth stay stationary."),
            f("br"),
            ft(" Closer objects move more, distant objects move less. ")
          ], -1))
        ])) : Pe("", !0)
      ]),
      x.value ? (re(), ae("div", AL, [
        f("div", {
          class: "section-header",
          onClick: A[13] || (A[13] = (G) => E("presetSettings"))
        }, [
          f("i", {
            class: Ue(["pi", u.value.has("presetSettings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          f("span", null, be(C.value), 1)
        ]),
        u.value.has("presetSettings") ? (re(), ae("div", PL, [
          g.value ? (re(), ae(Ze, { key: 0 }, [
            f("div", DL, [
              A[39] || (A[39] = f("label", null, "Orbit Radius", -1)),
              f("input", {
                type: "range",
                value: p.value.orbitRadius,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: A[14] || (A[14] = (G) => T("orbitRadius", Number(G.target.value)))
              }, null, 40, RL),
              f("span", IL, be(p.value.orbitRadius.toFixed(2)), 1)
            ]),
            f("div", kL, [
              A[40] || (A[40] = f("label", null, "Orbit Speed", -1)),
              f("input", {
                type: "range",
                value: p.value.orbitSpeed,
                min: "1",
                max: "720",
                step: "1",
                onInput: A[15] || (A[15] = (G) => T("orbitSpeed", Number(G.target.value)))
              }, null, 40, LL),
              f("span", FL, be(p.value.orbitSpeed) + "", 1)
            ])
          ], 64)) : Pe("", !0),
          S.value ? (re(), ae(Ze, { key: 1 }, [
            f("div", UL, [
              A[41] || (A[41] = f("label", null, "Amplitude", -1)),
              f("input", {
                type: "range",
                value: p.value.swingAmplitude,
                min: "0.01",
                max: "0.5",
                step: "0.01",
                onInput: A[16] || (A[16] = (G) => T("swingAmplitude", Number(G.target.value)))
              }, null, 40, OL),
              f("span", zL, be(p.value.swingAmplitude.toFixed(2)), 1)
            ]),
            f("div", NL, [
              A[42] || (A[42] = f("label", null, "Frequency", -1)),
              f("input", {
                type: "range",
                value: p.value.swingFrequency,
                min: "0.1",
                max: "5",
                step: "0.1",
                onInput: A[17] || (A[17] = (G) => T("swingFrequency", Number(G.target.value)))
              }, null, 40, BL),
              f("span", VL, be(p.value.swingFrequency.toFixed(1)) + " Hz", 1)
            ])
          ], 64)) : Pe("", !0),
          w.value ? (re(), ae("div", GL, [
            A[43] || (A[43] = f("label", null, "Dolly Rate", -1)),
            f("input", {
              type: "range",
              value: p.value.dollyZoom,
              min: "0",
              max: "1",
              step: "0.05",
              onInput: A[18] || (A[18] = (G) => T("dollyZoom", Number(G.target.value)))
            }, null, 40, HL),
            f("span", WL, be(p.value.dollyZoom.toFixed(2)), 1)
          ])) : Pe("", !0)
        ])) : Pe("", !0)
      ])) : Pe("", !0),
      f("div", $L, [
        f("div", {
          class: "section-header",
          onClick: A[19] || (A[19] = (G) => E("quality"))
        }, [
          f("i", {
            class: Ue(["pi", u.value.has("quality") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[44] || (A[44] = f("span", null, "Quality", -1))
        ]),
        u.value.has("quality") ? (re(), ae("div", XL, [
          f("div", jL, [
            A[45] || (A[45] = f("label", null, "Edge Dilation", -1)),
            f("input", {
              type: "range",
              value: p.value.edgeDilation,
              min: "0",
              max: "50",
              step: "1",
              onInput: A[20] || (A[20] = (G) => T("edgeDilation", Number(G.target.value)))
            }, null, 40, YL),
            f("span", qL, be(p.value.edgeDilation) + "px", 1)
          ]),
          f("div", ZL, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: p.value.inpaintEdges,
                onChange: A[21] || (A[21] = (G) => T("inpaintEdges", G.target.checked))
              }, null, 40, KL),
              A[46] || (A[46] = ft(" Inpaint Edges ", -1))
            ])
          ])
        ])) : Pe("", !0)
      ]),
      f("div", JL, [
        f("div", {
          class: "section-header",
          onClick: A[22] || (A[22] = (G) => E("preview"))
        }, [
          f("i", {
            class: Ue(["pi", u.value.has("preview") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          A[47] || (A[47] = f("span", null, "Preview", -1))
        ]),
        u.value.has("preview") ? (re(), ae("div", QL, [
          f("div", e4, [
            f("canvas", {
              ref_key: "previewCanvas",
              ref: o,
              class: "preview-canvas",
              width: Yi,
              height: Yi
            }, null, 512)
          ]),
          f("div", t4, [
            f("button", {
              class: Ue(["preview-btn", { active: a.value }]),
              onClick: L
            }, [
              f("i", {
                class: Ue(a.value ? "pi pi-pause" : "pi pi-play")
              }, null, 2),
              ft(" " + be(a.value ? "Pause" : "Play"), 1)
            ], 2),
            f("span", n4, " Frame " + be(l.value) + " / " + be(y.value - 1), 1)
          ])
        ])) : Pe("", !0)
      ])
    ]));
  }
}), s4 = /* @__PURE__ */ Bt(i4, [["__scopeId", "data-v-ffaf4c8a"]]), r4 = { class: "light-properties" }, o4 = { class: "property-section" }, a4 = { class: "section-content" }, l4 = { class: "property-row" }, c4 = ["value"], u4 = { class: "property-group" }, d4 = { class: "property-group" }, h4 = { class: "control-row" }, f4 = { class: "property-group" }, p4 = { class: "control-row" }, m4 = { class: "property-group" }, v4 = {
  key: 1,
  class: "property-row"
}, g4 = ["value"], y4 = {
  key: 2,
  class: "property-group"
}, _4 = {
  key: 3,
  class: "property-group"
}, x4 = { class: "property-group checkbox-row" }, b4 = ["checked"], w4 = { class: "property-group" }, S4 = { class: "property-group" }, M4 = {
  key: 5,
  class: "note"
}, C4 = /* @__PURE__ */ Ut({
  __name: "LightProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Oe(() => n.layer.data || {
      lightType: "spot",
      color: "#ffffff",
      intensity: 100,
      radius: 500,
      falloff: "none",
      falloffDistance: 500,
      castShadows: !1,
      shadowDarkness: 100,
      shadowDiffusion: 0,
      coneAngle: 90,
      coneFeather: 50
    });
    function a(l, c) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [l]: c }
      }), i("update");
    }
    return (l, c) => (re(), ae("div", r4, [
      f("div", o4, [
        c[25] || (c[25] = f("div", { class: "section-header" }, "Light Settings", -1)),
        f("div", a4, [
          f("div", l4, [
            c[13] || (c[13] = f("label", null, "Type", -1)),
            f("select", {
              value: o.value.lightType,
              onChange: c[0] || (c[0] = (u) => a("lightType", u.target.value)),
              class: "type-select"
            }, [...c[12] || (c[12] = [
              f("option", { value: "parallel" }, "Parallel", -1),
              f("option", { value: "spot" }, "Spot", -1),
              f("option", { value: "point" }, "Point", -1),
              f("option", { value: "ambient" }, "Ambient", -1)
            ])], 40, c4)
          ]),
          f("div", u4, [
            c[14] || (c[14] = f("label", null, "Color", -1)),
            Ne(Ge(Kc), {
              modelValue: o.value.color,
              "onUpdate:modelValue": c[1] || (c[1] = (u) => a("color", u))
            }, null, 8, ["modelValue"])
          ]),
          f("div", d4, [
            c[15] || (c[15] = f("label", null, "Intensity", -1)),
            f("div", h4, [
              Ne(Ge(li), {
                modelValue: o.value.intensity,
                "onUpdate:modelValue": c[2] || (c[2] = (u) => a("intensity", u)),
                min: 0,
                max: 500,
                step: 1,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ]),
          o.value.lightType === "spot" ? (re(), ae(Ze, { key: 0 }, [
            f("div", f4, [
              c[16] || (c[16] = f("label", null, "Cone Angle", -1)),
              f("div", p4, [
                Ne(Ge(Nf), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[3] || (c[3] = (u) => a("coneAngle", u)),
                  size: 32
                }, null, 8, ["modelValue"]),
                Ne(Ge(et), {
                  modelValue: o.value.coneAngle ?? 90,
                  "onUpdate:modelValue": c[4] || (c[4] = (u) => a("coneAngle", u)),
                  unit: ""
                }, null, 8, ["modelValue"])
              ])
            ]),
            f("div", m4, [
              c[17] || (c[17] = f("label", null, "Cone Feather", -1)),
              Ne(Ge(li), {
                modelValue: o.value.coneFeather ?? 50,
                "onUpdate:modelValue": c[5] || (c[5] = (u) => a("coneFeather", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Pe("", !0),
          o.value.lightType !== "ambient" ? (re(), ae("div", v4, [
            c[19] || (c[19] = f("label", null, "Falloff", -1)),
            f("select", {
              value: o.value.falloff,
              onChange: c[6] || (c[6] = (u) => a("falloff", u.target.value)),
              class: "type-select"
            }, [...c[18] || (c[18] = [
              f("option", { value: "none" }, "None", -1),
              f("option", { value: "smooth" }, "Smooth", -1),
              f("option", { value: "inverseSquareClamped" }, "Inverse Square Clamped", -1)
            ])], 40, g4)
          ])) : Pe("", !0),
          o.value.lightType !== "ambient" && o.value.lightType !== "parallel" ? (re(), ae("div", y4, [
            c[20] || (c[20] = f("label", null, "Radius", -1)),
            Ne(Ge(et), {
              modelValue: o.value.radius,
              "onUpdate:modelValue": c[7] || (c[7] = (u) => a("radius", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Pe("", !0),
          o.value.lightType !== "ambient" ? (re(), ae("div", _4, [
            c[21] || (c[21] = f("label", null, "Falloff Distance", -1)),
            Ne(Ge(et), {
              modelValue: o.value.falloffDistance ?? 500,
              "onUpdate:modelValue": c[8] || (c[8] = (u) => a("falloffDistance", u)),
              min: 0,
              unit: "px"
            }, null, 8, ["modelValue"])
          ])) : Pe("", !0),
          f("div", x4, [
            f("label", null, [
              f("input", {
                type: "checkbox",
                checked: o.value.castShadows,
                onChange: c[9] || (c[9] = (u) => a("castShadows", u.target.checked))
              }, null, 40, b4),
              c[22] || (c[22] = ft(" Casts Shadows ", -1))
            ])
          ]),
          o.value.castShadows ? (re(), ae(Ze, { key: 4 }, [
            f("div", w4, [
              c[23] || (c[23] = f("label", null, "Shadow Darkness", -1)),
              Ne(Ge(li), {
                modelValue: o.value.shadowDarkness ?? 100,
                "onUpdate:modelValue": c[10] || (c[10] = (u) => a("shadowDarkness", u)),
                min: 0,
                max: 100,
                unit: "%"
              }, null, 8, ["modelValue"])
            ]),
            f("div", S4, [
              c[24] || (c[24] = f("label", null, "Shadow Diffusion", -1)),
              Ne(Ge(et), {
                modelValue: o.value.shadowDiffusion ?? 0,
                "onUpdate:modelValue": c[11] || (c[11] = (u) => a("shadowDiffusion", u)),
                min: 0,
                unit: "px"
              }, null, 8, ["modelValue"])
            ])
          ], 64)) : Pe("", !0),
          o.value.castShadows ? (re(), ae("div", M4, " Note: Shadows are only cast from layers with 'Cast Shadows' enabled to layers with 'Accepts Shadows' enabled. ")) : Pe("", !0)
        ])
      ])
    ]));
  }
}), E4 = /* @__PURE__ */ Bt(C4, [["__scopeId", "data-v-7bf0f1bf"]]), T4 = { class: "shape-properties" }, A4 = { class: "property-section" }, P4 = { class: "section-content" }, D4 = { class: "property-group" }, R4 = { class: "group-header" }, I4 = ["checked"], k4 = {
  key: 0,
  class: "control-row"
}, L4 = { class: "property-group" }, F4 = { class: "group-header" }, U4 = ["checked"], O4 = {
  key: 0,
  class: "stroke-controls"
}, z4 = { class: "control-row" }, N4 = { class: "property-row" }, B4 = { class: "property-row" }, V4 = { class: "icon-toggle-group" }, G4 = { class: "property-group" }, H4 = { class: "control-row checkbox-row" }, W4 = ["checked"], $4 = /* @__PURE__ */ Ut({
  __name: "ShapeProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Oe(() => n.layer.data || {
      pathData: "",
      controlPoints: [],
      closed: !1,
      stroke: "#ffffff",
      strokeWidth: 2,
      fill: ""
    }), a = Oe(() => !!o.value.fill && o.value.fill !== "transparent"), l = Oe(() => !!o.value.stroke && o.value.strokeWidth > 0), c = Oe(() => o.value.strokeLineCap || "round");
    function u(m, p) {
      r.updateLayer(n.layer.id, {
        data: { ...o.value, [m]: p }
      }), i("update");
    }
    function d(m) {
      const p = m.target.checked;
      u("fill", p ? "#ffffff" : "");
    }
    function h(m) {
      m.target.checked ? (u("stroke", "#ffffff"), u("strokeWidth", 2)) : u("strokeWidth", 0);
    }
    return (m, p) => (re(), ae("div", T4, [
      f("div", A4, [
        p[13] || (p[13] = f("div", { class: "section-header" }, "Shape Appearance", -1)),
        f("div", P4, [
          f("div", D4, [
            f("div", R4, [
              p[7] || (p[7] = f("label", null, "Fill", -1)),
              f("input", {
                type: "checkbox",
                checked: a.value,
                onChange: d
              }, null, 40, I4)
            ]),
            a.value ? (re(), ae("div", k4, [
              Ne(Ge(Kc), {
                modelValue: o.value.fill || "#ffffff",
                "onUpdate:modelValue": p[0] || (p[0] = (y) => u("fill", y)),
                alpha: !0
              }, null, 8, ["modelValue"])
            ])) : Pe("", !0)
          ]),
          f("div", L4, [
            f("div", F4, [
              p[8] || (p[8] = f("label", null, "Stroke", -1)),
              f("input", {
                type: "checkbox",
                checked: l.value,
                onChange: h
              }, null, 40, U4)
            ]),
            l.value ? (re(), ae("div", O4, [
              f("div", z4, [
                Ne(Ge(Kc), {
                  modelValue: o.value.stroke || "#ffffff",
                  "onUpdate:modelValue": p[1] || (p[1] = (y) => u("stroke", y)),
                  alpha: !0
                }, null, 8, ["modelValue"])
              ]),
              f("div", N4, [
                p[9] || (p[9] = f("label", { class: "sub-label" }, "Width", -1)),
                Ne(Ge(et), {
                  modelValue: o.value.strokeWidth || 0,
                  "onUpdate:modelValue": p[2] || (p[2] = (y) => u("strokeWidth", y)),
                  min: 0,
                  max: 500,
                  unit: "px"
                }, null, 8, ["modelValue"])
              ]),
              f("div", B4, [
                p[10] || (p[10] = f("label", { class: "sub-label" }, "Cap", -1)),
                f("div", V4, [
                  f("button", {
                    class: Ue({ active: c.value === "butt" }),
                    onClick: p[3] || (p[3] = (y) => u("strokeLineCap", "butt")),
                    title: "Butt Cap"
                  }, "I", 2),
                  f("button", {
                    class: Ue({ active: c.value === "round" }),
                    onClick: p[4] || (p[4] = (y) => u("strokeLineCap", "round")),
                    title: "Round Cap"
                  }, "C", 2),
                  f("button", {
                    class: Ue({ active: c.value === "square" }),
                    onClick: p[5] || (p[5] = (y) => u("strokeLineCap", "square")),
                    title: "Square Cap"
                  }, "H", 2)
                ])
              ])
            ])) : Pe("", !0)
          ]),
          f("div", G4, [
            p[12] || (p[12] = f("label", null, "Path", -1)),
            f("div", H4, [
              f("label", null, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.closed,
                  onChange: p[6] || (p[6] = (y) => u("closed", y.target.checked))
                }, null, 40, W4),
                p[11] || (p[11] = ft(" Closed Path ", -1))
              ])
            ])
          ])
        ])
      ])
    ]));
  }
}), X4 = /* @__PURE__ */ Bt($4, [["__scopeId", "data-v-e2af8c92"]]), j4 = { class: "video-properties" }, Y4 = {
  key: 0,
  class: "property-section"
}, q4 = { class: "section-content info-grid" }, Z4 = { class: "info-row" }, K4 = { class: "info-value" }, J4 = { class: "info-row" }, Q4 = { class: "info-value" }, e5 = { class: "info-row" }, t5 = { class: "info-value" }, n5 = { class: "info-row" }, i5 = { class: "info-value" }, s5 = { class: "property-section" }, r5 = { class: "section-content" }, o5 = { class: "property-row" }, a5 = { class: "property-row" }, l5 = { class: "property-row" }, c5 = { class: "checkbox-group" }, u5 = { class: "checkbox-row" }, d5 = ["checked"], h5 = { class: "checkbox-row" }, f5 = ["checked"], p5 = { class: "property-section" }, m5 = { class: "section-header" }, v5 = { class: "header-toggle" }, g5 = ["checked"], y5 = {
  key: 0,
  class: "section-content"
}, _5 = { class: "property-row" }, x5 = { class: "control-with-keyframe" }, b5 = { class: "property-section" }, w5 = { class: "section-content" }, S5 = { class: "property-row" }, M5 = ["value"], C5 = {
  key: 1,
  class: "property-section"
}, E5 = { class: "section-content" }, T5 = { class: "checkbox-group" }, A5 = { class: "checkbox-row" }, P5 = ["checked"], D5 = {
  key: 0,
  class: "property-row"
}, R5 = { class: "control-with-keyframe" }, I5 = {
  key: 1,
  class: "property-row"
}, k5 = {
  key: 2,
  class: "waveform-container"
}, L5 = /* @__PURE__ */ Ut({
  __name: "VideoProperties",
  props: {
    layer: {}
  },
  emits: ["update"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Oe(() => n.layer.data || {
      assetId: null,
      loop: !1,
      pingPong: !1,
      startTime: 0,
      endTime: void 0,
      speed: 1,
      timeRemapEnabled: !1,
      timeRemap: void 0,
      frameBlending: "none",
      audioEnabled: !0,
      audioLevel: 100,
      posterFrame: 0
    }), a = Oe(() => {
      const C = o.value.assetId;
      return C && r.assets[C] || null;
    }), l = Oe(() => {
      var C;
      return (C = n.layer.audio) == null ? void 0 : C.level;
    }), c = Oe(() => o.value.timeRemap ? o.value.timeRemap.value : 0);
    function u(C) {
      var b;
      if (!C) return "0:00";
      const E = Math.floor(C / 60), P = Math.floor(C % 60), T = Math.floor(C % 1 * (((b = a.value) == null ? void 0 : b.fps) || 30));
      return `${E}:${P.toString().padStart(2, "0")}:${T.toString().padStart(2, "0")}`;
    }
    function d(C) {
      r.updateVideoLayerData(n.layer.id, { speed: C }), i("update");
    }
    function h(C) {
      r.updateVideoLayerData(n.layer.id, { startTime: C }), i("update");
    }
    function m(C) {
      r.updateVideoLayerData(n.layer.id, { endTime: C }), i("update");
    }
    function p(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { loop: E.checked }), i("update");
    }
    function y(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { pingPong: E.checked }), i("update");
    }
    function _(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { timeRemapEnabled: E.checked }), i("update");
    }
    function v(C) {
      const E = n.layer.data;
      E.timeRemap && (E.timeRemap.value = C), i("update");
    }
    function g(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { frameBlending: E.value }), i("update");
    }
    function S(C) {
      const E = C.target;
      r.updateVideoLayerData(n.layer.id, { audioEnabled: E.checked }), i("update");
    }
    function w(C) {
      r.updateVideoLayerData(n.layer.id, { audioLevel: C }), i("update");
    }
    function x(C) {
      var E;
      (E = n.layer.audio) != null && E.level && (n.layer.audio.level.value = C, i("update"));
    }
    return (C, E) => {
      var P, T, b;
      return re(), ae("div", j4, [
        a.value ? (re(), ae("div", Y4, [
          E[4] || (E[4] = f("div", { class: "section-header" }, "Video Info", -1)),
          f("div", q4, [
            f("div", Z4, [
              E[0] || (E[0] = f("span", { class: "info-label" }, "Dimensions", -1)),
              f("span", K4, be(a.value.width) + "  " + be(a.value.height), 1)
            ]),
            f("div", J4, [
              E[1] || (E[1] = f("span", { class: "info-label" }, "Duration", -1)),
              f("span", Q4, be(u(a.value.duration)), 1)
            ]),
            f("div", e5, [
              E[2] || (E[2] = f("span", { class: "info-label" }, "Frame Rate", -1)),
              f("span", t5, be(((P = a.value.fps) == null ? void 0 : P.toFixed(2)) || "?") + " fps", 1)
            ]),
            f("div", n5, [
              E[3] || (E[3] = f("span", { class: "info-label" }, "Has Audio", -1)),
              f("span", i5, be(a.value.hasAudio ? "Yes" : "No"), 1)
            ])
          ])
        ])) : Pe("", !0),
        f("div", s5, [
          E[10] || (E[10] = f("div", { class: "section-header" }, "Playback", -1)),
          f("div", r5, [
            f("div", o5, [
              E[5] || (E[5] = f("label", null, "Speed", -1)),
              Ne(Ge(et), {
                modelValue: o.value.speed,
                "onUpdate:modelValue": d,
                min: 0.1,
                max: 10,
                step: 0.1,
                precision: 2,
                unit: "x"
              }, null, 8, ["modelValue"])
            ]),
            f("div", a5, [
              E[6] || (E[6] = f("label", null, "Start Time", -1)),
              Ne(Ge(et), {
                modelValue: o.value.startTime,
                "onUpdate:modelValue": h,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            f("div", l5, [
              E[7] || (E[7] = f("label", null, "End Time", -1)),
              Ne(Ge(et), {
                modelValue: o.value.endTime || ((T = a.value) == null ? void 0 : T.duration) || 0,
                "onUpdate:modelValue": m,
                min: 0,
                step: 0.1,
                precision: 2,
                unit: "s"
              }, null, 8, ["modelValue"])
            ]),
            f("div", c5, [
              f("label", u5, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.loop,
                  onChange: p
                }, null, 40, d5),
                E[8] || (E[8] = f("span", null, "Loop", -1))
              ]),
              f("label", h5, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.pingPong,
                  onChange: y
                }, null, 40, f5),
                E[9] || (E[9] = f("span", null, "Ping-Pong", -1))
              ])
            ])
          ])
        ]),
        f("div", p5, [
          f("div", m5, [
            E[11] || (E[11] = f("span", null, "Time Remap", -1)),
            f("label", v5, [
              f("input", {
                type: "checkbox",
                checked: o.value.timeRemapEnabled,
                onChange: _
              }, null, 40, g5)
            ])
          ]),
          o.value.timeRemapEnabled ? (re(), ae("div", y5, [
            f("div", _5, [
              E[12] || (E[12] = f("label", null, "Remap Time", -1)),
              f("div", x5, [
                Ne(Ge(et), {
                  modelValue: c.value,
                  "onUpdate:modelValue": v,
                  min: 0,
                  step: 0.01,
                  precision: 3,
                  unit: "s"
                }, null, 8, ["modelValue"]),
                o.value.timeRemap ? (re(), St(Pr, {
                  key: 0,
                  property: o.value.timeRemap,
                  layerId: s.layer.id,
                  propertyPath: "data.timeRemap"
                }, null, 8, ["property", "layerId"])) : Pe("", !0)
              ])
            ]),
            E[13] || (E[13] = f("p", { class: "hint" }, "Animate time remap to control video playback independently of composition time.", -1))
          ])) : Pe("", !0)
        ]),
        f("div", b5, [
          E[16] || (E[16] = f("div", { class: "section-header" }, "Frame Blending", -1)),
          f("div", w5, [
            f("div", S5, [
              E[15] || (E[15] = f("label", null, "Mode", -1)),
              f("select", {
                value: o.value.frameBlending,
                onChange: g,
                class: "select-input"
              }, [...E[14] || (E[14] = [
                f("option", { value: "none" }, "None", -1),
                f("option", { value: "frame-mix" }, "Frame Mix", -1),
                f("option", { value: "pixel-motion" }, "Pixel Motion", -1)
              ])], 40, M5)
            ])
          ])
        ]),
        ((b = a.value) == null ? void 0 : b.hasAudio) !== !1 ? (re(), ae("div", C5, [
          E[21] || (E[21] = f("div", { class: "section-header" }, "Audio", -1)),
          f("div", E5, [
            f("div", T5, [
              f("label", A5, [
                f("input", {
                  type: "checkbox",
                  checked: o.value.audioEnabled,
                  onChange: S
                }, null, 40, P5),
                E[17] || (E[17] = f("span", null, "Audio Enabled", -1))
              ])
            ]),
            o.value.audioEnabled ? (re(), ae("div", D5, [
              E[18] || (E[18] = f("label", null, "Level", -1)),
              f("div", R5, [
                l.value ? (re(), St(Ge(et), {
                  key: 0,
                  modelValue: l.value.value,
                  "onUpdate:modelValue": x,
                  unit: "dB",
                  min: -48,
                  max: 12,
                  precision: 1
                }, null, 8, ["modelValue"])) : Pe("", !0),
                l.value ? (re(), St(Pr, {
                  key: 1,
                  property: l.value,
                  layerId: s.layer.id
                }, null, 8, ["property", "layerId"])) : Pe("", !0)
              ])
            ])) : Pe("", !0),
            o.value.audioEnabled ? (re(), ae("div", I5, [
              E[19] || (E[19] = f("label", null, "Volume", -1)),
              Ne(Ge(et), {
                modelValue: o.value.audioLevel,
                "onUpdate:modelValue": w,
                min: 0,
                max: 200,
                step: 1,
                precision: 0,
                unit: "%"
              }, null, 8, ["modelValue"])
            ])) : Pe("", !0),
            o.value.audioEnabled ? (re(), ae("div", k5, [...E[20] || (E[20] = [
              f("div", { class: "waveform-placeholder" }, "Audio Waveform", -1)
            ])])) : Pe("", !0)
          ])
        ])) : Pe("", !0)
      ]);
    };
  }
}), F5 = /* @__PURE__ */ Bt(L5, [["__scopeId", "data-v-5f46759a"]]), U5 = ["title"], O5 = {
  viewBox: "0 0 16 16",
  class: "pickwhip-icon"
}, z5 = {
  key: 0,
  d: "M8 5 L8 2 M8 11 L8 14 M5 8 L2 8 M11 8 L14 8",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, N5 = {
  key: 1,
  d: "M11 5 L14 2 M11 11 L14 14",
  stroke: "currentColor",
  "stroke-width": "1.5",
  fill: "none"
}, B5 = ["x1", "y1", "x2", "y2"], V5 = ["cx", "cy"], G5 = { class: "drop-label" }, H5 = /* @__PURE__ */ Ut({
  __name: "Pickwhip",
  props: {
    layerId: {},
    property: {},
    linkedTo: {}
  },
  emits: ["link", "unlink"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = Se(null), o = Se(!1), a = Se({ x: 0, y: 0 }), l = Se({ x: 0, y: 0 }), c = Se(null), u = Oe(() => !!n.linkedTo), d = Oe(() => n.linkedTo ? `${n.linkedTo.layerId}.${n.linkedTo.property}` : ""), h = Oe(() => ({
      position: "fixed",
      top: 0,
      left: 0,
      width: "100vw",
      height: "100vh",
      pointerEvents: "none",
      zIndex: 1e4
    })), m = Oe(() => {
      if (!c.value) return {};
      const x = c.value.rect;
      return {
        position: "fixed",
        top: `${x.top}px`,
        left: `${x.left}px`,
        width: `${x.width}px`,
        height: `${x.height}px`,
        zIndex: 9999
      };
    });
    function p() {
      const x = [];
      return document.querySelectorAll("[data-pickwhip-target]").forEach((E) => {
        const P = E, T = P.dataset.pickwhipLayerId, b = P.dataset.pickwhipTarget, M = P.dataset.pickwhipLabel || b;
        T === n.layerId && b === n.property || T && b && x.push({
          layerId: T,
          property: b,
          label: M,
          element: P,
          rect: P.getBoundingClientRect()
        });
      }), x;
    }
    function y(x, C, E) {
      for (const P of E) {
        const T = P.rect;
        if (x >= T.left && x <= T.right && C >= T.top && C <= T.bottom)
          return P;
      }
      return null;
    }
    let _ = [];
    function v(x) {
      var T;
      x.preventDefault(), x.stopPropagation();
      const C = "touches" in x ? x.touches[0].clientX : x.clientX, E = "touches" in x ? x.touches[0].clientY : x.clientY, P = (T = r.value) == null ? void 0 : T.getBoundingClientRect();
      P ? a.value = { x: P.left + P.width / 2, y: P.top + P.height / 2 } : a.value = { x: C, y: E }, l.value = { x: C, y: E }, o.value = !0, _ = p(), window.addEventListener("mousemove", g), window.addEventListener("mouseup", S), window.addEventListener("touchmove", g), window.addEventListener("touchend", S);
    }
    function g(x) {
      if (!o.value) return;
      const C = "touches" in x ? x.touches[0].clientX : x.clientX, E = "touches" in x ? x.touches[0].clientY : x.clientY;
      l.value = { x: C, y: E }, _.forEach((P) => {
        P.rect = P.element.getBoundingClientRect();
      }), c.value = y(C, E, _);
    }
    function S(x) {
      if (!o.value) return;
      const C = "changedTouches" in x ? x.changedTouches[0].clientX : x.clientX, E = "changedTouches" in x ? x.changedTouches[0].clientY : x.clientY, P = y(C, E, _);
      P && i("link", { layerId: P.layerId, property: P.property }), o.value = !1, c.value = null, _ = [], window.removeEventListener("mousemove", g), window.removeEventListener("mouseup", S), window.removeEventListener("touchmove", g), window.removeEventListener("touchend", S);
    }
    function w() {
      i("unlink");
    }
    return jn(() => {
      window.removeEventListener("mousemove", g), window.removeEventListener("mouseup", S), window.removeEventListener("touchmove", g), window.removeEventListener("touchend", S);
    }), (x, C) => (re(), ae("div", {
      class: "pickwhip-container",
      ref_key: "containerRef",
      ref: r
    }, [
      f("div", {
        class: Ue(["pickwhip-handle", { dragging: o.value, linked: u.value }]),
        onMousedown: v,
        onTouchstart: wt(v, ["prevent"]),
        title: u.value ? `Linked to: ${d.value}` : "Drag to link property"
      }, [
        (re(), ae("svg", O5, [
          C[0] || (C[0] = f("circle", {
            cx: "8",
            cy: "8",
            r: "3",
            fill: "currentColor"
          }, null, -1)),
          u.value ? (re(), ae("path", N5)) : (re(), ae("path", z5))
        ]))
      ], 42, U5),
      u.value ? (re(), ae("button", {
        key: 0,
        class: "clear-link-btn",
        onClick: w,
        title: "Remove link"
      }, "  ")) : Pe("", !0),
      (re(), St(Po, { to: "body" }, [
        o.value ? (re(), ae("svg", {
          key: 0,
          class: "pickwhip-line",
          style: bt(h.value)
        }, [
          f("line", {
            x1: a.value.x,
            y1: a.value.y,
            x2: l.value.x,
            y2: l.value.y,
            stroke: "#4a90d9",
            "stroke-width": "2",
            "stroke-dasharray": "4 2"
          }, null, 8, B5),
          f("circle", {
            cx: l.value.x,
            cy: l.value.y,
            r: "6",
            fill: "#4a90d9",
            stroke: "#fff",
            "stroke-width": "1"
          }, null, 8, V5)
        ], 4)) : Pe("", !0)
      ])),
      (re(), St(Po, { to: "body" }, [
        o.value && c.value ? (re(), ae("div", {
          key: 0,
          class: "drop-target-highlight",
          style: bt(m.value)
        }, [
          f("span", G5, be(c.value.label), 1)
        ], 4)) : Pe("", !0)
      ]))
    ], 512));
  }
}), ac = /* @__PURE__ */ Bt(H5, [["__scopeId", "data-v-da1938e3"]]), W5 = {
  key: 0,
  class: "driver-list"
}, $5 = { class: "expand-icon" }, X5 = { class: "count" }, j5 = {
  key: 0,
  class: "driver-items"
}, Y5 = { class: "driver-header" }, q5 = ["onClick"], Z5 = { class: "driver-info" }, K5 = { class: "target" }, J5 = {
  key: 0,
  class: "source"
}, Q5 = {
  key: 1,
  class: "source audio"
}, eF = {
  key: 2,
  class: "source time"
}, tF = ["onClick"], nF = {
  key: 0,
  class: "driver-transforms"
}, iF = ["title"], sF = {
  key: 1,
  class: "add-driver-section"
}, rF = {
  key: 0,
  class: "add-menu"
}, oF = { class: "menu-section" }, aF = { class: "menu-section" }, lF = { class: "menu-section" }, cF = { class: "menu-section" }, uF = { class: "menu-actions" }, dF = /* @__PURE__ */ Ut({
  __name: "DriverList",
  props: {
    layerId: {}
  },
  setup(s) {
    const e = s, n = nn(), i = Se(!0), r = Se(!1), o = Se({
      audioFeature: "amplitude",
      targetProperty: "transform.position.y",
      scale: 100,
      threshold: 0
    }), a = Oe(() => n.getDriversForLayer(e.layerId));
    function l(p) {
      return p ? {
        "transform.position.x": "Pos X",
        "transform.position.y": "Pos Y",
        "transform.position.z": "Pos Z",
        "transform.scale.x": "Scale X",
        "transform.scale.y": "Scale Y",
        "transform.rotation": "Rotation",
        "transform.rotationX": "Rot X",
        "transform.rotationY": "Rot Y",
        "transform.rotationZ": "Rot Z",
        opacity: "Opacity"
      }[p] || p : "?";
    }
    function c(p) {
      if (!p) return "?";
      const y = n.layers.find((_) => _.id === p);
      return (y == null ? void 0 : y.name) || p.slice(0, 8);
    }
    function u(p) {
      switch (p.type) {
        case "scale":
          return `Scale: ${p.factor}`;
        case "offset":
          return `Offset: ${p.amount}`;
        case "clamp":
          return `Clamp: ${p.min}-${p.max}`;
        case "smooth":
          return `Smooth: ${p.smoothing}`;
        case "threshold":
          return `Threshold: ${p.threshold}`;
        default:
          return p.type;
      }
    }
    function d(p) {
      n.togglePropertyDriver(p);
    }
    function h(p) {
      n.removePropertyDriver(p);
    }
    function m() {
      n.createAudioPropertyDriver(
        e.layerId,
        o.value.targetProperty,
        o.value.audioFeature,
        {
          scale: o.value.scale,
          threshold: o.value.threshold > 0 ? o.value.threshold : void 0
        }
      ), r.value = !1;
    }
    return (p, y) => a.value.length > 0 ? (re(), ae("div", W5, [
      f("div", {
        class: "driver-list-header",
        onClick: y[0] || (y[0] = (_) => i.value = !i.value)
      }, [
        f("span", $5, be(i.value ? "" : ""), 1),
        y[7] || (y[7] = f("span", { class: "title" }, "Property Drivers", -1)),
        f("span", X5, "(" + be(a.value.length) + ")", 1)
      ]),
      i.value ? (re(), ae("div", j5, [
        (re(!0), ae(Ze, null, at(a.value, (_) => (re(), ae("div", {
          key: _.id,
          class: Ue(["driver-item", { disabled: !_.enabled }])
        }, [
          f("div", Y5, [
            f("button", {
              class: Ue(["toggle-btn", { active: _.enabled }]),
              onClick: (v) => d(_.id),
              title: "Toggle driver"
            }, "  ", 10, q5),
            f("div", Z5, [
              f("span", K5, be(l(_.targetProperty)), 1),
              y[8] || (y[8] = f("span", { class: "arrow" }, "", -1)),
              _.sourceType === "property" ? (re(), ae("span", J5, be(c(_.sourceLayerId)) + "." + be(l(_.sourceProperty)), 1)) : _.sourceType === "audio" ? (re(), ae("span", Q5, "  " + be(_.audioFeature), 1)) : _.sourceType === "time" ? (re(), ae("span", eF, "  Time ")) : Pe("", !0)
            ]),
            f("button", {
              class: "remove-btn",
              onClick: (v) => h(_.id),
              title: "Remove driver"
            }, "  ", 8, tF)
          ]),
          _.transforms.length > 0 ? (re(), ae("div", nF, [
            (re(!0), ae(Ze, null, at(_.transforms, (v, g) => (re(), ae("span", {
              key: g,
              class: "transform-chip",
              title: u(v)
            }, be(v.type), 9, iF))), 128))
          ])) : Pe("", !0)
        ], 2))), 128))
      ])) : Pe("", !0),
      i.value ? (re(), ae("div", sF, [
        f("button", {
          class: "add-driver-btn",
          onClick: y[1] || (y[1] = (_) => r.value = !r.value)
        }, " + Add Audio Driver "),
        r.value ? (re(), ae("div", rF, [
          f("div", oF, [
            y[10] || (y[10] = f("label", null, "Audio Feature:", -1)),
            ct(f("select", {
              "onUpdate:modelValue": y[2] || (y[2] = (_) => o.value.audioFeature = _)
            }, [...y[9] || (y[9] = [
              Or('<option value="amplitude" data-v-d3107912>Amplitude</option><option value="bass" data-v-d3107912>Bass</option><option value="mid" data-v-d3107912>Mid</option><option value="high" data-v-d3107912>High</option><option value="rms" data-v-d3107912>RMS</option>', 5)
            ])], 512), [
              [ti, o.value.audioFeature]
            ])
          ]),
          f("div", aF, [
            y[12] || (y[12] = f("label", null, "Target Property:", -1)),
            ct(f("select", {
              "onUpdate:modelValue": y[3] || (y[3] = (_) => o.value.targetProperty = _)
            }, [...y[11] || (y[11] = [
              Or('<option value="transform.position.x" data-v-d3107912>Position X</option><option value="transform.position.y" data-v-d3107912>Position Y</option><option value="transform.scale.x" data-v-d3107912>Scale X</option><option value="transform.scale.y" data-v-d3107912>Scale Y</option><option value="transform.rotation" data-v-d3107912>Rotation</option><option value="opacity" data-v-d3107912>Opacity</option>', 6)
            ])], 512), [
              [ti, o.value.targetProperty]
            ])
          ]),
          f("div", lF, [
            y[13] || (y[13] = f("label", null, "Scale:", -1)),
            ct(f("input", {
              type: "number",
              "onUpdate:modelValue": y[4] || (y[4] = (_) => o.value.scale = _),
              step: "10"
            }, null, 512), [
              [
                $t,
                o.value.scale,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          f("div", cF, [
            y[14] || (y[14] = f("label", null, "Threshold:", -1)),
            ct(f("input", {
              type: "number",
              "onUpdate:modelValue": y[5] || (y[5] = (_) => o.value.threshold = _),
              min: "0",
              max: "1",
              step: "0.1"
            }, null, 512), [
              [
                $t,
                o.value.threshold,
                void 0,
                { number: !0 }
              ]
            ])
          ]),
          f("div", uF, [
            f("button", { onClick: m }, "Create"),
            f("button", {
              onClick: y[6] || (y[6] = (_) => r.value = !1)
            }, "Cancel")
          ])
        ])) : Pe("", !0)
      ])) : Pe("", !0)
    ])) : Pe("", !0);
  }
}), hF = /* @__PURE__ */ Bt(dF, [["__scopeId", "data-v-d3107912"]]), fF = { class: "properties-panel" }, pF = {
  key: 0,
  class: "panel-content"
}, mF = { class: "property-section" }, vF = { class: "property-row" }, gF = { class: "property-section" }, yF = { class: "property-row" }, _F = ["value"], xF = ["value"], bF = { class: "property-section" }, wF = { class: "expand-icon" }, SF = {
  key: 0,
  class: "section-content"
}, MF = ["data-pickwhip-layer-id"], CF = { class: "multi-value" }, EF = { class: "multi-value" }, TF = { class: "property-row" }, AF = { class: "multi-value orientation-row" }, PF = { class: "property-row" }, DF = { class: "single-value" }, RF = { class: "property-row" }, IF = { class: "single-value" }, kF = { class: "property-row" }, LF = { class: "single-value" }, FF = { class: "single-value" }, UF = { class: "property-row" }, OF = { class: "multi-value" }, zF = { class: "single-value" }, NF = { class: "property-section" }, BF = { class: "property-row" }, VF = ["value"], GF = {
  key: 1,
  class: "empty-state"
}, HF = /* @__PURE__ */ Ut({
  __name: "PropertiesPanel",
  setup(s) {
    const e = nn(), n = Se(["transform"]), i = Se(!0), r = Se(""), o = Se({
      position: { x: 0, y: 0, z: 0 },
      scale: { x: 100, y: 100 },
      rotation: 0,
      anchorPoint: { x: 0, y: 0 },
      opacity: 100,
      // 3D properties
      orientationX: 0,
      orientationY: 0,
      orientationZ: 0,
      rotationX: 0,
      rotationY: 0,
      rotationZ: 0
    }), a = Se("normal"), l = Se([]), c = [
      { label: "Normal", value: "normal" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
      { label: "Add", value: "add" }
    ], u = Oe(() => e.selectedLayer), d = Oe(() => {
      if (!u.value) return [];
      const T = u.value.id, b = (L) => {
        const N = e.layers.filter((O) => O.parentId === L);
        let D = N.map((O) => O.id);
        for (const O of N)
          D = D.concat(b(O.id));
        return D;
      }, M = new Set(b(T));
      return e.layers.filter(
        (L) => L.id !== T && !M.has(L.id) && L.type !== "camera"
        // Camera layers shouldn't be parents
      );
    }), h = Oe(() => {
      if (!u.value) return null;
      switch (u.value.type) {
        case "text":
          return ys(VP);
        case "particles":
          return ys(Vk);
        case "depthflow":
          return ys(s4);
        case "light":
          return ys(E4);
        case "spline":
          return ys(X4);
        case "video":
          return ys(F5);
        default:
          return null;
      }
    });
    Ft(u, (T) => {
      var b, M, L, N, D, O, A, G, he, ee, le, oe, Y, j, q, te, ne, de, H, X, V, I, F, k, Q;
      if (T) {
        r.value = T.name;
        const Z = T.transform;
        o.value = {
          position: {
            x: ((M = (b = Z == null ? void 0 : Z.position) == null ? void 0 : b.value) == null ? void 0 : M.x) || 0,
            y: ((N = (L = Z == null ? void 0 : Z.position) == null ? void 0 : L.value) == null ? void 0 : N.y) || 0,
            z: ((O = (D = Z == null ? void 0 : Z.position) == null ? void 0 : D.value) == null ? void 0 : O.z) || 0
          },
          scale: { x: ((G = (A = Z == null ? void 0 : Z.scale) == null ? void 0 : A.value) == null ? void 0 : G.x) || 100, y: ((ee = (he = Z == null ? void 0 : Z.scale) == null ? void 0 : he.value) == null ? void 0 : ee.y) || 100 },
          rotation: ((le = Z == null ? void 0 : Z.rotation) == null ? void 0 : le.value) || 0,
          anchorPoint: { x: ((Y = (oe = Z == null ? void 0 : Z.anchorPoint) == null ? void 0 : oe.value) == null ? void 0 : Y.x) || 0, y: ((q = (j = Z == null ? void 0 : Z.anchorPoint) == null ? void 0 : j.value) == null ? void 0 : q.y) || 0 },
          opacity: ((te = T.opacity) == null ? void 0 : te.value) || 100,
          // 3D properties
          orientationX: ((de = (ne = Z == null ? void 0 : Z.orientation) == null ? void 0 : ne.value) == null ? void 0 : de.x) || 0,
          orientationY: ((X = (H = Z == null ? void 0 : Z.orientation) == null ? void 0 : H.value) == null ? void 0 : X.y) || 0,
          orientationZ: ((I = (V = Z == null ? void 0 : Z.orientation) == null ? void 0 : V.value) == null ? void 0 : I.z) || 0,
          rotationX: ((F = Z == null ? void 0 : Z.rotationX) == null ? void 0 : F.value) || 0,
          rotationY: ((k = Z == null ? void 0 : Z.rotationY) == null ? void 0 : k.value) || 0,
          rotationZ: ((Q = Z == null ? void 0 : Z.rotationZ) == null ? void 0 : Q.value) || 0
        }, a.value = T.blendMode || "normal";
      }
    }, { immediate: !0 }), Ft(() => o.value.scale.x, (T, b) => {
      if (i.value && T !== b) {
        const M = T / b;
        o.value.scale.y = Math.round(o.value.scale.y * M * 10) / 10;
      }
    });
    function m(T) {
      const b = n.value.indexOf(T);
      b >= 0 ? n.value.splice(b, 1) : n.value.push(T);
    }
    function p() {
      u.value && r.value && (u.value.name = r.value);
    }
    function y() {
      if (!u.value) return;
      const T = u.value.transform, b = o.value;
      T != null && T.position && (T.position.value = { x: b.position.x, y: b.position.y, z: b.position.z }), T != null && T.scale && (T.scale.value = { x: b.scale.x, y: b.scale.y }), T != null && T.rotation && (T.rotation.value = b.rotation), T != null && T.anchorPoint && (T.anchorPoint.value = { x: b.anchorPoint.x, y: b.anchorPoint.y }), u.value.opacity && (u.value.opacity.value = b.opacity), u.value.threeD && (T != null && T.orientation && (T.orientation.value = { x: b.orientationX, y: b.orientationY, z: b.orientationZ }), T != null && T.rotationX && (T.rotationX.value = b.rotationX), T != null && T.rotationY && (T.rotationY.value = b.rotationY), T != null && T.rotationZ && (T.rotationZ.value = b.rotationZ)), S();
    }
    function _() {
      u.value && (u.value.blendMode = a.value);
    }
    function v(T) {
      return l.value.includes(T);
    }
    function g(T) {
      const b = l.value.indexOf(T);
      b >= 0 ? l.value.splice(b, 1) : (l.value.push(T), console.log(`Added keyframe for ${T} at frame ${e.currentFrame}`));
    }
    function S(T) {
      u.value && (T && Object.keys(T).length > 0 ? e.updateLayerData(u.value.id, T) : e.project.meta.modified = (/* @__PURE__ */ new Date()).toISOString());
    }
    function w(T) {
      if (!u.value) return;
      const b = T.target.value || null;
      e.setLayerParent(u.value.id, b);
    }
    function x(T) {
      if (!u.value) return null;
      const M = e.getDriversForLayer(u.value.id).find((L) => L.targetProperty === T && L.sourceType === "property");
      return M && M.sourceLayerId && M.sourceProperty ? {
        layerId: M.sourceLayerId,
        property: M.sourceProperty
      } : null;
    }
    function C(T, b) {
      u.value && (e.createPropertyLink(
        u.value.id,
        T,
        b.layerId,
        b.property,
        { blendMode: "add" }
      ), console.log(`[PropertiesPanel] Linked ${u.value.id}.${T} <- ${b.layerId}.${b.property}`));
    }
    function E(T) {
      if (!u.value) return;
      const M = e.getDriversForLayer(u.value.id).find((L) => L.targetProperty === T && L.sourceType === "property");
      M && (e.removePropertyDriver(M.id), console.log(`[PropertiesPanel] Unlinked ${u.value.id}.${T}`));
    }
    function P(T) {
      return u.value ? e.getDriversForLayer(u.value.id).some((M) => M.targetProperty === T && M.enabled) : !1;
    }
    return (T, b) => {
      var M, L, N, D, O, A, G, he, ee, le, oe;
      return re(), ae("div", fF, [
        b[49] || (b[49] = f("div", { class: "panel-header" }, [
          f("span", { class: "panel-title" }, "Layer Properties")
        ], -1)),
        u.value ? (re(), ae("div", pF, [
          f("div", mF, [
            f("div", vF, [
              ct(f("input", {
                type: "text",
                "onUpdate:modelValue": b[0] || (b[0] = (Y) => r.value = Y),
                class: "layer-name-input",
                onBlur: p,
                onKeydown: b[1] || (b[1] = Ja((Y) => Y.target.blur(), ["enter"]))
              }, null, 544), [
                [$t, r.value]
              ])
            ])
          ]),
          f("div", gF, [
            f("div", yF, [
              b[37] || (b[37] = f("label", null, "Parent", -1)),
              f("select", {
                class: "parent-select",
                value: ((M = u.value) == null ? void 0 : M.parentId) || "",
                onChange: w
              }, [
                b[36] || (b[36] = f("option", { value: "" }, "None", -1)),
                (re(!0), ae(Ze, null, at(d.value, (Y) => (re(), ae("option", {
                  key: Y.id,
                  value: Y.id
                }, be(Y.name), 9, xF))), 128))
              ], 40, _F)
            ])
          ]),
          f("div", bF, [
            f("div", {
              class: "section-header",
              onClick: b[2] || (b[2] = (Y) => m("transform"))
            }, [
              f("span", wF, be(n.value.includes("transform") ? "" : ""), 1),
              b[38] || (b[38] = f("span", { class: "section-title" }, "Transform", -1))
            ]),
            n.value.includes("transform") ? (re(), ae("div", SF, [
              f("div", {
                class: Ue(["property-row", { "has-driver": P("transform.position.x") }])
              }, [
                u.value ? (re(), St(ac, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.position.x",
                  linkedTo: x("transform.position.x"),
                  onLink: b[3] || (b[3] = (Y) => C("transform.position.x", Y)),
                  onUnlink: b[4] || (b[4] = () => E("transform.position.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                f("label", {
                  "data-pickwhip-target": "transform.position.x",
                  "data-pickwhip-layer-id": (L = u.value) == null ? void 0 : L.id,
                  "data-pickwhip-label": "Position X"
                }, "Position", 8, MF),
                f("div", CF, [
                  Ne(Ge(et), {
                    modelValue: o.value.position.x,
                    "onUpdate:modelValue": [
                      b[5] || (b[5] = (Y) => o.value.position.x = Y),
                      y
                    ],
                    precision: 1,
                    unit: "X",
                    "data-pickwhip-target": "transform.position.x",
                    "data-pickwhip-layer-id": (N = u.value) == null ? void 0 : N.id,
                    "data-pickwhip-label": "Position X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  Ne(Ge(et), {
                    modelValue: o.value.position.y,
                    "onUpdate:modelValue": [
                      b[6] || (b[6] = (Y) => o.value.position.y = Y),
                      y
                    ],
                    precision: 1,
                    unit: "Y",
                    "data-pickwhip-target": "transform.position.y",
                    "data-pickwhip-layer-id": (D = u.value) == null ? void 0 : D.id,
                    "data-pickwhip-label": "Position Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  (O = u.value) != null && O.threeD ? (re(), St(Ge(et), {
                    key: 0,
                    modelValue: o.value.position.z,
                    "onUpdate:modelValue": [
                      b[7] || (b[7] = (Y) => o.value.position.z = Y),
                      y
                    ],
                    precision: 1,
                    unit: "Z",
                    "data-pickwhip-target": "transform.position.z",
                    "data-pickwhip-layer-id": (A = u.value) == null ? void 0 : A.id,
                    "data-pickwhip-label": "Position Z"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])) : Pe("", !0)
                ]),
                f("button", {
                  class: Ue(["keyframe-btn", { active: v("position") }]),
                  onClick: b[8] || (b[8] = (Y) => g("position"))
                }, "", 2)
              ], 2),
              f("div", {
                class: Ue(["property-row", { "has-driver": P("transform.scale.x") || P("transform.scale.y") }])
              }, [
                u.value ? (re(), St(ac, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.scale.x",
                  linkedTo: x("transform.scale.x"),
                  onLink: b[9] || (b[9] = (Y) => C("transform.scale.x", Y)),
                  onUnlink: b[10] || (b[10] = () => E("transform.scale.x"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                b[39] || (b[39] = f("label", null, "Scale", -1)),
                f("div", EF, [
                  Ne(Ge(et), {
                    modelValue: o.value.scale.x,
                    "onUpdate:modelValue": [
                      b[11] || (b[11] = (Y) => o.value.scale.x = Y),
                      y
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.x",
                    "data-pickwhip-layer-id": (G = u.value) == null ? void 0 : G.id,
                    "data-pickwhip-label": "Scale X"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"]),
                  f("button", {
                    class: Ue(["link-btn", { active: i.value }]),
                    onClick: b[12] || (b[12] = (Y) => i.value = !i.value),
                    title: "Link scale values"
                  }, "  ", 2),
                  Ne(Ge(et), {
                    modelValue: o.value.scale.y,
                    "onUpdate:modelValue": [
                      b[13] || (b[13] = (Y) => o.value.scale.y = Y),
                      y
                    ],
                    min: 0,
                    max: 1e3,
                    unit: "%",
                    "data-pickwhip-target": "transform.scale.y",
                    "data-pickwhip-layer-id": (he = u.value) == null ? void 0 : he.id,
                    "data-pickwhip-label": "Scale Y"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Ue(["keyframe-btn", { active: v("scale") }]),
                  onClick: b[14] || (b[14] = (Y) => g("scale"))
                }, "", 2)
              ], 2),
              (ee = u.value) != null && ee.threeD ? (re(), ae(Ze, { key: 0 }, [
                f("div", TF, [
                  b[40] || (b[40] = f("label", null, "Orientation", -1)),
                  f("div", AF, [
                    Ne(Ge(et), {
                      modelValue: o.value.orientationX,
                      "onUpdate:modelValue": [
                        b[15] || (b[15] = (Y) => o.value.orientationX = Y),
                        y
                      ],
                      unit: "X"
                    }, null, 8, ["modelValue"]),
                    Ne(Ge(et), {
                      modelValue: o.value.orientationY,
                      "onUpdate:modelValue": [
                        b[16] || (b[16] = (Y) => o.value.orientationY = Y),
                        y
                      ],
                      unit: "Y"
                    }, null, 8, ["modelValue"]),
                    Ne(Ge(et), {
                      modelValue: o.value.orientationZ,
                      "onUpdate:modelValue": [
                        b[17] || (b[17] = (Y) => o.value.orientationZ = Y),
                        y
                      ],
                      unit: "Z"
                    }, null, 8, ["modelValue"])
                  ])
                ]),
                f("div", PF, [
                  b[41] || (b[41] = f("label", null, "X Rotation", -1)),
                  f("div", DF, [
                    Ne(Ge(et), {
                      modelValue: o.value.rotationX,
                      "onUpdate:modelValue": [
                        b[18] || (b[18] = (Y) => o.value.rotationX = Y),
                        y
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Ue(["keyframe-btn", { active: v("rotationX") }]),
                    onClick: b[19] || (b[19] = (Y) => g("rotationX"))
                  }, "", 2)
                ]),
                f("div", RF, [
                  b[42] || (b[42] = f("label", null, "Y Rotation", -1)),
                  f("div", IF, [
                    Ne(Ge(et), {
                      modelValue: o.value.rotationY,
                      "onUpdate:modelValue": [
                        b[20] || (b[20] = (Y) => o.value.rotationY = Y),
                        y
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Ue(["keyframe-btn", { active: v("rotationY") }]),
                    onClick: b[21] || (b[21] = (Y) => g("rotationY"))
                  }, "", 2)
                ]),
                f("div", kF, [
                  b[43] || (b[43] = f("label", null, "Z Rotation", -1)),
                  f("div", LF, [
                    Ne(Ge(et), {
                      modelValue: o.value.rotationZ,
                      "onUpdate:modelValue": [
                        b[22] || (b[22] = (Y) => o.value.rotationZ = Y),
                        y
                      ],
                      unit: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  f("button", {
                    class: Ue(["keyframe-btn", { active: v("rotationZ") }]),
                    onClick: b[23] || (b[23] = (Y) => g("rotationZ"))
                  }, "", 2)
                ])
              ], 64)) : (re(), ae("div", {
                key: 1,
                class: Ue(["property-row", { "has-driver": P("transform.rotation") }])
              }, [
                u.value ? (re(), St(ac, {
                  key: 0,
                  layerId: u.value.id,
                  property: "transform.rotation",
                  linkedTo: x("transform.rotation"),
                  onLink: b[24] || (b[24] = (Y) => C("transform.rotation", Y)),
                  onUnlink: b[25] || (b[25] = () => E("transform.rotation"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                b[44] || (b[44] = f("label", null, "Rotation", -1)),
                f("div", FF, [
                  Ne(Ge(et), {
                    modelValue: o.value.rotation,
                    "onUpdate:modelValue": [
                      b[26] || (b[26] = (Y) => o.value.rotation = Y),
                      y
                    ],
                    min: -360,
                    max: 360,
                    unit: "",
                    "data-pickwhip-target": "transform.rotation",
                    "data-pickwhip-layer-id": (le = u.value) == null ? void 0 : le.id,
                    "data-pickwhip-label": "Rotation"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Ue(["keyframe-btn", { active: v("rotation") }]),
                  onClick: b[27] || (b[27] = (Y) => g("rotation"))
                }, "", 2)
              ], 2)),
              f("div", UF, [
                b[45] || (b[45] = f("label", null, "Anchor Point", -1)),
                f("div", OF, [
                  Ne(Ge(et), {
                    modelValue: o.value.anchorPoint.x,
                    "onUpdate:modelValue": [
                      b[28] || (b[28] = (Y) => o.value.anchorPoint.x = Y),
                      y
                    ],
                    precision: 1,
                    unit: "X"
                  }, null, 8, ["modelValue"]),
                  Ne(Ge(et), {
                    modelValue: o.value.anchorPoint.y,
                    "onUpdate:modelValue": [
                      b[29] || (b[29] = (Y) => o.value.anchorPoint.y = Y),
                      y
                    ],
                    precision: 1,
                    unit: "Y"
                  }, null, 8, ["modelValue"])
                ]),
                f("button", {
                  class: Ue(["keyframe-btn", { active: v("anchorPoint") }]),
                  onClick: b[30] || (b[30] = (Y) => g("anchorPoint"))
                }, "", 2)
              ]),
              f("div", {
                class: Ue(["property-row", { "has-driver": P("opacity") }])
              }, [
                u.value ? (re(), St(ac, {
                  key: 0,
                  layerId: u.value.id,
                  property: "opacity",
                  linkedTo: x("opacity"),
                  onLink: b[31] || (b[31] = (Y) => C("opacity", Y)),
                  onUnlink: b[32] || (b[32] = () => E("opacity"))
                }, null, 8, ["layerId", "linkedTo"])) : Pe("", !0),
                b[46] || (b[46] = f("label", null, "Opacity", -1)),
                f("div", zF, [
                  Ne(Ge(li), {
                    modelValue: o.value.opacity,
                    "onUpdate:modelValue": [
                      b[33] || (b[33] = (Y) => o.value.opacity = Y),
                      y
                    ],
                    min: 0,
                    max: 100,
                    unit: "%",
                    "data-pickwhip-target": "opacity",
                    "data-pickwhip-layer-id": (oe = u.value) == null ? void 0 : oe.id,
                    "data-pickwhip-label": "Opacity"
                  }, null, 8, ["modelValue", "data-pickwhip-layer-id"])
                ]),
                f("button", {
                  class: Ue(["keyframe-btn", { active: v("opacity") }]),
                  onClick: b[34] || (b[34] = (Y) => g("opacity"))
                }, "", 2)
              ], 2)
            ])) : Pe("", !0)
          ]),
          f("div", NF, [
            f("div", BF, [
              b[47] || (b[47] = f("label", null, "Blend Mode", -1)),
              ct(f("select", {
                "onUpdate:modelValue": b[35] || (b[35] = (Y) => a.value = Y),
                class: "blend-select",
                onChange: _
              }, [
                (re(), ae(Ze, null, at(c, (Y) => f("option", {
                  key: Y.value,
                  value: Y.value
                }, be(Y.label), 9, VF)), 64))
              ], 544), [
                [ti, a.value]
              ])
            ])
          ]),
          h.value ? (re(), St(Ng(h.value), {
            key: 0,
            layer: u.value,
            onUpdate: S
          }, null, 40, ["layer"])) : Pe("", !0),
          u.value ? (re(), St(hF, {
            key: 1,
            layerId: u.value.id
          }, null, 8, ["layerId"])) : Pe("", !0)
        ])) : (re(), ae("div", GF, [...b[48] || (b[48] = [
          f("p", null, "No layer selected", -1),
          f("p", { class: "hint" }, "Select a layer to edit its properties", -1)
        ])]))
      ]);
    };
  }
}), WF = /* @__PURE__ */ Bt(HF, [["__scopeId", "data-v-a5a9c7d6"]]), $F = { class: "camera-properties" }, XF = { class: "panel-header" }, jF = { class: "camera-name" }, YF = {
  key: 0,
  class: "properties-content"
}, qF = { class: "property-section" }, ZF = { class: "property-row" }, KF = ["value"], JF = { class: "property-section" }, QF = { class: "toggle-icon" }, eU = { class: "section-content" }, tU = { class: "property-group" }, nU = { class: "xyz-inputs" }, iU = {
  key: 0,
  class: "property-group"
}, sU = { class: "xyz-inputs" }, rU = { class: "property-group" }, oU = { class: "xyz-inputs" }, aU = { class: "property-group" }, lU = { class: "property-group" }, cU = { class: "property-group" }, uU = { class: "property-section" }, dU = { class: "toggle-icon" }, hU = { class: "section-content" }, fU = { class: "preset-row" }, pU = ["onClick"], mU = { class: "property-group" }, vU = { class: "property-group" }, gU = { class: "property-group" }, yU = { class: "property-group" }, _U = ["value"], xU = { class: "property-section" }, bU = { class: "toggle-icon" }, wU = { class: "section-content" }, SU = { class: "property-group checkbox-group" }, MU = ["checked"], CU = { class: "property-group" }, EU = { class: "property-group" }, TU = { class: "property-group" }, AU = { class: "property-group checkbox-group" }, PU = ["checked"], DU = { class: "property-section" }, RU = { class: "toggle-icon" }, IU = { class: "section-content" }, kU = { class: "property-group" }, LU = { class: "property-group" }, FU = { class: "property-group" }, UU = { class: "property-group" }, OU = { class: "property-group" }, zU = { class: "property-section" }, NU = { class: "toggle-icon" }, BU = { class: "section-content" }, VU = { class: "property-group" }, GU = { class: "property-group" }, HU = { class: "property-group" }, WU = { class: "property-section" }, $U = { class: "toggle-icon" }, XU = { class: "section-content" }, jU = { class: "property-group" }, YU = ["value"], qU = { class: "property-section" }, ZU = { class: "toggle-icon" }, KU = { class: "section-content" }, JU = { class: "property-group" }, QU = { class: "property-group" }, eO = {
  key: 1,
  class: "no-camera"
}, tO = /* @__PURE__ */ Ut({
  __name: "CameraProperties",
  setup(s) {
    const e = nn(), n = Oe(() => {
      const v = e.selectedLayer;
      if ((v == null ? void 0 : v.type) === "camera" && v.data) {
        const g = v.data;
        return e.getCamera(g.cameraId);
      }
      return e.activeCamera;
    }), i = Go({
      transform: !0,
      lens: !0,
      dof: !1,
      iris: !1,
      highlight: !1,
      autoOrient: !1,
      clipping: !1
    });
    function r(v) {
      i[v] = !i[v];
    }
    function o(v, g) {
      n.value && e.updateCamera(n.value.id, { [v]: g });
    }
    function a(v, g) {
      n.value && e.updateCamera(n.value.id, {
        position: { ...n.value.position, [v]: g }
      });
    }
    function l(v, g) {
      n.value && e.updateCamera(n.value.id, {
        pointOfInterest: { ...n.value.pointOfInterest, [v]: g }
      });
    }
    function c(v, g) {
      n.value && e.updateCamera(n.value.id, {
        orientation: { ...n.value.orientation, [v]: g }
      });
    }
    function u(v) {
      if (!n.value) return;
      const g = gl(v, n.value.filmSize);
      e.updateCamera(n.value.id, {
        focalLength: v,
        angleOfView: g
      });
    }
    function d(v) {
      if (!n.value) return;
      const g = L2(v, n.value.filmSize);
      e.updateCamera(n.value.id, {
        angleOfView: v,
        focalLength: g
      });
    }
    function h(v, g) {
      n.value && e.updateCamera(n.value.id, {
        depthOfField: { ...n.value.depthOfField, [v]: g }
      });
    }
    function m(v, g) {
      n.value && e.updateCamera(n.value.id, {
        iris: { ...n.value.iris, [v]: g }
      });
    }
    function p(v, g) {
      n.value && e.updateCamera(n.value.id, {
        highlight: { ...n.value.highlight, [v]: g }
      });
    }
    function y(v) {
      n.value && e.updateCamera(n.value.id, {
        focalLength: v.focalLength,
        angleOfView: v.angleOfView,
        zoom: v.zoom
      });
    }
    function _() {
      e.createCameraLayer();
    }
    return (v, g) => {
      var S;
      return re(), ae("div", $F, [
        f("div", XF, [
          g[38] || (g[38] = f("span", { class: "panel-title" }, "Camera", -1)),
          f("span", jF, be(((S = n.value) == null ? void 0 : S.name) ?? "No Camera"), 1)
        ]),
        n.value ? (re(), ae("div", YF, [
          f("div", qF, [
            g[40] || (g[40] = f("div", { class: "section-header" }, "Type", -1)),
            f("div", ZF, [
              f("select", {
                value: n.value.type,
                onChange: g[0] || (g[0] = (w) => o("type", w.target.value)),
                class: "type-select"
              }, [...g[39] || (g[39] = [
                f("option", { value: "one-node" }, "One-Node Camera", -1),
                f("option", { value: "two-node" }, "Two-Node Camera", -1)
              ])], 40, KF)
            ])
          ]),
          f("div", JF, [
            f("div", {
              class: "section-header",
              onClick: g[1] || (g[1] = (w) => r("transform"))
            }, [
              f("span", QF, be(i.transform ? "" : ""), 1),
              g[41] || (g[41] = ft(" Transform ", -1))
            ]),
            ct(f("div", eU, [
              f("div", tU, [
                g[42] || (g[42] = f("label", null, "Position", -1)),
                f("div", nU, [
                  Ne(Ge(et), {
                    modelValue: n.value.position.x,
                    "onUpdate:modelValue": g[2] || (g[2] = (w) => a("x", w)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(Ge(et), {
                    modelValue: n.value.position.y,
                    "onUpdate:modelValue": g[3] || (g[3] = (w) => a("y", w)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(Ge(et), {
                    modelValue: n.value.position.z,
                    "onUpdate:modelValue": g[4] || (g[4] = (w) => a("z", w)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              n.value.type === "two-node" ? (re(), ae("div", iU, [
                g[43] || (g[43] = f("label", null, "Point of Interest", -1)),
                f("div", sU, [
                  Ne(Ge(et), {
                    modelValue: n.value.pointOfInterest.x,
                    "onUpdate:modelValue": g[5] || (g[5] = (w) => l("x", w)),
                    label: "X",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(Ge(et), {
                    modelValue: n.value.pointOfInterest.y,
                    "onUpdate:modelValue": g[6] || (g[6] = (w) => l("y", w)),
                    label: "Y",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(Ge(et), {
                    modelValue: n.value.pointOfInterest.z,
                    "onUpdate:modelValue": g[7] || (g[7] = (w) => l("z", w)),
                    label: "Z",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ])) : Pe("", !0),
              f("div", rU, [
                g[44] || (g[44] = f("label", null, "Orientation", -1)),
                f("div", oU, [
                  Ne(Ge(et), {
                    modelValue: n.value.orientation.x,
                    "onUpdate:modelValue": g[8] || (g[8] = (w) => c("x", w)),
                    label: "X",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(Ge(et), {
                    modelValue: n.value.orientation.y,
                    "onUpdate:modelValue": g[9] || (g[9] = (w) => c("y", w)),
                    label: "Y",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"]),
                  Ne(Ge(et), {
                    modelValue: n.value.orientation.z,
                    "onUpdate:modelValue": g[10] || (g[10] = (w) => c("z", w)),
                    label: "Z",
                    unit: "",
                    precision: 1
                  }, null, 8, ["modelValue"])
                ])
              ]),
              f("div", aU, [
                g[45] || (g[45] = f("label", null, "X Rotation", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.xRotation,
                  "onUpdate:modelValue": g[11] || (g[11] = (w) => o("xRotation", w)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", lU, [
                g[46] || (g[46] = f("label", null, "Y Rotation", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.yRotation,
                  "onUpdate:modelValue": g[12] || (g[12] = (w) => o("yRotation", w)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", cU, [
                g[47] || (g[47] = f("label", null, "Z Rotation", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.zRotation,
                  "onUpdate:modelValue": g[13] || (g[13] = (w) => o("zRotation", w)),
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [lr, i.transform]
            ])
          ]),
          f("div", uU, [
            f("div", {
              class: "section-header",
              onClick: g[14] || (g[14] = (w) => r("lens"))
            }, [
              f("span", dU, be(i.lens ? "" : ""), 1),
              g[48] || (g[48] = ft(" Lens ", -1))
            ]),
            ct(f("div", hU, [
              f("div", fU, [
                (re(!0), ae(Ze, null, at(Ge(A2), (w) => (re(), ae("button", {
                  key: w.name,
                  class: Ue({ active: Math.abs(n.value.focalLength - w.focalLength) < 0.5 }),
                  onClick: (x) => y(w)
                }, be(w.name), 11, pU))), 128))
              ]),
              f("div", mU, [
                g[49] || (g[49] = f("label", null, "Focal Length", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.focalLength,
                  "onUpdate:modelValue": u,
                  min: 1,
                  max: 500,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", vU, [
                g[50] || (g[50] = f("label", null, "Angle of View", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.angleOfView,
                  "onUpdate:modelValue": d,
                  min: 1,
                  max: 170,
                  unit: "",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", gU, [
                g[51] || (g[51] = f("label", null, "Film Size", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.filmSize,
                  "onUpdate:modelValue": g[15] || (g[15] = (w) => o("filmSize", w)),
                  min: 1,
                  max: 100,
                  unit: "mm",
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", yU, [
                g[53] || (g[53] = f("label", null, "Measure Film Size", -1)),
                f("select", {
                  value: n.value.measureFilmSize,
                  onChange: g[16] || (g[16] = (w) => o("measureFilmSize", w.target.value))
                }, [...g[52] || (g[52] = [
                  f("option", { value: "horizontal" }, "Horizontal", -1),
                  f("option", { value: "vertical" }, "Vertical", -1),
                  f("option", { value: "diagonal" }, "Diagonal", -1)
                ])], 40, _U)
              ])
            ], 512), [
              [lr, i.lens]
            ])
          ]),
          f("div", xU, [
            f("div", {
              class: "section-header",
              onClick: g[17] || (g[17] = (w) => r("dof"))
            }, [
              f("span", bU, be(i.dof ? "" : ""), 1),
              g[54] || (g[54] = ft(" Depth of Field ", -1))
            ]),
            ct(f("div", wU, [
              f("div", SU, [
                f("label", null, [
                  f("input", {
                    type: "checkbox",
                    checked: n.value.depthOfField.enabled,
                    onChange: g[18] || (g[18] = (w) => h("enabled", w.target.checked))
                  }, null, 40, MU),
                  g[55] || (g[55] = ft(" Enable DOF ", -1))
                ])
              ]),
              n.value.depthOfField.enabled ? (re(), ae(Ze, { key: 0 }, [
                f("div", CU, [
                  g[56] || (g[56] = f("label", null, "Focus Distance", -1)),
                  Ne(Ge(et), {
                    modelValue: n.value.depthOfField.focusDistance,
                    "onUpdate:modelValue": g[19] || (g[19] = (w) => h("focusDistance", w)),
                    min: 1,
                    unit: "px",
                    precision: 0
                  }, null, 8, ["modelValue"])
                ]),
                f("div", EU, [
                  g[57] || (g[57] = f("label", null, "f-Stop", -1)),
                  Ne(Ge(et), {
                    modelValue: n.value.depthOfField.fStop,
                    "onUpdate:modelValue": g[20] || (g[20] = (w) => h("fStop", w)),
                    min: 0.1,
                    max: 64,
                    precision: 1
                  }, null, 8, ["modelValue"])
                ]),
                f("div", TU, [
                  g[58] || (g[58] = f("label", null, "Blur Level", -1)),
                  Ne(Ge(li), {
                    modelValue: n.value.depthOfField.blurLevel,
                    "onUpdate:modelValue": g[21] || (g[21] = (w) => h("blurLevel", w)),
                    min: 0,
                    max: 1,
                    step: 0.01
                  }, null, 8, ["modelValue"])
                ]),
                f("div", AU, [
                  f("label", null, [
                    f("input", {
                      type: "checkbox",
                      checked: n.value.depthOfField.lockToZoom,
                      onChange: g[22] || (g[22] = (w) => h("lockToZoom", w.target.checked))
                    }, null, 40, PU),
                    g[59] || (g[59] = ft(" Lock to Zoom ", -1))
                  ])
                ])
              ], 64)) : Pe("", !0)
            ], 512), [
              [lr, i.dof]
            ])
          ]),
          f("div", DU, [
            f("div", {
              class: "section-header",
              onClick: g[23] || (g[23] = (w) => r("iris"))
            }, [
              f("span", RU, be(i.iris ? "" : ""), 1),
              g[60] || (g[60] = ft(" Iris ", -1))
            ]),
            ct(f("div", IU, [
              f("div", kU, [
                f("label", null, "Shape (" + be(Math.round(n.value.iris.shape)) + "-gon)", 1),
                Ne(Ge(li), {
                  modelValue: n.value.iris.shape,
                  "onUpdate:modelValue": g[24] || (g[24] = (w) => m("shape", w)),
                  min: 3,
                  max: 10,
                  step: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", LU, [
                g[61] || (g[61] = f("label", null, "Rotation", -1)),
                Ne(Ge(Nf), {
                  modelValue: n.value.iris.rotation,
                  "onUpdate:modelValue": g[25] || (g[25] = (w) => m("rotation", w)),
                  size: 48
                }, null, 8, ["modelValue"])
              ]),
              f("div", FU, [
                g[62] || (g[62] = f("label", null, "Roundness", -1)),
                Ne(Ge(li), {
                  modelValue: n.value.iris.roundness,
                  "onUpdate:modelValue": g[26] || (g[26] = (w) => m("roundness", w)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", UU, [
                g[63] || (g[63] = f("label", null, "Aspect Ratio", -1)),
                Ne(Ge(li), {
                  modelValue: n.value.iris.aspectRatio,
                  "onUpdate:modelValue": g[27] || (g[27] = (w) => m("aspectRatio", w)),
                  min: 0.5,
                  max: 2,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", OU, [
                g[64] || (g[64] = f("label", null, "Diffraction Fringe", -1)),
                Ne(Ge(li), {
                  modelValue: n.value.iris.diffractionFringe,
                  "onUpdate:modelValue": g[28] || (g[28] = (w) => m("diffractionFringe", w)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [lr, i.iris]
            ])
          ]),
          f("div", zU, [
            f("div", {
              class: "section-header",
              onClick: g[29] || (g[29] = (w) => r("highlight"))
            }, [
              f("span", NU, be(i.highlight ? "" : ""), 1),
              g[65] || (g[65] = ft(" Highlight ", -1))
            ]),
            ct(f("div", BU, [
              f("div", VU, [
                g[66] || (g[66] = f("label", null, "Gain", -1)),
                Ne(Ge(li), {
                  modelValue: n.value.highlight.gain,
                  "onUpdate:modelValue": g[30] || (g[30] = (w) => p("gain", w)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", GU, [
                g[67] || (g[67] = f("label", null, "Threshold", -1)),
                Ne(Ge(li), {
                  modelValue: n.value.highlight.threshold,
                  "onUpdate:modelValue": g[31] || (g[31] = (w) => p("threshold", w)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ]),
              f("div", HU, [
                g[68] || (g[68] = f("label", null, "Saturation", -1)),
                Ne(Ge(li), {
                  modelValue: n.value.highlight.saturation,
                  "onUpdate:modelValue": g[32] || (g[32] = (w) => p("saturation", w)),
                  min: 0,
                  max: 1,
                  step: 0.01
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [lr, i.highlight]
            ])
          ]),
          f("div", WU, [
            f("div", {
              class: "section-header",
              onClick: g[33] || (g[33] = (w) => r("autoOrient"))
            }, [
              f("span", $U, be(i.autoOrient ? "" : ""), 1),
              g[69] || (g[69] = ft(" Auto-Orient ", -1))
            ]),
            ct(f("div", XU, [
              f("div", jU, [
                f("select", {
                  value: n.value.autoOrient,
                  onChange: g[34] || (g[34] = (w) => o("autoOrient", w.target.value))
                }, [...g[70] || (g[70] = [
                  f("option", { value: "off" }, "Off", -1),
                  f("option", { value: "orient-along-path" }, "Orient Along Path", -1),
                  f("option", { value: "orient-towards-poi" }, "Orient Towards Point of Interest", -1)
                ])], 40, YU)
              ])
            ], 512), [
              [lr, i.autoOrient]
            ])
          ]),
          f("div", qU, [
            f("div", {
              class: "section-header",
              onClick: g[35] || (g[35] = (w) => r("clipping"))
            }, [
              f("span", ZU, be(i.clipping ? "" : ""), 1),
              g[71] || (g[71] = ft(" Clipping ", -1))
            ]),
            ct(f("div", KU, [
              f("div", JU, [
                g[72] || (g[72] = f("label", null, "Near Clip", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.nearClip,
                  "onUpdate:modelValue": g[36] || (g[36] = (w) => o("nearClip", w)),
                  min: 0.1,
                  precision: 1
                }, null, 8, ["modelValue"])
              ]),
              f("div", QU, [
                g[73] || (g[73] = f("label", null, "Far Clip", -1)),
                Ne(Ge(et), {
                  modelValue: n.value.farClip,
                  "onUpdate:modelValue": g[37] || (g[37] = (w) => o("farClip", w)),
                  min: 100,
                  precision: 0
                }, null, 8, ["modelValue"])
              ])
            ], 512), [
              [lr, i.clipping]
            ])
          ])
        ])) : (re(), ae("div", eO, [
          g[74] || (g[74] = f("p", null, "No camera selected", -1)),
          f("button", { onClick: _ }, "Create Camera")
        ]))
      ]);
    };
  }
}), nO = /* @__PURE__ */ Bt(tO, [["__scopeId", "data-v-1a588e9b"]]), iO = { class: "audio-properties" }, sO = { class: "property-section" }, rO = {
  key: 0,
  class: "section-content"
}, oO = { class: "property-row" }, aO = { class: "value-display" }, lO = { class: "property-row" }, cO = { class: "value-display" }, uO = { class: "property-row" }, dO = { class: "value-display" }, hO = { class: "property-row" }, fO = {
  key: 0,
  class: "peak-count"
}, pO = { class: "property-section" }, mO = { class: "mapping-count" }, vO = {
  key: 0,
  class: "section-content"
}, gO = { class: "mapping-header" }, yO = { class: "mapping-enabled" }, _O = ["onUpdate:modelValue"], xO = { class: "mapping-name" }, bO = ["onClick"], wO = {
  key: 0,
  class: "mapping-details"
}, SO = { class: "property-row" }, MO = ["onUpdate:modelValue"], CO = ["value"], EO = { class: "property-row" }, TO = ["onUpdate:modelValue"], AO = ["label"], PO = ["value"], DO = { class: "property-row" }, RO = ["onUpdate:modelValue"], IO = { class: "value-display" }, kO = { class: "property-row" }, LO = ["onUpdate:modelValue"], FO = { class: "value-display" }, UO = { class: "property-row" }, OO = ["onUpdate:modelValue"], zO = { class: "value-display" }, NO = { class: "property-row" }, BO = ["onUpdate:modelValue"], VO = ["onUpdate:modelValue"], GO = { class: "property-row" }, HO = ["onUpdate:modelValue"], WO = ["onClick"], $O = { class: "property-section" }, XO = {
  key: 0,
  class: "section-content"
}, jO = { class: "property-row" }, YO = ["value"], qO = { class: "visualizer-canvas-container" }, ZO = { class: "visualizer-value" }, KO = /* @__PURE__ */ Ut({
  __name: "AudioProperties",
  setup(s) {
    const e = nn(), n = Se(/* @__PURE__ */ new Set(["peaks", "mappings"])), i = Se(/* @__PURE__ */ new Set()), r = Se({
      threshold: 0.3,
      minPeaksDistance: 10,
      multiply: 1
    }), o = Se(null), a = Se([]), l = Se("amplitude"), c = Se(null), u = Oe(() => Q2()), d = Oe(() => eT()), h = Oe(
      () => e.currentFrame / e.frameCount * 100
    ), m = Oe(() => e.audioAnalysis ? ll(e.audioAnalysis, l.value, e.currentFrame) : 0);
    function p(w) {
      n.value.has(w) ? n.value.delete(w) : n.value.add(w);
    }
    function y(w) {
      i.value.has(w) ? i.value.delete(w) : i.value.add(w);
    }
    function _() {
      if (!e.audioAnalysis) return;
      const w = e.audioAnalysis.amplitudeEnvelope;
      o.value = py(w, r.value), e.setPeakData(o.value);
    }
    function v() {
      const w = K2();
      a.value.push(w), i.value.add(w.id), e.addAudioMapping(w);
    }
    function g(w) {
      const x = a.value.findIndex((C) => C.id === w);
      x >= 0 && (a.value.splice(x, 1), i.value.delete(w), e.removeAudioMapping(w));
    }
    function S() {
      const w = c.value;
      if (!w || !e.audioAnalysis) return;
      const x = w.getContext("2d");
      if (!x) return;
      const C = w.width, E = w.height;
      x.fillStyle = "#1e1e1e", x.fillRect(0, 0, C, E);
      let P = [];
      const T = e.audioAnalysis;
      switch (l.value) {
        case "amplitude":
          P = T.amplitudeEnvelope;
          break;
        case "rms":
          P = T.rmsEnergy;
          break;
        case "spectralCentroid":
          P = T.spectralCentroid;
          break;
        case "bass":
          P = T.frequencyBands.bass;
          break;
        case "mid":
          P = T.frequencyBands.mid;
          break;
        case "high":
          P = T.frequencyBands.high;
          break;
        case "sub":
          P = T.frequencyBands.sub;
          break;
        case "lowMid":
          P = T.frequencyBands.lowMid;
          break;
        case "highMid":
          P = T.frequencyBands.highMid;
          break;
        case "onsets":
          P = new Array(T.frameCount).fill(0);
          for (const b of T.onsets)
            b < P.length && (P[b] = 1);
          break;
        case "peaks":
          if (o.value) {
            P = new Array(T.frameCount).fill(0);
            for (const b of o.value.indices)
              b < P.length && (P[b] = 1);
          }
          break;
      }
      if (P.length !== 0) {
        x.strokeStyle = "#4a90d9", x.lineWidth = 1.5, x.beginPath();
        for (let b = 0; b < P.length; b++) {
          const M = b / P.length * C, L = E - P[b] * E * 0.9 - 5;
          b === 0 ? x.moveTo(M, L) : x.lineTo(M, L);
        }
        if (x.stroke(), o.value && l.value !== "peaks") {
          x.fillStyle = "#ff6b6b";
          for (const b of o.value.indices) {
            const M = b / P.length * C;
            x.beginPath(), x.moveTo(M, 0), x.lineTo(M, E), x.strokeStyle = "rgba(255, 107, 107, 0.3)", x.stroke();
          }
        }
      }
    }
    return Ft(
      () => [e.audioAnalysis, l.value, o.value],
      () => {
        S();
      }
    ), Ft(
      a,
      (w) => {
        for (const x of w)
          e.updateAudioMapping(x.id, x);
      },
      { deep: !0 }
    ), _n(() => {
      S();
      const w = e.getAudioMappings();
      w.length > 0 && (a.value = [...w]);
    }), (w, x) => (re(), ae("div", iO, [
      f("div", sO, [
        f("div", {
          class: "section-header",
          onClick: x[0] || (x[0] = (C) => p("peaks"))
        }, [
          f("i", {
            class: Ue(["pi", n.value.has("peaks") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          x[7] || (x[7] = f("span", null, "Peak Detection", -1))
        ]),
        n.value.has("peaks") ? (re(), ae("div", rO, [
          f("div", oO, [
            x[8] || (x[8] = f("label", null, "Threshold", -1)),
            ct(f("input", {
              type: "range",
              "onUpdate:modelValue": x[1] || (x[1] = (C) => r.value.threshold = C),
              min: "0",
              max: "1",
              step: "0.01"
            }, null, 512), [
              [
                $t,
                r.value.threshold,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", aO, be(r.value.threshold.toFixed(2)), 1)
          ]),
          f("div", lO, [
            x[9] || (x[9] = f("label", null, "Min Peak Distance", -1)),
            ct(f("input", {
              type: "range",
              "onUpdate:modelValue": x[2] || (x[2] = (C) => r.value.minPeaksDistance = C),
              min: "1",
              max: "60",
              step: "1"
            }, null, 512), [
              [
                $t,
                r.value.minPeaksDistance,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", cO, be(r.value.minPeaksDistance) + " frames", 1)
          ]),
          f("div", uO, [
            x[10] || (x[10] = f("label", null, "Multiply", -1)),
            ct(f("input", {
              type: "range",
              "onUpdate:modelValue": x[3] || (x[3] = (C) => r.value.multiply = C),
              min: "0.1",
              max: "5",
              step: "0.1"
            }, null, 512), [
              [
                $t,
                r.value.multiply,
                void 0,
                { number: !0 }
              ]
            ]),
            f("span", dO, be(r.value.multiply.toFixed(1)) + "x", 1)
          ]),
          f("div", hO, [
            f("button", {
              class: "action-btn",
              onClick: _
            }, [...x[11] || (x[11] = [
              f("i", { class: "pi pi-bolt" }, null, -1),
              ft(" Detect Peaks ", -1)
            ])]),
            o.value ? (re(), ae("span", fO, be(o.value.count) + " peaks found ", 1)) : Pe("", !0)
          ])
        ])) : Pe("", !0)
      ]),
      f("div", pO, [
        f("div", {
          class: "section-header",
          onClick: x[4] || (x[4] = (C) => p("mappings"))
        }, [
          f("i", {
            class: Ue(["pi", n.value.has("mappings") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          x[12] || (x[12] = f("span", null, "Audio Mappings", -1)),
          f("span", mO, be(a.value.length), 1)
        ]),
        n.value.has("mappings") ? (re(), ae("div", vO, [
          f("button", {
            class: "action-btn add-mapping-btn",
            onClick: v
          }, [...x[13] || (x[13] = [
            f("i", { class: "pi pi-plus" }, null, -1),
            ft(" Add Mapping ", -1)
          ])]),
          (re(!0), ae(Ze, null, at(a.value, (C) => (re(), ae("div", {
            key: C.id,
            class: "mapping-item"
          }, [
            f("div", gO, [
              f("label", yO, [
                ct(f("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": (E) => C.enabled = E
                }, null, 8, _O), [
                  [Ci, C.enabled]
                ])
              ]),
              f("span", xO, be(Ge(Pd)(C.feature)) + "  " + be(Ge(cv)(C.target)), 1),
              f("button", {
                class: "delete-btn",
                onClick: (E) => g(C.id)
              }, [...x[14] || (x[14] = [
                f("i", { class: "pi pi-times" }, null, -1)
              ])], 8, bO)
            ]),
            i.value.has(C.id) ? (re(), ae("div", wO, [
              f("div", SO, [
                x[15] || (x[15] = f("label", null, "Feature", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": (E) => C.feature = E
                }, [
                  (re(!0), ae(Ze, null, at(u.value, (E) => (re(), ae("option", {
                    key: E,
                    value: E
                  }, be(Ge(Pd)(E)), 9, CO))), 128))
                ], 8, MO), [
                  [ti, C.feature]
                ])
              ]),
              f("div", EO, [
                x[16] || (x[16] = f("label", null, "Target", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": (E) => C.target = E
                }, [
                  (re(!0), ae(Ze, null, at(d.value, (E, P) => (re(), ae("optgroup", {
                    key: P,
                    label: P
                  }, [
                    (re(!0), ae(Ze, null, at(E, (T) => (re(), ae("option", {
                      key: T,
                      value: T
                    }, be(Ge(cv)(T)), 9, PO))), 128))
                  ], 8, AO))), 128))
                ], 8, TO), [
                  [ti, C.target]
                ])
              ]),
              f("div", DO, [
                x[17] || (x[17] = f("label", null, "Sensitivity", -1)),
                ct(f("input", {
                  type: "range",
                  "onUpdate:modelValue": (E) => C.sensitivity = E,
                  min: "0.1",
                  max: "5",
                  step: "0.1"
                }, null, 8, RO), [
                  [
                    $t,
                    C.sensitivity,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                f("span", IO, be(C.sensitivity.toFixed(1)) + "x", 1)
              ]),
              f("div", kO, [
                x[18] || (x[18] = f("label", null, "Threshold", -1)),
                ct(f("input", {
                  type: "range",
                  "onUpdate:modelValue": (E) => C.threshold = E,
                  min: "0",
                  max: "1",
                  step: "0.01"
                }, null, 8, LO), [
                  [
                    $t,
                    C.threshold,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                f("span", FO, be(C.threshold.toFixed(2)), 1)
              ]),
              f("div", UO, [
                x[19] || (x[19] = f("label", null, "Smoothing", -1)),
                ct(f("input", {
                  type: "range",
                  "onUpdate:modelValue": (E) => C.smoothing = E,
                  min: "0",
                  max: "0.99",
                  step: "0.01"
                }, null, 8, OO), [
                  [
                    $t,
                    C.smoothing,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                f("span", zO, be(C.smoothing.toFixed(2)), 1)
              ]),
              f("div", NO, [
                x[20] || (x[20] = f("label", null, "Min/Max", -1)),
                ct(f("input", {
                  type: "number",
                  "onUpdate:modelValue": (E) => C.min = E,
                  step: "0.1",
                  class: "small-input"
                }, null, 8, BO), [
                  [
                    $t,
                    C.min,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                x[21] || (x[21] = f("span", { class: "separator" }, "-", -1)),
                ct(f("input", {
                  type: "number",
                  "onUpdate:modelValue": (E) => C.max = E,
                  step: "0.1",
                  class: "small-input"
                }, null, 8, VO), [
                  [
                    $t,
                    C.max,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              f("div", GO, [
                f("label", null, [
                  ct(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": (E) => C.invert = E
                  }, null, 8, HO), [
                    [Ci, C.invert]
                  ]),
                  x[22] || (x[22] = ft(" Invert ", -1))
                ])
              ])
            ])) : Pe("", !0),
            f("button", {
              class: "expand-btn",
              onClick: (E) => y(C.id)
            }, [
              f("i", {
                class: Ue(["pi", i.value.has(C.id) ? "pi-chevron-up" : "pi-chevron-down"])
              }, null, 2)
            ], 8, WO)
          ]))), 128))
        ])) : Pe("", !0)
      ]),
      f("div", $O, [
        f("div", {
          class: "section-header",
          onClick: x[5] || (x[5] = (C) => p("visualizer"))
        }, [
          f("i", {
            class: Ue(["pi", n.value.has("visualizer") ? "pi-chevron-down" : "pi-chevron-right"])
          }, null, 2),
          x[23] || (x[23] = f("span", null, "Feature Visualizer", -1))
        ]),
        n.value.has("visualizer") ? (re(), ae("div", XO, [
          f("div", jO, [
            x[24] || (x[24] = f("label", null, "Feature", -1)),
            ct(f("select", {
              "onUpdate:modelValue": x[6] || (x[6] = (C) => l.value = C)
            }, [
              (re(!0), ae(Ze, null, at(u.value, (C) => (re(), ae("option", {
                key: C,
                value: C
              }, be(Ge(Pd)(C)), 9, YO))), 128))
            ], 512), [
              [ti, l.value]
            ])
          ]),
          f("div", qO, [
            f("canvas", {
              ref_key: "visualizerCanvas",
              ref: c,
              class: "visualizer-canvas",
              width: "240",
              height: "60"
            }, null, 512),
            f("div", {
              class: "visualizer-playhead",
              style: bt({ left: `${h.value}%` })
            }, null, 4)
          ]),
          f("div", ZO, " Current: " + be(m.value.toFixed(3)), 1)
        ])) : Pe("", !0)
      ])
    ]));
  }
}), JO = /* @__PURE__ */ Bt(KO, [["__scopeId", "data-v-f0f6c1bb"]]), QO = { class: "audio-panel" }, ez = {
  key: 0,
  class: "panel-content"
}, tz = { class: "audio-info" }, nz = { class: "file-info" }, iz = { class: "file-details" }, sz = { class: "file-name" }, rz = { class: "file-meta" }, oz = { class: "control-section" }, az = { class: "control-row" }, lz = { class: "waveform-section" }, cz = { class: "waveform-display" }, uz = { class: "linker-section" }, dz = {
  key: 1,
  class: "empty-state"
}, hz = /* @__PURE__ */ Ut({
  __name: "AudioPanel",
  setup(s) {
    const e = nn(), n = Se(null), i = Se(null), r = Se(100), o = Se(!1), a = Oe(() => !!e.audioBuffer), l = Oe(() => {
      var _;
      return ((_ = e.audioFile) == null ? void 0 : _.name) || "Unknown";
    }), c = Oe(() => e.audioBuffer ? `${(e.audioBuffer.sampleRate / 1e3).toFixed(1)} kHz` : ""), u = Oe(() => {
      if (!e.audioBuffer) return "0:00";
      const _ = Math.floor(e.audioBuffer.duration / 60), v = Math.floor(e.audioBuffer.duration % 60);
      return `${_}:${v.toString().padStart(2, "0")}`;
    });
    function d() {
      var _;
      (_ = n.value) == null || _.click();
    }
    async function h(_) {
      var g;
      const v = _.target;
      (g = v.files) != null && g.length && await e.loadAudio(v.files[0]), v.value = "";
    }
    function m() {
      e.clearAudio();
    }
    function p() {
      o.value = !o.value;
    }
    function y() {
      if (!i.value || !e.audioBuffer) return;
      const _ = i.value, v = _.getContext("2d");
      if (!v) return;
      const g = _.getBoundingClientRect();
      _.width = g.width * window.devicePixelRatio, _.height = 60 * window.devicePixelRatio, v.scale(window.devicePixelRatio, window.devicePixelRatio);
      const S = e.audioBuffer.getChannelData(0), w = Math.ceil(S.length / g.width), x = 30;
      v.fillStyle = "#1a1a1a", v.fillRect(0, 0, g.width, 60), v.beginPath(), v.strokeStyle = "#4a90d9", v.lineWidth = 1;
      for (let E = 0; E < g.width; E++) {
        let P = 1, T = -1;
        for (let b = 0; b < w; b++) {
          const M = S[E * w + b];
          M < P && (P = M), M > T && (T = M);
        }
        v.moveTo(E, (1 + P) * x), v.lineTo(E, (1 + T) * x);
      }
      v.stroke();
      const C = e.currentFrame / e.frameCount * g.width;
      v.fillStyle = "#fff", v.fillRect(C, 0, 1, 60);
    }
    return Ft(() => [e.audioBuffer, e.currentFrame], y), _n(() => {
      a.value && setTimeout(y, 100);
    }), (_, v) => (re(), ae("div", QO, [
      f("div", { class: "panel-header" }, [
        v[2] || (v[2] = f("span", { class: "panel-title" }, "Audio Source", -1)),
        f("div", { class: "header-actions" }, [
          f("button", {
            onClick: d,
            title: "Load Audio"
          }, [...v[1] || (v[1] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ])
      ]),
      a.value ? (re(), ae("div", ez, [
        f("div", tz, [
          f("div", nz, [
            v[3] || (v[3] = f("span", { class: "file-icon" }, "", -1)),
            f("div", iz, [
              f("span", sz, be(l.value), 1),
              f("span", rz, be(u.value) + "  " + be(c.value), 1)
            ]),
            f("button", {
              class: "remove-btn",
              onClick: m,
              title: "Remove Audio"
            }, "")
          ])
        ]),
        f("div", oz, [
          f("div", az, [
            v[4] || (v[4] = f("label", null, "Master Vol", -1)),
            Ne(Ge(li), {
              modelValue: r.value,
              "onUpdate:modelValue": v[0] || (v[0] = (g) => r.value = g),
              min: 0,
              max: 100,
              unit: "%"
            }, null, 8, ["modelValue"]),
            f("button", {
              class: Ue(["mute-btn", { active: o.value }]),
              onClick: p,
              title: "Mute"
            }, be(o.value ? "" : ""), 3)
          ])
        ]),
        f("div", lz, [
          v[5] || (v[5] = f("div", { class: "section-header" }, [
            f("span", { class: "section-title" }, "Waveform")
          ], -1)),
          f("div", cz, [
            f("canvas", {
              ref_key: "waveformCanvas",
              ref: i,
              class: "waveform-canvas"
            }, null, 512)
          ])
        ]),
        f("div", uz, [
          v[6] || (v[6] = f("div", { class: "linker-header" }, "Audio Linker", -1)),
          Ne(JO)
        ])
      ])) : (re(), ae("div", dz, [
        v[7] || (v[7] = f("div", { class: "empty-icon" }, "", -1)),
        v[8] || (v[8] = f("p", null, "No audio loaded", -1)),
        f("button", {
          class: "load-btn",
          onClick: d
        }, "Load Audio File"),
        v[9] || (v[9] = f("p", { class: "hint" }, "Supports MP3, WAV, OGG, AAC", -1))
      ])),
      f("input", {
        ref_key: "audioFileInput",
        ref: n,
        type: "file",
        accept: "audio/*",
        style: { display: "none" },
        onChange: h
      }, null, 544)
    ]));
  }
}), fz = /* @__PURE__ */ Bt(hz, [["__scopeId", "data-v-66384e06"]]), hv = 40, pz = 30;
function mz(s) {
  const e = [], n = "#ffcc00", i = s.position;
  let r;
  if (s.type === "two-node")
    r = Cs(zf(s.pointOfInterest, i));
  else {
    const p = s.orientation.x * Math.PI / 180, y = s.orientation.y * Math.PI / 180;
    r = xt(
      Math.sin(y) * Math.cos(p),
      -Math.sin(p),
      Math.cos(y) * Math.cos(p)
    );
  }
  const o = xt(0, -1, 0);
  let a = Cs(No(r, o));
  isNaN(a.x) && (a = xt(1, 0, 0));
  const l = Cs(No(a, r)), c = hv / 2, u = At(i, Rt(r, -hv)), d = [];
  for (let p = 0; p < 2; p++) {
    const y = p === 0 ? i : u;
    for (let _ = -1; _ <= 1; _ += 2)
      for (let v = -1; v <= 1; v += 2)
        d.push(At(
          At(y, Rt(a, _ * c)),
          Rt(l, v * c)
        ));
  }
  e.push({ start: d[0], end: d[1], color: n }), e.push({ start: d[1], end: d[3], color: n }), e.push({ start: d[3], end: d[2], color: n }), e.push({ start: d[2], end: d[0], color: n }), e.push({ start: d[4], end: d[5], color: n }), e.push({ start: d[5], end: d[7], color: n }), e.push({ start: d[7], end: d[6], color: n }), e.push({ start: d[6], end: d[4], color: n }), e.push({ start: d[0], end: d[4], color: n }), e.push({ start: d[1], end: d[5], color: n }), e.push({ start: d[2], end: d[6], color: n }), e.push({ start: d[3], end: d[7], color: n });
  const h = At(i, Rt(r, pz)), m = 8;
  for (let p = 0; p < m; p++) {
    const y = p / m * Math.PI * 2, _ = (p + 1) / m * Math.PI * 2, v = At(
      At(i, Rt(a, Math.cos(y) * c * 0.5)),
      Rt(l, Math.sin(y) * c * 0.5)
    ), g = At(
      At(i, Rt(a, Math.cos(_) * c * 0.5)),
      Rt(l, Math.sin(_) * c * 0.5)
    );
    e.push({ start: v, end: g, color: n }), e.push({ start: v, end: h, color: n });
  }
  return e;
}
function vz(s, e, n, i = 2e3) {
  const r = [], o = "#7c9cff", a = gl(s.focalLength, s.filmSize), l = e / n, c = s.position;
  let u;
  if (s.type === "two-node")
    u = Cs(zf(s.pointOfInterest, c));
  else {
    const P = s.orientation.x * Math.PI / 180, T = s.orientation.y * Math.PI / 180;
    u = xt(
      Math.sin(T) * Math.cos(P),
      -Math.sin(P),
      Math.cos(T) * Math.cos(P)
    );
  }
  const d = xt(0, -1, 0);
  let h = Cs(No(u, d));
  isNaN(h.x) && (h = xt(1, 0, 0));
  const m = Cs(No(h, u)), p = s.nearClip, y = Math.min(s.farClip, i), _ = p * Math.tan(a * Math.PI / 360), v = _ * l, g = y * Math.tan(a * Math.PI / 360), S = g * l, w = At(c, Rt(u, p)), x = [
    At(At(w, Rt(h, -v)), Rt(m, _)),
    At(At(w, Rt(h, v)), Rt(m, _)),
    At(At(w, Rt(h, v)), Rt(m, -_)),
    At(At(w, Rt(h, -v)), Rt(m, -_))
  ], C = At(c, Rt(u, y)), E = [
    At(At(C, Rt(h, -S)), Rt(m, g)),
    At(At(C, Rt(h, S)), Rt(m, g)),
    At(At(C, Rt(h, S)), Rt(m, -g)),
    At(At(C, Rt(h, -S)), Rt(m, -g))
  ];
  for (let P = 0; P < 4; P++)
    r.push({ start: x[P], end: x[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    r.push({ start: E[P], end: E[(P + 1) % 4], color: o });
  for (let P = 0; P < 4; P++)
    r.push({ start: x[P], end: E[P], color: o });
  return r;
}
function gz(s, e) {
  const n = "#00ff88", i = [
    xt(0, 0, 0),
    xt(s, 0, 0),
    xt(s, e, 0),
    xt(0, e, 0)
  ], r = [];
  for (let o = 0; o < 4; o++)
    r.push({ start: i[o], end: i[(o + 1) % 4], color: n });
  return r.push({ start: i[0], end: i[2], color: "#005533" }), r.push({ start: i[1], end: i[3], color: "#005533" }), r;
}
function yz(s) {
  return s.type !== "two-node" ? null : {
    start: s.position,
    end: s.pointOfInterest,
    color: "#ff6600"
    // Orange for POI connection
  };
}
function _z(s, e, n) {
  if (!s.depthOfField.enabled)
    return [];
  const i = "#ff00ff", r = [], o = s.position, a = s.depthOfField.focusDistance;
  let l;
  if (s.type === "two-node")
    l = Cs(zf(s.pointOfInterest, o));
  else {
    const _ = s.orientation.x * Math.PI / 180, v = s.orientation.y * Math.PI / 180;
    l = xt(
      Math.sin(v) * Math.cos(_),
      -Math.sin(_),
      Math.cos(v) * Math.cos(_)
    );
  }
  const c = xt(0, -1, 0);
  let u = Cs(No(l, c));
  isNaN(u.x) && (u = xt(1, 0, 0));
  const d = Cs(No(u, l)), h = At(o, Rt(l, a)), m = e / 4, p = n / 4, y = [
    At(At(h, Rt(u, -m)), Rt(d, p)),
    At(At(h, Rt(u, m)), Rt(d, p)),
    At(At(h, Rt(u, m)), Rt(d, -p)),
    At(At(h, Rt(u, -m)), Rt(d, -p))
  ];
  for (let _ = 0; _ < 4; _++)
    r.push({ start: y[_], end: y[(_ + 1) % 4], color: i });
  return r;
}
function fv(s, e, n, i = !0, r = !0, o = !1) {
  return {
    body: mz(s),
    frustum: i ? vz(s, e, n) : [],
    compositionBounds: r ? gz(e, n) : [],
    poiLine: yz(s),
    focalPlane: o ? _z(s, e, n) : [],
    motionPath: []
    // Populated separately from keyframes
  };
}
function xz(s, e, n) {
  const i = e / n, r = gl(s.focalLength, s.filmSize);
  let o;
  if (s.type === "two-node")
    o = s.pointOfInterest;
  else {
    const u = s.orientation.x * Math.PI / 180, d = s.orientation.y * Math.PI / 180, h = xt(
      Math.sin(d) * Math.cos(u),
      -Math.sin(u),
      Math.cos(d) * Math.cos(u)
    );
    o = At(s.position, Rt(h, 1e3));
  }
  const a = Zi(s.position, o, xt(0, -1, 0)), l = R2(r, i, s.nearClip, s.farClip), c = vy(l, a);
  return { view: a, projection: l, viewProjection: c };
}
function pv(s, e, n, i) {
  const r = e / n;
  let o, a = 1e3;
  const l = e / 2, c = n / 2;
  switch (s) {
    case "front":
      o = Zi(
        xt(l, c, -2e3),
        xt(l, c, 0),
        xt(0, -1, 0)
      );
      break;
    case "back":
      o = Zi(
        xt(l, c, 2e3),
        xt(l, c, 0),
        xt(0, -1, 0)
      );
      break;
    case "left":
      o = Zi(
        xt(-2e3, c, 0),
        xt(l, c, 0),
        xt(0, -1, 0)
      );
      break;
    case "right":
      o = Zi(
        xt(l + 2e3, c, 0),
        xt(l, c, 0),
        xt(0, -1, 0)
      );
      break;
    case "top":
      o = Zi(
        xt(l, -2e3, 0),
        xt(l, c, 0),
        xt(0, 0, 1)
      );
      break;
    case "bottom":
      o = Zi(
        xt(l, c + 2e3, 0),
        xt(l, c, 0),
        xt(0, 0, -1)
      );
      break;
    case "custom-1":
    case "custom-2":
    case "custom-3":
      if (i) {
        const h = i.orbitPhi * Math.PI / 180, m = i.orbitTheta * Math.PI / 180, p = i.orbitDistance, y = xt(
          i.orbitCenter.x + p * Math.sin(h) * Math.sin(m),
          i.orbitCenter.y + p * Math.cos(h),
          i.orbitCenter.z + p * Math.sin(h) * Math.cos(m)
        );
        o = Zi(
          y,
          i.orbitCenter,
          xt(0, -1, 0)
        ), a = 1e3 / i.orthoZoom;
      } else
        o = Zi(
          xt(l, c, -2e3),
          xt(l, c, 0),
          xt(0, -1, 0)
        );
      break;
    default:
      o = Zi(
        xt(l, c, -2e3),
        xt(l, c, 0),
        xt(0, -1, 0)
      );
  }
  const u = I2(
    -a * r,
    a * r,
    -a,
    a,
    1,
    1e4
  ), d = vy(u, o);
  return { view: o, projection: u, viewProjection: d };
}
function vy(s, e) {
  const n = s.elements, i = e.elements, r = new Float32Array(16);
  for (let o = 0; o < 4; o++)
    for (let a = 0; a < 4; a++) {
      let l = 0;
      for (let c = 0; c < 4; c++)
        l += n[o + c * 4] * i[c + a * 4];
      r[o + a * 4] = l;
    }
  return { elements: r };
}
function Dd(s, e, n, i) {
  const r = k2(e, s), o = e.elements, a = s.x * o[3] + s.y * o[7] + s.z * o[11] + o[15];
  if (a <= 0)
    return { x: 0, y: 0, z: r.z, visible: !1 };
  const l = (r.x / a * 0.5 + 0.5) * n, c = (-r.y / a * 0.5 + 0.5) * i;
  return {
    x: l,
    y: c,
    z: r.z / a,
    visible: !0
  };
}
function bz(s, e = 100) {
  return [
    { start: s, end: At(s, xt(e, 0, 0)), color: "#ff0000" },
    // X - Red
    { start: s, end: At(s, xt(0, e, 0)), color: "#00ff00" },
    // Y - Green
    { start: s, end: At(s, xt(0, 0, e)), color: "#0000ff" }
    // Z - Blue
  ];
}
function wz(s, e, n = 100) {
  const i = [], r = "#333333", o = "#444444", a = s / 2, l = e / 2, c = Math.max(s, e);
  for (let u = -c; u <= c + s; u += n) {
    const d = Math.abs(u - a) < n / 2;
    i.push({
      start: xt(u, -c, 0),
      end: xt(u, c + e, 0),
      color: d ? o : r
    });
  }
  for (let u = -c; u <= c + e; u += n) {
    const d = Math.abs(u - l) < n / 2;
    i.push({
      start: xt(-c, u, 0),
      end: xt(c + s, u, 0),
      color: d ? o : r
    });
  }
  return i;
}
const Sz = ["onClick"], Mz = { class: "view-header" }, Cz = ["value", "onChange"], Ez = { class: "view-tools" }, Tz = ["onClick"], Az = ["onMousedown", "onWheel"], Pz = { class: "view-info" }, Dz = { class: "view-name" }, Rz = {
  key: 0,
  class: "view-coords"
}, Iz = { class: "layout-controls" }, kz = ["onClick", "title"], Lz = /* @__PURE__ */ Ut({
  __name: "ViewportRenderer",
  setup(s) {
    const e = nn(), n = Oe(() => e.activeCamera), i = Oe(() => e.width), r = Oe(() => e.height), o = Oe(() => e.viewportState), a = Oe(() => e.viewOptions), l = Oe(() => e.layers.filter((le) => le.type !== "camera").map((le) => ({
      id: le.id,
      name: le.name,
      position: {
        x: le.transform.position.value.x,
        y: le.transform.position.value.y,
        z: 0
        // 2D layers at z=0
      },
      selected: e.selectedLayerIds.includes(le.id)
    }))), c = Se([null, null, null, null]), u = Se([null, null, null, null]), d = Se(!1), h = Se({ x: 0, y: 0 }), m = Se(0), p = Se(0), y = [
      { value: "1-view", label: "1 View", icon: "" },
      { value: "2-view-horizontal", label: "2 Views Horizontal", icon: "" },
      { value: "2-view-vertical", label: "2 Views Vertical", icon: "" },
      { value: "4-view", label: "4 Views", icon: "" }
    ], _ = Oe(() => o.value.layout), v = Oe(() => o.value.activeViewIndex), g = Oe(() => o.value.customViews), S = Oe(() => {
      switch (o.value.layout) {
        case "1-view":
          return [o.value.views[0]];
        case "2-view-horizontal":
        case "2-view-vertical":
          return o.value.views.slice(0, 2);
        case "4-view":
          return o.value.views.slice(0, 4);
        default:
          return [o.value.views[0]];
      }
    });
    function w(le, oe) {
      c.value[oe] = le, le && (u.value[oe] = le.getContext("2d"));
    }
    function x(le) {
      return le.startsWith("custom-");
    }
    function C(le) {
      return {
        "active-camera": "Camera",
        "custom-1": "Custom 1",
        "custom-2": "Custom 2",
        "custom-3": "Custom 3",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        top: "Top",
        bottom: "Bottom"
      }[le];
    }
    function E(le) {
      e.updateViewportState({
        activeViewIndex: le
      });
    }
    function P(le, oe) {
      const Y = [...o.value.views];
      Y[le] = oe, e.updateViewportState({
        views: Y
      });
    }
    function T(le) {
      const oe = ["active-camera", "top", "front", "right"];
      let Y = [...o.value.views];
      for (; Y.length < 4; )
        Y.push(oe[Y.length] || "front");
      e.updateViewportState({
        layout: le,
        views: Y,
        activeViewIndex: Math.min(o.value.activeViewIndex, b(le) - 1)
      });
    }
    function b(le) {
      switch (le) {
        case "1-view":
          return 1;
        case "2-view-horizontal":
        case "2-view-vertical":
          return 2;
        case "4-view":
          return 4;
        default:
          return 1;
      }
    }
    function M(le) {
      const oe = {
        orbitCenter: { x: i.value / 2, y: r.value / 2, z: 0 },
        orbitDistance: 2e3,
        orbitPhi: 60,
        orbitTheta: 45,
        orthoZoom: 1,
        orthoOffset: { x: 0, y: 0 }
      };
      e.updateViewportState({
        customViews: {
          ...o.value.customViews,
          [le]: oe
        }
      });
    }
    function L(le, oe) {
      d.value = !0, h.value = { x: le.clientX, y: le.clientY }, m.value = oe, p.value = le.button, document.addEventListener("mousemove", N), document.addEventListener("mouseup", D);
    }
    function N(le) {
      if (!d.value) return;
      const oe = le.clientX - h.value.x, Y = le.clientY - h.value.y;
      h.value = { x: le.clientX, y: le.clientY };
      const j = S.value[m.value];
      if (x(j)) {
        const q = g.value[j];
        if (p.value === 0) {
          const te = q.orbitTheta + oe * 0.5, ne = Math.max(1, Math.min(179, q.orbitPhi + Y * 0.5));
          e.updateViewportState({
            customViews: {
              ...o.value.customViews,
              [j]: {
                ...q,
                orbitTheta: te,
                orbitPhi: ne
              }
            }
          });
        } else (p.value === 1 || p.value === 2) && e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [j]: {
              ...q,
              orthoOffset: {
                x: q.orthoOffset.x + oe,
                y: q.orthoOffset.y + Y
              }
            }
          }
        });
      }
    }
    function D() {
      d.value = !1, document.removeEventListener("mousemove", N), document.removeEventListener("mouseup", D);
    }
    function O(le, oe) {
      le.preventDefault();
      const Y = S.value[oe];
      if (x(Y)) {
        const j = g.value[Y], q = le.deltaY > 0 ? 1.1 : 0.9;
        e.updateViewportState({
          customViews: {
            ...o.value.customViews,
            [Y]: {
              ...j,
              orbitDistance: j.orbitDistance * q
            }
          }
        });
      }
    }
    function A() {
      S.value.forEach((le, oe) => {
        const Y = c.value[oe], j = u.value[oe];
        if (!Y || !j) return;
        const q = Y.getBoundingClientRect(), te = window.devicePixelRatio || 1;
        Y.width = q.width * te, Y.height = q.height * te, j.scale(te, te), j.fillStyle = "#1a1a1a", j.fillRect(0, 0, q.width, q.height);
        let ne;
        le === "active-camera" && n.value ? ne = xz(n.value, i.value, r.value) : x(le) ? ne = pv(le, i.value, r.value, g.value[le]) : ne = pv(le, i.value, r.value);
        const de = [];
        if (a.value.showGrid && de.push(...wz(i.value, r.value)), a.value.show3DReferenceAxes && de.push(...bz(xt(i.value / 2, r.value / 2, 0))), a.value.showCompositionBounds) {
          const H = fv(
            n.value ?? G(),
            i.value,
            r.value,
            !1,
            !0,
            !1
          );
          de.push(...H.compositionBounds);
        }
        if (le !== "active-camera" && n.value && (a.value.cameraWireframes === "always" || a.value.cameraWireframes === "selected")) {
          const X = fv(
            n.value,
            i.value,
            r.value,
            !0,
            !1,
            a.value.showFocalPlane
          );
          de.push(...X.body), de.push(...X.frustum), de.push(...X.focalPlane), X.poiLine && de.push(X.poiLine);
        }
        for (const H of de) {
          const X = Dd(H.start, ne.viewProjection, q.width, q.height), V = Dd(H.end, ne.viewProjection, q.width, q.height);
          !X.visible && !V.visible || (j.beginPath(), j.strokeStyle = H.color, j.lineWidth = 1, j.moveTo(X.x, X.y), j.lineTo(V.x, V.y), j.stroke());
        }
        if (a.value.showLayerHandles)
          for (const H of l.value) {
            const X = Dd(H.position, ne.viewProjection, q.width, q.height);
            X.visible && (j.beginPath(), j.fillStyle = H.selected ? "#ffcc00" : "#888888", j.arc(X.x, X.y, H.selected ? 6 : 4, 0, Math.PI * 2), j.fill(), j.fillStyle = "#ffffff", j.font = "10px sans-serif", j.fillText(H.name, X.x + 8, X.y + 4));
          }
      });
    }
    function G() {
      return {
        id: "dummy",
        name: "Dummy",
        type: "two-node",
        position: { x: i.value / 2, y: r.value / 2, z: -1500 },
        pointOfInterest: { x: i.value / 2, y: r.value / 2, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1778,
        focalLength: 50,
        angleOfView: 39.6,
        filmSize: 36,
        measureFilmSize: "horizontal",
        depthOfField: {
          enabled: !1,
          focusDistance: 1500,
          aperture: 50,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off",
        nearClip: 1,
        farClip: 1e4
      };
    }
    let he;
    function ee() {
      A(), he = requestAnimationFrame(ee);
    }
    return _n(() => {
      ee();
    }), jn(() => {
      cancelAnimationFrame(he);
    }), Ft([n, o, a, l], () => {
    }, { deep: !0 }), (le, oe) => (re(), ae("div", {
      class: Ue(["viewport-renderer", [`layout-${_.value}`]])
    }, [
      (re(!0), ae(Ze, null, at(S.value, (Y, j) => {
        var q, te;
        return re(), ae("div", {
          key: j,
          class: Ue(["view-panel", { active: j === v.value }]),
          onClick: (ne) => E(j)
        }, [
          f("div", Mz, [
            f("select", {
              value: Y,
              onChange: (ne) => P(j, ne.target.value),
              class: "view-select"
            }, [...oe[1] || (oe[1] = [
              Or('<option value="active-camera" data-v-cdf0e094>Active Camera</option><option value="custom-1" data-v-cdf0e094>Custom View 1</option><option value="custom-2" data-v-cdf0e094>Custom View 2</option><option value="custom-3" data-v-cdf0e094>Custom View 3</option><option value="front" data-v-cdf0e094>Front</option><option value="back" data-v-cdf0e094>Back</option><option value="left" data-v-cdf0e094>Left</option><option value="right" data-v-cdf0e094>Right</option><option value="top" data-v-cdf0e094>Top</option><option value="bottom" data-v-cdf0e094>Bottom</option>', 10)
            ])], 40, Cz),
            f("div", Ez, [
              x(Y) ? (re(), ae("button", {
                key: 0,
                onClick: wt((ne) => M(Y), ["stop"]),
                title: "Reset View"
              }, [...oe[2] || (oe[2] = [
                f("span", { class: "icon" }, "", -1)
              ])], 8, Tz)) : Pe("", !0)
            ])
          ]),
          f("canvas", {
            ref_for: !0,
            ref: (ne) => w(ne, j),
            class: "view-canvas",
            onMousedown: (ne) => L(ne, j),
            onWheel: (ne) => O(ne, j),
            onContextmenu: oe[0] || (oe[0] = wt(() => {
            }, ["prevent"]))
          }, null, 40, Az),
          f("div", Pz, [
            f("span", Dz, be(C(Y)), 1),
            x(Y) ? (re(), ae("span", Rz, " : " + be(Math.round(((q = g.value[Y]) == null ? void 0 : q.orbitTheta) ?? 0)) + " : " + be(Math.round(((te = g.value[Y]) == null ? void 0 : te.orbitPhi) ?? 0)) + " ", 1)) : Pe("", !0)
          ])
        ], 10, Sz);
      }), 128)),
      f("div", Iz, [
        (re(), ae(Ze, null, at(y, (Y) => f("button", {
          key: Y.value,
          class: Ue({ active: _.value === Y.value }),
          onClick: (j) => T(Y.value),
          title: Y.label
        }, be(Y.icon), 11, kz)), 64))
      ])
    ], 2));
  }
}), Fz = /* @__PURE__ */ Bt(Lz, [["__scopeId", "data-v-cdf0e094"]]), gr = new Of(), Vn = new ce(), Gs = new ce(), rn = new Qn(), mv = {
  X: new ce(1, 0, 0),
  Y: new ce(0, 1, 0),
  Z: new ce(0, 0, 1)
}, Rd = { type: "change" }, vv = { type: "mouseDown", mode: null }, gv = { type: "mouseUp", mode: null }, yv = { type: "objectChange" };
class Uz extends h2 {
  constructor(e, n = null) {
    super(void 0, n);
    const i = new Gz(this);
    this._root = i;
    const r = new Hz();
    this._gizmo = r, i.add(r);
    const o = new Wz();
    this._plane = o, i.add(o);
    const a = this;
    function l(w, x) {
      let C = x;
      Object.defineProperty(a, w, {
        get: function() {
          return C !== void 0 ? C : x;
        },
        set: function(E) {
          C !== E && (C = E, o[w] = E, r[w] = E, a.dispatchEvent({ type: w + "-changed", value: E }), a.dispatchEvent(Rd));
        }
      }), a[w] = x, o[w] = x, r[w] = x;
    }
    l("camera", e), l("object", void 0), l("enabled", !0), l("axis", null), l("mode", "translate"), l("translationSnap", null), l("rotationSnap", null), l("scaleSnap", null), l("space", "world"), l("size", 1), l("dragging", !1), l("showX", !0), l("showY", !0), l("showZ", !0), l("minX", -1 / 0), l("maxX", 1 / 0), l("minY", -1 / 0), l("maxY", 1 / 0), l("minZ", -1 / 0), l("maxZ", 1 / 0);
    const c = new ce(), u = new ce(), d = new Qn(), h = new Qn(), m = new ce(), p = new Qn(), y = new ce(), _ = new ce(), v = new ce(), g = 0, S = new ce();
    l("worldPosition", c), l("worldPositionStart", u), l("worldQuaternion", d), l("worldQuaternionStart", h), l("cameraPosition", m), l("cameraQuaternion", p), l("pointStart", y), l("pointEnd", _), l("rotationAxis", v), l("rotationAngle", g), l("eye", S), this._offset = new ce(), this._startNorm = new ce(), this._endNorm = new ce(), this._cameraScale = new ce(), this._parentPosition = new ce(), this._parentQuaternion = new Qn(), this._parentQuaternionInv = new Qn(), this._parentScale = new ce(), this._worldScaleStart = new ce(), this._worldQuaternionInv = new Qn(), this._worldScale = new ce(), this._positionStart = new ce(), this._quaternionStart = new Qn(), this._scaleStart = new ce(), this._getPointer = Oz.bind(this), this._onPointerDown = Nz.bind(this), this._onPointerHover = zz.bind(this), this._onPointerMove = Bz.bind(this), this._onPointerUp = Vz.bind(this), n !== null && this.connect();
  }
  connect() {
    this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && gr.setFromCamera(e, this.camera);
    const n = Id(this._gizmo.picker[this.mode], gr);
    n ? this.axis = n.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && gr.setFromCamera(e, this.camera);
      const n = Id(this._plane, gr, !0);
      n && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(n.point).sub(this.worldPositionStart)), this.dragging = !0, vv.mode = this.mode, this.dispatchEvent(vv);
    }
  }
  pointerMove(e) {
    const n = this.axis, i = this.mode, r = this.object;
    let o = this.space;
    if (i === "scale" ? o = "local" : (n === "E" || n === "XYZE" || n === "XYZ") && (o = "world"), r === void 0 || n === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && gr.setFromCamera(e, this.camera);
    const a = Id(this._plane, gr, !0);
    if (a) {
      if (this.pointEnd.copy(a.point).sub(this.worldPositionStart), i === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && n !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), n.indexOf("X") === -1 && (this._offset.x = 0), n.indexOf("Y") === -1 && (this._offset.y = 0), n.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && n !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), r.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (r.position.applyQuaternion(rn.copy(this._quaternionStart).invert()), n.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.position.applyQuaternion(this._quaternionStart)), o === "world" && (r.parent && r.position.add(Vn.setFromMatrixPosition(r.parent.matrixWorld)), n.search("X") !== -1 && (r.position.x = Math.round(r.position.x / this.translationSnap) * this.translationSnap), n.search("Y") !== -1 && (r.position.y = Math.round(r.position.y / this.translationSnap) * this.translationSnap), n.search("Z") !== -1 && (r.position.z = Math.round(r.position.z / this.translationSnap) * this.translationSnap), r.parent && r.position.sub(Vn.setFromMatrixPosition(r.parent.matrixWorld)))), r.position.x = Math.max(this.minX, Math.min(this.maxX, r.position.x)), r.position.y = Math.max(this.minY, Math.min(this.maxY, r.position.y)), r.position.z = Math.max(this.minZ, Math.min(this.maxZ, r.position.z));
      else if (i === "scale") {
        if (n.search("XYZ") !== -1) {
          let l = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (l *= -1), Gs.set(l, l, l);
        } else
          Vn.copy(this.pointStart), Gs.copy(this.pointEnd), Vn.applyQuaternion(this._worldQuaternionInv), Gs.applyQuaternion(this._worldQuaternionInv), Gs.divide(Vn), n.search("X") === -1 && (Gs.x = 1), n.search("Y") === -1 && (Gs.y = 1), n.search("Z") === -1 && (Gs.z = 1);
        r.scale.copy(this._scaleStart).multiply(Gs), this.scaleSnap && (n.search("X") !== -1 && (r.scale.x = Math.round(r.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Y") !== -1 && (r.scale.y = Math.round(r.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), n.search("Z") !== -1 && (r.scale.z = Math.round(r.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (i === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const l = 20 / this.worldPosition.distanceTo(Vn.setFromMatrixPosition(this.camera.matrixWorld));
        let c = !1;
        n === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Vn.copy(this.rotationAxis).cross(this.eye)) * l) : (n === "X" || n === "Y" || n === "Z") && (this.rotationAxis.copy(mv[n]), Vn.copy(mv[n]), o === "local" && Vn.applyQuaternion(this.worldQuaternion), Vn.cross(this.eye), Vn.length() === 0 ? c = !0 : this.rotationAngle = this._offset.dot(Vn.normalize()) * l), (n === "E" || c) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && n !== "E" && n !== "XYZE" ? (r.quaternion.copy(this._quaternionStart), r.quaternion.multiply(rn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), r.quaternion.copy(rn.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), r.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Rd), this.dispatchEvent(yv);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (gv.mode = this.mode, this.dispatchEvent(gv)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  // Set current object
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  // Detach from object
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(Rd), this.dispatchEvent(yv), this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return gr;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
}
function Oz(s) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: s.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (s.clientX - e.left) / e.width * 2 - 1,
      y: -(s.clientY - e.top) / e.height * 2 + 1,
      button: s.button
    };
  }
}
function zz(s) {
  if (this.enabled)
    switch (s.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(s));
        break;
    }
}
function Nz(s) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(s.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(s)), this.pointerDown(this._getPointer(s)));
}
function Bz(s) {
  this.enabled && this.pointerMove(this._getPointer(s));
}
function Vz(s) {
  this.enabled && (this.domElement.releasePointerCapture(s.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(s)));
}
function Id(s, e, n) {
  const i = e.intersectObject(s, !0);
  for (let r = 0; r < i.length; r++)
    if (i[r].object.visible || n)
      return i[r];
  return !1;
}
const lc = new wi(), Jt = new ce(0, 1, 0), _v = new ce(0, 0, 0), xv = new Zt(), cc = new Qn(), Pc = new Qn(), qi = new ce(), bv = new Zt(), Ma = new ce(1, 0, 0), Mr = new ce(0, 1, 0), Ca = new ce(0, 0, 1), uc = new ce(), ha = new ce(), fa = new ce();
class Gz extends ln {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const n = this.controls;
    n.object !== void 0 && (n.object.updateMatrixWorld(), n.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : n.object.parent.matrixWorld.decompose(n._parentPosition, n._parentQuaternion, n._parentScale), n.object.matrixWorld.decompose(n.worldPosition, n.worldQuaternion, n._worldScale), n._parentQuaternionInv.copy(n._parentQuaternion).invert(), n._worldQuaternionInv.copy(n.worldQuaternion).invert()), n.camera.updateMatrixWorld(), n.camera.matrixWorld.decompose(n.cameraPosition, n.cameraQuaternion, n._cameraScale), n.camera.isOrthographicCamera ? n.camera.getWorldDirection(n.eye).negate() : n.eye.copy(n.cameraPosition).sub(n.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  dispose() {
    this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
}
class Hz extends ln {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Mn({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = new Wi({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), i = e.clone();
    i.opacity = 0.15;
    const r = n.clone();
    r.opacity = 0.5;
    const o = e.clone();
    o.color.setHex(16711680);
    const a = e.clone();
    a.color.setHex(65280);
    const l = e.clone();
    l.color.setHex(255);
    const c = e.clone();
    c.color.setHex(16711680), c.opacity = 0.5;
    const u = e.clone();
    u.color.setHex(65280), u.opacity = 0.5;
    const d = e.clone();
    d.color.setHex(255), d.opacity = 0.5;
    const h = e.clone();
    h.opacity = 0.25;
    const m = e.clone();
    m.color.setHex(16776960), m.opacity = 0.25, e.clone().color.setHex(16776960);
    const y = e.clone();
    y.color.setHex(7895160);
    const _ = new Rn(0, 0.04, 0.1, 12);
    _.translate(0, 0.05, 0);
    const v = new hn(0.08, 0.08, 0.08);
    v.translate(0, 0.04, 0);
    const g = new Nt();
    g.setAttribute("position", new Pt([0, 0, 0, 1, 0, 0], 3));
    const S = new Rn(75e-4, 75e-4, 0.5, 3);
    S.translate(0, 0.25, 0);
    function w(A, G) {
      const he = new Tr(A, 75e-4, 3, 64, G * Math.PI * 2);
      return he.rotateY(Math.PI / 2), he.rotateX(Math.PI / 2), he;
    }
    function x() {
      const A = new Nt();
      return A.setAttribute("position", new Pt([0, 0, 0, 1, 1, 1], 3)), A;
    }
    const C = {
      X: [
        [new qe(_, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new qe(_, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new qe(S, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new qe(_, a), [0, 0.5, 0]],
        [new qe(_, a), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new qe(S, a)]
      ],
      Z: [
        [new qe(_, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new qe(_, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new qe(S, l), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new qe(new _o(0.1, 0), h.clone()), [0, 0, 0]]
      ],
      XY: [
        [new qe(new hn(0.15, 0.15, 0.01), d.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new qe(new hn(0.15, 0.15, 0.01), c.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new qe(new hn(0.15, 0.15, 0.01), u.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, E = {
      X: [
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new qe(new _o(0.2, 0), i)]
      ],
      XY: [
        [new qe(new hn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new qe(new hn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new qe(new hn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, P = {
      START: [
        [new qe(new _o(0.01, 2), r), null, null, null, "helper"]
      ],
      END: [
        [new qe(new _o(0.01, 2), r), null, null, null, "helper"]
      ],
      DELTA: [
        [new an(x(), r), null, null, null, "helper"]
      ],
      X: [
        [new an(g, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new an(g, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new an(g, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, T = {
      XYZE: [
        [new qe(w(0.5, 1), y), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new qe(w(0.5, 0.5), o)]
      ],
      Y: [
        [new qe(w(0.5, 0.5), a), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new qe(w(0.5, 0.5), l), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new qe(w(0.75, 1), m), null, [0, Math.PI / 2, 0]]
      ]
    }, b = {
      AXIS: [
        [new an(g, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, M = {
      XYZE: [
        [new qe(new _u(0.25, 10, 8), i)]
      ],
      X: [
        [new qe(new Tr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new qe(new Tr(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new qe(new Tr(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new qe(new Tr(0.75, 0.1, 2, 24), i)]
      ]
    }, L = {
      X: [
        [new qe(v, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new qe(S, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new qe(v, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new qe(v, a), [0, 0.5, 0]],
        [new qe(S, a)],
        [new qe(v, a), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new qe(v, l), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new qe(S, l), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new qe(v, l), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new qe(new hn(0.15, 0.15, 0.01), d), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new qe(new hn(0.15, 0.15, 0.01), c), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new qe(new hn(0.15, 0.15, 0.01), u), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new qe(new hn(0.1, 0.1, 0.1), h.clone())]
      ]
    }, N = {
      X: [
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new qe(new Rn(0.2, 0, 0.6, 4), i), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new qe(new hn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new qe(new hn(0.2, 0.2, 0.01), i), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new qe(new hn(0.2, 0.2, 0.01), i), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new qe(new hn(0.2, 0.2, 0.2), i), [0, 0, 0]]
      ]
    }, D = {
      X: [
        [new an(g, r.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new an(g, r.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new an(g, r.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function O(A) {
      const G = new ln();
      for (const he in A)
        for (let ee = A[he].length; ee--; ) {
          const le = A[he][ee][0].clone(), oe = A[he][ee][1], Y = A[he][ee][2], j = A[he][ee][3], q = A[he][ee][4];
          le.name = he, le.tag = q, oe && le.position.set(oe[0], oe[1], oe[2]), Y && le.rotation.set(Y[0], Y[1], Y[2]), j && le.scale.set(j[0], j[1], j[2]), le.updateMatrix();
          const te = le.geometry.clone();
          te.applyMatrix4(le.matrix), le.geometry = te, le.renderOrder = 1 / 0, le.position.set(0, 0, 0), le.rotation.set(0, 0, 0), le.scale.set(1, 1, 1), G.add(le);
        }
      return G;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = O(C)), this.add(this.gizmo.rotate = O(T)), this.add(this.gizmo.scale = O(L)), this.add(this.picker.translate = O(E)), this.add(this.picker.rotate = O(M)), this.add(this.picker.scale = O(N)), this.add(this.helper.translate = O(P)), this.add(this.helper.rotate = O(b)), this.add(this.helper.scale = O(D)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const i = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : Pc;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let r = [];
    r = r.concat(this.picker[this.mode].children), r = r.concat(this.gizmo[this.mode].children), r = r.concat(this.helper[this.mode].children);
    for (let o = 0; o < r.length; o++) {
      const a = r[o];
      a.visible = !0, a.rotation.set(0, 0, 0), a.position.copy(this.worldPosition);
      let l;
      if (this.camera.isOrthographicCamera ? l = (this.camera.top - this.camera.bottom) / this.camera.zoom : l = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), a.scale.set(1, 1, 1).multiplyScalar(l * this.size / 4), a.tag === "helper") {
        a.visible = !1, a.name === "AXIS" ? (a.visible = !!this.axis, this.axis === "X" && (rn.setFromEuler(lc.set(0, 0, 0)), a.quaternion.copy(i).multiply(rn), Math.abs(Jt.copy(Ma).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Y" && (rn.setFromEuler(lc.set(0, 0, Math.PI / 2)), a.quaternion.copy(i).multiply(rn), Math.abs(Jt.copy(Mr).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "Z" && (rn.setFromEuler(lc.set(0, Math.PI / 2, 0)), a.quaternion.copy(i).multiply(rn), Math.abs(Jt.copy(Ca).applyQuaternion(i).dot(this.eye)) > 0.9 && (a.visible = !1)), this.axis === "XYZE" && (rn.setFromEuler(lc.set(0, Math.PI / 2, 0)), Jt.copy(this.rotationAxis), a.quaternion.setFromRotationMatrix(xv.lookAt(_v, Jt, Mr)), a.quaternion.multiply(rn), a.visible = this.dragging), this.axis === "E" && (a.visible = !1)) : a.name === "START" ? (a.position.copy(this.worldPositionStart), a.visible = this.dragging) : a.name === "END" ? (a.position.copy(this.worldPosition), a.visible = this.dragging) : a.name === "DELTA" ? (a.position.copy(this.worldPositionStart), a.quaternion.copy(this.worldQuaternionStart), Vn.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Vn.applyQuaternion(this.worldQuaternionStart.clone().invert()), a.scale.copy(Vn), a.visible = this.dragging) : (a.quaternion.copy(i), this.dragging ? a.position.copy(this.worldPositionStart) : a.position.copy(this.worldPosition), this.axis && (a.visible = this.axis.search(a.name) !== -1));
        continue;
      }
      a.quaternion.copy(i), this.mode === "translate" || this.mode === "scale" ? (a.name === "X" && Math.abs(Jt.copy(Ma).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Y" && Math.abs(Jt.copy(Mr).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "Z" && Math.abs(Jt.copy(Ca).applyQuaternion(i).dot(this.eye)) > 0.99 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XY" && Math.abs(Jt.copy(Ca).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "YZ" && Math.abs(Jt.copy(Ma).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1), a.name === "XZ" && Math.abs(Jt.copy(Mr).applyQuaternion(i).dot(this.eye)) < 0.2 && (a.scale.set(1e-10, 1e-10, 1e-10), a.visible = !1)) : this.mode === "rotate" && (cc.copy(i), Jt.copy(this.eye).applyQuaternion(rn.copy(i).invert()), a.name.search("E") !== -1 && a.quaternion.setFromRotationMatrix(xv.lookAt(this.eye, _v, Mr)), a.name === "X" && (rn.setFromAxisAngle(Ma, Math.atan2(-Jt.y, Jt.z)), rn.multiplyQuaternions(cc, rn), a.quaternion.copy(rn)), a.name === "Y" && (rn.setFromAxisAngle(Mr, Math.atan2(Jt.x, Jt.z)), rn.multiplyQuaternions(cc, rn), a.quaternion.copy(rn)), a.name === "Z" && (rn.setFromAxisAngle(Ca, Math.atan2(Jt.y, Jt.x)), rn.multiplyQuaternions(cc, rn), a.quaternion.copy(rn))), a.visible = a.visible && (a.name.indexOf("X") === -1 || this.showX), a.visible = a.visible && (a.name.indexOf("Y") === -1 || this.showY), a.visible = a.visible && (a.name.indexOf("Z") === -1 || this.showZ), a.visible = a.visible && (a.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), a.material._color = a.material._color || a.material.color.clone(), a.material._opacity = a.material._opacity || a.material.opacity, a.material.color.copy(a.material._color), a.material.opacity = a.material._opacity, this.enabled && this.axis && (a.name === this.axis || this.axis.split("").some(function(c) {
        return a.name === c;
      })) && (a.material.color.setHex(16776960), a.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class Wz extends qe {
  constructor() {
    super(
      new cn(1e5, 1e5, 2, 2),
      new Mn({ visible: !1, wireframe: !0, side: mn, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let n = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (n = "local"), uc.copy(Ma).applyQuaternion(n === "local" ? this.worldQuaternion : Pc), ha.copy(Mr).applyQuaternion(n === "local" ? this.worldQuaternion : Pc), fa.copy(Ca).applyQuaternion(n === "local" ? this.worldQuaternion : Pc), Jt.copy(ha), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Jt.copy(this.eye).cross(uc), qi.copy(uc).cross(Jt);
            break;
          case "Y":
            Jt.copy(this.eye).cross(ha), qi.copy(ha).cross(Jt);
            break;
          case "Z":
            Jt.copy(this.eye).cross(fa), qi.copy(fa).cross(Jt);
            break;
          case "XY":
            qi.copy(fa);
            break;
          case "YZ":
            qi.copy(uc);
            break;
          case "XZ":
            Jt.copy(fa), qi.copy(ha);
            break;
          case "XYZ":
          case "E":
            qi.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        qi.set(0, 0, 0);
    }
    qi.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (bv.lookAt(Vn.set(0, 0, 0), qi, Jt), this.quaternion.setFromRotationMatrix(bv)), super.updateMatrixWorld(e);
  }
}
class $z {
  constructor(e = null) {
    /** The main Three.js scene */
    pe(this, "scene");
    /** Group for composition layers (rendered content) */
    pe(this, "compositionGroup");
    /** Group for UI overlay elements */
    pe(this, "overlayGroup");
    /** Group for debug helpers */
    pe(this, "debugGroup");
    /** Composition bounds frame */
    pe(this, "compositionBounds", null);
    /** Composition dimensions */
    pe(this, "compositionWidth", 1920);
    pe(this, "compositionHeight", 1080);
    this.scene = new _E(), this.scene.name = "WeylScene", e ? this.scene.background = new Mt(e) : this.scene.background = null, this.compositionGroup = new Ei(), this.compositionGroup.name = "composition", this.scene.add(this.compositionGroup), this.overlayGroup = new Ei(), this.overlayGroup.name = "overlay", this.overlayGroup.renderOrder = 1e3, this.scene.add(this.overlayGroup), this.debugGroup = new Ei(), this.debugGroup.name = "debug", this.debugGroup.visible = !1, this.scene.add(this.debugGroup), this.setupDefaultLighting();
  }
  /**
   * Set up default ambient and directional lighting
   */
  setupDefaultLighting() {
    const e = new ay(16777215, 0.6);
    e.name = "ambientLight", this.scene.add(e);
    const n = new xo(16777215, 0.8);
    n.name = "keyLight", n.position.set(1e3, -1e3, 2e3), n.castShadow = !0, n.shadow.mapSize.width = 2048, n.shadow.mapSize.height = 2048, this.scene.add(n);
    const i = new xo(16777215, 0.3);
    i.name = "fillLight", i.position.set(-500, 500, 1e3), this.scene.add(i);
  }
  // ============================================================================
  // COMPOSITION MANAGEMENT
  // ============================================================================
  /**
   * Add object to composition group
   */
  addToComposition(e) {
    this.compositionGroup.add(e), this.sortByZ();
  }
  /**
   * Remove object from composition group
   */
  removeFromComposition(e) {
    this.compositionGroup.remove(e);
  }
  /**
   * Sort composition layers by Z position for proper depth ordering
   */
  sortByZ() {
    this.compositionGroup.children.sort((e, n) => (e.position.z || 0) - (n.position.z || 0));
  }
  /**
   * Get all composition layer objects
   */
  getCompositionObjects() {
    return [...this.compositionGroup.children];
  }
  // ============================================================================
  // OVERLAY MANAGEMENT
  // ============================================================================
  /**
   * Add object to overlay group
   */
  addToOverlay(e) {
    this.overlayGroup.add(e);
  }
  /**
   * Remove object from overlay group
   */
  removeFromOverlay(e) {
    this.overlayGroup.remove(e);
  }
  /**
   * Clear all overlay objects
   */
  clearOverlay() {
    for (; this.overlayGroup.children.length > 0; ) {
      const e = this.overlayGroup.children[0];
      this.overlayGroup.remove(e), this.disposeObject(e);
    }
  }
  /**
   * Add a UI element directly to the scene (for transform controls, etc.)
   * UI elements are added to the scene root so they're always visible
   */
  addUIElement(e) {
    this.scene.add(e);
  }
  /**
   * Remove a UI element from the scene
   */
  removeUIElement(e) {
    this.scene.remove(e);
  }
  // ============================================================================
  // DEBUG HELPERS
  // ============================================================================
  /**
   * Toggle debug helpers visibility
   */
  setDebugVisible(e) {
    this.debugGroup.visible = e;
  }
  /**
   * Add axis helper to debug group
   */
  addAxisHelper(e = 500) {
    const n = this.debugGroup.getObjectByName("axisHelper");
    n && this.debugGroup.remove(n);
    const i = new d2(e);
    i.name = "axisHelper", this.debugGroup.add(i);
  }
  /**
   * Add grid helper to debug group
   */
  addGridHelper(e = 2e3, n = 40) {
    const i = this.debugGroup.getObjectByName("gridHelper");
    i && this.debugGroup.remove(i);
    const r = new c2(e, n, 4473924, 2236962);
    r.name = "gridHelper", r.rotation.x = Math.PI / 2, this.debugGroup.add(r);
  }
  // ============================================================================
  // BACKGROUND
  // ============================================================================
  /**
   * Set scene background color
   */
  setBackground(e) {
    e ? this.scene.background = new Mt(e) : this.scene.background = null;
  }
  /**
   * Get current background color
   */
  getBackground() {
    return this.scene.background instanceof Mt ? "#" + this.scene.background.getHexString() : null;
  }
  // ============================================================================
  // COMPOSITION BOUNDS
  // ============================================================================
  /**
   * Set composition dimensions and create/update bounds frame
   */
  setCompositionSize(e, n) {
    this.compositionWidth = e, this.compositionHeight = n, this.updateCompositionBounds();
  }
  /**
   * Get composition dimensions
   */
  getCompositionSize() {
    return { width: this.compositionWidth, height: this.compositionHeight };
  }
  /**
   * Create or update composition bounds frame
   */
  updateCompositionBounds() {
    this.compositionBounds && (this.overlayGroup.remove(this.compositionBounds), this.compositionBounds.geometry.dispose(), this.compositionBounds.material.dispose());
    const e = this.compositionWidth, n = this.compositionHeight, i = [
      new ce(0, 0, 0),
      new ce(e, 0, 0),
      new ce(e, -n, 0),
      new ce(0, -n, 0)
    ], r = new Nt().setFromPoints(i), o = new Wi({
      color: 4886745,
      linewidth: 2,
      depthTest: !1
    });
    this.compositionBounds = new xE(r, o), this.compositionBounds.name = "compositionBounds", this.compositionBounds.renderOrder = 998, this.overlayGroup.add(this.compositionBounds);
  }
  /**
   * Show/hide composition bounds
   */
  setCompositionBoundsVisible(e) {
    this.compositionBounds && (this.compositionBounds.visible = e);
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast against composition objects
   */
  raycastComposition(e) {
    return e.intersectObjects(this.compositionGroup.children, !0);
  }
  /**
   * Find layer object by ID
   */
  findLayerById(e) {
    return this.compositionGroup.children.find(
      (n) => n.userData.layerId === e
    ) ?? null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose object and its resources
   */
  disposeObject(e) {
    var n;
    for (e instanceof qe && ((n = e.geometry) == null || n.dispose(), Array.isArray(e.material) ? e.material.forEach((i) => {
      this.disposeMaterial(i);
    }) : e.material && this.disposeMaterial(e.material)); e.children.length > 0; ) {
      const i = e.children[0];
      e.remove(i), this.disposeObject(i);
    }
  }
  /**
   * Dispose material and its textures
   */
  disposeMaterial(e) {
    var i, r, o, a, l, c, u, d;
    const n = e;
    (i = n.map) == null || i.dispose(), (r = n.normalMap) == null || r.dispose(), (o = n.roughnessMap) == null || o.dispose(), (a = n.metalnessMap) == null || a.dispose(), (l = n.aoMap) == null || l.dispose(), (c = n.emissiveMap) == null || c.dispose(), (u = n.alphaMap) == null || u.dispose(), (d = n.envMap) == null || d.dispose(), e.dispose();
  }
  /**
   * Dispose all scene resources
   */
  dispose() {
    for (; this.compositionGroup.children.length > 0; ) {
      const e = this.compositionGroup.children[0];
      this.compositionGroup.remove(e), this.disposeObject(e);
    }
    for (this.clearOverlay(); this.debugGroup.children.length > 0; ) {
      const e = this.debugGroup.children[0];
      this.debugGroup.remove(e), this.disposeObject(e);
    }
    this.scene.clear();
  }
}
const Xz = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class Xo {
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const jz = new mu(-1, 1, 1, -1, 0, 1);
class Yz extends Nt {
  constructor() {
    super(), this.setAttribute("position", new Pt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new Pt([0, 2, 0, 0, 2, 0], 2));
  }
}
const qz = new Yz();
class Bf {
  constructor(e) {
    this._mesh = new qe(qz, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, jz);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class Zz extends Xo {
  constructor(e, n) {
    super(), this.textureID = n !== void 0 ? n : "tDiffuse", e instanceof Fn ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = ml.clone(e.uniforms), this.material = new Fn({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new Bf(this.material);
  }
  render(e, n, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class wv extends Xo {
  constructor(e, n) {
    super(), this.scene = e, this.camera = n, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, n, i) {
    const r = e.getContext(), o = e.state;
    o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0);
    let a, l;
    this.inverse ? (a = 0, l = 1) : (a = 1, l = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), o.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295), o.buffers.stencil.setClear(l), o.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.color.setMask(!0), o.buffers.depth.setMask(!0), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), o.buffers.stencil.setLocked(!0);
  }
}
class Kz extends Xo {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class Jz {
  constructor(e, n) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), n === void 0) {
      const i = e.getSize(new st());
      this._width = i.width, this._height = i.height, n = new Hi(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: sr }), n.texture.name = "EffectComposer.rt1";
    } else
      this._width = n.width, this._height = n.height;
    this.renderTarget1 = n, this.renderTarget2 = n.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new Zz(Xz), this.copyPass.material.blending = ts, this.clock = new a2();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, n) {
    this.passes.splice(n, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const n = this.passes.indexOf(e);
    n !== -1 && this.passes.splice(n, 1);
  }
  isLastEnabledPass(e) {
    for (let n = e + 1; n < this.passes.length; n++)
      if (this.passes[n].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const n = this.renderer.getRenderTarget();
    let i = !1;
    for (let r = 0, o = this.passes.length; r < o; r++) {
      const a = this.passes[r];
      if (a.enabled !== !1) {
        if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
          if (i) {
            const l = this.renderer.getContext(), c = this.renderer.state.buffers.stencil;
            c.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), c.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        wv !== void 0 && (a instanceof wv ? i = !0 : a instanceof Kz && (i = !1));
      }
    }
    this.renderer.setRenderTarget(n);
  }
  reset(e) {
    if (e === void 0) {
      const n = this.renderer.getSize(new st());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = n.width, this._height = n.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, n) {
    this._width = e, this._height = n;
    const i = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, r), this.renderTarget2.setSize(i, r);
    for (let o = 0; o < this.passes.length; o++)
      this.passes[o].setSize(i, r);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class Qz extends Xo {
  constructor(e, n, i = null, r = null, o = null) {
    super(), this.scene = e, this.camera = n, this.overrideMaterial = i, this.clearColor = r, this.clearAlpha = o, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    const r = e.autoClear;
    e.autoClear = !1;
    let o, a;
    this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (o = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(o), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = r;
  }
}
const e6 = {
  name: "OutputShader",
  uniforms: {
    tDiffuse: { value: null },
    toneMappingExposure: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `
		precision highp float;

		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		attribute vec3 position;
		attribute vec2 uv;

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `
	
		precision highp float;

		uniform sampler2D tDiffuse;

		#include <tonemapping_pars_fragment>
		#include <colorspace_pars_fragment>

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );

			// tone mapping

			#ifdef LINEAR_TONE_MAPPING

				gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );

			#elif defined( REINHARD_TONE_MAPPING )

				gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );

			#elif defined( CINEON_TONE_MAPPING )

				gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );

			#elif defined( ACES_FILMIC_TONE_MAPPING )

				gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );

			#elif defined( AGX_TONE_MAPPING )

				gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );

			#elif defined( NEUTRAL_TONE_MAPPING )

				gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );

			#endif

			// color space

			#ifdef SRGB_TRANSFER

				gl_FragColor = sRGBTransferOETF( gl_FragColor );

			#endif

		}`
  )
};
class t6 extends Xo {
  constructor() {
    super();
    const e = e6;
    this.uniforms = ml.clone(e.uniforms), this.material = new KE({
      name: e.name,
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    }), this.fsQuad = new Bf(this.material), this._outputColorSpace = null, this._toneMapping = null;
  }
  render(e, n, i) {
    this.uniforms.tDiffuse.value = i.texture, this.uniforms.toneMappingExposure.value = e.toneMappingExposure, (this._outputColorSpace !== e.outputColorSpace || this._toneMapping !== e.toneMapping) && (this._outputColorSpace = e.outputColorSpace, this._toneMapping = e.toneMapping, this.material.defines = {}, kt.getTransfer(this._outputColorSpace) === qt && (this.material.defines.SRGB_TRANSFER = ""), this._toneMapping === w0 ? this.material.defines.LINEAR_TONE_MAPPING = "" : this._toneMapping === S0 ? this.material.defines.REINHARD_TONE_MAPPING = "" : this._toneMapping === M0 ? this.material.defines.CINEON_TONE_MAPPING = "" : this._toneMapping === hf ? this.material.defines.ACES_FILMIC_TONE_MAPPING = "" : this._toneMapping === C0 ? this.material.defines.AGX_TONE_MAPPING = "" : this._toneMapping === E0 && (this.material.defines.NEUTRAL_TONE_MAPPING = ""), this.material.needsUpdate = !0), this.renderToScreen === !0 ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const n6 = {
  defines: {
    DEPTH_PACKING: 1,
    PERSPECTIVE_CAMERA: 1
  },
  uniforms: {
    tColor: { value: null },
    tDepth: { value: null },
    focus: { value: 1 },
    aspect: { value: 1 },
    aperture: { value: 0.025 },
    maxblur: { value: 0.01 },
    nearClip: { value: 1 },
    farClip: { value: 1e3 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		#include <common>

		varying vec2 vUv;

		uniform sampler2D tColor;
		uniform sampler2D tDepth;

		uniform float maxblur; // max blur amount
		uniform float aperture; // aperture - bigger values for shallower depth of field

		uniform float nearClip;
		uniform float farClip;

		uniform float focus;
		uniform float aspect;

		#include <packing>

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, nearClip, farClip );
			#else
			return orthographicDepthToViewZ( depth, nearClip, farClip );
			#endif
		}


		void main() {

			vec2 aspectcorrect = vec2( 1.0, aspect );

			float viewZ = getViewZ( getDepth( vUv ) );

			float factor = ( focus + viewZ ); // viewZ is <= 0, so this is a difference equation

			vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );

			vec2 dofblur9 = dofblur * 0.9;
			vec2 dofblur7 = dofblur * 0.7;
			vec2 dofblur4 = dofblur * 0.4;

			vec4 col = vec4( 0.0 );

			col += texture2D( tColor, vUv.xy );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );

			col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );
			col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );

			gl_FragColor = col / 41.0;
			gl_FragColor.a = 1.0;

		}`
  )
};
class i6 extends Xo {
  constructor(e, n, i) {
    super(), this.scene = e, this.camera = n;
    const r = i.focus !== void 0 ? i.focus : 1, o = i.aperture !== void 0 ? i.aperture : 0.025, a = i.maxblur !== void 0 ? i.maxblur : 1;
    this.renderTargetDepth = new Hi(1, 1, {
      // will be resized later
      minFilter: Ln,
      magFilter: Ln,
      type: sr
    }), this.renderTargetDepth.texture.name = "BokehPass.depth", this.materialDepth = new Tf(), this.materialDepth.depthPacking = _f, this.materialDepth.blending = ts;
    const l = n6, c = ml.clone(l.uniforms);
    c.tDepth.value = this.renderTargetDepth.texture, c.focus.value = r, c.aspect.value = n.aspect, c.aperture.value = o, c.maxblur.value = a, c.nearClip.value = n.near, c.farClip.value = n.far, this.materialBokeh = new Fn({
      defines: Object.assign({}, l.defines),
      uniforms: c,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader
    }), this.uniforms = c, this.fsQuad = new Bf(this.materialBokeh), this._oldClearColor = new Mt();
  }
  render(e, n, i) {
    this.scene.overrideMaterial = this.materialDepth, e.getClearColor(this._oldClearColor);
    const r = e.getClearAlpha(), o = e.autoClear;
    e.autoClear = !1, e.setClearColor(16777215), e.setClearAlpha(1), e.setRenderTarget(this.renderTargetDepth), e.clear(), e.render(this.scene, this.camera), this.uniforms.tColor.value = i.texture, this.uniforms.nearClip.value = this.camera.near, this.uniforms.farClip.value = this.camera.far, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(n), e.clear(), this.fsQuad.render(e)), this.scene.overrideMaterial = null, e.setClearColor(this._oldClearColor), e.setClearAlpha(r), e.autoClear = o;
  }
  setSize(e, n) {
    this.materialBokeh.uniforms.aspect.value = e / n, this.renderTargetDepth.setSize(e, n);
  }
  dispose() {
    this.renderTargetDepth.dispose(), this.materialDepth.dispose(), this.materialBokeh.dispose(), this.fsQuad.dispose();
  }
}
class s6 {
  constructor(e, n, i) {
    pe(this, "renderer");
    pe(this, "composer");
    pe(this, "scene");
    pe(this, "camera");
    // Render targets
    pe(this, "colorTarget");
    pe(this, "depthTarget");
    // Frame capture
    pe(this, "captureCanvas");
    pe(this, "captureCtx");
    // Depth capture material
    pe(this, "depthMaterial");
    // Normal material for normal pass
    pe(this, "normalMaterial");
    // Dimensions
    pe(this, "width");
    pe(this, "height");
    pe(this, "pixelRatio");
    // Render mode
    pe(this, "renderMode", "color");
    // DOF pass
    pe(this, "bokehPass", null);
    pe(this, "dofConfig", {
      enabled: !1,
      focusDistance: 500,
      aperture: 0.025,
      maxBlur: 0.01
    });
    this.scene = n, this.camera = i, this.width = e.width, this.height = e.height, this.pixelRatio = e.pixelRatio ?? Math.min(window.devicePixelRatio, 2), this.renderer = new yE({
      canvas: e.canvas,
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      preserveDrawingBuffer: !0,
      // Required for frame capture
      powerPreference: "high-performance",
      stencil: !1,
      depth: !0
    }), this.renderer.setPixelRatio(this.pixelRatio), this.renderer.setSize(this.width, this.height), this.renderer.outputColorSpace = pn, this.renderer.toneMapping = hf, this.renderer.toneMappingExposure = 1, this.renderer.shadowMap.enabled = !0, this.renderer.shadowMap.type = v0;
    const r = Math.floor(this.width * this.pixelRatio), o = Math.floor(this.height * this.pixelRatio);
    this.colorTarget = this.createColorTarget(r, o), this.depthTarget = this.createDepthTarget(r, o), this.composer = new Jz(this.renderer, this.colorTarget), this.setupDefaultPasses(), this.captureCanvas = new OffscreenCanvas(r, o), this.captureCtx = this.captureCanvas.getContext("2d"), this.depthMaterial = this.createDepthMaterial(), this.normalMaterial = new QE();
  }
  // ============================================================================
  // RENDER TARGET CREATION
  // ============================================================================
  createColorTarget(e, n) {
    return new Hi(e, n, {
      minFilter: Xt,
      magFilter: Xt,
      format: $n,
      type: sr,
      colorSpace: pn,
      depthBuffer: !0,
      stencilBuffer: !1,
      samples: 4
      // MSAA
    });
  }
  createDepthTarget(e, n) {
    const i = new Hi(e, n, {
      minFilter: Ln,
      magFilter: Ln,
      format: $n,
      type: ui,
      depthBuffer: !0,
      stencilBuffer: !1
    });
    return i.depthTexture = new Ef(e, n), i.depthTexture.format = Lr, i.depthTexture.type = ui, i;
  }
  createDepthMaterial() {
    return new Fn({
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        #include <packing>

        varying vec2 vUv;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;

        float readDepth(sampler2D depthSampler, vec2 coord) {
          float fragCoordZ = texture2D(depthSampler, coord).x;
          float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);
          return viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        }

        void main() {
          float depth = readDepth(tDepth, vUv);
          gl_FragColor = vec4(vec3(1.0 - depth), 1.0);
        }
      `,
      uniforms: {
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1e4 }
      },
      depthWrite: !1,
      depthTest: !1
    });
  }
  // ============================================================================
  // POST-PROCESSING
  // ============================================================================
  setupDefaultPasses() {
    const e = new Qz(this.scene.scene, this.camera.camera);
    this.composer.addPass(e);
    const n = new t6();
    this.composer.addPass(n);
  }
  /**
   * Add a post-processing pass
   */
  addPass(e) {
    const n = this.composer.passes.findIndex(
      (i) => i.constructor.name === "OutputPass"
    );
    n > -1 ? this.composer.insertPass(e, n) : this.composer.addPass(e);
  }
  /**
   * Remove a post-processing pass
   */
  removePass(e) {
    this.composer.removePass(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field effect
   */
  setDOF(e) {
    this.dofConfig = { ...this.dofConfig, ...e }, this.dofConfig.enabled ? (this.bokehPass || this.createBokehPass(), this.updateBokehPass()) : this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return { ...this.dofConfig };
  }
  /**
   * Create the bokeh (DOF) pass
   */
  createBokehPass() {
    Math.floor(this.width * this.pixelRatio), Math.floor(this.height * this.pixelRatio), this.bokehPass = new i6(
      this.scene.scene,
      this.camera.camera,
      {
        focus: this.dofConfig.focusDistance,
        aperture: this.dofConfig.aperture,
        maxblur: this.dofConfig.maxBlur
      }
      // width/height are needed but not in types
    ), this.addPass(this.bokehPass);
  }
  /**
   * Update bokeh pass parameters
   */
  updateBokehPass() {
    if (!this.bokehPass) return;
    const e = this.bokehPass.uniforms;
    e && (e.focus.value = this.dofConfig.focusDistance, e.aperture.value = this.dofConfig.aperture, e.maxblur.value = this.dofConfig.maxBlur);
  }
  /**
   * Set focus distance (convenience method)
   */
  setFocusDistance(e) {
    this.setDOF({ focusDistance: e });
  }
  /**
   * Set aperture size (convenience method)
   */
  setAperture(e) {
    this.setDOF({ aperture: e });
  }
  /**
   * Enable/disable DOF (convenience method)
   */
  setDOFEnabled(e) {
    this.setDOF({ enabled: e });
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.scene.sortByZ(), this.composer.render();
  }
  /**
   * Render directly to a render target
   */
  renderToTarget(e) {
    const n = this.renderer.getRenderTarget();
    this.renderer.setRenderTarget(e), this.renderer.render(this.scene.scene, this.camera.camera), this.renderer.setRenderTarget(n);
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, e === "depth" || e === "normal" ? this.scene.scene.overrideMaterial = e === "depth" ? this.depthMaterial : this.normalMaterial : this.scene.scene.overrideMaterial = null;
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // FRAME CAPTURE
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio), i = new Uint8Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.colorTarget,
      0,
      0,
      e,
      n,
      i
    );
    const r = new Uint8ClampedArray(i.length), o = e * 4;
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * o, c = a * o;
      r.set(i.subarray(l, l + o), c);
    }
    return new ImageData(r, e, n);
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    const e = Math.floor(this.width * this.pixelRatio), n = Math.floor(this.height * this.pixelRatio);
    this.renderToTarget(this.depthTarget);
    const i = new Float32Array(e * n * 4);
    this.renderer.readRenderTargetPixels(
      this.depthTarget,
      0,
      0,
      e,
      n,
      i
    );
    const r = new Float32Array(e * n);
    for (let a = 0; a < e * n; a++)
      r[a] = i[a * 4];
    const o = new Float32Array(e * n);
    for (let a = 0; a < n; a++) {
      const l = (n - 1 - a) * e, c = a * e;
      o.set(r.subarray(l, l + e), c);
    }
    return o;
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize the renderer and targets
   */
  resize(e, n) {
    this.width = e, this.height = n;
    const i = Math.floor(e * this.pixelRatio), r = Math.floor(n * this.pixelRatio);
    this.renderer.setSize(e, n), this.composer.setSize(i, r), this.colorTarget.dispose(), this.depthTarget.dispose(), this.colorTarget = this.createColorTarget(i, r), this.depthTarget = this.createDepthTarget(i, r), this.composer.renderTarget1.dispose(), this.composer.renderTarget2.dispose(), this.composer.renderTarget1 = this.colorTarget.clone(), this.composer.renderTarget2 = this.colorTarget.clone(), this.captureCanvas.width = i, this.captureCanvas.height = r, this.bokehPass && this.dofConfig.enabled && (this.composer.removePass(this.bokehPass), this.bokehPass = null, this.createBokehPass());
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying WebGL renderer
   */
  getWebGLRenderer() {
    return this.renderer;
  }
  /**
   * Get renderer info (for debugging)
   */
  getInfo() {
    return this.renderer.info;
  }
  /**
   * Get current dimensions
   */
  getDimensions() {
    return {
      width: this.width,
      height: this.height,
      pixelRatio: this.pixelRatio
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Get the DOM element (canvas) attached to the renderer
   * Used for attaching controls like TransformControls
   */
  getDomElement() {
    return this.renderer.domElement;
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.bokehPass && (this.composer.removePass(this.bokehPass), this.bokehPass = null), this.colorTarget.dispose(), this.depthTarget.dispose(), this.depthMaterial.dispose(), this.normalMaterial.dispose(), this.composer.dispose(), this.renderer.dispose();
  }
}
class r6 extends $i {
  constructor(n, i) {
    super(n);
    pe(this, "mesh");
    pe(this, "geometry");
    pe(this, "material");
    pe(this, "texture", null);
    /** Resource manager for texture loading */
    pe(this, "resources");
    /** Image dimensions */
    pe(this, "imageWidth", 100);
    pe(this, "imageHeight", 100);
    /** Source URL or asset ID */
    pe(this, "sourceUrl", null);
    /** Original (unprocessed) texture for effects source */
    pe(this, "originalTexture", null);
    /** Canvas for rendering texture to 2D for effect processing */
    pe(this, "textureCanvas", null);
    pe(this, "textureCanvasCtx", null);
    this.resources = i, this.geometry = new cn(1, 1), this.material = new Mn({
      color: 16777215,
      transparent: !0,
      side: mn,
      depthWrite: !1
    }), this.mesh = new qe(this.geometry, this.material), this.mesh.name = `image_${this.id}`, this.group.add(this.mesh);
    const r = this.extractImageData(n);
    r.source && this.loadImage(r.source), this.initializeBlendMode();
  }
  /**
   * Extract image data from layer object
   */
  extractImageData(n) {
    const i = n.data;
    return {
      source: (i == null ? void 0 : i.source) ?? (i == null ? void 0 : i.url) ?? (i == null ? void 0 : i.assetId) ?? null,
      width: (i == null ? void 0 : i.width) ?? 100,
      height: (i == null ? void 0 : i.height) ?? 100
    };
  }
  // ============================================================================
  // IMAGE LOADING
  // ============================================================================
  /**
   * Load image from URL
   */
  async loadImage(n) {
    this.sourceUrl = n;
    try {
      const i = await this.resources.loadTexture(n, {
        minFilter: Xt,
        magFilter: Xt,
        generateMipmaps: !1,
        colorSpace: pn
      });
      this.setTexture(i);
    } catch (i) {
      console.error(`[ImageLayer] Failed to load image: ${n}`, i);
    }
  }
  /**
   * Set texture directly
   */
  setTexture(n) {
    this.texture = n, this.originalTexture = n, this.material.map = n, this.material.needsUpdate = !0, n.image && (this.imageWidth = n.image.width || n.image.videoWidth || 100, this.imageHeight = n.image.height || n.image.videoHeight || 100, this.updateMeshSize(), this.textureCanvas = null, this.textureCanvasCtx = null, this.effectsDirty = !0);
  }
  /**
   * Set texture from ImageData
   */
  setTextureFromImageData(n) {
    const i = this.resources.createTextureFromImageData(
      n,
      `layer_${this.id}_imagedata`,
      {
        minFilter: Xt,
        magFilter: Xt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.setTexture(i);
  }
  /**
   * Set texture from canvas
   */
  setTextureFromCanvas(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_canvas`,
      {
        minFilter: Xt,
        magFilter: Xt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.setTexture(i);
  }
  /**
   * Update mesh size to match image dimensions
   */
  updateMeshSize() {
    this.geometry.dispose(), this.geometry = new cn(this.imageWidth, this.imageHeight), this.mesh.geometry = this.geometry;
  }
  // ============================================================================
  // PROPERTIES
  // ============================================================================
  /**
   * Get image dimensions
   */
  getDimensions() {
    return {
      width: this.imageWidth,
      height: this.imageHeight
    };
  }
  /**
   * Set dimensions (stretches the image)
   */
  setDimensions(n, i) {
    this.imageWidth = n, this.imageHeight = i, this.updateMeshSize();
  }
  /**
   * Get source URL
   */
  getSource() {
    return this.sourceUrl;
  }
  /**
   * Set tint color
   */
  setTint(n) {
    this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Clear tint (reset to white)
   */
  clearTint() {
    this.material.color.set(16777215), this.material.needsUpdate = !0;
  }
  // ============================================================================
  // EFFECTS SUPPORT
  // ============================================================================
  /**
   * Get source canvas for effect processing
   * Renders the original texture to a 2D canvas
   */
  getSourceCanvas() {
    var i;
    if (!((i = this.originalTexture) != null && i.image))
      return null;
    const n = this.originalTexture.image;
    return (!this.textureCanvas || this.textureCanvas.width !== this.imageWidth || this.textureCanvas.height !== this.imageHeight) && (this.textureCanvas = document.createElement("canvas"), this.textureCanvas.width = this.imageWidth, this.textureCanvas.height = this.imageHeight, this.textureCanvasCtx = this.textureCanvas.getContext("2d")), this.textureCanvasCtx ? (this.textureCanvasCtx.clearRect(0, 0, this.imageWidth, this.imageHeight), this.textureCanvasCtx.drawImage(n, 0, 0, this.imageWidth, this.imageHeight), this.textureCanvas) : null;
  }
  /**
   * Apply processed effects canvas back to the material
   */
  applyProcessedEffects(n) {
    const i = this.resources.createTextureFromCanvas(
      n,
      `layer_${this.id}_effects`,
      {
        minFilter: Xt,
        magFilter: Xt,
        generateMipmaps: !1,
        colorSpace: pn
      }
    );
    this.texture = i, this.material.map = i, this.material.needsUpdate = !0;
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.evaluateEffects(n);
  }
  onUpdate(n) {
    const i = n.data;
    if (i != null && i.source || i != null && i.url || i != null && i.assetId) {
      const r = i.source ?? i.url ?? i.assetId;
      r !== this.sourceUrl && this.loadImage(r);
    }
    ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      i.width ?? this.imageWidth,
      i.height ?? this.imageHeight
    );
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class o6 extends $i {
  constructor(n) {
    super(n);
    pe(this, "mesh");
    pe(this, "geometry");
    pe(this, "material");
    /** Solid color */
    pe(this, "color");
    /** Solid dimensions */
    pe(this, "width");
    pe(this, "height");
    const i = this.extractSolidData(n);
    this.color = i.color, this.width = i.width, this.height = i.height, this.geometry = new cn(this.width, this.height), this.material = new Mn({
      color: this.color,
      transparent: !0,
      side: mn,
      depthWrite: !1
    }), this.mesh = new qe(this.geometry, this.material), this.mesh.name = `solid_${this.id}`, this.group.add(this.mesh), this.initializeBlendMode();
  }
  /**
   * Extract solid layer data from layer object
   */
  extractSolidData(n) {
    const i = n.data;
    return {
      color: (i == null ? void 0 : i.color) ?? "#808080",
      width: (i == null ? void 0 : i.width) ?? 1920,
      height: (i == null ? void 0 : i.height) ?? 1080
    };
  }
  /**
   * Set solid color
   */
  setColor(n) {
    this.color = n, this.material.color.set(n), this.material.needsUpdate = !0;
  }
  /**
   * Get current color
   */
  getColor() {
    return this.color;
  }
  /**
   * Set solid dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new cn(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Get dimensions
   */
  getDimensions() {
    return { width: this.width, height: this.height };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    const i = n.data;
    (i == null ? void 0 : i.color) !== void 0 && this.setColor(i.color), ((i == null ? void 0 : i.width) !== void 0 || (i == null ? void 0 : i.height) !== void 0) && this.setDimensions(
      i.width ?? this.width,
      i.height ?? this.height
    ), i === void 0 && n.labelColor !== void 0 && this.setColor(n.labelColor);
  }
  onDispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class Sv extends $i {
  constructor(n, i = !0) {
    super(n);
    /** Visual indicator (crosshair) for editor visibility */
    pe(this, "indicator", null);
    /** Whether to show the null indicator */
    pe(this, "showIndicator");
    /** Indicator size */
    pe(this, "indicatorSize");
    this.showIndicator = i, this.indicatorSize = 50, this.showIndicator && this.createIndicator();
  }
  /**
   * Create visual indicator (crosshair) for the null object
   */
  createIndicator() {
    this.indicator = new Ei(), this.indicator.name = `null_indicator_${this.id}`;
    const n = this.indicatorSize, i = 16737792, r = new Wi({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), o = [
      new ce(-n / 2, 0, 0),
      new ce(n / 2, 0, 0)
    ], a = new Nt().setFromPoints(o), l = new an(a, r);
    this.indicator.add(l);
    const c = [
      new ce(0, -n / 2, 0),
      new ce(0, n / 2, 0)
    ], u = new Nt().setFromPoints(c), d = new an(u, r);
    if (this.indicator.add(d), this.threeD) {
      const y = [
        new ce(0, 0, -n / 2),
        new ce(0, 0, n / 2)
      ], _ = new Nt().setFromPoints(y), v = new an(_, r);
      this.indicator.add(v);
    }
    const h = new gu(3, 16), m = new Mn({
      color: i,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1,
      side: mn
    }), p = new qe(h, m);
    this.indicator.add(p), this.group.add(this.indicator), this.indicator.renderOrder = 999;
  }
  /**
   * Set indicator visibility
   */
  setIndicatorVisible(n) {
    this.indicator && (this.indicator.visible = n);
  }
  /**
   * Set indicator size
   */
  setIndicatorSize(n) {
    n !== this.indicatorSize && (this.indicatorSize = n, this.indicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  /**
   * Dispose indicator resources
   */
  disposeIndicator() {
    this.indicator && (this.indicator.traverse((n) => {
      n instanceof an && (n.geometry.dispose(), n.material.dispose()), n instanceof qe && (n.geometry.dispose(), n.material.dispose());
    }), this.indicator.clear(), this.indicator = null);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    n.threeD !== void 0 && n.threeD !== this.threeD && (this.threeD = n.threeD, this.indicator && this.showIndicator && (this.group.remove(this.indicator), this.disposeIndicator(), this.createIndicator()));
  }
  onDispose() {
    this.disposeIndicator();
  }
}
function a6() {
  var s = /* @__PURE__ */ Object.create(null);
  function e(r, o) {
    var a = r.id, l = r.name, c = r.dependencies;
    c === void 0 && (c = []);
    var u = r.init;
    u === void 0 && (u = function() {
    });
    var d = r.getTransferables;
    if (d === void 0 && (d = null), !s[a])
      try {
        c = c.map(function(m) {
          return m && m.isWorkerModule && (e(m, function(p) {
            if (p instanceof Error)
              throw p;
          }), m = s[m.id].value), m;
        }), u = i("<" + l + ">.init", u), d && (d = i("<" + l + ">.getTransferables", d));
        var h = null;
        typeof u == "function" ? h = u.apply(void 0, c) : console.error("worker module init function failed to rehydrate"), s[a] = {
          id: a,
          value: h,
          getTransferables: d
        }, o(h);
      } catch (m) {
        m && m.noLog || console.error(m), o(m);
      }
  }
  function n(r, o) {
    var a, l = r.id, c = r.args;
    (!s[l] || typeof s[l].value != "function") && o(new Error("Worker module " + l + ": not found or its 'init' did not return a function"));
    try {
      var u = (a = s[l]).value.apply(a, c);
      u && typeof u.then == "function" ? u.then(d, function(h) {
        return o(h instanceof Error ? h : new Error("" + h));
      }) : d(u);
    } catch (h) {
      o(h);
    }
    function d(h) {
      try {
        var m = s[l].getTransferables && s[l].getTransferables(h);
        (!m || !Array.isArray(m) || !m.length) && (m = void 0), o(h, m);
      } catch (p) {
        console.error(p), o(p);
      }
    }
  }
  function i(r, o) {
    var a = void 0;
    self.troikaDefine = function(c) {
      return a = c;
    };
    var l = URL.createObjectURL(
      new Blob(
        ["/** " + r.replace(/\*/g, "") + ` **/

troikaDefine(
` + o + `
)`],
        { type: "application/javascript" }
      )
    );
    try {
      importScripts(l);
    } catch (c) {
      console.error(c);
    }
    return URL.revokeObjectURL(l), delete self.troikaDefine, a;
  }
  self.addEventListener("message", function(r) {
    var o = r.data, a = o.messageId, l = o.action, c = o.data;
    try {
      l === "registerModule" && e(c, function(u) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: { isCallable: typeof u == "function" }
        });
      }), l === "callModule" && n(c, function(u, d) {
        u instanceof Error ? postMessage({
          messageId: a,
          success: !1,
          error: u.message
        }) : postMessage({
          messageId: a,
          success: !0,
          result: u
        }, d || void 0);
      });
    } catch (u) {
      postMessage({
        messageId: a,
        success: !1,
        error: u.stack
      });
    }
  });
}
function l6(s) {
  var e = function() {
    for (var n = [], i = arguments.length; i--; ) n[i] = arguments[i];
    return e._getInitResult().then(function(r) {
      if (typeof r == "function")
        return r.apply(void 0, n);
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  };
  return e._getInitResult = function() {
    var n = s.dependencies, i = s.init;
    n = Array.isArray(n) ? n.map(function(o) {
      return o && (o = o.onMainThread || o, o._getInitResult && (o = o._getInitResult())), o;
    }) : [];
    var r = Promise.all(n).then(function(o) {
      return i.apply(null, o);
    });
    return e._getInitResult = function() {
      return r;
    }, r;
  }, e;
}
var gy = function() {
  var s = !1;
  if (typeof window < "u" && typeof window.document < "u")
    try {
      var e = new Worker(
        URL.createObjectURL(new Blob([""], { type: "application/javascript" }))
      );
      e.terminate(), s = !0;
    } catch (n) {
      console.log(
        "Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + n.message + "]"
      );
    }
  return gy = function() {
    return s;
  }, s;
}, c6 = 0, u6 = 0, kd = !1, Ga = /* @__PURE__ */ Object.create(null), Ha = /* @__PURE__ */ Object.create(null), Gh = /* @__PURE__ */ Object.create(null);
function jo(s) {
  if ((!s || typeof s.init != "function") && !kd)
    throw new Error("requires `options.init` function");
  var e = s.dependencies, n = s.init, i = s.getTransferables, r = s.workerId, o = l6(s);
  r == null && (r = "#default");
  var a = "workerModule" + ++c6, l = s.name || a, c = null;
  e = e && e.map(function(d) {
    return typeof d == "function" && !d.workerModuleData && (kd = !0, d = jo({
      workerId: r,
      name: "<" + l + "> function dependency: " + d.name,
      init: `function(){return (
` + Dc(d) + `
)}`
    }), kd = !1), d && d.workerModuleData && (d = d.workerModuleData), d;
  });
  function u() {
    for (var d = [], h = arguments.length; h--; ) d[h] = arguments[h];
    if (!gy())
      return o.apply(void 0, d);
    if (!c) {
      c = Mv(r, "registerModule", u.workerModuleData);
      var m = function() {
        c = null, Ha[r].delete(m);
      };
      (Ha[r] || (Ha[r] = /* @__PURE__ */ new Set())).add(m);
    }
    return c.then(function(p) {
      var y = p.isCallable;
      if (y)
        return Mv(r, "callModule", { id: a, args: d });
      throw new Error("Worker module function was called but `init` did not return a callable function");
    });
  }
  return u.workerModuleData = {
    isWorkerModule: !0,
    id: a,
    name: l,
    dependencies: e,
    init: Dc(n),
    getTransferables: i && Dc(i)
  }, u.onMainThread = o, u;
}
function d6(s) {
  Ha[s] && Ha[s].forEach(function(e) {
    e();
  }), Ga[s] && (Ga[s].terminate(), delete Ga[s]);
}
function Dc(s) {
  var e = s.toString();
  return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e;
}
function h6(s) {
  var e = Ga[s];
  if (!e) {
    var n = Dc(a6);
    e = Ga[s] = new Worker(
      URL.createObjectURL(
        new Blob(
          ["/** Worker Module Bootstrap: " + s.replace(/\*/g, "") + ` **/

;(` + n + ")()"],
          { type: "application/javascript" }
        )
      )
    ), e.onmessage = function(i) {
      var r = i.data, o = r.messageId, a = Gh[o];
      if (!a)
        throw new Error("WorkerModule response with empty or unknown messageId");
      delete Gh[o], a(r);
    };
  }
  return e;
}
function Mv(s, e, n) {
  return new Promise(function(i, r) {
    var o = ++u6;
    Gh[o] = function(a) {
      a.success ? i(a.result) : r(new Error("Error in worker " + e + " call: " + a.error));
    }, h6(s).postMessage({
      messageId: o,
      action: e,
      data: n
    });
  });
}
function yy() {
  var s = function(e) {
    function n(le, oe, Y, j, q, te, ne, de) {
      var H = 1 - ne;
      de.x = H * H * le + 2 * H * ne * Y + ne * ne * q, de.y = H * H * oe + 2 * H * ne * j + ne * ne * te;
    }
    function i(le, oe, Y, j, q, te, ne, de, H, X) {
      var V = 1 - H;
      X.x = V * V * V * le + 3 * V * V * H * Y + 3 * V * H * H * q + H * H * H * ne, X.y = V * V * V * oe + 3 * V * V * H * j + 3 * V * H * H * te + H * H * H * de;
    }
    function r(le, oe) {
      for (var Y = /([MLQCZ])([^MLQCZ]*)/g, j, q, te, ne, de; j = Y.exec(le); ) {
        var H = j[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(X) {
          return parseFloat(X);
        });
        switch (j[1]) {
          case "M":
            ne = q = H[0], de = te = H[1];
            break;
          case "L":
            (H[0] !== ne || H[1] !== de) && oe("L", ne, de, ne = H[0], de = H[1]);
            break;
          case "Q": {
            oe("Q", ne, de, ne = H[2], de = H[3], H[0], H[1]);
            break;
          }
          case "C": {
            oe("C", ne, de, ne = H[4], de = H[5], H[0], H[1], H[2], H[3]);
            break;
          }
          case "Z":
            (ne !== q || de !== te) && oe("L", ne, de, q, te);
            break;
        }
      }
    }
    function o(le, oe, Y) {
      Y === void 0 && (Y = 16);
      var j = { x: 0, y: 0 };
      r(le, function(q, te, ne, de, H, X, V, I, F) {
        switch (q) {
          case "L":
            oe(te, ne, de, H);
            break;
          case "Q": {
            for (var k = te, Q = ne, Z = 1; Z < Y; Z++)
              n(
                te,
                ne,
                X,
                V,
                de,
                H,
                Z / (Y - 1),
                j
              ), oe(k, Q, j.x, j.y), k = j.x, Q = j.y;
            break;
          }
          case "C": {
            for (var R = te, ie = ne, J = 1; J < Y; J++)
              i(
                te,
                ne,
                X,
                V,
                I,
                F,
                de,
                H,
                J / (Y - 1),
                j
              ), oe(R, ie, j.x, j.y), R = j.x, ie = j.y;
            break;
          }
        }
      });
    }
    var a = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", l = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}", c = /* @__PURE__ */ new WeakMap(), u = {
      premultipliedAlpha: !1,
      preserveDrawingBuffer: !0,
      antialias: !1,
      depth: !1
    };
    function d(le, oe) {
      var Y = le.getContext ? le.getContext("webgl", u) : le, j = c.get(Y);
      if (!j) {
        let V = function(R) {
          var ie = te[R];
          if (!ie && (ie = te[R] = Y.getExtension(R), !ie))
            throw new Error(R + " not supported");
          return ie;
        }, I = function(R, ie) {
          var J = Y.createShader(ie);
          return Y.shaderSource(J, R), Y.compileShader(J), J;
        }, F = function(R, ie, J, B) {
          if (!ne[R]) {
            var $ = {}, se = {}, U = Y.createProgram();
            Y.attachShader(U, I(ie, Y.VERTEX_SHADER)), Y.attachShader(U, I(J, Y.FRAGMENT_SHADER)), Y.linkProgram(U), ne[R] = {
              program: U,
              transaction: function(K) {
                Y.useProgram(U), K({
                  setUniform: function(me, ge) {
                    for (var Me = [], Te = arguments.length - 2; Te-- > 0; ) Me[Te] = arguments[Te + 2];
                    var Ae = se[ge] || (se[ge] = Y.getUniformLocation(U, ge));
                    Y["uniform" + me].apply(Y, [Ae].concat(Me));
                  },
                  setAttribute: function(me, ge, Me, Te, Ae) {
                    var Xe = $[me];
                    Xe || (Xe = $[me] = {
                      buf: Y.createBuffer(),
                      // TODO should we destroy our buffers?
                      loc: Y.getAttribLocation(U, me),
                      data: null
                    }), Y.bindBuffer(Y.ARRAY_BUFFER, Xe.buf), Y.vertexAttribPointer(Xe.loc, ge, Y.FLOAT, !1, 0, 0), Y.enableVertexAttribArray(Xe.loc), q ? Y.vertexAttribDivisor(Xe.loc, Te) : V("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(Xe.loc, Te), Ae !== Xe.data && (Y.bufferData(Y.ARRAY_BUFFER, Ae, Me), Xe.data = Ae);
                  }
                });
              }
            };
          }
          ne[R].transaction(B);
        }, k = function(R, ie) {
          H++;
          try {
            Y.activeTexture(Y.TEXTURE0 + H);
            var J = de[R];
            J || (J = de[R] = Y.createTexture(), Y.bindTexture(Y.TEXTURE_2D, J), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MIN_FILTER, Y.NEAREST), Y.texParameteri(Y.TEXTURE_2D, Y.TEXTURE_MAG_FILTER, Y.NEAREST)), Y.bindTexture(Y.TEXTURE_2D, J), ie(J, H);
          } finally {
            H--;
          }
        }, Q = function(R, ie, J) {
          var B = Y.createFramebuffer();
          X.push(B), Y.bindFramebuffer(Y.FRAMEBUFFER, B), Y.activeTexture(Y.TEXTURE0 + ie), Y.bindTexture(Y.TEXTURE_2D, R), Y.framebufferTexture2D(Y.FRAMEBUFFER, Y.COLOR_ATTACHMENT0, Y.TEXTURE_2D, R, 0);
          try {
            J(B);
          } finally {
            Y.deleteFramebuffer(B), Y.bindFramebuffer(Y.FRAMEBUFFER, X[--X.length - 1] || null);
          }
        }, Z = function() {
          te = {}, ne = {}, de = {}, H = -1, X.length = 0;
        };
        var q = typeof WebGL2RenderingContext < "u" && Y instanceof WebGL2RenderingContext, te = {}, ne = {}, de = {}, H = -1, X = [];
        Y.canvas.addEventListener("webglcontextlost", function(R) {
          Z(), R.preventDefault();
        }, !1), c.set(Y, j = {
          gl: Y,
          isWebGL2: q,
          getExtension: V,
          withProgram: F,
          withTexture: k,
          withTextureFramebuffer: Q,
          handleContextLoss: Z
        });
      }
      oe(j);
    }
    function h(le, oe, Y, j, q, te, ne, de) {
      ne === void 0 && (ne = 15), de === void 0 && (de = null), d(le, function(H) {
        var X = H.gl, V = H.withProgram, I = H.withTexture;
        I("copy", function(F, k) {
          X.texImage2D(X.TEXTURE_2D, 0, X.RGBA, q, te, 0, X.RGBA, X.UNSIGNED_BYTE, oe), V("copy", a, l, function(Q) {
            var Z = Q.setUniform, R = Q.setAttribute;
            R("aUV", 2, X.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), Z("1i", "image", k), X.bindFramebuffer(X.FRAMEBUFFER, de || null), X.disable(X.BLEND), X.colorMask(ne & 8, ne & 4, ne & 2, ne & 1), X.viewport(Y, j, q, te), X.scissor(Y, j, q, te), X.drawArrays(X.TRIANGLES, 0, 3);
          });
        });
      });
    }
    function m(le, oe, Y) {
      var j = le.width, q = le.height;
      d(le, function(te) {
        var ne = te.gl, de = new Uint8Array(j * q * 4);
        ne.readPixels(0, 0, j, q, ne.RGBA, ne.UNSIGNED_BYTE, de), le.width = oe, le.height = Y, h(ne, de, 0, 0, j, q);
      });
    }
    var p = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      withWebGLContext: d,
      renderImageData: h,
      resizeWebGLCanvasWithoutClearing: m
    });
    function y(le, oe, Y, j, q, te) {
      te === void 0 && (te = 1);
      var ne = new Uint8Array(le * oe), de = j[2] - j[0], H = j[3] - j[1], X = [];
      o(Y, function(R, ie, J, B) {
        X.push({
          x1: R,
          y1: ie,
          x2: J,
          y2: B,
          minX: Math.min(R, J),
          minY: Math.min(ie, B),
          maxX: Math.max(R, J),
          maxY: Math.max(ie, B)
        });
      }), X.sort(function(R, ie) {
        return R.maxX - ie.maxX;
      });
      for (var V = 0; V < le; V++)
        for (var I = 0; I < oe; I++) {
          var F = Q(
            j[0] + de * (V + 0.5) / le,
            j[1] + H * (I + 0.5) / oe
          ), k = Math.pow(1 - Math.abs(F) / q, te) / 2;
          F < 0 && (k = 1 - k), k = Math.max(0, Math.min(255, Math.round(k * 255))), ne[I * le + V] = k;
        }
      return ne;
      function Q(R, ie) {
        for (var J = 1 / 0, B = 1 / 0, $ = X.length; $--; ) {
          var se = X[$];
          if (se.maxX + B <= R)
            break;
          if (R + B > se.minX && ie - B < se.maxY && ie + B > se.minY) {
            var U = g(R, ie, se.x1, se.y1, se.x2, se.y2);
            U < J && (J = U, B = Math.sqrt(J));
          }
        }
        return Z(R, ie) && (B = -B), B;
      }
      function Z(R, ie) {
        for (var J = 0, B = X.length; B--; ) {
          var $ = X[B];
          if ($.maxX <= R)
            break;
          var se = $.y1 > ie != $.y2 > ie && R < ($.x2 - $.x1) * (ie - $.y1) / ($.y2 - $.y1) + $.x1;
          se && (J += $.y1 < $.y2 ? 1 : -1);
        }
        return J !== 0;
      }
    }
    function _(le, oe, Y, j, q, te, ne, de, H, X) {
      te === void 0 && (te = 1), de === void 0 && (de = 0), H === void 0 && (H = 0), X === void 0 && (X = 0), v(le, oe, Y, j, q, te, ne, null, de, H, X);
    }
    function v(le, oe, Y, j, q, te, ne, de, H, X, V) {
      te === void 0 && (te = 1), H === void 0 && (H = 0), X === void 0 && (X = 0), V === void 0 && (V = 0);
      for (var I = y(le, oe, Y, j, q, te), F = new Uint8Array(I.length * 4), k = 0; k < I.length; k++)
        F[k * 4 + V] = I[k];
      h(ne, F, H, X, le, oe, 1 << 3 - V, de);
    }
    function g(le, oe, Y, j, q, te) {
      var ne = q - Y, de = te - j, H = ne * ne + de * de, X = H ? Math.max(0, Math.min(1, ((le - Y) * ne + (oe - j) * de) / H)) : 0, V = le - (Y + X * ne), I = oe - (j + X * de);
      return V * V + I * I;
    }
    var S = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: y,
      generateIntoCanvas: _,
      generateIntoFramebuffer: v
    }), w = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}", x = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}", C = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}", E = new Float32Array([0, 0, 2, 0, 0, 2]), P = null, T = !1, b = {}, M = /* @__PURE__ */ new WeakMap();
    function L(le) {
      if (!T && !A(le))
        throw new Error("WebGL generation not supported");
    }
    function N(le, oe, Y, j, q, te, ne) {
      if (te === void 0 && (te = 1), ne === void 0 && (ne = null), !ne && (ne = P, !ne)) {
        var de = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
        if (!de)
          throw new Error("OffscreenCanvas or DOM canvas not supported");
        ne = P = de.getContext("webgl", { depth: !1 });
      }
      L(ne);
      var H = new Uint8Array(le * oe * 4);
      d(ne, function(F) {
        var k = F.gl, Q = F.withTexture, Z = F.withTextureFramebuffer;
        Q("readable", function(R, ie) {
          k.texImage2D(k.TEXTURE_2D, 0, k.RGBA, le, oe, 0, k.RGBA, k.UNSIGNED_BYTE, null), Z(R, ie, function(J) {
            O(
              le,
              oe,
              Y,
              j,
              q,
              te,
              k,
              J,
              0,
              0,
              0
              // red channel
            ), k.readPixels(0, 0, le, oe, k.RGBA, k.UNSIGNED_BYTE, H);
          });
        });
      });
      for (var X = new Uint8Array(le * oe), V = 0, I = 0; V < H.length; V += 4)
        X[I++] = H[V];
      return X;
    }
    function D(le, oe, Y, j, q, te, ne, de, H, X) {
      te === void 0 && (te = 1), de === void 0 && (de = 0), H === void 0 && (H = 0), X === void 0 && (X = 0), O(le, oe, Y, j, q, te, ne, null, de, H, X);
    }
    function O(le, oe, Y, j, q, te, ne, de, H, X, V) {
      te === void 0 && (te = 1), H === void 0 && (H = 0), X === void 0 && (X = 0), V === void 0 && (V = 0), L(ne);
      var I = [];
      o(Y, function(F, k, Q, Z) {
        I.push(F, k, Q, Z);
      }), I = new Float32Array(I), d(ne, function(F) {
        var k = F.gl, Q = F.isWebGL2, Z = F.getExtension, R = F.withProgram, ie = F.withTexture, J = F.withTextureFramebuffer, B = F.handleContextLoss;
        if (ie("rawDistances", function($, se) {
          (le !== $._lastWidth || oe !== $._lastHeight) && k.texImage2D(
            k.TEXTURE_2D,
            0,
            k.RGBA,
            $._lastWidth = le,
            $._lastHeight = oe,
            0,
            k.RGBA,
            k.UNSIGNED_BYTE,
            null
          ), R("main", w, x, function(U) {
            var z = U.setAttribute, K = U.setUniform, ue = !Q && Z("ANGLE_instanced_arrays"), me = !Q && Z("EXT_blend_minmax");
            z("aUV", 2, k.STATIC_DRAW, 0, E), z("aLineSegment", 4, k.DYNAMIC_DRAW, 1, I), K.apply(void 0, ["4f", "uGlyphBounds"].concat(j)), K("1f", "uMaxDistance", q), K("1f", "uExponent", te), J($, se, function(ge) {
              k.enable(k.BLEND), k.colorMask(!0, !0, !0, !0), k.viewport(0, 0, le, oe), k.scissor(0, 0, le, oe), k.blendFunc(k.ONE, k.ONE), k.blendEquationSeparate(k.FUNC_ADD, Q ? k.MAX : me.MAX_EXT), k.clear(k.COLOR_BUFFER_BIT), Q ? k.drawArraysInstanced(k.TRIANGLES, 0, 3, I.length / 4) : ue.drawArraysInstancedANGLE(k.TRIANGLES, 0, 3, I.length / 4);
            });
          }), R("post", a, C, function(U) {
            U.setAttribute("aUV", 2, k.STATIC_DRAW, 0, E), U.setUniform("1i", "tex", se), k.bindFramebuffer(k.FRAMEBUFFER, de), k.disable(k.BLEND), k.colorMask(V === 0, V === 1, V === 2, V === 3), k.viewport(H, X, le, oe), k.scissor(H, X, le, oe), k.drawArrays(k.TRIANGLES, 0, 3);
          });
        }), k.isContextLost())
          throw B(), new Error("webgl context lost");
      });
    }
    function A(le) {
      var oe = !le || le === P ? b : le.canvas || le, Y = M.get(oe);
      if (Y === void 0) {
        T = !0;
        var j = null;
        try {
          var q = [
            97,
            106,
            97,
            61,
            99,
            137,
            118,
            80,
            80,
            118,
            137,
            99,
            61,
            97,
            106,
            97
          ], te = N(
            4,
            4,
            "M8,8L16,8L24,24L16,24Z",
            [0, 0, 32, 32],
            24,
            1,
            le
          );
          Y = te && q.length === te.length && te.every(function(ne, de) {
            return ne === q[de];
          }), Y || (j = "bad trial run results", console.info(q, te));
        } catch (ne) {
          Y = !1, j = ne.message;
        }
        j && console.warn("WebGL SDF generation not supported:", j), T = !1, M.set(oe, Y);
      }
      return Y;
    }
    var G = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: N,
      generateIntoCanvas: D,
      generateIntoFramebuffer: O,
      isSupported: A
    });
    function he(le, oe, Y, j, q, te) {
      q === void 0 && (q = Math.max(j[2] - j[0], j[3] - j[1]) / 2), te === void 0 && (te = 1);
      try {
        return N.apply(G, arguments);
      } catch (ne) {
        return console.info("WebGL SDF generation failed, falling back to JS", ne), y.apply(S, arguments);
      }
    }
    function ee(le, oe, Y, j, q, te, ne, de, H, X) {
      q === void 0 && (q = Math.max(j[2] - j[0], j[3] - j[1]) / 2), te === void 0 && (te = 1), de === void 0 && (de = 0), H === void 0 && (H = 0), X === void 0 && (X = 0);
      try {
        return D.apply(G, arguments);
      } catch (V) {
        return console.info("WebGL SDF generation failed, falling back to JS", V), _.apply(S, arguments);
      }
    }
    return e.forEachPathCommand = r, e.generate = he, e.generateIntoCanvas = ee, e.javascript = S, e.pathToLineSegments = o, e.webgl = G, e.webglUtils = p, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
function f6() {
  var s = function(e) {
    var n = {
      R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
      EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
      ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
      ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
      AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
      CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
      B: "a,3,f+2,2v,690",
      S: "9,2,k",
      WS: "c,k,4f4,1vk+a,u,1j,335",
      ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
      BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
      NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
      AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
      LRO: "6ct",
      RLO: "6cu",
      LRE: "6cq",
      RLE: "6cr",
      PDF: "6cs",
      LRI: "6ee",
      RLI: "6ef",
      FSI: "6eg",
      PDI: "6eh"
    }, i = {}, r = {};
    i.L = 1, r[1] = "L", Object.keys(n).forEach(function(B, $) {
      i[B] = 1 << $ + 1, r[i[B]] = B;
    }), Object.freeze(i);
    var o = i.LRI | i.RLI | i.FSI, a = i.L | i.R | i.AL, l = i.B | i.S | i.WS | i.ON | i.FSI | i.LRI | i.RLI | i.PDI, c = i.BN | i.RLE | i.LRE | i.RLO | i.LRO | i.PDF, u = i.S | i.WS | i.B | o | i.PDI | c, d = null;
    function h() {
      if (!d) {
        d = /* @__PURE__ */ new Map();
        var B = function(se) {
          if (n.hasOwnProperty(se)) {
            var U = 0;
            n[se].split(",").forEach(function(z) {
              var K = z.split("+"), ue = K[0], me = K[1];
              ue = parseInt(ue, 36), me = me ? parseInt(me, 36) : 0, d.set(U += ue, i[se]);
              for (var ge = 0; ge < me; ge++)
                d.set(++U, i[se]);
            });
          }
        };
        for (var $ in n) B($);
      }
    }
    function m(B) {
      return h(), d.get(B.codePointAt(0)) || i.L;
    }
    function p(B) {
      return r[m(B)];
    }
    var y = {
      pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
      canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
    };
    function _(B, $) {
      var se = 36, U = 0, z = /* @__PURE__ */ new Map(), K = $ && /* @__PURE__ */ new Map(), ue;
      return B.split(",").forEach(function me(ge) {
        if (ge.indexOf("+") !== -1)
          for (var Me = +ge; Me--; )
            me(ue);
        else {
          ue = ge;
          var Te = ge.split(">"), Ae = Te[0], Xe = Te[1];
          Ae = String.fromCodePoint(U += parseInt(Ae, se)), Xe = String.fromCodePoint(U += parseInt(Xe, se)), z.set(Ae, Xe), $ && K.set(Xe, Ae);
        }
      }), { map: z, reverseMap: K };
    }
    var v, g, S;
    function w() {
      if (!v) {
        var B = _(y.pairs, !0), $ = B.map, se = B.reverseMap;
        v = $, g = se, S = _(y.canonical, !1).map;
      }
    }
    function x(B) {
      return w(), v.get(B) || null;
    }
    function C(B) {
      return w(), g.get(B) || null;
    }
    function E(B) {
      return w(), S.get(B) || null;
    }
    var P = i.L, T = i.R, b = i.EN, M = i.ES, L = i.ET, N = i.AN, D = i.CS, O = i.B, A = i.S, G = i.ON, he = i.BN, ee = i.NSM, le = i.AL, oe = i.LRO, Y = i.RLO, j = i.LRE, q = i.RLE, te = i.PDF, ne = i.LRI, de = i.RLI, H = i.FSI, X = i.PDI;
    function V(B, $) {
      for (var se = 125, U = new Uint32Array(B.length), z = 0; z < B.length; z++)
        U[z] = m(B[z]);
      var K = /* @__PURE__ */ new Map();
      function ue(oi, Ri) {
        var ai = U[oi];
        U[oi] = Ri, K.set(ai, K.get(ai) - 1), ai & l && K.set(l, K.get(l) - 1), K.set(Ri, (K.get(Ri) || 0) + 1), Ri & l && K.set(l, (K.get(l) || 0) + 1);
      }
      for (var me = new Uint8Array(B.length), ge = /* @__PURE__ */ new Map(), Me = [], Te = null, Ae = 0; Ae < B.length; Ae++)
        Te || Me.push(Te = {
          start: Ae,
          end: B.length - 1,
          // 3.3.1 P2-P3: Determine the paragraph level
          level: $ === "rtl" ? 1 : $ === "ltr" ? 0 : np(Ae, !1)
        }), U[Ae] & O && (Te.end = Ae, Te = null);
      for (var Xe = q | j | Y | oe | o | X | te | O, Fe = function(oi) {
        return oi + (oi & 1 ? 1 : 2);
      }, He = function(oi) {
        return oi + (oi & 1 ? 2 : 1);
      }, Ye = 0; Ye < Me.length; Ye++) {
        Te = Me[Ye];
        var We = [{
          _level: Te.level,
          _override: 0,
          //0=neutral, 1=L, 2=R
          _isolate: 0
          //bool
        }], ke = void 0, nt = 0, Je = 0, _t = 0;
        K.clear();
        for (var we = Te.start; we <= Te.end; we++) {
          var ze = U[we];
          if (ke = We[We.length - 1], K.set(ze, (K.get(ze) || 0) + 1), ze & l && K.set(l, (K.get(l) || 0) + 1), ze & Xe)
            if (ze & (q | j)) {
              me[we] = ke._level;
              var De = (ze === q ? He : Fe)(ke._level);
              De <= se && !nt && !Je ? We.push({
                _level: De,
                _override: 0,
                _isolate: 0
              }) : nt || Je++;
            } else if (ze & (Y | oe)) {
              me[we] = ke._level;
              var Be = (ze === Y ? He : Fe)(ke._level);
              Be <= se && !nt && !Je ? We.push({
                _level: Be,
                _override: ze & Y ? T : P,
                _isolate: 0
              }) : nt || Je++;
            } else if (ze & o) {
              ze & H && (ze = np(we + 1, !0) === 1 ? de : ne), me[we] = ke._level, ke._override && ue(we, ke._override);
              var je = (ze === de ? He : Fe)(ke._level);
              je <= se && nt === 0 && Je === 0 ? (_t++, We.push({
                _level: je,
                _override: 0,
                _isolate: 1,
                _isolInitIndex: we
              })) : nt++;
            } else if (ze & X) {
              if (nt > 0)
                nt--;
              else if (_t > 0) {
                for (Je = 0; !We[We.length - 1]._isolate; )
                  We.pop();
                var Ve = We[We.length - 1]._isolInitIndex;
                Ve != null && (ge.set(Ve, we), ge.set(we, Ve)), We.pop(), _t--;
              }
              ke = We[We.length - 1], me[we] = ke._level, ke._override && ue(we, ke._override);
            } else ze & te ? (nt === 0 && (Je > 0 ? Je-- : !ke._isolate && We.length > 1 && (We.pop(), ke = We[We.length - 1])), me[we] = ke._level) : ze & O && (me[we] = Te.level);
          else
            me[we] = ke._level, ke._override && ze !== he && ue(we, ke._override);
        }
        for (var lt = [], rt = null, ut = Te.start; ut <= Te.end; ut++) {
          var pt = U[ut];
          if (!(pt & c)) {
            var Ot = me[ut], Kt = pt & o, sn = pt === X;
            rt && Ot === rt._level ? (rt._end = ut, rt._endsWithIsolInit = Kt) : lt.push(rt = {
              _start: ut,
              _end: ut,
              _level: Ot,
              _startsWithPDI: sn,
              _endsWithIsolInit: Kt
            });
          }
        }
        for (var Un = [], xn = 0; xn < lt.length; xn++) {
          var Yn = lt[xn];
          if (!Yn._startsWithPDI || Yn._startsWithPDI && !ge.has(Yn._start)) {
            for (var hi = [rt = Yn], fi = void 0; rt && rt._endsWithIsolInit && (fi = ge.get(rt._end)) != null; )
              for (var On = xn + 1; On < lt.length; On++)
                if (lt[On]._start === fi) {
                  hi.push(rt = lt[On]);
                  break;
                }
            for (var bn = [], ni = 0; ni < hi.length; ni++)
              for (var Pi = hi[ni], fe = Pi._start; fe <= Pi._end; fe++)
                bn.push(fe);
            for (var _e = me[bn[0]], Ee = Te.level, Le = bn[0] - 1; Le >= 0; Le--)
              if (!(U[Le] & c)) {
                Ee = me[Le];
                break;
              }
            var W = bn[bn.length - 1], ve = me[W], ye = Te.level;
            if (!(U[W] & o)) {
              for (var Ce = W + 1; Ce <= Te.end; Ce++)
                if (!(U[Ce] & c)) {
                  ye = me[Ce];
                  break;
                }
            }
            Un.push({
              _seqIndices: bn,
              _sosType: Math.max(Ee, _e) % 2 ? T : P,
              _eosType: Math.max(ye, ve) % 2 ? T : P
            });
          }
        }
        for (var xe = 0; xe < Un.length; xe++) {
          var Ie = Un[xe], Re = Ie._seqIndices, Qe = Ie._sosType, it = Ie._eosType, mt = me[Re[0]] & 1 ? T : P;
          if (K.get(ee))
            for (var gt = 0; gt < Re.length; gt++) {
              var ot = Re[gt];
              if (U[ot] & ee) {
                for (var Dt = Qe, Vt = gt - 1; Vt >= 0; Vt--)
                  if (!(U[Re[Vt]] & c)) {
                    Dt = U[Re[Vt]];
                    break;
                  }
                ue(ot, Dt & (o | X) ? G : Dt);
              }
            }
          if (K.get(b))
            for (var Gt = 0; Gt < Re.length; Gt++) {
              var An = Re[Gt];
              if (U[An] & b)
                for (var It = Gt - 1; It >= -1; It--) {
                  var dt = It === -1 ? Qe : U[Re[It]];
                  if (dt & a) {
                    dt === le && ue(An, N);
                    break;
                  }
                }
            }
          if (K.get(le))
            for (var pi = 0; pi < Re.length; pi++) {
              var Lt = Re[pi];
              U[Lt] & le && ue(Lt, T);
            }
          if (K.get(M) || K.get(D))
            for (var Pn = 1; Pn < Re.length - 1; Pn++) {
              var Xi = Re[Pn];
              if (U[Xi] & (M | D)) {
                for (var wn = 0, rs = 0, Yt = Pn - 1; Yt >= 0 && (wn = U[Re[Yt]], !!(wn & c)); Yt--)
                  ;
                for (var ii = Pn + 1; ii < Re.length && (rs = U[Re[ii]], !!(rs & c)); ii++)
                  ;
                wn === rs && (U[Xi] === M ? wn === b : wn & (b | N)) && ue(Xi, wn);
              }
            }
          if (K.get(b))
            for (var zn = 0; zn < Re.length; zn++) {
              var si = Re[zn];
              if (U[si] & b) {
                for (var mi = zn - 1; mi >= 0 && U[Re[mi]] & (L | c); mi--)
                  ue(Re[mi], b);
                for (zn++; zn < Re.length && U[Re[zn]] & (L | c | b); zn++)
                  U[Re[zn]] !== b && ue(Re[zn], b);
              }
            }
          if (K.get(L) || K.get(M) || K.get(D))
            for (var ri = 0; ri < Re.length; ri++) {
              var Yo = Re[ri];
              if (U[Yo] & (L | M | D)) {
                ue(Yo, G);
                for (var xl = ri - 1; xl >= 0 && U[Re[xl]] & c; xl--)
                  ue(Re[xl], G);
                for (var bl = ri + 1; bl < Re.length && U[Re[bl]] & c; bl++)
                  ue(Re[bl], G);
              }
            }
          if (K.get(b))
            for (var Su = 0, Wf = Qe; Su < Re.length; Su++) {
              var $f = Re[Su], Mu = U[$f];
              Mu & b ? Wf === P && ue($f, P) : Mu & a && (Wf = Mu);
            }
          if (K.get(l)) {
            var qo = T | b | N, Xf = qo | P, wl = [];
            {
              for (var Hr = [], Wr = 0; Wr < Re.length; Wr++)
                if (U[Re[Wr]] & l) {
                  var Zo = B[Re[Wr]], jf = void 0;
                  if (x(Zo) !== null)
                    if (Hr.length < 63)
                      Hr.push({ char: Zo, seqIndex: Wr });
                    else
                      break;
                  else if ((jf = C(Zo)) !== null)
                    for (var Ko = Hr.length - 1; Ko >= 0; Ko--) {
                      var Cu = Hr[Ko].char;
                      if (Cu === jf || Cu === C(E(Zo)) || x(E(Cu)) === Zo) {
                        wl.push([Hr[Ko].seqIndex, Wr]), Hr.length = Ko;
                        break;
                      }
                    }
                }
              wl.sort(function(oi, Ri) {
                return oi[0] - Ri[0];
              });
            }
            for (var Eu = 0; Eu < wl.length; Eu++) {
              for (var Yf = wl[Eu], Sl = Yf[0], Tu = Yf[1], qf = !1, Di = 0, Au = Sl + 1; Au < Tu; Au++) {
                var Zf = Re[Au];
                if (U[Zf] & Xf) {
                  qf = !0;
                  var Kf = U[Zf] & qo ? T : P;
                  if (Kf === mt) {
                    Di = Kf;
                    break;
                  }
                }
              }
              if (qf && !Di) {
                Di = Qe;
                for (var Pu = Sl - 1; Pu >= 0; Pu--) {
                  var Jf = Re[Pu];
                  if (U[Jf] & Xf) {
                    var Qf = U[Jf] & qo ? T : P;
                    Qf !== mt ? Di = Qf : Di = mt;
                    break;
                  }
                }
              }
              if (Di) {
                if (U[Re[Sl]] = U[Re[Tu]] = Di, Di !== mt) {
                  for (var Jo = Sl + 1; Jo < Re.length; Jo++)
                    if (!(U[Re[Jo]] & c)) {
                      m(B[Re[Jo]]) & ee && (U[Re[Jo]] = Di);
                      break;
                    }
                }
                if (Di !== mt) {
                  for (var Qo = Tu + 1; Qo < Re.length; Qo++)
                    if (!(U[Re[Qo]] & c)) {
                      m(B[Re[Qo]]) & ee && (U[Re[Qo]] = Di);
                      break;
                    }
                }
              }
            }
            for (var ks = 0; ks < Re.length; ks++)
              if (U[Re[ks]] & l) {
                for (var ep = ks, Du = ks, Ru = Qe, ea = ks - 1; ea >= 0; ea--)
                  if (U[Re[ea]] & c)
                    ep = ea;
                  else {
                    Ru = U[Re[ea]] & qo ? T : P;
                    break;
                  }
                for (var tp = it, ta = ks + 1; ta < Re.length; ta++)
                  if (U[Re[ta]] & (l | c))
                    Du = ta;
                  else {
                    tp = U[Re[ta]] & qo ? T : P;
                    break;
                  }
                for (var Iu = ep; Iu <= Du; Iu++)
                  U[Re[Iu]] = Ru === tp ? Ru : mt;
                ks = Du;
              }
          }
        }
        for (var vi = Te.start; vi <= Te.end; vi++) {
          var zy = me[vi], Ml = U[vi];
          if (zy & 1 ? Ml & (P | b | N) && me[vi]++ : Ml & T ? me[vi]++ : Ml & (N | b) && (me[vi] += 2), Ml & c && (me[vi] = vi === 0 ? Te.level : me[vi - 1]), vi === Te.end || m(B[vi]) & (A | O))
            for (var Cl = vi; Cl >= 0 && m(B[Cl]) & u; Cl--)
              me[Cl] = Te.level;
        }
      }
      return {
        levels: me,
        paragraphs: Me
      };
      function np(oi, Ri) {
        for (var ai = oi; ai < B.length; ai++) {
          var Ls = U[ai];
          if (Ls & (T | le))
            return 1;
          if (Ls & (O | P) || Ri && Ls === X)
            return 0;
          if (Ls & o) {
            var ip = Ny(ai);
            ai = ip === -1 ? B.length : ip;
          }
        }
        return 0;
      }
      function Ny(oi) {
        for (var Ri = 1, ai = oi + 1; ai < B.length; ai++) {
          var Ls = U[ai];
          if (Ls & O)
            break;
          if (Ls & X) {
            if (--Ri === 0)
              return ai;
          } else Ls & o && Ri++;
        }
        return -1;
      }
    }
    var I = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1", F;
    function k() {
      if (!F) {
        var B = _(I, !0), $ = B.map, se = B.reverseMap;
        se.forEach(function(U, z) {
          $.set(z, U);
        }), F = $;
      }
    }
    function Q(B) {
      return k(), F.get(B) || null;
    }
    function Z(B, $, se, U) {
      var z = B.length;
      se = Math.max(0, se == null ? 0 : +se), U = Math.min(z - 1, U == null ? z - 1 : +U);
      for (var K = /* @__PURE__ */ new Map(), ue = se; ue <= U; ue++)
        if ($[ue] & 1) {
          var me = Q(B[ue]);
          me !== null && K.set(ue, me);
        }
      return K;
    }
    function R(B, $, se, U) {
      var z = B.length;
      se = Math.max(0, se == null ? 0 : +se), U = Math.min(z - 1, U == null ? z - 1 : +U);
      var K = [];
      return $.paragraphs.forEach(function(ue) {
        var me = Math.max(se, ue.start), ge = Math.min(U, ue.end);
        if (me < ge) {
          for (var Me = $.levels.slice(me, ge + 1), Te = ge; Te >= me && m(B[Te]) & u; Te--)
            Me[Te] = ue.level;
          for (var Ae = ue.level, Xe = 1 / 0, Fe = 0; Fe < Me.length; Fe++) {
            var He = Me[Fe];
            He > Ae && (Ae = He), He < Xe && (Xe = He | 1);
          }
          for (var Ye = Ae; Ye >= Xe; Ye--)
            for (var We = 0; We < Me.length; We++)
              if (Me[We] >= Ye) {
                for (var ke = We; We + 1 < Me.length && Me[We + 1] >= Ye; )
                  We++;
                We > ke && K.push([ke + me, We + me]);
              }
        }
      }), K;
    }
    function ie(B, $, se, U) {
      var z = J(B, $, se, U), K = [].concat(B);
      return z.forEach(function(ue, me) {
        K[me] = ($.levels[ue] & 1 ? Q(B[ue]) : null) || B[ue];
      }), K.join("");
    }
    function J(B, $, se, U) {
      for (var z = R(B, $, se, U), K = [], ue = 0; ue < B.length; ue++)
        K[ue] = ue;
      return z.forEach(function(me) {
        for (var ge = me[0], Me = me[1], Te = K.slice(ge, Me + 1), Ae = Te.length; Ae--; )
          K[Me - Ae] = Te[Ae];
      }), K;
    }
    return e.closingToOpeningBracket = C, e.getBidiCharType = m, e.getBidiCharTypeName = p, e.getCanonicalBracket = E, e.getEmbeddingLevels = V, e.getMirroredCharacter = Q, e.getMirroredCharactersMap = Z, e.getReorderSegments = R, e.getReorderedIndices = J, e.getReorderedString = ie, e.openingToClosingBracket = x, Object.defineProperty(e, "__esModule", { value: !0 }), e;
  }({});
  return s;
}
const _y = /\bvoid\s+main\s*\(\s*\)\s*{/g;
function Hh(s) {
  const e = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function n(i, r) {
    let o = Tt[r];
    return o ? Hh(o) : i;
  }
  return s.replace(e, n);
}
const Dn = [];
for (let s = 0; s < 256; s++)
  Dn[s] = (s < 16 ? "0" : "") + s.toString(16);
function p6() {
  const s = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Dn[s & 255] + Dn[s >> 8 & 255] + Dn[s >> 16 & 255] + Dn[s >> 24 & 255] + "-" + Dn[e & 255] + Dn[e >> 8 & 255] + "-" + Dn[e >> 16 & 15 | 64] + Dn[e >> 24 & 255] + "-" + Dn[n & 63 | 128] + Dn[n >> 8 & 255] + "-" + Dn[n >> 16 & 255] + Dn[n >> 24 & 255] + Dn[i & 255] + Dn[i >> 8 & 255] + Dn[i >> 16 & 255] + Dn[i >> 24 & 255]).toUpperCase();
}
const yr = Object.assign || function() {
  let s = arguments[0];
  for (let e = 1, n = arguments.length; e < n; e++) {
    let i = arguments[e];
    if (i)
      for (let r in i)
        Object.prototype.hasOwnProperty.call(i, r) && (s[r] = i[r]);
  }
  return s;
}, m6 = Date.now(), Cv = /* @__PURE__ */ new WeakMap(), Ev = /* @__PURE__ */ new Map();
let v6 = 1e10;
function Wh(s, e) {
  const n = x6(e);
  let i = Cv.get(s);
  if (i || Cv.set(s, i = /* @__PURE__ */ Object.create(null)), i[n])
    return new i[n]();
  const r = `_onBeforeCompile${n}`, o = function(u, d) {
    s.onBeforeCompile.call(this, u, d);
    const h = this.customProgramCacheKey() + "|" + u.vertexShader + "|" + u.fragmentShader;
    let m = Ev[h];
    if (!m) {
      const p = g6(this, u, e, n);
      m = Ev[h] = p;
    }
    u.vertexShader = m.vertexShader, u.fragmentShader = m.fragmentShader, yr(u.uniforms, this.uniforms), e.timeUniform && (u.uniforms[e.timeUniform] = {
      get value() {
        return Date.now() - m6;
      }
    }), this[r] && this[r](u);
  }, a = function() {
    return l(e.chained ? s : s.clone());
  }, l = function(u) {
    const d = Object.create(u, c);
    return Object.defineProperty(d, "baseMaterial", { value: s }), Object.defineProperty(d, "id", { value: v6++ }), d.uuid = p6(), d.uniforms = yr({}, u.uniforms, e.uniforms), d.defines = yr({}, u.defines, e.defines), d.defines[`TROIKA_DERIVED_MATERIAL_${n}`] = "", d.extensions = yr({}, u.extensions, e.extensions), d._listeners = void 0, d;
  }, c = {
    constructor: { value: a },
    isDerivedMaterial: { value: !0 },
    type: {
      get: () => s.type,
      set: (u) => {
        s.type = u;
      }
    },
    isDerivedFrom: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        const d = this.baseMaterial;
        return u === d || d.isDerivedMaterial && d.isDerivedFrom(u) || !1;
      }
    },
    customProgramCacheKey: {
      writable: !0,
      configurable: !0,
      value: function() {
        return s.customProgramCacheKey() + "|" + n;
      }
    },
    onBeforeCompile: {
      get() {
        return o;
      },
      set(u) {
        this[r] = u;
      }
    },
    copy: {
      writable: !0,
      configurable: !0,
      value: function(u) {
        return s.copy.call(this, u), !s.isShaderMaterial && !s.isDerivedMaterial && (yr(this.extensions, u.extensions), yr(this.defines, u.defines), yr(this.uniforms, ml.clone(u.uniforms))), this;
      }
    },
    clone: {
      writable: !0,
      configurable: !0,
      value: function() {
        const u = new s.constructor();
        return l(u).copy(this);
      }
    },
    /**
     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDepthMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._depthMaterial;
        return u || (u = this._depthMaterial = Wh(
          s.isDerivedMaterial ? s.getDepthMaterial() : new Tf({ depthPacking: _f }),
          e
        ), u.defines.IS_DEPTH_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    /**
     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex
     * transformations and discarded fragments.
     */
    getDistanceMaterial: {
      writable: !0,
      configurable: !0,
      value: function() {
        let u = this._distanceMaterial;
        return u || (u = this._distanceMaterial = Wh(
          s.isDerivedMaterial ? s.getDistanceMaterial() : new J0(),
          e
        ), u.defines.IS_DISTANCE_MATERIAL = "", u.uniforms = this.uniforms), u;
      }
    },
    dispose: {
      writable: !0,
      configurable: !0,
      value() {
        const { _depthMaterial: u, _distanceMaterial: d } = this;
        u && u.dispose(), d && d.dispose(), s.dispose.call(this);
      }
    }
  };
  return i[n] = a, new a();
}
function g6(s, { vertexShader: e, fragmentShader: n }, i, r) {
  let {
    vertexDefs: o,
    vertexMainIntro: a,
    vertexMainOutro: l,
    vertexTransform: c,
    fragmentDefs: u,
    fragmentMainIntro: d,
    fragmentMainOutro: h,
    fragmentColorTransform: m,
    customRewriter: p,
    timeUniform: y
  } = i;
  if (o = o || "", a = a || "", l = l || "", u = u || "", d = d || "", h = h || "", (c || p) && (e = Hh(e)), (m || p) && (n = n.replace(
    /^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,
    `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`
  ), n = Hh(n)), p) {
    let _ = p({ vertexShader: e, fragmentShader: n });
    e = _.vertexShader, n = _.fragmentShader;
  }
  if (m) {
    let _ = [];
    n = n.replace(
      /^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm,
      // [^]+? = non-greedy match of any chars including newlines
      (v) => (_.push(v), "")
    ), h = `${m}
${_.join(`
`)}
${h}`;
  }
  if (y) {
    const _ = `
uniform float ${y};
`;
    o = _ + o, u = _ + u;
  }
  return c && (e = `vec3 troika_position_${r};
vec3 troika_normal_${r};
vec2 troika_uv_${r};
${e}
`, o = `${o}
void troikaVertexTransform${r}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${c}
}
`, a = `
troika_position_${r} = vec3(position);
troika_normal_${r} = vec3(normal);
troika_uv_${r} = vec2(uv);
troikaVertexTransform${r}(troika_position_${r}, troika_normal_${r}, troika_uv_${r});
${a}
`, e = e.replace(/\b(position|normal|uv)\b/g, (_, v, g, S) => /\battribute\s+vec[23]\s+$/.test(S.substr(0, g)) ? v : `troika_${v}_${r}`), s.map && s.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${r}`))), e = Tv(e, r, o, a, l), n = Tv(n, r, u, d, h), {
    vertexShader: e,
    fragmentShader: n
  };
}
function Tv(s, e, n, i, r) {
  return (i || r || n) && (s = s.replace(
    _y,
    `
${n}
void troikaOrigMain${e}() {`
  ), s += `
void main() {
  ${i}
  troikaOrigMain${e}();
  ${r}
}`), s;
}
function y6(s, e) {
  return s === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e;
}
let _6 = 0;
const Av = /* @__PURE__ */ new Map();
function x6(s) {
  const e = JSON.stringify(s, y6);
  let n = Av.get(e);
  return n == null && Av.set(e, n = ++_6), n;
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function b6() {
  return typeof window > "u" && (self.window = self), function(s) {
    var e = { parse: function(r) {
      var o = e._bin, a = new Uint8Array(r);
      if (o.readASCII(a, 0, 4) == "ttcf") {
        var l = 4;
        o.readUshort(a, l), l += 2, o.readUshort(a, l), l += 2;
        var c = o.readUint(a, l);
        l += 4;
        for (var u = [], d = 0; d < c; d++) {
          var h = o.readUint(a, l);
          l += 4, u.push(e._readFont(a, h));
        }
        return u;
      }
      return [e._readFont(a, 0)];
    }, _readFont: function(r, o) {
      var a = e._bin, l = o;
      a.readFixed(r, o), o += 4;
      var c = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2;
      for (var u = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], d = { _data: r, _offset: l }, h = {}, m = 0; m < c; m++) {
        var p = a.readASCII(r, o, 4);
        o += 4, a.readUint(r, o), o += 4;
        var y = a.readUint(r, o);
        o += 4;
        var _ = a.readUint(r, o);
        o += 4, h[p] = { offset: y, length: _ };
      }
      for (m = 0; m < u.length; m++) {
        var v = u[m];
        h[v] && (d[v.trim()] = e[v.trim()].parse(r, h[v].offset, h[v].length, d));
      }
      return d;
    }, _tabOffset: function(r, o, a) {
      for (var l = e._bin, c = l.readUshort(r, a + 4), u = a + 12, d = 0; d < c; d++) {
        var h = l.readASCII(r, u, 4);
        u += 4, l.readUint(r, u), u += 4;
        var m = l.readUint(r, u);
        if (u += 4, l.readUint(r, u), u += 4, h == o) return m;
      }
      return 0;
    } };
    e._bin = { readFixed: function(r, o) {
      return (r[o] << 8 | r[o + 1]) + (r[o + 2] << 8 | r[o + 3]) / 65540;
    }, readF2dot14: function(r, o) {
      return e._bin.readShort(r, o) / 16384;
    }, readInt: function(r, o) {
      return e._bin._view(r).getInt32(o);
    }, readInt8: function(r, o) {
      return e._bin._view(r).getInt8(o);
    }, readShort: function(r, o) {
      return e._bin._view(r).getInt16(o);
    }, readUshort: function(r, o) {
      return e._bin._view(r).getUint16(o);
    }, readUshorts: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(e._bin.readUshort(r, o + 2 * c));
      return l;
    }, readUint: function(r, o) {
      return e._bin._view(r).getUint32(o);
    }, readUint64: function(r, o) {
      return 4294967296 * e._bin.readUint(r, o) + e._bin.readUint(r, o + 4);
    }, readASCII: function(r, o, a) {
      for (var l = "", c = 0; c < a; c++) l += String.fromCharCode(r[o + c]);
      return l;
    }, readUnicode: function(r, o, a) {
      for (var l = "", c = 0; c < a; c++) {
        var u = r[o++] << 8 | r[o++];
        l += String.fromCharCode(u);
      }
      return l;
    }, _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder() : null, readUTF8: function(r, o, a) {
      var l = e._bin._tdec;
      return l && o == 0 && a == r.length ? l.decode(r) : e._bin.readASCII(r, o, a);
    }, readBytes: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(r[o + c]);
      return l;
    }, readASCIIArray: function(r, o, a) {
      for (var l = [], c = 0; c < a; c++) l.push(String.fromCharCode(r[o + c]));
      return l;
    }, _view: function(r) {
      return r._dataView || (r._dataView = r.buffer ? new DataView(r.buffer, r.byteOffset, r.byteLength) : new DataView(new Uint8Array(r).buffer));
    } }, e._lctf = {}, e._lctf.parse = function(r, o, a, l, c) {
      var u = e._bin, d = {}, h = o;
      u.readFixed(r, o), o += 4;
      var m = u.readUshort(r, o);
      o += 2;
      var p = u.readUshort(r, o);
      o += 2;
      var y = u.readUshort(r, o);
      return o += 2, d.scriptList = e._lctf.readScriptList(r, h + m), d.featureList = e._lctf.readFeatureList(r, h + p), d.lookupList = e._lctf.readLookupList(r, h + y, c), d;
    }, e._lctf.readLookupList = function(r, o, a) {
      var l = e._bin, c = o, u = [], d = l.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        var m = l.readUshort(r, o);
        o += 2;
        var p = e._lctf.readLookupTable(r, c + m, a);
        u.push(p);
      }
      return u;
    }, e._lctf.readLookupTable = function(r, o, a) {
      var l = e._bin, c = o, u = { tabs: [] };
      u.ltype = l.readUshort(r, o), o += 2, u.flag = l.readUshort(r, o), o += 2;
      var d = l.readUshort(r, o);
      o += 2;
      for (var h = u.ltype, m = 0; m < d; m++) {
        var p = l.readUshort(r, o);
        o += 2;
        var y = a(r, h, c + p, u);
        u.tabs.push(y);
      }
      return u;
    }, e._lctf.numOfOnes = function(r) {
      for (var o = 0, a = 0; a < 32; a++) r >>> a & 1 && o++;
      return o;
    }, e._lctf.readClassDef = function(r, o) {
      var a = e._bin, l = [], c = a.readUshort(r, o);
      if (o += 2, c == 1) {
        var u = a.readUshort(r, o);
        o += 2;
        var d = a.readUshort(r, o);
        o += 2;
        for (var h = 0; h < d; h++) l.push(u + h), l.push(u + h), l.push(a.readUshort(r, o)), o += 2;
      }
      if (c == 2) {
        var m = a.readUshort(r, o);
        for (o += 2, h = 0; h < m; h++) l.push(a.readUshort(r, o)), o += 2, l.push(a.readUshort(r, o)), o += 2, l.push(a.readUshort(r, o)), o += 2;
      }
      return l;
    }, e._lctf.getInterval = function(r, o) {
      for (var a = 0; a < r.length; a += 3) {
        var l = r[a], c = r[a + 1];
        if (r[a + 2], l <= o && o <= c) return a;
      }
      return -1;
    }, e._lctf.readCoverage = function(r, o) {
      var a = e._bin, l = {};
      l.fmt = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      return o += 2, l.fmt == 1 && (l.tab = a.readUshorts(r, o, c)), l.fmt == 2 && (l.tab = a.readUshorts(r, o, 3 * c)), l;
    }, e._lctf.coverageIndex = function(r, o) {
      var a = r.tab;
      if (r.fmt == 1) return a.indexOf(o);
      if (r.fmt == 2) {
        var l = e._lctf.getInterval(a, o);
        if (l != -1) return a[l + 2] + (o - a[l]);
      }
      return -1;
    }, e._lctf.readFeatureList = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readASCII(r, o, 4);
        o += 4;
        var m = a.readUshort(r, o);
        o += 2;
        var p = e._lctf.readFeatureTable(r, l + m);
        p.tag = h.trim(), c.push(p);
      }
      return c;
    }, e._lctf.readFeatureTable = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2, u > 0 && (c.featureParams = l + u);
      var d = a.readUshort(r, o);
      o += 2, c.tab = [];
      for (var h = 0; h < d; h++) c.tab.push(a.readUshort(r, o + 2 * h));
      return c;
    }, e._lctf.readScriptList = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readASCII(r, o, 4);
        o += 4;
        var m = a.readUshort(r, o);
        o += 2, c[h.trim()] = e._lctf.readScriptTable(r, l + m);
      }
      return c;
    }, e._lctf.readScriptTable = function(r, o) {
      var a = e._bin, l = o, c = {}, u = a.readUshort(r, o);
      o += 2, u > 0 && (c.default = e._lctf.readLangSysTable(r, l + u));
      var d = a.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        var m = a.readASCII(r, o, 4);
        o += 4;
        var p = a.readUshort(r, o);
        o += 2, c[m.trim()] = e._lctf.readLangSysTable(r, l + p);
      }
      return c;
    }, e._lctf.readLangSysTable = function(r, o) {
      var a = e._bin, l = {};
      a.readUshort(r, o), o += 2, l.reqFeature = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      return o += 2, l.features = a.readUshorts(r, o, c), l;
    }, e.CFF = {}, e.CFF.parse = function(r, o, a) {
      var l = e._bin;
      (r = new Uint8Array(r.buffer, o, a))[o = 0], r[++o], r[++o], r[++o], o++;
      var c = [];
      o = e.CFF.readIndex(r, o, c);
      for (var u = [], d = 0; d < c.length - 1; d++) u.push(l.readASCII(r, o + c[d], c[d + 1] - c[d]));
      o += c[c.length - 1];
      var h = [];
      o = e.CFF.readIndex(r, o, h);
      var m = [];
      for (d = 0; d < h.length - 1; d++) m.push(e.CFF.readDict(r, o + h[d], o + h[d + 1]));
      o += h[h.length - 1];
      var p = m[0], y = [];
      o = e.CFF.readIndex(r, o, y);
      var _ = [];
      for (d = 0; d < y.length - 1; d++) _.push(l.readASCII(r, o + y[d], y[d + 1] - y[d]));
      if (o += y[y.length - 1], e.CFF.readSubrs(r, o, p), p.CharStrings) {
        o = p.CharStrings, y = [], o = e.CFF.readIndex(r, o, y);
        var v = [];
        for (d = 0; d < y.length - 1; d++) v.push(l.readBytes(r, o + y[d], y[d + 1] - y[d]));
        p.CharStrings = v;
      }
      if (p.ROS) {
        o = p.FDArray;
        var g = [];
        for (o = e.CFF.readIndex(r, o, g), p.FDArray = [], d = 0; d < g.length - 1; d++) {
          var S = e.CFF.readDict(r, o + g[d], o + g[d + 1]);
          e.CFF._readFDict(r, S, _), p.FDArray.push(S);
        }
        o += g[g.length - 1], o = p.FDSelect, p.FDSelect = [];
        var w = r[o];
        if (o++, w != 3) throw w;
        var x = l.readUshort(r, o);
        for (o += 2, d = 0; d < x + 1; d++) p.FDSelect.push(l.readUshort(r, o), r[o + 2]), o += 3;
      }
      return p.Encoding && (p.Encoding = e.CFF.readEncoding(r, p.Encoding, p.CharStrings.length)), p.charset && (p.charset = e.CFF.readCharset(r, p.charset, p.CharStrings.length)), e.CFF._readFDict(r, p, _), p;
    }, e.CFF._readFDict = function(r, o, a) {
      var l;
      for (var c in o.Private && (l = o.Private[1], o.Private = e.CFF.readDict(r, l, l + o.Private[0]), o.Private.Subrs && e.CFF.readSubrs(r, l + o.Private.Subrs, o.Private)), o) ["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(c) != -1 && (o[c] = a[o[c] - 426 + 35]);
    }, e.CFF.readSubrs = function(r, o, a) {
      var l = e._bin, c = [];
      o = e.CFF.readIndex(r, o, c);
      var u, d = c.length;
      u = d < 1240 ? 107 : d < 33900 ? 1131 : 32768, a.Bias = u, a.Subrs = [];
      for (var h = 0; h < c.length - 1; h++) a.Subrs.push(l.readBytes(r, o + c[h], c[h + 1] - c[h]));
    }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(r, o) {
      for (var a = 0; a < r.charset.length; a++) if (r.charset[a] == o) return a;
      return -1;
    }, e.CFF.glyphBySE = function(r, o) {
      return o < 0 || o > 255 ? -1 : e.CFF.glyphByUnicode(r, e.CFF.tableSE[o]);
    }, e.CFF.readEncoding = function(r, o, a) {
      e._bin;
      var l = [".notdef"], c = r[o];
      if (o++, c != 0) throw "error: unknown encoding format: " + c;
      var u = r[o];
      o++;
      for (var d = 0; d < u; d++) l.push(r[o + d]);
      return l;
    }, e.CFF.readCharset = function(r, o, a) {
      var l = e._bin, c = [".notdef"], u = r[o];
      if (o++, u == 0) for (var d = 0; d < a; d++) {
        var h = l.readUshort(r, o);
        o += 2, c.push(h);
      }
      else {
        if (u != 1 && u != 2) throw "error: format: " + u;
        for (; c.length < a; ) {
          h = l.readUshort(r, o), o += 2;
          var m = 0;
          for (u == 1 ? (m = r[o], o++) : (m = l.readUshort(r, o), o += 2), d = 0; d <= m; d++) c.push(h), h++;
        }
      }
      return c;
    }, e.CFF.readIndex = function(r, o, a) {
      var l = e._bin, c = l.readUshort(r, o) + 1, u = r[o += 2];
      if (o++, u == 1) for (var d = 0; d < c; d++) a.push(r[o + d]);
      else if (u == 2) for (d = 0; d < c; d++) a.push(l.readUshort(r, o + 2 * d));
      else if (u == 3) for (d = 0; d < c; d++) a.push(16777215 & l.readUint(r, o + 3 * d - 1));
      else if (c != 1) throw "unsupported offset size: " + u + ", count: " + c;
      return (o += c * u) - 1;
    }, e.CFF.getCharString = function(r, o, a) {
      var l = e._bin, c = r[o], u = r[o + 1];
      r[o + 2], r[o + 3], r[o + 4];
      var d = 1, h = null, m = null;
      c <= 20 && (h = c, d = 1), c == 12 && (h = 100 * c + u, d = 2), 21 <= c && c <= 27 && (h = c, d = 1), c == 28 && (m = l.readShort(r, o + 1), d = 3), 29 <= c && c <= 31 && (h = c, d = 1), 32 <= c && c <= 246 && (m = c - 139, d = 1), 247 <= c && c <= 250 && (m = 256 * (c - 247) + u + 108, d = 2), 251 <= c && c <= 254 && (m = 256 * -(c - 251) - u - 108, d = 2), c == 255 && (m = l.readInt(r, o + 1) / 65535, d = 5), a.val = m ?? "o" + h, a.size = d;
    }, e.CFF.readCharString = function(r, o, a) {
      for (var l = o + a, c = e._bin, u = []; o < l; ) {
        var d = r[o], h = r[o + 1];
        r[o + 2], r[o + 3], r[o + 4];
        var m = 1, p = null, y = null;
        d <= 20 && (p = d, m = 1), d == 12 && (p = 100 * d + h, m = 2), d != 19 && d != 20 || (p = d, m = 2), 21 <= d && d <= 27 && (p = d, m = 1), d == 28 && (y = c.readShort(r, o + 1), m = 3), 29 <= d && d <= 31 && (p = d, m = 1), 32 <= d && d <= 246 && (y = d - 139, m = 1), 247 <= d && d <= 250 && (y = 256 * (d - 247) + h + 108, m = 2), 251 <= d && d <= 254 && (y = 256 * -(d - 251) - h - 108, m = 2), d == 255 && (y = c.readInt(r, o + 1) / 65535, m = 5), u.push(y ?? "o" + p), o += m;
      }
      return u;
    }, e.CFF.readDict = function(r, o, a) {
      for (var l = e._bin, c = {}, u = []; o < a; ) {
        var d = r[o], h = r[o + 1];
        r[o + 2], r[o + 3], r[o + 4];
        var m = 1, p = null, y = null;
        if (d == 28 && (y = l.readShort(r, o + 1), m = 3), d == 29 && (y = l.readInt(r, o + 1), m = 5), 32 <= d && d <= 246 && (y = d - 139, m = 1), 247 <= d && d <= 250 && (y = 256 * (d - 247) + h + 108, m = 2), 251 <= d && d <= 254 && (y = 256 * -(d - 251) - h - 108, m = 2), d == 255) throw y = l.readInt(r, o + 1) / 65535, m = 5, "unknown number";
        if (d == 30) {
          var _ = [];
          for (m = 1; ; ) {
            var v = r[o + m];
            m++;
            var g = v >> 4, S = 15 & v;
            if (g != 15 && _.push(g), S != 15 && _.push(S), S == 15) break;
          }
          for (var w = "", x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], C = 0; C < _.length; C++) w += x[_[C]];
          y = parseFloat(w);
        }
        d <= 21 && (p = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][d], m = 1, d == 12 && (p = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][h], m = 2)), p != null ? (c[p] = u.length == 1 ? u[0] : u, u = []) : u.push(y), o += m;
      }
      return c;
    }, e.cmap = {}, e.cmap.parse = function(r, o, a) {
      r = new Uint8Array(r.buffer, o, a), o = 0;
      var l = e._bin, c = {};
      l.readUshort(r, o), o += 2;
      var u = l.readUshort(r, o);
      o += 2;
      var d = [];
      c.tables = [];
      for (var h = 0; h < u; h++) {
        var m = l.readUshort(r, o);
        o += 2;
        var p = l.readUshort(r, o);
        o += 2;
        var y = l.readUint(r, o);
        o += 4;
        var _ = "p" + m + "e" + p, v = d.indexOf(y);
        if (v == -1) {
          var g;
          v = c.tables.length, d.push(y);
          var S = l.readUshort(r, y);
          S == 0 ? g = e.cmap.parse0(r, y) : S == 4 ? g = e.cmap.parse4(r, y) : S == 6 ? g = e.cmap.parse6(r, y) : S == 12 ? g = e.cmap.parse12(r, y) : console.debug("unknown format: " + S, m, p, y), c.tables.push(g);
        }
        if (c[_] != null) throw "multiple tables for one platform+encoding";
        c[_] = v;
      }
      return c;
    }, e.cmap.parse0 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2, l.map = [];
      for (var u = 0; u < c - 6; u++) l.map.push(r[o + u]);
      return l;
    }, e.cmap.parse4 = function(r, o) {
      var a = e._bin, l = o, c = {};
      c.format = a.readUshort(r, o), o += 2;
      var u = a.readUshort(r, o);
      o += 2, a.readUshort(r, o), o += 2;
      var d = a.readUshort(r, o);
      o += 2;
      var h = d / 2;
      c.searchRange = a.readUshort(r, o), o += 2, c.entrySelector = a.readUshort(r, o), o += 2, c.rangeShift = a.readUshort(r, o), o += 2, c.endCount = a.readUshorts(r, o, h), o += 2 * h, o += 2, c.startCount = a.readUshorts(r, o, h), o += 2 * h, c.idDelta = [];
      for (var m = 0; m < h; m++) c.idDelta.push(a.readShort(r, o)), o += 2;
      for (c.idRangeOffset = a.readUshorts(r, o, h), o += 2 * h, c.glyphIdArray = []; o < l + u; ) c.glyphIdArray.push(a.readUshort(r, o)), o += 2;
      return c;
    }, e.cmap.parse6 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, a.readUshort(r, o), o += 2, l.firstCode = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2, l.glyphIdArray = [];
      for (var u = 0; u < c; u++) l.glyphIdArray.push(a.readUshort(r, o)), o += 2;
      return l;
    }, e.cmap.parse12 = function(r, o) {
      var a = e._bin, l = {};
      l.format = a.readUshort(r, o), o += 2, o += 2, a.readUint(r, o), o += 4, a.readUint(r, o), o += 4;
      var c = a.readUint(r, o);
      o += 4, l.groups = [];
      for (var u = 0; u < c; u++) {
        var d = o + 12 * u, h = a.readUint(r, d + 0), m = a.readUint(r, d + 4), p = a.readUint(r, d + 8);
        l.groups.push([h, m, p]);
      }
      return l;
    }, e.glyf = {}, e.glyf.parse = function(r, o, a, l) {
      for (var c = [], u = 0; u < l.maxp.numGlyphs; u++) c.push(null);
      return c;
    }, e.glyf._parseGlyf = function(r, o) {
      var a = e._bin, l = r._data, c = e._tabOffset(l, "glyf", r._offset) + r.loca[o];
      if (r.loca[o] == r.loca[o + 1]) return null;
      var u = {};
      if (u.noc = a.readShort(l, c), c += 2, u.xMin = a.readShort(l, c), c += 2, u.yMin = a.readShort(l, c), c += 2, u.xMax = a.readShort(l, c), c += 2, u.yMax = a.readShort(l, c), c += 2, u.xMin >= u.xMax || u.yMin >= u.yMax) return null;
      if (u.noc > 0) {
        u.endPts = [];
        for (var d = 0; d < u.noc; d++) u.endPts.push(a.readUshort(l, c)), c += 2;
        var h = a.readUshort(l, c);
        if (c += 2, l.length - c < h) return null;
        u.instructions = a.readBytes(l, c, h), c += h;
        var m = u.endPts[u.noc - 1] + 1;
        for (u.flags = [], d = 0; d < m; d++) {
          var p = l[c];
          if (c++, u.flags.push(p), (8 & p) != 0) {
            var y = l[c];
            c++;
            for (var _ = 0; _ < y; _++) u.flags.push(p), d++;
          }
        }
        for (u.xs = [], d = 0; d < m; d++) {
          var v = (2 & u.flags[d]) != 0, g = (16 & u.flags[d]) != 0;
          v ? (u.xs.push(g ? l[c] : -l[c]), c++) : g ? u.xs.push(0) : (u.xs.push(a.readShort(l, c)), c += 2);
        }
        for (u.ys = [], d = 0; d < m; d++)
          v = (4 & u.flags[d]) != 0, g = (32 & u.flags[d]) != 0, v ? (u.ys.push(g ? l[c] : -l[c]), c++) : g ? u.ys.push(0) : (u.ys.push(a.readShort(l, c)), c += 2);
        var S = 0, w = 0;
        for (d = 0; d < m; d++) S += u.xs[d], w += u.ys[d], u.xs[d] = S, u.ys[d] = w;
      } else {
        var x;
        u.parts = [];
        do {
          x = a.readUshort(l, c), c += 2;
          var C = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
          if (u.parts.push(C), C.glyphIndex = a.readUshort(l, c), c += 2, 1 & x) {
            var E = a.readShort(l, c);
            c += 2;
            var P = a.readShort(l, c);
            c += 2;
          } else
            E = a.readInt8(l, c), c++, P = a.readInt8(l, c), c++;
          2 & x ? (C.m.tx = E, C.m.ty = P) : (C.p1 = E, C.p2 = P), 8 & x ? (C.m.a = C.m.d = a.readF2dot14(l, c), c += 2) : 64 & x ? (C.m.a = a.readF2dot14(l, c), c += 2, C.m.d = a.readF2dot14(l, c), c += 2) : 128 & x && (C.m.a = a.readF2dot14(l, c), c += 2, C.m.b = a.readF2dot14(l, c), c += 2, C.m.c = a.readF2dot14(l, c), c += 2, C.m.d = a.readF2dot14(l, c), c += 2);
        } while (32 & x);
        if (256 & x) {
          var T = a.readUshort(l, c);
          for (c += 2, u.instr = [], d = 0; d < T; d++) u.instr.push(l[c]), c++;
        }
      }
      return u;
    }, e.GDEF = {}, e.GDEF.parse = function(r, o, a, l) {
      var c = o;
      o += 4;
      var u = e._bin.readUshort(r, o);
      return { glyphClassDef: u === 0 ? null : e._lctf.readClassDef(r, c + u) };
    }, e.GPOS = {}, e.GPOS.parse = function(r, o, a, l) {
      return e._lctf.parse(r, o, a, l, e.GPOS.subt);
    }, e.GPOS.subt = function(r, o, a, l) {
      var c = e._bin, u = a, d = {};
      if (d.fmt = c.readUshort(r, a), a += 2, o == 1 || o == 2 || o == 3 || o == 7 || o == 8 && d.fmt <= 2) {
        var h = c.readUshort(r, a);
        a += 2, d.coverage = e._lctf.readCoverage(r, h + u);
      }
      if (o == 1 && d.fmt == 1) {
        var m = c.readUshort(r, a);
        a += 2, m != 0 && (d.pos = e.GPOS.readValueRecord(r, a, m));
      } else if (o == 2 && d.fmt >= 1 && d.fmt <= 2) {
        m = c.readUshort(r, a), a += 2;
        var p = c.readUshort(r, a);
        a += 2;
        var y = e._lctf.numOfOnes(m), _ = e._lctf.numOfOnes(p);
        if (d.fmt == 1) {
          d.pairsets = [];
          var v = c.readUshort(r, a);
          a += 2;
          for (var g = 0; g < v; g++) {
            var S = u + c.readUshort(r, a);
            a += 2;
            var w = c.readUshort(r, S);
            S += 2;
            for (var x = [], C = 0; C < w; C++) {
              var E = c.readUshort(r, S);
              S += 2, m != 0 && (N = e.GPOS.readValueRecord(r, S, m), S += 2 * y), p != 0 && (D = e.GPOS.readValueRecord(r, S, p), S += 2 * _), x.push({ gid2: E, val1: N, val2: D });
            }
            d.pairsets.push(x);
          }
        }
        if (d.fmt == 2) {
          var P = c.readUshort(r, a);
          a += 2;
          var T = c.readUshort(r, a);
          a += 2;
          var b = c.readUshort(r, a);
          a += 2;
          var M = c.readUshort(r, a);
          for (a += 2, d.classDef1 = e._lctf.readClassDef(r, u + P), d.classDef2 = e._lctf.readClassDef(r, u + T), d.matrix = [], g = 0; g < b; g++) {
            var L = [];
            for (C = 0; C < M; C++) {
              var N = null, D = null;
              m != 0 && (N = e.GPOS.readValueRecord(r, a, m), a += 2 * y), p != 0 && (D = e.GPOS.readValueRecord(r, a, p), a += 2 * _), L.push({ val1: N, val2: D });
            }
            d.matrix.push(L);
          }
        }
      } else if (o == 4 && d.fmt == 1) d.markCoverage = e._lctf.readCoverage(r, c.readUshort(r, a) + u), d.baseCoverage = e._lctf.readCoverage(r, c.readUshort(r, a + 2) + u), d.markClassCount = c.readUshort(r, a + 4), d.markArray = e.GPOS.readMarkArray(r, c.readUshort(r, a + 6) + u), d.baseArray = e.GPOS.readBaseArray(r, c.readUshort(r, a + 8) + u, d.markClassCount);
      else if (o == 6 && d.fmt == 1) d.mark1Coverage = e._lctf.readCoverage(r, c.readUshort(r, a) + u), d.mark2Coverage = e._lctf.readCoverage(r, c.readUshort(r, a + 2) + u), d.markClassCount = c.readUshort(r, a + 4), d.mark1Array = e.GPOS.readMarkArray(r, c.readUshort(r, a + 6) + u), d.mark2Array = e.GPOS.readBaseArray(r, c.readUshort(r, a + 8) + u, d.markClassCount);
      else {
        if (o == 9 && d.fmt == 1) {
          var O = c.readUshort(r, a);
          a += 2;
          var A = c.readUint(r, a);
          if (a += 4, l.ltype == 9) l.ltype = O;
          else if (l.ltype != O) throw "invalid extension substitution";
          return e.GPOS.subt(r, l.ltype, u + A);
        }
        console.debug("unsupported GPOS table LookupType", o, "format", d.fmt);
      }
      return d;
    }, e.GPOS.readValueRecord = function(r, o, a) {
      var l = e._bin, c = [];
      return c.push(1 & a ? l.readShort(r, o) : 0), o += 1 & a ? 2 : 0, c.push(2 & a ? l.readShort(r, o) : 0), o += 2 & a ? 2 : 0, c.push(4 & a ? l.readShort(r, o) : 0), o += 4 & a ? 2 : 0, c.push(8 & a ? l.readShort(r, o) : 0), o += 8 & a ? 2 : 0, c;
    }, e.GPOS.readBaseArray = function(r, o, a) {
      var l = e._bin, c = [], u = o, d = l.readUshort(r, o);
      o += 2;
      for (var h = 0; h < d; h++) {
        for (var m = [], p = 0; p < a; p++) m.push(e.GPOS.readAnchorRecord(r, u + l.readUshort(r, o))), o += 2;
        c.push(m);
      }
      return c;
    }, e.GPOS.readMarkArray = function(r, o) {
      var a = e._bin, l = [], c = o, u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = e.GPOS.readAnchorRecord(r, a.readUshort(r, o + 2) + c);
        h.markClass = a.readUshort(r, o), l.push(h), o += 4;
      }
      return l;
    }, e.GPOS.readAnchorRecord = function(r, o) {
      var a = e._bin, l = {};
      return l.fmt = a.readUshort(r, o), l.x = a.readShort(r, o + 2), l.y = a.readShort(r, o + 4), l;
    }, e.GSUB = {}, e.GSUB.parse = function(r, o, a, l) {
      return e._lctf.parse(r, o, a, l, e.GSUB.subt);
    }, e.GSUB.subt = function(r, o, a, l) {
      var c = e._bin, u = a, d = {};
      if (d.fmt = c.readUshort(r, a), a += 2, o != 1 && o != 2 && o != 4 && o != 5 && o != 6) return null;
      if (o == 1 || o == 2 || o == 4 || o == 5 && d.fmt <= 2 || o == 6 && d.fmt <= 2) {
        var h = c.readUshort(r, a);
        a += 2, d.coverage = e._lctf.readCoverage(r, u + h);
      }
      if (o == 1 && d.fmt >= 1 && d.fmt <= 2) {
        if (d.fmt == 1) d.delta = c.readShort(r, a), a += 2;
        else if (d.fmt == 2) {
          var m = c.readUshort(r, a);
          a += 2, d.newg = c.readUshorts(r, a, m), a += 2 * d.newg.length;
        }
      } else if (o == 2 && d.fmt == 1) {
        m = c.readUshort(r, a), a += 2, d.seqs = [];
        for (var p = 0; p < m; p++) {
          var y = c.readUshort(r, a) + u;
          a += 2;
          var _ = c.readUshort(r, y);
          d.seqs.push(c.readUshorts(r, y + 2, _));
        }
      } else if (o == 4)
        for (d.vals = [], m = c.readUshort(r, a), a += 2, p = 0; p < m; p++) {
          var v = c.readUshort(r, a);
          a += 2, d.vals.push(e.GSUB.readLigatureSet(r, u + v));
        }
      else if (o == 5 && d.fmt == 2) {
        if (d.fmt == 2) {
          var g = c.readUshort(r, a);
          a += 2, d.cDef = e._lctf.readClassDef(r, u + g), d.scset = [];
          var S = c.readUshort(r, a);
          for (a += 2, p = 0; p < S; p++) {
            var w = c.readUshort(r, a);
            a += 2, d.scset.push(w == 0 ? null : e.GSUB.readSubClassSet(r, u + w));
          }
        }
      } else if (o == 6 && d.fmt == 3) {
        if (d.fmt == 3) {
          for (p = 0; p < 3; p++) {
            m = c.readUshort(r, a), a += 2;
            for (var x = [], C = 0; C < m; C++) x.push(e._lctf.readCoverage(r, u + c.readUshort(r, a + 2 * C)));
            a += 2 * m, p == 0 && (d.backCvg = x), p == 1 && (d.inptCvg = x), p == 2 && (d.ahedCvg = x);
          }
          m = c.readUshort(r, a), a += 2, d.lookupRec = e.GSUB.readSubstLookupRecords(r, a, m);
        }
      } else {
        if (o == 7 && d.fmt == 1) {
          var E = c.readUshort(r, a);
          a += 2;
          var P = c.readUint(r, a);
          if (a += 4, l.ltype == 9) l.ltype = E;
          else if (l.ltype != E) throw "invalid extension substitution";
          return e.GSUB.subt(r, l.ltype, u + P);
        }
        console.debug("unsupported GSUB table LookupType", o, "format", d.fmt);
      }
      return d;
    }, e.GSUB.readSubClassSet = function(r, o) {
      var a = e._bin.readUshort, l = o, c = [], u = a(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a(r, o);
        o += 2, c.push(e.GSUB.readSubClassRule(r, l + h));
      }
      return c;
    }, e.GSUB.readSubClassRule = function(r, o) {
      var a = e._bin.readUshort, l = {}, c = a(r, o), u = a(r, o += 2);
      o += 2, l.input = [];
      for (var d = 0; d < c - 1; d++) l.input.push(a(r, o)), o += 2;
      return l.substLookupRecords = e.GSUB.readSubstLookupRecords(r, o, u), l;
    }, e.GSUB.readSubstLookupRecords = function(r, o, a) {
      for (var l = e._bin.readUshort, c = [], u = 0; u < a; u++) c.push(l(r, o), l(r, o + 2)), o += 4;
      return c;
    }, e.GSUB.readChainSubClassSet = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readUshort(r, o);
        o += 2, c.push(e.GSUB.readChainSubClassRule(r, l + h));
      }
      return c;
    }, e.GSUB.readChainSubClassRule = function(r, o) {
      for (var a = e._bin, l = {}, c = ["backtrack", "input", "lookahead"], u = 0; u < c.length; u++) {
        var d = a.readUshort(r, o);
        o += 2, u == 1 && d--, l[c[u]] = a.readUshorts(r, o, d), o += 2 * l[c[u]].length;
      }
      return d = a.readUshort(r, o), o += 2, l.subst = a.readUshorts(r, o, 2 * d), o += 2 * l.subst.length, l;
    }, e.GSUB.readLigatureSet = function(r, o) {
      var a = e._bin, l = o, c = [], u = a.readUshort(r, o);
      o += 2;
      for (var d = 0; d < u; d++) {
        var h = a.readUshort(r, o);
        o += 2, c.push(e.GSUB.readLigature(r, l + h));
      }
      return c;
    }, e.GSUB.readLigature = function(r, o) {
      var a = e._bin, l = { chain: [] };
      l.nglyph = a.readUshort(r, o), o += 2;
      var c = a.readUshort(r, o);
      o += 2;
      for (var u = 0; u < c - 1; u++) l.chain.push(a.readUshort(r, o)), o += 2;
      return l;
    }, e.head = {}, e.head.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(r, o), o += 4, c.fontRevision = l.readFixed(r, o), o += 4, l.readUint(r, o), o += 4, l.readUint(r, o), o += 4, c.flags = l.readUshort(r, o), o += 2, c.unitsPerEm = l.readUshort(r, o), o += 2, c.created = l.readUint64(r, o), o += 8, c.modified = l.readUint64(r, o), o += 8, c.xMin = l.readShort(r, o), o += 2, c.yMin = l.readShort(r, o), o += 2, c.xMax = l.readShort(r, o), o += 2, c.yMax = l.readShort(r, o), o += 2, c.macStyle = l.readUshort(r, o), o += 2, c.lowestRecPPEM = l.readUshort(r, o), o += 2, c.fontDirectionHint = l.readShort(r, o), o += 2, c.indexToLocFormat = l.readShort(r, o), o += 2, c.glyphDataFormat = l.readShort(r, o), o += 2, c;
    }, e.hhea = {}, e.hhea.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return l.readFixed(r, o), o += 4, c.ascender = l.readShort(r, o), o += 2, c.descender = l.readShort(r, o), o += 2, c.lineGap = l.readShort(r, o), o += 2, c.advanceWidthMax = l.readUshort(r, o), o += 2, c.minLeftSideBearing = l.readShort(r, o), o += 2, c.minRightSideBearing = l.readShort(r, o), o += 2, c.xMaxExtent = l.readShort(r, o), o += 2, c.caretSlopeRise = l.readShort(r, o), o += 2, c.caretSlopeRun = l.readShort(r, o), o += 2, c.caretOffset = l.readShort(r, o), o += 2, o += 8, c.metricDataFormat = l.readShort(r, o), o += 2, c.numberOfHMetrics = l.readUshort(r, o), o += 2, c;
    }, e.hmtx = {}, e.hmtx.parse = function(r, o, a, l) {
      for (var c = e._bin, u = { aWidth: [], lsBearing: [] }, d = 0, h = 0, m = 0; m < l.maxp.numGlyphs; m++) m < l.hhea.numberOfHMetrics && (d = c.readUshort(r, o), o += 2, h = c.readShort(r, o), o += 2), u.aWidth.push(d), u.lsBearing.push(h);
      return u;
    }, e.kern = {}, e.kern.parse = function(r, o, a, l) {
      var c = e._bin, u = c.readUshort(r, o);
      if (o += 2, u == 1) return e.kern.parseV1(r, o - 2, a, l);
      var d = c.readUshort(r, o);
      o += 2;
      for (var h = { glyph1: [], rval: [] }, m = 0; m < d; m++) {
        o += 2, a = c.readUshort(r, o), o += 2;
        var p = c.readUshort(r, o);
        o += 2;
        var y = p >>> 8;
        if ((y &= 15) != 0) throw "unknown kern table format: " + y;
        o = e.kern.readFormat0(r, o, h);
      }
      return h;
    }, e.kern.parseV1 = function(r, o, a, l) {
      var c = e._bin;
      c.readFixed(r, o), o += 4;
      var u = c.readUint(r, o);
      o += 4;
      for (var d = { glyph1: [], rval: [] }, h = 0; h < u; h++) {
        c.readUint(r, o), o += 4;
        var m = c.readUshort(r, o);
        o += 2, c.readUshort(r, o), o += 2;
        var p = m >>> 8;
        if ((p &= 15) != 0) throw "unknown kern table format: " + p;
        o = e.kern.readFormat0(r, o, d);
      }
      return d;
    }, e.kern.readFormat0 = function(r, o, a) {
      var l = e._bin, c = -1, u = l.readUshort(r, o);
      o += 2, l.readUshort(r, o), o += 2, l.readUshort(r, o), o += 2, l.readUshort(r, o), o += 2;
      for (var d = 0; d < u; d++) {
        var h = l.readUshort(r, o);
        o += 2;
        var m = l.readUshort(r, o);
        o += 2;
        var p = l.readShort(r, o);
        o += 2, h != c && (a.glyph1.push(h), a.rval.push({ glyph2: [], vals: [] }));
        var y = a.rval[a.rval.length - 1];
        y.glyph2.push(m), y.vals.push(p), c = h;
      }
      return o;
    }, e.loca = {}, e.loca.parse = function(r, o, a, l) {
      var c = e._bin, u = [], d = l.head.indexToLocFormat, h = l.maxp.numGlyphs + 1;
      if (d == 0) for (var m = 0; m < h; m++) u.push(c.readUshort(r, o + (m << 1)) << 1);
      if (d == 1) for (m = 0; m < h; m++) u.push(c.readUint(r, o + (m << 2)));
      return u;
    }, e.maxp = {}, e.maxp.parse = function(r, o, a) {
      var l = e._bin, c = {}, u = l.readUint(r, o);
      return o += 4, c.numGlyphs = l.readUshort(r, o), o += 2, u == 65536 && (c.maxPoints = l.readUshort(r, o), o += 2, c.maxContours = l.readUshort(r, o), o += 2, c.maxCompositePoints = l.readUshort(r, o), o += 2, c.maxCompositeContours = l.readUshort(r, o), o += 2, c.maxZones = l.readUshort(r, o), o += 2, c.maxTwilightPoints = l.readUshort(r, o), o += 2, c.maxStorage = l.readUshort(r, o), o += 2, c.maxFunctionDefs = l.readUshort(r, o), o += 2, c.maxInstructionDefs = l.readUshort(r, o), o += 2, c.maxStackElements = l.readUshort(r, o), o += 2, c.maxSizeOfInstructions = l.readUshort(r, o), o += 2, c.maxComponentElements = l.readUshort(r, o), o += 2, c.maxComponentDepth = l.readUshort(r, o), o += 2), c;
    }, e.name = {}, e.name.parse = function(r, o, a) {
      var l = e._bin, c = {};
      l.readUshort(r, o), o += 2;
      var u = l.readUshort(r, o);
      o += 2, l.readUshort(r, o);
      for (var d, h = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], m = o += 2, p = 0; p < u; p++) {
        var y = l.readUshort(r, o);
        o += 2;
        var _ = l.readUshort(r, o);
        o += 2;
        var v = l.readUshort(r, o);
        o += 2;
        var g = l.readUshort(r, o);
        o += 2;
        var S = l.readUshort(r, o);
        o += 2;
        var w = l.readUshort(r, o);
        o += 2;
        var x, C = h[g], E = m + 12 * u + w;
        if (y == 0) x = l.readUnicode(r, E, S / 2);
        else if (y == 3 && _ == 0) x = l.readUnicode(r, E, S / 2);
        else if (_ == 0) x = l.readASCII(r, E, S);
        else if (_ == 1) x = l.readUnicode(r, E, S / 2);
        else if (_ == 3) x = l.readUnicode(r, E, S / 2);
        else {
          if (y != 1) throw "unknown encoding " + _ + ", platformID: " + y;
          x = l.readASCII(r, E, S), console.debug("reading unknown MAC encoding " + _ + " as ASCII");
        }
        var P = "p" + y + "," + v.toString(16);
        c[P] == null && (c[P] = {}), c[P][C !== void 0 ? C : g] = x, c[P]._lang = v;
      }
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 1033) return c[T];
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 0) return c[T];
      for (var T in c) if (c[T].postScriptName != null && c[T]._lang == 3084) return c[T];
      for (var T in c) if (c[T].postScriptName != null) return c[T];
      for (var T in c) {
        d = T;
        break;
      }
      return console.debug("returning name table with languageID " + c[d]._lang), c[d];
    }, e["OS/2"] = {}, e["OS/2"].parse = function(r, o, a) {
      var l = e._bin.readUshort(r, o);
      o += 2;
      var c = {};
      if (l == 0) e["OS/2"].version0(r, o, c);
      else if (l == 1) e["OS/2"].version1(r, o, c);
      else if (l == 2 || l == 3 || l == 4) e["OS/2"].version2(r, o, c);
      else {
        if (l != 5) throw "unknown OS/2 table version: " + l;
        e["OS/2"].version5(r, o, c);
      }
      return c;
    }, e["OS/2"].version0 = function(r, o, a) {
      var l = e._bin;
      return a.xAvgCharWidth = l.readShort(r, o), o += 2, a.usWeightClass = l.readUshort(r, o), o += 2, a.usWidthClass = l.readUshort(r, o), o += 2, a.fsType = l.readUshort(r, o), o += 2, a.ySubscriptXSize = l.readShort(r, o), o += 2, a.ySubscriptYSize = l.readShort(r, o), o += 2, a.ySubscriptXOffset = l.readShort(r, o), o += 2, a.ySubscriptYOffset = l.readShort(r, o), o += 2, a.ySuperscriptXSize = l.readShort(r, o), o += 2, a.ySuperscriptYSize = l.readShort(r, o), o += 2, a.ySuperscriptXOffset = l.readShort(r, o), o += 2, a.ySuperscriptYOffset = l.readShort(r, o), o += 2, a.yStrikeoutSize = l.readShort(r, o), o += 2, a.yStrikeoutPosition = l.readShort(r, o), o += 2, a.sFamilyClass = l.readShort(r, o), o += 2, a.panose = l.readBytes(r, o, 10), o += 10, a.ulUnicodeRange1 = l.readUint(r, o), o += 4, a.ulUnicodeRange2 = l.readUint(r, o), o += 4, a.ulUnicodeRange3 = l.readUint(r, o), o += 4, a.ulUnicodeRange4 = l.readUint(r, o), o += 4, a.achVendID = [l.readInt8(r, o), l.readInt8(r, o + 1), l.readInt8(r, o + 2), l.readInt8(r, o + 3)], o += 4, a.fsSelection = l.readUshort(r, o), o += 2, a.usFirstCharIndex = l.readUshort(r, o), o += 2, a.usLastCharIndex = l.readUshort(r, o), o += 2, a.sTypoAscender = l.readShort(r, o), o += 2, a.sTypoDescender = l.readShort(r, o), o += 2, a.sTypoLineGap = l.readShort(r, o), o += 2, a.usWinAscent = l.readUshort(r, o), o += 2, a.usWinDescent = l.readUshort(r, o), o += 2;
    }, e["OS/2"].version1 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version0(r, o, a), a.ulCodePageRange1 = l.readUint(r, o), o += 4, a.ulCodePageRange2 = l.readUint(r, o), o += 4;
    }, e["OS/2"].version2 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version1(r, o, a), a.sxHeight = l.readShort(r, o), o += 2, a.sCapHeight = l.readShort(r, o), o += 2, a.usDefault = l.readUshort(r, o), o += 2, a.usBreak = l.readUshort(r, o), o += 2, a.usMaxContext = l.readUshort(r, o), o += 2;
    }, e["OS/2"].version5 = function(r, o, a) {
      var l = e._bin;
      return o = e["OS/2"].version2(r, o, a), a.usLowerOpticalPointSize = l.readUshort(r, o), o += 2, a.usUpperOpticalPointSize = l.readUshort(r, o), o += 2;
    }, e.post = {}, e.post.parse = function(r, o, a) {
      var l = e._bin, c = {};
      return c.version = l.readFixed(r, o), o += 4, c.italicAngle = l.readFixed(r, o), o += 4, c.underlinePosition = l.readShort(r, o), o += 2, c.underlineThickness = l.readShort(r, o), o += 2, c;
    }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(r, o) {
      var a = r.cmap, l = -1;
      if (a.p0e4 != null ? l = a.p0e4 : a.p3e1 != null ? l = a.p3e1 : a.p1e0 != null ? l = a.p1e0 : a.p0e3 != null && (l = a.p0e3), l == -1) throw "no familiar platform and encoding!";
      var c = a.tables[l];
      if (c.format == 0) return o >= c.map.length ? 0 : c.map[o];
      if (c.format == 4) {
        for (var u = -1, d = 0; d < c.endCount.length; d++) if (o <= c.endCount[d]) {
          u = d;
          break;
        }
        return u == -1 || c.startCount[u] > o ? 0 : 65535 & (c.idRangeOffset[u] != 0 ? c.glyphIdArray[o - c.startCount[u] + (c.idRangeOffset[u] >> 1) - (c.idRangeOffset.length - u)] : o + c.idDelta[u]);
      }
      if (c.format == 12) {
        if (o > c.groups[c.groups.length - 1][1]) return 0;
        for (d = 0; d < c.groups.length; d++) {
          var h = c.groups[d];
          if (h[0] <= o && o <= h[1]) return h[2] + (o - h[0]);
        }
        return 0;
      }
      throw "unknown cmap table format " + c.format;
    }, e.U.glyphToPath = function(r, o) {
      var a = { cmds: [], crds: [] };
      if (r.SVG && r.SVG.entries[o]) {
        var l = r.SVG.entries[o];
        return l == null ? a : (typeof l == "string" && (l = e.SVG.toPath(l), r.SVG.entries[o] = l), l);
      }
      if (r.CFF) {
        var c = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: !1, width: r.CFF.Private ? r.CFF.Private.defaultWidthX : 0, open: !1 }, u = r.CFF, d = r.CFF.Private;
        if (u.ROS) {
          for (var h = 0; u.FDSelect[h + 2] <= o; ) h += 2;
          d = u.FDArray[u.FDSelect[h + 1]].Private;
        }
        e.U._drawCFF(r.CFF.CharStrings[o], c, u, d, a);
      } else r.glyf && e.U._drawGlyf(o, r, a);
      return a;
    }, e.U._drawGlyf = function(r, o, a) {
      var l = o.glyf[r];
      l == null && (l = o.glyf[r] = e.glyf._parseGlyf(o, r)), l != null && (l.noc > -1 ? e.U._simpleGlyph(l, a) : e.U._compoGlyph(l, o, a));
    }, e.U._simpleGlyph = function(r, o) {
      for (var a = 0; a < r.noc; a++) {
        for (var l = a == 0 ? 0 : r.endPts[a - 1] + 1, c = r.endPts[a], u = l; u <= c; u++) {
          var d = u == l ? c : u - 1, h = u == c ? l : u + 1, m = 1 & r.flags[u], p = 1 & r.flags[d], y = 1 & r.flags[h], _ = r.xs[u], v = r.ys[u];
          if (u == l) if (m) {
            if (!p) {
              e.U.P.moveTo(o, _, v);
              continue;
            }
            e.U.P.moveTo(o, r.xs[d], r.ys[d]);
          } else p ? e.U.P.moveTo(o, r.xs[d], r.ys[d]) : e.U.P.moveTo(o, (r.xs[d] + _) / 2, (r.ys[d] + v) / 2);
          m ? p && e.U.P.lineTo(o, _, v) : y ? e.U.P.qcurveTo(o, _, v, r.xs[h], r.ys[h]) : e.U.P.qcurveTo(o, _, v, (_ + r.xs[h]) / 2, (v + r.ys[h]) / 2);
        }
        e.U.P.closePath(o);
      }
    }, e.U._compoGlyph = function(r, o, a) {
      for (var l = 0; l < r.parts.length; l++) {
        var c = { cmds: [], crds: [] }, u = r.parts[l];
        e.U._drawGlyf(u.glyphIndex, o, c);
        for (var d = u.m, h = 0; h < c.crds.length; h += 2) {
          var m = c.crds[h], p = c.crds[h + 1];
          a.crds.push(m * d.a + p * d.b + d.tx), a.crds.push(m * d.c + p * d.d + d.ty);
        }
        for (h = 0; h < c.cmds.length; h++) a.cmds.push(c.cmds[h]);
      }
    }, e.U._getGlyphClass = function(r, o) {
      var a = e._lctf.getInterval(o, r);
      return a == -1 ? 0 : o[a + 2];
    }, e.U._applySubs = function(r, o, a, l) {
      for (var c = r.length - o - 1, u = 0; u < a.tabs.length; u++) if (a.tabs[u] != null) {
        var d, h = a.tabs[u];
        if (!h.coverage || (d = e._lctf.coverageIndex(h.coverage, r[o])) != -1) {
          if (a.ltype == 1) r[o], h.fmt == 1 ? r[o] = r[o] + h.delta : r[o] = h.newg[d];
          else if (a.ltype == 4) for (var m = h.vals[d], p = 0; p < m.length; p++) {
            var y = m[p], _ = y.chain.length;
            if (!(_ > c)) {
              for (var v = !0, g = 0, S = 0; S < _; S++) {
                for (; r[o + g + (1 + S)] == -1; ) g++;
                y.chain[S] != r[o + g + (1 + S)] && (v = !1);
              }
              if (v) {
                for (r[o] = y.nglyph, S = 0; S < _ + g; S++) r[o + S + 1] = -1;
                break;
              }
            }
          }
          else if (a.ltype == 5 && h.fmt == 2) for (var w = e._lctf.getInterval(h.cDef, r[o]), x = h.cDef[w + 2], C = h.scset[x], E = 0; E < C.length; E++) {
            var P = C[E], T = P.input;
            if (!(T.length > c)) {
              for (v = !0, S = 0; S < T.length; S++) {
                var b = e._lctf.getInterval(h.cDef, r[o + 1 + S]);
                if (w == -1 && h.cDef[b + 2] != T[S]) {
                  v = !1;
                  break;
                }
              }
              if (v) {
                var M = P.substLookupRecords;
                for (p = 0; p < M.length; p += 2) M[p], M[p + 1];
              }
            }
          }
          else if (a.ltype == 6 && h.fmt == 3) {
            if (!e.U._glsCovered(r, h.backCvg, o - h.backCvg.length) || !e.U._glsCovered(r, h.inptCvg, o) || !e.U._glsCovered(r, h.ahedCvg, o + h.inptCvg.length)) continue;
            var L = h.lookupRec;
            for (E = 0; E < L.length; E += 2) {
              w = L[E];
              var N = l[L[E + 1]];
              e.U._applySubs(r, o + w, N, l);
            }
          }
        }
      }
    }, e.U._glsCovered = function(r, o, a) {
      for (var l = 0; l < o.length; l++)
        if (e._lctf.coverageIndex(o[l], r[a + l]) == -1) return !1;
      return !0;
    }, e.U.glyphsToPath = function(r, o, a) {
      for (var l = { cmds: [], crds: [] }, c = 0, u = 0; u < o.length; u++) {
        var d = o[u];
        if (d != -1) {
          for (var h = u < o.length - 1 && o[u + 1] != -1 ? o[u + 1] : 0, m = e.U.glyphToPath(r, d), p = 0; p < m.crds.length; p += 2) l.crds.push(m.crds[p] + c), l.crds.push(m.crds[p + 1]);
          for (a && l.cmds.push(a), p = 0; p < m.cmds.length; p++) l.cmds.push(m.cmds[p]);
          a && l.cmds.push("X"), c += r.hmtx.aWidth[d], u < o.length - 1 && (c += e.U.getPairAdjustment(r, d, h));
        }
      }
      return l;
    }, e.U.P = {}, e.U.P.moveTo = function(r, o, a) {
      r.cmds.push("M"), r.crds.push(o, a);
    }, e.U.P.lineTo = function(r, o, a) {
      r.cmds.push("L"), r.crds.push(o, a);
    }, e.U.P.curveTo = function(r, o, a, l, c, u, d) {
      r.cmds.push("C"), r.crds.push(o, a, l, c, u, d);
    }, e.U.P.qcurveTo = function(r, o, a, l, c) {
      r.cmds.push("Q"), r.crds.push(o, a, l, c);
    }, e.U.P.closePath = function(r) {
      r.cmds.push("Z");
    }, e.U._drawCFF = function(r, o, a, l, c) {
      for (var u = o.stack, d = o.nStems, h = o.haveWidth, m = o.width, p = o.open, y = 0, _ = o.x, v = o.y, g = 0, S = 0, w = 0, x = 0, C = 0, E = 0, P = 0, T = 0, b = 0, M = 0, L = { val: 0, size: 0 }; y < r.length; ) {
        e.CFF.getCharString(r, y, L);
        var N = L.val;
        if (y += L.size, N == "o1" || N == "o18") u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (N == "o3" || N == "o23")
          u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0;
        else if (N == "o4") u.length > 1 && !h && (m = u.shift() + l.nominalWidthX, h = !0), p && e.U.P.closePath(c), v += u.pop(), e.U.P.moveTo(c, _, v), p = !0;
        else if (N == "o5") for (; u.length > 0; ) _ += u.shift(), v += u.shift(), e.U.P.lineTo(c, _, v);
        else if (N == "o6" || N == "o7") for (var D = u.length, O = N == "o6", A = 0; A < D; A++) {
          var G = u.shift();
          O ? _ += G : v += G, O = !O, e.U.P.lineTo(c, _, v);
        }
        else if (N == "o8" || N == "o24") {
          D = u.length;
          for (var he = 0; he + 6 <= D; ) g = _ + u.shift(), S = v + u.shift(), w = g + u.shift(), x = S + u.shift(), _ = w + u.shift(), v = x + u.shift(), e.U.P.curveTo(c, g, S, w, x, _, v), he += 6;
          N == "o24" && (_ += u.shift(), v += u.shift(), e.U.P.lineTo(c, _, v));
        } else {
          if (N == "o11") break;
          if (N == "o1234" || N == "o1235" || N == "o1236" || N == "o1237") N == "o1234" && (S = v, w = (g = _ + u.shift()) + u.shift(), M = x = S + u.shift(), E = x, T = v, _ = (P = (C = (b = w + u.shift()) + u.shift()) + u.shift()) + u.shift(), e.U.P.curveTo(c, g, S, w, x, b, M), e.U.P.curveTo(c, C, E, P, T, _, v)), N == "o1235" && (g = _ + u.shift(), S = v + u.shift(), w = g + u.shift(), x = S + u.shift(), b = w + u.shift(), M = x + u.shift(), C = b + u.shift(), E = M + u.shift(), P = C + u.shift(), T = E + u.shift(), _ = P + u.shift(), v = T + u.shift(), u.shift(), e.U.P.curveTo(c, g, S, w, x, b, M), e.U.P.curveTo(c, C, E, P, T, _, v)), N == "o1236" && (g = _ + u.shift(), S = v + u.shift(), w = g + u.shift(), M = x = S + u.shift(), E = x, P = (C = (b = w + u.shift()) + u.shift()) + u.shift(), T = E + u.shift(), _ = P + u.shift(), e.U.P.curveTo(c, g, S, w, x, b, M), e.U.P.curveTo(c, C, E, P, T, _, v)), N == "o1237" && (g = _ + u.shift(), S = v + u.shift(), w = g + u.shift(), x = S + u.shift(), b = w + u.shift(), M = x + u.shift(), C = b + u.shift(), E = M + u.shift(), P = C + u.shift(), T = E + u.shift(), Math.abs(P - _) > Math.abs(T - v) ? _ = P + u.shift() : v = T + u.shift(), e.U.P.curveTo(c, g, S, w, x, b, M), e.U.P.curveTo(c, C, E, P, T, _, v));
          else if (N == "o14") {
            if (u.length > 0 && !h && (m = u.shift() + a.nominalWidthX, h = !0), u.length == 4) {
              var ee = u.shift(), le = u.shift(), oe = u.shift(), Y = u.shift(), j = e.CFF.glyphBySE(a, oe), q = e.CFF.glyphBySE(a, Y);
              e.U._drawCFF(a.CharStrings[j], o, a, l, c), o.x = ee, o.y = le, e.U._drawCFF(a.CharStrings[q], o, a, l, c);
            }
            p && (e.U.P.closePath(c), p = !1);
          } else if (N == "o19" || N == "o20")
            u.length % 2 != 0 && !h && (m = u.shift() + l.nominalWidthX), d += u.length >> 1, u.length = 0, h = !0, y += d + 7 >> 3;
          else if (N == "o21") u.length > 2 && !h && (m = u.shift() + l.nominalWidthX, h = !0), v += u.pop(), _ += u.pop(), p && e.U.P.closePath(c), e.U.P.moveTo(c, _, v), p = !0;
          else if (N == "o22") u.length > 1 && !h && (m = u.shift() + l.nominalWidthX, h = !0), _ += u.pop(), p && e.U.P.closePath(c), e.U.P.moveTo(c, _, v), p = !0;
          else if (N == "o25") {
            for (; u.length > 6; ) _ += u.shift(), v += u.shift(), e.U.P.lineTo(c, _, v);
            g = _ + u.shift(), S = v + u.shift(), w = g + u.shift(), x = S + u.shift(), _ = w + u.shift(), v = x + u.shift(), e.U.P.curveTo(c, g, S, w, x, _, v);
          } else if (N == "o26") for (u.length % 2 && (_ += u.shift()); u.length > 0; ) g = _, S = v + u.shift(), _ = w = g + u.shift(), v = (x = S + u.shift()) + u.shift(), e.U.P.curveTo(c, g, S, w, x, _, v);
          else if (N == "o27") for (u.length % 2 && (v += u.shift()); u.length > 0; ) S = v, w = (g = _ + u.shift()) + u.shift(), x = S + u.shift(), _ = w + u.shift(), v = x, e.U.P.curveTo(c, g, S, w, x, _, v);
          else if (N == "o10" || N == "o29") {
            var te = N == "o10" ? l : a;
            if (u.length == 0) console.debug("error: empty stack");
            else {
              var ne = u.pop(), de = te.Subrs[ne + te.Bias];
              o.x = _, o.y = v, o.nStems = d, o.haveWidth = h, o.width = m, o.open = p, e.U._drawCFF(de, o, a, l, c), _ = o.x, v = o.y, d = o.nStems, h = o.haveWidth, m = o.width, p = o.open;
            }
          } else if (N == "o30" || N == "o31") {
            var H = u.length, X = (he = 0, N == "o31");
            for (he += H - (D = -3 & H); he < D; ) X ? (S = v, w = (g = _ + u.shift()) + u.shift(), v = (x = S + u.shift()) + u.shift(), D - he == 5 ? (_ = w + u.shift(), he++) : _ = w, X = !1) : (g = _, S = v + u.shift(), w = g + u.shift(), x = S + u.shift(), _ = w + u.shift(), D - he == 5 ? (v = x + u.shift(), he++) : v = x, X = !0), e.U.P.curveTo(c, g, S, w, x, _, v), he += 4;
          } else {
            if ((N + "").charAt(0) == "o") throw console.debug("Unknown operation: " + N, r), N;
            u.push(N);
          }
        }
      }
      o.x = _, o.y = v, o.nStems = d, o.haveWidth = h, o.width = m, o.open = p;
    };
    var n = e, i = { Typr: n };
    return s.Typr = n, s.default = i, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).Typr;
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function w6() {
  return function(s) {
    var e = Uint8Array, n = Uint16Array, i = Uint32Array, r = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), o = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), a = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), l = function(N, D) {
      for (var O = new n(31), A = 0; A < 31; ++A) O[A] = D += 1 << N[A - 1];
      var G = new i(O[30]);
      for (A = 1; A < 30; ++A) for (var he = O[A]; he < O[A + 1]; ++he) G[he] = he - O[A] << 5 | A;
      return [O, G];
    }, c = l(r, 2), u = c[0], d = c[1];
    u[28] = 258, d[258] = 28;
    for (var h = l(o, 0)[0], m = new n(32768), p = 0; p < 32768; ++p) {
      var y = (43690 & p) >>> 1 | (21845 & p) << 1;
      y = (61680 & (y = (52428 & y) >>> 2 | (13107 & y) << 2)) >>> 4 | (3855 & y) << 4, m[p] = ((65280 & y) >>> 8 | (255 & y) << 8) >>> 1;
    }
    var _ = function(N, D, O) {
      for (var A = N.length, G = 0, he = new n(D); G < A; ++G) ++he[N[G] - 1];
      var ee, le = new n(D);
      for (G = 0; G < D; ++G) le[G] = le[G - 1] + he[G - 1] << 1;
      {
        ee = new n(1 << D);
        var oe = 15 - D;
        for (G = 0; G < A; ++G) if (N[G]) for (var Y = G << 4 | N[G], j = D - N[G], q = le[N[G] - 1]++ << j, te = q | (1 << j) - 1; q <= te; ++q) ee[m[q] >>> oe] = Y;
      }
      return ee;
    }, v = new e(288);
    for (p = 0; p < 144; ++p) v[p] = 8;
    for (p = 144; p < 256; ++p) v[p] = 9;
    for (p = 256; p < 280; ++p) v[p] = 7;
    for (p = 280; p < 288; ++p) v[p] = 8;
    var g = new e(32);
    for (p = 0; p < 32; ++p) g[p] = 5;
    var S = _(v, 9), w = _(g, 5), x = function(N) {
      for (var D = N[0], O = 1; O < N.length; ++O) N[O] > D && (D = N[O]);
      return D;
    }, C = function(N, D, O) {
      var A = D / 8 | 0;
      return (N[A] | N[A + 1] << 8) >> (7 & D) & O;
    }, E = function(N, D) {
      var O = D / 8 | 0;
      return (N[O] | N[O + 1] << 8 | N[O + 2] << 16) >> (7 & D);
    }, P = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], T = function(N, D, O) {
      var A = new Error(D || P[N]);
      if (A.code = N, Error.captureStackTrace && Error.captureStackTrace(A, T), !O) throw A;
      return A;
    }, b = function(N, D, O) {
      var A = N.length;
      if (!A || O && !O.l && A < 5) return D || new e(0);
      var G = !D || O, he = !O || O.i;
      O || (O = {}), D || (D = new e(3 * A));
      var ee, le = function(ke) {
        var nt = D.length;
        if (ke > nt) {
          var Je = new e(Math.max(2 * nt, ke));
          Je.set(D), D = Je;
        }
      }, oe = O.f || 0, Y = O.p || 0, j = O.b || 0, q = O.l, te = O.d, ne = O.m, de = O.n, H = 8 * A;
      do {
        if (!q) {
          O.f = oe = C(N, Y, 1);
          var X = C(N, Y + 1, 3);
          if (Y += 3, !X) {
            var V = N[(se = ((ee = Y) / 8 | 0) + (7 & ee && 1) + 4) - 4] | N[se - 3] << 8, I = se + V;
            if (I > A) {
              he && T(0);
              break;
            }
            G && le(j + V), D.set(N.subarray(se, I), j), O.b = j += V, O.p = Y = 8 * I;
            continue;
          }
          if (X == 1) q = S, te = w, ne = 9, de = 5;
          else if (X == 2) {
            var F = C(N, Y, 31) + 257, k = C(N, Y + 10, 15) + 4, Q = F + C(N, Y + 5, 31) + 1;
            Y += 14;
            for (var Z = new e(Q), R = new e(19), ie = 0; ie < k; ++ie) R[a[ie]] = C(N, Y + 3 * ie, 7);
            Y += 3 * k;
            var J = x(R), B = (1 << J) - 1, $ = _(R, J);
            for (ie = 0; ie < Q; ) {
              var se, U = $[C(N, Y, B)];
              if (Y += 15 & U, (se = U >>> 4) < 16) Z[ie++] = se;
              else {
                var z = 0, K = 0;
                for (se == 16 ? (K = 3 + C(N, Y, 3), Y += 2, z = Z[ie - 1]) : se == 17 ? (K = 3 + C(N, Y, 7), Y += 3) : se == 18 && (K = 11 + C(N, Y, 127), Y += 7); K--; ) Z[ie++] = z;
              }
            }
            var ue = Z.subarray(0, F), me = Z.subarray(F);
            ne = x(ue), de = x(me), q = _(ue, ne), te = _(me, de);
          } else T(1);
          if (Y > H) {
            he && T(0);
            break;
          }
        }
        G && le(j + 131072);
        for (var ge = (1 << ne) - 1, Me = (1 << de) - 1, Te = Y; ; Te = Y) {
          var Ae = (z = q[E(N, Y) & ge]) >>> 4;
          if ((Y += 15 & z) > H) {
            he && T(0);
            break;
          }
          if (z || T(2), Ae < 256) D[j++] = Ae;
          else {
            if (Ae == 256) {
              Te = Y, q = null;
              break;
            }
            var Xe = Ae - 254;
            if (Ae > 264) {
              var Fe = r[ie = Ae - 257];
              Xe = C(N, Y, (1 << Fe) - 1) + u[ie], Y += Fe;
            }
            var He = te[E(N, Y) & Me], Ye = He >>> 4;
            if (He || T(3), Y += 15 & He, me = h[Ye], Ye > 3 && (Fe = o[Ye], me += E(N, Y) & (1 << Fe) - 1, Y += Fe), Y > H) {
              he && T(0);
              break;
            }
            G && le(j + 131072);
            for (var We = j + Xe; j < We; j += 4) D[j] = D[j - me], D[j + 1] = D[j + 1 - me], D[j + 2] = D[j + 2 - me], D[j + 3] = D[j + 3 - me];
            j = We;
          }
        }
        O.l = q, O.p = Te, O.b = j, q && (oe = 1, O.m = ne, O.d = te, O.n = de);
      } while (!oe);
      return j == D.length ? D : function(ke, nt, Je) {
        (Je == null || Je > ke.length) && (Je = ke.length);
        var _t = new (ke instanceof n ? n : ke instanceof i ? i : e)(Je - nt);
        return _t.set(ke.subarray(nt, Je)), _t;
      }(D, 0, j);
    }, M = new e(0), L = typeof TextDecoder < "u" && new TextDecoder();
    try {
      L.decode(M, { stream: !0 });
    } catch {
    }
    return s.convert_streams = function(N) {
      var D = new DataView(N), O = 0;
      function A() {
        var F = D.getUint16(O);
        return O += 2, F;
      }
      function G() {
        var F = D.getUint32(O);
        return O += 4, F;
      }
      function he(F) {
        V.setUint16(I, F), I += 2;
      }
      function ee(F) {
        V.setUint32(I, F), I += 4;
      }
      for (var le = { signature: G(), flavor: G(), length: G(), numTables: A(), reserved: A(), totalSfntSize: G(), majorVersion: A(), minorVersion: A(), metaOffset: G(), metaLength: G(), metaOrigLength: G(), privOffset: G(), privLength: G() }, oe = 0; Math.pow(2, oe) <= le.numTables; ) oe++;
      oe--;
      for (var Y = 16 * Math.pow(2, oe), j = 16 * le.numTables - Y, q = 12, te = [], ne = 0; ne < le.numTables; ne++) te.push({ tag: G(), offset: G(), compLength: G(), origLength: G(), origChecksum: G() }), q += 16;
      var de, H = new Uint8Array(12 + 16 * te.length + te.reduce(function(F, k) {
        return F + k.origLength + 4;
      }, 0)), X = H.buffer, V = new DataView(X), I = 0;
      return ee(le.flavor), he(le.numTables), he(Y), he(oe), he(j), te.forEach(function(F) {
        ee(F.tag), ee(F.origChecksum), ee(q), ee(F.origLength), F.outOffset = q, (q += F.origLength) % 4 != 0 && (q += 4 - q % 4);
      }), te.forEach(function(F) {
        var k, Q = N.slice(F.offset, F.offset + F.compLength);
        if (F.compLength != F.origLength) {
          var Z = new Uint8Array(F.origLength);
          k = new Uint8Array(Q, 2), b(k, Z);
        } else Z = new Uint8Array(Q);
        H.set(Z, F.outOffset);
        var R = 0;
        (q = F.outOffset + F.origLength) % 4 != 0 && (R = 4 - q % 4), H.set(new Uint8Array(R).buffer, F.outOffset + F.origLength), de = q + R;
      }), X.slice(0, de);
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({}).convert_streams;
}
function S6(s, e) {
  const n = {
    M: 2,
    L: 2,
    Q: 4,
    C: 6,
    Z: 0
  }, i = { C: "18g,ca,368,1kz", D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v", R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6", L: "x9u,jff,a,fd,jv", T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n" }, r = 1, o = 2, a = 4, l = 8, c = 16, u = 32;
  let d;
  function h(P) {
    if (!d) {
      const T = {
        R: o,
        L: r,
        D: a,
        C: c,
        U: u,
        T: l
      };
      d = /* @__PURE__ */ new Map();
      for (let b in i) {
        let M = 0;
        i[b].split(",").forEach((L) => {
          let [N, D] = L.split("+");
          N = parseInt(N, 36), D = D ? parseInt(D, 36) : 0, d.set(M += N, T[b]);
          for (let O = D; O--; )
            d.set(++M, T[b]);
        });
      }
    }
    return d.get(P) || u;
  }
  const m = 1, p = 2, y = 3, _ = 4, v = [null, "isol", "init", "fina", "medi"];
  function g(P) {
    const T = new Uint8Array(P.length);
    let b = u, M = m, L = -1;
    for (let N = 0; N < P.length; N++) {
      const D = P.codePointAt(N);
      let O = h(D) | 0, A = m;
      O & l || (b & (r | a | c) ? O & (o | a | c) ? (A = y, (M === m || M === y) && T[L]++) : O & (r | u) && (M === p || M === _) && T[L]-- : b & (o | u) && (M === p || M === _) && T[L]--, M = T[N] = A, b = O, L = N, D > 65535 && N++);
    }
    return T;
  }
  function S(P, T) {
    const b = [];
    for (let L = 0; L < T.length; L++) {
      const N = T.codePointAt(L);
      N > 65535 && L++, b.push(s.U.codeToGlyph(P, N));
    }
    const M = P.GSUB;
    if (M) {
      const { lookupList: L, featureList: N } = M;
      let D;
      const O = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/, A = [];
      N.forEach((G) => {
        if (O.test(G.tag))
          for (let he = 0; he < G.tab.length; he++) {
            if (A[G.tab[he]]) continue;
            A[G.tab[he]] = !0;
            const ee = L[G.tab[he]], le = /^(isol|init|fina|medi)$/.test(G.tag);
            le && !D && (D = g(T));
            for (let oe = 0; oe < b.length; oe++)
              (!D || !le || v[D[oe]] === G.tag) && s.U._applySubs(b, oe, ee, L);
          }
      });
    }
    return b;
  }
  function w(P, T) {
    const b = new Int16Array(T.length * 3);
    let M = 0;
    for (; M < T.length; M++) {
      const O = T[M];
      if (O === -1) continue;
      b[M * 3 + 2] = P.hmtx.aWidth[O];
      const A = P.GPOS;
      if (A) {
        const G = A.lookupList;
        for (let he = 0; he < G.length; he++) {
          const ee = G[he];
          for (let le = 0; le < ee.tabs.length; le++) {
            const oe = ee.tabs[le];
            if (ee.ltype === 1) {
              if (s._lctf.coverageIndex(oe.coverage, O) !== -1 && oe.pos) {
                D(oe.pos, M);
                break;
              }
            } else if (ee.ltype === 2) {
              let Y = null, j = L();
              if (j !== -1) {
                const q = s._lctf.coverageIndex(oe.coverage, T[j]);
                if (q !== -1) {
                  if (oe.fmt === 1) {
                    const te = oe.pairsets[q];
                    for (let ne = 0; ne < te.length; ne++)
                      te[ne].gid2 === O && (Y = te[ne]);
                  } else if (oe.fmt === 2) {
                    const te = s.U._getGlyphClass(T[j], oe.classDef1), ne = s.U._getGlyphClass(O, oe.classDef2);
                    Y = oe.matrix[te][ne];
                  }
                  if (Y) {
                    Y.val1 && D(Y.val1, j), Y.val2 && D(Y.val2, M);
                    break;
                  }
                }
              }
            } else if (ee.ltype === 4) {
              const Y = s._lctf.coverageIndex(oe.markCoverage, O);
              if (Y !== -1) {
                const j = L(N), q = j === -1 ? -1 : s._lctf.coverageIndex(oe.baseCoverage, T[j]);
                if (q !== -1) {
                  const te = oe.markArray[Y], ne = oe.baseArray[q][te.markClass];
                  b[M * 3] = ne.x - te.x + b[j * 3] - b[j * 3 + 2], b[M * 3 + 1] = ne.y - te.y + b[j * 3 + 1];
                  break;
                }
              }
            } else if (ee.ltype === 6) {
              const Y = s._lctf.coverageIndex(oe.mark1Coverage, O);
              if (Y !== -1) {
                const j = L();
                if (j !== -1) {
                  const q = T[j];
                  if (x(P, q) === 3) {
                    const te = s._lctf.coverageIndex(oe.mark2Coverage, q);
                    if (te !== -1) {
                      const ne = oe.mark1Array[Y], de = oe.mark2Array[te][ne.markClass];
                      b[M * 3] = de.x - ne.x + b[j * 3] - b[j * 3 + 2], b[M * 3 + 1] = de.y - ne.y + b[j * 3 + 1];
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      } else if (P.kern && !P.cff) {
        const G = L();
        if (G !== -1) {
          const he = P.kern.glyph1.indexOf(T[G]);
          if (he !== -1) {
            const ee = P.kern.rval[he].glyph2.indexOf(O);
            ee !== -1 && (b[G * 3 + 2] += P.kern.rval[he].vals[ee]);
          }
        }
      }
    }
    return b;
    function L(O) {
      for (let A = M - 1; A >= 0; A--)
        if (T[A] !== -1 && (!O || O(T[A])))
          return A;
      return -1;
    }
    function N(O) {
      return x(P, O) === 1;
    }
    function D(O, A) {
      for (let G = 0; G < 3; G++)
        b[A * 3 + G] += O[G] || 0;
    }
  }
  function x(P, T) {
    const b = P.GDEF && P.GDEF.glyphClassDef;
    return b ? s.U._getGlyphClass(T, b) : 0;
  }
  function C(...P) {
    for (let T = 0; T < P.length; T++)
      if (typeof P[T] == "number")
        return P[T];
  }
  function E(P) {
    const T = /* @__PURE__ */ Object.create(null), b = P["OS/2"], M = P.hhea, L = P.head.unitsPerEm, N = C(b && b.sTypoAscender, M && M.ascender, L), D = {
      unitsPerEm: L,
      ascender: N,
      descender: C(b && b.sTypoDescender, M && M.descender, 0),
      capHeight: C(b && b.sCapHeight, N),
      xHeight: C(b && b.sxHeight, N),
      lineGap: C(b && b.sTypoLineGap, M && M.lineGap),
      supportsCodePoint(O) {
        return s.U.codeToGlyph(P, O) > 0;
      },
      forEachGlyph(O, A, G, he) {
        let ee = 0;
        const le = 1 / D.unitsPerEm * A, oe = S(P, O);
        let Y = 0;
        const j = w(P, oe);
        return oe.forEach((q, te) => {
          if (q !== -1) {
            let ne = T[q];
            if (!ne) {
              const { cmds: de, crds: H } = s.U.glyphToPath(P, q);
              let X = "", V = 0;
              for (let Z = 0, R = de.length; Z < R; Z++) {
                const ie = n[de[Z]];
                X += de[Z];
                for (let J = 1; J <= ie; J++)
                  X += (J > 1 ? "," : "") + H[V++];
              }
              let I, F, k, Q;
              if (H.length) {
                I = F = 1 / 0, k = Q = -1 / 0;
                for (let Z = 0, R = H.length; Z < R; Z += 2) {
                  let ie = H[Z], J = H[Z + 1];
                  ie < I && (I = ie), J < F && (F = J), ie > k && (k = ie), J > Q && (Q = J);
                }
              } else
                I = k = F = Q = 0;
              ne = T[q] = {
                index: q,
                advanceWidth: P.hmtx.aWidth[q],
                xMin: I,
                yMin: F,
                xMax: k,
                yMax: Q,
                path: X
              };
            }
            he.call(
              null,
              ne,
              ee + j[te * 3] * le,
              j[te * 3 + 1] * le,
              Y
            ), ee += j[te * 3 + 2] * le, G && (ee += G * A);
          }
          Y += O.codePointAt(Y) > 65535 ? 2 : 1;
        }), ee;
      }
    };
    return D;
  }
  return function(T) {
    const b = new Uint8Array(T, 0, 4), M = s._bin.readASCII(b, 0, 4);
    if (M === "wOFF")
      T = e(T);
    else if (M === "wOF2")
      throw new Error("woff2 fonts not supported");
    return E(s.parse(T)[0]);
  };
}
const M6 = /* @__PURE__ */ jo({
  name: "Typr Font Parser",
  dependencies: [b6, w6, S6],
  init(s, e, n) {
    const i = s(), r = e();
    return n(i, r);
  }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function C6() {
  return function(s) {
    var e = function() {
      this.buckets = /* @__PURE__ */ new Map();
    };
    e.prototype.add = function(w) {
      var x = w >> 5;
      this.buckets.set(x, (this.buckets.get(x) || 0) | 1 << (31 & w));
    }, e.prototype.has = function(w) {
      var x = this.buckets.get(w >> 5);
      return x !== void 0 && (x & 1 << (31 & w)) != 0;
    }, e.prototype.serialize = function() {
      var w = [];
      return this.buckets.forEach(function(x, C) {
        w.push((+C).toString(36) + ":" + x.toString(36));
      }), w.join(",");
    }, e.prototype.deserialize = function(w) {
      var x = this;
      this.buckets.clear(), w.split(",").forEach(function(C) {
        var E = C.split(":");
        x.buckets.set(parseInt(E[0], 36), parseInt(E[1], 36));
      });
    };
    var n = Math.pow(2, 8), i = n - 1, r = ~i;
    function o(w) {
      var x = function(E) {
        return E & r;
      }(w).toString(16), C = function(E) {
        return (E & r) + n - 1;
      }(w).toString(16);
      return "codepoint-index/plane" + (w >> 16) + "/" + x + "-" + C + ".json";
    }
    function a(w, x) {
      var C = w & i, E = x.codePointAt(C / 6 | 0);
      return ((E = (E || 48) - 48) & 1 << C % 6) != 0;
    }
    function l(w, x) {
      var C;
      (C = w, C.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(E) {
        return E.split("-").map(function(P) {
          return parseInt(P.trim(), 16);
        });
      })).forEach(function(E) {
        var P = E[0], T = E[1];
        T === void 0 && (T = P), x(P, T);
      });
    }
    function c(w, x) {
      l(w, function(C, E) {
        for (var P = C; P <= E; P++) x(P);
      });
    }
    var u = {}, d = {}, h = /* @__PURE__ */ new WeakMap(), m = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";
    function p(w) {
      var x = h.get(w);
      return x || (x = new e(), c(w.ranges, function(C) {
        return x.add(C);
      }), h.set(w, x)), x;
    }
    var y, _ = /* @__PURE__ */ new Map();
    function v(w, x, C) {
      return w[x] ? x : w[C] ? C : function(E) {
        for (var P in E) return P;
      }(w);
    }
    function g(w, x) {
      var C = x;
      if (!w.includes(C)) {
        C = 1 / 0;
        for (var E = 0; E < w.length; E++) Math.abs(w[E] - x) < Math.abs(C - x) && (C = w[E]);
      }
      return C;
    }
    function S(w) {
      return y || (y = /* @__PURE__ */ new Set(), c("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(x) {
        y.add(x);
      })), y.has(w);
    }
    return s.CodePointSet = e, s.clearCache = function() {
      u = {}, d = {};
    }, s.getFontsForString = function(w, x) {
      x === void 0 && (x = {});
      var C, E = x.lang;
      E === void 0 && (E = new RegExp("\\p{Script=Hangul}", "u").test(C = w) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(C) ? "ja" : "en");
      var P = x.category;
      P === void 0 && (P = "sans-serif");
      var T = x.style;
      T === void 0 && (T = "normal");
      var b = x.weight;
      b === void 0 && (b = 400);
      var M = (x.dataUrl || m).replace(/\/$/g, ""), L = /* @__PURE__ */ new Map(), N = new Uint8Array(w.length), D = {}, O = {}, A = new Array(w.length), G = /* @__PURE__ */ new Map(), he = !1;
      function ee(Y) {
        var j = _.get(Y);
        return j || (j = fetch(M + "/" + Y).then(function(q) {
          if (!q.ok) throw new Error(q.statusText);
          return q.json().then(function(te) {
            if (!Array.isArray(te) || te[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + te[0]);
            return te[1];
          });
        }).catch(function(q) {
          if (M !== m) return he || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + M + '", trying default CDN. ' + q.message), he = !0), M = m, _.delete(Y), ee(Y);
          throw q;
        }), _.set(Y, j)), j;
      }
      for (var le = function(Y) {
        var j = w.codePointAt(Y), q = o(j);
        A[Y] = q, u[q] || G.has(q) || G.set(q, ee(q).then(function(te) {
          u[q] = te;
        })), j > 65535 && (Y++, oe = Y);
      }, oe = 0; oe < w.length; oe++) le(oe);
      return Promise.all(G.values()).then(function() {
        G.clear();
        for (var Y = function(q) {
          var te = w.codePointAt(q), ne = null, de = u[A[q]], H = void 0;
          for (var X in de) {
            var V = O[X];
            if (V === void 0 && (V = O[X] = new RegExp(X).test(E || "en")), V) {
              for (var I in H = X, de[X]) if (a(te, de[X][I])) {
                ne = I;
                break;
              }
              break;
            }
          }
          if (!ne) {
            e: for (var F in de) if (F !== H) {
              for (var k in de[F]) if (a(te, de[F][k])) {
                ne = k;
                break e;
              }
            }
          }
          ne || (console.debug("No font coverage for U+" + te.toString(16)), ne = "latin"), A[q] = ne, d[ne] || G.has(ne) || G.set(ne, ee("font-meta/" + ne + ".json").then(function(Q) {
            d[ne] = Q;
          })), te > 65535 && (q++, j = q);
        }, j = 0; j < w.length; j++) Y(j);
        return Promise.all(G.values());
      }).then(function() {
        for (var Y, j = null, q = 0; q < w.length; q++) {
          var te = w.codePointAt(q);
          if (j && (S(te) || p(j).has(te))) N[q] = N[q - 1];
          else {
            j = d[A[q]];
            var ne = D[j.id];
            if (!ne) {
              var de = j.typeforms, H = v(de, P, "sans-serif"), X = v(de[H], T, "normal"), V = g((Y = de[H]) === null || Y === void 0 ? void 0 : Y[X], b);
              ne = D[j.id] = M + "/font-files/" + j.id + "/" + H + "." + X + "." + V + ".woff";
            }
            var I = L.get(ne);
            I == null && (I = L.size, L.set(ne, I)), N[q] = I;
          }
          te > 65535 && (q++, N[q] = N[q - 1]);
        }
        return { fontUrls: Array.from(L.keys()), chars: N };
      });
    }, Object.defineProperty(s, "__esModule", { value: !0 }), s;
  }({});
}
function E6(s, e) {
  const n = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null);
  function r(a, l) {
    const c = (u) => {
      console.error(`Failure loading font ${a}`, u);
    };
    try {
      const u = new XMLHttpRequest();
      u.open("get", a, !0), u.responseType = "arraybuffer", u.onload = function() {
        if (u.status >= 400)
          c(new Error(u.statusText));
        else if (u.status > 0)
          try {
            const d = s(u.response);
            d.src = a, l(d);
          } catch (d) {
            c(d);
          }
      }, u.onerror = c, u.send();
    } catch (u) {
      c(u);
    }
  }
  function o(a, l) {
    let c = n[a];
    c ? l(c) : i[a] ? i[a].push(l) : (i[a] = [l], r(a, (u) => {
      u.src = a, n[a] = u, i[a].forEach((d) => d(u)), delete i[a];
    }));
  }
  return function(a, l, {
    lang: c,
    fonts: u = [],
    style: d = "normal",
    weight: h = "normal",
    unicodeFontsURL: m
  } = {}) {
    const p = new Uint8Array(a.length), y = [];
    a.length || S();
    const _ = /* @__PURE__ */ new Map(), v = [];
    if (d !== "italic" && (d = "normal"), typeof h != "number" && (h = h === "bold" ? 700 : 400), u && !Array.isArray(u) && (u = [u]), u = u.slice().filter((x) => !x.lang || x.lang.test(c)).reverse(), u.length) {
      let P = 0;
      (function T(b = 0) {
        for (let M = b, L = a.length; M < L; M++) {
          const N = a.codePointAt(M);
          if (P === 1 && y[p[M - 1]].supportsCodePoint(N) || M > 0 && /\s/.test(a[M]))
            p[M] = p[M - 1], P === 2 && (v[v.length - 1][1] = M);
          else
            for (let D = p[M], O = u.length; D <= O; D++)
              if (D === O) {
                const A = P === 2 ? v[v.length - 1] : v[v.length] = [M, M];
                A[1] = M, P = 2;
              } else {
                p[M] = D;
                const { src: A, unicodeRange: G } = u[D];
                if (!G || w(N, G)) {
                  const he = n[A];
                  if (!he) {
                    o(A, () => {
                      T(M);
                    });
                    return;
                  }
                  if (he.supportsCodePoint(N)) {
                    let ee = _.get(he);
                    typeof ee != "number" && (ee = y.length, y.push(he), _.set(he, ee)), p[M] = ee, P = 1;
                    break;
                  }
                }
              }
          N > 65535 && M + 1 < L && (p[M + 1] = p[M], M++, P === 2 && (v[v.length - 1][1] = M));
        }
        g();
      })();
    } else
      v.push([0, a.length - 1]), g();
    function g() {
      if (v.length) {
        const x = v.map((C) => a.substring(C[0], C[1] + 1)).join(`
`);
        e.getFontsForString(x, {
          lang: c || void 0,
          style: d,
          weight: h,
          dataUrl: m
        }).then(({ fontUrls: C, chars: E }) => {
          const P = y.length;
          let T = 0;
          v.forEach((M) => {
            for (let L = 0, N = M[1] - M[0]; L <= N; L++)
              p[M[0] + L] = E[T++] + P;
            T++;
          });
          let b = 0;
          C.forEach((M, L) => {
            o(M, (N) => {
              y[L + P] = N, ++b === C.length && S();
            });
          });
        });
      } else
        S();
    }
    function S() {
      l({
        chars: p,
        fonts: y
      });
    }
    function w(x, C) {
      for (let E = 0; E < C.length; E++) {
        const [P, T = P] = C[E];
        if (P <= x && x <= T)
          return !0;
      }
      return !1;
    }
  };
}
const T6 = /* @__PURE__ */ jo({
  name: "FontResolver",
  dependencies: [
    E6,
    M6,
    C6
  ],
  init(s, e, n) {
    return s(e, n());
  }
});
function A6(s, e) {
  const i = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/, r = "[^\\S\\u00A0]", o = new RegExp(`${r}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);
  function a({ text: y, lang: _, fonts: v, style: g, weight: S, preResolvedFonts: w, unicodeFontsURL: x }, C) {
    const E = ({ chars: P, fonts: T }) => {
      let b, M;
      const L = [];
      for (let N = 0; N < P.length; N++)
        P[N] !== M ? (M = P[N], L.push(b = { start: N, end: N, fontObj: T[P[N]] })) : b.end = N;
      C(L);
    };
    w ? E(w) : s(
      y,
      E,
      { lang: _, fonts: v, style: g, weight: S, unicodeFontsURL: x }
    );
  }
  function l({
    text: y = "",
    font: _,
    lang: v,
    sdfGlyphSize: g = 64,
    fontSize: S = 400,
    fontWeight: w = 1,
    fontStyle: x = "normal",
    letterSpacing: C = 0,
    lineHeight: E = "normal",
    maxWidth: P = 1 / 0,
    direction: T,
    textAlign: b = "left",
    textIndent: M = 0,
    whiteSpace: L = "normal",
    overflowWrap: N = "normal",
    anchorX: D = 0,
    anchorY: O = 0,
    metricsOnly: A = !1,
    unicodeFontsURL: G,
    preResolvedFonts: he = null,
    includeCaretPositions: ee = !1,
    chunkedBoundsSize: le = 8192,
    colorRanges: oe = null
  }, Y) {
    const j = h(), q = { fontLoad: 0, typesetting: 0 };
    y.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), y = y.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), S = +S, C = +C, P = +P, E = E || "normal", M = +M, a({
      text: y,
      lang: v,
      style: x,
      weight: w,
      fonts: typeof _ == "string" ? [{ src: _ }] : _,
      unicodeFontsURL: G,
      preResolvedFonts: he
    }, (te) => {
      q.fontLoad = h() - j;
      const ne = isFinite(P);
      let de = null, H = null, X = null, V = null, I = null, F = null, k = null, Q = null, Z = 0, R = 0, ie = L !== "nowrap";
      const J = /* @__PURE__ */ new Map(), B = h();
      let $ = M, se = 0, U = new m();
      const z = [U];
      te.forEach((Me) => {
        const { fontObj: Te } = Me, { ascender: Ae, descender: Xe, unitsPerEm: Fe, lineGap: He, capHeight: Ye, xHeight: We } = Te;
        let ke = J.get(Te);
        if (!ke) {
          const ze = S / Fe, De = E === "normal" ? (Ae - Xe + He) * ze : E * S, Be = (De - (Ae - Xe) * ze) / 2, je = Math.min(De, (Ae - Xe) * ze), Ve = (Ae + Xe) / 2 * ze + je / 2;
          ke = {
            index: J.size,
            src: Te.src,
            fontObj: Te,
            fontSizeMult: ze,
            unitsPerEm: Fe,
            ascender: Ae * ze,
            descender: Xe * ze,
            capHeight: Ye * ze,
            xHeight: We * ze,
            lineHeight: De,
            baseline: -Be - Ae * ze,
            // baseline offset from top of line height
            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height
            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height
            caretTop: Ve,
            caretBottom: Ve - je
          }, J.set(Te, ke);
        }
        const { fontSizeMult: nt } = ke, Je = y.slice(Me.start, Me.end + 1);
        let _t, we;
        Te.forEachGlyph(Je, S, C, (ze, De, Be, je) => {
          De += se, je += Me.start, _t = De, we = ze;
          const Ve = y.charAt(je), lt = ze.advanceWidth * nt, rt = U.count;
          let ut;
          if ("isEmpty" in ze || (ze.isWhitespace = !!Ve && new RegExp(r).test(Ve), ze.canBreakAfter = !!Ve && o.test(Ve), ze.isEmpty = ze.xMin === ze.xMax || ze.yMin === ze.yMax || i.test(Ve)), !ze.isWhitespace && !ze.isEmpty && R++, ie && ne && !ze.isWhitespace && De + lt + $ > P && rt) {
            if (U.glyphAt(rt - 1).glyphObj.canBreakAfter)
              ut = new m(), $ = -De;
            else
              for (let Ot = rt; Ot--; )
                if (Ot === 0 && N === "break-word") {
                  ut = new m(), $ = -De;
                  break;
                } else if (U.glyphAt(Ot).glyphObj.canBreakAfter) {
                  ut = U.splitAt(Ot + 1);
                  const Kt = ut.glyphAt(0).x;
                  $ -= Kt;
                  for (let sn = ut.count; sn--; )
                    ut.glyphAt(sn).x -= Kt;
                  break;
                }
            ut && (U.isSoftWrapped = !0, U = ut, z.push(U), Z = P);
          }
          let pt = U.glyphAt(U.count);
          pt.glyphObj = ze, pt.x = De + $, pt.y = Be, pt.width = lt, pt.charIndex = je, pt.fontData = ke, Ve === `
` && (U = new m(), z.push(U), $ = -(De + lt + C * S) + M);
        }), se = _t + we.advanceWidth * nt + C * S;
      });
      let K = 0;
      z.forEach((Me) => {
        let Te = !0;
        for (let Ae = Me.count; Ae--; ) {
          const Xe = Me.glyphAt(Ae);
          Te && !Xe.glyphObj.isWhitespace && (Me.width = Xe.x + Xe.width, Me.width > Z && (Z = Me.width), Te = !1);
          let { lineHeight: Fe, capHeight: He, xHeight: Ye, baseline: We } = Xe.fontData;
          Fe > Me.lineHeight && (Me.lineHeight = Fe);
          const ke = We - Me.baseline;
          ke < 0 && (Me.baseline += ke, Me.cap += ke, Me.ex += ke), Me.cap = Math.max(Me.cap, Me.baseline + He), Me.ex = Math.max(Me.ex, Me.baseline + Ye);
        }
        Me.baseline -= K, Me.cap -= K, Me.ex -= K, K += Me.lineHeight;
      });
      let ue = 0, me = 0;
      if (D && (typeof D == "number" ? ue = -D : typeof D == "string" && (ue = -Z * (D === "left" ? 0 : D === "center" ? 0.5 : D === "right" ? 1 : u(D)))), O && (typeof O == "number" ? me = -O : typeof O == "string" && (me = O === "top" ? 0 : O === "top-baseline" ? -z[0].baseline : O === "top-cap" ? -z[0].cap : O === "top-ex" ? -z[0].ex : O === "middle" ? K / 2 : O === "bottom" ? K : O === "bottom-baseline" ? -z[z.length - 1].baseline : u(O) * K)), !A) {
        const Me = e.getEmbeddingLevels(y, T);
        de = new Uint16Array(R), H = new Uint8Array(R), X = new Float32Array(R * 2), V = {}, k = [1 / 0, 1 / 0, -1 / 0, -1 / 0], Q = [], ee && (F = new Float32Array(y.length * 4)), oe && (I = new Uint8Array(R * 3));
        let Te = 0, Ae = -1, Xe = -1, Fe, He;
        if (z.forEach((Ye, We) => {
          let { count: ke, width: nt } = Ye;
          if (ke > 0) {
            let Je = 0;
            for (let je = ke; je-- && Ye.glyphAt(je).glyphObj.isWhitespace; )
              Je++;
            let _t = 0, we = 0;
            if (b === "center")
              _t = (Z - nt) / 2;
            else if (b === "right")
              _t = Z - nt;
            else if (b === "justify" && Ye.isSoftWrapped) {
              let je = 0;
              for (let Ve = ke - Je; Ve--; )
                Ye.glyphAt(Ve).glyphObj.isWhitespace && je++;
              we = (Z - nt) / je;
            }
            if (we || _t) {
              let je = 0;
              for (let Ve = 0; Ve < ke; Ve++) {
                let lt = Ye.glyphAt(Ve);
                const rt = lt.glyphObj;
                lt.x += _t + je, we !== 0 && rt.isWhitespace && Ve < ke - Je && (je += we, lt.width += we);
              }
            }
            const ze = e.getReorderSegments(
              y,
              Me,
              Ye.glyphAt(0).charIndex,
              Ye.glyphAt(Ye.count - 1).charIndex
            );
            for (let je = 0; je < ze.length; je++) {
              const [Ve, lt] = ze[je];
              let rt = 1 / 0, ut = -1 / 0;
              for (let pt = 0; pt < ke; pt++)
                if (Ye.glyphAt(pt).charIndex >= Ve) {
                  let Ot = pt, Kt = pt;
                  for (; Kt < ke; Kt++) {
                    let sn = Ye.glyphAt(Kt);
                    if (sn.charIndex > lt)
                      break;
                    Kt < ke - Je && (rt = Math.min(rt, sn.x), ut = Math.max(ut, sn.x + sn.width));
                  }
                  for (let sn = Ot; sn < Kt; sn++) {
                    const Un = Ye.glyphAt(sn);
                    Un.x = ut - (Un.x + Un.width - rt);
                  }
                  break;
                }
            }
            let De;
            const Be = (je) => De = je;
            for (let je = 0; je < ke; je++) {
              const Ve = Ye.glyphAt(je);
              De = Ve.glyphObj;
              const lt = De.index, rt = Me.levels[Ve.charIndex] & 1;
              if (rt) {
                const ut = e.getMirroredCharacter(y[Ve.charIndex]);
                ut && Ve.fontData.fontObj.forEachGlyph(ut, 0, 0, Be);
              }
              if (ee) {
                const { charIndex: ut, fontData: pt } = Ve, Ot = Ve.x + ue, Kt = Ve.x + Ve.width + ue;
                F[ut * 4] = rt ? Kt : Ot, F[ut * 4 + 1] = rt ? Ot : Kt, F[ut * 4 + 2] = Ye.baseline + pt.caretBottom + me, F[ut * 4 + 3] = Ye.baseline + pt.caretTop + me;
                const sn = ut - Ae;
                sn > 1 && d(F, Ae, sn), Ae = ut;
              }
              if (oe) {
                const { charIndex: ut } = Ve;
                for (; ut > Xe; )
                  Xe++, oe.hasOwnProperty(Xe) && (He = oe[Xe]);
              }
              if (!De.isWhitespace && !De.isEmpty) {
                const ut = Te++, { fontSizeMult: pt, src: Ot, index: Kt } = Ve.fontData, sn = V[Ot] || (V[Ot] = {});
                sn[lt] || (sn[lt] = {
                  path: De.path,
                  pathBounds: [De.xMin, De.yMin, De.xMax, De.yMax]
                });
                const Un = Ve.x + ue, xn = Ve.y + Ye.baseline + me;
                X[ut * 2] = Un, X[ut * 2 + 1] = xn;
                const Yn = Un + De.xMin * pt, hi = xn + De.yMin * pt, fi = Un + De.xMax * pt, On = xn + De.yMax * pt;
                Yn < k[0] && (k[0] = Yn), hi < k[1] && (k[1] = hi), fi > k[2] && (k[2] = fi), On > k[3] && (k[3] = On), ut % le === 0 && (Fe = { start: ut, end: ut, rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0] }, Q.push(Fe)), Fe.end++;
                const bn = Fe.rect;
                if (Yn < bn[0] && (bn[0] = Yn), hi < bn[1] && (bn[1] = hi), fi > bn[2] && (bn[2] = fi), On > bn[3] && (bn[3] = On), de[ut] = lt, H[ut] = Kt, oe) {
                  const ni = ut * 3;
                  I[ni] = He >> 16 & 255, I[ni + 1] = He >> 8 & 255, I[ni + 2] = He & 255;
                }
              }
            }
          }
        }), F) {
          const Ye = y.length - Ae;
          Ye > 1 && d(F, Ae, Ye);
        }
      }
      const ge = [];
      J.forEach(({ index: Me, src: Te, unitsPerEm: Ae, ascender: Xe, descender: Fe, lineHeight: He, capHeight: Ye, xHeight: We }) => {
        ge[Me] = { src: Te, unitsPerEm: Ae, ascender: Xe, descender: Fe, lineHeight: He, capHeight: Ye, xHeight: We };
      }), q.typesetting = h() - B, Y({
        glyphIds: de,
        //id for each glyph, specific to that glyph's font
        glyphFontIndices: H,
        //index into fontData for each glyph
        glyphPositions: X,
        //x,y of each glyph's origin in layout
        glyphData: V,
        //dict holding data about each glyph appearing in the text
        fontData: ge,
        //data about each font used in the text
        caretPositions: F,
        //startX,endX,bottomY caret positions for each char
        // caretHeight, //height of cursor from bottom to top - todo per glyph?
        glyphColors: I,
        //color for each glyph, if color ranges supplied
        chunkedBounds: Q,
        //total rects per (n=chunkedBoundsSize) consecutive glyphs
        fontSize: S,
        //calculated em height
        topBaseline: me + z[0].baseline,
        //y coordinate of the top line's baseline
        blockBounds: [
          //bounds for the whole block of text, including vertical padding for lineHeight
          ue,
          me - K,
          ue + Z,
          me
        ],
        visibleBounds: k,
        //total bounds of visible text paths, may be larger or smaller than blockBounds
        timings: q
      });
    });
  }
  function c(y, _) {
    l({ ...y, metricsOnly: !0 }, (v) => {
      const [g, S, w, x] = v.blockBounds;
      _({
        width: w - g,
        height: x - S
      });
    });
  }
  function u(y) {
    let _ = y.match(/^([\d.]+)%$/), v = _ ? parseFloat(_[1]) : NaN;
    return isNaN(v) ? 0 : v / 100;
  }
  function d(y, _, v) {
    const g = y[_ * 4], S = y[_ * 4 + 1], w = y[_ * 4 + 2], x = y[_ * 4 + 3], C = (S - g) / v;
    for (let E = 0; E < v; E++) {
      const P = (_ + E) * 4;
      y[P] = g + C * E, y[P + 1] = g + C * (E + 1), y[P + 2] = w, y[P + 3] = x;
    }
  }
  function h() {
    return (self.performance || Date).now();
  }
  function m() {
    this.data = [];
  }
  const p = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
  return m.prototype = {
    width: 0,
    lineHeight: 0,
    baseline: 0,
    cap: 0,
    ex: 0,
    isSoftWrapped: !1,
    get count() {
      return Math.ceil(this.data.length / p.length);
    },
    glyphAt(y) {
      let _ = m.flyweight;
      return _.data = this.data, _.index = y, _;
    },
    splitAt(y) {
      let _ = new m();
      return _.data = this.data.splice(y * p.length), _;
    }
  }, m.flyweight = p.reduce((y, _, v, g) => (Object.defineProperty(y, _, {
    get() {
      return this.data[this.index * p.length + v];
    },
    set(S) {
      this.data[this.index * p.length + v] = S;
    }
  }), y), { data: null, index: 0 }), {
    typeset: l,
    measure: c
  };
}
const Ur = () => (self.performance || Date).now(), wu = /* @__PURE__ */ yy();
let Pv;
function P6(s, e, n, i, r, o, a, l, c, u, d = !0) {
  return d ? R6(s, e, n, i, r, o, a, l, c, u).then(
    null,
    (h) => (Pv || (console.warn("WebGL SDF generation failed, falling back to JS", h), Pv = !0), Rv(s, e, n, i, r, o, a, l, c, u))
  ) : Rv(s, e, n, i, r, o, a, l, c, u);
}
const Rc = [], D6 = 5;
let $h = 0;
function xy() {
  const s = Ur();
  for (; Rc.length && Ur() - s < D6; )
    Rc.shift()();
  $h = Rc.length ? setTimeout(xy, 0) : 0;
}
const R6 = (...s) => new Promise((e, n) => {
  Rc.push(() => {
    const i = Ur();
    try {
      wu.webgl.generateIntoCanvas(...s), e({ timing: Ur() - i });
    } catch (r) {
      n(r);
    }
  }), $h || ($h = setTimeout(xy, 0));
}), I6 = 4, k6 = 2e3, Dv = {};
let L6 = 0;
function Rv(s, e, n, i, r, o, a, l, c, u) {
  const d = "TroikaTextSDFGenerator_JS_" + L6++ % I6;
  let h = Dv[d];
  return h || (h = Dv[d] = {
    workerModule: jo({
      name: d,
      workerId: d,
      dependencies: [
        yy,
        Ur
      ],
      init(m, p) {
        const y = m().javascript.generate;
        return function(..._) {
          const v = p();
          return {
            textureData: y(..._),
            timing: p() - v
          };
        };
      },
      getTransferables(m) {
        return [m.textureData.buffer];
      }
    }),
    requests: 0,
    idleTimer: null
  }), h.requests++, clearTimeout(h.idleTimer), h.workerModule(s, e, n, i, r, o).then(({ textureData: m, timing: p }) => {
    const y = Ur(), _ = new Uint8Array(m.length * 4);
    for (let v = 0; v < m.length; v++)
      _[v * 4 + u] = m[v];
    return wu.webglUtils.renderImageData(a, _, l, c, s, e, 1 << 3 - u), p += Ur() - y, --h.requests === 0 && (h.idleTimer = setTimeout(() => {
      d6(d);
    }, k6)), { timing: p };
  });
}
function F6(s) {
  s._warm || (wu.webgl.isSupported(s), s._warm = !0);
}
const U6 = wu.webglUtils.resizeWebGLCanvasWithoutClearing, Ea = {
  unicodeFontsURL: null,
  sdfGlyphSize: 64,
  sdfMargin: 1 / 16,
  sdfExponent: 9,
  textureWidth: 2048
}, O6 = /* @__PURE__ */ new Mt();
function uo() {
  return (self.performance || Date).now();
}
const Iv = /* @__PURE__ */ Object.create(null);
function z6(s, e) {
  s = B6({}, s);
  const n = uo(), i = [];
  if (s.font && i.push({ label: "user", src: V6(s.font) }), s.font = i, s.text = "" + s.text, s.sdfGlyphSize = s.sdfGlyphSize || Ea.sdfGlyphSize, s.unicodeFontsURL = s.unicodeFontsURL || Ea.unicodeFontsURL, s.colorRanges != null) {
    let m = {};
    for (let p in s.colorRanges)
      if (s.colorRanges.hasOwnProperty(p)) {
        let y = s.colorRanges[p];
        typeof y != "number" && (y = O6.set(y).getHex()), m[p] = y;
      }
    s.colorRanges = m;
  }
  Object.freeze(s);
  const { textureWidth: r, sdfExponent: o } = Ea, { sdfGlyphSize: a } = s, l = r / a * 4;
  let c = Iv[a];
  if (!c) {
    const m = document.createElement("canvas");
    m.width = r, m.height = a * 256 / l, c = Iv[a] = {
      glyphCount: 0,
      sdfGlyphSize: a,
      sdfCanvas: m,
      sdfTexture: new yn(
        m,
        void 0,
        void 0,
        void 0,
        Xt,
        Xt
      ),
      contextLost: !1,
      glyphsByFont: /* @__PURE__ */ new Map()
    }, c.sdfTexture.generateMipmaps = !1, N6(c);
  }
  const { sdfTexture: u, sdfCanvas: d } = c;
  Sy(s).then((m) => {
    const { glyphIds: p, glyphFontIndices: y, fontData: _, glyphPositions: v, fontSize: g, timings: S } = m, w = [], x = new Float32Array(p.length * 4);
    let C = 0, E = 0;
    const P = uo(), T = _.map((D) => {
      let O = c.glyphsByFont.get(D.src);
      return O || c.glyphsByFont.set(D.src, O = /* @__PURE__ */ new Map()), O;
    });
    p.forEach((D, O) => {
      const A = y[O], { src: G, unitsPerEm: he } = _[A];
      let ee = T[A].get(D);
      if (!ee) {
        const { path: q, pathBounds: te } = m.glyphData[G][D], ne = Math.max(te[2] - te[0], te[3] - te[1]) / a * (Ea.sdfMargin * a + 0.5), de = c.glyphCount++, H = [
          te[0] - ne,
          te[1] - ne,
          te[2] + ne,
          te[3] + ne
        ];
        T[A].set(D, ee = { path: q, atlasIndex: de, sdfViewBox: H }), w.push(ee);
      }
      const { sdfViewBox: le } = ee, oe = v[E++], Y = v[E++], j = g / he;
      x[C++] = oe + le[0] * j, x[C++] = Y + le[1] * j, x[C++] = oe + le[2] * j, x[C++] = Y + le[3] * j, p[O] = ee.atlasIndex;
    }), S.quads = (S.quads || 0) + (uo() - P);
    const b = uo();
    S.sdf = {};
    const M = d.height, L = Math.ceil(c.glyphCount / l), N = Math.pow(2, Math.ceil(Math.log2(L * a)));
    N > M && (console.info(`Increasing SDF texture size ${M}->${N}`), U6(d, r, N), u.dispose()), Promise.all(w.map(
      (D) => by(D, c, s.gpuAccelerateSDF).then(({ timing: O }) => {
        S.sdf[D.atlasIndex] = O;
      })
    )).then(() => {
      w.length && !c.contextLost && (wy(c), u.needsUpdate = !0), S.sdfTotal = uo() - b, S.total = uo() - n, e(Object.freeze({
        parameters: s,
        sdfTexture: u,
        sdfGlyphSize: a,
        sdfExponent: o,
        glyphBounds: x,
        glyphAtlasIndices: p,
        glyphColors: m.glyphColors,
        caretPositions: m.caretPositions,
        chunkedBounds: m.chunkedBounds,
        ascender: m.ascender,
        descender: m.descender,
        lineHeight: m.lineHeight,
        capHeight: m.capHeight,
        xHeight: m.xHeight,
        topBaseline: m.topBaseline,
        blockBounds: m.blockBounds,
        visibleBounds: m.visibleBounds,
        timings: m.timings
      }));
    });
  }), Promise.resolve().then(() => {
    c.contextLost || F6(d);
  });
}
function by({ path: s, atlasIndex: e, sdfViewBox: n }, { sdfGlyphSize: i, sdfCanvas: r, contextLost: o }, a) {
  if (o)
    return Promise.resolve({ timing: -1 });
  const { textureWidth: l, sdfExponent: c } = Ea, u = Math.max(n[2] - n[0], n[3] - n[1]), d = Math.floor(e / 4), h = d % (l / i) * i, m = Math.floor(d / (l / i)) * i, p = e % 4;
  return P6(i, i, s, n, u, c, r, h, m, p, a);
}
function N6(s) {
  const e = s.sdfCanvas;
  e.addEventListener("webglcontextlost", (n) => {
    console.log("Context Lost", n), n.preventDefault(), s.contextLost = !0;
  }), e.addEventListener("webglcontextrestored", (n) => {
    console.log("Context Restored", n), s.contextLost = !1;
    const i = [];
    s.glyphsByFont.forEach((r) => {
      r.forEach((o) => {
        i.push(by(o, s, !0));
      });
    }), Promise.all(i).then(() => {
      wy(s), s.sdfTexture.needsUpdate = !0;
    });
  });
}
function B6(s, e) {
  for (let n in e)
    e.hasOwnProperty(n) && (s[n] = e[n]);
  return s;
}
let dc;
function V6(s) {
  return dc || (dc = typeof document > "u" ? {} : document.createElement("a")), dc.href = s, dc.href;
}
function wy(s) {
  if (typeof createImageBitmap != "function") {
    console.info("Safari<15: applying SDF canvas workaround");
    const { sdfCanvas: e, sdfTexture: n } = s, { width: i, height: r } = e, o = s.sdfCanvas.getContext("webgl");
    let a = n.image.data;
    (!a || a.length !== i * r * 4) && (a = new Uint8Array(i * r * 4), n.image = { width: i, height: r, data: a }, n.flipY = !1, n.isDataTexture = !0), o.readPixels(0, 0, i, r, o.RGBA, o.UNSIGNED_BYTE, a);
  }
}
const G6 = /* @__PURE__ */ jo({
  name: "Typesetter",
  dependencies: [
    A6,
    T6,
    f6
  ],
  init(s, e, n) {
    return s(e, n());
  }
}), Sy = /* @__PURE__ */ jo({
  name: "Typesetter",
  dependencies: [
    G6
  ],
  init(s) {
    return function(e) {
      return new Promise((n) => {
        s.typeset(e, n);
      });
    };
  },
  getTransferables(s) {
    const e = [];
    for (let n in s)
      s[n] && s[n].buffer && e.push(s[n].buffer);
    return e;
  }
});
Sy.onMainThread;
const kv = {};
function H6(s) {
  let e = kv[s];
  return e || (e = kv[s] = new cn(1, 1, s, s).translate(0.5, 0.5, 0)), e;
}
const W6 = "aTroikaGlyphBounds", Lv = "aTroikaGlyphIndex", $6 = "aTroikaGlyphColor";
class X6 extends ly {
  constructor() {
    super(), this.detail = 1, this.curveRadius = 0, this.groups = [
      { start: 0, count: 1 / 0, materialIndex: 0 },
      { start: 0, count: 1 / 0, materialIndex: 1 }
    ], this.boundingSphere = new pl(), this.boundingBox = new rr();
  }
  computeBoundingSphere() {
  }
  computeBoundingBox() {
  }
  set detail(e) {
    if (e !== this._detail) {
      this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
      let n = H6(e);
      ["position", "normal", "uv"].forEach((i) => {
        this.attributes[i] = n.attributes[i].clone();
      }), this.setIndex(n.getIndex().clone());
    }
  }
  get detail() {
    return this._detail;
  }
  set curveRadius(e) {
    e !== this._curveRadius && (this._curveRadius = e, this._updateBounds());
  }
  get curveRadius() {
    return this._curveRadius;
  }
  /**
   * Update the geometry for a new set of glyphs.
   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs
   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1
   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within
   *        the SDF atlas texture.
   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs
   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N
   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be
   *        used with `applyClipRect` to choose an optimized `instanceCount`.
   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.
   */
  updateGlyphs(e, n, i, r, o) {
    this.updateAttributeData(W6, e, 4), this.updateAttributeData(Lv, n, 1), this.updateAttributeData($6, o, 3), this._blockBounds = i, this._chunkedBounds = r, this.instanceCount = n.length, this._updateBounds();
  }
  _updateBounds() {
    const e = this._blockBounds;
    if (e) {
      const { curveRadius: n, boundingBox: i } = this;
      if (n) {
        const { PI: r, floor: o, min: a, max: l, sin: c, cos: u } = Math, d = r / 2, h = r * 2, m = Math.abs(n), p = e[0] / m, y = e[2] / m, _ = o((p + d) / h) !== o((y + d) / h) ? -m : a(c(p) * m, c(y) * m), v = o((p - d) / h) !== o((y - d) / h) ? m : l(c(p) * m, c(y) * m), g = o((p + r) / h) !== o((y + r) / h) ? m * 2 : l(m - u(p) * m, m - u(y) * m);
        i.min.set(_, e[1], n < 0 ? -g : 0), i.max.set(v, e[3], n < 0 ? 0 : g);
      } else
        i.min.set(e[0], e[1], 0), i.max.set(e[2], e[3], 0);
      i.getBoundingSphere(this.boundingSphere);
    }
  }
  /**
   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest
   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization
   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would
   * be clipped anyway.
   *
   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting
   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the
   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,
   * but at the expense of much larger attribute buffers (see classdoc above.)
   *
   * @param {Vector4} clipRect
   */
  applyClipRect(e) {
    let n = this.getAttribute(Lv).count, i = this._chunkedBounds;
    if (i)
      for (let r = i.length; r--; ) {
        n = i[r].end;
        let o = i[r].rect;
        if (o[1] < e.w && o[3] > e.y && o[0] < e.z && o[2] > e.x)
          break;
      }
    this.instanceCount = n;
  }
  /**
   * Utility for updating instance attributes with automatic resizing
   */
  updateAttributeData(e, n, i) {
    const r = this.getAttribute(e);
    n ? r && r.array.length === n.length ? (r.array.set(n), r.needsUpdate = !0) : (this.setAttribute(e, new Sr(n, i)), delete this._maxInstanceCount, this.dispose()) : r && this.deleteAttribute(e);
  }
}
const j6 = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`, Y6 = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`, q6 = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`, Z6 = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;
function K6(s) {
  const e = Wh(s, {
    chained: !0,
    extensions: {
      derivatives: !0
    },
    uniforms: {
      uTroikaSDFTexture: { value: null },
      uTroikaSDFTextureSize: { value: new st() },
      uTroikaSDFGlyphSize: { value: 0 },
      uTroikaSDFExponent: { value: 0 },
      uTroikaTotalBounds: { value: new jt(0, 0, 0, 0) },
      uTroikaClipRect: { value: new jt(0, 0, 0, 0) },
      uTroikaEdgeOffset: { value: 0 },
      uTroikaFillOpacity: { value: 1 },
      uTroikaPositionOffset: { value: new st() },
      uTroikaCurveRadius: { value: 0 },
      uTroikaBlurRadius: { value: 0 },
      uTroikaStrokeWidth: { value: 0 },
      uTroikaStrokeColor: { value: new Mt() },
      uTroikaStrokeOpacity: { value: 1 },
      uTroikaOrient: { value: new Et() },
      uTroikaUseGlyphColors: { value: !0 },
      uTroikaSDFDebug: { value: !1 }
    },
    vertexDefs: j6,
    vertexTransform: Y6,
    fragmentDefs: q6,
    fragmentColorTransform: Z6,
    customRewriter({ vertexShader: n, fragmentShader: i }) {
      let r = /\buniform\s+vec3\s+diffuse\b/;
      return r.test(i) && (i = i.replace(r, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), r.test(n) || (n = n.replace(
        _y,
        `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`
      ))), { vertexShader: n, fragmentShader: i };
    }
  });
  return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
    isTroikaTextMaterial: { value: !0 },
    // WebGLShadowMap reverses the side of the shadow material by default, which fails
    // for planes, so here we force the `shadowSide` to always match the main side.
    shadowSide: {
      get() {
        return this.side;
      },
      set() {
      }
    }
  }), e;
}
const Vf = /* @__PURE__ */ new Mn({
  color: 16777215,
  side: mn,
  transparent: !0
}), Fv = 8421504, Uv = /* @__PURE__ */ new Zt(), hc = /* @__PURE__ */ new ce(), Ld = /* @__PURE__ */ new ce(), pa = [], J6 = /* @__PURE__ */ new ce(), Fd = "+x+y";
function Ov(s) {
  return Array.isArray(s) ? s[0] : s;
}
let My = () => {
  const s = new qe(
    new cn(1, 1),
    Vf
  );
  return My = () => s, s;
}, Cy = () => {
  const s = new qe(
    new cn(1, 1, 32, 1),
    Vf
  );
  return Cy = () => s, s;
};
const Q6 = { type: "syncstart" }, eN = { type: "synccomplete" }, Ey = [
  "font",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "lang",
  "letterSpacing",
  "lineHeight",
  "maxWidth",
  "overflowWrap",
  "text",
  "direction",
  "textAlign",
  "textIndent",
  "whiteSpace",
  "anchorX",
  "anchorY",
  "colorRanges",
  "sdfGlyphSize"
], tN = Ey.concat(
  "material",
  "color",
  "depthOffset",
  "clipRect",
  "curveRadius",
  "orientation",
  "glyphGeometryDetail"
);
class Xh extends qe {
  constructor() {
    const e = new X6();
    super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = 0.1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = Fv, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = Fd, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1;
  }
  /**
   * Updates the text rendering according to the current text-related configuration properties.
   * This is an async process, so you can pass in a callback function to be executed when it
   * finishes.
   * @param {function} [callback]
   */
  sync(e) {
    this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(Q6), z6({
      text: this.text,
      font: this.font,
      lang: this.lang,
      fontSize: this.fontSize || 0.1,
      fontWeight: this.fontWeight || "normal",
      fontStyle: this.fontStyle || "normal",
      letterSpacing: this.letterSpacing || 0,
      lineHeight: this.lineHeight || "normal",
      maxWidth: this.maxWidth,
      direction: this.direction || "auto",
      textAlign: this.textAlign,
      textIndent: this.textIndent,
      whiteSpace: this.whiteSpace,
      overflowWrap: this.overflowWrap,
      anchorX: this.anchorX,
      anchorY: this.anchorY,
      colorRanges: this.colorRanges,
      includeCaretPositions: !0,
      //TODO parameterize
      sdfGlyphSize: this.sdfGlyphSize,
      gpuAccelerateSDF: this.gpuAccelerateSDF,
      unicodeFontsURL: this.unicodeFontsURL
    }, (n) => {
      this._isSyncing = !1, this._textRenderInfo = n, this.geometry.updateGlyphs(
        n.glyphBounds,
        n.glyphAtlasIndices,
        n.blockBounds,
        n.chunkedBounds,
        n.glyphColors
      );
      const i = this._queuedSyncs;
      i && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
        i.forEach((r) => r && r());
      })), this.dispatchEvent(eN), e && e();
    })));
  }
  /**
   * Initiate a sync if needed - note it won't complete until next frame at the
   * earliest so if possible it's a good idea to call sync() manually as soon as
   * all the properties have been set.
   * @override
   */
  onBeforeRender(e, n, i, r, o, a) {
    this.sync(), o.isTroikaTextMaterial && this._prepareForRender(o);
  }
  /**
   * Shortcut to dispose the geometry specific to this instance.
   * Note: we don't also dispose the derived material here because if anything else is
   * sharing the same base material it will result in a pause next frame as the program
   * is recompiled. Instead users can dispose the base material manually, like normal,
   * and we'll also dispose the derived material at that time.
   */
  dispose() {
    this.geometry.dispose();
  }
  /**
   * @property {TroikaTextRenderInfo|null} textRenderInfo
   * @readonly
   * The current processed rendering data for this TextMesh, returned by the TextBuilder after
   * a `sync()` call. This will be `null` initially, and may be stale for a short period until
   * the asynchrous `sync()` process completes.
   */
  get textRenderInfo() {
    return this._textRenderInfo || null;
  }
  /**
   * Create the text derived material from the base material. Can be overridden to use a custom
   * derived material.
   */
  createDerivedMaterial(e) {
    return K6(e);
  }
  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping
  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.
  get material() {
    let e = this._derivedMaterial;
    const n = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = Vf.clone());
    if ((!e || !e.isDerivedFrom(n)) && (e = this._derivedMaterial = this.createDerivedMaterial(n), n.addEventListener("dispose", function i() {
      n.removeEventListener("dispose", i), e.dispose();
    })), this.hasOutline()) {
      let i = e._outlineMtl;
      return i || (i = e._outlineMtl = Object.create(e, {
        id: { value: e.id + 0.1 }
      }), i.isTextOutlineMaterial = !0, i.depthWrite = !1, i.map = null, e.addEventListener("dispose", function r() {
        e.removeEventListener("dispose", r), i.dispose();
      })), [
        i,
        e
      ];
    } else
      return e;
  }
  set material(e) {
    e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e;
  }
  hasOutline() {
    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY);
  }
  get glyphGeometryDetail() {
    return this.geometry.detail;
  }
  set glyphGeometryDetail(e) {
    this.geometry.detail = e;
  }
  get curveRadius() {
    return this.geometry.curveRadius;
  }
  set curveRadius(e) {
    this.geometry.curveRadius = e;
  }
  // Create and update material for shadows upon request:
  get customDepthMaterial() {
    return Ov(this.material).getDepthMaterial();
  }
  set customDepthMaterial(e) {
  }
  get customDistanceMaterial() {
    return Ov(this.material).getDistanceMaterial();
  }
  set customDistanceMaterial(e) {
  }
  _prepareForRender(e) {
    const n = e.isTextOutlineMaterial, i = e.uniforms, r = this.textRenderInfo;
    if (r) {
      const { sdfTexture: l, blockBounds: c } = r;
      i.uTroikaSDFTexture.value = l, i.uTroikaSDFTextureSize.value.set(l.image.width, l.image.height), i.uTroikaSDFGlyphSize.value = r.sdfGlyphSize, i.uTroikaSDFExponent.value = r.sdfExponent, i.uTroikaTotalBounds.value.fromArray(c), i.uTroikaUseGlyphColors.value = !n && !!r.glyphColors;
      let u = 0, d = 0, h = 0, m, p, y, _ = 0, v = 0;
      if (n) {
        let { outlineWidth: S, outlineOffsetX: w, outlineOffsetY: x, outlineBlur: C, outlineOpacity: E } = this;
        u = this._parsePercent(S) || 0, d = Math.max(0, this._parsePercent(C) || 0), m = E, _ = this._parsePercent(w) || 0, v = this._parsePercent(x) || 0;
      } else
        h = Math.max(0, this._parsePercent(this.strokeWidth) || 0), h && (y = this.strokeColor, i.uTroikaStrokeColor.value.set(y ?? Fv), p = this.strokeOpacity, p == null && (p = 1)), m = this.fillOpacity;
      i.uTroikaEdgeOffset.value = u, i.uTroikaPositionOffset.value.set(_, v), i.uTroikaBlurRadius.value = d, i.uTroikaStrokeWidth.value = h, i.uTroikaStrokeOpacity.value = p, i.uTroikaFillOpacity.value = m ?? 1, i.uTroikaCurveRadius.value = this.curveRadius || 0;
      let g = this.clipRect;
      if (g && Array.isArray(g) && g.length === 4)
        i.uTroikaClipRect.value.fromArray(g);
      else {
        const S = (this.fontSize || 0.1) * 100;
        i.uTroikaClipRect.value.set(
          c[0] - S,
          c[1] - S,
          c[2] + S,
          c[3] + S
        );
      }
      this.geometry.applyClipRect(i.uTroikaClipRect.value);
    }
    i.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
    const o = n ? this.outlineColor || 0 : this.color;
    if (o == null)
      delete e.color;
    else {
      const l = e.hasOwnProperty("color") ? e.color : e.color = new Mt();
      (o !== l._input || typeof o == "object") && l.set(l._input = o);
    }
    let a = this.orientation || Fd;
    if (a !== e._orientation) {
      let l = i.uTroikaOrient.value;
      a = a.replace(/[^-+xyz]/g, "");
      let c = a !== Fd && a.match(/^([-+])([xyz])([-+])([xyz])$/);
      if (c) {
        let [, u, d, h, m] = c;
        hc.set(0, 0, 0)[d] = u === "-" ? 1 : -1, Ld.set(0, 0, 0)[m] = h === "-" ? -1 : 1, Uv.lookAt(J6, hc.cross(Ld), Ld), l.setFromMatrix4(Uv);
      } else
        l.identity();
      e._orientation = a;
    }
  }
  _parsePercent(e) {
    if (typeof e == "string") {
      let n = e.match(/^(-?[\d.]+)%$/), i = n ? parseFloat(n[1]) : NaN;
      e = (isNaN(i) ? 0 : i / 100) * this.fontSize;
    }
    return e;
  }
  /**
   * Translate a point in local space to an x/y in the text plane.
   */
  localPositionToTextCoords(e, n = new st()) {
    n.copy(e);
    const i = this.curveRadius;
    return i && (n.x = Math.atan2(e.x, Math.abs(i) - Math.abs(e.z)) * Math.abs(i)), n;
  }
  /**
   * Translate a point in world space to an x/y in the text plane.
   */
  worldPositionToTextCoords(e, n = new st()) {
    return hc.copy(e), this.localPositionToTextCoords(this.worldToLocal(hc), n);
  }
  /**
   * @override Custom raycasting to test against the whole text block's max rectangular bounds
   * TODO is there any reason to make this more granular, like within individual line or glyph rects?
   */
  raycast(e, n) {
    const { textRenderInfo: i, curveRadius: r } = this;
    if (i) {
      const o = i.blockBounds, a = r ? Cy() : My(), l = a.geometry, { position: c, uv: u } = l.attributes;
      for (let d = 0; d < u.count; d++) {
        let h = o[0] + u.getX(d) * (o[2] - o[0]);
        const m = o[1] + u.getY(d) * (o[3] - o[1]);
        let p = 0;
        r && (p = r - Math.cos(h / r) * r, h = Math.sin(h / r) * r), c.setXYZ(d, h, m, p);
      }
      l.boundingSphere = this.geometry.boundingSphere, l.boundingBox = this.geometry.boundingBox, a.matrixWorld = this.matrixWorld, a.material.side = this.material.side, pa.length = 0, a.raycast(e, pa);
      for (let d = 0; d < pa.length; d++)
        pa[d].object = this, n.push(pa[d]);
    }
  }
  copy(e) {
    const n = this.geometry;
    return super.copy(e), this.geometry = n, tN.forEach((i) => {
      this[i] = e[i];
    }), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
Ey.forEach((s) => {
  const e = "_private_" + s;
  Object.defineProperty(Xh.prototype, s, {
    get() {
      return this[e];
    },
    set(n) {
      n !== this[e] && (this[e] = n, this._needsSync = !0);
    }
  });
});
new rr();
new Mt();
class zv {
  constructor(e, n = 500) {
    pe(this, "entries", []);
    pe(this, "totalLength", 0);
    this.curve = e, this.build(n);
  }
  build(e) {
    this.entries = [];
    let n = 0, i = this.curve.getPointAt(0);
    for (let r = 0; r <= e; r++) {
      const o = r / e, a = this.curve.getPointAt(o), l = this.curve.getTangentAt(o);
      r > 0 && (n += a.distanceTo(i)), this.entries.push({
        t: o,
        distance: n,
        position: a.clone(),
        tangent: l.clone().normalize()
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to parameter t
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.entries.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.entries[l].distance < e ? n = l + 1 : i = l;
    }
    const r = this.entries[n], o = this.entries[Math.max(0, n - 1)];
    if (r.distance === o.distance)
      return r.t;
    const a = (e - o.distance) / (r.distance - o.distance);
    return o.t + a * (r.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e), i = this.curve.getPointAt(n), r = this.curve.getTangentAt(n).normalize(), o = new ce(-r.y, r.x, 0).normalize();
    return {
      position: i,
      tangent: r,
      normal: o,
      t: n,
      distance: e
    };
  }
}
class nN {
  constructor() {
    pe(this, "arcLengthTable", null);
    pe(this, "curve", null);
  }
  /**
   * Set the path from control points
   */
  setPath(e, n = !1) {
    var i, r, o, a, l, c, u, d;
    if (e.length < 2) {
      this.curve = null, this.arcLengthTable = null;
      return;
    }
    this.curve = new Rf();
    for (let h = 0; h < e.length - 1; h++) {
      const m = e[h], p = e[h + 1], y = m.depth ?? 0, _ = p.depth ?? 0, v = new il(
        new ce(m.x, -m.y, y),
        new ce(
          m.x + (((i = m.handleOut) == null ? void 0 : i.x) ?? 0),
          -(m.y + (((r = m.handleOut) == null ? void 0 : r.y) ?? 0)),
          y
        ),
        new ce(
          p.x + (((o = p.handleIn) == null ? void 0 : o.x) ?? 0),
          -(p.y + (((a = p.handleIn) == null ? void 0 : a.y) ?? 0)),
          _
        ),
        new ce(p.x, -p.y, _)
      );
      this.curve.add(v);
    }
    if (n && e.length > 2) {
      const h = e[e.length - 1], m = e[0], p = h.depth ?? 0, y = m.depth ?? 0, _ = new il(
        new ce(h.x, -h.y, p),
        new ce(
          h.x + (((l = h.handleOut) == null ? void 0 : l.x) ?? 0),
          -(h.y + (((c = h.handleOut) == null ? void 0 : c.y) ?? 0)),
          p
        ),
        new ce(
          m.x + (((u = m.handleIn) == null ? void 0 : u.x) ?? 0),
          -(m.y + (((d = m.handleIn) == null ? void 0 : d.y) ?? 0)),
          y
        ),
        new ce(m.x, -m.y, y)
      );
      this.curve.add(_);
    }
    this.arcLengthTable = new zv(this.curve);
  }
  /**
   * Set path from THREE.js CurvePath directly
   */
  setCurve(e) {
    this.curve = e, this.arcLengthTable = new zv(e);
  }
  /**
   * Get total path length
   */
  getTotalLength() {
    var e;
    return ((e = this.arcLengthTable) == null ? void 0 : e.totalLength) ?? 0;
  }
  /**
   * Check if path is set
   */
  hasPath() {
    return this.curve !== null && this.arcLengthTable !== null;
  }
  /**
   * Calculate character placements along the path
   *
   * @param characterWidths - Array of character widths in pixels
   * @param config - Text on path configuration
   * @param tracking - Letter spacing in 1/1000 em
   * @param fontSize - Font size for tracking calculation
   * @returns Array of character placements
   */
  calculatePlacements(e, n, i = 0, r = 72) {
    if (!this.arcLengthTable || e.length === 0)
      return [];
    const o = this.arcLengthTable.totalLength, a = [], l = i / 1e3 * r;
    let c = 0;
    for (let p = 0; p < e.length; p++)
      c += e[p], p < e.length - 1 && (c += l);
    const u = o - n.firstMargin - n.lastMargin;
    let d;
    switch (n.align) {
      case "center":
        d = n.firstMargin + (u - c) / 2;
        break;
      case "right":
        d = n.firstMargin + u - c;
        break;
      default:
        d = n.firstMargin;
    }
    const h = n.offset / 100 * u;
    d += h, n.reversed && (d = o - d - c);
    let m = d;
    for (let p = 0; p < e.length; p++) {
      const y = e[p];
      let v = m + y / 2, g = !0;
      (v < 0 || v > o) && (n.forceAlignment ? v = (v % o + o) % o : (g = v >= -y && v <= o + y, v = Math.max(0, Math.min(o, v))));
      const S = this.arcLengthTable.getPointAtDistance(v);
      let w;
      if (n.perpendicularToPath) {
        const x = Math.atan2(S.tangent.y, S.tangent.x);
        w = new wi(0, 0, n.reversed ? x + Math.PI : x);
      } else
        w = new wi(0, 0, 0);
      a.push({
        index: p,
        position: S.position.clone(),
        rotation: w,
        scale: 1,
        pathDistance: v,
        pathT: S.t,
        visible: g
      }), m += y + l;
    }
    return a;
  }
  /**
   * Get a point on the path at a specific percentage
   * Useful for positioning anchors or debugging
   */
  getPointAtPercent(e) {
    if (!this.arcLengthTable) return null;
    const n = e / 100 * this.arcLengthTable.totalLength;
    return this.arcLengthTable.getPointAtDistance(n);
  }
  /**
   * Get evenly spaced points along the path
   * Useful for path visualization
   */
  getEvenlySpacedPoints(e) {
    if (!this.arcLengthTable || e < 2) return [];
    const n = [], i = this.arcLengthTable.totalLength / (e - 1);
    for (let r = 0; r < e; r++) {
      const o = r * i;
      n.push(this.arcLengthTable.getPointAtDistance(o));
    }
    return n;
  }
  /**
   * Dispose resources
   */
  dispose() {
    this.curve = null, this.arcLengthTable = null;
  }
}
function iN() {
  return {
    pathLayerId: null,
    reversed: !1,
    perpendicularToPath: !0,
    forceAlignment: !1,
    firstMargin: 0,
    lastMargin: 0,
    offset: 0,
    align: "left"
  };
}
class sN extends $i {
  constructor(n, i) {
    super(n);
    pe(this, "resources");
    // Text rendering
    pe(this, "textMesh");
    pe(this, "perCharacterGroup", null);
    pe(this, "characterMeshes", []);
    // Text data from layer
    pe(this, "textData");
    // Animatable text properties (from layer.properties)
    pe(this, "fontSizeProp");
    pe(this, "trackingProp");
    pe(this, "lineSpacingProp");
    pe(this, "fillColorProp");
    pe(this, "strokeColorProp");
    pe(this, "strokeWidthProp");
    pe(this, "pathOffsetProp");
    pe(this, "firstMarginProp");
    pe(this, "lastMarginProp");
    pe(this, "characterOffsetProp");
    // Per-character animation
    pe(this, "characterTransforms");
    // Path following service
    pe(this, "textOnPath");
    pe(this, "pathConfig");
    pe(this, "pathControlPoints", []);
    pe(this, "pathClosed", !1);
    // Character width cache (recalculated when text/font changes)
    pe(this, "characterWidths", []);
    pe(this, "characterWidthsDirty", !0);
    // Additional evaluator for text-specific properties
    pe(this, "textEvaluator");
    this.resources = i, this.textEvaluator = new vl(), this.textOnPath = new nN(), this.pathConfig = iN(), this.textData = this.extractTextData(n), this.extractAnimatableProperties(n), this.textMesh = this.createTextMesh(), this.group.add(this.textMesh), (this.textData.perCharacter3D || this.textData.pathLayerId) && this.enablePerCharacter3D(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract text data from layer, with defaults matching AE
   */
  extractTextData(n) {
    const i = n.data;
    return {
      text: (i == null ? void 0 : i.text) ?? "Text",
      fontFamily: (i == null ? void 0 : i.fontFamily) ?? "Impact",
      fontSize: (i == null ? void 0 : i.fontSize) ?? 72,
      fontWeight: (i == null ? void 0 : i.fontWeight) ?? "400",
      fontStyle: (i == null ? void 0 : i.fontStyle) ?? "normal",
      fill: (i == null ? void 0 : i.fill) ?? "#ffffff",
      stroke: (i == null ? void 0 : i.stroke) ?? "",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 0,
      // Character properties
      tracking: (i == null ? void 0 : i.tracking) ?? 0,
      lineSpacing: (i == null ? void 0 : i.lineSpacing) ?? 0,
      lineAnchor: (i == null ? void 0 : i.lineAnchor) ?? 50,
      characterOffset: (i == null ? void 0 : i.characterOffset) ?? 0,
      characterValue: (i == null ? void 0 : i.characterValue) ?? 0,
      blur: (i == null ? void 0 : i.blur) ?? { x: 0, y: 0 },
      // Paragraph (aliases)
      letterSpacing: (i == null ? void 0 : i.letterSpacing) ?? (i == null ? void 0 : i.tracking) ?? 0,
      lineHeight: (i == null ? void 0 : i.lineHeight) ?? (i == null ? void 0 : i.lineSpacing) ?? 1.2,
      textAlign: (i == null ? void 0 : i.textAlign) ?? "left",
      // Path options (full AE parity)
      pathLayerId: (i == null ? void 0 : i.pathLayerId) ?? null,
      pathReversed: (i == null ? void 0 : i.pathReversed) ?? !1,
      pathPerpendicularToPath: (i == null ? void 0 : i.pathPerpendicularToPath) ?? !0,
      pathForceAlignment: (i == null ? void 0 : i.pathForceAlignment) ?? !1,
      pathFirstMargin: (i == null ? void 0 : i.pathFirstMargin) ?? 0,
      pathLastMargin: (i == null ? void 0 : i.pathLastMargin) ?? 0,
      pathOffset: (i == null ? void 0 : i.pathOffset) ?? 0,
      pathAlign: (i == null ? void 0 : i.pathAlign) ?? "left",
      // More Options
      anchorPointGrouping: (i == null ? void 0 : i.anchorPointGrouping) ?? "character",
      groupingAlignment: (i == null ? void 0 : i.groupingAlignment) ?? { x: 0, y: 0 },
      fillAndStroke: (i == null ? void 0 : i.fillAndStroke) ?? "fill-over-stroke",
      interCharacterBlending: (i == null ? void 0 : i.interCharacterBlending) ?? "normal",
      // 3D
      perCharacter3D: (i == null ? void 0 : i.perCharacter3D) ?? !1
    };
  }
  /**
   * Extract animatable properties from layer.properties array
   */
  extractAnimatableProperties(n) {
    if (n.properties) {
      for (const i of n.properties)
        switch (i.name) {
          case "Font Size":
            this.fontSizeProp = i;
            break;
          case "Tracking":
            this.trackingProp = i;
            break;
          case "Line Spacing":
            this.lineSpacingProp = i;
            break;
          case "Fill Color":
            this.fillColorProp = i;
            break;
          case "Stroke Color":
            this.strokeColorProp = i;
            break;
          case "Stroke Width":
            this.strokeWidthProp = i;
            break;
          case "Path Offset":
            this.pathOffsetProp = i;
            break;
          case "First Margin":
            this.firstMarginProp = i;
            break;
          case "Last Margin":
            this.lastMarginProp = i;
            break;
          case "Character Offset":
            this.characterOffsetProp = i;
            break;
        }
      this.syncPathConfig();
    }
  }
  /**
   * Sync path configuration from text data
   */
  syncPathConfig() {
    this.pathConfig.pathLayerId = this.textData.pathLayerId, this.pathConfig.reversed = this.textData.pathReversed, this.pathConfig.perpendicularToPath = this.textData.pathPerpendicularToPath, this.pathConfig.forceAlignment = this.textData.pathForceAlignment, this.pathConfig.firstMargin = this.textData.pathFirstMargin, this.pathConfig.lastMargin = this.textData.pathLastMargin, this.pathConfig.offset = this.textData.pathOffset, this.pathConfig.align = this.textData.pathAlign;
  }
  // ============================================================================
  // TEXT MESH CREATION
  // ============================================================================
  /**
   * Create Troika text mesh with current settings
   */
  createTextMesh() {
    const n = new Xh();
    return n.text = this.textData.text, n.font = this.getFontUrl(this.textData.fontFamily) ?? null, n.fontSize = this.textData.fontSize, n.color = this.textData.fill, this.textData.stroke && this.textData.strokeWidth > 0 && (n.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, n.outlineColor = this.textData.stroke), n.letterSpacing = (this.textData.tracking || 0) / 1e3, n.lineHeight = this.textData.lineHeight || 1.2, n.textAlign = this.textData.textAlign, n.anchorX = this.getAnchorX(), n.anchorY = "middle", n.depthOffset = 0, n.renderOrder = 0, n.sync(), n;
  }
  /**
   * Get font URL for Troika
   */
  getFontUrl(n) {
    return [
      "Arial",
      "Helvetica",
      "Times New Roman",
      "Georgia",
      "Verdana",
      "Courier New",
      "Impact",
      "Comic Sans MS",
      "Trebuchet MS",
      "Palatino"
    ].includes(n) ? void 0 : {
      Roboto: "https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxK.woff2",
      "Open Sans": "https://fonts.gstatic.com/s/opensans/v35/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4gaVI.woff2",
      Lato: "https://fonts.gstatic.com/s/lato/v24/S6uyw4BMUTPHjx4wXg.woff2",
      Montserrat: "https://fonts.gstatic.com/s/montserrat/v26/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw5aXo.woff2",
      Oswald: "https://fonts.gstatic.com/s/oswald/v53/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUZiYA.woff2",
      Poppins: "https://fonts.gstatic.com/s/poppins/v21/pxiEyp8kv8JHgFVrJJfecg.woff2"
    }[n];
  }
  /**
   * Get anchor X based on text alignment
   */
  getAnchorX() {
    switch (this.textData.textAlign) {
      case "left":
        return "left";
      case "right":
        return "right";
      default:
        return "center";
    }
  }
  // ============================================================================
  // PATH INTEGRATION
  // ============================================================================
  /**
   * Set the path from SplineLayer control points
   * Called by LayerManager when connecting text to a spline
   */
  setPathFromControlPoints(n, i = !1) {
    this.pathControlPoints = n, this.pathClosed = i, n.length >= 2 ? (this.textOnPath.setPath(n, i), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout()) : (this.textOnPath.dispose(), this.resetPathLayout());
  }
  /**
   * Set the path from a THREE.js CurvePath directly
   */
  setPathFromCurve(n) {
    this.textOnPath.setCurve(n), this.perCharacterGroup || this.enablePerCharacter3D(), this.updatePathLayout();
  }
  /**
   * Clear the path reference
   */
  clearPath() {
    this.textData.pathLayerId = null, this.pathConfig.pathLayerId = null, this.textOnPath.dispose(), this.resetPathLayout();
  }
  /**
   * Update character positions along the path
   */
  updatePathLayout() {
    if (!this.textOnPath.hasPath() || !this.perCharacterGroup)
      return;
    this.ensureCharacterWidths();
    const n = this.textOnPath.calculatePlacements(
      this.characterWidths,
      this.pathConfig,
      this.textData.tracking,
      this.textData.fontSize
    );
    this.applyPlacements(n);
  }
  /**
   * Apply character placements to meshes
   */
  applyPlacements(n) {
    for (let i = 0; i < this.characterMeshes.length && i < n.length; i++) {
      const r = this.characterMeshes[i], o = n[i];
      r.position.copy(o.position), r.rotation.copy(o.rotation), r.scale.setScalar(o.scale), r.visible = o.visible;
    }
  }
  /**
   * Reset to horizontal layout (no path)
   */
  resetPathLayout() {
    this.textData.perCharacter3D ? this.createCharacterMeshes() : this.disablePerCharacter3D();
  }
  /**
   * Calculate character widths for path spacing
   */
  ensureCharacterWidths() {
    if (!this.characterWidthsDirty) return;
    this.characterWidths = [];
    const n = this.textData.text, i = this.textData.fontSize * 0.6;
    for (let r = 0; r < n.length; r++) {
      const o = n[r];
      `iIl1|!.,;:'"`.includes(o) ? this.characterWidths.push(i * 0.4) : "mwMW".includes(o) ? this.characterWidths.push(i * 1.3) : o === " " ? this.characterWidths.push(i * 0.5) : this.characterWidths.push(i);
    }
    this.characterWidthsDirty = !1;
  }
  // ============================================================================
  // PER-CHARACTER 3D MODE
  // ============================================================================
  /**
   * Enable per-character mode (for 3D and path following)
   */
  enablePerCharacter3D() {
    this.perCharacterGroup || (this.textMesh.visible = !1, this.perCharacterGroup = new Ei(), this.perCharacterGroup.name = `text_chars_${this.id}`, this.group.add(this.perCharacterGroup), this.createCharacterMeshes());
  }
  /**
   * Disable per-character mode
   */
  disablePerCharacter3D() {
    this.perCharacterGroup && (this.textMesh.visible = !0, this.disposeCharacterMeshes(), this.group.remove(this.perCharacterGroup), this.perCharacterGroup = null);
  }
  /**
   * Create individual character meshes
   */
  createCharacterMeshes() {
    if (!this.perCharacterGroup) return;
    this.disposeCharacterMeshes(), this.characterWidthsDirty = !0;
    const n = this.textData.text;
    let i = 0;
    this.ensureCharacterWidths();
    const r = this.characterWidths.reduce((a, l) => a + l, 0) + (n.length - 1) * (this.textData.tracking / 1e3) * this.textData.fontSize;
    let o = 0;
    switch (this.textData.textAlign) {
      case "center":
        o = -r / 2;
        break;
      case "right":
        o = -r;
        break;
      default:
        o = 0;
    }
    i = o;
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = new Xh();
      c.text = l, c.font = this.getFontUrl(this.textData.fontFamily) ?? null, c.fontSize = this.textData.fontSize, c.color = this.textData.fill, c.anchorX = "center", c.anchorY = "middle", this.textData.stroke && this.textData.strokeWidth > 0 && (c.outlineWidth = this.textData.strokeWidth / this.textData.fontSize, c.outlineColor = this.textData.stroke);
      const u = this.characterWidths[a];
      c.position.x = i + u / 2, c.position.y = 0, c.position.z = 0, i += u + this.textData.tracking / 1e3 * this.textData.fontSize, c.sync(), this.characterMeshes.push(c), this.perCharacterGroup.add(c);
    }
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Dispose character meshes
   */
  disposeCharacterMeshes() {
    var n;
    for (const i of this.characterMeshes)
      i.dispose(), (n = this.perCharacterGroup) == null || n.remove(i);
    this.characterMeshes = [];
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  setText(n) {
    this.textData.text = n, this.textMesh.text = n, this.textMesh.sync(), this.characterWidthsDirty = !0, this.perCharacterGroup && this.createCharacterMeshes();
  }
  setFontFamily(n) {
    this.textData.fontFamily = n;
    const i = this.getFontUrl(n) ?? null;
    this.textMesh.font = i, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const r of this.characterMeshes)
      r.font = i, r.sync();
    this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setFontSize(n) {
    this.textData.fontSize = n, this.textMesh.fontSize = n, this.textMesh.sync(), this.characterWidthsDirty = !0;
    for (const i of this.characterMeshes)
      i.fontSize = n, i.sync();
    this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setFillColor(n) {
    this.textData.fill = n, this.textMesh.color = n;
    for (const i of this.characterMeshes)
      i.color = n;
  }
  setStroke(n, i) {
    this.textData.stroke = n, this.textData.strokeWidth = i;
    const r = i / this.textData.fontSize;
    this.textMesh.outlineWidth = r, this.textMesh.outlineColor = n;
    for (const o of this.characterMeshes)
      o.outlineWidth = r, o.outlineColor = n;
  }
  setTracking(n) {
    this.textData.tracking = n, this.textMesh.letterSpacing = n / 1e3, this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? this.updatePathLayout() : this.createCharacterMeshes());
  }
  setTextAlign(n) {
    this.textData.textAlign = n, this.textMesh.textAlign = n, this.textMesh.anchorX = this.getAnchorX(), this.textMesh.sync(), this.perCharacterGroup && (this.textOnPath.hasPath() ? (this.pathConfig.align = n, this.updatePathLayout()) : this.createCharacterMeshes());
  }
  /**
   * Set path offset (0-100%)
   * This is the primary animatable property for text-on-path animation
   */
  setPathOffset(n) {
    this.textData.pathOffset = n, this.pathConfig.offset = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set first margin (pixels)
   */
  setFirstMargin(n) {
    this.textData.pathFirstMargin = n, this.pathConfig.firstMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set last margin (pixels)
   */
  setLastMargin(n) {
    this.textData.pathLastMargin = n, this.pathConfig.lastMargin = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set path reversed
   */
  setPathReversed(n) {
    this.textData.pathReversed = n, this.pathConfig.reversed = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set perpendicular to path
   */
  setPerpendicularToPath(n) {
    this.textData.pathPerpendicularToPath = n, this.pathConfig.perpendicularToPath = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  /**
   * Set force alignment
   */
  setForceAlignment(n) {
    this.textData.pathForceAlignment = n, this.pathConfig.forceAlignment = n, this.textOnPath.hasPath() && this.updatePathLayout();
  }
  setAnchorPointGrouping(n) {
    this.textData.anchorPointGrouping = n;
  }
  setFillAndStroke(n) {
    this.textData.fillAndStroke = n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    var i, r, o, a, l, c, u;
    if ((i = this.fontSizeProp) != null && i.animated) {
      const d = this.textEvaluator.evaluate(this.fontSizeProp, n);
      this.setFontSize(d);
    }
    if ((r = this.trackingProp) != null && r.animated) {
      const d = this.textEvaluator.evaluate(this.trackingProp, n);
      this.setTracking(d);
    }
    if ((o = this.fillColorProp) != null && o.animated) {
      const d = this.textEvaluator.evaluate(this.fillColorProp, n);
      this.setFillColor(d);
    }
    if ((a = this.strokeColorProp) != null && a.animated && this.strokeWidthProp) {
      const d = this.textEvaluator.evaluate(this.strokeColorProp, n), h = this.strokeWidthProp.animated ? this.textEvaluator.evaluate(this.strokeWidthProp, n) : this.textData.strokeWidth;
      this.setStroke(d, h);
    }
    if (this.pathOffsetProp) {
      const d = this.pathOffsetProp.animated ? this.textEvaluator.evaluate(this.pathOffsetProp, n) : this.textData.pathOffset;
      this.setPathOffset(d);
    }
    if ((l = this.firstMarginProp) != null && l.animated) {
      const d = this.textEvaluator.evaluate(this.firstMarginProp, n);
      this.setFirstMargin(d);
    }
    if ((c = this.lastMarginProp) != null && c.animated) {
      const d = this.textEvaluator.evaluate(this.lastMarginProp, n);
      this.setLastMargin(d);
    }
    (u = this.characterTransforms) != null && u.animated && this.perCharacterGroup && this.applyCharacterTransforms(n);
  }
  /**
   * Apply per-character animated transforms (additional offsets)
   */
  applyCharacterTransforms(n) {
    if (!this.characterTransforms) return;
    const i = this.textEvaluator.evaluate(this.characterTransforms, n);
    for (let r = 0; r < this.characterMeshes.length && r < i.length; r++) {
      const o = this.characterMeshes[r], a = i[r];
      o.position.x += a.position.x, o.position.y += a.position.y, o.position.z += a.position.z, o.rotation.x += fn.degToRad(a.rotation.x), o.rotation.y += fn.degToRad(a.rotation.y), o.rotation.z += fn.degToRad(a.rotation.z), o.scale.x *= a.scale.x, o.scale.y *= a.scale.y, o.material && (o.material.opacity *= a.opacity);
    }
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.text !== void 0 && this.setText(i.text), i.fontFamily !== void 0 && this.setFontFamily(i.fontFamily), i.fontSize !== void 0 && this.setFontSize(i.fontSize), i.fill !== void 0 && this.setFillColor(i.fill), (i.stroke !== void 0 || i.strokeWidth !== void 0) && this.setStroke(
      i.stroke ?? this.textData.stroke,
      i.strokeWidth ?? this.textData.strokeWidth
    ), i.tracking !== void 0 && this.setTracking(i.tracking), i.textAlign !== void 0 && this.setTextAlign(i.textAlign), i.pathLayerId !== void 0 && (this.textData.pathLayerId = i.pathLayerId, this.pathConfig.pathLayerId = i.pathLayerId), i.pathOffset !== void 0 && this.setPathOffset(i.pathOffset), i.pathFirstMargin !== void 0 && this.setFirstMargin(i.pathFirstMargin), i.pathLastMargin !== void 0 && this.setLastMargin(i.pathLastMargin), i.pathReversed !== void 0 && this.setPathReversed(i.pathReversed), i.pathPerpendicularToPath !== void 0 && this.setPerpendicularToPath(i.pathPerpendicularToPath), i.pathForceAlignment !== void 0 && this.setForceAlignment(i.pathForceAlignment), i.perCharacter3D !== void 0 && (i.perCharacter3D && !this.perCharacterGroup ? this.enablePerCharacter3D() : !i.perCharacter3D && !this.textOnPath.hasPath() && this.perCharacterGroup && this.disablePerCharacter3D()), i.anchorPointGrouping !== void 0 && this.setAnchorPointGrouping(i.anchorPointGrouping), i.fillAndStroke !== void 0 && this.setFillAndStroke(i.fillAndStroke)), n.properties && this.extractAnimatableProperties(n);
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  getTextData() {
    return { ...this.textData };
  }
  getTextBounds() {
    var i;
    const n = (i = this.textMesh.textRenderInfo) == null ? void 0 : i.blockBounds;
    return n ? {
      width: n[2] - n[0],
      height: n[3] - n[1]
    } : { width: 0, height: 0 };
  }
  getPathLength() {
    return this.textOnPath.getTotalLength();
  }
  hasPath() {
    return this.textOnPath.hasPath();
  }
  getTextOnPathService() {
    return this.textOnPath;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.textMesh.dispose(), this.disposeCharacterMeshes(), this.textOnPath.dispose(), this.perCharacterGroup && this.group.remove(this.perCharacterGroup);
  }
}
class rN extends $i {
  constructor(n) {
    super(n);
    /** The line mesh for the spline */
    pe(this, "lineMesh", null);
    /** The fill mesh (if closed path with fill) */
    pe(this, "fillMesh", null);
    /** Spline data */
    pe(this, "splineData");
    /** Cached curve for path calculations */
    pe(this, "curve", null);
    this.splineData = this.extractSplineData(n), this.buildSpline(), this.initializeBlendMode();
  }
  /**
   * Extract spline data from layer
   */
  extractSplineData(n) {
    const i = n.data;
    return {
      controlPoints: (i == null ? void 0 : i.controlPoints) ?? [],
      closed: (i == null ? void 0 : i.closed) ?? !1,
      stroke: (i == null ? void 0 : i.stroke) ?? "#00ff00",
      strokeWidth: (i == null ? void 0 : i.strokeWidth) ?? 2,
      fill: (i == null ? void 0 : i.fill) ?? "",
      pathData: (i == null ? void 0 : i.pathData) ?? ""
    };
  }
  /**
   * Build the Three.js spline from control points
   */
  buildSpline() {
    var a, l, c, u, d, h, m, p;
    this.clearMeshes();
    const n = this.splineData.controlPoints;
    if (n.length < 2) return;
    this.curve = new Rf();
    for (let y = 0; y < n.length - 1; y++) {
      const _ = n[y], v = n[y + 1], g = _.depth ?? 0, S = v.depth ?? 0, w = new il(
        new ce(_.x, -_.y, g),
        new ce(
          _.x + (((a = _.handleOut) == null ? void 0 : a.x) ?? 0),
          -(_.y + (((l = _.handleOut) == null ? void 0 : l.y) ?? 0)),
          g
        ),
        new ce(
          v.x + (((c = v.handleIn) == null ? void 0 : c.x) ?? 0),
          -(v.y + (((u = v.handleIn) == null ? void 0 : u.y) ?? 0)),
          S
        ),
        new ce(v.x, -v.y, S)
      );
      this.curve.add(w);
    }
    if (this.splineData.closed && n.length > 2) {
      const y = n[n.length - 1], _ = n[0], v = y.depth ?? 0, g = _.depth ?? 0, S = new il(
        new ce(y.x, -y.y, v),
        new ce(
          y.x + (((d = y.handleOut) == null ? void 0 : d.x) ?? 0),
          -(y.y + (((h = y.handleOut) == null ? void 0 : h.y) ?? 0)),
          v
        ),
        new ce(
          _.x + (((m = _.handleIn) == null ? void 0 : m.x) ?? 0),
          -(_.y + (((p = _.handleIn) == null ? void 0 : p.y) ?? 0)),
          g
        ),
        new ce(_.x, -_.y, g)
      );
      this.curve.add(S);
    }
    const i = this.curve.getPoints(n.length * 20), r = new Nt().setFromPoints(i), o = new Wi({
      color: this.splineData.stroke,
      linewidth: this.splineData.strokeWidth,
      transparent: !0
    });
    this.lineMesh = new an(r, o), this.lineMesh.name = `spline_line_${this.id}`, this.group.add(this.lineMesh), this.splineData.fill && this.splineData.closed && this.createFill(i);
  }
  /**
   * Create fill mesh for closed paths
   */
  createFill(n) {
    if (n.length < 3) return;
    const i = new iy();
    i.moveTo(n[0].x, n[0].y);
    for (let a = 1; a < n.length; a++)
      i.lineTo(n[a].x, n[a].y);
    i.closePath();
    const r = new Lf(i), o = new Mn({
      color: this.splineData.fill,
      transparent: !0,
      side: mn,
      depthWrite: !1
    });
    this.fillMesh = new qe(r, o), this.fillMesh.name = `spline_fill_${this.id}`, this.fillMesh.position.z = -0.1, this.group.add(this.fillMesh);
  }
  /**
   * Clear existing meshes
   */
  clearMeshes() {
    this.lineMesh && (this.group.remove(this.lineMesh), this.lineMesh.geometry.dispose(), this.lineMesh.material.dispose(), this.lineMesh = null), this.fillMesh && (this.group.remove(this.fillMesh), this.fillMesh.geometry.dispose(), this.fillMesh.material.dispose(), this.fillMesh = null), this.curve = null;
  }
  // ============================================================================
  // PATH UTILITIES
  // ============================================================================
  /**
   * Get a point on the path at parameter t (0-1)
   */
  getPointAt(n) {
    return this.curve ? this.curve.getPointAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the tangent at parameter t (0-1)
   */
  getTangentAt(n) {
    return this.curve ? this.curve.getTangentAt(Math.max(0, Math.min(1, n))) : null;
  }
  /**
   * Get the total length of the path
   */
  getLength() {
    return this.curve ? this.curve.getLength() : 0;
  }
  /**
   * Get point and rotation for placing objects along path
   */
  getTransformAt(n) {
    const i = this.getPointAt(n), r = this.getTangentAt(n);
    if (!i || !r) return null;
    const o = Math.atan2(r.y, r.x) * (180 / Math.PI);
    return { position: i, rotation: o };
  }
  /**
   * Get the underlying curve for advanced operations
   */
  getCurve() {
    return this.curve;
  }
  // ============================================================================
  // PROPERTY SETTERS
  // ============================================================================
  /**
   * Set stroke color
   */
  setStroke(n) {
    this.splineData.stroke = n, this.lineMesh && this.lineMesh.material.color.set(n);
  }
  /**
   * Set stroke width
   */
  setStrokeWidth(n) {
    this.splineData.strokeWidth = n, this.lineMesh && (this.lineMesh.material.linewidth = n);
  }
  /**
   * Set fill color
   */
  setFill(n) {
    if (this.splineData.fill = n, this.fillMesh)
      this.fillMesh.material.color.set(n);
    else if (n && this.splineData.closed && this.curve) {
      const i = this.curve.getPoints(this.splineData.controlPoints.length * 20);
      this.createFill(i);
    }
  }
  /**
   * Update control points
   */
  setControlPoints(n) {
    this.splineData.controlPoints = n, this.buildSpline();
  }
  /**
   * Set closed state
   */
  setClosed(n) {
    this.splineData.closed !== n && (this.splineData.closed = n, this.buildSpline());
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
  }
  onUpdate(n) {
    const i = n.data;
    if (i) {
      let r = !1;
      i.controlPoints !== void 0 && (this.splineData.controlPoints = i.controlPoints, r = !0), i.closed !== void 0 && i.closed !== this.splineData.closed && (this.splineData.closed = i.closed, r = !0), i.stroke !== void 0 && this.setStroke(i.stroke), i.strokeWidth !== void 0 && this.setStrokeWidth(i.strokeWidth), i.fill !== void 0 && this.setFill(i.fill), r && this.buildSpline();
    }
  }
  onDispose() {
    this.clearMeshes();
  }
}
const fs = 16, oN = 50;
function Nv(s) {
  return {
    id: s || `emitter_${Date.now()}`,
    name: "Emitter",
    enabled: !0,
    position: { x: 0.5, y: 0.5, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    shape: { type: "point" },
    emissionRate: 100,
    emissionRateVariance: 0,
    burstCount: 0,
    burstInterval: 0,
    initialSpeed: 200,
    speedVariance: 50,
    inheritEmitterVelocity: 0,
    initialSize: 10,
    sizeVariance: 2,
    initialMass: 1,
    massVariance: 0,
    lifetime: 120,
    lifetimeVariance: 20,
    initialRotation: 0,
    rotationVariance: 360,
    initialAngularVelocity: 0,
    angularVelocityVariance: 0,
    colorStart: [1, 1, 1, 1],
    colorEnd: [1, 1, 1, 0],
    colorVariance: 0,
    emissionDirection: { x: 0, y: -1, z: 0 },
    emissionSpread: 30,
    burstOnBeat: !1,
    beatEmissionMultiplier: 5
  };
}
function aN(s, e) {
  const n = {
    id: e || `force_${Date.now()}`,
    name: s.charAt(0).toUpperCase() + s.slice(1),
    type: s,
    enabled: !0,
    strength: 100,
    position: { x: 0.5, y: 0.5, z: 0 },
    falloffStart: 0,
    falloffEnd: 500,
    falloffType: "linear"
  };
  switch (s) {
    case "gravity":
      n.direction = { x: 0, y: 1, z: 0 }, n.strength = 98;
      break;
    case "vortex":
      n.vortexAxis = { x: 0, y: 0, z: 1 }, n.inwardForce = 20;
      break;
    case "turbulence":
      n.noiseScale = 5e-3, n.noiseSpeed = 0.5, n.noiseOctaves = 3, n.noiseLacunarity = 2, n.noiseGain = 0.5;
      break;
    case "drag":
      n.linearDrag = 0.1, n.quadraticDrag = 0.01;
      break;
    case "wind":
      n.windDirection = { x: 1, y: 0, z: 0 }, n.gustStrength = 50, n.gustFrequency = 0.1;
      break;
    case "lorenz":
      n.lorenzSigma = 10, n.lorenzRho = 28, n.lorenzBeta = 2.667;
      break;
  }
  return n;
}
function Ty() {
  return {
    maxParticles: 1e5,
    simulationSpace: "world",
    deltaTimeMode: "variable",
    fixedDeltaTime: 1 / 60,
    timeScale: 1,
    warmupFrames: 0,
    emitters: [],
    forceFields: [],
    subEmitters: [],
    lifetimeModulation: {},
    render: {
      mode: "billboard",
      sortByDepth: !0,
      depthWrite: !1,
      depthTest: !0,
      blendMode: "normal",
      stretchFactor: 1,
      minStretch: 1,
      maxStretch: 4,
      trailLength: 0,
      trailSegments: 8,
      trailWidthStart: 1,
      trailWidthEnd: 0,
      trailFadeMode: "both",
      texture: {},
      shadow: {
        castShadows: !1,
        receiveShadows: !1,
        shadowSoftness: 1,
        shadowBias: 1e-3,
        aoEnabled: !1,
        aoRadius: 10,
        aoIntensity: 0.5,
        aoSamples: 8
      },
      lighting: {
        receiveLighting: !1,
        roughness: 0.5,
        metalness: 0,
        emissiveIntensity: 0,
        subsurfaceScattering: !1,
        subsurfaceColor: [1, 0.5, 0.5],
        subsurfaceRadius: 1
      },
      motionBlur: !1,
      motionBlurSamples: 4,
      motionBlurStrength: 0.5,
      lodEnabled: !1,
      lodDistances: [100, 500, 1e3],
      lodSizeMultipliers: [1, 0.5, 0.25]
    },
    audioBindings: [],
    spatialHashCellSize: oN,
    updateFrequency: 1,
    cullOffscreen: !0
  };
}
class Bv {
  constructor(e = {}) {
    pe(this, "config");
    pe(this, "gl", null);
    pe(this, "renderer", null);
    // Double-buffered particle data
    pe(this, "particleBufferA");
    pe(this, "particleBufferB");
    pe(this, "currentBuffer", "A");
    // WebGL resources
    pe(this, "transformFeedbackProgram", null);
    pe(this, "renderProgram", null);
    pe(this, "vaoA", null);
    pe(this, "vaoB", null);
    pe(this, "particleVboA", null);
    pe(this, "particleVboB", null);
    pe(this, "transformFeedbackA", null);
    pe(this, "transformFeedbackB", null);
    // Three.js integration
    pe(this, "particleMesh", null);
    pe(this, "instancedGeometry", null);
    pe(this, "material", null);
    // Textures for modulation curves
    pe(this, "sizeOverLifetimeTexture", null);
    pe(this, "opacityOverLifetimeTexture", null);
    pe(this, "colorOverLifetimeTexture", null);
    // Emitter state
    pe(this, "emitters", /* @__PURE__ */ new Map());
    pe(this, "forceFields", /* @__PURE__ */ new Map());
    pe(this, "subEmitters", /* @__PURE__ */ new Map());
    // Runtime state
    pe(this, "state", {
      particleCount: 0,
      activeEmitters: 0,
      simulationTime: 0,
      frameCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0,
      gpuMemoryBytes: 0,
      currentAudioFeatures: /* @__PURE__ */ new Map()
    });
    // Audio reactivity
    pe(this, "audioFeatures", /* @__PURE__ */ new Map());
    // Spatial hash for neighbor queries (flocking)
    pe(this, "spatialHash", /* @__PURE__ */ new Map());
    // Event system
    pe(this, "eventHandlers", /* @__PURE__ */ new Map());
    // Pool of free particle indices
    pe(this, "freeIndices", []);
    pe(this, "nextParticleIndex", 0);
    // Random number generator with seed
    pe(this, "rng");
    this.config = { ...Ty(), ...e };
    const n = this.config.maxParticles * fs;
    this.particleBufferA = new Float32Array(n), this.particleBufferB = new Float32Array(n);
    for (let i = this.config.maxParticles - 1; i >= 0; i--)
      this.freeIndices.push(i);
    this.rng = this.createSeededRandom(this.config.randomSeed ?? Date.now()), this.config.emitters.forEach((i) => this.addEmitter(i)), this.config.forceFields.forEach((i) => this.addForceField(i)), this.config.subEmitters.forEach((i) => this.addSubEmitter(i));
  }
  // ============================================================================
  // Initialization
  // ============================================================================
  /**
   * Initialize GPU resources. Must be called before simulation.
   */
  initialize(e) {
    if (this.renderer = e, this.gl = e.getContext(), !this.gl)
      throw new Error("WebGL2 context required for GPU particle system");
    this.createModulationTextures(), this.createParticleMesh(), this.state.gpuMemoryBytes = this.config.maxParticles * fs * 4 * 2;
  }
  /**
   * Create textures for lifetime modulation curves
   */
  createModulationTextures() {
    const n = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.sizeOverLifetime, n), this.sizeOverLifetimeTexture = new Oa(
      n,
      256,
      1,
      Gc,
      ui
    ), this.sizeOverLifetimeTexture.needsUpdate = !0;
    const i = new Float32Array(256);
    this.sampleModulationCurve(this.config.lifetimeModulation.opacityOverLifetime, i), this.opacityOverLifetimeTexture = new Oa(
      i,
      256,
      1,
      Gc,
      ui
    ), this.opacityOverLifetimeTexture.needsUpdate = !0;
    const r = this.config.lifetimeModulation.colorOverLifetime || [
      { time: 0, color: [1, 1, 1, 1] },
      { time: 1, color: [1, 1, 1, 1] }
    ], o = new Float32Array(256 * 4);
    for (let a = 0; a < 256; a++) {
      const l = a / 255, c = this.sampleColorGradient(r, l);
      o[a * 4] = c[0], o[a * 4 + 1] = c[1], o[a * 4 + 2] = c[2], o[a * 4 + 3] = c[3];
    }
    this.colorOverLifetimeTexture = new Oa(
      o,
      256,
      1,
      $n,
      ui
    ), this.colorOverLifetimeTexture.needsUpdate = !0;
  }
  /**
   * Sample a modulation curve into a float array
   */
  sampleModulationCurve(e, n) {
    const i = n.length;
    if (!e) {
      n.fill(1);
      return;
    }
    for (let r = 0; r < i; r++) {
      const o = r / (i - 1);
      n[r] = this.evaluateModulationCurve(e, o);
    }
  }
  /**
   * Evaluate a modulation curve at time t
   */
  evaluateModulationCurve(e, n) {
    switch (e.type) {
      case "constant":
        return e.value;
      case "linear":
        return e.start + (e.end - e.start) * n;
      case "curve": {
        const i = e.points;
        if (i.length === 0) return 1;
        if (i.length === 1) return i[0].value;
        let r = i[0], o = i[i.length - 1];
        for (let p = 0; p < i.length - 1; p++)
          if (n >= i[p].time && n <= i[p + 1].time) {
            r = i[p], o = i[p + 1];
            break;
          }
        const a = (n - r.time) / (o.time - r.time), l = a * a, c = l * a, u = 2 * c - 3 * l + 1, d = -2 * c + 3 * l, h = c - 2 * l + a, m = c - l;
        return u * r.value + d * o.value + h * (r.outTangent ?? 0) + m * (o.inTangent ?? 0);
      }
      case "random":
        return e.min + this.rng() * (e.max - e.min);
      case "randomCurve": {
        const i = this.evaluateModulationCurve(e.minCurve, n), r = this.evaluateModulationCurve(e.maxCurve, n);
        return i + this.rng() * (r - i);
      }
      default:
        return 1;
    }
  }
  /**
   * Sample color gradient at time t
   */
  sampleColorGradient(e, n) {
    if (e.length === 0) return [1, 1, 1, 1];
    if (e.length === 1) return e[0].color;
    let i = e[0], r = e[e.length - 1];
    for (let a = 0; a < e.length - 1; a++)
      if (n >= e[a].time && n <= e[a + 1].time) {
        i = e[a], r = e[a + 1];
        break;
      }
    const o = (n - i.time) / (r.time - i.time);
    return [
      i.color[0] + (r.color[0] - i.color[0]) * o,
      i.color[1] + (r.color[1] - i.color[1]) * o,
      i.color[2] + (r.color[2] - i.color[2]) * o,
      i.color[3] + (r.color[3] - i.color[3]) * o
    ];
  }
  /**
   * Create the Three.js mesh for particle rendering
   */
  createParticleMesh() {
    const e = new Float32Array([
      -1,
      -1,
      1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      1
    ]), n = new Float32Array([
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1
    ]);
    this.instancedGeometry = new ly(), this.instancedGeometry.setAttribute("position", new bi(e, 2)), this.instancedGeometry.setAttribute("uv", new bi(n, 2));
    const i = new Sr(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), r = new Sr(
      new Float32Array(this.config.maxParticles * 3),
      3
    ), o = new Sr(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), a = new Sr(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), l = new Sr(
      new Float32Array(this.config.maxParticles * 2),
      2
    ), c = new Sr(
      new Float32Array(this.config.maxParticles * 4),
      4
    );
    i.setUsage(Yr), r.setUsage(Yr), o.setUsage(Yr), a.setUsage(Yr), l.setUsage(Yr), c.setUsage(Yr), this.instancedGeometry.setAttribute("i_position", i), this.instancedGeometry.setAttribute("i_velocity", r), this.instancedGeometry.setAttribute("i_life", o), this.instancedGeometry.setAttribute("i_physical", a), this.instancedGeometry.setAttribute("i_rotation", l), this.instancedGeometry.setAttribute("i_color", c), this.material = new Fn({
      vertexShader: this.getVertexShader(),
      fragmentShader: this.getFragmentShader(),
      uniforms: this.createUniforms(),
      transparent: !0,
      depthWrite: this.config.render.depthWrite,
      depthTest: this.config.render.depthTest,
      blending: this.getThreeBlending()
    }), this.particleMesh = new qe(this.instancedGeometry, this.material), this.particleMesh.frustumCulled = !1;
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    this.emitters.set(e.id, {
      ...e,
      accumulator: 0,
      velocity: new ce()
    }), this.state.activeEmitters = this.emitters.size;
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.state.activeEmitters = this.emitters.size;
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  // ============================================================================
  // Force Field Management
  // ============================================================================
  addForceField(e) {
    this.forceFields.set(e.id, e);
  }
  updateForceField(e, n) {
    const i = this.forceFields.get(e);
    i && Object.assign(i, n);
  }
  removeForceField(e) {
    this.forceFields.delete(e);
  }
  // ============================================================================
  // Sub-Emitter Management
  // ============================================================================
  addSubEmitter(e) {
    this.subEmitters.set(e.id, e);
  }
  removeSubEmitter(e) {
    this.subEmitters.delete(e);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  /**
   * Step the particle simulation forward
   */
  step(e) {
    var r;
    const n = performance.now(), i = this.config.deltaTimeMode === "fixed" ? this.config.fixedDeltaTime : e * this.config.timeScale;
    this.emitParticles(i), this.updatePhysics(i), this.processSubEmitters(), (r = this.config.flocking) != null && r.enabled && (this.updateSpatialHash(), this.applyFlocking(i)), this.applyAudioModulation(), this.updateInstanceBuffers(), this.state.simulationTime += i, this.state.frameCount++, this.state.updateTimeMs = performance.now() - n;
  }
  /**
   * Emit particles from all active emitters
   */
  emitParticles(e) {
    for (const n of this.emitters.values()) {
      if (!n.enabled) continue;
      let i = n.emissionRate;
      const r = this.getAudioModulation("emitter", n.id, "emissionRate");
      if (r !== void 0 && (i *= r), n.burstOnBeat && this.audioFeatures.get("beat") === 1) {
        const o = Math.floor(n.burstCount * n.beatEmissionMultiplier);
        for (let a = 0; a < o; a++)
          this.spawnParticle(n);
      }
      for (n.accumulator += i * e; n.accumulator >= 1; )
        this.spawnParticle(n), n.accumulator -= 1;
    }
  }
  /**
   * Spawn a single particle from an emitter
   */
  spawnParticle(e) {
    if (this.freeIndices.length === 0) {
      let d = 0, h = 0;
      const m = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
      for (let p = 0; p < this.config.maxParticles; p++) {
        const y = m[p * fs + 6];
        y > h && (h = y, d = p);
      }
      this.freeIndices.push(d);
    }
    const n = this.freeIndices.pop(), i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, r = n * fs, o = this.getEmitterPosition(e), a = this.getEmissionDirection(e), l = e.initialSpeed + (this.rng() - 0.5) * 2 * e.speedVariance, c = e.velocity.clone().multiplyScalar(e.inheritEmitterVelocity);
    i[r + 0] = o.x, i[r + 1] = o.y, i[r + 2] = o.z, i[r + 3] = a.x * l + c.x, i[r + 4] = a.y * l + c.y, i[r + 5] = a.z * l + c.z, i[r + 6] = 0, i[r + 7] = e.lifetime + (this.rng() - 0.5) * 2 * e.lifetimeVariance, i[r + 8] = e.initialMass + (this.rng() - 0.5) * 2 * e.massVariance, i[r + 9] = e.initialSize + (this.rng() - 0.5) * 2 * e.sizeVariance, i[r + 10] = e.initialRotation + this.rng() * e.rotationVariance, i[r + 11] = e.initialAngularVelocity + (this.rng() - 0.5) * 2 * e.angularVelocityVariance;
    const u = this.rng() * e.colorVariance;
    return i[r + 12] = e.colorStart[0] + (e.colorEnd[0] - e.colorStart[0]) * u, i[r + 13] = e.colorStart[1] + (e.colorEnd[1] - e.colorStart[1]) * u, i[r + 14] = e.colorStart[2] + (e.colorEnd[2] - e.colorStart[2]) * u, i[r + 15] = e.colorStart[3], this.state.particleCount++, this.emit("particleBirth", { index: n, emitterId: e.id }), n;
  }
  /**
   * Get spawn position based on emitter shape
   */
  getEmitterPosition(e) {
    const n = e.shape, i = new ce(e.position.x, e.position.y, e.position.z);
    switch (n.type) {
      case "point":
        return i;
      case "circle": {
        const r = this.rng() * Math.PI * 2;
        let o = n.radius ?? 50;
        return n.emitFromEdge || (o *= Math.sqrt(this.rng())), i.add(new ce(
          Math.cos(r) * o,
          Math.sin(r) * o,
          0
        ));
      }
      case "sphere": {
        const r = this.rng() * Math.PI * 2, o = Math.acos(2 * this.rng() - 1);
        let a = n.radius ?? 50;
        return n.emitFromEdge || (a *= Math.cbrt(this.rng())), i.add(new ce(
          Math.sin(o) * Math.cos(r) * a,
          Math.sin(o) * Math.sin(r) * a,
          Math.cos(o) * a
        ));
      }
      case "box": {
        const r = n.boxSize ?? { x: 100, y: 100, z: 100 };
        return i.add(new ce(
          (this.rng() - 0.5) * r.x,
          (this.rng() - 0.5) * r.y,
          (this.rng() - 0.5) * r.z
        ));
      }
      case "line": {
        const r = n.lineStart ?? { x: -50, y: 0, z: 0 }, o = n.lineEnd ?? { x: 50, y: 0, z: 0 }, a = this.rng();
        return i.add(new ce(
          r.x + (o.x - r.x) * a,
          r.y + (o.y - r.y) * a,
          r.z + (o.z - r.z) * a
        ));
      }
      case "cone": {
        const r = this.rng() * Math.PI * 2, o = this.rng(), a = o * (n.coneRadius ?? 50), l = o * (n.coneLength ?? 100);
        return i.add(new ce(
          Math.cos(r) * a,
          l,
          Math.sin(r) * a
        ));
      }
      case "image": {
        if (!n.imageData) return i;
        const { width: r, height: o, data: a } = n.imageData, l = n.emissionThreshold ?? 0.1;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * r), d = Math.floor(this.rng() * o), h = (d * r + u) * 4;
          if (a[h + 3] / 255 > l)
            return i.add(new ce(
              u - r / 2,
              -(d - o / 2),
              // Flip Y for screen coords
              0
            ));
        }
        return i;
      }
      case "depthEdge": {
        if (!n.depthData || !n.imageData) return i;
        const { width: r, height: o } = n.imageData, a = n.depthData, l = n.emissionThreshold ?? 0.05;
        for (let c = 0; c < 100; c++) {
          const u = Math.floor(this.rng() * (r - 2)) + 1, d = Math.floor(this.rng() * (o - 2)) + 1, h = d * r + u, m = a[h], p = a[h - 1], y = a[h + 1], _ = a[h - r], v = a[h + r], g = Math.abs(y - p), S = Math.abs(v - _);
          if (Math.sqrt(g * g + S * S) > l) {
            const x = m * 500;
            return i.add(new ce(
              u - r / 2,
              -(d - o / 2),
              // Flip Y for screen coords
              x
            ));
          }
        }
        return i;
      }
      default:
        return i;
    }
  }
  /**
   * Get emission direction based on emitter settings
   */
  getEmissionDirection(e) {
    const n = new ce(
      e.emissionDirection.x,
      e.emissionDirection.y,
      e.emissionDirection.z
    ).normalize();
    if (e.emissionSpread <= 0)
      return n;
    const i = e.emissionSpread * Math.PI / 180, r = this.rng() * Math.PI * 2, o = Math.acos(1 - this.rng() * (1 - Math.cos(i))), a = Math.abs(n.y) < 0.99 ? new ce(0, 1, 0) : new ce(1, 0, 0), l = new ce().crossVectors(a, n).normalize(), c = new ce().crossVectors(n, l);
    return new ce().addScaledVector(n, Math.cos(o)).addScaledVector(l, Math.sin(o) * Math.cos(r)).addScaledVector(c, Math.sin(o) * Math.sin(r)).normalize();
  }
  /**
   * Update particle physics (CPU implementation)
   */
  updatePhysics(e) {
    const n = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const r = i * fs, o = n[r + 6], a = n[r + 7];
      if (a <= 0 || o >= a) continue;
      let l = n[r + 0], c = n[r + 1], u = n[r + 2], d = n[r + 3], h = n[r + 4], m = n[r + 5];
      const p = n[r + 8];
      let y = 0, _ = 0, v = 0;
      for (const T of this.forceFields.values()) {
        if (!T.enabled) continue;
        const b = this.calculateForceField(T, l, c, u, d, h, m, p);
        y += b.x, _ += b.y, v += b.z;
      }
      const g = y / Math.max(p, 0.1), S = _ / Math.max(p, 0.1), w = v / Math.max(p, 0.1);
      d += g * e, h += S * e, m += w * e, l += d * e, c += h * e, u += m * e;
      const x = o / a, C = this.evaluateModulationCurve(
        this.config.lifetimeModulation.sizeOverLifetime || { type: "constant", value: 1 },
        x
      ), E = this.evaluateModulationCurve(
        this.config.lifetimeModulation.opacityOverLifetime || { type: "constant", value: 1 },
        x
      ), P = n[r + 10] + n[r + 11] * e;
      n[r + 0] = l, n[r + 1] = c, n[r + 2] = u, n[r + 3] = d, n[r + 4] = h, n[r + 5] = m, n[r + 6] = o + e, n[r + 9] *= C, n[r + 10] = P, n[r + 15] *= E, o + e >= a && (this.freeIndices.push(i), this.state.particleCount--, this.emit("particleDeath", { index: i }));
    }
  }
  /**
   * Calculate force from a force field
   */
  calculateForceField(e, n, i, r, o, a, l, c) {
    var v, g, S, w, x, C, E, P, T;
    const u = new ce(), d = n - e.position.x, h = i - e.position.y, m = r - e.position.z, p = Math.sqrt(d * d + h * h + m * m);
    let y = 1;
    if (p > e.falloffStart) {
      const b = Math.min((p - e.falloffStart) / (e.falloffEnd - e.falloffStart), 1);
      switch (e.falloffType) {
        case "linear":
          y = 1 - b;
          break;
        case "quadratic":
          y = 1 - b * b;
          break;
        case "exponential":
          y = Math.exp(-b * 3);
          break;
        case "smoothstep":
          y = 1 - (3 * b * b - 2 * b * b * b);
          break;
      }
    }
    const _ = e.strength * y;
    switch (e.type) {
      case "gravity":
        u.set(
          (((v = e.direction) == null ? void 0 : v.x) ?? 0) * _,
          (((g = e.direction) == null ? void 0 : g.y) ?? 1) * _,
          (((S = e.direction) == null ? void 0 : S.z) ?? 0) * _
        );
        break;
      case "point":
        if (p > 1e-3) {
          const b = new ce(-d, -h, -m).normalize();
          u.copy(b).multiplyScalar(_ / c);
        }
        break;
      case "vortex":
        if (p > 1e-3) {
          const b = new ce(
            ((w = e.vortexAxis) == null ? void 0 : w.x) ?? 0,
            ((x = e.vortexAxis) == null ? void 0 : x.y) ?? 0,
            ((C = e.vortexAxis) == null ? void 0 : C.z) ?? 1
          ).normalize(), M = new ce(d, h, m), L = new ce().crossVectors(b, M).normalize(), N = M.normalize().multiplyScalar(-(e.inwardForce ?? 0));
          u.copy(L).multiplyScalar(_).add(N);
        }
        break;
      case "turbulence": {
        const b = e.noiseScale ?? 0.01, M = e.noiseSpeed ?? 0.5, L = this.state.simulationTime * M, N = Math.sin(n * b + L) * Math.cos(i * b * 1.3) * _, D = Math.sin(i * b + L * 1.1) * Math.cos(r * b * 1.2) * _, O = Math.sin(r * b + L * 0.9) * Math.cos(n * b * 1.1) * _;
        u.set(N, D, O);
        break;
      }
      case "drag": {
        const b = Math.sqrt(o * o + a * a + l * l);
        if (b > 1e-3) {
          const M = (e.linearDrag ?? 0.1) * b + (e.quadraticDrag ?? 0.01) * b * b;
          u.set(-o, -a, -l).normalize().multiplyScalar(-M * _);
        }
        break;
      }
      case "wind": {
        const b = new ce(
          ((E = e.windDirection) == null ? void 0 : E.x) ?? 1,
          ((P = e.windDirection) == null ? void 0 : P.y) ?? 0,
          ((T = e.windDirection) == null ? void 0 : T.z) ?? 0
        ).normalize(), M = Math.sin(this.state.simulationTime * (e.gustFrequency ?? 0.5)) * (e.gustStrength ?? 0);
        u.copy(b).multiplyScalar(_ + M);
        break;
      }
      case "lorenz": {
        const b = e.lorenzSigma ?? 10, M = e.lorenzRho ?? 28, L = e.lorenzBeta ?? 2.667;
        u.set(
          b * (h - d),
          d * (M - m) - h,
          d * h - L * m
        ).multiplyScalar(_ * 0.01);
        break;
      }
    }
    return u;
  }
  /**
   * Process sub-emitter triggers
   */
  processSubEmitters() {
  }
  /**
   * Update spatial hash for neighbor queries
   */
  updateSpatialHash() {
    this.spatialHash.clear();
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.config.spatialHashCellSize;
    for (let i = 0; i < this.config.maxParticles; i++) {
      const r = i * fs;
      if (e[r + 7] <= 0) continue;
      const a = e[r + 0], l = e[r + 1], c = e[r + 2], u = Math.floor(a / n), d = Math.floor(l / n), h = Math.floor(c / n), m = `${u},${d},${h}`;
      this.spatialHash.has(m) || this.spatialHash.set(m, []), this.spatialHash.get(m).push(i);
    }
  }
  /**
   * Apply flocking behaviors
   */
  applyFlocking(e) {
    const n = this.config.flocking;
    if (!(n != null && n.enabled)) return;
    const i = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, r = this.config.spatialHashCellSize;
    for (let o = 0; o < this.config.maxParticles; o++) {
      const a = o * fs;
      if (i[a + 7] <= 0) continue;
      const c = i[a + 0], u = i[a + 1], d = i[a + 2], h = Math.floor(c / r), m = Math.floor(u / r), p = Math.floor(d / r), y = new ce(), _ = new ce(), v = new ce();
      let g = 0, S = 0, w = 0;
      for (let E = h - 1; E <= h + 1; E++)
        for (let P = m - 1; P <= m + 1; P++)
          for (let T = p - 1; T <= p + 1; T++) {
            const b = this.spatialHash.get(`${E},${P},${T}`);
            if (b)
              for (const M of b) {
                if (M === o) continue;
                const L = M * fs, N = i[L + 0], D = i[L + 1], O = i[L + 2], A = c - N, G = u - D, he = d - O, ee = Math.sqrt(A * A + G * G + he * he);
                ee < n.separationRadius && ee > 0 && (y.add(new ce(A, G, he).divideScalar(ee)), g++), ee < n.alignmentRadius && (_.add(new ce(
                  i[L + 3],
                  i[L + 4],
                  i[L + 5]
                )), S++), ee < n.cohesionRadius && (v.add(new ce(N, D, O)), w++);
              }
          }
      g > 0 && y.divideScalar(g).normalize().multiplyScalar(n.separationWeight), S > 0 && _.divideScalar(S).normalize().multiplyScalar(n.alignmentWeight), w > 0 && (v.divideScalar(w), v.sub(new ce(c, u, d)).normalize().multiplyScalar(n.cohesionWeight));
      const x = y.add(_).add(v);
      x.length() > n.maxForce && x.normalize().multiplyScalar(n.maxForce), i[a + 3] += x.x * e, i[a + 4] += x.y * e, i[a + 5] += x.z * e;
      const C = Math.sqrt(
        i[a + 3] ** 2 + i[a + 4] ** 2 + i[a + 5] ** 2
      );
      if (C > n.maxSpeed) {
        const E = n.maxSpeed / C;
        i[a + 3] *= E, i[a + 4] *= E, i[a + 5] *= E;
      }
    }
  }
  /**
   * Apply audio modulation to parameters
   */
  applyAudioModulation() {
    for (const e of this.config.audioBindings) {
      const r = ((this.audioFeatures.get(e.feature) ?? 0) - e.min) / (e.max - e.min);
      let o = e.outputMin + r * (e.outputMax - e.outputMin);
      if (e.curve === "exponential" ? o = e.outputMin + Math.pow(r, 2) * (e.outputMax - e.outputMin) : e.curve === "logarithmic" && (o = e.outputMin + Math.sqrt(r) * (e.outputMax - e.outputMin)), e.target === "emitter") {
        const a = this.emitters.get(e.targetId);
        a && (a[e.parameter] = o);
      } else if (e.target === "forceField") {
        const a = this.forceFields.get(e.targetId);
        a && (a[e.parameter] = o);
      }
    }
  }
  /**
   * Get audio modulation for a specific parameter
   */
  getAudioModulation(e, n, i) {
    for (const r of this.config.audioBindings)
      if (r.target === e && r.targetId === n && r.parameter === i) {
        const a = ((this.audioFeatures.get(r.feature) ?? 0) - r.min) / (r.max - r.min);
        return r.outputMin + a * (r.outputMax - r.outputMin);
      }
  }
  /**
   * Update instance buffer attributes for rendering
   */
  updateInstanceBuffers() {
    if (!this.instancedGeometry) return;
    const e = this.currentBuffer === "A" ? this.particleBufferA : this.particleBufferB, n = this.instancedGeometry.getAttribute("i_position"), i = this.instancedGeometry.getAttribute("i_velocity"), r = this.instancedGeometry.getAttribute("i_life"), o = this.instancedGeometry.getAttribute("i_physical"), a = this.instancedGeometry.getAttribute("i_rotation"), l = this.instancedGeometry.getAttribute("i_color");
    for (let c = 0; c < this.config.maxParticles; c++) {
      const u = c * fs;
      n.setXYZ(c, e[u + 0], e[u + 1], e[u + 2]), i.setXYZ(c, e[u + 3], e[u + 4], e[u + 5]), r.setXY(c, e[u + 6], e[u + 7]), o.setXY(c, e[u + 8], e[u + 9]), a.setXY(c, e[u + 10], e[u + 11]), l.setXYZW(c, e[u + 12], e[u + 13], e[u + 14], e[u + 15]);
    }
    n.needsUpdate = !0, i.needsUpdate = !0, r.needsUpdate = !0, o.needsUpdate = !0, a.needsUpdate = !0, l.needsUpdate = !0;
  }
  // ============================================================================
  // Audio Integration
  // ============================================================================
  /**
   * Set audio feature value
   */
  setAudioFeature(e, n) {
    this.audioFeatures.set(e, n), this.state.currentAudioFeatures.set(e, n);
  }
  /**
   * Trigger beat event
   */
  triggerBeat() {
    this.audioFeatures.set("beat", 1), requestAnimationFrame(() => {
      this.audioFeatures.set("beat", 0);
    });
  }
  /**
   * Trigger burst on all beat-enabled emitters
   */
  triggerBurst(e) {
    if (e) {
      const n = this.emitters.get(e);
      if (n)
        for (let i = 0; i < n.burstCount; i++)
          this.spawnParticle(n);
    } else
      for (const n of this.emitters.values())
        if (n.burstOnBeat && n.enabled)
          for (let i = 0; i < n.burstCount; i++)
            this.spawnParticle(n);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  /**
   * Get the Three.js mesh for adding to scene
   */
  getMesh() {
    return this.particleMesh;
  }
  /**
   * Get vertex shader code
   */
  getVertexShader() {
    return `
      precision highp float;

      attribute vec2 position;
      attribute vec2 uv;

      attribute vec3 i_position;
      attribute vec3 i_velocity;
      attribute vec2 i_life;
      attribute vec2 i_physical;
      attribute vec2 i_rotation;
      attribute vec4 i_color;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;
      uniform vec3 cameraPosition;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      void main() {
        // Skip dead particles
        if (i_life.y <= 0.0 || i_life.x >= i_life.y) {
          gl_Position = vec4(0.0, 0.0, -1000.0, 1.0);
          return;
        }

        float size = i_physical.y;
        float rotation = i_rotation.x;
        float lifeRatio = i_life.x / i_life.y;

        // Billboard facing camera
        vec3 cameraRight = vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]);
        vec3 cameraUp = vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]);

        // Apply rotation
        float cosR = cos(rotation);
        float sinR = sin(rotation);
        vec2 rotatedPos = vec2(
          position.x * cosR - position.y * sinR,
          position.x * sinR + position.y * cosR
        );

        vec3 vertexPos = i_position
          + cameraRight * rotatedPos.x * size
          + cameraUp * rotatedPos.y * size;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPos, 1.0);

        vUv = uv;
        vColor = i_color;
        vLifeRatio = lifeRatio;
      }
    `;
  }
  /**
   * Get fragment shader code
   */
  getFragmentShader() {
    return `
      precision highp float;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vLifeRatio;

      uniform sampler2D diffuseMap;
      uniform int hasDiffuseMap;
      uniform int proceduralShape;

      float proceduralAlpha(vec2 uv, int shape) {
        vec2 centered = uv * 2.0 - 1.0;
        float dist = length(centered);

        if (shape == 1) {
          return 1.0 - smoothstep(0.8, 1.0, dist);
        } else if (shape == 2) {
          return smoothstep(0.5, 0.6, dist) * (1.0 - smoothstep(0.9, 1.0, dist));
        }

        return 1.0;
      }

      void main() {
        vec4 texColor = vec4(1.0);

        if (hasDiffuseMap == 1) {
          texColor = texture2D(diffuseMap, vUv);
        } else if (proceduralShape > 0) {
          float alpha = proceduralAlpha(vUv, proceduralShape);
          texColor = vec4(1.0, 1.0, 1.0, alpha);
        }

        vec4 finalColor = texColor * vColor;

        if (finalColor.a < 0.01) discard;

        gl_FragColor = finalColor;
      }
    `;
  }
  /**
   * Create shader uniforms
   */
  createUniforms() {
    return {
      diffuseMap: { value: null },
      hasDiffuseMap: { value: 0 },
      proceduralShape: { value: 1 }
      // Circle by default
    };
  }
  /**
   * Get Three.js blending mode
   */
  getThreeBlending() {
    switch (this.config.render.blendMode) {
      case "additive":
        return Qa;
      case "multiply":
        return Eo;
      case "screen":
        return Cr;
      default:
        return Ni;
    }
  }
  // ============================================================================
  // Event System
  // ============================================================================
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var r;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (r = this.eventHandlers.get(e)) == null || r.forEach((o) => o(i));
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  /**
   * Create seeded random number generator
   */
  createSeededRandom(e) {
    let n = e;
    return () => (n = n * 1103515245 + 12345 & 2147483647, n / 2147483647);
  }
  /**
   * Get current state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleBufferA.fill(0), this.particleBufferB.fill(0), this.freeIndices = [];
    for (let e = this.config.maxParticles - 1; e >= 0; e--)
      this.freeIndices.push(e);
    this.state.particleCount = 0, this.state.simulationTime = 0, this.state.frameCount = 0, this.spatialHash.clear();
  }
  /**
   * Dispose all resources
   */
  dispose() {
    var e, n, i, r, o;
    (e = this.instancedGeometry) == null || e.dispose(), (n = this.material) == null || n.dispose(), (i = this.sizeOverLifetimeTexture) == null || i.dispose(), (r = this.opacityOverLifetimeTexture) == null || r.dispose(), (o = this.colorOverLifetimeTexture) == null || o.dispose(), this.emitters.clear(), this.forceFields.clear(), this.subEmitters.clear(), this.eventHandlers.clear();
  }
}
class lN extends $i {
  constructor(n) {
    super(n);
    /** The GPU particle system instance */
    pe(this, "particleSystem");
    /** Particle system configuration */
    pe(this, "systemConfig");
    /** Whether the system has been initialized with a renderer */
    pe(this, "initialized", !1);
    /** Stored renderer reference for reinitialization */
    pe(this, "rendererRef", null);
    /** Composition FPS for time calculation */
    pe(this, "fps", 60);
    /** Performance stats */
    pe(this, "stats", {
      particleCount: 0,
      updateTimeMs: 0,
      renderTimeMs: 0
    });
    this.systemConfig = this.buildSystemConfig(n), this.particleSystem = new Bv(this.systemConfig), this.initializeBlendMode();
  }
  /**
   * Build GPUParticleSystemConfig from layer data
   */
  buildSystemConfig(n) {
    const i = n.data, r = Ty();
    if (!i)
      return r.emitters = [Nv("default")], r;
    if (i.systemConfig) {
      if (r.maxParticles = i.systemConfig.maxParticles ?? 1e5, r.timeScale = 1, i.systemConfig.gravity !== 0 && r.forceFields.push({
        id: "global_gravity",
        name: "Gravity",
        type: "gravity",
        enabled: !0,
        strength: i.systemConfig.gravity * 10,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        direction: { x: 0, y: 1, z: 0 }
      }), i.systemConfig.windStrength !== 0) {
        const o = (i.systemConfig.windDirection ?? 0) * Math.PI / 180;
        r.forceFields.push({
          id: "global_wind",
          name: "Wind",
          type: "wind",
          enabled: !0,
          strength: i.systemConfig.windStrength,
          position: { x: 0, y: 0, z: 0 },
          falloffStart: 0,
          falloffEnd: 1e4,
          falloffType: "none",
          windDirection: {
            x: Math.cos(o),
            y: Math.sin(o),
            z: 0
          },
          gustStrength: i.systemConfig.windStrength * 0.3,
          gustFrequency: 0.1
        });
      }
      if (i.systemConfig.friction > 0 && r.forceFields.push({
        id: "global_drag",
        name: "Friction",
        type: "drag",
        enabled: !0,
        strength: 1,
        position: { x: 0, y: 0, z: 0 },
        falloffStart: 0,
        falloffEnd: 1e4,
        falloffType: "none",
        linearDrag: i.systemConfig.friction,
        quadraticDrag: i.systemConfig.friction * 0.1
      }), i.systemConfig.turbulenceFields)
        for (const o of i.systemConfig.turbulenceFields)
          o.enabled && r.forceFields.push({
            id: o.id,
            name: "Turbulence",
            type: "turbulence",
            enabled: !0,
            strength: o.strength,
            position: { x: 0, y: 0, z: 0 },
            falloffStart: 0,
            falloffEnd: 1e4,
            falloffType: "none",
            noiseScale: o.scale,
            noiseSpeed: o.evolutionSpeed,
            noiseOctaves: 3,
            noiseLacunarity: 2,
            noiseGain: 0.5
          });
    }
    if (i.emitters)
      for (const o of i.emitters) {
        if (!o.enabled) continue;
        const a = (o.direction ?? 0) * Math.PI / 180, l = {
          id: o.id,
          name: o.name,
          enabled: !0,
          position: { x: o.x, y: o.y, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          shape: { type: "point" },
          emissionRate: o.emissionRate,
          emissionRateVariance: 0,
          burstCount: o.burstCount,
          burstInterval: 0,
          initialSpeed: o.speed,
          speedVariance: o.speedVariance,
          inheritEmitterVelocity: 0,
          initialSize: o.size,
          sizeVariance: o.sizeVariance,
          initialMass: 1,
          massVariance: 0,
          lifetime: o.particleLifetime,
          lifetimeVariance: o.lifetimeVariance,
          initialRotation: 0,
          rotationVariance: 360,
          initialAngularVelocity: 0,
          angularVelocityVariance: 0,
          colorStart: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            1
          ],
          colorEnd: [
            o.color[0] / 255,
            o.color[1] / 255,
            o.color[2] / 255,
            0
          ],
          colorVariance: 0,
          emissionDirection: {
            x: Math.cos(a),
            y: Math.sin(a),
            z: 0
          },
          emissionSpread: o.spread,
          burstOnBeat: o.burstOnBeat,
          beatEmissionMultiplier: 5
        };
        r.emitters.push(l);
      }
    if (i.gravityWells)
      for (const o of i.gravityWells)
        o.enabled && r.forceFields.push({
          id: o.id,
          name: o.name,
          type: "point",
          enabled: !0,
          strength: o.strength,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: o.falloff === "linear" ? "linear" : o.falloff === "quadratic" ? "quadratic" : "none"
        });
    if (i.vortices)
      for (const o of i.vortices)
        o.enabled && r.forceFields.push({
          id: o.id,
          name: o.name,
          type: "vortex",
          enabled: !0,
          strength: o.strength * o.rotationSpeed,
          position: { x: o.x, y: o.y, z: 0 },
          falloffStart: 0,
          falloffEnd: o.radius,
          falloffType: "linear",
          vortexAxis: { x: 0, y: 0, z: 1 },
          inwardForce: o.inwardPull
        });
    if (i.modulations) {
      const o = i.modulations.filter((l) => l.property === "size");
      if (o.length > 0) {
        const l = o[0];
        r.lifetimeModulation.sizeOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
      const a = i.modulations.filter((l) => l.property === "opacity");
      if (a.length > 0) {
        const l = a[0];
        r.lifetimeModulation.opacityOverLifetime = {
          type: "linear",
          start: l.startValue / 100,
          end: l.endValue / 100
        };
      }
    }
    return i.renderOptions && (r.render.blendMode = i.renderOptions.blendMode ?? "normal", r.render.motionBlur = i.renderOptions.motionBlur ?? !1, r.render.motionBlurStrength = i.renderOptions.motionBlurStrength ?? 0.5, r.render.motionBlurSamples = i.renderOptions.motionBlurSamples ?? 4, i.renderOptions.renderTrails && (r.render.mode = "trail", r.render.trailLength = i.renderOptions.trailLength, r.render.trailWidthEnd = 1 - (i.renderOptions.trailOpacityFalloff ?? 0.8)), r.render.texture.proceduralType = i.renderOptions.particleShape === "star" ? "star" : i.renderOptions.particleShape === "square" ? "square" : "circle"), r;
  }
  /**
   * Initialize the particle system with a WebGL renderer
   */
  initializeWithRenderer(n) {
    if (this.initialized) return;
    this.rendererRef = n, this.particleSystem.initialize(n), this.initialized = !0;
    const i = this.particleSystem.getMesh();
    i && this.group.add(i);
  }
  /**
   * Set renderer for lazy initialization
   */
  setRenderer(n) {
    this.rendererRef = n, this.initialized || this.initializeWithRenderer(n);
  }
  /**
   * Set composition FPS for accurate time calculation
   */
  setFPS(n) {
    this.fps = n;
  }
  // ============================================================================
  // EMITTER MANAGEMENT
  // ============================================================================
  /**
   * Add a new emitter
   */
  addEmitter(n) {
    const i = Nv();
    return n && Object.assign(i, n), this.particleSystem.addEmitter(i), i.id;
  }
  /**
   * Update an emitter
   */
  updateEmitter(n, i) {
    this.particleSystem.updateEmitter(n, i);
  }
  /**
   * Remove an emitter
   */
  removeEmitter(n) {
    this.particleSystem.removeEmitter(n);
  }
  // ============================================================================
  // FORCE FIELD MANAGEMENT
  // ============================================================================
  /**
   * Add a force field
   */
  addForceField(n, i) {
    const r = aN(n);
    return i && Object.assign(r, i), this.particleSystem.addForceField(r), r.id;
  }
  /**
   * Update a force field
   */
  updateForceField(n, i) {
    this.particleSystem.updateForceField(n, i);
  }
  /**
   * Remove a force field
   */
  removeForceField(n) {
    this.particleSystem.removeForceField(n);
  }
  // ============================================================================
  // AUDIO REACTIVITY
  // ============================================================================
  /**
   * Set audio feature value for reactivity
   */
  setAudioFeature(n, i) {
    this.particleSystem.setAudioFeature(n, i);
  }
  /**
   * Trigger a beat event (causes burst on beat-enabled emitters)
   */
  triggerBeat() {
    this.particleSystem.triggerBeat();
  }
  /**
   * Trigger a burst emission
   */
  triggerBurst(n) {
    this.particleSystem.triggerBurst(n);
  }
  // ============================================================================
  // SIMULATION
  // ============================================================================
  /**
   * Step the particle simulation
   */
  step(n) {
    if (!this.initialized) return;
    this.particleSystem.step(n);
    const i = this.particleSystem.getState();
    this.stats.particleCount = i.particleCount, this.stats.updateTimeMs = i.updateTimeMs, this.stats.renderTimeMs = i.renderTimeMs;
  }
  /**
   * Get current performance stats
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset the particle system
   */
  reset() {
    this.particleSystem.reset();
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    const i = 1 / this.fps;
    this.step(i);
  }
  onUpdate(n) {
    if (n.data) {
      const r = this.particleSystem.getMesh();
      r && this.group.remove(r), this.systemConfig = this.buildSystemConfig({
        ...n,
        id: this.id,
        type: "particles"
      }), this.particleSystem.dispose(), this.particleSystem = new Bv(this.systemConfig), this.rendererRef && (this.initialized = !1, this.initializeWithRenderer(this.rendererRef));
    }
  }
  onDispose() {
    this.particleSystem.dispose();
  }
  // ============================================================================
  // ACCESSORS
  // ============================================================================
  /**
   * Get the underlying particle system for advanced operations
   */
  getParticleSystem() {
    return this.particleSystem;
  }
  /**
   * Get current particle count
   */
  getParticleCount() {
    return this.particleSystem.getState().particleCount;
  }
  /**
   * Check if system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
}
class cN extends $i {
  constructor(n) {
    super(n);
    // Precomp data
    pe(this, "precompData");
    // Render context (provided by LayerManager)
    pe(this, "renderContext", null);
    // Display mesh
    pe(this, "mesh", null);
    pe(this, "material", null);
    // Cached render texture
    pe(this, "renderTexture", null);
    // Animation evaluator for time remap
    pe(this, "precompEvaluator");
    // Cached composition reference
    pe(this, "cachedComposition", null);
    // Parent composition FPS for frame rate conversion
    pe(this, "parentFPS", 30);
    this.precompEvaluator = new vl(), this.precompData = this.extractPrecompData(n), this.createMesh(), this.initializeBlendMode();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract precomp data with defaults
   */
  extractPrecompData(n) {
    const i = n.data;
    return {
      compositionId: (i == null ? void 0 : i.compositionId) ?? "",
      timeRemapEnabled: (i == null ? void 0 : i.timeRemapEnabled) ?? !1,
      timeRemap: i == null ? void 0 : i.timeRemap,
      collapseTransformations: (i == null ? void 0 : i.collapseTransformations) ?? !1,
      overrideFrameRate: (i == null ? void 0 : i.overrideFrameRate) ?? !1,
      frameRate: i == null ? void 0 : i.frameRate
    };
  }
  /**
   * Create display mesh
   */
  createMesh() {
    const n = new cn(1, 1);
    this.material = new Mn({
      color: 4473924,
      transparent: !0,
      side: mn
    }), this.mesh = new qe(n, this.material), this.mesh.name = `precomp_${this.id}`, this.group.add(this.mesh);
  }
  // ============================================================================
  // RENDER CONTEXT
  // ============================================================================
  /**
   * Set the render context (required for precomp rendering)
   * Called by LayerManager after creation
   */
  setRenderContext(n) {
    this.renderContext = n, this.loadComposition();
  }
  /**
   * Set parent composition FPS for frame rate conversion
   */
  setFPS(n) {
    this.parentFPS = n;
  }
  /**
   * Load and cache the referenced composition
   */
  loadComposition() {
    !this.renderContext || !this.precompData.compositionId || (this.cachedComposition = this.renderContext.getComposition(
      this.precompData.compositionId
    ), this.cachedComposition && this.resizeMesh(
      this.cachedComposition.settings.width,
      this.cachedComposition.settings.height
    ));
  }
  /**
   * Resize mesh to match composition dimensions
   */
  resizeMesh(n, i) {
    this.mesh && (this.mesh.geometry.dispose(), this.mesh.geometry = new cn(n, i));
  }
  // ============================================================================
  // TIME CALCULATION
  // ============================================================================
  /**
   * Calculate the frame in the nested composition
   * based on parent frame and time remapping
   */
  calculateNestedFrame(n) {
    if (!this.cachedComposition) return 0;
    if (this.precompData.timeRemapEnabled && this.precompData.timeRemap) {
      const i = this.precompData.timeRemap.animated ? this.precompEvaluator.evaluate(this.precompData.timeRemap, n) : this.precompData.timeRemap.value, r = this.precompData.overrideFrameRate && this.precompData.frameRate ? this.precompData.frameRate : this.cachedComposition.settings.fps;
      return Math.floor(i * r);
    }
    if (this.precompData.overrideFrameRate && this.precompData.frameRate) {
      const i = this.parentFPS, r = this.precompData.frameRate;
      return Math.floor(n * (r / i));
    }
    return n;
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    if (!this.renderContext || !this.cachedComposition)
      return;
    const i = this.calculateNestedFrame(n), r = Math.max(
      0,
      Math.min(i, this.cachedComposition.settings.frameCount - 1)
    );
    this.renderTexture = this.renderContext.renderComposition(
      this.precompData.compositionId,
      r
    ), this.material && (this.renderTexture ? (this.material.map = this.renderTexture, this.material.color.setHex(16777215)) : (this.material.map = null, this.material.color.setHex(4473924)), this.material.needsUpdate = !0);
  }
  // ============================================================================
  // PROPERTY UPDATES
  // ============================================================================
  /**
   * Set the source composition
   */
  setComposition(n) {
    this.precompData.compositionId = n, this.loadComposition();
  }
  /**
   * Enable/disable time remapping
   */
  setTimeRemapEnabled(n) {
    this.precompData.timeRemapEnabled = n;
  }
  /**
   * Set time remap property
   */
  setTimeRemap(n) {
    this.precompData.timeRemap = n;
  }
  /**
   * Enable/disable collapse transformations
   */
  setCollapseTransformations(n) {
    this.precompData.collapseTransformations = n;
  }
  /**
   * Override frame rate
   */
  setFrameRateOverride(n, i) {
    this.precompData.overrideFrameRate = n, this.precompData.frameRate = i;
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.compositionId !== void 0 && this.setComposition(i.compositionId), i.timeRemapEnabled !== void 0 && this.setTimeRemapEnabled(i.timeRemapEnabled), i.timeRemap !== void 0 && this.setTimeRemap(i.timeRemap), i.collapseTransformations !== void 0 && this.setCollapseTransformations(i.collapseTransformations), (i.overrideFrameRate !== void 0 || i.frameRate !== void 0) && this.setFrameRateOverride(
      i.overrideFrameRate ?? this.precompData.overrideFrameRate,
      i.frameRate ?? this.precompData.frameRate
    ));
  }
  // ============================================================================
  // GETTERS
  // ============================================================================
  /**
   * Get precomp data
   */
  getPrecompData() {
    return { ...this.precompData };
  }
  /**
   * Get referenced composition
   */
  getComposition() {
    return this.cachedComposition;
  }
  /**
   * Get composition ID
   */
  getCompositionId() {
    return this.precompData.compositionId;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  onDispose() {
    this.material && this.material.dispose(), this.mesh && (this.mesh.geometry.dispose(), this.group.remove(this.mesh)), this.renderTexture = null, this.cachedComposition = null;
  }
}
class uN extends $i {
  constructor(n) {
    super(n);
    // Camera data reference
    pe(this, "cameraData");
    // Callbacks to store
    pe(this, "cameraGetter");
    pe(this, "cameraAtFrameGetter");
    pe(this, "cameraUpdater");
    // Track current frame for interpolation
    pe(this, "currentFrame", 0);
    // Visual wireframe (shown in editor)
    pe(this, "wireframe", null);
    pe(this, "wireframeVisible", !0);
    // Frustum visualization
    pe(this, "frustumHelper", null);
    pe(this, "showFrustum", !0);
    // Track last camera state for frustum updates
    pe(this, "lastFrustumState", null);
    this.threeD = !0, this.cameraData = this.extractCameraData(n), this.createWireframe();
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Extract camera layer data with defaults
   */
  extractCameraData(n) {
    const i = n.data;
    return {
      cameraId: (i == null ? void 0 : i.cameraId) ?? "",
      isActiveCamera: (i == null ? void 0 : i.isActiveCamera) ?? !1
    };
  }
  /**
   * Set callbacks to access Camera3D data from store
   */
  setCameraCallbacks(n, i, r) {
    this.cameraGetter = n, this.cameraUpdater = i, this.cameraAtFrameGetter = r;
  }
  // ============================================================================
  // WIREFRAME VISUALIZATION
  // ============================================================================
  /**
   * Create camera wireframe indicator
   */
  createWireframe() {
    this.wireframe = new Ei(), this.wireframe.name = `camera_wireframe_${this.id}`;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200, i = 40, r = new hn(i, i * 0.6, i * 0.8), o = new Mn({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), a = new qe(r, o);
    this.wireframe.add(a);
    const l = new If(i * 0.3, i * 0.6, 8), c = new Mn({
      color: n,
      wireframe: !0,
      transparent: !0,
      opacity: 0.6,
      depthTest: !1
    }), u = new qe(l, c);
    u.rotation.x = Math.PI / 2, u.position.z = i * 0.7, this.wireframe.add(u);
    const d = new cn(i * 0.8, i * 0.5), h = new Mn({
      color: n,
      transparent: !0,
      opacity: 0.2,
      side: mn,
      depthTest: !1
    }), m = new qe(d, h);
    m.position.z = -i * 0.4, this.wireframe.add(m);
    const p = [
      new ce(0, i * 0.4, 0),
      new ce(0, i * 0.7, 0),
      new ce(-i * 0.1, i * 0.55, 0),
      new ce(0, i * 0.7, 0),
      new ce(i * 0.1, i * 0.55, 0)
    ], y = new Nt().setFromPoints(p), _ = new Wi({
      color: 65280,
      transparent: !0,
      opacity: 0.8,
      depthTest: !1
    }), v = new an(y, _);
    this.wireframe.add(v), this.group.add(this.wireframe), this.wireframe.renderOrder = 998;
  }
  /**
   * Create frustum visualization
   */
  createFrustum() {
    const n = this.getCamera();
    if (!n) return;
    this.frustumHelper = new Ei(), this.frustumHelper.name = `camera_frustum_${this.id}`;
    const i = this.cameraData.isActiveCamera ? 43775 : 16755200, r = n.nearClip, o = Math.min(n.farClip, 2e3), a = n.angleOfView * (Math.PI / 180), l = 16 / 9, c = 2 * Math.tan(a / 2) * r, u = c * l, d = 2 * Math.tan(a / 2) * o, h = d * l, m = new Wi({
      color: i,
      transparent: !0,
      opacity: 0.3,
      depthTest: !1
    }), p = new ce(-u / 2, c / 2, r), y = new ce(u / 2, c / 2, r), _ = new ce(-u / 2, -c / 2, r), v = new ce(u / 2, -c / 2, r), g = new ce(-h / 2, d / 2, o), S = new ce(h / 2, d / 2, o), w = new ce(-h / 2, -d / 2, o), x = new ce(h / 2, -d / 2, o), C = new Nt().setFromPoints([
      p,
      y,
      v,
      _,
      p
    ]);
    this.frustumHelper.add(new an(C, m));
    const E = new Nt().setFromPoints([
      g,
      S,
      x,
      w,
      g
    ]);
    this.frustumHelper.add(new an(E, m));
    const P = [
      [p, g],
      [y, S],
      [_, w],
      [v, x]
    ];
    for (const [T, b] of P) {
      const M = new Nt().setFromPoints([T, b]);
      this.frustumHelper.add(new an(M, m));
    }
    this.group.add(this.frustumHelper), this.frustumHelper.renderOrder = 997, this.frustumHelper.visible = this.showFrustum;
  }
  /**
   * Update wireframe color based on active state
   */
  updateWireframeColor() {
    if (!this.wireframe) return;
    const n = this.cameraData.isActiveCamera ? 43775 : 16755200;
    this.wireframe.traverse((i) => {
      if (i instanceof qe || i instanceof an) {
        const r = i.material;
        if (r.color.getHex() === 65280) return;
        r.color.setHex(n);
      }
    });
  }
  // ============================================================================
  // CAMERA ACCESS
  // ============================================================================
  /**
   * Get the linked Camera3D object (base, without interpolation)
   */
  getCamera() {
    return !this.cameraGetter || !this.cameraData.cameraId ? null : this.cameraGetter(this.cameraData.cameraId);
  }
  /**
   * Get the camera with keyframe interpolation applied at the current frame
   */
  getCameraAtCurrentFrame() {
    return this.cameraData.cameraId ? this.cameraAtFrameGetter ? this.cameraAtFrameGetter(this.cameraData.cameraId, this.currentFrame) : this.getCamera() : null;
  }
  /**
   * Get camera ID
   */
  getCameraId() {
    return this.cameraData.cameraId;
  }
  /**
   * Check if this is the active camera
   */
  isActiveCamera() {
    return this.cameraData.isActiveCamera;
  }
  /**
   * Set as active camera
   */
  setActiveCamera(n) {
    this.cameraData.isActiveCamera = n, this.updateWireframeColor(), this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum(), this.createFrustum());
  }
  // ============================================================================
  // VISIBILITY CONTROLS
  // ============================================================================
  /**
   * Set wireframe visibility
   */
  setWireframeVisible(n) {
    this.wireframeVisible = n, this.wireframe && (this.wireframe.visible = n);
  }
  /**
   * Set frustum visibility
   */
  setFrustumVisible(n) {
    this.showFrustum = n, this.frustumHelper && (this.frustumHelper.visible = n);
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  onEvaluateFrame(n) {
    this.currentFrame = n;
    const i = this.getCameraAtCurrentFrame();
    if (!i) return;
    this.group.position.set(
      i.position.x,
      i.position.y,
      i.position.z
    );
    const r = Math.PI / 180;
    if (i.type === "two-node" && i.pointOfInterest) {
      const l = new ce(
        i.pointOfInterest.x,
        i.pointOfInterest.y,
        i.pointOfInterest.z
      );
      this.group.lookAt(l), this.group.rotation.z += i.zRotation * r;
    } else
      this.group.rotation.set(
        (i.orientation.x + i.xRotation) * r,
        (i.orientation.y + i.yRotation) * r,
        (i.orientation.z + i.zRotation) * r,
        "YXZ"
        // Standard After Effects rotation order
      );
    const o = {
      fov: i.angleOfView,
      near: i.nearClip,
      far: i.farClip
    };
    (!this.lastFrustumState || this.lastFrustumState.fov !== o.fov || this.lastFrustumState.near !== o.near || this.lastFrustumState.far !== o.far) && (this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum(), this.lastFrustumState = o);
  }
  // ============================================================================
  // LAYER UPDATE
  // ============================================================================
  onUpdate(n) {
    const i = n.data;
    i && (i.cameraId !== void 0 && (this.cameraData.cameraId = i.cameraId, this.frustumHelper && (this.group.remove(this.frustumHelper), this.disposeFrustum()), this.createFrustum()), i.isActiveCamera !== void 0 && this.setActiveCamera(i.isActiveCamera));
  }
  // ============================================================================
  // EXPORT HELPERS
  // ============================================================================
  /**
   * Get camera transform data for export/render
   * Returns position, rotation, and lens data at current frame (with interpolation)
   */
  getExportData() {
    const n = this.getCameraAtCurrentFrame();
    return n ? {
      position: { ...n.position },
      rotation: {
        x: n.orientation.x + n.xRotation,
        y: n.orientation.y + n.yRotation,
        z: n.orientation.z + n.zRotation
      },
      fov: n.angleOfView,
      focalLength: n.focalLength,
      nearClip: n.nearClip,
      farClip: n.farClip
    } : null;
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  disposeWireframe() {
    this.wireframe && (this.wireframe.traverse((n) => {
      (n instanceof qe || n instanceof an) && (n.geometry.dispose(), n.material.dispose());
    }), this.wireframe.clear(), this.wireframe = null);
  }
  disposeFrustum() {
    this.frustumHelper && (this.frustumHelper.traverse((n) => {
      n instanceof an && (n.geometry.dispose(), n.material.dispose());
    }), this.frustumHelper.clear(), this.frustumHelper = null);
  }
  onDispose() {
    this.disposeWireframe(), this.disposeFrustum();
  }
}
class dN extends $i {
  constructor(n) {
    super(n);
    pe(this, "light");
    pe(this, "helper", null);
    pe(this, "lightData");
    this.lightData = this.extractLightData(n), this.light = this.createLight(), this.group.add(this.light), this.createHelper(), this.initializeBlendMode();
  }
  /**
   * Extract light data from layer object
   */
  extractLightData(n) {
    const i = n.data;
    return {
      lightType: (i == null ? void 0 : i.lightType) ?? "point",
      color: (i == null ? void 0 : i.color) ?? "#ffffff",
      intensity: (i == null ? void 0 : i.intensity) ?? 100,
      radius: (i == null ? void 0 : i.radius) ?? 500,
      falloff: (i == null ? void 0 : i.falloff) ?? "none",
      falloffDistance: (i == null ? void 0 : i.falloffDistance) ?? 500,
      castShadows: (i == null ? void 0 : i.castShadows) ?? !1,
      shadowDarkness: (i == null ? void 0 : i.shadowDarkness) ?? 100,
      shadowDiffusion: (i == null ? void 0 : i.shadowDiffusion) ?? 0,
      coneAngle: (i == null ? void 0 : i.coneAngle) ?? 90,
      coneFeather: (i == null ? void 0 : i.coneFeather) ?? 50,
      animatedIntensity: i == null ? void 0 : i.animatedIntensity,
      animatedConeAngle: i == null ? void 0 : i.animatedConeAngle
    };
  }
  /**
   * Create the Three.js light based on type
   */
  createLight() {
    const n = new Mt(this.lightData.color), i = this.lightData.intensity / 100;
    switch (this.lightData.lightType) {
      case "point": {
        const r = new da(n, i);
        return r.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, r.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, this.configureShadows(r), r;
      }
      case "spot": {
        const r = new Vs(n, i);
        return r.distance = this.lightData.falloff === "none" ? 0 : this.lightData.falloffDistance, r.decay = this.lightData.falloff === "inverseSquareClamped" ? 2 : 1, r.angle = fn.degToRad((this.lightData.coneAngle ?? 90) / 2), r.penumbra = (this.lightData.coneFeather ?? 50) / 100, this.configureShadows(r), r;
      }
      case "parallel": {
        const r = new xo(n, i);
        return this.configureShadows(r), r;
      }
      case "ambient":
        return new ay(n, i);
      default:
        return console.warn(`[LightLayer] Unknown light type: ${this.lightData.lightType}, defaulting to point`), new da(n, i);
    }
  }
  /**
   * Configure shadow settings for shadow-capable lights
   */
  configureShadows(n) {
    n.castShadow = this.lightData.castShadows, n.castShadow && (n.shadow.mapSize.width = 1024, n.shadow.mapSize.height = 1024, n.shadow.bias = -1e-4 * (100 - this.lightData.shadowDarkness) / 100, n.shadow.radius = 1 + this.lightData.shadowDiffusion / 10, (n instanceof Vs || n instanceof xo) && (n.shadow.camera.near = 1, n.shadow.camera.far = this.lightData.falloffDistance * 2));
  }
  /**
   * Create helper visualization for the editor
   */
  createHelper() {
    switch (this.helper && (this.group.remove(this.helper), this.helper.dispose && this.helper.dispose()), this.lightData.lightType) {
      case "point": {
        const n = new l2(this.light, this.lightData.radius / 10);
        this.helper = n, this.group.add(n);
        break;
      }
      case "spot": {
        const n = new Md(this.light);
        this.helper = n, this.group.add(n);
        break;
      }
      case "parallel": {
        const n = new u2(this.light, 50);
        this.helper = n, this.group.add(n);
        break;
      }
    }
  }
  /**
   * Update light type (requires recreating the light)
   */
  setLightType(n) {
    n !== this.lightData.lightType && (this.lightData.lightType = n, this.group.remove(this.light), this.light.dispose && this.light.dispose(), this.light = this.createLight(), this.group.add(this.light), this.createHelper());
  }
  /**
   * Set light color
   */
  setColor(n) {
    this.lightData.color = n, this.light.color.set(n);
  }
  /**
   * Set light intensity
   */
  setIntensity(n) {
    this.lightData.intensity = n, this.light.intensity = n / 100;
  }
  /**
   * Set falloff distance
   */
  setFalloffDistance(n) {
    this.lightData.falloffDistance = n, (this.light instanceof da || this.light instanceof Vs) && (this.light.distance = this.lightData.falloff === "none" ? 0 : n);
  }
  /**
   * Set cone angle (spot lights only)
   */
  setConeAngle(n) {
    this.light instanceof Vs && (this.lightData.coneAngle = n, this.light.angle = fn.degToRad(n / 2), this.helper instanceof Md && this.helper.update());
  }
  /**
   * Set cone feather (spot lights only)
   */
  setConeFeather(n) {
    this.light instanceof Vs && (this.lightData.coneFeather = n, this.light.penumbra = n / 100);
  }
  /**
   * Toggle shadow casting
   */
  setCastShadows(n) {
    this.lightData.castShadows = n, (this.light instanceof da || this.light instanceof Vs || this.light instanceof xo) && (this.light.castShadow = n);
  }
  /**
   * Get the underlying Three.js light
   */
  getLight() {
    return this.light;
  }
  /**
   * Get light data
   */
  getLightData() {
    return { ...this.lightData };
  }
  /**
   * Show/hide editor helper
   */
  setHelperVisible(n) {
    this.helper && (this.helper.visible = n);
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    if (this.lightData.animatedIntensity) {
      const i = this.evaluator.evaluate(this.lightData.animatedIntensity, n);
      this.light.intensity = i / 100;
    }
    if (this.lightData.animatedConeAngle && this.light instanceof Vs) {
      const i = this.evaluator.evaluate(this.lightData.animatedConeAngle, n);
      this.light.angle = fn.degToRad(i / 2), this.helper instanceof Md && this.helper.update();
    }
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.lightType !== void 0 && i.lightType !== this.lightData.lightType && this.setLightType(i.lightType), i.color !== void 0 && this.setColor(i.color), i.intensity !== void 0 && this.setIntensity(i.intensity), i.falloffDistance !== void 0 && this.setFalloffDistance(i.falloffDistance), i.falloff !== void 0 && (this.lightData.falloff = i.falloff, this.setFalloffDistance(this.lightData.falloffDistance)), i.coneAngle !== void 0 && this.setConeAngle(i.coneAngle), i.coneFeather !== void 0 && this.setConeFeather(i.coneFeather), i.castShadows !== void 0 && this.setCastShadows(i.castShadows), (i.shadowDarkness !== void 0 || i.shadowDiffusion !== void 0) && (this.lightData.shadowDarkness = i.shadowDarkness ?? this.lightData.shadowDarkness, this.lightData.shadowDiffusion = i.shadowDiffusion ?? this.lightData.shadowDiffusion, (this.light instanceof da || this.light instanceof Vs || this.light instanceof xo) && this.configureShadows(this.light)), i.animatedIntensity !== void 0 && (this.lightData.animatedIntensity = i.animatedIntensity), i.animatedConeAngle !== void 0 && (this.lightData.animatedConeAngle = i.animatedConeAngle));
  }
  onDispose() {
    this.light.dispose && this.light.dispose(), this.helper && this.helper.dispose && this.helper.dispose();
  }
}
const hN = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`, fN = `
  uniform sampler2D sourceTexture;
  uniform sampler2D depthTexture;
  uniform float depthScale;
  uniform float focusDepth;
  uniform vec2 offset;
  uniform float zoom;
  uniform float rotation;
  uniform float edgeDilation;
  uniform float time;

  varying vec2 vUv;

  // Rotate UV around center
  vec2 rotateUV(vec2 uv, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    uv -= 0.5;
    uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
    uv += 0.5;
    return uv;
  }

  void main() {
    // Sample depth at current UV
    float depth = texture2D(depthTexture, vUv).r;

    // Calculate displacement based on depth
    // Objects at focusDepth have no displacement
    float depthDiff = depth - focusDepth;
    float displacement = depthDiff * depthScale;

    // Apply zoom (perspective effect - closer objects move more)
    vec2 zoomedUV = (vUv - 0.5) / zoom + 0.5;

    // Apply rotation
    vec2 rotatedUV = rotateUV(zoomedUV, rotation);

    // Apply offset with depth-based parallax
    vec2 parallaxOffset = offset * (1.0 + displacement);
    vec2 finalUV = rotatedUV + parallaxOffset;

    // Edge handling - dilate edges slightly
    vec2 edgeUV = finalUV;
    if (edgeDilation > 0.0) {
      // Simple edge stretch when outside [0,1] range
      if (finalUV.x < 0.0) edgeUV.x = finalUV.x * (1.0 - edgeDilation);
      if (finalUV.x > 1.0) edgeUV.x = 1.0 - (1.0 - finalUV.x) * (1.0 - edgeDilation);
      if (finalUV.y < 0.0) edgeUV.y = finalUV.y * (1.0 - edgeDilation);
      if (finalUV.y > 1.0) edgeUV.y = 1.0 - (1.0 - finalUV.y) * (1.0 - edgeDilation);
    }

    // Clamp to valid range (or could use mirror/repeat)
    finalUV = clamp(edgeUV, 0.0, 1.0);

    // Sample source with displaced UVs
    vec4 color = texture2D(sourceTexture, finalUV);

    // Handle edges - fade out pixels that would be outside the source
    float edgeFade = 1.0;
    float edgeThreshold = 0.01;
    if (edgeUV.x < edgeThreshold || edgeUV.x > 1.0 - edgeThreshold ||
        edgeUV.y < edgeThreshold || edgeUV.y > 1.0 - edgeThreshold) {
      edgeFade = 0.0;
    }

    gl_FragColor = vec4(color.rgb, color.a * edgeFade);
  }
`;
class pN extends $i {
  constructor(n, i) {
    super(n);
    pe(this, "resources");
    // Textures
    pe(this, "sourceTexture", null);
    pe(this, "depthTexture", null);
    // Mesh and material
    pe(this, "mesh");
    pe(this, "geometry");
    pe(this, "material");
    // Layer data
    pe(this, "depthflowData");
    // Dimensions
    pe(this, "width", 1920);
    pe(this, "height", 1080);
    // Animation state
    pe(this, "animationTime", 0);
    this.resources = i, this.depthflowData = this.extractDepthflowData(n), this.geometry = new cn(this.width, this.height), this.material = new Fn({
      uniforms: {
        sourceTexture: { value: null },
        depthTexture: { value: null },
        depthScale: { value: this.depthflowData.config.depthScale },
        focusDepth: { value: this.depthflowData.config.focusDepth },
        offset: { value: new st(0, 0) },
        zoom: { value: this.depthflowData.config.zoom },
        rotation: { value: this.depthflowData.config.rotation },
        edgeDilation: { value: this.depthflowData.config.edgeDilation },
        time: { value: 0 }
      },
      vertexShader: hN,
      fragmentShader: fN,
      transparent: !0,
      side: mn,
      depthWrite: !1
    }), this.mesh = new qe(this.geometry, this.material), this.mesh.name = `depthflow_${this.id}`, this.group.add(this.mesh), this.loadTextures(), this.initializeBlendMode();
  }
  /**
   * Extract depthflow data with defaults
   */
  extractDepthflowData(n) {
    var r, o, a, l, c, u, d, h, m, p, y, _, v, g;
    const i = n.data;
    return {
      sourceLayerId: (i == null ? void 0 : i.sourceLayerId) ?? "",
      depthLayerId: (i == null ? void 0 : i.depthLayerId) ?? "",
      config: {
        preset: ((r = i == null ? void 0 : i.config) == null ? void 0 : r.preset) ?? "static",
        zoom: ((o = i == null ? void 0 : i.config) == null ? void 0 : o.zoom) ?? 1,
        offsetX: ((a = i == null ? void 0 : i.config) == null ? void 0 : a.offsetX) ?? 0,
        offsetY: ((l = i == null ? void 0 : i.config) == null ? void 0 : l.offsetY) ?? 0,
        rotation: ((c = i == null ? void 0 : i.config) == null ? void 0 : c.rotation) ?? 0,
        depthScale: ((u = i == null ? void 0 : i.config) == null ? void 0 : u.depthScale) ?? 0.1,
        focusDepth: ((d = i == null ? void 0 : i.config) == null ? void 0 : d.focusDepth) ?? 0.5,
        dollyZoom: ((h = i == null ? void 0 : i.config) == null ? void 0 : h.dollyZoom) ?? 0,
        orbitRadius: ((m = i == null ? void 0 : i.config) == null ? void 0 : m.orbitRadius) ?? 0.1,
        orbitSpeed: ((p = i == null ? void 0 : i.config) == null ? void 0 : p.orbitSpeed) ?? 1,
        swingAmplitude: ((y = i == null ? void 0 : i.config) == null ? void 0 : y.swingAmplitude) ?? 0.05,
        swingFrequency: ((_ = i == null ? void 0 : i.config) == null ? void 0 : _.swingFrequency) ?? 1,
        edgeDilation: ((v = i == null ? void 0 : i.config) == null ? void 0 : v.edgeDilation) ?? 0,
        inpaintEdges: ((g = i == null ? void 0 : i.config) == null ? void 0 : g.inpaintEdges) ?? !1
      },
      animatedZoom: i == null ? void 0 : i.animatedZoom,
      animatedOffsetX: i == null ? void 0 : i.animatedOffsetX,
      animatedOffsetY: i == null ? void 0 : i.animatedOffsetY,
      animatedRotation: i == null ? void 0 : i.animatedRotation,
      animatedDepthScale: i == null ? void 0 : i.animatedDepthScale
    };
  }
  /**
   * Load source and depth textures from referenced layers
   */
  async loadTextures() {
    if (this.depthflowData.sourceLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.sourceLayerId);
      n && (this.sourceTexture = n, this.material.uniforms.sourceTexture.value = n, n.image && this.setDimensions(n.image.width, n.image.height));
    }
    if (this.depthflowData.depthLayerId) {
      const n = await this.loadTextureFromLayer(this.depthflowData.depthLayerId);
      n && (this.depthTexture = n, this.material.uniforms.depthTexture.value = n);
    }
  }
  /**
   * Load texture from a layer (image layer asset)
   */
  async loadTextureFromLayer(n) {
    const i = this.resources.getLayerTexture(n);
    return i || (console.warn(`[DepthflowLayer] Could not load texture for layer ${n}`), null);
  }
  /**
   * Set mesh dimensions
   */
  setDimensions(n, i) {
    n === this.width && i === this.height || (this.width = n, this.height = i, this.geometry.dispose(), this.geometry = new cn(n, i), this.mesh.geometry = this.geometry);
  }
  /**
   * Set source layer
   */
  async setSourceLayer(n) {
    var r;
    this.depthflowData.sourceLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((r = this.sourceTexture) == null || r.dispose(), this.sourceTexture = i, this.material.uniforms.sourceTexture.value = i);
  }
  /**
   * Set depth layer
   */
  async setDepthLayer(n) {
    var r;
    this.depthflowData.depthLayerId = n;
    const i = await this.loadTextureFromLayer(n);
    i && ((r = this.depthTexture) == null || r.dispose(), this.depthTexture = i, this.material.uniforms.depthTexture.value = i);
  }
  /**
   * Update config values
   */
  updateConfig(n) {
    Object.assign(this.depthflowData.config, n), n.depthScale !== void 0 && (this.material.uniforms.depthScale.value = n.depthScale), n.focusDepth !== void 0 && (this.material.uniforms.focusDepth.value = n.focusDepth), n.zoom !== void 0 && (this.material.uniforms.zoom.value = n.zoom), n.rotation !== void 0 && (this.material.uniforms.rotation.value = fn.degToRad(n.rotation)), n.edgeDilation !== void 0 && (this.material.uniforms.edgeDilation.value = n.edgeDilation);
  }
  /**
   * Calculate preset-based animation values
   */
  calculatePresetValues(n, i = 30) {
    const r = this.depthflowData.config, o = this.outPoint - this.inPoint, a = o > 0 ? (n - this.inPoint) / o : 0, l = n / i;
    let c = r.zoom, u = r.offsetX, d = r.offsetY, h = r.rotation;
    switch (r.preset) {
      case "static":
        break;
      case "zoom_in":
        c = 1 + a * 0.5;
        break;
      case "zoom_out":
        c = 1.5 - a * 0.5;
        break;
      case "dolly_zoom_in":
        c = 1 + a * 0.5, this.material.uniforms.depthScale.value = r.depthScale * (1 + r.dollyZoom * a);
        break;
      case "dolly_zoom_out":
        c = 1.5 - a * 0.5, this.material.uniforms.depthScale.value = r.depthScale * (1 + r.dollyZoom * (1 - a));
        break;
      case "pan_left":
        u = a * 0.2;
        break;
      case "pan_right":
        u = -a * 0.2;
        break;
      case "pan_up":
        d = a * 0.2;
        break;
      case "pan_down":
        d = -a * 0.2;
        break;
      case "circle_cw":
        u = Math.sin(a * Math.PI * 2) * r.orbitRadius, d = Math.cos(a * Math.PI * 2) * r.orbitRadius;
        break;
      case "circle_ccw":
        u = -Math.sin(a * Math.PI * 2) * r.orbitRadius, d = Math.cos(a * Math.PI * 2) * r.orbitRadius;
        break;
      case "horizontal_swing":
        u = Math.sin(l * r.swingFrequency * Math.PI * 2) * r.swingAmplitude;
        break;
      case "vertical_swing":
        d = Math.sin(l * r.swingFrequency * Math.PI * 2) * r.swingAmplitude;
        break;
    }
    return { zoom: c, offsetX: u, offsetY: d, rotation: h };
  }
  // ============================================================================
  // ABSTRACT IMPLEMENTATIONS
  // ============================================================================
  onEvaluateFrame(n) {
    this.depthflowData.config;
    const i = this.calculatePresetValues(n);
    let r = i.zoom, o = i.offsetX, a = i.offsetY, l = i.rotation;
    this.depthflowData.animatedZoom && (r = this.evaluator.evaluate(this.depthflowData.animatedZoom, n)), this.depthflowData.animatedOffsetX && (o = this.evaluator.evaluate(this.depthflowData.animatedOffsetX, n)), this.depthflowData.animatedOffsetY && (a = this.evaluator.evaluate(this.depthflowData.animatedOffsetY, n)), this.depthflowData.animatedRotation && (l = this.evaluator.evaluate(this.depthflowData.animatedRotation, n)), this.depthflowData.animatedDepthScale && (this.material.uniforms.depthScale.value = this.evaluator.evaluate(
      this.depthflowData.animatedDepthScale,
      n
    )), r = this.getDrivenOrBase("depthflow.zoom", r), o = this.getDrivenOrBase("depthflow.offsetX", o), a = this.getDrivenOrBase("depthflow.offsetY", a), l = this.getDrivenOrBase("depthflow.rotation", l), this.material.uniforms.zoom.value = r, this.material.uniforms.offset.value.set(o, a), this.material.uniforms.rotation.value = fn.degToRad(l), this.material.uniforms.time.value = n / 30, this.material.needsUpdate = !0;
  }
  onUpdate(n) {
    const i = n.data;
    i && (i.sourceLayerId !== void 0 && i.sourceLayerId !== this.depthflowData.sourceLayerId && this.setSourceLayer(i.sourceLayerId), i.depthLayerId !== void 0 && i.depthLayerId !== this.depthflowData.depthLayerId && this.setDepthLayer(i.depthLayerId), i.config && this.updateConfig(i.config), i.animatedZoom !== void 0 && (this.depthflowData.animatedZoom = i.animatedZoom), i.animatedOffsetX !== void 0 && (this.depthflowData.animatedOffsetX = i.animatedOffsetX), i.animatedOffsetY !== void 0 && (this.depthflowData.animatedOffsetY = i.animatedOffsetY), i.animatedRotation !== void 0 && (this.depthflowData.animatedRotation = i.animatedRotation), i.animatedDepthScale !== void 0 && (this.depthflowData.animatedDepthScale = i.animatedDepthScale));
  }
  onDispose() {
    var n, i;
    (n = this.sourceTexture) == null || n.dispose(), (i = this.depthTexture) == null || i.dispose(), this.geometry.dispose(), this.material.dispose();
  }
}
class mN {
  constructor(e, n) {
    pe(this, "scene");
    pe(this, "resources");
    pe(this, "layers");
    // Callbacks
    pe(this, "onVideoMetadataLoaded");
    pe(this, "precompRenderContext", null);
    pe(this, "cameraGetter");
    pe(this, "cameraAtFrameGetter");
    pe(this, "cameraUpdater");
    // Renderer reference for particle systems
    pe(this, "rendererRef", null);
    // Composition FPS for particle timing
    pe(this, "compositionFPS", 60);
    // Camera reference for particles
    pe(this, "cameraRef", null);
    // Audio reactive callback
    pe(this, "audioReactiveGetter", null);
    this.scene = e, this.resources = n, this.layers = /* @__PURE__ */ new Map();
  }
  // ============================================================================
  // CALLBACKS
  // ============================================================================
  /**
   * Set callback for when a video layer loads its metadata
   * Used by the store to auto-resize composition based on video duration
   */
  setVideoMetadataCallback(e) {
    this.onVideoMetadataLoaded = e;
  }
  /**
   * Set the precomp render context
   * This allows precomp layers to render nested compositions
   */
  setPrecompRenderContext(e) {
    this.precompRenderContext = e;
    for (const n of this.layers.values())
      n.type === "precomp" && n.setRenderContext(e);
  }
  /**
   * Set camera callbacks for CameraLayer access to store
   */
  setCameraCallbacks(e, n, i) {
    this.cameraGetter = e, this.cameraUpdater = n, this.cameraAtFrameGetter = i;
    for (const r of this.layers.values())
      r.type === "camera" && r.setCameraCallbacks(e, n, i);
  }
  /**
   * Set renderer for particle layers
   * Must be called to enable GPU particle rendering
   */
  setRenderer(e) {
    this.rendererRef = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setRenderer(e);
  }
  /**
   * Set composition FPS for timing calculations
   */
  setCompositionFPS(e) {
    this.compositionFPS = e;
    for (const n of this.layers.values())
      n.type === "particles" && n.setFPS(e), n.type === "video" && n.setFPS(e), n.type === "precomp" && n.setFPS(e);
  }
  /**
   * Set camera reference for particle systems
   * Used for camera-relative effects (soft particles, depth culling)
   */
  setCamera(e) {
    this.cameraRef = e;
  }
  /**
   * Get camera reference
   */
  getCamera() {
    return this.cameraRef;
  }
  // ============================================================================
  // LAYER CREATION
  // ============================================================================
  /**
   * Create a new layer from layer data
   */
  create(e) {
    if (this.layers.has(e.id))
      return console.warn(`[LayerManager] Layer ${e.id} already exists, updating instead`), this.update(e.id, e), this.layers.get(e.id);
    const n = this.createLayerInstance(e);
    if (this.layers.set(e.id, n), this.setupLayerCallbacks(n, e), e.parentId) {
      const i = this.layers.get(e.parentId);
      i && n.setParent(i);
    }
    return n.hasParent() || this.scene.addToComposition(n.getObject()), n;
  }
  /**
   * Set up type-specific callbacks after layer creation
   */
  setupLayerCallbacks(e, n) {
    if (e.type === "video" && this.onVideoMetadataLoaded && e.setMetadataCallback((r) => {
      this.onVideoMetadataLoaded(n.id, r);
    }), e.type === "precomp" && this.precompRenderContext && e.setRenderContext(this.precompRenderContext), e.type === "camera" && this.cameraGetter && this.cameraUpdater && e.setCameraCallbacks(this.cameraGetter, this.cameraUpdater, this.cameraAtFrameGetter), e.type === "particles") {
      const i = e;
      this.rendererRef && i.setRenderer(this.rendererRef), i.setFPS(this.compositionFPS);
    }
    e.type === "video" && e.setFPS(this.compositionFPS), e.type === "precomp" && e.setFPS(this.compositionFPS);
  }
  /**
   * Create the appropriate layer instance based on type
   */
  createLayerInstance(e) {
    switch (e.type) {
      case "image":
        return new r6(e, this.resources);
      case "solid":
        return new o6(e);
      case "null":
        return new Sv(e);
      case "text":
        return new sN(e, this.resources);
      case "spline":
        return new rN(e);
      case "particles":
        return new lN(e);
      case "video":
        return new C2(e, this.resources);
      case "precomp":
        return new cN(e);
      case "camera":
        return new uN(e);
      case "light":
        return new dN(e);
      case "depthflow":
        return new pN(e, this.resources);
      default:
        return console.warn(`[LayerManager] Unknown layer type: ${e.type}, creating NullLayer`), new Sv(e);
    }
  }
  // ============================================================================
  // LAYER UPDATES
  // ============================================================================
  /**
   * Update a layer's properties
   */
  update(e, n) {
    const i = this.layers.get(e);
    if (!i) {
      console.warn(`[LayerManager] Layer ${e} not found for update`);
      return;
    }
    i.update(n);
  }
  /**
   * Batch update multiple layers
   */
  batchUpdate(e) {
    for (const { id: n, properties: i } of e)
      this.update(n, i);
  }
  // ============================================================================
  // LAYER REMOVAL
  // ============================================================================
  /**
   * Remove a layer by ID
   */
  remove(e) {
    const n = this.layers.get(e);
    if (!n) {
      console.warn(`[LayerManager] Layer ${e} not found for removal`);
      return;
    }
    this.scene.removeFromComposition(n.getObject()), n.dispose(), this.layers.delete(e);
  }
  /**
   * Remove multiple layers
   */
  removeMultiple(e) {
    for (const n of e)
      this.remove(n);
  }
  /**
   * Remove all layers
   */
  removeAll() {
    for (const [e, n] of this.layers)
      this.scene.removeFromComposition(n.getObject()), n.dispose();
    this.layers.clear();
  }
  // ============================================================================
  // FRAME EVALUATION
  // ============================================================================
  /**
   * Evaluate all layers at a given frame
   * @param frame - The frame number
   * @param audioReactiveGetter - Optional callback to get audio reactive values
   */
  evaluateFrame(e, n) {
    this.updateTextPathConnections();
    const i = n ?? this.audioReactiveGetter;
    for (const r of this.layers.values()) {
      if (i) {
        const o = i(r.id, e);
        o.size > 0 && r.setAudioReactiveValues(o);
      }
      r.evaluateFrame(e);
    }
    this.scene.sortByZ();
  }
  /**
   * Set the audio reactive getter callback
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e;
  }
  /**
   * Set driven values for a specific layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    const i = this.layers.get(e);
    i && i.setDrivenValues(n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    const n = this.layers.get(e);
    n && n.clearDrivenValues();
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    for (const e of this.layers.values())
      e.clearDrivenValues();
  }
  /**
   * Update text layer connections to spline paths
   * Called before frame evaluation to ensure paths are current
   */
  updateTextPathConnections() {
    for (const e of this.layers.values())
      if (e.type === "text") {
        const n = e, i = n.getTextData();
        if (i.pathLayerId) {
          const r = this.layers.get(i.pathLayerId);
          if (r && r.type === "spline") {
            const o = r.getCurve();
            o && n.setPathFromCurve(o);
          }
        }
      }
  }
  /**
   * Connect a text layer to a spline path
   */
  connectTextToPath(e, n) {
    const i = this.layers.get(e);
    if (!i || i.type !== "text") {
      console.warn(`[LayerManager] Text layer ${e} not found`);
      return;
    }
    if (!n) {
      i.clearPath();
      return;
    }
    const r = this.layers.get(n);
    if (!r || r.type !== "spline") {
      console.warn(`[LayerManager] Spline layer ${n} not found`);
      return;
    }
    const o = r.getCurve();
    o && i.setPathFromCurve(o);
  }
  // ============================================================================
  // LAYER ACCESS
  // ============================================================================
  /**
   * Get a layer's Three.js object
   */
  getObject(e) {
    var n;
    return ((n = this.layers.get(e)) == null ? void 0 : n.getObject()) ?? null;
  }
  /**
   * Get a layer instance
   */
  getLayer(e) {
    return this.layers.get(e) ?? null;
  }
  /**
   * Get all layer IDs
   */
  getLayerIds() {
    return Array.from(this.layers.keys());
  }
  /**
   * Get all layers of a specific type
   */
  getLayersByType(e) {
    return Array.from(this.layers.values()).filter(
      (n) => n.type === e
    );
  }
  /**
   * Check if a layer exists
   */
  hasLayer(e) {
    return this.layers.has(e);
  }
  /**
   * Get layer count
   */
  getLayerCount() {
    return this.layers.size;
  }
  // ============================================================================
  // LAYER ORDERING
  // ============================================================================
  /**
   * Reorder layers in the scene based on their Z positions
   */
  reorderLayers() {
    this.scene.sortByZ();
  }
  // ============================================================================
  // PARENTING
  // ============================================================================
  /**
   * Rebuild the parenting hierarchy for all layers
   * Call this after batch-adding layers to ensure proper parent-child relationships
   */
  rebuildParentHierarchy() {
    for (const e of this.layers.values())
      if (e.hasParent()) {
        const n = e.getParent();
        n && n.getObject().remove(e.getObject());
      }
    for (const e of this.layers.values()) {
      const n = e.getParentId();
      if (n) {
        const i = this.layers.get(n);
        i ? e.setParent(i) : (e.setParent(null), this.scene.addToComposition(e.getObject()));
      }
    }
  }
  /**
   * Set parent for a layer
   */
  setLayerParent(e, n) {
    const i = this.layers.get(e);
    if (i) {
      if (i.hasParent()) {
        const r = i.getParent();
        r && r.getObject().remove(i.getObject());
      } else
        this.scene.removeFromComposition(i.getObject());
      if (n) {
        const r = this.layers.get(n);
        r ? i.setParent(r) : (i.setParent(null), this.scene.addToComposition(i.getObject()));
      } else
        i.setParent(null), this.scene.addToComposition(i.getObject());
    }
  }
  /**
   * Move a layer to a specific Z position
   */
  setLayerZ(e, n) {
    const i = this.layers.get(e);
    i && (i.getObject().position.z = n, this.scene.sortByZ());
  }
  // ============================================================================
  // VISIBILITY
  // ============================================================================
  /**
   * Set layer visibility
   */
  setLayerVisible(e, n) {
    const i = this.layers.get(e);
    i && i.setVisible(n);
  }
  /**
   * Toggle layer visibility
   */
  toggleLayerVisible(e) {
    const n = this.layers.get(e);
    if (n) {
      const i = !n.getObject().visible;
      return n.setVisible(i), i;
    }
    return !1;
  }
  /**
   * Solo a layer (hide all others)
   */
  soloLayer(e) {
    for (const [n, i] of this.layers)
      i.setVisible(n === e);
  }
  /**
   * Unsolo all layers (show all)
   */
  unsoloAll() {
    for (const e of this.layers.values())
      e.setVisible(!0);
  }
  // ============================================================================
  // SELECTION
  // ============================================================================
  /**
   * Get layers at a screen position
   */
  getLayersAtPosition(e, n, i) {
    const r = new Of(), o = new st(e, n);
    r.setFromCamera(o, i);
    const a = this.scene.raycastComposition(r), l = /* @__PURE__ */ new Set();
    for (const c of a) {
      let u = c.object;
      for (; u; ) {
        if (u.userData.layerId) {
          l.add(u.userData.layerId);
          break;
        }
        u = u.parent;
      }
    }
    return Array.from(l).map((c) => this.layers.get(c)).filter((c) => c !== void 0);
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all layers and resources
   */
  dispose() {
    for (const e of this.layers.values())
      this.scene.removeFromComposition(e.getObject()), e.dispose();
    this.layers.clear();
  }
}
class vN {
  constructor(e, n) {
    /** The main camera */
    pe(this, "camera");
    /** Keyframe evaluator for animations */
    pe(this, "evaluator");
    /** Composition dimensions */
    pe(this, "width");
    pe(this, "height");
    /** Animation properties */
    pe(this, "positionProp");
    pe(this, "targetProp");
    pe(this, "fovProp");
    /** Current target position (for lookAt) */
    pe(this, "target");
    // ============================================================================
    // VIEWPORT ZOOM/PAN
    // ============================================================================
    /** Pan offset for viewport navigation */
    pe(this, "panOffset", new st(0, 0));
    pe(this, "zoomLevel", 1);
    this.width = e, this.height = n, this.evaluator = new vl(), this.camera = new ci(
      50,
      // Field of view
      e / n,
      // Aspect ratio
      0.1,
      // Near plane
      1e4
      // Far plane
    );
    const i = fn.degToRad(this.camera.fov), r = n / 2 / Math.tan(i / 2);
    this.camera.position.set(e / 2, -n / 2, r), this.target = new ce(e / 2, -n / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // POSITION & ORIENTATION
  // ============================================================================
  /**
   * Set camera position
   * Note: Y is negated for screen coordinates (Y down)
   */
  setPosition(e, n, i) {
    this.camera.position.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera position (in screen coordinates)
   */
  getPosition() {
    return {
      x: this.camera.position.x,
      y: -this.camera.position.y,
      // Convert back to screen coords
      z: this.camera.position.z
    };
  }
  /**
   * Set camera target (look-at point)
   * Note: Y is negated for screen coordinates
   */
  setTarget(e, n, i) {
    this.target.set(e, -n, i), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  /**
   * Get camera target (in screen coordinates)
   */
  getTarget() {
    return {
      x: this.target.x,
      y: -this.target.y,
      z: this.target.z
    };
  }
  /**
   * Set camera rotation directly (Euler angles in degrees)
   */
  setRotation(e, n, i) {
    this.camera.rotation.set(
      fn.degToRad(e),
      fn.degToRad(n),
      fn.degToRad(i)
    ), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // PROJECTION
  // ============================================================================
  /**
   * Set field of view (in degrees)
   */
  setFOV(e) {
    this.camera.fov = fn.clamp(e, 1, 179), this.camera.updateProjectionMatrix();
  }
  /**
   * Get field of view
   */
  getFOV() {
    return this.camera.fov;
  }
  /**
   * Set near and far planes
   */
  setClipPlanes(e, n) {
    this.camera.near = Math.max(1e-3, e), this.camera.far = Math.max(this.camera.near + 1, n), this.camera.updateProjectionMatrix();
  }
  /**
   * Set zoom level for viewport navigation
   * This adjusts the camera's effective view without changing FOV
   */
  setZoom(e) {
    this.zoomLevel = Math.max(0.1, Math.min(10, e)), this.updateCameraForViewport();
  }
  /**
   * Get current zoom level
   */
  getZoom() {
    return this.zoomLevel;
  }
  /**
   * Set pan offset for viewport navigation
   */
  setPan(e, n) {
    this.panOffset.set(e, n), this.updateCameraForViewport();
  }
  /**
   * Get current pan offset
   */
  getPan() {
    return { x: this.panOffset.x, y: this.panOffset.y };
  }
  /**
   * Update camera position based on zoom and pan
   */
  updateCameraForViewport() {
    const e = fn.degToRad(this.camera.fov), i = this.height / 2 / Math.tan(e / 2) / this.zoomLevel, r = this.width / 2 - this.panOffset.x / this.zoomLevel, o = this.height / 2 - this.panOffset.y / this.zoomLevel;
    this.camera.position.set(r, -o, i), this.target.set(r, -o, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ANIMATION
  // ============================================================================
  /**
   * Set animated properties for keyframe evaluation
   */
  setAnimationProperties(e) {
    this.positionProp = e.position, this.targetProp = e.target, this.fovProp = e.fov;
  }
  /**
   * Clear animation properties
   */
  clearAnimationProperties() {
    this.positionProp = void 0, this.targetProp = void 0, this.fovProp = void 0;
  }
  /**
   * Evaluate animated properties at a given frame
   */
  evaluateFrame(e) {
    if (this.positionProp) {
      const n = this.evaluator.evaluate(this.positionProp, e);
      this.setPosition(n.x, n.y, n.z ?? this.camera.position.z);
    }
    if (this.targetProp) {
      const n = this.evaluator.evaluate(this.targetProp, e);
      this.setTarget(n.x, n.y, n.z ?? 0);
    }
    if (this.fovProp) {
      const n = this.evaluator.evaluate(this.fovProp, e);
      this.setFOV(n);
    }
  }
  // ============================================================================
  // RESIZE
  // ============================================================================
  /**
   * Resize camera for new viewport dimensions
   */
  resize(e, n) {
    this.width = e, this.height = n, this.camera.aspect = e / n, this.camera.updateProjectionMatrix();
    const i = fn.degToRad(this.camera.fov), r = n / 2 / Math.tan(i / 2);
    this.camera.position.x = e / 2, this.camera.position.y = -n / 2, this.camera.position.z = r, this.target.set(e / 2, -n / 2, 0), this.camera.lookAt(this.target);
  }
  // ============================================================================
  // COORDINATE CONVERSION
  // ============================================================================
  /**
   * Convert screen coordinates to world position at a given Z depth
   */
  screenToWorld(e, n, i = 0) {
    const r = e / this.width * 2 - 1, o = -(n / this.height) * 2 + 1, a = new ce(r, o, 0.5);
    a.unproject(this.camera);
    const l = a.sub(this.camera.position).normalize(), c = (i - this.camera.position.z) / l.z;
    return this.camera.position.clone().add(l.multiplyScalar(c));
  }
  /**
   * Convert world position to screen coordinates
   */
  worldToScreen(e, n, i = 0) {
    const r = new ce(e, -n, i);
    return r.project(this.camera), {
      x: (r.x + 1) / 2 * this.width,
      y: (-r.y + 1) / 2 * this.height
    };
  }
  // ============================================================================
  // STATE
  // ============================================================================
  /**
   * Get the Three.js camera object directly
   */
  getCamera() {
    return this.camera;
  }
  /**
   * Get complete camera state
   */
  getState() {
    return {
      position: this.getPosition(),
      target: this.getTarget(),
      fov: this.camera.fov,
      near: this.camera.near,
      far: this.camera.far
    };
  }
  /**
   * Set complete camera state
   */
  setState(e) {
    e.position && this.setPosition(e.position.x, e.position.y, e.position.z), e.target && this.setTarget(e.target.x, e.target.y, e.target.z), e.fov !== void 0 && this.setFOV(e.fov), (e.near !== void 0 || e.far !== void 0) && this.setClipPlanes(
      e.near ?? this.camera.near,
      e.far ?? this.camera.far
    );
  }
  /**
   * Reset camera to default position for current composition size
   */
  reset() {
    const e = fn.degToRad(50), n = this.height / 2 / Math.tan(e / 2);
    this.camera.fov = 50, this.camera.position.set(this.width / 2, -this.height / 2, n), this.target.set(this.width / 2, -this.height / 2, 0), this.camera.lookAt(this.target), this.camera.updateProjectionMatrix();
  }
  // ============================================================================
  // ORTHOGRAPHIC
  // ============================================================================
  /**
   * Create an orthographic camera for 2D rendering
   */
  createOrthographic() {
    const e = new mu(
      0,
      // Left
      this.width,
      // Right
      0,
      // Top (in screen coords)
      -this.height,
      // Bottom
      0.1,
      // Near
      1e4
      // Far
    );
    return e.position.set(0, 0, 1e3), e.lookAt(0, 0, 0), e;
  }
}
class gN {
  constructor() {
    // Texture cache (keyed by URL or ID)
    pe(this, "textures");
    // Geometry cache (keyed by type and parameters)
    pe(this, "geometries");
    // Material cache (keyed by configuration hash)
    pe(this, "materials");
    // Texture loader
    pe(this, "textureLoader");
    // Asset getter callback (set by WeylEngine)
    pe(this, "assetGetter");
    // Statistics
    pe(this, "stats", {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    });
    this.textures = /* @__PURE__ */ new Map(), this.geometries = /* @__PURE__ */ new Map(), this.materials = /* @__PURE__ */ new Map(), this.textureLoader = new i2(), this.initializeCommonGeometries();
  }
  // ============================================================================
  // ASSET ACCESS
  // ============================================================================
  /**
   * Set the asset getter callback
   * Called by WeylEngine to provide access to project assets
   */
  setAssetGetter(e) {
    this.assetGetter = e;
  }
  /**
   * Get an asset reference by ID
   * Returns undefined if asset not found or getter not set
   */
  getAsset(e) {
    var n;
    return (n = this.assetGetter) == null ? void 0 : n.call(this, e);
  }
  // ============================================================================
  // INITIALIZATION
  // ============================================================================
  /**
   * Pre-create commonly used geometries
   */
  initializeCommonGeometries() {
    const e = new cn(1, 1, 1, 1);
    this.geometries.set("plane:1:1", e);
    const n = new cn(2, 2, 1, 1);
    this.geometries.set("quad:fullscreen", n);
  }
  // ============================================================================
  // TEXTURE MANAGEMENT
  // ============================================================================
  /**
   * Load a texture from URL
   */
  async loadTexture(e, n) {
    const i = this.getTextureCacheKey(e, n), r = this.textures.get(i);
    return r ? (this.stats.texturesFromCache++, r) : new Promise((o, a) => {
      this.textureLoader.load(
        e,
        (l) => {
          this.applyTextureOptions(l, n), this.textures.set(i, l), this.stats.texturesLoaded++, o(l);
        },
        void 0,
        // Progress callback
        (l) => {
          console.error("[ResourceManager] Failed to load texture:", e, l), a(l);
        }
      );
    });
  }
  /**
   * Create texture from ImageData
   */
  createTextureFromImageData(e, n, i) {
    const r = this.textures.get(n);
    if (r instanceof Oa)
      return r.image = e, r.needsUpdate = !0, r;
    const o = new Oa(
      e.data,
      e.width,
      e.height,
      $n,
      is
    );
    return this.applyTextureOptions(o, i), o.needsUpdate = !0, this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Create texture from canvas
   */
  createTextureFromCanvas(e, n, i) {
    const r = this.textures.get(n);
    if (r instanceof Vm)
      return r.needsUpdate = !0, r;
    const o = new Vm(e);
    return this.applyTextureOptions(o, i), this.textures.set(n, o), this.stats.texturesLoaded++, o;
  }
  /**
   * Get a cached texture
   */
  getTexture(e) {
    return this.textures.get(e);
  }
  /**
   * Apply options to a texture
   */
  applyTextureOptions(e, n) {
    if (!n) {
      e.minFilter = Xt, e.magFilter = Xt, e.generateMipmaps = !1, e.colorSpace = pn;
      return;
    }
    n.wrapS !== void 0 && (e.wrapS = n.wrapS), n.wrapT !== void 0 && (e.wrapT = n.wrapT), n.minFilter !== void 0 && (e.minFilter = n.minFilter), n.magFilter !== void 0 && (e.magFilter = n.magFilter), n.generateMipmaps !== void 0 && (e.generateMipmaps = n.generateMipmaps), n.flipY !== void 0 && (e.flipY = n.flipY), n.colorSpace !== void 0 && (e.colorSpace = n.colorSpace);
  }
  /**
   * Generate cache key for texture
   */
  getTextureCacheKey(e, n) {
    return n ? `${e}:${JSON.stringify(n)}` : e;
  }
  /**
   * Release a texture
   */
  releaseTexture(e) {
    const n = this.textures.get(e);
    n && (n.dispose(), this.textures.delete(e));
  }
  /**
   * Get texture for a layer by its ID
   * Looks up the layer's asset and returns its texture if cached
   */
  getLayerTexture(e) {
    const n = `layer:${e}`, i = this.textures.get(n);
    return i || null;
  }
  /**
   * Cache a texture for a layer
   */
  setLayerTexture(e, n) {
    const i = `layer:${e}`;
    this.textures.set(i, n);
  }
  // ============================================================================
  // GEOMETRY MANAGEMENT
  // ============================================================================
  /**
   * Get a plane geometry (cached)
   */
  getPlaneGeometry(e = 1, n = 1) {
    const i = `plane:${e}:${n}`;
    let r = this.geometries.get(i);
    return r ? (this.stats.geometriesFromCache++, r) : (r = new cn(e, n, 1, 1), this.geometries.set(i, r), this.stats.geometriesCreated++, r);
  }
  /**
   * Get a circle geometry (cached)
   */
  getCircleGeometry(e = 1, n = 32) {
    const i = `circle:${e}:${n}`;
    let r = this.geometries.get(i);
    return r ? (this.stats.geometriesFromCache++, r) : (r = new gu(e, n), this.geometries.set(i, r), this.stats.geometriesCreated++, r);
  }
  /**
   * Get a box geometry (cached)
   */
  getBoxGeometry(e = 1, n = 1, i = 1) {
    const r = `box:${e}:${n}:${i}`;
    let o = this.geometries.get(r);
    return o ? (this.stats.geometriesFromCache++, o) : (o = new hn(e, n, i), this.geometries.set(r, o), this.stats.geometriesCreated++, o);
  }
  /**
   * Get the fullscreen quad geometry
   */
  getFullscreenQuad() {
    return this.geometries.get("quad:fullscreen");
  }
  // ============================================================================
  // MATERIAL MANAGEMENT
  // ============================================================================
  /**
   * Get or create a basic material
   */
  getBasicMaterial(e) {
    const n = `basic:${JSON.stringify(e)}`;
    let i = this.materials.get(n);
    return i || (i = new Mn({
      color: e.color ?? 16777215,
      transparent: e.transparent ?? !0,
      opacity: e.opacity ?? 1,
      map: e.map,
      side: e.side ?? mn
    }), this.materials.set(n, i), i);
  }
  /**
   * Create a non-cached material (for layers with unique properties)
   */
  createMaterial(e) {
    switch (e) {
      case "basic":
        return new Mn({
          transparent: !0,
          side: mn
        });
      case "standard":
        return new JE({
          transparent: !0,
          side: mn
        });
      case "shader":
        return new Fn();
      default:
        return new Mn();
    }
  }
  // ============================================================================
  // STATISTICS
  // ============================================================================
  /**
   * Get resource statistics
   */
  getStats() {
    return {
      textureCount: this.textures.size,
      geometryCount: this.geometries.size,
      materialCount: this.materials.size,
      ...this.stats
    };
  }
  /**
   * Reset statistics
   */
  resetStats() {
    this.stats = {
      texturesLoaded: 0,
      texturesFromCache: 0,
      geometriesCreated: 0,
      geometriesFromCache: 0
    };
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all cached resources
   */
  dispose() {
    for (const e of this.textures.values())
      e.dispose();
    this.textures.clear();
    for (const e of this.geometries.values())
      e.dispose();
    this.geometries.clear();
    for (const e of this.materials.values())
      e.dispose();
    this.materials.clear();
  }
  /**
   * Clear unused resources (call periodically)
   */
  clearUnused() {
    console.log("[ResourceManager] Resource stats:", this.getStats());
  }
}
class yN {
  constructor() {
    // Frame timing
    pe(this, "frameCount", 0);
    pe(this, "lastTime", 0);
    pe(this, "frameTimes", []);
    pe(this, "maxFrameTimes", 60);
    // FPS calculation
    pe(this, "fps", 0);
    pe(this, "fpsUpdateInterval", 500);
    // ms
    pe(this, "lastFpsUpdate", 0);
    pe(this, "framesInInterval", 0);
    // Frame start time (for measuring frame duration)
    pe(this, "frameStartTime", 0);
    // Last captured stats
    pe(this, "lastStats", {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    });
    this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime;
  }
  /**
   * Call at the beginning of each frame
   */
  beginFrame() {
    this.frameStartTime = performance.now();
  }
  /**
   * Call at the end of each frame
   */
  endFrame(e) {
    const n = performance.now(), i = n - this.frameStartTime;
    this.frameTimes.push(i), this.frameTimes.length > this.maxFrameTimes && this.frameTimes.shift(), this.frameCount++, this.framesInInterval++;
    const r = n - this.lastFpsUpdate;
    r >= this.fpsUpdateInterval && (this.fps = Math.round(this.framesInInterval * 1e3 / r), this.framesInInterval = 0, this.lastFpsUpdate = n);
    const o = e.info, a = performance.memory, l = (a == null ? void 0 : a.usedJSHeapSize) ?? 0, c = this.frameTimes.length > 0 ? this.frameTimes.reduce((u, d) => u + d, 0) / this.frameTimes.length : 0;
    return this.lastStats = {
      fps: this.fps,
      frameTime: Math.round(c * 100) / 100,
      drawCalls: o.render.calls,
      triangles: o.render.triangles,
      textures: o.memory.textures,
      geometries: o.memory.geometries,
      memoryUsed: l
    }, this.lastTime = n, this.lastStats;
  }
  /**
   * Get the last captured stats
   */
  getStats() {
    return { ...this.lastStats };
  }
  /**
   * Get current FPS
   */
  getFPS() {
    return this.fps;
  }
  /**
   * Get average frame time in ms
   */
  getAverageFrameTime() {
    return this.frameTimes.length === 0 ? 0 : this.frameTimes.reduce((e, n) => e + n, 0) / this.frameTimes.length;
  }
  /**
   * Get min/max frame times
   */
  getFrameTimeRange() {
    return this.frameTimes.length === 0 ? { min: 0, max: 0 } : {
      min: Math.min(...this.frameTimes),
      max: Math.max(...this.frameTimes)
    };
  }
  /**
   * Get frame time history
   */
  getFrameTimeHistory() {
    return [...this.frameTimes];
  }
  /**
   * Get total frame count
   */
  getFrameCount() {
    return this.frameCount;
  }
  /**
   * Reset all statistics
   */
  reset() {
    this.frameCount = 0, this.frameTimes = [], this.fps = 0, this.framesInInterval = 0, this.lastTime = performance.now(), this.lastFpsUpdate = this.lastTime, this.lastStats = {
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    };
  }
  /**
   * Check if performance is degraded
   */
  isPerformanceDegraded(e = 30) {
    return this.fps > 0 && this.fps < e;
  }
  /**
   * Get performance report as string
   */
  getReport() {
    const e = this.lastStats, n = this.getFrameTimeRange();
    return [
      `FPS: ${e.fps}`,
      `Frame Time: ${e.frameTime.toFixed(2)}ms (min: ${n.min.toFixed(2)}, max: ${n.max.toFixed(2)})`,
      `Draw Calls: ${e.drawCalls}`,
      `Triangles: ${e.triangles.toLocaleString()}`,
      `Textures: ${e.textures}`,
      `Geometries: ${e.geometries}`,
      `Memory: ${(e.memoryUsed / 1024 / 1024).toFixed(2)} MB`
    ].join(`
`);
  }
}
class _N {
  constructor(e) {
    // Core subsystems
    pe(this, "scene");
    pe(this, "renderer");
    pe(this, "layers");
    pe(this, "camera");
    pe(this, "resources");
    pe(this, "performance");
    // State
    pe(this, "state");
    pe(this, "animationFrameId", null);
    // Background and overlay images
    pe(this, "backgroundImage", null);
    pe(this, "depthMapMesh", null);
    pe(this, "depthMapSettings", { colormap: "viridis", opacity: 0.5, visible: !1 });
    // Viewport transform for pan/zoom
    pe(this, "viewportTransform", [1, 0, 0, 1, 0, 0]);
    // Render mode
    pe(this, "renderMode", "color");
    // Audio reactivity
    pe(this, "audioReactiveGetter", null);
    // Transform controls for layer manipulation
    pe(this, "transformControls", null);
    pe(this, "selectedLayerId", null);
    pe(this, "transformMode", "translate");
    // Transform change callback
    pe(this, "onTransformChange", null);
    // Event system
    pe(this, "eventHandlers");
    // Configuration
    pe(this, "config");
    // Active camera tracking
    pe(this, "activeCameraGetter");
    pe(this, "activeCameraId", null);
    this.validateConfig(e), this.config = {
      canvas: e.canvas,
      width: e.width,
      height: e.height,
      compositionWidth: e.compositionWidth ?? e.width,
      compositionHeight: e.compositionHeight ?? e.height,
      pixelRatio: e.pixelRatio ?? Math.min(window.devicePixelRatio, 2),
      antialias: e.antialias ?? !0,
      alpha: e.alpha ?? !0,
      backgroundColor: e.backgroundColor ?? null,
      debug: e.debug ?? !1,
      powerPreference: e.powerPreference ?? "high-performance"
    }, this.state = {
      currentFrame: 0,
      isRendering: !1,
      isDisposed: !1,
      viewport: {
        width: this.config.width,
        height: this.config.height
      }
    }, this.eventHandlers = /* @__PURE__ */ new Map(), this.resources = new gN(), this.scene = new $z(this.config.backgroundColor), this.camera = new vN(this.config.width, this.config.height), this.renderer = new s6({
      canvas: this.config.canvas,
      width: this.config.width,
      height: this.config.height,
      pixelRatio: this.config.pixelRatio,
      antialias: this.config.antialias,
      alpha: this.config.alpha
    }, this.scene, this.camera), this.layers = new mN(this.scene, this.resources), this.performance = new yN(), this.scene.setCompositionSize(
      this.config.compositionWidth,
      this.config.compositionHeight
    ), this.setupContextLossHandling(), this.config.debug && console.log("[WeylEngine] Initialized", this.config);
  }
  // ============================================================================
  // CONFIGURATION VALIDATION
  // ============================================================================
  validateConfig(e) {
    if (!(e.canvas instanceof HTMLCanvasElement))
      throw new Error("WeylEngine requires a valid HTMLCanvasElement");
    if (e.width <= 0 || e.height <= 0)
      throw new Error("WeylEngine requires positive width and height");
    if (e.width > 8192 || e.height > 8192)
      throw new Error("WeylEngine maximum dimension is 8192 pixels");
  }
  // ============================================================================
  // LAYER MANAGEMENT
  // ============================================================================
  /**
   * Add a layer to the composition
   * @param layerData - The layer data from the project schema
   */
  addLayer(e) {
    this.assertNotDisposed(), this.layers.create(e), this.emit("layerAdded", { layerId: e.id }), this.config.debug && console.log("[WeylEngine] Layer added:", e.id, e.type);
  }
  /**
   * Update a layer's properties
   * @param layerId - The layer ID to update
   * @param properties - Partial layer properties to update
   */
  updateLayer(e, n) {
    this.assertNotDisposed(), this.layers.update(e, n), this.emit("layerUpdated", { layerId: e, properties: n });
  }
  /**
   * Remove a layer from the composition
   * @param layerId - The layer ID to remove
   */
  removeLayer(e) {
    this.assertNotDisposed(), this.layers.remove(e), this.emit("layerRemoved", { layerId: e }), this.config.debug && console.log("[WeylEngine] Layer removed:", e);
  }
  /**
   * Get all layer IDs currently in the composition
   */
  getLayerIds() {
    return this.layers.getLayerIds();
  }
  /**
   * Get the Three.js object for a layer (for advanced manipulation)
   * @param layerId - The layer ID
   */
  getLayerObject(e) {
    return this.layers.getObject(e);
  }
  /**
   * Sync all layers from store data
   * @param layers - Array of layer data from store
   */
  syncLayers(e) {
    this.assertNotDisposed();
    const n = new Set(this.layers.getLayerIds()), i = new Set(e.map((r) => r.id));
    for (const r of n)
      i.has(r) || this.layers.remove(r);
    for (const r of e)
      n.has(r.id) ? this.layers.update(r.id, r) : this.layers.create(r);
  }
  // ============================================================================
  // CALLBACKS & INTEGRATION
  // ============================================================================
  /**
   * Set the asset getter callback for ResourceManager
   * This allows layers to access project assets
   * @param getter - Function that retrieves assets by ID
   */
  setAssetGetter(e) {
    this.resources.setAssetGetter(e);
  }
  /**
   * Set the video metadata callback for LayerManager
   * Called when a video layer finishes loading its metadata
   * @param callback - Function called with layer ID and video metadata
   */
  setVideoMetadataCallback(e) {
    this.layers.setVideoMetadataCallback(e);
  }
  /**
   * Set the precomp render context for LayerManager
   * Allows precomp layers to render nested compositions
   * @param context - Render context with composition access
   */
  setPrecompRenderContext(e) {
    this.layers.setPrecompRenderContext(e);
  }
  /**
   * Set camera callbacks for LayerManager
   * Allows camera layers to access Camera3D data from store
   * @param getter - Function to get Camera3D by ID
   * @param updater - Function to update Camera3D properties
   * @param atFrameGetter - Function to get Camera3D with keyframe interpolation at a specific frame
   */
  setCameraCallbacks(e, n, i) {
    this.layers.setCameraCallbacks(e, n, i), this.activeCameraGetter = e;
  }
  /**
   * Set the active camera layer that drives the render view
   * @param cameraLayerId - The camera layer ID, or null to use default camera
   */
  setActiveCameraLayer(e) {
    this.activeCameraId = e;
  }
  /**
   * Sync render camera from active CameraLayer
   * Called during frame evaluation to update the actual render camera
   */
  syncActiveCamera() {
    if (!this.activeCameraId || !this.activeCameraGetter)
      return;
    const e = this.layers.getLayer(this.activeCameraId);
    if (!e || e.type !== "camera")
      return;
    const n = e, i = n.getExportData();
    if (!i)
      return;
    this.camera.setPosition(i.position.x, i.position.y, i.position.z), this.camera.setRotation(i.rotation.x, i.rotation.y, i.rotation.z), this.camera.setFOV(i.fov), this.camera.setClipPlanes(i.nearClip, i.farClip);
    const r = n.getCameraAtCurrentFrame();
    r && r.depthOfField && this.setDOFFromCamera(r.depthOfField);
  }
  /**
   * Set composition FPS for particle timing
   * @param fps - Frames per second
   */
  setCompositionFPS(e) {
    this.layers.setCompositionFPS(e);
  }
  /**
   * Initialize particle systems with WebGL renderer
   * Must be called after engine initialization to enable GPU particles
   */
  initializeParticleSystems() {
    this.layers.setRenderer(this.renderer.getWebGLRenderer()), this.layers.setCamera(this.camera.camera);
  }
  /**
   * Get the current camera position (for particle systems, etc.)
   * Returns world-space position of the active camera
   */
  getCameraPosition() {
    return this.camera.camera.position.clone();
  }
  /**
   * Get the camera's projection and view matrices
   * Useful for depth calculations and screen-space effects
   */
  getCameraMatrices() {
    const e = this.camera.camera;
    return {
      projectionMatrix: e.projectionMatrix.clone(),
      viewMatrix: e.matrixWorldInverse.clone(),
      projectionMatrixInverse: e.projectionMatrixInverse.clone()
    };
  }
  // ============================================================================
  // PROPERTY DRIVERS (Expressions/Links)
  // ============================================================================
  /**
   * Set driven values for a layer
   * Used by the expression/driver system to override animated properties
   */
  setLayerDrivenValues(e, n) {
    this.layers.setLayerDrivenValues(e, n);
  }
  /**
   * Clear driven values for a layer
   */
  clearLayerDrivenValues(e) {
    this.layers.clearLayerDrivenValues(e);
  }
  /**
   * Clear all driven values for all layers
   */
  clearAllDrivenValues() {
    this.layers.clearAllDrivenValues();
  }
  /**
   * Get the Three.js camera directly (for advanced use)
   */
  getCamera() {
    return this.camera.camera;
  }
  // ============================================================================
  // ANIMATION & TIMELINE
  // ============================================================================
  /**
   * Set the current frame for animation evaluation
   * @param frame - The frame number (0-indexed)
   */
  setFrame(e) {
    this.assertNotDisposed(), this.state.currentFrame = e, this.layers.evaluateFrame(e, this.audioReactiveGetter), this.syncActiveCamera(), this.activeCameraId || this.camera.evaluateFrame(e);
  }
  /**
   * Set the audio reactive getter callback
   * This callback will be called during frame evaluation to get audio-modulated values
   */
  setAudioReactiveCallback(e) {
    this.audioReactiveGetter = e, this.layers.setAudioReactiveCallback(e);
  }
  /**
   * Get the current frame
   */
  getCurrentFrame() {
    return this.state.currentFrame;
  }
  // ============================================================================
  // RENDERING
  // ============================================================================
  /**
   * Render the current frame
   */
  render() {
    this.assertNotDisposed(), this.performance.beginFrame(), this.emit("frameStart", { frame: this.state.currentFrame }), this.renderer.render(), this.emit("frameEnd", { frame: this.state.currentFrame }), this.performance.endFrame(this.renderer.getWebGLRenderer());
  }
  /**
   * Start continuous rendering loop
   */
  startRenderLoop() {
    if (this.assertNotDisposed(), this.animationFrameId !== null)
      return;
    this.state.isRendering = !0;
    const e = () => {
      !this.state.isRendering || this.state.isDisposed || (this.render(), this.animationFrameId = requestAnimationFrame(e));
    };
    this.animationFrameId = requestAnimationFrame(e);
  }
  /**
   * Stop continuous rendering loop
   */
  stopRenderLoop() {
    this.state.isRendering = !1, this.animationFrameId !== null && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  /**
   * Check if render loop is active
   */
  isRenderLoopActive() {
    return this.state.isRendering;
  }
  // ============================================================================
  // VIEWPORT
  // ============================================================================
  /**
   * Resize the viewport
   * @param width - New viewport width in pixels
   * @param height - New viewport height in pixels
   * @param compositionWidth - Optional new composition width
   * @param compositionHeight - Optional new composition height
   */
  resize(e, n, i, r) {
    if (this.assertNotDisposed(), e <= 0 || n <= 0) {
      console.warn("[WeylEngine] Invalid resize dimensions:", e, n);
      return;
    }
    this.state.viewport = { width: e, height: n }, this.renderer.resize(e, n);
    const o = i ?? e, a = r ?? n;
    this.camera.resize(o, a), this.emit("resize", { width: e, height: n, compositionWidth: i, compositionHeight: r });
  }
  /**
   * Get current viewport dimensions
   */
  getViewport() {
    return { ...this.state.viewport };
  }
  // ============================================================================
  // CAMERA
  // ============================================================================
  /**
   * Get the camera controller for advanced camera manipulation
   */
  getCameraController() {
    return this.camera;
  }
  /**
   * Set camera position
   */
  setCameraPosition(e, n, i) {
    this.camera.setPosition(e, n, i);
  }
  /**
   * Set camera target (look-at point)
   */
  setCameraTarget(e, n, i) {
    this.camera.setTarget(e, n, i);
  }
  /**
   * Set camera field of view
   */
  setCameraFOV(e) {
    this.camera.setFOV(e);
  }
  // ============================================================================
  // DEPTH OF FIELD
  // ============================================================================
  /**
   * Configure depth of field from Camera3D DOF settings
   * @param dof - Camera3D.depthOfField settings
   */
  setDOFFromCamera(e) {
    this.renderer.setDOF({
      enabled: e.enabled,
      focusDistance: e.focusDistance,
      // Convert aperture to BokehPass scale (smaller = more blur)
      aperture: e.aperture * 1e-4,
      maxBlur: e.blurLevel * 0.02
    });
  }
  /**
   * Enable or disable DOF
   */
  setDOFEnabled(e) {
    this.renderer.setDOFEnabled(e);
  }
  /**
   * Set DOF focus distance
   * @param distance - Focus distance in world units
   */
  setDOFFocusDistance(e) {
    this.renderer.setFocusDistance(e);
  }
  /**
   * Set DOF aperture
   * @param aperture - Aperture value (higher = more blur)
   */
  setDOFAperture(e) {
    this.renderer.setAperture(e * 1e-4);
  }
  /**
   * Get current DOF configuration
   */
  getDOF() {
    return this.renderer.getDOF();
  }
  // ============================================================================
  // VIEWPORT TRANSFORM (PAN/ZOOM)
  // ============================================================================
  /**
   * Set the viewport transform for pan/zoom operations
   * @param transform - [scaleX, skewX, skewY, scaleY, translateX, translateY]
   */
  setViewportTransform(e) {
    this.viewportTransform = [...e];
    const n = e[0], i = e[4], r = e[5];
    this.camera.setZoom(n), this.camera.setPan(i, r);
  }
  /**
   * Get the current viewport transform
   */
  getViewportTransform() {
    return [...this.viewportTransform];
  }
  // ============================================================================
  // BACKGROUND & OVERLAYS
  // ============================================================================
  /**
   * Set a background image for the composition
   * @param image - HTMLImageElement to use as background
   */
  setBackgroundImage(e) {
    this.assertNotDisposed(), this.backgroundImage && (this.scene.removeFromComposition(this.backgroundImage), this.backgroundImage.geometry.dispose(), this.backgroundImage.material.dispose());
    const n = new yn(e);
    n.needsUpdate = !0, n.colorSpace = pn;
    const i = new cn(e.width, e.height), r = new Mn({
      map: n,
      transparent: !0,
      depthWrite: !1
    });
    this.backgroundImage = new qe(i, r), this.backgroundImage.position.set(e.width / 2, e.height / 2, -1e3), this.backgroundImage.userData.isBackground = !0, this.scene.addToComposition(this.backgroundImage);
  }
  /**
   * Set the depth map overlay
   * @param image - HTMLImageElement containing depth data
   * @param options - Display options
   */
  setDepthMap(e, n) {
    this.assertNotDisposed(), this.depthMapSettings = {
      colormap: n.colormap ?? this.depthMapSettings.colormap,
      opacity: n.opacity ?? this.depthMapSettings.opacity,
      visible: n.visible ?? this.depthMapSettings.visible
    }, this.depthMapMesh && (this.scene.removeFromComposition(this.depthMapMesh), this.depthMapMesh.geometry.dispose(), this.depthMapMesh.material.dispose());
    const i = new yn(e);
    i.needsUpdate = !0;
    const r = this.createColormapMaterial(i, this.depthMapSettings), o = new cn(e.width, e.height);
    this.depthMapMesh = new qe(o, r), this.depthMapMesh.position.set(e.width / 2, e.height / 2, -999), this.depthMapMesh.visible = this.depthMapSettings.visible, this.depthMapMesh.userData.isDepthOverlay = !0, this.scene.addToComposition(this.depthMapMesh);
  }
  /**
   * Create a colormap shader material for depth visualization
   */
  createColormapMaterial(e, n) {
    const i = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `, r = `
      uniform sampler2D depthMap;
      uniform float opacity;
      uniform int colormap;
      varying vec2 vUv;

      vec3 viridis(float t) {
        const vec3 c0 = vec3(0.267, 0.004, 0.329);
        const vec3 c1 = vec3(0.282, 0.140, 0.458);
        const vec3 c2 = vec3(0.253, 0.265, 0.529);
        const vec3 c3 = vec3(0.191, 0.407, 0.556);
        const vec3 c4 = vec3(0.127, 0.566, 0.551);
        const vec3 c5 = vec3(0.208, 0.718, 0.472);
        const vec3 c6 = vec3(0.565, 0.843, 0.262);
        const vec3 c7 = vec3(0.993, 0.906, 0.144);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      vec3 plasma(float t) {
        const vec3 c0 = vec3(0.050, 0.030, 0.528);
        const vec3 c1 = vec3(0.327, 0.012, 0.615);
        const vec3 c2 = vec3(0.534, 0.054, 0.553);
        const vec3 c3 = vec3(0.716, 0.215, 0.475);
        const vec3 c4 = vec3(0.863, 0.395, 0.362);
        const vec3 c5 = vec3(0.958, 0.590, 0.233);
        const vec3 c6 = vec3(0.995, 0.812, 0.166);
        const vec3 c7 = vec3(0.940, 0.975, 0.131);

        t = clamp(t, 0.0, 1.0);
        float i = t * 7.0;
        int idx = int(floor(i));
        float f = fract(i);

        if (idx < 1) return mix(c0, c1, f);
        if (idx < 2) return mix(c1, c2, f);
        if (idx < 3) return mix(c2, c3, f);
        if (idx < 4) return mix(c3, c4, f);
        if (idx < 5) return mix(c4, c5, f);
        if (idx < 6) return mix(c5, c6, f);
        return mix(c6, c7, f);
      }

      void main() {
        float depth = texture2D(depthMap, vUv).r;
        vec3 color;

        if (colormap == 0) {
          color = viridis(depth);
        } else if (colormap == 1) {
          color = plasma(depth);
        } else {
          color = vec3(depth);
        }

        gl_FragColor = vec4(color, opacity);
      }
    `, o = n.colormap === "viridis" ? 0 : n.colormap === "plasma" ? 1 : 2;
    return new Fn({
      uniforms: {
        depthMap: { value: e },
        opacity: { value: n.opacity },
        colormap: { value: o }
      },
      vertexShader: i,
      fragmentShader: r,
      transparent: !0,
      depthWrite: !1
    });
  }
  /**
   * Set depth overlay visibility
   */
  setDepthOverlayVisible(e) {
    this.depthMapSettings.visible = e, this.depthMapMesh && (this.depthMapMesh.visible = e);
  }
  /**
   * Set depth colormap
   */
  setDepthColormap(e) {
    if (this.depthMapSettings.colormap = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material, i = e === "viridis" ? 0 : e === "plasma" ? 1 : 2;
      n.uniforms.colormap.value = i;
    }
  }
  /**
   * Set depth overlay opacity
   */
  setDepthOpacity(e) {
    if (this.depthMapSettings.opacity = e, this.depthMapMesh) {
      const n = this.depthMapMesh.material;
      n.uniforms.opacity.value = e;
    }
  }
  // ============================================================================
  // RENDER MODE
  // ============================================================================
  /**
   * Set the render mode (color, depth, normal)
   */
  setRenderMode(e) {
    this.renderMode = e, this.renderer.setRenderMode(e);
  }
  /**
   * Get the current render mode
   */
  getRenderMode() {
    return this.renderMode;
  }
  // ============================================================================
  // RAYCASTING
  // ============================================================================
  /**
   * Raycast to find layers at a normalized screen position
   * @param x - Normalized X coordinate (-1 to 1)
   * @param y - Normalized Y coordinate (-1 to 1)
   * @returns Layer ID if hit, null otherwise
   */
  raycastLayers(e, n) {
    const i = new Of(), r = new st(e, n);
    i.setFromCamera(r, this.camera.getCamera());
    const o = this.scene.raycastComposition(i);
    for (const a of o) {
      let l = a.object;
      for (; l; ) {
        if (l.userData.layerId)
          return l.userData.layerId;
        if (l.userData.isBackground || l.userData.isDepthOverlay)
          break;
        l = l.parent;
      }
    }
    return null;
  }
  // ============================================================================
  // TRANSFORM CONTROLS
  // ============================================================================
  /**
   * Initialize transform controls for layer manipulation
   */
  initializeTransformControls() {
    if (this.assertNotDisposed(), this.transformControls)
      return;
    const e = this.camera.getCamera(), n = this.renderer.getDomElement();
    this.transformControls = new Uz(e, n), this.transformControls.setMode(this.transformMode), this.transformControls.setSpace("world"), this.transformControls.setSize(1), this.scene.addUIElement(this.transformControls), this.transformControls.addEventListener("change", () => {
      if (!this.transformControls || !this.selectedLayerId) return;
      const i = this.transformControls.object;
      if (!i) return;
      const r = {
        position: {
          x: i.position.x,
          y: i.position.y,
          z: i.position.z
        },
        rotationX: fn.radToDeg(i.rotation.x),
        rotationY: fn.radToDeg(i.rotation.y),
        rotationZ: fn.radToDeg(i.rotation.z),
        scale: {
          x: i.scale.x * 100,
          // Convert back to percentage
          y: i.scale.y * 100,
          z: i.scale.z * 100
        }
      };
      r.rotation = r.rotationZ, this.onTransformChange && this.onTransformChange(this.selectedLayerId, r);
    }), this.transformControls.addEventListener("dragging-changed", (i) => {
      this.emit("transform-dragging", { dragging: i.value });
    }), this.transformControls.addEventListener("mouseUp", () => {
      this.emit("transform-end", { layerId: this.selectedLayerId });
    });
  }
  /**
   * Set transform change callback
   * Called whenever a layer is transformed via the controls
   */
  setTransformChangeCallback(e) {
    this.onTransformChange = e;
  }
  /**
   * Select a layer and attach transform controls
   * @param layerId - Layer ID to select, or null to deselect
   */
  selectLayer(e) {
    if (this.assertNotDisposed(), this.transformControls || this.initializeTransformControls(), this.selectedLayerId && this.transformControls && this.transformControls.detach(), this.selectedLayerId = e, !e || !this.transformControls)
      return;
    const n = this.getLayerObject(e);
    n && this.transformControls.attach(n);
  }
  /**
   * Get the currently selected layer ID
   */
  getSelectedLayerId() {
    return this.selectedLayerId;
  }
  /**
   * Set the transform mode
   * @param mode - 'translate' | 'rotate' | 'scale'
   */
  setTransformMode(e) {
    this.transformMode = e, this.transformControls && this.transformControls.setMode(e);
  }
  /**
   * Get the current transform mode
   */
  getTransformMode() {
    return this.transformMode;
  }
  /**
   * Set transform controls visibility
   */
  setTransformControlsVisible(e) {
    this.transformControls && (this.transformControls.visible = e, this.transformControls.enabled = e);
  }
  /**
   * Check if transform controls are dragging
   */
  isTransformDragging() {
    var e;
    return ((e = this.transformControls) == null ? void 0 : e.dragging) ?? !1;
  }
  // ============================================================================
  // RENDER LOOP ALIASES
  // ============================================================================
  /**
   * Alias for startRenderLoop
   */
  start() {
    this.startRenderLoop();
  }
  /**
   * Alias for stopRenderLoop
   */
  stop() {
    this.stopRenderLoop();
  }
  // ============================================================================
  // FRAME CAPTURE & EXPORT
  // ============================================================================
  /**
   * Capture the current frame as ImageData
   */
  captureFrame() {
    this.assertNotDisposed();
    const e = this.renderer.captureFrame();
    return {
      imageData: e,
      width: e.width,
      height: e.height,
      format: "rgba"
    };
  }
  /**
   * Capture the current frame as a Blob
   * @param format - Image format ('png' | 'jpeg' | 'webp')
   * @param quality - Quality for lossy formats (0-1)
   */
  async captureFrameAsBlob(e = "png", n = 0.95) {
    this.assertNotDisposed();
    const { imageData: i, width: r, height: o } = this.captureFrame(), a = new OffscreenCanvas(r, o);
    return a.getContext("2d").putImageData(i, 0, 0), a.convertToBlob({
      type: `image/${e}`,
      quality: n
    });
  }
  /**
   * Capture the depth buffer
   */
  captureDepth() {
    this.assertNotDisposed();
    const e = this.renderer.captureDepth(), n = this.camera.getState();
    return {
      depthBuffer: e,
      width: this.state.viewport.width,
      height: this.state.viewport.height,
      near: n.near,
      far: n.far
    };
  }
  // ============================================================================
  // PERFORMANCE
  // ============================================================================
  /**
   * Get current performance statistics
   */
  getPerformanceStats() {
    return this.performance.getStats();
  }
  /**
   * Reset performance statistics
   */
  resetPerformanceStats() {
    this.performance.reset();
  }
  // ============================================================================
  // EVENTS
  // ============================================================================
  /**
   * Subscribe to engine events
   * @param type - Event type to listen for
   * @param handler - Event handler function
   */
  on(e, n) {
    this.eventHandlers.has(e) || this.eventHandlers.set(e, /* @__PURE__ */ new Set()), this.eventHandlers.get(e).add(n);
  }
  /**
   * Unsubscribe from engine events
   * @param type - Event type
   * @param handler - Event handler to remove
   */
  off(e, n) {
    var i;
    (i = this.eventHandlers.get(e)) == null || i.delete(n);
  }
  emit(e, n) {
    var r;
    const i = {
      type: e,
      timestamp: performance.now(),
      data: n
    };
    (r = this.eventHandlers.get(e)) == null || r.forEach((o) => {
      try {
        o(i);
      } catch (a) {
        console.error(`[WeylEngine] Event handler error for ${e}:`, a);
      }
    });
  }
  // ============================================================================
  // CONTEXT LOSS HANDLING
  // ============================================================================
  setupContextLossHandling() {
    const e = this.config.canvas;
    e.addEventListener("webglcontextlost", (n) => {
      n.preventDefault(), this.stopRenderLoop(), this.emit("contextLost", null), console.warn("[WeylEngine] WebGL context lost");
    }), e.addEventListener("webglcontextrestored", () => {
      this.emit("contextRestored", null), console.log("[WeylEngine] WebGL context restored");
    });
  }
  // ============================================================================
  // STATE & UTILITIES
  // ============================================================================
  /**
   * Get current engine state
   */
  getState() {
    return { ...this.state };
  }
  /**
   * Check if the engine has been disposed
   */
  isDisposed() {
    return this.state.isDisposed;
  }
  assertNotDisposed() {
    if (this.state.isDisposed)
      throw new Error("WeylEngine has been disposed");
  }
  // ============================================================================
  // DISPOSAL
  // ============================================================================
  /**
   * Dispose all engine resources
   * After calling dispose(), the engine cannot be used again.
   */
  dispose() {
    this.state.isDisposed || (this.stopRenderLoop(), this.layers.dispose(), this.renderer.dispose(), this.scene.dispose(), this.resources.dispose(), this.eventHandlers.clear(), this.state.isDisposed = !0, this.emit("dispose", null), this.config.debug && console.log("[WeylEngine] Disposed"));
  }
}
const xN = { class: "spline-editor" }, bN = ["viewBox"], wN = ["x1", "y1", "x2", "y2"], SN = ["x1", "y1", "x2", "y2"], MN = ["cx", "cy", "onMousedown"], CN = ["cx", "cy", "onMousedown"], EN = ["cx", "cy", "onMousedown"], TN = ["cx", "cy"], AN = /* @__PURE__ */ Ut({
  __name: "SplineEditor",
  props: {
    layerId: {},
    canvasWidth: {},
    canvasHeight: {},
    zoom: {},
    viewportTransform: {},
    isPenMode: { type: Boolean }
  },
  emits: ["pointAdded", "pointMoved", "handleMoved", "pointDeleted", "pathUpdated"],
  setup(s, { expose: e, emit: n }) {
    const i = s, r = n, o = nn(), a = Se(null), l = Se(null), c = Se(null), u = Oe(() => {
      if (!i.layerId) return [];
      const S = o.layers.find((x) => x.id === i.layerId);
      return !S || S.type !== "spline" || !S.data ? [] : S.data.controlPoints || [];
    });
    function d(S, w) {
      const x = i.viewportTransform, C = (S - x[4]) / x[0], E = (w - x[5]) / x[3];
      return { x: C, y: E };
    }
    function h(S) {
      const x = S.currentTarget.getBoundingClientRect(), C = S.clientX - x.left, E = S.clientY - x.top;
      return d(C, E);
    }
    function m(S) {
      if (!i.isPenMode) return;
      const w = h(S);
      if (i.layerId) {
        const x = o.layers.find((C) => C.id === i.layerId);
        if (x && x.type === "spline") {
          const C = {
            id: `cp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            x: w.x,
            y: w.y,
            handleIn: null,
            handleOut: null,
            type: "corner"
          };
          o.addSplineControlPoint(i.layerId, C), a.value = C.id, c.value = {
            type: "handleOut",
            pointId: C.id,
            startX: w.x,
            startY: w.y
          }, r("pointAdded", C), r("pathUpdated");
        }
      }
    }
    function p(S) {
      var x;
      const w = h(S);
      if (i.isPenMode && (l.value = w), c.value && i.layerId) {
        const C = o.layers.find((T) => T.id === i.layerId);
        if (!C || C.type !== "spline") return;
        const P = (x = C.data.controlPoints) == null ? void 0 : x.find((T) => T.id === c.value.pointId);
        if (!P) return;
        if (c.value.type === "point") {
          const T = w.x - P.x, b = w.y - P.y, M = { x: w.x, y: w.y };
          P.handleIn && (M.handleIn = { x: P.handleIn.x + T, y: P.handleIn.y + b }), P.handleOut && (M.handleOut = { x: P.handleOut.x + T, y: P.handleOut.y + b }), o.updateSplineControlPoint(i.layerId, P.id, M), r("pointMoved", P.id, w.x, w.y);
        } else if (c.value.type === "handleIn") {
          const T = { handleIn: { x: w.x, y: w.y } };
          if (P.type === "smooth") {
            const b = w.x - P.x, M = w.y - P.y;
            T.handleOut = { x: P.x - b, y: P.y - M };
          }
          o.updateSplineControlPoint(i.layerId, P.id, T), r("handleMoved", P.id, "in", w.x, w.y);
        } else if (c.value.type === "handleOut") {
          const T = { handleOut: { x: w.x, y: w.y } };
          if (P.type === "smooth") {
            const b = w.x - P.x, M = w.y - P.y;
            T.handleIn = { x: P.x - b, y: P.y - M };
          }
          o.updateSplineControlPoint(i.layerId, P.id, T), r("handleMoved", P.id, "out", w.x, w.y);
        }
        r("pathUpdated");
      }
    }
    function y() {
      var S;
      if (c.value && i.layerId) {
        const w = o.layers.find((x) => x.id === i.layerId);
        if (w && w.type === "spline") {
          const C = (S = w.data.controlPoints) == null ? void 0 : S.find((E) => E.id === c.value.pointId);
          if (C && C.handleOut) {
            const E = C.handleOut.x - C.x, P = C.handleOut.y - C.y;
            Math.sqrt(E * E + P * P) > 5 ? o.updateSplineControlPoint(i.layerId, C.id, {
              type: "smooth",
              handleIn: { x: C.x - E, y: C.y - P }
            }) : o.updateSplineControlPoint(i.layerId, C.id, {
              handleOut: null
            });
          }
        }
        c.value = null, r("pathUpdated");
      }
    }
    function _(S, w) {
      if (a.value = S, !i.isPenMode) {
        const x = h(w);
        c.value = {
          type: "point",
          pointId: S,
          startX: x.x,
          startY: x.y
        };
      }
    }
    function v(S, w, x) {
      const C = h(x);
      c.value = {
        type: w === "in" ? "handleIn" : "handleOut",
        pointId: S,
        startX: C.x,
        startY: C.y
      };
    }
    function g(S) {
      if ((S.key === "Delete" || S.key === "Backspace") && a.value && i.layerId) {
        const w = o.layers.find((x) => x.id === i.layerId);
        if (w && w.type === "spline") {
          const x = a.value;
          o.deleteSplineControlPoint(i.layerId, x), r("pointDeleted", x), r("pathUpdated"), a.value = null;
        }
      }
    }
    return _n(() => {
      window.addEventListener("keydown", g);
    }), jn(() => {
      window.removeEventListener("keydown", g);
    }), e({
      selectedPointId: a,
      clearSelection: () => {
        a.value = null;
      }
    }), (S, w) => (re(), ae("div", xN, [
      (re(), ae("svg", {
        class: "control-overlay",
        viewBox: `0 0 ${s.canvasWidth} ${s.canvasHeight}`,
        onMousedown: m,
        onMousemove: p,
        onMouseup: y,
        onMouseleave: y
      }, [
        (re(!0), ae(Ze, null, at(u.value, (x) => (re(), ae(Ze, {
          key: `handles-${x.id}`
        }, [
          x.handleIn && a.value === x.id ? (re(), ae("line", {
            key: 0,
            x1: x.x,
            y1: x.y,
            x2: x.handleIn.x,
            y2: x.handleIn.y,
            class: "handle-line"
          }, null, 8, wN)) : Pe("", !0),
          x.handleOut && a.value === x.id ? (re(), ae("line", {
            key: 1,
            x1: x.x,
            y1: x.y,
            x2: x.handleOut.x,
            y2: x.handleOut.y,
            class: "handle-line"
          }, null, 8, SN)) : Pe("", !0)
        ], 64))), 128)),
        (re(!0), ae(Ze, null, at(u.value, (x) => {
          var C, E;
          return re(), ae(Ze, {
            key: `handle-points-${x.id}`
          }, [
            x.handleIn && a.value === x.id ? (re(), ae("circle", {
              key: 0,
              cx: x.handleIn.x,
              cy: x.handleIn.y,
              r: "4",
              class: Ue(["handle-point", { active: ((C = c.value) == null ? void 0 : C.type) === "handleIn" && c.value.pointId === x.id }]),
              onMousedown: wt((P) => v(x.id, "in", P), ["stop"])
            }, null, 42, MN)) : Pe("", !0),
            x.handleOut && a.value === x.id ? (re(), ae("circle", {
              key: 1,
              cx: x.handleOut.x,
              cy: x.handleOut.y,
              r: "4",
              class: Ue(["handle-point", { active: ((E = c.value) == null ? void 0 : E.type) === "handleOut" && c.value.pointId === x.id }]),
              onMousedown: wt((P) => v(x.id, "out", P), ["stop"])
            }, null, 42, CN)) : Pe("", !0)
          ], 64);
        }), 128)),
        (re(!0), ae(Ze, null, at(u.value, (x) => (re(), ae("circle", {
          key: `point-${x.id}`,
          cx: x.x,
          cy: x.y,
          r: "6",
          class: Ue(["control-point", {
            selected: a.value === x.id,
            corner: x.type === "corner",
            smooth: x.type === "smooth"
          }]),
          onMousedown: wt((C) => _(x.id, C), ["stop"])
        }, null, 42, EN))), 128)),
        l.value && s.isPenMode ? (re(), ae("circle", {
          key: 0,
          cx: l.value.x,
          cy: l.value.y,
          r: "4",
          class: "preview-point"
        }, null, 8, TN)) : Pe("", !0)
      ], 40, bN))
    ]));
  }
}), PN = /* @__PURE__ */ Bt(AN, [["__scopeId", "data-v-55bdee8d"]]), DN = {
  key: 1,
  class: "overlay-controls"
}, RN = { class: "render-mode-controls" }, IN = {
  key: 2,
  class: "transform-mode-controls"
}, kN = {
  key: 3,
  class: "performance-overlay"
}, LN = {
  key: 4,
  class: "loading-overlay"
}, FN = /* @__PURE__ */ Ut({
  __name: "ThreeCanvas",
  setup(s, { expose: e }) {
    const n = nn(), i = Se(null), r = Se(null), o = Se(null), a = x1(null), l = Se(!1), c = Se(1), u = Se(800), d = Se(600), h = Se(!1), m = Se("viridis"), p = Se(50), y = Se("color"), _ = Se(!1), v = Se({
      fps: 0,
      frameTime: 0,
      drawCalls: 0,
      triangles: 0,
      textures: 0,
      geometries: 0,
      memoryUsed: 0
    }), g = Se([1, 0, 0, 1, 0, 0]), S = Se("translate"), w = Oe(() => n.depthMap !== null), x = Oe(() => n.currentTool === "pen"), C = Oe(() => {
      const H = n.selectedLayer;
      if ((H == null ? void 0 : H.type) === "spline")
        return H.id;
      if (x.value) {
        const X = n.layers.filter((V) => V.type === "spline");
        return X.length > 0 ? X[X.length - 1].id : null;
      }
      return null;
    }), E = Oe(() => g.value);
    _n(async () => {
      if (!r.value || !i.value) return;
      const H = i.value, X = H.getBoundingClientRect();
      u.value = X.width, d.value = X.height;
      const V = {
        canvas: r.value,
        width: X.width,
        height: X.height,
        compositionWidth: n.width || 1920,
        compositionHeight: n.height || 1080,
        pixelRatio: Math.min(window.devicePixelRatio, 2),
        // Cap at 2 for performance
        antialias: !0,
        alpha: !0,
        powerPreference: "high-performance"
      };
      try {
        l.value = !0, a.value = new _N(V), a.value.setAssetGetter((F) => n.assets[F]), a.value.setVideoMetadataCallback((F, k) => {
          n.onVideoMetadataLoaded(F, k);
        }), a.value.setCameraCallbacks(
          (F) => n.getCamera(F),
          (F, k) => n.updateCamera(F, k),
          (F, k) => n.getCameraAtFrame(F, k)
        ), a.value.setPrecompRenderContext({
          renderComposition: (F, k) => (n.getComposition(F) && console.log("[ThreeCanvas] Precomp render requested:", F, "frame:", k), null),
          getComposition: (F) => n.getComposition(F)
        }), a.value.setAudioReactiveCallback(
          (F, k) => n.getAudioReactiveValuesForLayer(F, k)
        ), a.value.initializeTransformControls(), a.value.setTransformChangeCallback((F, k) => {
          A(F, k);
        }), a.value.initializeParticleSystems(), a.value.setCompositionFPS(n.fps || 60), a.value.start(), await Ti(), T(), n.initializePropertyDriverSystem(), a.value.setFrame(n.currentFrame), D(), new ResizeObserver(he).observe(H), ee();
      } catch (I) {
        console.error("[ThreeCanvas] Failed to initialize engine:", I);
      } finally {
        l.value = !1;
      }
      P();
    }), jn(() => {
      a.value && (a.value.stop(), a.value.dispose(), a.value = null);
    });
    function P() {
      Ft(
        () => n.layers,
        () => {
          T(), a.value && a.value.setFrame(n.currentFrame);
        },
        { deep: !0 }
      ), Ft(
        () => n.currentFrame,
        (H) => {
          a.value && (b(), a.value.setFrame(H));
        }
      ), Ft(
        () => [n.width, n.height],
        ([H, X]) => {
          a.value && (a.value.resize(u.value, d.value, H, X), ee());
        }
      ), Ft(
        () => n.sourceImage,
        async (H) => {
          a.value && H && await M(H);
        },
        { immediate: !0 }
      ), Ft(
        () => n.depthMap,
        async (H) => {
          a.value && H && await L(H);
        },
        { immediate: !0 }
      ), Ft(
        () => {
          var H;
          return (H = a.value) == null ? void 0 : H.getPerformanceStats();
        },
        (H) => {
          H && (v.value = H);
        }
      ), Ft(
        () => n.activeCameraId,
        (H) => {
          if (!a.value) return;
          if (!H) {
            a.value.setActiveCameraLayer(null);
            return;
          }
          const X = n.layers.find(
            (V) => {
              var I;
              return V.type === "camera" && ((I = V.data) == null ? void 0 : I.cameraId) === H;
            }
          );
          X && a.value.setActiveCameraLayer(X.id);
        },
        { immediate: !0 }
      ), Ft(
        () => n.selectedLayerIds,
        (H) => {
          if (!a.value) return;
          const X = H.length > 0 ? H[0] : null;
          a.value.selectLayer(X);
        },
        { deep: !0 }
      );
    }
    function T() {
      if (!a.value) return;
      const H = new Set(a.value.getLayerIds()), X = new Set(n.layers.map((V) => V.id));
      for (const V of H)
        X.has(V) || a.value.removeLayer(V);
      for (const V of n.layers)
        H.has(V.id) ? a.value.updateLayer(V.id, V) : a.value.addLayer(V);
    }
    function b() {
      if (a.value) {
        a.value.clearAllDrivenValues();
        for (const H of n.layers) {
          const X = n.getDrivenValuesForLayer(H.id);
          X.size > 0 && a.value.setLayerDrivenValues(H.id, X);
        }
      }
    }
    async function M(H) {
      if (a.value)
        try {
          l.value = !0;
          const X = await N(H);
          a.value.setBackgroundImage(X);
        } catch (X) {
          console.error("[ThreeCanvas] Failed to load source image:", X);
        } finally {
          l.value = !1;
        }
    }
    async function L(H) {
      if (a.value)
        try {
          const X = await N(H);
          a.value.setDepthMap(X, {
            colormap: m.value,
            opacity: p.value / 100,
            visible: h.value
          });
        } catch (X) {
          console.error("[ThreeCanvas] Failed to load depth map:", X);
        }
    }
    function N(H) {
      return new Promise((X, V) => {
        const I = new Image();
        I.crossOrigin = "anonymous", I.onload = () => X(I), I.onerror = V, I.src = H.startsWith("data:") ? H : `data:image/png;base64,${H}`;
      });
    }
    function D() {
      const H = i.value, X = r.value;
      if (!H || !X) return;
      let V = !1, I = !1, F = 0, k = 0, Q = 0, Z = 1;
      H.addEventListener("mousedown", (R) => {
        R.button === 1 && R.preventDefault();
      }), H.addEventListener("auxclick", (R) => {
        R.button === 1 && R.preventDefault();
      }), X.addEventListener("wheel", (R) => {
        R.preventDefault();
        const ie = R.deltaY;
        let J = c.value * (ie > 0 ? 0.9 : 1.1);
        J = Math.min(Math.max(J, 0.1), 10);
        const B = X.getBoundingClientRect(), $ = R.clientX - B.left, se = R.clientY - B.top, U = J / c.value;
        g.value[4] = $ - U * ($ - g.value[4]), g.value[5] = se - U * (se - g.value[5]), g.value[0] = J, g.value[3] = J, c.value = J, a.value && a.value.setViewportTransform(g.value);
      }, { passive: !1 }), X.addEventListener("mousedown", (R) => {
        var J, B;
        const ie = n.currentTool;
        if (R.button === 1 || ie === "hand" || R.button === 0 && R.altKey) {
          V = !0, F = R.clientX, k = R.clientY, X.style.cursor = "grabbing", R.preventDefault();
          return;
        }
        if (ie === "zoom") {
          if (R.shiftKey) {
            const $ = Math.max(c.value * 0.7, 0.1);
            c.value = $, g.value[0] = $, g.value[3] = $, a.value && a.value.setViewportTransform(g.value);
          } else
            I = !0, Q = R.clientY, Z = c.value;
          return;
        }
        if (ie === "text") {
          const $ = X.getBoundingClientRect(), se = O(R.clientX - $.left, R.clientY - $.top), U = n.createLayer("text");
          (J = U.transform) != null && J.position && (U.transform.position.value = { x: se.x, y: se.y, z: 0 }), n.updateLayer(U.id, {
            transform: {
              ...U.transform,
              position: {
                ...U.transform.position,
                value: { x: se.x, y: se.y, z: 0 }
              }
            }
          }), n.selectLayer(U.id), n.setTool("select");
          return;
        }
        if (ie === "select" && R.button === 0) {
          if ((B = a.value) != null && B.isTransformDragging())
            return;
          const $ = X.getBoundingClientRect(), se = (R.clientX - $.left) / $.width * 2 - 1, U = -((R.clientY - $.top) / $.height) * 2 + 1;
          if (a.value) {
            const z = a.value.raycastLayers(se, U);
            z ? (n.selectLayer(z), a.value.selectLayer(z)) : (n.clearSelection(), a.value.selectLayer(null));
          }
        }
      }), X.addEventListener("mousemove", (R) => {
        if (V) {
          const J = R.clientX - F, B = R.clientY - k;
          g.value[4] += J, g.value[5] += B, F = R.clientX, k = R.clientY, a.value && a.value.setViewportTransform(g.value);
          return;
        }
        if (I) {
          const B = 1 + (Q - R.clientY) * 0.01, $ = Math.max(0.1, Math.min(10, Z * B));
          c.value = $, g.value[0] = $, g.value[3] = $, a.value && a.value.setViewportTransform(g.value);
          return;
        }
        const ie = n.currentTool;
        ie === "hand" ? X.style.cursor = "grab" : ie === "zoom" ? X.style.cursor = "zoom-in" : ie === "text" ? X.style.cursor = "text" : ie === "pen" ? X.style.cursor = "crosshair" : X.style.cursor = "default";
      }), X.addEventListener("mouseup", () => {
        V && (V = !1, X.style.cursor = n.currentTool === "hand" ? "grab" : "default"), I && (I = !1);
      }), X.addEventListener("mouseleave", () => {
        V = !1, I = !1;
      });
    }
    function O(H, X) {
      const V = g.value;
      return {
        x: (H - V[4]) / V[0],
        y: (X - V[5]) / V[3]
      };
    }
    function A(H, X) {
      var F, k, Q, Z;
      const V = n.layers.find((R) => R.id === H);
      if (!V) return;
      const I = {};
      X.position && V.transform && (I.transform = {
        ...V.transform,
        position: {
          ...V.transform.position,
          value: {
            x: X.position.x,
            y: X.position.y,
            z: X.position.z ?? ((k = (F = V.transform.position) == null ? void 0 : F.value) == null ? void 0 : k.z) ?? 0
          }
        }
      }), V.threeD ? (X.rotationX !== void 0 || X.rotationY !== void 0 || X.rotationZ !== void 0) && (!I.transform && V.transform && (I.transform = { ...V.transform }), I.transform && (X.rotationX !== void 0 && (I.transform.rotationX = { ...V.transform.rotationX, value: X.rotationX }), X.rotationY !== void 0 && (I.transform.rotationY = { ...V.transform.rotationY, value: X.rotationY }), X.rotationZ !== void 0 && (I.transform.rotationZ = { ...V.transform.rotationZ, value: X.rotationZ }))) : X.rotation !== void 0 && V.transform && (I.transform || (I.transform = { ...V.transform }), I.transform.rotation = { ...V.transform.rotation, value: X.rotation }), X.scale && V.transform && (I.transform || (I.transform = { ...V.transform }), I.transform.scale = {
        ...V.transform.scale,
        value: {
          x: X.scale.x,
          y: X.scale.y,
          z: X.scale.z ?? ((Z = (Q = V.transform.scale) == null ? void 0 : Q.value) == null ? void 0 : Z.z) ?? 100
        }
      }), Object.keys(I).length > 0 && n.updateLayer(H, I);
    }
    function G(H) {
      S.value = H, a.value && a.value.setTransformMode(H);
    }
    function he(H) {
      for (const X of H) {
        const { width: V, height: I } = X.contentRect;
        V > 0 && I > 0 && (u.value = V, d.value = I, a.value && a.value.resize(V, I));
      }
    }
    function ee() {
      const H = i.value;
      if (!H || !a.value) return;
      const X = n.width || 1920, V = n.height || 1080, I = H.getBoundingClientRect(), F = 60, k = (I.width - F * 2) / X, Q = (I.height - F * 2) / V, Z = Math.min(k, Q, 1);
      g.value = [
        Z,
        0,
        0,
        Z,
        (I.width - X * Z) / 2,
        (I.height - V * Z) / 2
      ], c.value = Z, a.value.setViewportTransform(g.value);
    }
    function le(H) {
      y.value = H, a.value && a.value.setRenderMode(H);
    }
    function oe(H) {
      if (!C.value) {
        const X = n.createLayer("spline");
        n.selectLayer(X.id);
      }
    }
    function Y() {
      T();
    }
    function j() {
      const H = Math.min(c.value * 1.2, 10);
      c.value = H, g.value[0] = H, g.value[3] = H, a.value && a.value.setViewportTransform(g.value);
    }
    function q() {
      const H = Math.max(c.value * 0.8, 0.1);
      c.value = H, g.value[0] = H, g.value[3] = H, a.value && a.value.setViewportTransform(g.value);
    }
    function te() {
      ee();
    }
    async function ne() {
      if (!a.value) return null;
      const H = a.value.captureFrame();
      if (!(H != null && H.imageData)) return null;
      const X = document.createElement("canvas");
      X.width = H.width, X.height = H.height;
      const V = X.getContext("2d");
      return V ? (V.putImageData(H.imageData, 0, 0), X.toDataURL("image/png")) : null;
    }
    async function de() {
      if (!a.value) return null;
      const H = a.value.captureDepth();
      if (!(H != null && H.depthBuffer)) return null;
      const X = document.createElement("canvas");
      X.width = H.width, X.height = H.height;
      const V = X.getContext("2d");
      if (!V) return null;
      const I = V.createImageData(H.width, H.height);
      for (let F = 0; F < H.depthBuffer.length; F++) {
        const k = Math.floor(H.depthBuffer[F] * 255), Q = F * 4;
        I.data[Q] = k, I.data[Q + 1] = k, I.data[Q + 2] = k, I.data[Q + 3] = 255;
      }
      return V.putImageData(I, 0, 0), X.toDataURL("image/png");
    }
    return Ft(h, (H) => {
      a.value && a.value.setDepthOverlayVisible(H);
    }), Ft(m, (H) => {
      a.value && a.value.setDepthColormap(H);
    }), Ft(p, (H) => {
      a.value && a.value.setDepthOpacity(H / 100);
    }), e({
      engine: a,
      fitToView: te,
      zoomIn: j,
      zoomOut: q,
      zoom: c,
      captureFrame: ne,
      captureDepth: de,
      showPerformance: _,
      performanceStats: v,
      renderMode: y,
      setRenderMode: le,
      transformMode: S,
      setTransformModeTo: G
    }), (H, X) => (re(), ae("div", {
      class: "three-canvas",
      ref_key: "containerRef",
      ref: i
    }, [
      f("canvas", {
        ref_key: "canvasRef",
        ref: r
      }, null, 512),
      C.value || x.value ? (re(), St(PN, {
        key: 0,
        layerId: C.value,
        canvasWidth: u.value,
        canvasHeight: d.value,
        zoom: c.value,
        viewportTransform: E.value,
        isPenMode: x.value,
        onPointAdded: oe,
        onPathUpdated: Y,
        ref_key: "splineEditorRef",
        ref: o
      }, null, 8, ["layerId", "canvasWidth", "canvasHeight", "zoom", "viewportTransform", "isPenMode"])) : Pe("", !0),
      w.value ? (re(), ae("div", DN, [
        f("label", null, [
          ct(f("input", {
            type: "checkbox",
            "onUpdate:modelValue": X[0] || (X[0] = (V) => h.value = V)
          }, null, 512), [
            [Ci, h.value]
          ]),
          X[9] || (X[9] = ft(" Depth Overlay ", -1))
        ]),
        ct(f("select", {
          "onUpdate:modelValue": X[1] || (X[1] = (V) => m.value = V),
          class: "colormap-select"
        }, [...X[10] || (X[10] = [
          f("option", { value: "viridis" }, "Viridis", -1),
          f("option", { value: "plasma" }, "Plasma", -1),
          f("option", { value: "grayscale" }, "Grayscale", -1)
        ])], 512), [
          [ti, m.value]
        ]),
        ct(f("input", {
          type: "range",
          min: "0",
          max: "100",
          "onUpdate:modelValue": X[2] || (X[2] = (V) => p.value = V),
          class: "opacity-slider"
        }, null, 512), [
          [
            $t,
            p.value,
            void 0,
            { number: !0 }
          ]
        ])
      ])) : Pe("", !0),
      f("div", RN, [
        f("button", {
          class: Ue({ active: y.value === "color" }),
          onClick: X[3] || (X[3] = (V) => le("color")),
          title: "Color View"
        }, [...X[11] || (X[11] = [
          f("i", { class: "pi pi-image" }, null, -1)
        ])], 2),
        f("button", {
          class: Ue({ active: y.value === "depth" }),
          onClick: X[4] || (X[4] = (V) => le("depth")),
          title: "Depth View"
        }, [...X[12] || (X[12] = [
          f("i", { class: "pi pi-box" }, null, -1)
        ])], 2),
        f("button", {
          class: Ue({ active: y.value === "normal" }),
          onClick: X[5] || (X[5] = (V) => le("normal")),
          title: "Normal View"
        }, [...X[13] || (X[13] = [
          f("i", { class: "pi pi-compass" }, null, -1)
        ])], 2)
      ]),
      Ge(n).selectedLayerIds.length > 0 ? (re(), ae("div", IN, [
        f("button", {
          class: Ue({ active: S.value === "translate" }),
          onClick: X[6] || (X[6] = (V) => G("translate")),
          title: "Move (V)"
        }, [...X[14] || (X[14] = [
          f("i", { class: "pi pi-arrows-alt" }, null, -1)
        ])], 2),
        f("button", {
          class: Ue({ active: S.value === "rotate" }),
          onClick: X[7] || (X[7] = (V) => G("rotate")),
          title: "Rotate (R)"
        }, [...X[15] || (X[15] = [
          f("i", { class: "pi pi-sync" }, null, -1)
        ])], 2),
        f("button", {
          class: Ue({ active: S.value === "scale" }),
          onClick: X[8] || (X[8] = (V) => G("scale")),
          title: "Scale (S)"
        }, [...X[16] || (X[16] = [
          f("i", { class: "pi pi-expand" }, null, -1)
        ])], 2)
      ])) : Pe("", !0),
      _.value ? (re(), ae("div", kN, [
        f("span", null, "FPS: " + be(v.value.fps), 1),
        f("span", null, "Draw: " + be(v.value.drawCalls), 1),
        f("span", null, "Tris: " + be(v.value.triangles), 1)
      ])) : Pe("", !0),
      l.value ? (re(), ae("div", LN, [...X[17] || (X[17] = [
        f("div", { class: "loading-spinner" }, null, -1),
        f("span", null, "Loading...", -1)
      ])])) : Pe("", !0)
    ], 512));
  }
}), UN = /* @__PURE__ */ Bt(FN, [["__scopeId", "data-v-8efacaec"]]), ON = { class: "prop-wrapper" }, zN = { class: "prop-content" }, NN = { class: "prop-name" }, BN = { class: "prop-inputs" }, VN = {
  key: 0,
  class: "vec-item"
}, GN = {
  key: 1,
  class: "color-input-wrapper"
}, HN = ["value"], WN = { class: "color-hex" }, $N = { class: "vec-item" }, XN = { class: "vec-item" }, jN = ["onMousedown", "onDblclick"], YN = /* @__PURE__ */ Ut({
  __name: "PropertyTrack",
  props: ["name", "property", "layerId", "propertyPath", "layoutMode", "pixelsPerFrame", "gridStyle"],
  emits: ["selectKeyframe", "deleteKeyframe", "moveKeyframe"],
  setup(s, { emit: e }) {
    const n = s, i = nn(), r = Se(/* @__PURE__ */ new Set()), o = Oe(() => {
      var _;
      return (_ = n.property.keyframes) == null ? void 0 : _.some((v) => v.frame === i.currentFrame);
    }), a = Oe(() => i.selectedPropertyPath === n.propertyPath);
    function l() {
      i.setPropertyAnimated(n.layerId, n.propertyPath, !n.property.animated);
    }
    function c() {
      i.addKeyframe(n.layerId, n.propertyPath, n.property.value);
    }
    function u(_) {
      i.setPropertyValue(n.layerId, n.propertyPath, _);
    }
    function d(_, v) {
      const g = { ...n.property.value, [_]: v };
      i.setPropertyValue(n.layerId, n.propertyPath, g);
    }
    function h() {
      i.selectProperty(n.propertyPath);
    }
    function m(_) {
      const v = _.currentTarget.getBoundingClientRect(), g = _.clientX - v.left, S = Math.round(g / n.pixelsPerFrame);
      i.setFrame(Math.max(0, Math.min(i.frameCount - 1, S)));
    }
    function p(_, v) {
      _.shiftKey ? r.value.has(v.id) ? r.value.delete(v.id) : r.value.add(v.id) : (r.value.clear(), r.value.add(v.id));
      const g = _.clientX, S = v.frame, w = (C) => {
        const E = C.clientX - g, P = Math.round(E / n.pixelsPerFrame), T = Math.max(0, Math.min(i.frameCount - 1, S + P));
        T !== v.frame && i.moveKeyframe(n.layerId, n.propertyPath, v.id, T);
      }, x = () => {
        window.removeEventListener("mousemove", w), window.removeEventListener("mouseup", x);
      };
      window.addEventListener("mousemove", w), window.addEventListener("mouseup", x);
    }
    function y(_) {
      i.removeKeyframe(n.layerId, n.propertyPath, _), r.value.delete(_);
    }
    return (_, v) => {
      var g;
      return re(), ae("div", ON, [
        s.layoutMode === "sidebar" ? (re(), ae("div", {
          key: 0,
          class: Ue(["prop-sidebar", { selected: a.value }]),
          style: bt(s.gridStyle),
          onClick: h
        }, [
          v[7] || (v[7] = f("div", { class: "indent-spacer" }, null, -1)),
          f("div", {
            class: "icon-box",
            onClick: wt(c, ["stop"])
          }, [
            f("span", {
              class: Ue(["kf-btn", { active: o.value }])
            }, "", 2)
          ]),
          f("div", {
            class: "icon-box",
            onClick: wt(l, ["stop"])
          }, [
            f("span", {
              class: Ue(["stopwatch", { active: s.property.animated }])
            }, "", 2)
          ]),
          f("div", zN, [
            f("span", NN, be(s.name), 1),
            f("div", BN, [
              s.name === "Z Position" ? (re(), ae("div", VN, [
                v[4] || (v[4] = f("span", { class: "label z-label" }, "Z", -1)),
                Ne(et, {
                  modelValue: ((g = s.property.value) == null ? void 0 : g.z) ?? 0,
                  "onUpdate:modelValue": v[0] || (v[0] = (S) => d("z", S))
                }, null, 8, ["modelValue"])
              ])) : s.property.type === "color" ? (re(), ae("div", GN, [
                f("input", {
                  type: "color",
                  value: s.property.value,
                  onInput: v[1] || (v[1] = (S) => u(S.target.value))
                }, null, 40, HN),
                f("span", WN, be(s.property.value), 1)
              ])) : typeof s.property.value == "object" ? (re(), ae(Ze, { key: 2 }, [
                f("div", $N, [
                  v[5] || (v[5] = f("span", { class: "label x-label" }, "X", -1)),
                  Ne(et, {
                    modelValue: s.property.value.x,
                    "onUpdate:modelValue": v[2] || (v[2] = (S) => d("x", S))
                  }, null, 8, ["modelValue"])
                ]),
                f("div", XN, [
                  v[6] || (v[6] = f("span", { class: "label y-label" }, "Y", -1)),
                  Ne(et, {
                    modelValue: s.property.value.y,
                    "onUpdate:modelValue": v[3] || (v[3] = (S) => d("y", S))
                  }, null, 8, ["modelValue"])
                ])
              ], 64)) : typeof s.property.value == "number" ? (re(), St(et, {
                key: 3,
                modelValue: s.property.value,
                "onUpdate:modelValue": u,
                precision: 1
              }, null, 8, ["modelValue"])) : Pe("", !0)
            ])
          ])
        ], 6)) : (re(), ae("div", {
          key: 1,
          class: "prop-track",
          onMousedown: m
        }, [
          (re(!0), ae(Ze, null, at(s.property.keyframes, (S) => (re(), ae("div", {
            key: S.id,
            class: Ue(["keyframe", { selected: r.value.has(S.id) }]),
            style: bt({ left: `${S.frame * s.pixelsPerFrame}px` }),
            onMousedown: wt((w) => p(w, S), ["stop"]),
            onDblclick: wt((w) => y(S.id), ["stop"])
          }, null, 46, jN))), 128))
        ], 32))
      ]);
    };
  }
}), Vv = /* @__PURE__ */ Bt(YN, [["__scopeId", "data-v-d351e86b"]]), qN = {
  key: 0,
  class: "track-wrapper"
}, ZN = { class: "arrow" }, KN = { class: "layer-id" }, JN = { class: "type-icon" }, QN = {
  key: 0,
  class: "name-text"
}, e8 = { class: "col-mode" }, t8 = ["value"], n8 = { class: "col-parent" }, i8 = ["value"], s8 = ["value"], r8 = {
  key: 0,
  class: "children-container"
}, o8 = ["onMousedown"], a8 = { class: "arrow-col" }, l8 = { class: "arrow" }, c8 = { class: "group-label" }, u8 = { key: 0 }, d8 = {
  key: 0,
  class: "children-container"
}, h8 = { key: 0 }, f8 = /* @__PURE__ */ Ut({
  __name: "EnhancedLayerTrack",
  props: ["layer", "index", "layoutMode", "isExpandedExternal", "allLayers", "frameCount", "pixelsPerFrame", "gridStyle"],
  emits: ["toggleExpand", "select", "updateLayer"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Se(!1), a = Oe(() => n.isExpandedExternal ?? o.value), l = Oe(() => r.selectedLayerIds.includes(n.layer.id)), c = Se(["Transform", "Text", "More Options"]), u = Se(!1), d = Se(""), h = Se(null), m = Se(!1), p = Se(0), y = Se(0), _ = Oe(() => {
      var te;
      return ((te = n.allLayers) == null ? void 0 : te.filter((ne) => ne.id !== n.layer.id)) || [];
    }), v = Oe(() => {
      const te = {}, ne = n.layer.transform, de = [], H = (X, V, I) => {
        I && de.push({ path: X, name: V, property: I });
      };
      return H("transform.anchorPoint", "Anchor Point", ne.anchorPoint), H("transform.position", "Position", ne.position), n.layer.threeD && de.push({
        path: "transform.position.z",
        name: "Z Position",
        property: ne.position
        // Pass full position property, PropertyTrack handles .z
      }), H("transform.scale", "Scale", ne.scale), n.layer.threeD ? (ne.orientation && de.push({ path: "transform.orientation", name: "Orientation", property: ne.orientation }), ne.rotationX && de.push({ path: "transform.rotationX", name: "X Rotation", property: ne.rotationX }), ne.rotationY && de.push({ path: "transform.rotationY", name: "Y Rotation", property: ne.rotationY }), ne.rotationZ && de.push({ path: "transform.rotationZ", name: "Z Rotation", property: ne.rotationZ })) : ne.rotation && de.push({ path: "transform.rotation", name: "Rotation", property: ne.rotation }), n.layer.opacity && de.push({ path: "opacity", name: "Opacity", property: n.layer.opacity }), te.Transform = de, n.layer.properties && n.layer.properties.forEach((X) => {
        const V = X.group || "Properties";
        te[V] || (te[V] = []), te[V].push({ path: X.name, name: X.name, property: X });
      }), te;
    }), g = Oe(() => {
      const te = n.pixelsPerFrame || 10;
      return { left: `${n.layer.inPoint * te}px`, width: `${(n.layer.outPoint - n.layer.inPoint + 1) * te}px` };
    });
    function S() {
      i("select", n.layer.id);
    }
    function w() {
      i("toggleExpand", n.layer.id, !a.value);
    }
    function x(te) {
      c.value.includes(te) ? c.value = c.value.filter((ne) => ne !== te) : c.value.push(te);
    }
    function C(te) {
      return { text: "T", solid: "", camera: "" }[te] || "";
    }
    function E() {
      u.value = !0, d.value = n.layer.name, Ti(() => {
        var te;
        return (te = h.value) == null ? void 0 : te.focus();
      });
    }
    function P() {
      i("updateLayer", n.layer.id, { name: d.value }), u.value = !1;
    }
    function T(te) {
      i("updateLayer", n.layer.id, { parentId: te.target.value || null });
    }
    function b(te) {
      i("updateLayer", n.layer.id, { blendMode: te.target.value });
    }
    function M() {
    }
    function L() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible });
    }
    function N() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked });
    }
    function D() {
    }
    function O(te) {
      p.value = te.clientX, y.value = te.clientY, m.value = !0, l.value || i("select", n.layer.id);
    }
    function A() {
      m.value = !1;
    }
    function G() {
      r.duplicateLayer(n.layer.id), A();
    }
    function he() {
      A(), Ti(() => {
        u.value = !0, d.value = n.layer.name, Ti(() => {
          var te;
          return (te = h.value) == null ? void 0 : te.focus();
        });
      });
    }
    function ee() {
      i("updateLayer", n.layer.id, { visible: !n.layer.visible }), A();
    }
    function le() {
      i("updateLayer", n.layer.id, { locked: !n.layer.locked }), A();
    }
    function oe() {
      r.toggleLayer3D(n.layer.id), A();
    }
    function Y() {
      r.selectLayer(n.layer.id), r.precomposeSelectedLayers(n.layer.name + " Precomp"), A();
    }
    function j() {
      r.deleteLayer(n.layer.id), A();
    }
    function q(te) {
      m.value && A();
    }
    return _n(() => {
      document.addEventListener("click", q);
    }), jn(() => {
      document.removeEventListener("click", q);
    }), (te, ne) => s.layer ? (re(), ae("div", qN, [
      s.layoutMode === "sidebar" ? (re(), ae(Ze, { key: 0 }, [
        f("div", {
          class: Ue(["sidebar-row", { selected: l.value }]),
          style: bt(s.gridStyle),
          onMousedown: S,
          onContextmenu: wt(O, ["prevent"])
        }, [
          f("div", {
            class: "arrow-col",
            onMousedown: wt(w, ["stop"])
          }, [
            f("span", ZN, be(a.value ? "" : ""), 1)
          ], 32),
          f("div", {
            class: "label-box",
            onMousedown: wt(D, ["stop"]),
            style: bt({ background: s.layer.labelColor || "#999" })
          }, null, 36),
          f("div", KN, be(s.index), 1),
          f("div", {
            class: "icon-col",
            onMousedown: wt(L, ["stop"])
          }, be(s.layer.visible ? "" : ""), 33),
          f("div", {
            class: "icon-col",
            onMousedown: wt(N, ["stop"])
          }, be(s.layer.locked ? "" : ""), 33),
          f("div", {
            class: Ue(["icon-col cube-icon", { active: s.layer.threeD }]),
            onMousedown: ne[0] || (ne[0] = wt((de) => Ge(r).toggleLayer3D(s.layer.id), ["stop"]))
          }, "", 34),
          f("div", {
            class: "layer-name-col",
            onDblclick: wt(E, ["stop"])
          }, [
            f("span", JN, be(C(s.layer.type)), 1),
            u.value ? ct((re(), ae("input", {
              key: 1,
              "onUpdate:modelValue": ne[1] || (ne[1] = (de) => d.value = de),
              onBlur: P,
              onKeydown: Ja(P, ["enter"]),
              class: "rename-input",
              ref_key: "renameInput",
              ref: h
            }, null, 544)), [
              [$t, d.value]
            ]) : (re(), ae("span", QN, be(s.layer.name), 1))
          ], 32),
          f("div", e8, [
            f("select", {
              value: s.layer.blendMode,
              class: "mini-select",
              onChange: b,
              onMousedown: ne[2] || (ne[2] = wt(() => {
              }, ["stop"]))
            }, [...ne[5] || (ne[5] = [
              Or('<optgroup label="Normal" data-v-ae1384d4><option value="normal" data-v-ae1384d4>Normal</option><option value="dissolve" data-v-ae1384d4>Dissolve</option></optgroup><optgroup label="Darken" data-v-ae1384d4><option value="darken" data-v-ae1384d4>Darken</option><option value="multiply" data-v-ae1384d4>Multiply</option><option value="colorBurn" data-v-ae1384d4>Color Burn</option><option value="linearBurn" data-v-ae1384d4>Linear Burn</option></optgroup><optgroup label="Lighten" data-v-ae1384d4><option value="add" data-v-ae1384d4>Add</option><option value="lighten" data-v-ae1384d4>Lighten</option><option value="screen" data-v-ae1384d4>Screen</option><option value="colorDodge" data-v-ae1384d4>Color Dodge</option><option value="linearDodge" data-v-ae1384d4>Linear Dodge</option></optgroup><optgroup label="Contrast" data-v-ae1384d4><option value="overlay" data-v-ae1384d4>Overlay</option><option value="softLight" data-v-ae1384d4>Soft Light</option><option value="hardLight" data-v-ae1384d4>Hard Light</option><option value="vividLight" data-v-ae1384d4>Vivid Light</option><option value="linearLight" data-v-ae1384d4>Linear Light</option><option value="pinLight" data-v-ae1384d4>Pin Light</option><option value="hardMix" data-v-ae1384d4>Hard Mix</option></optgroup><optgroup label="Inversion" data-v-ae1384d4><option value="difference" data-v-ae1384d4>Difference</option><option value="exclusion" data-v-ae1384d4>Exclusion</option><option value="subtract" data-v-ae1384d4>Subtract</option><option value="divide" data-v-ae1384d4>Divide</option></optgroup><optgroup label="Component" data-v-ae1384d4><option value="hue" data-v-ae1384d4>Hue</option><option value="saturation" data-v-ae1384d4>Saturation</option><option value="color" data-v-ae1384d4>Color</option><option value="luminosity" data-v-ae1384d4>Luminosity</option></optgroup>', 6)
            ])], 40, t8)
          ]),
          f("div", n8, [
            f("select", {
              value: s.layer.parentId || "",
              class: "mini-select",
              onChange: T,
              onMousedown: ne[3] || (ne[3] = wt(() => {
              }, ["stop"]))
            }, [
              ne[6] || (ne[6] = f("option", { value: "" }, "None", -1)),
              (re(!0), ae(Ze, null, at(_.value, (de) => (re(), ae("option", {
                key: de.id,
                value: de.id
              }, be(de.index), 9, s8))), 128))
            ], 40, i8)
          ])
        ], 38),
        a.value ? (re(), ae("div", r8, [
          (re(!0), ae(Ze, null, at(v.value, (de, H) => (re(), ae("div", {
            key: H,
            class: "property-group"
          }, [
            f("div", {
              class: "group-header sidebar-row",
              style: bt(s.gridStyle),
              onMousedown: wt((X) => x(H), ["stop"])
            }, [
              f("div", a8, [
                f("span", l8, be(c.value.includes(H) ? "" : ""), 1)
              ]),
              f("div", c8, be(H), 1)
            ], 44, o8),
            c.value.includes(H) ? (re(), ae("div", u8, [
              (re(!0), ae(Ze, null, at(de, (X) => (re(), St(Vv, {
                key: X.path,
                layerId: s.layer.id,
                propertyPath: X.path,
                name: X.name,
                property: X.property,
                layoutMode: "sidebar",
                gridStyle: s.gridStyle,
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "gridStyle", "pixelsPerFrame"]))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : Pe("", !0)
      ], 64)) : (re(), ae(Ze, { key: 1 }, [
        f("div", {
          class: "layer-row track-bg",
          onMousedown: S
        }, [
          f("div", {
            class: "duration-bar",
            style: bt(g.value),
            onMousedown: wt(M, ["stop"])
          }, [
            f("div", {
              class: "bar-fill",
              style: bt({ background: s.layer.labelColor || "#777" })
            }, null, 4)
          ], 36)
        ], 32),
        a.value ? (re(), ae("div", d8, [
          (re(!0), ae(Ze, null, at(v.value, (de, H) => (re(), ae("div", {
            key: H,
            class: "property-group"
          }, [
            ne[7] || (ne[7] = f("div", { class: "group-header track-bg" }, null, -1)),
            c.value.includes(H) ? (re(), ae("div", h8, [
              (re(!0), ae(Ze, null, at(de, (X) => (re(), St(Vv, {
                key: X.path,
                layerId: s.layer.id,
                propertyPath: X.path,
                name: X.name,
                property: X.property,
                layoutMode: "track",
                pixelsPerFrame: s.pixelsPerFrame
              }, null, 8, ["layerId", "propertyPath", "name", "property", "pixelsPerFrame"]))), 128))
            ])) : Pe("", !0)
          ]))), 128))
        ])) : Pe("", !0)
      ], 64)),
      (re(), St(Po, { to: "body" }, [
        m.value ? (re(), ae("div", {
          key: 0,
          class: "layer-context-menu",
          style: bt({ left: p.value + "px", top: y.value + "px" }),
          onClick: ne[4] || (ne[4] = wt(() => {
          }, ["stop"]))
        }, [
          f("button", { onClick: G }, "Duplicate Layer"),
          f("button", { onClick: he }, "Rename"),
          ne[8] || (ne[8] = f("hr", null, null, -1)),
          f("button", { onClick: ee }, be(s.layer.visible ? "Hide" : "Show") + " Layer", 1),
          f("button", { onClick: le }, be(s.layer.locked ? "Unlock" : "Lock") + " Layer", 1),
          f("button", { onClick: oe }, be(s.layer.threeD ? "Make 2D" : "Make 3D"), 1),
          ne[9] || (ne[9] = f("hr", null, null, -1)),
          f("button", { onClick: Y }, "Pre-compose..."),
          ne[10] || (ne[10] = f("hr", null, null, -1)),
          f("button", {
            onClick: j,
            class: "danger"
          }, "Delete Layer")
        ], 4)) : Pe("", !0)
      ]))
    ])) : Pe("", !0);
  }
}), Gv = /* @__PURE__ */ Bt(f8, [["__scopeId", "data-v-ae1384d4"]]), p8 = { class: "composition-tabs" }, m8 = { class: "tabs-container" }, v8 = ["onClick", "onDblclick", "onContextmenu"], g8 = {
  key: 0,
  class: "precomp-icon",
  title: "Pre-composition"
}, y8 = {
  key: 1,
  class: "tab-name"
}, _8 = {
  key: 2,
  class: "tab-name"
}, x8 = { class: "tab-info" }, b8 = ["onClick"], w8 = ["disabled"], S8 = ["disabled"], M8 = /* @__PURE__ */ Ut({
  __name: "CompositionTabs",
  emits: ["newComposition"],
  setup(s, { emit: e }) {
    const n = e, i = nn(), r = Se(null), o = Se(""), a = Se(null), l = Se({
      visible: !1,
      x: 0,
      y: 0,
      comp: null
    }), c = Oe(() => i.openCompositions), u = Oe(() => i.activeCompositionId), d = Oe(() => i.project.mainCompositionId);
    function h(b) {
      i.switchComposition(b);
    }
    function m(b) {
      i.closeCompositionTab(b);
    }
    function p(b) {
      const M = b.settings;
      return `${M.width}x${M.height} ${M.fps}fps`;
    }
    function y(b) {
      r.value = b.id, o.value = b.name, Ti(() => {
        var M, L;
        (M = a.value) == null || M.focus(), (L = a.value) == null || L.select();
      });
    }
    function _() {
      r.value && o.value.trim() && i.renameComposition(r.value, o.value.trim()), r.value = null, o.value = "";
    }
    function v() {
      r.value = null, o.value = "";
    }
    function g(b, M) {
      l.value = {
        visible: !0,
        x: b.clientX,
        y: b.clientY,
        comp: M
      };
    }
    function S() {
      l.value.visible = !1, l.value.comp = null;
    }
    function w() {
      l.value.comp && y(l.value.comp), S();
    }
    function x() {
      if (l.value.comp) {
        const b = l.value.comp, M = i.createComposition(
          `${b.name} Copy`,
          b.settings,
          b.isPrecomp
        );
        console.log("[CompositionTabs] Duplicated:", M.name);
      }
      S();
    }
    function C() {
      l.value.comp && i.switchComposition(l.value.comp.id), S();
    }
    function E() {
      l.value.comp && (i.project.mainCompositionId = l.value.comp.id, console.log("[CompositionTabs] Set main composition:", l.value.comp.name)), S();
    }
    function P() {
      l.value.comp && l.value.comp.id !== d.value && i.deleteComposition(l.value.comp.id), S();
    }
    function T() {
      l.value.visible && S();
    }
    return _n(() => {
      document.addEventListener("click", T);
    }), jn(() => {
      document.removeEventListener("click", T);
    }), (b, M) => {
      var L, N;
      return re(), ae("div", p8, [
        f("div", m8, [
          (re(!0), ae(Ze, null, at(c.value, (D) => (re(), ae("div", {
            key: D.id,
            class: Ue(["tab", {
              active: D.id === u.value,
              precomp: D.isPrecomp
            }]),
            onClick: (O) => h(D.id),
            onDblclick: (O) => y(D),
            onContextmenu: wt((O) => g(O, D), ["prevent"])
          }, [
            D.isPrecomp ? (re(), ae("span", g8, "")) : Pe("", !0),
            r.value === D.id ? (re(), ae("span", y8, [
              ct(f("input", {
                ref_for: !0,
                ref_key: "renameInput",
                ref: a,
                "onUpdate:modelValue": M[0] || (M[0] = (O) => o.value = O),
                type: "text",
                class: "rename-input",
                onBlur: _,
                onKeydown: [
                  Ja(_, ["enter"]),
                  Ja(v, ["escape"])
                ],
                onClick: M[1] || (M[1] = wt(() => {
                }, ["stop"]))
              }, null, 544), [
                [$t, o.value]
              ])
            ])) : (re(), ae("span", _8, be(D.name), 1)),
            f("span", x8, be(p(D)), 1),
            c.value.length > 1 ? (re(), ae("button", {
              key: 3,
              class: "close-btn",
              onClick: wt((O) => m(D.id), ["stop"]),
              title: "Close tab"
            }, "  ", 8, b8)) : Pe("", !0)
          ], 42, v8))), 128)),
          f("button", {
            class: "new-comp-btn",
            onClick: M[2] || (M[2] = (D) => n("newComposition")),
            title: "New Composition (Ctrl+K)"
          }, " + ")
        ]),
        (re(), St(Po, { to: "body" }, [
          l.value.visible ? (re(), ae("div", {
            key: 0,
            class: "context-menu",
            style: bt({ left: l.value.x + "px", top: l.value.y + "px" }),
            onClick: M[3] || (M[3] = wt(() => {
            }, ["stop"]))
          }, [
            f("button", { onClick: w }, "Rename"),
            f("button", { onClick: x }, "Duplicate"),
            f("button", { onClick: C }, "Open in New Tab"),
            M[4] || (M[4] = f("hr", null, null, -1)),
            f("button", {
              onClick: E,
              disabled: ((L = l.value.comp) == null ? void 0 : L.id) === d.value
            }, " Set as Main Composition ", 8, w8),
            M[5] || (M[5] = f("hr", null, null, -1)),
            f("button", {
              onClick: P,
              disabled: ((N = l.value.comp) == null ? void 0 : N.id) === d.value,
              class: "danger"
            }, " Delete Composition ", 8, S8)
          ], 4)) : Pe("", !0)
        ]))
      ]);
    };
  }
}), C8 = /* @__PURE__ */ Bt(M8, [["__scopeId", "data-v-c032dfe4"]]), E8 = { class: "timeline-header" }, T8 = { class: "header-left" }, A8 = { class: "timecode" }, P8 = { class: "frame-display" }, D8 = ["value"], R8 = { class: "fps-label" }, I8 = { class: "header-center" }, k8 = {
  key: 0,
  class: "add-layer-menu"
}, L8 = { class: "tool-group" }, F8 = ["disabled"], U8 = { class: "header-right" }, O8 = { class: "timeline-content" }, z8 = /* @__PURE__ */ Ut({
  __name: "TimelinePanel",
  emits: ["openCompositionSettings"],
  setup(s, { emit: e }) {
    const n = e, i = nn(), r = Se(10), o = Se(450), a = Se({}), l = Se(!1), c = Se(null), u = Se(null), d = Se(null), h = Se(null), m = Se(null), p = Se(null);
    let y = !1, _ = !1;
    const v = Se(1e3), g = Oe(() => i.layers || []), S = Oe(() => i.currentFrame * r.value), w = Oe(() => {
      const j = i.frameCount * r.value;
      return Math.max(j, v.value) + "px";
    }), x = Oe(() => ({
      display: "grid",
      gridTemplateColumns: "24px 24px 30px 24px 24px 24px 1fr 70px 70px",
      alignItems: "center",
      height: "32px",
      width: "100%",
      boxSizing: "border-box"
    }));
    function C() {
      l.value = !l.value;
    }
    function E(j) {
      j === "text" ? i.createTextLayer() : j === "video" ? i.createLayer("video") : j === "camera" ? i.createCameraLayer() : i.createLayer(j), l.value = !1;
    }
    function P(j) {
      i.selectLayer(j);
    }
    function T(j, q) {
      i.updateLayer(j, q);
    }
    function b() {
      i.selectedLayerIds.forEach((j) => i.deleteLayer(j));
    }
    function M(j) {
      i.setFrame(parseInt(j.target.value) || 0);
    }
    function L() {
      i.togglePlayback();
    }
    function N(j, q) {
      a.value[j] = q;
    }
    function D(j) {
      const q = i.fps, te = Math.floor(j / q), ne = Math.floor(j % q), de = te % 60, H = Math.floor(te / 60) % 60, X = Math.floor(te / 3600), V = (I, F = 2) => String(I).padStart(F, "0");
      return `${V(X)};${V(H)};${V(de)};${V(ne)}`;
    }
    function O() {
      const j = d.value;
      if (!j) return;
      const q = j.getContext("2d");
      if (!q) return;
      const te = i.frameCount * r.value, ne = Math.max(te, v.value);
      j.width = ne, j.height = 30, q.fillStyle = "#222", q.fillRect(0, 0, j.width, j.height), q.strokeStyle = "#666", q.fillStyle = "#aaa", q.font = "11px sans-serif";
      const de = r.value;
      let H, X;
      de >= 20 ? (H = 1, X = 0) : de >= 10 ? (H = 5, X = 1) : de >= 5 ? (H = 10, X = 5) : de >= 2 ? (H = 20, X = 10) : de >= 1 ? (H = 50, X = 25) : de >= 0.5 ? (H = 100, X = 50) : (H = 200, X = 0);
      for (let V = 0; V <= i.frameCount; V++) {
        const I = V * de;
        if (V % H === 0) {
          q.strokeStyle = "#888", q.beginPath(), q.moveTo(I, 12), q.lineTo(I, 30), q.stroke();
          const F = String(V), k = q.measureText(F), Q = (V + H) * de, Z = k.width + 20;
          (Q - I >= Z || V === 0 || V >= i.frameCount - H) && (q.fillStyle = "#ccc", q.fillText(F, I + 3, 10));
        } else X > 0 && V % X === 0 && (q.strokeStyle = "#555", q.beginPath(), q.moveTo(I, 22), q.lineTo(I, 30), q.stroke());
      }
      q.strokeStyle = "#444", q.beginPath(), q.moveTo(0, 29.5), q.lineTo(j.width, 29.5), q.stroke();
    }
    function A(j) {
      var ne, de;
      const q = d.value.getBoundingClientRect();
      (ne = p.value) != null && ne.scrollLeft || (de = m.value) != null && de.scrollLeft;
      const te = (H) => {
        var F, k;
        const X = ((F = p.value) == null ? void 0 : F.scrollLeft) || ((k = m.value) == null ? void 0 : k.scrollLeft) || 0, V = H.clientX - q.left + X, I = Math.max(0, Math.min(i.frameCount - 1, V / r.value));
        i.setFrame(Math.round(I));
      };
      te(j), window.addEventListener("mousemove", te), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", te), { once: !0 });
    }
    function G(j) {
      const q = j.clientX, te = o.value, ne = (de) => {
        o.value = Math.max(300, te + (de.clientX - q));
      };
      window.addEventListener("mousemove", ne), window.addEventListener("mouseup", () => window.removeEventListener("mousemove", ne), { once: !0 });
    }
    function he(j) {
      if (_) return;
      y = !0;
      const q = j.target;
      m.value && (m.value.scrollTop = q.scrollTop), requestAnimationFrame(() => {
        y = !1;
      });
    }
    function ee(j) {
      const q = j.target;
      y || (_ = !0, h.value && (h.value.scrollTop = q.scrollTop), requestAnimationFrame(() => {
        _ = !1;
      })), p.value && (p.value.scrollLeft = q.scrollLeft);
    }
    function le(j) {
      const q = j.target;
      m.value && (m.value.scrollLeft = q.scrollLeft);
    }
    function oe(j) {
      j.target instanceof HTMLInputElement || j.target instanceof HTMLTextAreaElement || (j.code === "Space" && (j.preventDefault(), L()), (j.code === "Delete" || j.code === "Backspace") && (j.preventDefault(), b()));
    }
    let Y = null;
    return _n(() => {
      window.addEventListener("mousedown", (q) => {
        c.value && !c.value.contains(q.target) && (l.value = !1);
      });
      const j = m.value || u.value;
      j && (Y = new ResizeObserver((q) => {
        for (const te of q)
          v.value = te.contentRect.width, O();
      }), Y.observe(j)), setTimeout(O, 100);
    }), jn(() => {
      Y && Y.disconnect();
    }), Ft(() => [w.value, r.value, i.frameCount], () => Ti(O)), (j, q) => (re(), ae("div", {
      class: "timeline-panel",
      tabindex: "0",
      onKeydown: oe
    }, [
      Ne(C8, {
        onNewComposition: q[0] || (q[0] = (te) => n("openCompositionSettings"))
      }),
      f("div", E8, [
        f("div", T8, [
          f("span", A8, be(D(Ge(i).currentFrame)), 1),
          f("div", P8, [
            f("input", {
              type: "number",
              value: Ge(i).currentFrame,
              onChange: M,
              class: "frame-input"
            }, null, 40, D8),
            f("span", R8, be(Ge(i).fps) + " fps", 1)
          ])
        ]),
        f("div", I8, [
          f("div", {
            class: "tool-group add-layer-wrapper",
            ref_key: "addLayerContainer",
            ref: c
          }, [
            f("button", {
              class: Ue(["add-layer-btn", { active: l.value }]),
              onMousedown: wt(C, ["stop", "prevent"])
            }, [...q[9] || (q[9] = [
              f("span", { class: "icon" }, "+", -1),
              ft(" Layer ", -1)
            ])], 34),
            l.value ? (re(), ae("div", k8, [
              f("button", {
                onMousedown: q[1] || (q[1] = (te) => E("solid"))
              }, [...q[10] || (q[10] = [
                f("span", { class: "icon" }, "", -1),
                ft(" Solid", -1)
              ])], 32),
              f("button", {
                onMousedown: q[2] || (q[2] = (te) => E("text"))
              }, [...q[11] || (q[11] = [
                f("span", { class: "icon" }, "T", -1),
                ft(" Text", -1)
              ])], 32),
              f("button", {
                onMousedown: q[3] || (q[3] = (te) => E("spline"))
              }, [...q[12] || (q[12] = [
                f("span", { class: "icon" }, "~", -1),
                ft(" Shape", -1)
              ])], 32),
              f("button", {
                onMousedown: q[4] || (q[4] = (te) => E("null"))
              }, [...q[13] || (q[13] = [
                f("span", { class: "icon" }, "", -1),
                ft(" Null", -1)
              ])], 32),
              f("button", {
                onMousedown: q[5] || (q[5] = (te) => E("camera"))
              }, [...q[14] || (q[14] = [
                f("span", { class: "icon" }, "", -1),
                ft(" Camera", -1)
              ])], 32),
              f("button", {
                onMousedown: q[6] || (q[6] = (te) => E("light"))
              }, [...q[15] || (q[15] = [
                f("span", { class: "icon" }, "", -1),
                ft(" Light", -1)
              ])], 32),
              f("button", {
                onMousedown: q[7] || (q[7] = (te) => E("video"))
              }, [...q[16] || (q[16] = [
                f("span", { class: "icon" }, "", -1),
                ft(" Video", -1)
              ])], 32)
            ])) : Pe("", !0)
          ], 512),
          f("div", L8, [
            f("button", {
              class: "delete-btn",
              onClick: b,
              disabled: Ge(i).selectedLayerIds.length === 0
            }, "", 8, F8)
          ])
        ]),
        f("div", U8, [
          ct(f("input", {
            type: "range",
            min: "0.1",
            max: "50",
            step: "0.1",
            "onUpdate:modelValue": q[8] || (q[8] = (te) => r.value = te),
            class: "zoom-slider",
            title: "Zoom Timeline"
          }, null, 512), [
            [
              $t,
              r.value,
              void 0,
              { number: !0 }
            ]
          ])
        ])
      ]),
      f("div", O8, [
        f("div", {
          class: "timeline-sidebar",
          style: bt({ width: o.value + "px" })
        }, [
          q[17] || (q[17] = Or('<div class="sidebar-header-row" data-v-0fa05443><div class="col-header col-arrow" data-v-0fa05443></div><div class="col-header col-name" data-v-0fa05443>Layer Name</div><div class="col-header col-mode" data-v-0fa05443>Mode</div><div class="col-header col-parent" data-v-0fa05443>Parent</div></div>', 1)),
          f("div", {
            class: "sidebar-scroll-area",
            ref_key: "sidebarScrollRef",
            ref: h,
            onScroll: he
          }, [
            (re(!0), ae(Ze, null, at(g.value, (te, ne) => (re(), St(Gv, {
              key: te.id,
              layer: te,
              index: ne + 1,
              layoutMode: "sidebar",
              isExpandedExternal: a.value[te.id],
              allLayers: Ge(i).layers,
              gridStyle: x.value,
              onToggleExpand: N,
              onSelect: P,
              onUpdateLayer: T
            }, null, 8, ["layer", "index", "isExpandedExternal", "allLayers", "gridStyle"]))), 128))
          ], 544)
        ], 4),
        f("div", {
          class: "sidebar-resizer",
          onMousedown: G
        }, null, 32),
        f("div", {
          class: "track-viewport",
          ref_key: "trackViewportRef",
          ref: u
        }, [
          f("div", {
            class: "ruler-scroll-wrapper",
            onScroll: le,
            ref_key: "rulerScrollRef",
            ref: p
          }, [
            f("div", {
              class: "time-ruler",
              style: bt({ width: w.value }),
              onMousedown: A
            }, [
              f("canvas", {
                ref_key: "rulerCanvas",
                ref: d,
                height: "30"
              }, null, 512),
              f("div", {
                class: "playhead-head",
                style: bt({ left: S.value + "px" })
              }, null, 4),
              f("div", {
                class: "playhead-hit-area",
                style: bt({ left: S.value + "px" }),
                onMousedown: wt(A, ["stop"])
              }, null, 36)
            ], 36)
          ], 544),
          f("div", {
            class: "track-scroll-area",
            ref_key: "trackScrollRef",
            ref: m,
            onScroll: ee
          }, [
            f("div", {
              class: "layer-bars-container",
              style: bt({ width: w.value })
            }, [
              q[18] || (q[18] = f("div", { class: "grid-background" }, null, -1)),
              (re(!0), ae(Ze, null, at(g.value, (te) => (re(), St(Gv, {
                key: te.id,
                layer: te,
                layoutMode: "track",
                frameCount: Ge(i).frameCount,
                pixelsPerFrame: r.value,
                isExpandedExternal: a.value[te.id],
                onSelect: P,
                onUpdateLayer: T
              }, null, 8, ["layer", "frameCount", "pixelsPerFrame", "isExpandedExternal"]))), 128)),
              f("div", {
                class: "playhead-line",
                style: bt({ left: S.value + "px" })
              }, null, 4)
            ], 4)
          ], 544)
        ], 512)
      ])
    ], 32));
  }
}), Hv = /* @__PURE__ */ Bt(z8, [["__scopeId", "data-v-0fa05443"]]), N8 = { class: "graph-editor" }, B8 = { class: "graph-header" }, V8 = { class: "mode-toggle" }, G8 = { class: "preset-buttons" }, H8 = ["onClick", "title"], W8 = { class: "toolbar" }, $8 = { class: "graph-content" }, X8 = { class: "property-list" }, j8 = { class: "property-list-header" }, Y8 = ["title"], q8 = ["onClick"], Z8 = ["onClick"], K8 = { class: "property-name" }, J8 = {
  key: 0,
  class: "keyframe-count"
}, Q8 = {
  key: 0,
  class: "dimension-toggles"
}, eB = ["onClick"], tB = {
  key: 0,
  class: "no-properties"
}, nB = { class: "graph-main" }, iB = ["viewBox"], sB = ["onMousedown"], rB = ["x", "y", "fill", "transform"], oB = {
  key: 1,
  class: "bezier-handles"
}, aB = {
  key: 0,
  class: "handle out-handle"
}, lB = ["x1", "y1", "x2", "y2"], cB = ["cx", "cy", "onMousedown"], uB = {
  key: 1,
  class: "handle in-handle"
}, dB = ["x1", "y1", "x2", "y2"], hB = ["cx", "cy", "onMousedown"], fB = ["x1", "x2", "y2"], pB = {
  key: 0,
  class: "keyframe-info-panel"
}, mB = { class: "info-row" }, vB = ["value"], gB = { class: "info-row" }, yB = ["value"], _B = { class: "info-row" }, xB = ["value"], bB = ["disabled"], wB = ["disabled"], SB = ["disabled"], MB = /* @__PURE__ */ Ut({
  __name: "GraphEditor",
  emits: ["close"],
  setup(s, { emit: e }) {
    const n = e, i = nn(), r = Se(null), o = Se(null), a = Se(null), l = Se(null), c = Se(null), u = Se(null), d = Se(400), h = Se(200), m = Se("value"), p = Go({
      frameStart: 0,
      frameEnd: 100,
      valueMin: 0,
      valueMax: 100,
      zoom: 1
    }), y = Se([]), _ = Se([]), v = Se({}), g = Se([]), S = Se(null), w = Se(null), x = Se(null), C = Se(null), E = Se(null), P = Se(!1), T = Se(!0), b = { top: 10, right: 10, bottom: 10, left: 10 }, M = {
      Position: "#ff6b6b",
      "Position.x": "#ff6b6b",
      "Position.y": "#4ecdc4",
      "Position.z": "#45b7d1",
      Scale: "#f7dc6f",
      "Scale.x": "#f7dc6f",
      "Scale.y": "#82e0aa",
      "Scale.z": "#85c1e9",
      Rotation: "#bb8fce",
      Opacity: "#f8b739",
      default: "#7c9cff"
    }, L = [
      { key: "linear", label: "Linear", shortLabel: "Lin" },
      { key: "easeIn", label: "Ease In", shortLabel: "In" },
      { key: "easeOut", label: "Ease Out", shortLabel: "Out" },
      { key: "easeInOut", label: "Ease In/Out", shortLabel: "I/O" },
      { key: "easeInCubic", label: "Ease In Cubic", shortLabel: "In3" },
      { key: "easeOutCubic", label: "Ease Out Cubic", shortLabel: "Ou3" },
      { key: "easeInOutCubic", label: "Ease In/Out Cubic", shortLabel: "IO3" },
      { key: "easeInBack", label: "Ease In Back", shortLabel: "InB" },
      { key: "easeOutBack", label: "Ease Out Back", shortLabel: "OuB" }
    ], N = Oe(() => {
      const fe = i.selectedLayer;
      if (!fe) return [];
      const _e = [];
      return _e.push(fe.transform.position), _e.push(fe.transform.scale), _e.push(fe.transform.rotation), _e.push(fe.opacity), _e.push(...fe.properties), _e;
    }), D = Oe(() => N.value.filter(
      (fe) => _.value.includes(fe.id) && fe.animated
    )), O = Oe(() => N.value.every((fe) => _.value.includes(fe.id))), A = Oe(() => G(i.currentFrame));
    function G(fe) {
      const _e = d.value - b.left - b.right, Ee = (fe - p.frameStart) / (p.frameEnd - p.frameStart);
      return b.left + Ee * _e;
    }
    function he(fe) {
      const _e = d.value - b.left - b.right, Ee = (fe - b.left) / _e;
      return p.frameStart + Ee * (p.frameEnd - p.frameStart);
    }
    function ee(fe) {
      const _e = h.value - b.top - b.bottom, Ee = (fe - p.valueMin) / (p.valueMax - p.valueMin);
      return h.value - b.bottom - Ee * _e;
    }
    function le(fe) {
      const _e = h.value - b.top - b.bottom, Ee = (h.value - b.bottom - fe) / _e;
      return p.valueMin + Ee * (p.valueMax - p.valueMin);
    }
    function oe(fe) {
      return G(fe.frame);
    }
    function Y(fe, _e) {
      const Ee = typeof _e.value == "number" ? _e.value : typeof _e.value == "object" ? _e.value.x ?? _e.value : 0;
      return ee(Ee);
    }
    function j(fe) {
      if (!fe) return 0;
      const _e = fe.keyframe.value;
      return typeof _e == "number" ? _e : typeof _e == "object" ? _e.x ?? 0 : 0;
    }
    function q(fe, _e) {
      const Ee = fe.keyframes[_e];
      if (!Ee || !Ee.outHandle.enabled) return G(Ee.frame);
      const Le = Ee.frame + Ee.outHandle.frame;
      return G(Le);
    }
    function te(fe, _e) {
      const Ee = fe.keyframes[_e];
      if (!Ee || !Ee.outHandle.enabled) return ee(H(Ee.value));
      const Le = H(Ee.value) + Ee.outHandle.value;
      return ee(Le);
    }
    function ne(fe, _e) {
      const Ee = fe.keyframes[_e];
      if (!Ee || !Ee.inHandle.enabled) return G(Ee.frame);
      const Le = Ee.frame + Ee.inHandle.frame;
      return G(Le);
    }
    function de(fe, _e) {
      const Ee = fe.keyframes[_e];
      if (!Ee || !Ee.inHandle.enabled) return ee(H(Ee.value));
      const Le = H(Ee.value) + Ee.inHandle.value;
      return ee(Le);
    }
    function H(fe) {
      return typeof fe == "number" ? fe : typeof fe == "object" ? fe.x ?? fe.y ?? fe.z ?? 0 : 0;
    }
    function X(fe) {
      const _e = N.value.find((Ee) => Ee.id === fe);
      return _e ? M[_e.name] ?? M.default : M.default;
    }
    function V(fe) {
      return fe.frame >= p.frameStart && fe.frame <= p.frameEnd;
    }
    function I(fe, _e) {
      return g.value.some((Ee) => Ee.propId === fe && Ee.index === _e);
    }
    function F(fe, _e) {
      if (!fe.animated || fe.keyframes.length === 0) return !1;
      const Ee = fe.keyframes[0].value;
      return typeof Ee == "object" && _e in Ee;
    }
    function k(fe) {
      const _e = y.value.indexOf(fe);
      _e === -1 ? y.value.push(fe) : y.value.splice(_e, 1);
    }
    function Q(fe) {
      const _e = _.value.indexOf(fe);
      _e === -1 ? _.value.push(fe) : _.value.splice(_e, 1), J();
    }
    function Z() {
      O.value ? _.value = [] : _.value = N.value.map((fe) => fe.id), J();
    }
    function R(fe, _e) {
      v.value[fe] || (v.value[fe] = []);
      const Ee = v.value[fe], Le = Ee.indexOf(_e);
      Le === -1 ? Ee.push(_e) : Ee.splice(Le, 1);
    }
    function ie() {
      const fe = D.value;
      if (fe.length === 0) return;
      let _e = 1 / 0, Ee = -1 / 0, Le = 1 / 0, W = -1 / 0;
      for (const Ce of fe)
        for (const xe of Ce.keyframes) {
          _e = Math.min(_e, xe.frame), Ee = Math.max(Ee, xe.frame);
          const Ie = H(xe.value);
          Le = Math.min(Le, Ie), W = Math.max(W, Ie);
        }
      const ve = (Ee - _e) * 0.1 || 10, ye = (W - Le) * 0.1 || 10;
      p.frameStart = _e - ve, p.frameEnd = Ee + ve, p.valueMin = Le - ye, p.valueMax = W + ye;
    }
    function J() {
      ie();
    }
    function B() {
      T.value = !T.value;
    }
    function $(fe) {
      return g.value.length === 0 || !Yc[fe] ? !1 : fe === "linear" ? g.value.every((Ee) => Ee.keyframe.interpolation === "linear") : g.value.every((Ee) => Ee.keyframe.interpolation === "bezier");
    }
    function se(fe) {
      const _e = Yc[fe];
      if (!_e) return;
      const Ee = i.selectedLayer;
      if (Ee) {
        for (const Le of g.value) {
          const W = N.value.find((Qe) => Qe.id === Le.propId);
          if (!W) continue;
          const ve = Ae(W), ye = Le.index, Ce = ye > 0 ? W.keyframes[ye - 1] : null, xe = ye < W.keyframes.length - 1 ? W.keyframes[ye + 1] : null, Ie = Ce ? Le.keyframe.frame - Ce.frame : 10, Re = xe ? xe.frame - Le.keyframe.frame : 10;
          if (fe === "linear")
            i.setKeyframeInterpolation(Ee.id, ve, Le.keyframe.id, "linear"), Le.keyframe.interpolation = "linear", Le.keyframe.outHandle = { frame: Re * 0.33, value: 0, enabled: !1 }, Le.keyframe.inHandle = { frame: -Ie * 0.33, value: 0, enabled: !1 };
          else {
            const Qe = {
              frame: _e.outHandle.x * Re,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            }, it = {
              frame: -_e.inHandle.x * Ie,
              value: 0,
              // Would need value delta for proper curve
              enabled: !0
            };
            i.setKeyframeInterpolation(Ee.id, ve, Le.keyframe.id, "bezier"), i.setKeyframeHandle(Ee.id, ve, Le.keyframe.id, "out", Qe), i.setKeyframeHandle(Ee.id, ve, Le.keyframe.id, "in", it), Le.keyframe.interpolation = "bezier", Le.keyframe.outHandle = Qe, Le.keyframe.inHandle = it;
          }
        }
        rt();
      }
    }
    function U(fe) {
      var W;
      const _e = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e) return;
      const Ee = fe.clientX - _e.left, Le = fe.clientY - _e.top;
      fe.button === 1 || fe.button === 0 && fe.altKey ? w.value = { type: "pan", startX: Ee, startY: Le } : fe.button === 0 && (fe.shiftKey || (g.value = []), x.value = { x: Ee, y: Le, width: 0, height: 0 }, w.value = { type: "select", startX: Ee, startY: Le });
    }
    function z(fe) {
      var W;
      const _e = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e) return;
      const Ee = fe.clientX - _e.left, Le = fe.clientY - _e.top;
      if (me(Ee, Le), !!w.value)
        if (w.value.type === "pan") {
          const ve = Ee - (w.value.startX ?? 0), ye = Le - (w.value.startY ?? 0), Ce = d.value - b.left - b.right, xe = h.value - b.top - b.bottom, Ie = -ve / Ce * (p.frameEnd - p.frameStart), Re = ye / xe * (p.valueMax - p.valueMin);
          p.frameStart += Ie, p.frameEnd += Ie, p.valueMin += Re, p.valueMax += Re, w.value.startX = Ee, w.value.startY = Le, rt();
        } else if (w.value.type === "select" && x.value) {
          const ve = w.value.startX ?? 0, ye = w.value.startY ?? 0;
          x.value = {
            x: Math.min(Ee, ve),
            y: Math.min(Le, ye),
            width: Math.abs(Ee - ve),
            height: Math.abs(Le - ye)
          };
        } else w.value.type === "keyframe" ? Te(Ee, Le) : (w.value.type === "outHandle" || w.value.type === "inHandle") && He(Ee, Le);
    }
    function K() {
      var fe;
      ((fe = w.value) == null ? void 0 : fe.type) === "select" && x.value && Me(), w.value = null, x.value = null;
    }
    function ue(fe) {
      var Ce;
      fe.preventDefault();
      const _e = (Ce = r.value) == null ? void 0 : Ce.getBoundingClientRect();
      if (!_e) return;
      const Ee = fe.clientX - _e.left, Le = fe.deltaY > 0 ? 1.1 : 0.9, W = he(Ee), ve = W - (W - p.frameStart) * Le, ye = W + (p.frameEnd - W) * Le;
      if (fe.shiftKey)
        p.frameStart = ve, p.frameEnd = ye;
      else {
        p.frameStart = ve, p.frameEnd = ye;
        const xe = fe.clientY - _e.top, Ie = le(xe);
        p.valueMin = Ie - (Ie - p.valueMin) * Le, p.valueMax = Ie + (p.valueMax - Ie) * Le;
      }
      rt();
    }
    function me(fe, _e) {
      S.value = null;
      for (const Ee of D.value)
        for (let Le = 0; Le < Ee.keyframes.length; Le++) {
          const W = Ee.keyframes[Le], ve = oe(W), ye = Y(Ee, W);
          if (Math.sqrt((fe - ve) ** 2 + (_e - ye) ** 2) < 10) {
            S.value = { propId: Ee.id, index: Le };
            return;
          }
        }
    }
    function ge(fe, _e, Ee) {
      const Le = N.value.find((ve) => ve.id === fe);
      if (!Le) return;
      const W = Le.keyframes[_e];
      Ee.shiftKey || (g.value = []), I(fe, _e) || g.value.push({ propId: fe, index: _e, keyframe: W }), w.value = { type: "keyframe", propId: fe, index: _e };
    }
    function Me() {
      if (!x.value) return;
      const fe = x.value;
      for (const _e of D.value)
        for (let Ee = 0; Ee < _e.keyframes.length; Ee++) {
          const Le = _e.keyframes[Ee], W = oe(Le), ve = Y(_e, Le);
          W >= fe.x && W <= fe.x + fe.width && ve >= fe.y && ve <= fe.y + fe.height && (I(_e.id, Ee) || g.value.push({ propId: _e.id, index: Ee, keyframe: Le }));
        }
    }
    function Te(fe, _e) {
      const Ee = Math.round(he(fe)), Le = le(_e), W = i.selectedLayer;
      if (W) {
        if (g.value.length > 0) {
          const ve = g.value[0], ye = N.value.find((Ie) => Ie.id === ve.propId);
          if (!ye) return;
          const Ce = P.value ? Math.round(Ee / 5) * 5 : Ee;
          typeof ve.keyframe.value == "number" || ve.keyframe.value;
          const xe = Ae(ye);
          i.updateKeyframe(W.id, xe, ve.keyframe.id, {
            frame: Ce,
            value: typeof ve.keyframe.value == "number" ? Le : void 0
          }), ve.keyframe.frame = Ce, typeof ve.keyframe.value == "number" && (ve.keyframe.value = Le);
        }
        rt();
      }
    }
    function Ae(fe) {
      const _e = fe.name.toLowerCase();
      return _e === "position" ? "transform.position" : _e === "scale" ? "transform.scale" : _e === "rotation" ? "transform.rotation" : _e === "opacity" ? "opacity" : _e === "anchor point" ? "transform.anchorPoint" : fe.id;
    }
    function Xe(fe, _e, Ee, Le) {
      w.value = { type: fe, propId: _e, index: Ee }, document.addEventListener("mousemove", Fe), document.addEventListener("mouseup", We);
    }
    function Fe(fe) {
      var W;
      const _e = (W = r.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e || !w.value) return;
      const Ee = fe.clientX - _e.left, Le = fe.clientY - _e.top;
      He(Ee, Le);
    }
    function He(fe, _e) {
      if (!w.value || !w.value.propId) return;
      const Ee = i.selectedLayer;
      if (!Ee) return;
      const Le = N.value.find((Ie) => Ie.id === w.value.propId);
      if (!Le) return;
      const W = w.value.index, ve = Le.keyframes[W];
      if (!ve) return;
      const ye = he(fe), Ce = le(_e), xe = Ae(Le);
      if (w.value.type === "outHandle") {
        const Ie = Le.keyframes[W + 1];
        let Re = ye - ve.frame;
        Ie ? Re = Math.max(0, Math.min(Ie.frame - ve.frame, Re)) : Re = Math.max(0, Re);
        const Qe = Ce - H(ve.value), it = {
          frame: Re,
          value: Qe,
          enabled: !0
        };
        i.setKeyframeHandle(Ee.id, xe, ve.id, "out", it), ve.outHandle = it, ve.interpolation = "bezier", Ye(ve, "out", xe);
      } else if (w.value.type === "inHandle") {
        const Ie = Le.keyframes[W - 1];
        let Re = ye - ve.frame;
        Ie ? Re = Math.min(0, Math.max(Ie.frame - ve.frame, Re)) : Re = Math.min(0, Re);
        const Qe = Ce - H(ve.value), it = {
          frame: Re,
          value: Qe,
          enabled: !0
        };
        i.setKeyframeHandle(Ee.id, xe, ve.id, "in", it), ve.inHandle = it, Ye(ve, "in", xe);
      }
      rt();
    }
    function Ye(fe, _e, Ee) {
      if (!fe.controlMode || fe.controlMode === "corner")
        return;
      const Le = i.selectedLayer;
      if (Le && (fe.controlMode === "symmetric" && (_e === "in" ? (fe.outHandle.frame = -fe.inHandle.frame, fe.outHandle.value = -fe.inHandle.value, fe.outHandle.enabled = fe.inHandle.enabled, i.setKeyframeHandle(Le.id, Ee, fe.id, "out", { ...fe.outHandle })) : (fe.inHandle.frame = -fe.outHandle.frame, fe.inHandle.value = -fe.outHandle.value, fe.inHandle.enabled = fe.outHandle.enabled, i.setKeyframeHandle(Le.id, Ee, fe.id, "in", { ...fe.inHandle }))), fe.controlMode === "smooth")) {
        const W = _e === "in" ? fe.inHandle : fe.outHandle, ve = _e === "in" ? fe.outHandle : fe.inHandle, ye = _e === "in" ? "out" : "in";
        if (W.frame !== 0 || W.value !== 0) {
          const xe = Math.atan2(W.value, W.frame) + Math.PI, Ie = Math.hypot(ve.frame, ve.value);
          ve.frame = Math.cos(xe) * Ie, ve.value = Math.sin(xe) * Ie, i.setKeyframeHandle(Le.id, Ee, fe.id, ye, { ...ve });
        }
      }
    }
    function We() {
      w.value = null, document.removeEventListener("mousemove", Fe), document.removeEventListener("mouseup", We);
    }
    function ke(fe) {
      C.value = { x: fe.offsetX, y: fe.offsetY };
    }
    function nt() {
      if (!C.value) return;
      const fe = i.selectedLayer;
      if (!fe) return;
      const _e = Math.round(he(C.value.x)), Ee = le(C.value.y);
      if (D.value.length > 0) {
        const Le = D.value[0], W = Ae(Le), ve = typeof Le.value == "number" ? Ee : { x: Ee, y: Ee };
        i.addKeyframe(fe.id, W, ve, _e), rt();
      }
      C.value = null;
    }
    function Je() {
      const fe = i.selectedLayer;
      if (fe) {
        for (const _e of g.value) {
          const Ee = N.value.find((Le) => Le.id === _e.propId);
          if (Ee) {
            const Le = Ae(Ee);
            i.removeKeyframe(fe.id, Le, _e.keyframe.id);
          }
        }
        g.value = [], rt();
      }
    }
    function _t() {
      E.value = g.value.map((fe) => ({ ...fe.keyframe }));
    }
    function we() {
      var W, ve;
      if (!E.value || D.value.length === 0) return;
      const fe = i.selectedLayer;
      if (!fe) return;
      const _e = D.value[0], Ee = Ae(_e), Le = i.currentFrame - E.value[0].frame;
      for (const ye of E.value) {
        const Ce = ye.frame + Le, xe = i.addKeyframe(fe.id, Ee, ye.value, Ce);
        xe && (ye.interpolation !== "linear" && i.setKeyframeInterpolation(fe.id, Ee, xe.id, ye.interpolation), (W = ye.inHandle) != null && W.enabled && i.setKeyframeHandle(fe.id, Ee, xe.id, "in", ye.inHandle), (ve = ye.outHandle) != null && ve.enabled && i.setKeyframeHandle(fe.id, Ee, xe.id, "out", ye.outHandle));
      }
      rt();
    }
    function ze() {
      g.value = [];
      for (const fe of D.value)
        for (let _e = 0; _e < fe.keyframes.length; _e++)
          g.value.push({ propId: fe.id, index: _e, keyframe: fe.keyframes[_e] });
    }
    function De() {
      const fe = [];
      for (const _e of D.value)
        for (let Ee = 0; Ee < _e.keyframes.length; Ee++)
          I(_e.id, Ee) || fe.push({ propId: _e.id, index: Ee, keyframe: _e.keyframes[Ee] });
      g.value = fe;
    }
    function Be(fe) {
      const _e = parseInt(fe.target.value);
      g.value.length > 0 && !isNaN(_e) && (g.value[0].keyframe.frame = _e, rt());
    }
    function je(fe) {
      const _e = parseFloat(fe.target.value);
      if (g.value.length > 0 && !isNaN(_e)) {
        const Ee = g.value[0].keyframe;
        typeof Ee.value == "number" ? Ee.value = _e : typeof Ee.value == "object" && (Ee.value.x = _e), rt();
      }
    }
    function Ve(fe) {
      const _e = fe.target.value;
      g.value.length > 0 && (g.value[0].keyframe.interpolation = _e, rt());
    }
    function lt(fe) {
      var W;
      const _e = (W = l.value) == null ? void 0 : W.getBoundingClientRect();
      if (!_e) return;
      const Ee = fe.clientX - _e.left, Le = Math.round(he(Ee));
      i.setFrame(Le);
    }
    function rt() {
      ut(), sn(), Un();
    }
    function ut() {
      const fe = r.value;
      if (!fe) return;
      const _e = fe.getContext("2d");
      if (_e) {
        fe.width = d.value, fe.height = h.value, _e.fillStyle = "#1a1a1a", _e.fillRect(0, 0, d.value, h.value), pt(_e);
        for (const Ee of D.value)
          Kt(_e, Ee);
      }
    }
    function pt(fe) {
      const _e = d.value - b.left - b.right, Ee = h.value - b.top - b.bottom;
      fe.strokeStyle = "#2a2a2a", fe.lineWidth = 1;
      const Le = p.frameEnd - p.frameStart, W = Ot(Le, _e, 50), ve = p.valueMax - p.valueMin, ye = Ot(ve, Ee, 30), Ce = Math.ceil(p.frameStart / W) * W;
      for (let Ie = Ce; Ie <= p.frameEnd; Ie += W) {
        const Re = G(Ie);
        fe.beginPath(), fe.moveTo(Re, b.top), fe.lineTo(Re, h.value - b.bottom), fe.stroke();
      }
      const xe = Math.ceil(p.valueMin / ye) * ye;
      for (let Ie = xe; Ie <= p.valueMax; Ie += ye) {
        const Re = ee(Ie);
        fe.beginPath(), fe.moveTo(b.left, Re), fe.lineTo(d.value - b.right, Re), fe.stroke();
      }
      if (fe.strokeStyle = "#3a3a3a", fe.lineWidth = 1, p.frameStart <= 0 && p.frameEnd >= 0) {
        const Ie = G(0);
        fe.beginPath(), fe.moveTo(Ie, b.top), fe.lineTo(Ie, h.value - b.bottom), fe.stroke();
      }
      if (p.valueMin <= 0 && p.valueMax >= 0) {
        const Ie = ee(0);
        fe.beginPath(), fe.moveTo(b.left, Ie), fe.lineTo(d.value - b.right, Ie), fe.stroke();
      }
    }
    function Ot(fe, _e, Ee) {
      const Le = fe * Ee / _e, W = Math.pow(10, Math.floor(Math.log10(Le))), ve = Le / W;
      return ve <= 1 ? W : ve <= 2 ? 2 * W : ve <= 5 ? 5 * W : 10 * W;
    }
    function Kt(fe, _e) {
      if (_e.keyframes.length < 2) return;
      const Ee = X(_e.id);
      for (let Le = 0; Le < 2; Le++) {
        Le === 0 ? (fe.strokeStyle = "#000", fe.lineWidth = 4) : (fe.strokeStyle = Ee, fe.lineWidth = 2), fe.beginPath();
        let W = !1;
        for (let ve = 0; ve < _e.keyframes.length - 1; ve++) {
          const ye = _e.keyframes[ve], Ce = _e.keyframes[ve + 1];
          if (Ce.frame < p.frameStart || ye.frame > p.frameEnd) continue;
          const xe = oe(ye), Ie = Y(_e, ye), Re = oe(Ce), Qe = Y(_e, Ce);
          if (W || (fe.moveTo(xe, Ie), W = !0), ye.interpolation === "hold")
            fe.lineTo(Re, Ie), fe.lineTo(Re, Qe);
          else if (ye.interpolation === "linear" || !ye.outHandle.enabled && !Ce.inHandle.enabled)
            fe.lineTo(Re, Qe);
          else {
            const it = G(ye.frame + ye.outHandle.frame), mt = ee(H(ye.value) + ye.outHandle.value), gt = G(Ce.frame + Ce.inHandle.frame), ot = ee(H(Ce.value) + Ce.inHandle.value);
            fe.bezierCurveTo(it, mt, gt, ot, Re, Qe);
          }
        }
        fe.stroke();
      }
    }
    function sn() {
      var Ce;
      const fe = l.value;
      if (!fe) return;
      const _e = (Ce = a.value) == null ? void 0 : Ce.getBoundingClientRect();
      if (!_e) return;
      fe.width = _e.width, fe.height = 24;
      const Ee = fe.getContext("2d");
      if (!Ee) return;
      Ee.fillStyle = "#252525", Ee.fillRect(0, 0, fe.width, fe.height);
      const Le = p.frameEnd - p.frameStart, W = Ot(Le, fe.width, 60);
      Ee.fillStyle = "#888", Ee.font = "10px system-ui", Ee.textAlign = "center";
      const ve = Math.ceil(p.frameStart / W) * W;
      for (let xe = ve; xe <= p.frameEnd; xe += W) {
        const Ie = G(xe);
        Ee.fillText(xe.toString(), Ie, 16), Ee.strokeStyle = "#444", Ee.beginPath(), Ee.moveTo(Ie, 20), Ee.lineTo(Ie, 24), Ee.stroke();
      }
      const ye = G(i.currentFrame);
      Ee.fillStyle = "#ff4444", Ee.beginPath(), Ee.moveTo(ye - 5, 0), Ee.lineTo(ye + 5, 0), Ee.lineTo(ye, 8), Ee.closePath(), Ee.fill();
    }
    function Un() {
      var ye;
      const fe = u.value;
      if (!fe) return;
      const _e = (ye = c.value) == null ? void 0 : ye.getBoundingClientRect();
      if (!_e) return;
      fe.width = 40, fe.height = _e.height;
      const Ee = fe.getContext("2d");
      if (!Ee) return;
      Ee.fillStyle = "#252525", Ee.fillRect(0, 0, fe.width, fe.height);
      const Le = p.valueMax - p.valueMin, W = Ot(Le, fe.height, 30);
      Ee.fillStyle = "#888", Ee.font = "10px system-ui", Ee.textAlign = "right";
      const ve = Math.ceil(p.valueMin / W) * W;
      for (let Ce = ve; Ce <= p.valueMax; Ce += W) {
        const xe = ee(Ce);
        Ee.fillText(Ce.toFixed(0), 36, xe + 4);
      }
    }
    function xn(fe = "both") {
      for (const _e of g.value) {
        const Ee = N.value.find((Re) => Re.id === _e.propId);
        if (!Ee) continue;
        const Le = _e.keyframe, W = _e.index, ve = W > 0 ? Ee.keyframes[W - 1] : null, ye = W < Ee.keyframes.length - 1 ? Ee.keyframes[W + 1] : null, Ce = ve ? Le.frame - ve.frame : 10, xe = ye ? ye.frame - Le.frame : 10, Ie = 0.3333;
        (fe === "both" || fe === "in") && (Le.inHandle = {
          frame: -Ce * Ie,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), (fe === "both" || fe === "out") && (Le.outHandle = {
          frame: xe * Ie,
          value: 0,
          // 0 velocity at keyframe
          enabled: !0
        }), Le.interpolation = "bezier", Le.controlMode = "smooth";
      }
      rt();
    }
    function Yn() {
      const fe = i.currentFrame, _e = [];
      for (const Le of D.value)
        for (const W of Le.keyframes)
          _e.includes(W.frame) || _e.push(W.frame);
      _e.sort((Le, W) => Le - W);
      const Ee = [..._e].reverse().find((Le) => Le < fe);
      Ee !== void 0 && i.setFrame(Ee);
    }
    function hi() {
      const fe = i.currentFrame, _e = [];
      for (const Le of D.value)
        for (const W of Le.keyframes)
          _e.includes(W.frame) || _e.push(W.frame);
      _e.sort((Le, W) => Le - W);
      const Ee = _e.find((Le) => Le > fe);
      Ee !== void 0 && i.setFrame(Ee);
    }
    function fi(fe) {
      if (fe.key === "F9") {
        fe.preventDefault(), fe.ctrlKey && fe.shiftKey ? xn("out") : fe.shiftKey ? xn("in") : xn("both");
        return;
      }
      if (fe.key.toLowerCase() === "j") {
        fe.preventDefault(), Yn();
        return;
      }
      if (fe.key.toLowerCase() === "k") {
        fe.preventDefault(), hi();
        return;
      }
      if (fe.key === "Delete" || fe.key === "Backspace") {
        fe.preventDefault(), Je();
        return;
      }
      if (fe.key.toLowerCase() === "f" && !fe.ctrlKey) {
        fe.preventDefault(), fe.shiftKey ? ie() : g.value.length > 0 ? On() : ie();
        return;
      }
      if (fe.key === "=" || fe.key === "+") {
        fe.preventDefault(), bn();
        return;
      }
      if (fe.key === "-" || fe.key === "_") {
        fe.preventDefault(), ni();
        return;
      }
    }
    function On() {
      if (g.value.length === 0) {
        ie();
        return;
      }
      let fe = 1 / 0, _e = -1 / 0, Ee = 1 / 0, Le = -1 / 0;
      for (const ye of g.value) {
        fe = Math.min(fe, ye.keyframe.frame), _e = Math.max(_e, ye.keyframe.frame);
        const Ce = H(ye.keyframe.value);
        Ee = Math.min(Ee, Ce), Le = Math.max(Le, Ce);
      }
      const W = (_e - fe) * 0.1 || 10, ve = (Le - Ee) * 0.1 || 10;
      p.frameStart = fe - W, p.frameEnd = _e + W, p.valueMin = Ee - ve, p.valueMax = Le + ve, rt();
    }
    function bn() {
      const fe = (p.frameStart + p.frameEnd) / 2, _e = p.frameEnd - p.frameStart;
      p.frameStart = fe - _e * 0.4, p.frameEnd = fe + _e * 0.4, rt();
    }
    function ni() {
      const fe = (p.frameStart + p.frameEnd) / 2, _e = p.frameEnd - p.frameStart;
      p.frameStart = fe - _e * 0.6, p.frameEnd = fe + _e * 0.6, rt();
    }
    let Pi = null;
    return _n(() => {
      o.value && (Pi = new ResizeObserver((fe) => {
        for (const _e of fe)
          d.value = _e.contentRect.width, h.value = _e.contentRect.height, rt();
      }), Pi.observe(o.value)), _.value = N.value.filter((fe) => fe.animated).map((fe) => fe.id), window.addEventListener("keydown", fi), ie(), rt();
    }), jn(() => {
      Pi == null || Pi.disconnect(), window.removeEventListener("keydown", fi);
    }), Ft([() => i.currentFrame, _, m], () => {
      rt();
    }), Ft(N, () => {
      ie(), rt();
    }, { deep: !0 }), (fe, _e) => {
      var Ee, Le;
      return re(), ae("div", N8, [
        f("div", B8, [
          _e[9] || (_e[9] = f("span", { class: "graph-title" }, "Graph Editor", -1)),
          f("div", V8, [
            f("button", {
              class: Ue({ active: m.value === "value" }),
              onClick: _e[0] || (_e[0] = (W) => m.value = "value"),
              title: "Value Graph"
            }, " Value ", 2),
            f("button", {
              class: Ue({ active: m.value === "speed" }),
              onClick: _e[1] || (_e[1] = (W) => m.value = "speed"),
              title: "Speed Graph"
            }, " Speed ", 2)
          ]),
          f("div", G8, [
            (re(), ae(Ze, null, at(L, (W) => f("button", {
              key: W.key,
              class: Ue(["preset-btn", { active: $(W.key) }]),
              onClick: (ve) => se(W.key),
              title: W.label
            }, be(W.shortLabel), 11, H8)), 64))
          ]),
          f("div", W8, [
            f("button", {
              onClick: ie,
              title: "Fit to View"
            }, [..._e[5] || (_e[5] = [
              f("span", { class: "icon" }, "[ ]", -1)
            ])]),
            f("button", {
              onClick: B,
              class: Ue({ active: T.value }),
              title: "Auto-select Nearby Keyframes"
            }, [..._e[6] || (_e[6] = [
              f("span", { class: "icon" }, "A", -1)
            ])], 2),
            f("button", {
              onClick: _e[2] || (_e[2] = (W) => P.value = !P.value),
              class: Ue({ active: P.value }),
              title: "Snap to Grid"
            }, [..._e[7] || (_e[7] = [
              f("span", { class: "icon" }, "#", -1)
            ])], 2)
          ]),
          f("button", {
            class: "close-btn",
            onClick: _e[3] || (_e[3] = (W) => n("close"))
          }, [..._e[8] || (_e[8] = [
            f("span", { class: "icon" }, "X", -1)
          ])])
        ]),
        f("div", $8, [
          f("div", X8, [
            f("div", j8, [
              _e[10] || (_e[10] = ft(" Properties ", -1)),
              f("button", {
                class: "toggle-all-btn",
                onClick: Z,
                title: O.value ? "Hide All" : "Show All"
              }, be(O.value ? "Hide" : "Show"), 9, Y8)
            ]),
            (re(!0), ae(Ze, null, at(N.value, (W) => (re(), ae("div", {
              key: W.id,
              class: Ue(["property-item", {
                selected: y.value.includes(W.id),
                animated: W.animated
              }])
            }, [
              f("div", {
                class: "property-row",
                onClick: (ve) => k(W.id)
              }, [
                f("span", {
                  class: Ue(["visibility-toggle", { visible: _.value.includes(W.id) }]),
                  onClick: wt((ve) => Q(W.id), ["stop"])
                }, null, 10, Z8),
                f("span", {
                  class: "property-color",
                  style: bt({ background: X(W.id) })
                }, null, 4),
                f("span", K8, be(W.name), 1),
                W.animated ? (re(), ae("span", J8, be(W.keyframes.length), 1)) : Pe("", !0)
              ], 8, q8),
              W.name === "Position" || W.name === "Scale" ? (re(), ae("div", Q8, [
                (re(), ae(Ze, null, at(["x", "y", "z"], (ve) => {
                  var ye;
                  return f("button", {
                    key: ve,
                    class: Ue({
                      active: (ye = v.value[W.id]) == null ? void 0 : ye.includes(ve),
                      hasValue: F(W, ve)
                    }),
                    onClick: (Ce) => R(W.id, ve)
                  }, be(ve.toUpperCase()), 11, eB);
                }), 64))
              ])) : Pe("", !0)
            ], 2))), 128)),
            N.value.length === 0 ? (re(), ae("div", tB, " No animated properties ")) : Pe("", !0)
          ]),
          f("div", nB, [
            f("div", {
              class: "time-ruler",
              ref_key: "timeRulerRef",
              ref: a
            }, [
              f("canvas", {
                ref_key: "timeRulerCanvas",
                ref: l,
                onClick: lt
              }, null, 512)
            ], 512),
            f("div", {
              class: "graph-canvas-container",
              ref_key: "canvasContainerRef",
              ref: o
            }, [
              f("canvas", {
                ref_key: "canvasRef",
                ref: r,
                onMousedown: U,
                onMousemove: z,
                onMouseup: K,
                onMouseleave: K,
                onWheel: ue,
                onContextmenu: wt(ke, ["prevent"])
              }, null, 544),
              x.value ? (re(), ae("div", {
                key: 0,
                class: "selection-box",
                style: bt({
                  left: x.value.x + "px",
                  top: x.value.y + "px",
                  width: x.value.width + "px",
                  height: x.value.height + "px"
                })
              }, null, 4)) : Pe("", !0),
              (re(), ae("svg", {
                class: "handle-overlay",
                viewBox: `0 0 ${d.value} ${h.value}`
              }, [
                (re(!0), ae(Ze, null, at(D.value, (W) => (re(), ae("g", {
                  key: W.id,
                  class: "property-handles"
                }, [
                  (re(!0), ae(Ze, null, at(W.keyframes, (ve, ye) => {
                    var Ce, xe, Ie, Re, Qe, it, mt, gt;
                    return re(), ae(Ze, { key: ye }, [
                      V(ve) ? (re(), ae("g", {
                        key: 0,
                        class: Ue(["keyframe-marker", {
                          selected: I(W.id, ye),
                          hovered: ((Ce = S.value) == null ? void 0 : Ce.propId) === W.id && ((xe = S.value) == null ? void 0 : xe.index) === ye
                        }]),
                        onMousedown: wt((ot) => ge(W.id, ye, ot), ["stop"])
                      }, [
                        f("rect", {
                          x: oe(ve) - 5,
                          y: Y(W, ve) - 5,
                          width: "10",
                          height: "10",
                          fill: X(W.id),
                          "transform-origin": "center",
                          transform: `rotate(45, ${oe(ve)}, ${Y(W, ve)})`
                        }, null, 8, rB)
                      ], 42, sB)) : Pe("", !0),
                      I(W.id, ye) && ve.interpolation !== "hold" ? (re(), ae("g", oB, [
                        W.keyframes[ye + 1] && (ve.outHandle.enabled || ve.interpolation === "bezier") ? (re(), ae("g", aB, [
                          f("line", {
                            x1: oe(ve),
                            y1: Y(W, ve),
                            x2: q(W, ye),
                            y2: te(W, ye),
                            class: "handle-line"
                          }, null, 8, lB),
                          f("circle", {
                            cx: q(W, ye),
                            cy: te(W, ye),
                            r: "5",
                            class: Ue(["handle-point", { dragging: ((Ie = w.value) == null ? void 0 : Ie.type) === "outHandle" && ((Re = w.value) == null ? void 0 : Re.propId) === W.id && ((Qe = w.value) == null ? void 0 : Qe.index) === ye }]),
                            onMousedown: wt((ot) => Xe("outHandle", W.id, ye), ["stop"])
                          }, null, 42, cB)
                        ])) : Pe("", !0),
                        ye > 0 && (ve.inHandle.enabled || ve.interpolation === "bezier") ? (re(), ae("g", uB, [
                          f("line", {
                            x1: oe(ve),
                            y1: Y(W, ve),
                            x2: ne(W, ye),
                            y2: de(W, ye),
                            class: "handle-line"
                          }, null, 8, dB),
                          f("circle", {
                            cx: ne(W, ye),
                            cy: de(W, ye),
                            r: "5",
                            class: Ue(["handle-point", { dragging: ((it = w.value) == null ? void 0 : it.type) === "inHandle" && ((mt = w.value) == null ? void 0 : mt.propId) === W.id && ((gt = w.value) == null ? void 0 : gt.index) === ye }]),
                            onMousedown: wt((ot) => Xe("inHandle", W.id, ye), ["stop"])
                          }, null, 42, hB)
                        ])) : Pe("", !0)
                      ])) : Pe("", !0)
                    ], 64);
                  }), 128))
                ]))), 128)),
                f("line", {
                  x1: A.value,
                  y1: 0,
                  x2: A.value,
                  y2: h.value,
                  class: "current-time-line"
                }, null, 8, fB)
              ], 8, iB))
            ], 512),
            f("div", {
              class: "value-axis",
              ref_key: "valueAxisRef",
              ref: c
            }, [
              f("canvas", {
                ref_key: "valueAxisCanvas",
                ref: u
              }, null, 512)
            ], 512)
          ])
        ]),
        g.value.length > 0 ? (re(), ae("div", pB, [
          f("div", mB, [
            _e[11] || (_e[11] = f("span", { class: "info-label" }, "Frame:", -1)),
            f("input", {
              type: "number",
              value: (Ee = g.value[0]) == null ? void 0 : Ee.keyframe.frame,
              onChange: Be,
              class: "info-input"
            }, null, 40, vB)
          ]),
          f("div", gB, [
            _e[12] || (_e[12] = f("span", { class: "info-label" }, "Value:", -1)),
            f("input", {
              type: "number",
              value: j(g.value[0]),
              onChange: je,
              class: "info-input",
              step: "0.1"
            }, null, 40, yB)
          ]),
          f("div", _B, [
            _e[14] || (_e[14] = f("span", { class: "info-label" }, "Interpolation:", -1)),
            f("select", {
              value: (Le = g.value[0]) == null ? void 0 : Le.keyframe.interpolation,
              onChange: Ve,
              class: "info-select"
            }, [..._e[13] || (_e[13] = [
              f("option", { value: "linear" }, "Linear", -1),
              f("option", { value: "bezier" }, "Bezier", -1),
              f("option", { value: "hold" }, "Hold", -1)
            ])], 40, xB)
          ])
        ])) : Pe("", !0),
        C.value ? (re(), ae("div", {
          key: 1,
          class: "context-menu",
          style: bt({ left: C.value.x + "px", top: C.value.y + "px" }),
          onClick: _e[4] || (_e[4] = (W) => C.value = null)
        }, [
          f("button", { onClick: nt }, "Add Keyframe"),
          f("button", {
            onClick: Je,
            disabled: g.value.length === 0
          }, "Delete Keyframe(s)", 8, bB),
          _e[15] || (_e[15] = f("hr", null, null, -1)),
          f("button", {
            onClick: _t,
            disabled: g.value.length === 0
          }, "Copy", 8, wB),
          f("button", {
            onClick: we,
            disabled: !E.value
          }, "Paste", 8, SB),
          _e[16] || (_e[16] = f("hr", null, null, -1)),
          f("button", { onClick: ze }, "Select All"),
          f("button", { onClick: De }, "Invert Selection")
        ], 4)) : Pe("", !0)
      ]);
    };
  }
}), CB = /* @__PURE__ */ Bt(MB, [["__scopeId", "data-v-70deec8d"]]), { abs: ma, cos: ps, sin: ho, acos: EB, atan2: va, sqrt: Hs, pow: Mi } = Math;
function ga(s) {
  return s < 0 ? -Mi(-s, 1 / 3) : Mi(s, 1 / 3);
}
const Ay = Math.PI, fc = 2 * Ay, Ws = Ay / 2, TB = 1e-6, Ud = Number.MAX_SAFE_INTEGER || 9007199254740991, Od = Number.MIN_SAFE_INTEGER || -9007199254740991, AB = { x: 0, y: 0, z: 0 }, Ke = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(s, e) {
    const n = e(s);
    let i = n.x * n.x + n.y * n.y;
    return typeof n.z < "u" && (i += n.z * n.z), Hs(i);
  },
  compute: function(s, e, n) {
    if (s === 0)
      return e[0].t = 0, e[0];
    const i = e.length - 1;
    if (s === 1)
      return e[i].t = 1, e[i];
    const r = 1 - s;
    let o = e;
    if (i === 0)
      return e[0].t = s, e[0];
    if (i === 1) {
      const l = {
        x: r * o[0].x + s * o[1].x,
        y: r * o[0].y + s * o[1].y,
        t: s
      };
      return n && (l.z = r * o[0].z + s * o[1].z), l;
    }
    if (i < 4) {
      let l = r * r, c = s * s, u, d, h, m = 0;
      i === 2 ? (o = [o[0], o[1], o[2], AB], u = l, d = r * s * 2, h = c) : i === 3 && (u = l * r, d = l * s * 3, h = r * c * 3, m = s * c);
      const p = {
        x: u * o[0].x + d * o[1].x + h * o[2].x + m * o[3].x,
        y: u * o[0].y + d * o[1].y + h * o[2].y + m * o[3].y,
        t: s
      };
      return n && (p.z = u * o[0].z + d * o[1].z + h * o[2].z + m * o[3].z), p;
    }
    const a = JSON.parse(JSON.stringify(e));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * s,
          y: a[l].y + (a[l + 1].y - a[l].y) * s
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * s);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = s, a[0];
  },
  computeWithRatios: function(s, e, n, i) {
    const r = 1 - s, o = n, a = e;
    let l = o[0], c = o[1], u = o[2], d = o[3], h;
    if (l *= r, c *= s, a.length === 2)
      return h = l + c, {
        x: (l * a[0].x + c * a[1].x) / h,
        y: (l * a[0].y + c * a[1].y) / h,
        z: i ? (l * a[0].z + c * a[1].z) / h : !1,
        t: s
      };
    if (l *= r, c *= 2 * r, u *= s * s, a.length === 3)
      return h = l + c + u, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y) / h,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z) / h : !1,
        t: s
      };
    if (l *= r, c *= 1.5 * r, u *= 3 * r, d *= s * s * s, a.length === 4)
      return h = l + c + u + d, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x + d * a[3].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y + d * a[3].y) / h,
        z: i ? (l * a[0].z + c * a[1].z + u * a[2].z + d * a[3].z) / h : !1,
        t: s
      };
  },
  derive: function(s, e) {
    const n = [];
    for (let i = s, r = i.length, o = r - 1; r > 1; r--, o--) {
      const a = [];
      for (let l = 0, c; l < o; l++)
        c = {
          x: o * (i[l + 1].x - i[l].x),
          y: o * (i[l + 1].y - i[l].y)
        }, e && (c.z = o * (i[l + 1].z - i[l].z)), a.push(c);
      n.push(a), i = a;
    }
    return n;
  },
  between: function(s, e, n) {
    return e <= s && s <= n || Ke.approximately(s, e) || Ke.approximately(s, n);
  },
  approximately: function(s, e, n) {
    return ma(s - e) <= (n || TB);
  },
  length: function(s) {
    const n = Ke.Tvalues.length;
    let i = 0;
    for (let r = 0, o; r < n; r++)
      o = 0.5 * Ke.Tvalues[r] + 0.5, i += Ke.Cvalues[r] * Ke.arcfn(o, s);
    return 0.5 * i;
  },
  map: function(s, e, n, i, r) {
    const o = n - e, a = r - i, l = s - e, c = l / o;
    return i + a * c;
  },
  lerp: function(s, e, n) {
    const i = {
      x: e.x + s * (n.x - e.x),
      y: e.y + s * (n.y - e.y)
    };
    return e.z !== void 0 && n.z !== void 0 && (i.z = e.z + s * (n.z - e.z)), i;
  },
  pointToString: function(s) {
    let e = s.x + "/" + s.y;
    return typeof s.z < "u" && (e += "/" + s.z), e;
  },
  pointsToString: function(s) {
    return "[" + s.map(Ke.pointToString).join(", ") + "]";
  },
  copy: function(s) {
    return JSON.parse(JSON.stringify(s));
  },
  angle: function(s, e, n) {
    const i = e.x - s.x, r = e.y - s.y, o = n.x - s.x, a = n.y - s.y, l = i * a - r * o, c = i * o + r * a;
    return va(l, c);
  },
  // round as string, to avoid rounding errors
  round: function(s, e) {
    const n = "" + s, i = n.indexOf(".");
    return parseFloat(n.substring(0, i + 1 + e));
  },
  dist: function(s, e) {
    const n = s.x - e.x, i = s.y - e.y;
    return Hs(n * n + i * i);
  },
  closest: function(s, e) {
    let n = Mi(2, 63), i, r;
    return s.forEach(function(o, a) {
      r = Ke.dist(e, o), r < n && (n = r, i = a);
    }), { mdist: n, mpos: i };
  },
  abcratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = Mi(s, e) + Mi(1 - s, e), i = n - 1;
    return ma(i / n);
  },
  projectionratio: function(s, e) {
    if (e !== 2 && e !== 3)
      return !1;
    if (typeof s > "u")
      s = 0.5;
    else if (s === 0 || s === 1)
      return s;
    const n = Mi(1 - s, e), i = Mi(s, e) + n;
    return n / i;
  },
  lli8: function(s, e, n, i, r, o, a, l) {
    const c = (s * i - e * n) * (r - a) - (s - n) * (r * l - o * a), u = (s * i - e * n) * (o - l) - (e - i) * (r * l - o * a), d = (s - n) * (o - l) - (e - i) * (r - a);
    return d == 0 ? !1 : { x: c / d, y: u / d };
  },
  lli4: function(s, e, n, i) {
    const r = s.x, o = s.y, a = e.x, l = e.y, c = n.x, u = n.y, d = i.x, h = i.y;
    return Ke.lli8(r, o, a, l, c, u, d, h);
  },
  lli: function(s, e) {
    return Ke.lli4(s, s.c, e, e.c);
  },
  makeline: function(s, e) {
    return new Py(
      s.x,
      s.y,
      (s.x + e.x) / 2,
      (s.y + e.y) / 2,
      e.x,
      e.y
    );
  },
  findbbox: function(s) {
    let e = Ud, n = Ud, i = Od, r = Od;
    return s.forEach(function(o) {
      const a = o.bbox();
      e > a.x.min && (e = a.x.min), n > a.y.min && (n = a.y.min), i < a.x.max && (i = a.x.max), r < a.y.max && (r = a.y.max);
    }), {
      x: { min: e, mid: (e + i) / 2, max: i, size: i - e },
      y: { min: n, mid: (n + r) / 2, max: r, size: r - n }
    };
  },
  shapeintersections: function(s, e, n, i, r) {
    if (!Ke.bboxoverlap(e, i)) return [];
    const o = [], a = [s.startcap, s.forward, s.back, s.endcap], l = [n.startcap, n.forward, n.back, n.endcap];
    return a.forEach(function(c) {
      c.virtual || l.forEach(function(u) {
        if (u.virtual) return;
        const d = c.intersects(u, r);
        d.length > 0 && (d.c1 = c, d.c2 = u, d.s1 = s, d.s2 = n, o.push(d));
      });
    }), o;
  },
  makeshape: function(s, e, n) {
    const i = e.points.length, r = s.points.length, o = Ke.makeline(e.points[i - 1], s.points[0]), a = Ke.makeline(s.points[r - 1], e.points[0]), l = {
      startcap: o,
      forward: s,
      back: e,
      endcap: a,
      bbox: Ke.findbbox([o, s, e, a])
    };
    return l.intersections = function(c) {
      return Ke.shapeintersections(
        l,
        l.bbox,
        c,
        c.bbox,
        n
      );
    }, l;
  },
  getminmax: function(s, e, n) {
    if (!n) return { min: 0, max: 0 };
    let i = Ud, r = Od, o, a;
    n.indexOf(0) === -1 && (n = [0].concat(n)), n.indexOf(1) === -1 && n.push(1);
    for (let l = 0, c = n.length; l < c; l++)
      o = n[l], a = s.get(o), a[e] < i && (i = a[e]), a[e] > r && (r = a[e]);
    return { min: i, mid: (i + r) / 2, max: r, size: r - i };
  },
  align: function(s, e) {
    const n = e.p1.x, i = e.p1.y, r = -va(e.p2.y - i, e.p2.x - n), o = function(a) {
      return {
        x: (a.x - n) * ps(r) - (a.y - i) * ho(r),
        y: (a.x - n) * ho(r) + (a.y - i) * ps(r)
      };
    };
    return s.map(o);
  },
  roots: function(s, e) {
    e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const n = s.length - 1, i = Ke.align(s, e), r = function(P) {
      return 0 <= P && P <= 1;
    };
    if (n === 2) {
      const P = i[0].y, T = i[1].y, b = i[2].y, M = P - 2 * T + b;
      if (M !== 0) {
        const L = -Hs(T * T - P * b), N = -P + T, D = -(L + N) / M, O = -(-L + N) / M;
        return [D, O].filter(r);
      } else if (T !== b && M === 0)
        return [(2 * T - b) / (2 * T - 2 * b)].filter(r);
      return [];
    }
    const o = i[0].y, a = i[1].y, l = i[2].y, c = i[3].y;
    let u = -o + 3 * a - 3 * l + c, d = 3 * o - 6 * a + 3 * l, h = -3 * o + 3 * a, m = o;
    if (Ke.approximately(u, 0)) {
      if (Ke.approximately(d, 0))
        return Ke.approximately(h, 0) ? [] : [-m / h].filter(r);
      const P = Hs(h * h - 4 * d * m), T = 2 * d;
      return [(P - h) / T, (-h - P) / T].filter(r);
    }
    d /= u, h /= u, m /= u;
    const p = (3 * h - d * d) / 3, y = p / 3, _ = (2 * d * d * d - 9 * d * h + 27 * m) / 27, v = _ / 2, g = v * v + y * y * y;
    let S, w, x, C, E;
    if (g < 0) {
      const P = -p / 3, T = P * P * P, b = Hs(T), M = -_ / (2 * b), L = M < -1 ? -1 : M > 1 ? 1 : M, N = EB(L), D = ga(b), O = 2 * D;
      return x = O * ps(N / 3) - d / 3, C = O * ps((N + fc) / 3) - d / 3, E = O * ps((N + 2 * fc) / 3) - d / 3, [x, C, E].filter(r);
    } else {
      if (g === 0)
        return S = v < 0 ? ga(-v) : -ga(v), x = 2 * S - d / 3, C = -S - d / 3, [x, C].filter(r);
      {
        const P = Hs(g);
        return S = ga(-v + P), w = ga(v + P), [S - w - d / 3].filter(r);
      }
    }
  },
  droots: function(s) {
    if (s.length === 3) {
      const e = s[0], n = s[1], i = s[2], r = e - 2 * n + i;
      if (r !== 0) {
        const o = -Hs(n * n - e * i), a = -e + n, l = -(o + a) / r, c = -(-o + a) / r;
        return [l, c];
      } else if (n !== i && r === 0)
        return [(2 * n - i) / (2 * (n - i))];
      return [];
    }
    if (s.length === 2) {
      const e = s[0], n = s[1];
      return e !== n ? [e / (e - n)] : [];
    }
    return [];
  },
  curvature: function(s, e, n, i, r) {
    let o, a, l, c, u = 0, d = 0;
    const h = Ke.compute(s, e), m = Ke.compute(s, n), p = h.x * h.x + h.y * h.y;
    if (i ? (o = Hs(
      Mi(h.y * m.z - m.y * h.z, 2) + Mi(h.z * m.x - m.z * h.x, 2) + Mi(h.x * m.y - m.x * h.y, 2)
    ), a = Mi(p + h.z * h.z, 3 / 2)) : (o = h.x * m.y - h.y * m.x, a = Mi(p, 3 / 2)), o === 0 || a === 0)
      return { k: 0, r: 0 };
    if (u = o / a, d = a / o, !r) {
      const y = Ke.curvature(s - 1e-3, e, n, i, !0).k, _ = Ke.curvature(s + 1e-3, e, n, i, !0).k;
      c = (_ - u + (u - y)) / 2, l = (ma(_ - u) + ma(u - y)) / 2;
    }
    return { k: u, r: d, dk: c, adk: l };
  },
  inflections: function(s) {
    if (s.length < 4) return [];
    const e = Ke.align(s, { p1: s[0], p2: s.slice(-1)[0] }), n = e[2].x * e[1].y, i = e[3].x * e[1].y, r = e[1].x * e[2].y, o = e[3].x * e[2].y, a = 18 * (-3 * n + 2 * i + 3 * r - o), l = 18 * (3 * n - i - 3 * r), c = 18 * (r - n);
    if (Ke.approximately(a, 0)) {
      if (!Ke.approximately(l, 0)) {
        let m = -c / l;
        if (0 <= m && m <= 1) return [m];
      }
      return [];
    }
    const u = 2 * a;
    if (Ke.approximately(u, 0)) return [];
    const d = l * l - 4 * a * c;
    if (d < 0) return [];
    const h = Math.sqrt(d);
    return [(h - l) / u, -(l + h) / u].filter(function(m) {
      return 0 <= m && m <= 1;
    });
  },
  bboxoverlap: function(s, e) {
    const n = ["x", "y"], i = n.length;
    for (let r = 0, o, a, l, c; r < i; r++)
      if (o = n[r], a = s[o].mid, l = e[o].mid, c = (s[o].size + e[o].size) / 2, ma(a - l) >= c) return !1;
    return !0;
  },
  expandbox: function(s, e) {
    e.x.min < s.x.min && (s.x.min = e.x.min), e.y.min < s.y.min && (s.y.min = e.y.min), e.z && e.z.min < s.z.min && (s.z.min = e.z.min), e.x.max > s.x.max && (s.x.max = e.x.max), e.y.max > s.y.max && (s.y.max = e.y.max), e.z && e.z.max > s.z.max && (s.z.max = e.z.max), s.x.mid = (s.x.min + s.x.max) / 2, s.y.mid = (s.y.min + s.y.max) / 2, s.z && (s.z.mid = (s.z.min + s.z.max) / 2), s.x.size = s.x.max - s.x.min, s.y.size = s.y.max - s.y.min, s.z && (s.z.size = s.z.max - s.z.min);
  },
  pairiteration: function(s, e, n) {
    const i = s.bbox(), r = e.bbox(), o = 1e5, a = n || 0.5;
    if (i.x.size + i.y.size < a && r.x.size + r.y.size < a)
      return [
        (o * (s._t1 + s._t2) / 2 | 0) / o + "/" + (o * (e._t1 + e._t2) / 2 | 0) / o
      ];
    let l = s.split(0.5), c = e.split(0.5), u = [
      { left: l.left, right: c.left },
      { left: l.left, right: c.right },
      { left: l.right, right: c.right },
      { left: l.right, right: c.left }
    ];
    u = u.filter(function(h) {
      return Ke.bboxoverlap(h.left.bbox(), h.right.bbox());
    });
    let d = [];
    return u.length === 0 || (u.forEach(function(h) {
      d = d.concat(
        Ke.pairiteration(h.left, h.right, a)
      );
    }), d = d.filter(function(h, m) {
      return d.indexOf(h) === m;
    })), d;
  },
  getccenter: function(s, e, n) {
    const i = e.x - s.x, r = e.y - s.y, o = n.x - e.x, a = n.y - e.y, l = i * ps(Ws) - r * ho(Ws), c = i * ho(Ws) + r * ps(Ws), u = o * ps(Ws) - a * ho(Ws), d = o * ho(Ws) + a * ps(Ws), h = (s.x + e.x) / 2, m = (s.y + e.y) / 2, p = (e.x + n.x) / 2, y = (e.y + n.y) / 2, _ = h + l, v = m + c, g = p + u, S = y + d, w = Ke.lli8(h, m, _, v, p, y, g, S), x = Ke.dist(w, s);
    let C = va(s.y - w.y, s.x - w.x), E = va(e.y - w.y, e.x - w.x), P = va(n.y - w.y, n.x - w.x), T;
    return C < P ? ((C > E || E > P) && (C += fc), C > P && (T = P, P = C, C = T)) : P < E && E < C ? (T = P, P = C, C = T) : P += fc, w.s = C, w.e = P, w.r = x, w;
  },
  numberSort: function(s, e) {
    return s - e;
  }
};
class Wa {
  constructor(e) {
    this.curves = [], this._3d = !1, e && (this.curves = e, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(e) {
      return Ke.pointsToString(e.points);
    }).join(", ") + "]";
  }
  addCurve(e) {
    this.curves.push(e), this._3d = this._3d || e._3d;
  }
  length() {
    return this.curves.map(function(e) {
      return e.length();
    }).reduce(function(e, n) {
      return e + n;
    });
  }
  curve(e) {
    return this.curves[e];
  }
  bbox() {
    const e = this.curves;
    for (var n = e[0].bbox(), i = 1; i < e.length; i++)
      Ke.expandbox(n, e[i].bbox());
    return n;
  }
  offset(e) {
    const n = [];
    return this.curves.forEach(function(i) {
      n.push(...i.offset(e));
    }), new Wa(n);
  }
}
const { abs: ya, min: Wv, max: $v, cos: PB, sin: DB, acos: RB, sqrt: _a } = Math, IB = Math.PI;
let Py = class dn {
  constructor(e) {
    let n = e && e.forEach ? e : Array.from(arguments).slice(), i = !1;
    if (typeof n[0] == "object") {
      i = n.length;
      const p = [];
      n.forEach(function(y) {
        ["x", "y", "z"].forEach(function(_) {
          typeof y[_] < "u" && p.push(y[_]);
        });
      }), n = p;
    }
    let r = !1;
    const o = n.length;
    if (i) {
      if (i > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        r = !0;
      }
    } else if (o !== 6 && o !== 8 && o !== 9 && o !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !r && (o === 9 || o === 12) || e && e[0] && typeof e[0].z < "u", l = this.points = [];
    for (let p = 0, y = a ? 3 : 2; p < o; p += y) {
      var c = {
        x: n[p],
        y: n[p + 1]
      };
      a && (c.z = n[p + 2]), l.push(c);
    }
    const u = this.order = l.length - 1, d = this.dims = ["x", "y"];
    a && d.push("z"), this.dimlen = d.length;
    const h = Ke.align(l, { p1: l[0], p2: l[u] }), m = Ke.dist(l[0], l[u]);
    this._linear = h.reduce((p, y) => p + ya(y.y), 0) < m / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(e, n, i, r) {
    if (typeof r > "u" && (r = 0.5), r === 0)
      return new dn(n, n, i);
    if (r === 1)
      return new dn(e, n, n);
    const o = dn.getABC(2, e, n, i, r);
    return new dn(e, o.A, i);
  }
  static cubicFromPoints(e, n, i, r, o) {
    typeof r > "u" && (r = 0.5);
    const a = dn.getABC(3, e, n, i, r);
    typeof o > "u" && (o = Ke.dist(n, a.C));
    const l = o * (1 - r) / r, c = Ke.dist(e, i), u = (i.x - e.x) / c, d = (i.y - e.y) / c, h = o * u, m = o * d, p = l * u, y = l * d, _ = { x: n.x - h, y: n.y - m }, v = { x: n.x + p, y: n.y + y }, g = a.A, S = { x: g.x + (_.x - g.x) / (1 - r), y: g.y + (_.y - g.y) / (1 - r) }, w = { x: g.x + (v.x - g.x) / r, y: g.y + (v.y - g.y) / r }, x = { x: e.x + (S.x - e.x) / r, y: e.y + (S.y - e.y) / r }, C = {
      x: i.x + (w.x - i.x) / (1 - r),
      y: i.y + (w.y - i.y) / (1 - r)
    };
    return new dn(e, x, C, i);
  }
  static getUtils() {
    return Ke;
  }
  getUtils() {
    return dn.getUtils();
  }
  static get PolyBezier() {
    return Wa;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return Ke.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const e = this.points, n = e[0].x, i = e[0].y, r = ["M", n, i, this.order === 2 ? "Q" : "C"];
    for (let o = 1, a = e.length; o < a; o++)
      r.push(e[o].x), r.push(e[o].y);
    return r.join(" ");
  }
  setRatios(e) {
    if (e.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = e, this._lut = [];
  }
  verify() {
    const e = this.coordDigest();
    e !== this._print && (this._print = e, this.update());
  }
  coordDigest() {
    return this.points.map(function(e, n) {
      return "" + n + e.x + e.y + (e.z ? e.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = Ke.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const e = this.points, n = Ke.angle(e[0], e[this.order], e[1]);
    this.clockwise = n > 0;
  }
  length() {
    return Ke.length(this.derivative.bind(this));
  }
  static getABC(e = 2, n, i, r, o = 0.5) {
    const a = Ke.projectionratio(o, e), l = 1 - a, c = {
      x: a * n.x + l * r.x,
      y: a * n.y + l * r.y
    }, u = Ke.abcratio(o, e);
    return { A: {
      x: i.x + (i.x - c.x) / u,
      y: i.y + (i.y - c.y) / u
    }, B: i, C: c, S: n, E: r };
  }
  getABC(e, n) {
    n = n || this.get(e);
    let i = this.points[0], r = this.points[this.order];
    return dn.getABC(this.order, i, n, r, e);
  }
  getLUT(e) {
    if (this.verify(), e = e || 100, this._lut.length === e + 1)
      return this._lut;
    this._lut = [], e++, this._lut = [];
    for (let n = 0, i, r; n < e; n++)
      r = n / (e - 1), i = this.compute(r), i.t = r, this._lut.push(i);
    return this._lut;
  }
  on(e, n) {
    n = n || 5;
    const i = this.getLUT(), r = [];
    for (let o = 0, a, l = 0; o < i.length; o++)
      a = i[o], Ke.dist(a, e) < n && (r.push(a), l += o / i.length);
    return r.length ? t /= r.length : !1;
  }
  project(e) {
    const n = this.getLUT(), i = n.length - 1, r = Ke.closest(n, e), o = r.mpos, a = (o - 1) / i, l = (o + 1) / i, c = 0.1 / i;
    let u = r.mdist, d = a, h = d, m;
    u += 1;
    for (let p; d < l + c; d += c)
      m = this.compute(d), p = Ke.dist(e, m), p < u && (u = p, h = d);
    return h = h < 0 ? 0 : h > 1 ? 1 : h, m = this.compute(h), m.t = h, m.d = u, m;
  }
  get(e) {
    return this.compute(e);
  }
  point(e) {
    return this.points[e];
  }
  compute(e) {
    return this.ratios ? Ke.computeWithRatios(e, this.points, this.ratios, this._3d) : Ke.compute(e, this.points, this._3d, this.ratios);
  }
  raise() {
    const e = this.points, n = [e[0]], i = e.length;
    for (let r = 1, o, a; r < i; r++)
      o = e[r], a = e[r - 1], n[r] = {
        x: (i - r) / i * o.x + r / i * a.x,
        y: (i - r) / i * o.y + r / i * a.y
      };
    return n[i] = e[i - 1], new dn(n);
  }
  derivative(e) {
    return Ke.compute(e, this.dpoints[0], this._3d);
  }
  dderivative(e) {
    return Ke.compute(e, this.dpoints[1], this._3d);
  }
  align() {
    let e = this.points;
    return new dn(Ke.align(e, { p1: e[0], p2: e[e.length - 1] }));
  }
  curvature(e) {
    return Ke.curvature(e, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return Ke.inflections(this.points);
  }
  normal(e) {
    return this._3d ? this.__normal3(e) : this.__normal2(e);
  }
  __normal2(e) {
    const n = this.derivative(e), i = _a(n.x * n.x + n.y * n.y);
    return { t: e, x: -n.y / i, y: n.x / i };
  }
  __normal3(e) {
    const n = this.derivative(e), i = this.derivative(e + 0.01), r = _a(n.x * n.x + n.y * n.y + n.z * n.z), o = _a(i.x * i.x + i.y * i.y + i.z * i.z);
    n.x /= r, n.y /= r, n.z /= r, i.x /= o, i.y /= o, i.z /= o;
    const a = {
      x: i.y * n.z - i.z * n.y,
      y: i.z * n.x - i.x * n.z,
      z: i.x * n.y - i.y * n.x
    }, l = _a(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const c = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: e,
      x: c[0] * n.x + c[1] * n.y + c[2] * n.z,
      y: c[3] * n.x + c[4] * n.y + c[5] * n.z,
      z: c[6] * n.x + c[7] * n.y + c[8] * n.z
    };
  }
  hull(e) {
    let n = this.points, i = [], r = [], o = 0;
    for (r[o++] = n[0], r[o++] = n[1], r[o++] = n[2], this.order === 3 && (r[o++] = n[3]); n.length > 1; ) {
      i = [];
      for (let a = 0, l, c = n.length - 1; a < c; a++)
        l = Ke.lerp(e, n[a], n[a + 1]), r[o++] = l, i.push(l);
      n = i;
    }
    return r;
  }
  split(e, n) {
    if (e === 0 && n)
      return this.split(n).left;
    if (n === 1)
      return this.split(e).right;
    const i = this.hull(e), r = {
      left: this.order === 2 ? new dn([i[0], i[3], i[5]]) : new dn([i[0], i[4], i[7], i[9]]),
      right: this.order === 2 ? new dn([i[5], i[4], i[2]]) : new dn([i[9], i[8], i[6], i[3]]),
      span: i
    };
    return r.left._t1 = Ke.map(0, 0, 1, this._t1, this._t2), r.left._t2 = Ke.map(e, 0, 1, this._t1, this._t2), r.right._t1 = Ke.map(e, 0, 1, this._t1, this._t2), r.right._t2 = Ke.map(1, 0, 1, this._t1, this._t2), n ? (n = Ke.map(n, e, 1, 0, 1), r.right.split(n).left) : r;
  }
  extrema() {
    const e = {};
    let n = [];
    return this.dims.forEach(
      (function(i) {
        let r = function(a) {
          return a[i];
        }, o = this.dpoints[0].map(r);
        e[i] = Ke.droots(o), this.order === 3 && (o = this.dpoints[1].map(r), e[i] = e[i].concat(Ke.droots(o))), e[i] = e[i].filter(function(a) {
          return a >= 0 && a <= 1;
        }), n = n.concat(e[i].sort(Ke.numberSort));
      }).bind(this)
    ), e.values = n.sort(Ke.numberSort).filter(function(i, r) {
      return n.indexOf(i) === r;
    }), e;
  }
  bbox() {
    const e = this.extrema(), n = {};
    return this.dims.forEach(
      (function(i) {
        n[i] = Ke.getminmax(this, i, e[i]);
      }).bind(this)
    ), n;
  }
  overlaps(e) {
    const n = this.bbox(), i = e.bbox();
    return Ke.bboxoverlap(n, i);
  }
  offset(e, n) {
    if (typeof n < "u") {
      const i = this.get(e), r = this.normal(e), o = {
        c: i,
        n: r,
        x: i.x + r.x * n,
        y: i.y + r.y * n
      };
      return this._3d && (o.z = i.z + r.z * n), o;
    }
    if (this._linear) {
      const i = this.normal(0), r = this.points.map(function(o) {
        const a = {
          x: o.x + e * i.x,
          y: o.y + e * i.y
        };
        return o.z && i.z && (a.z = o.z + e * i.z), a;
      });
      return [new dn(r)];
    }
    return this.reduce().map(function(i) {
      return i._linear ? i.offset(e)[0] : i.scale(e);
    });
  }
  simple() {
    if (this.order === 3) {
      const r = Ke.angle(this.points[0], this.points[3], this.points[1]), o = Ke.angle(this.points[0], this.points[3], this.points[2]);
      if (r > 0 && o < 0 || r < 0 && o > 0) return !1;
    }
    const e = this.normal(0), n = this.normal(1);
    let i = e.x * n.x + e.y * n.y;
    return this._3d && (i += e.z * n.z), ya(RB(i)) < IB / 3;
  }
  reduce() {
    let e, n = 0, i = 0, r = 0.01, o, a = [], l = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), n = c[0], e = 1; e < c.length; e++)
      i = c[e], o = this.split(n, i), o._t1 = n, o._t2 = i, a.push(o), n = i;
    return a.forEach(function(u) {
      for (n = 0, i = 0; i <= 1; )
        for (i = n + r; i <= 1 + r; i += r)
          if (o = u.split(n, i), !o.simple()) {
            if (i -= r, ya(n - i) < r)
              return [];
            o = u.split(n, i), o._t1 = Ke.map(n, 0, 1, u._t1, u._t2), o._t2 = Ke.map(i, 0, 1, u._t1, u._t2), l.push(o), n = i;
            break;
          }
      n < 1 && (o = u.split(n, 1), o._t1 = Ke.map(n, 0, 1, u._t1, u._t2), o._t2 = u._t2, l.push(o));
    }), l;
  }
  translate(e, n, i) {
    i = typeof i == "number" ? i : n;
    const r = this.order;
    let o = this.points.map((a, l) => (1 - l / r) * n + l / r * i);
    return new dn(
      this.points.map((a, l) => ({
        x: a.x + e.x * o[l],
        y: a.y + e.y * o[l]
      }))
    );
  }
  scale(e) {
    const n = this.order;
    let i = !1;
    if (typeof e == "function" && (i = e), i && n === 2)
      return this.raise().scale(i);
    const r = this.clockwise, o = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        i ? i(0) : e,
        i ? i(1) : e
      );
    const a = i ? i(0) : e, l = i ? i(1) : e, c = [this.offset(0, 10), this.offset(1, 10)], u = [], d = Ke.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!d)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(h) {
      const m = u[h * n] = Ke.copy(o[h * n]);
      m.x += (h ? l : a) * c[h].n.x, m.y += (h ? l : a) * c[h].n.y;
    }), i ? ([0, 1].forEach(function(h) {
      if (!(n === 2 && h)) {
        var m = o[h + 1], p = {
          x: m.x - d.x,
          y: m.y - d.y
        }, y = i ? i((h + 1) / n) : e;
        i && !r && (y = -y);
        var _ = _a(p.x * p.x + p.y * p.y);
        p.x /= _, p.y /= _, u[h + 1] = {
          x: m.x + y * p.x,
          y: m.y + y * p.y
        };
      }
    }), new dn(u)) : ([0, 1].forEach((h) => {
      if (n === 2 && h) return;
      const m = u[h * n], p = this.derivative(h), y = { x: m.x + p.x, y: m.y + p.y };
      u[h + 1] = Ke.lli4(m, y, d, o[h + 1]);
    }), new dn(u));
  }
  outline(e, n, i, r) {
    if (n = n === void 0 ? e : n, this._linear) {
      const C = this.normal(0), E = this.points[0], P = this.points[this.points.length - 1];
      let T, b, M;
      i === void 0 && (i = e, r = n), T = { x: E.x + C.x * e, y: E.y + C.y * e }, M = { x: P.x + C.x * i, y: P.y + C.y * i }, b = { x: (T.x + M.x) / 2, y: (T.y + M.y) / 2 };
      const L = [T, b, M];
      T = { x: E.x - C.x * n, y: E.y - C.y * n }, M = { x: P.x - C.x * r, y: P.y - C.y * r }, b = { x: (T.x + M.x) / 2, y: (T.y + M.y) / 2 };
      const N = [M, b, T], D = Ke.makeline(N[2], L[0]), O = Ke.makeline(L[2], N[0]), A = [D, new dn(L), O, new dn(N)];
      return new Wa(A);
    }
    const o = this.reduce(), a = o.length, l = [];
    let c = [], u, d = 0, h = this.length();
    const m = typeof i < "u" && typeof r < "u";
    function p(C, E, P, T, b) {
      return function(M) {
        const L = T / P, N = (T + b) / P, D = E - C;
        return Ke.map(M, 0, 1, C + L * D, C + N * D);
      };
    }
    o.forEach(function(C) {
      const E = C.length();
      m ? (l.push(
        C.scale(p(e, i, h, d, E))
      ), c.push(
        C.scale(p(-n, -r, h, d, E))
      )) : (l.push(C.scale(e)), c.push(C.scale(-n))), d += E;
    }), c = c.map(function(C) {
      return u = C.points, u[3] ? C.points = [u[3], u[2], u[1], u[0]] : C.points = [u[2], u[1], u[0]], C;
    }).reverse();
    const y = l[0].points[0], _ = l[a - 1].points[l[a - 1].points.length - 1], v = c[a - 1].points[c[a - 1].points.length - 1], g = c[0].points[0], S = Ke.makeline(v, y), w = Ke.makeline(_, g), x = [S].concat(l).concat([w]).concat(c);
    return new Wa(x);
  }
  outlineshapes(e, n, i) {
    n = n || e;
    const r = this.outline(e, n).curves, o = [];
    for (let a = 1, l = r.length; a < l / 2; a++) {
      const c = Ke.makeshape(
        r[a],
        r[l - a],
        i
      );
      c.startcap.virtual = a > 1, c.endcap.virtual = a < l / 2 - 1, o.push(c);
    }
    return o;
  }
  intersects(e, n) {
    return e ? e.p1 && e.p2 ? this.lineIntersects(e) : (e instanceof dn && (e = e.reduce()), this.curveintersects(
      this.reduce(),
      e,
      n
    )) : this.selfintersects(n);
  }
  lineIntersects(e) {
    const n = Wv(e.p1.x, e.p2.x), i = Wv(e.p1.y, e.p2.y), r = $v(e.p1.x, e.p2.x), o = $v(e.p1.y, e.p2.y);
    return Ke.roots(this.points, e).filter((a) => {
      var l = this.get(a);
      return Ke.between(l.x, n, r) && Ke.between(l.y, i, o);
    });
  }
  selfintersects(e) {
    const n = this.reduce(), i = n.length - 2, r = [];
    for (let o = 0, a, l, c; o < i; o++)
      l = n.slice(o, o + 1), c = n.slice(o + 2), a = this.curveintersects(l, c, e), r.push(...a);
    return r;
  }
  curveintersects(e, n, i) {
    const r = [];
    e.forEach(function(a) {
      n.forEach(function(l) {
        a.overlaps(l) && r.push({ left: a, right: l });
      });
    });
    let o = [];
    return r.forEach(function(a) {
      const l = Ke.pairiteration(
        a.left,
        a.right,
        i
      );
      l.length > 0 && (o = o.concat(l));
    }), o;
  }
  arcs(e) {
    return e = e || 0.5, this._iterate(e, []);
  }
  _error(e, n, i, r) {
    const o = (r - i) / 4, a = this.get(i + o), l = this.get(r - o), c = Ke.dist(e, n), u = Ke.dist(e, a), d = Ke.dist(e, l);
    return ya(u - c) + ya(d - c);
  }
  _iterate(e, n) {
    let i = 0, r = 1, o;
    do {
      o = 0, r = 1;
      let a = this.get(i), l, c, u, d, h = !1, m = !1, p, y = r, _ = 1;
      do
        if (m = h, d = u, y = (i + r) / 2, l = this.get(y), c = this.get(r), u = Ke.getccenter(a, l, c), u.interval = {
          start: i,
          end: r
        }, h = this._error(u, a, i, r) <= e, p = m && !h, p || (_ = r), h) {
          if (r >= 1) {
            if (u.interval.end = _ = 1, d = u, r > 1) {
              let g = {
                x: u.x + u.r * PB(u.e),
                y: u.y + u.r * DB(u.e)
              };
              u.e += Ke.angle({ x: u.x, y: u.y }, g, this.get(1));
            }
            break;
          }
          r = r + (r - i) / 2;
        } else
          r = y;
      while (!p && o++ < 100);
      if (o >= 100)
        break;
      d = d || u, n.push(d), i = _;
    } while (r < 1);
    return n;
  }
};
const kB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bezier: Py
}, Symbol.toStringTag, { value: "Module" })), Xv = kB;
class LB {
  /**
   * @param curve - Bezier.js curve instance
   * @param resolution - Number of samples for LUT (higher = more accurate)
   */
  constructor(e, n = 1e3) {
    pe(this, "curve");
    pe(this, "lut");
    pe(this, "totalLength");
    this.curve = e, this.lut = [], this.totalLength = 0, this.buildLUT(n);
  }
  /**
   * Build the arc length lookup table
   */
  buildLUT(e) {
    let n = 0, i = this.curve.get(0);
    for (let r = 0; r <= e; r++) {
      const o = r / e, a = this.curve.get(o);
      if (r > 0) {
        const l = a.x - i.x, c = a.y - i.y;
        n += Math.sqrt(l * l + c * c);
      }
      this.lut.push({
        t: o,
        length: n
      }), i = a;
    }
    this.totalLength = n;
  }
  /**
   * Convert arc length distance to t parameter
   *
   * @param distance - Distance along curve (0 to totalLength)
   * @returns t parameter (0 to 1)
   */
  distanceToT(e) {
    if (e <= 0) return 0;
    if (e >= this.totalLength) return 1;
    let n = 0, i = this.lut.length - 1;
    for (; n < i; ) {
      const l = Math.floor((n + i) / 2);
      this.lut[l].length < e ? n = l + 1 : i = l;
    }
    const r = this.lut[n], o = this.lut[Math.max(0, n - 1)];
    if (r.length === o.length)
      return r.t;
    const a = (e - o.length) / (r.length - o.length);
    return o.t + a * (r.t - o.t);
  }
  /**
   * Get point and tangent at arc length distance
   */
  getPointAtDistance(e) {
    const n = this.distanceToT(e);
    return {
      point: this.curve.get(n),
      tangent: this.curve.derivative(n),
      t: n
    };
  }
  /**
   * Get evenly spaced points along the curve
   *
   * @param count - Number of points
   * @returns Array of points with position and tangent
   */
  getEvenlySpacedPoints(e) {
    const n = [], i = this.totalLength / (e - 1);
    for (let r = 0; r < e; r++) {
      const o = r * i;
      n.push(this.getPointAtDistance(o));
    }
    return n;
  }
}
function FB(s) {
  if (!s || s.length < 2)
    return null;
  let e = null;
  for (const n of s) {
    const [i, ...r] = n;
    if (i === "M")
      e = { x: r[0], y: r[1] };
    else {
      if (i === "C" && e)
        return new Xv(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point 1
          r[2],
          r[3],
          // control point 2
          r[4],
          r[5]
          // end point
        );
      if (i === "Q" && e)
        return new Xv(
          e.x,
          e.y,
          r[0],
          r[1],
          // control point
          r[2],
          r[3]
          // end point
        );
    }
  }
  return null;
}
const Dy = /* @__PURE__ */ Math.sqrt(3), UB = 0.5 * (Dy - 1), xa = (3 - Dy) / 6, jv = (s) => Math.floor(s) | 0, Yv = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function OB(s = Math.random) {
  const e = zB(s), n = new Float64Array(e).map((r) => Yv[r % 12 * 2]), i = new Float64Array(e).map((r) => Yv[r % 12 * 2 + 1]);
  return function(o, a) {
    let l = 0, c = 0, u = 0;
    const d = (o + a) * UB, h = jv(o + d), m = jv(a + d), p = (h + m) * xa, y = h - p, _ = m - p, v = o - y, g = a - _;
    let S, w;
    v > g ? (S = 1, w = 0) : (S = 0, w = 1);
    const x = v - S + xa, C = g - w + xa, E = v - 1 + 2 * xa, P = g - 1 + 2 * xa, T = h & 255, b = m & 255;
    let M = 0.5 - v * v - g * g;
    if (M >= 0) {
      const D = T + e[b], O = n[D], A = i[D];
      M *= M, l = M * M * (O * v + A * g);
    }
    let L = 0.5 - x * x - C * C;
    if (L >= 0) {
      const D = T + S + e[b + w], O = n[D], A = i[D];
      L *= L, c = L * L * (O * x + A * C);
    }
    let N = 0.5 - E * E - P * P;
    if (N >= 0) {
      const D = T + 1 + e[b + 1], O = n[D], A = i[D];
      N *= N, u = N * N * (O * E + A * P);
    }
    return 70 * (l + c + u);
  };
}
function zB(s) {
  const n = new Uint8Array(512);
  for (let i = 0; i < 512 / 2; i++)
    n[i] = i;
  for (let i = 0; i < 512 / 2 - 1; i++) {
    const r = i + ~~(s() * (256 - i)), o = n[i];
    n[i] = n[r], n[r] = o;
  }
  for (let i = 256; i < 512; i++)
    n[i] = n[i - 256];
  return n;
}
function NB() {
  return {
    enabled: !1,
    maxDistance: 100,
    maxConnections: 3,
    lineWidth: 1,
    lineOpacity: 0.5,
    fadeByDistance: !0
  };
}
function BB() {
  return {
    maxParticles: 1e4,
    gravity: 0,
    windStrength: 0,
    windDirection: 0,
    warmupPeriod: 0,
    respectMaskBoundary: !1,
    boundaryBehavior: "kill",
    friction: 0.01,
    turbulenceFields: [],
    subEmitters: []
  };
}
function qv() {
  return {
    blendMode: "additive",
    renderTrails: !1,
    trailLength: 5,
    trailOpacityFalloff: 0.7,
    particleShape: "circle",
    glowEnabled: !1,
    glowRadius: 10,
    glowIntensity: 0.5,
    motionBlur: !1,
    motionBlurStrength: 0.5,
    motionBlurSamples: 8,
    connections: NB()
  };
}
class Gf {
  constructor(e = {}) {
    pe(this, "particles", []);
    pe(this, "emitters", /* @__PURE__ */ new Map());
    pe(this, "gravityWells", /* @__PURE__ */ new Map());
    pe(this, "vortices", /* @__PURE__ */ new Map());
    pe(this, "modulations", []);
    pe(this, "config");
    pe(this, "boundaryMask", null);
    pe(this, "frameCount", 0);
    pe(this, "emissionAccumulators", /* @__PURE__ */ new Map());
    pe(this, "nextParticleId", 0);
    pe(this, "trailHistory", /* @__PURE__ */ new Map());
    // Audio reactivity state
    pe(this, "featureOverrides", /* @__PURE__ */ new Map());
    // Turbulence noise generator
    pe(this, "noise2D");
    pe(this, "noiseTime", 0);
    // Render options cache for spatial grid
    pe(this, "renderOptions", qv());
    this.config = { ...BB(), ...e }, this.noise2D = OB();
  }
  // ============================================================================
  // Emitter Management
  // ============================================================================
  addEmitter(e) {
    if (this.emitters.set(e.id, { ...e }), this.emissionAccumulators.set(e.id, 0), e.initialBurst > 0 && e.enabled) {
      const n = Math.floor(e.emissionRate * e.initialBurst * 10);
      for (let i = 0; i < n; i++)
        this.spawnParticle(e);
    }
  }
  updateEmitter(e, n) {
    const i = this.emitters.get(e);
    i && Object.assign(i, n);
  }
  removeEmitter(e) {
    this.emitters.delete(e), this.emissionAccumulators.delete(e);
  }
  getEmitter(e) {
    return this.emitters.get(e);
  }
  getEmitters() {
    return Array.from(this.emitters.values());
  }
  // ============================================================================
  // Gravity Well Management
  // ============================================================================
  addGravityWell(e) {
    this.gravityWells.set(e.id, { ...e });
  }
  updateGravityWell(e, n) {
    const i = this.gravityWells.get(e);
    i && Object.assign(i, n);
  }
  removeGravityWell(e) {
    this.gravityWells.delete(e);
  }
  getGravityWells() {
    return Array.from(this.gravityWells.values());
  }
  // ============================================================================
  // Vortex Management
  // ============================================================================
  addVortex(e) {
    this.vortices.set(e.id, { ...e });
  }
  updateVortex(e, n) {
    const i = this.vortices.get(e);
    i && Object.assign(i, n);
  }
  removeVortex(e) {
    this.vortices.delete(e);
  }
  getVortices() {
    return Array.from(this.vortices.values());
  }
  // ============================================================================
  // Modulation Management
  // ============================================================================
  addModulation(e) {
    this.modulations.push({ ...e });
  }
  removeModulation(e) {
    const n = this.modulations.findIndex((i) => i.id === e);
    n >= 0 && this.modulations.splice(n, 1);
  }
  getModulations() {
    return [...this.modulations];
  }
  // ============================================================================
  // Boundary Mask
  // ============================================================================
  setBoundaryMask(e) {
    this.boundaryMask = e;
  }
  // ============================================================================
  // Audio Reactivity
  // ============================================================================
  setFeatureValue(e, n, i) {
    const r = i ? `${i}:${e}` : `*:${e}`;
    this.featureOverrides.set(r, n);
  }
  getFeatureValue(e, n) {
    return this.featureOverrides.get(`${n}:${e}`) ?? this.featureOverrides.get(`*:${e}`);
  }
  // ============================================================================
  // Simulation
  // ============================================================================
  step(e = 1) {
    this.emitters.forEach((u, d) => {
      if (!u.enabled) return;
      const m = (this.getFeatureValue("emissionRate", d) ?? u.emissionRate) * e;
      let p = (this.emissionAccumulators.get(d) || 0) + m;
      for (; p >= 1 && this.particles.length < this.config.maxParticles; )
        this.spawnParticle(u), p -= 1;
      this.emissionAccumulators.set(d, p);
    });
    const n = this.config.windDirection * Math.PI / 180, i = Math.cos(n) * this.config.windStrength * 1e-3, r = Math.sin(n) * this.config.windStrength * 1e-3, o = this.getFeatureValue("gravity", "*") ?? this.config.gravity, a = this.getFeatureValue("windStrength", "*") ?? this.config.windStrength, l = i * (a / Math.max(1, this.config.windStrength)), c = r * (a / Math.max(1, this.config.windStrength));
    for (let u = this.particles.length - 1; u >= 0; u--) {
      const d = this.particles[u];
      if (d.prevX = d.x, d.prevY = d.y, this.trailHistory.has(d.id)) {
        const m = this.trailHistory.get(d.id);
        m.unshift({ x: d.x, y: d.y }), m.length > 20 && m.pop();
      }
      d.vy += o * 1e-3 * e, d.vx += l * e, d.vy += c * e, this.gravityWells.forEach((m) => {
        if (!m.enabled) return;
        const p = m.x - d.x, y = m.y - d.y, _ = Math.sqrt(p * p + y * y);
        if (_ < m.radius && _ > 1e-3) {
          let v = m.strength * 1e-4;
          switch (m.falloff) {
            case "linear":
              v *= 1 - _ / m.radius;
              break;
            case "quadratic":
              v *= Math.pow(1 - _ / m.radius, 2);
              break;
          }
          const g = p / _, S = y / _;
          d.vx += g * v * e, d.vy += S * v * e;
        }
      }), this.vortices.forEach((m) => {
        if (!m.enabled) return;
        const p = m.x - d.x, y = m.y - d.y, _ = Math.sqrt(p * p + y * y);
        if (_ < m.radius && _ > 1e-3) {
          const v = 1 - _ / m.radius, g = m.strength * 1e-4 * v, S = p / _, w = y / _, x = -w, C = S;
          d.vx += x * g * e, d.vy += C * g * e;
          const E = m.inwardPull * 1e-4 * v;
          d.vx += S * E * e, d.vy += w * E * e;
        }
      }), this.applyTurbulence(d, e);
      const h = 1 - this.config.friction;
      d.vx *= h, d.vy *= h, d.x += d.vx * e, d.y += d.vy * e, this.boundaryMask && this.config.respectMaskBoundary && this.handleBoundaryCollision(d), this.handleCanvasBoundary(d), this.applyModulations(d), d.age += e, d.age > d.lifetime && (d.isSubParticle || this.triggerSubEmitters(d), this.particles.splice(u, 1), this.trailHistory.delete(d.id));
    }
    this.noiseTime += e, this.frameCount++;
  }
  spawnParticle(e) {
    if (this.particles.length >= this.config.maxParticles) return;
    const n = e.spread * Math.PI / 180, r = e.direction * Math.PI / 180 + (Math.random() - 0.5) * n, a = (e.speed + (Math.random() - 0.5) * 2 * e.speedVariance) * 1e-3, l = Math.max(1, e.size + (Math.random() - 0.5) * 2 * e.sizeVariance), c = Math.max(1, e.particleLifetime + (Math.random() - 0.5) * 2 * e.lifetimeVariance), u = {
      id: this.nextParticleId++,
      x: e.x,
      y: e.y,
      prevX: e.x,
      prevY: e.y,
      vx: Math.cos(r) * a,
      vy: Math.sin(r) * a,
      age: 0,
      lifetime: c,
      size: l,
      baseSize: l,
      color: [...e.color, 255],
      baseColor: [...e.color, 255],
      emitterId: e.id,
      isSubParticle: !1
    };
    this.particles.push(u), this.trailHistory.set(u.id, [{ x: u.x, y: u.y }]);
  }
  handleBoundaryCollision(e) {
    if (!this.boundaryMask) return;
    const n = Math.floor(e.x * this.boundaryMask.width), i = Math.floor(e.y * this.boundaryMask.height);
    if (n < 0 || n >= this.boundaryMask.width || i < 0 || i >= this.boundaryMask.height)
      return;
    const r = (i * this.boundaryMask.width + n) * 4;
    if (this.boundaryMask.data[r] < 128)
      switch (this.config.boundaryBehavior) {
        case "bounce":
          e.vx *= -0.8, e.vy *= -0.8, e.x = e.prevX, e.y = e.prevY;
          break;
        case "kill":
          e.age = e.lifetime + 1;
          break;
        case "wrap":
          e.x = Math.random(), e.y = Math.random();
          break;
      }
  }
  handleCanvasBoundary(e) {
    switch (this.config.boundaryBehavior) {
      case "bounce":
        e.x < 0 && (e.x = 0, e.vx *= -0.8), e.x > 1 && (e.x = 1, e.vx *= -0.8), e.y < 0 && (e.y = 0, e.vy *= -0.8), e.y > 1 && (e.y = 1, e.vy *= -0.8);
        break;
      case "kill":
        (e.x < -0.1 || e.x > 1.1 || e.y < -0.1 || e.y > 1.1) && (e.age = e.lifetime + 1);
        break;
      case "wrap":
        e.x < 0 && (e.x += 1), e.x > 1 && (e.x -= 1), e.y < 0 && (e.y += 1), e.y > 1 && (e.y -= 1);
        break;
    }
  }
  applyModulations(e) {
    const n = e.age / e.lifetime;
    for (const i of this.modulations) {
      if (i.emitterId !== "*" && i.emitterId !== e.emitterId) continue;
      const r = i.easing, o = Yc[r] || Yc.linear, a = b2(n, o), l = i.startValue + (i.endValue - i.startValue) * a;
      switch (i.property) {
        case "size":
          e.size = e.baseSize * l;
          break;
        case "speed":
          const c = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
          if (c > 1e-4) {
            const u = l / Math.max(1e-4, c * 1e3);
            e.vx *= u, e.vy *= u;
          }
          break;
        case "opacity":
          e.color[3] = Math.max(0, Math.min(255, e.baseColor[3] * l));
          break;
        case "colorR":
          e.color[0] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorG":
          e.color[1] = Math.max(0, Math.min(255, l * 255));
          break;
        case "colorB":
          e.color[2] = Math.max(0, Math.min(255, l * 255));
          break;
      }
    }
  }
  // ============================================================================
  // Turbulence
  // ============================================================================
  applyTurbulence(e, n) {
    const i = this.config.turbulenceFields || [];
    for (const r of i) {
      if (!r.enabled) continue;
      const o = e.x * r.scale * 1e3, a = e.y * r.scale * 1e3, l = this.noiseTime * r.evolutionSpeed, c = this.noise2D(o + l, a + l) * Math.PI * 2, u = r.strength * 1e-5;
      e.vx += Math.cos(c) * u * n, e.vy += Math.sin(c) * u * n;
    }
  }
  addTurbulence(e) {
    this.config.turbulenceFields || (this.config.turbulenceFields = []), this.config.turbulenceFields.push(e);
  }
  updateTurbulence(e, n) {
    var r;
    const i = (r = this.config.turbulenceFields) == null ? void 0 : r.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeTurbulence(e) {
    this.config.turbulenceFields && (this.config.turbulenceFields = this.config.turbulenceFields.filter((n) => n.id !== e));
  }
  getTurbulenceFields() {
    return this.config.turbulenceFields || [];
  }
  // ============================================================================
  // Sub-Emitters
  // ============================================================================
  triggerSubEmitters(e) {
    const n = this.config.subEmitters || [];
    for (const i of n)
      if (i.enabled && !(i.parentEmitterId !== "*" && i.parentEmitterId !== e.emitterId))
        for (let r = 0; r < i.spawnCount; r++) {
          const o = (Math.random() - 0.5) * i.spread * Math.PI / 180, l = Math.atan2(e.vy, e.vx) + o, c = Math.sqrt(e.vx ** 2 + e.vy ** 2) * i.inheritVelocity, u = i.speed * 1e-3 + c, d = {
            id: this.nextParticleId++,
            x: e.x,
            y: e.y,
            prevX: e.x,
            prevY: e.y,
            vx: Math.cos(l) * u + e.vx * i.inheritVelocity,
            vy: Math.sin(l) * u + e.vy * i.inheritVelocity,
            age: 0,
            lifetime: i.lifetime * (1 + (Math.random() - 0.5) * 0.2),
            size: i.size * (1 + (Math.random() - 0.5) * i.sizeVariance / i.size),
            baseSize: i.size,
            color: [...i.color, 255],
            baseColor: [...i.color, 255],
            emitterId: i.id,
            isSubParticle: !0
          };
          this.particles.push(d), this.trailHistory.set(d.id, [{ x: d.x, y: d.y }]);
        }
  }
  addSubEmitter(e) {
    this.config.subEmitters || (this.config.subEmitters = []), this.config.subEmitters.push(e);
  }
  updateSubEmitter(e, n) {
    var r;
    const i = (r = this.config.subEmitters) == null ? void 0 : r.find((o) => o.id === e);
    i && Object.assign(i, n);
  }
  removeSubEmitter(e) {
    this.config.subEmitters && (this.config.subEmitters = this.config.subEmitters.filter((n) => n.id !== e));
  }
  getSubEmitters() {
    return this.config.subEmitters || [];
  }
  // ============================================================================
  // Burst on Beat
  // ============================================================================
  triggerBurst(e, n) {
    const i = this.emitters.get(e);
    if (!i || !i.enabled) return;
    const r = n ?? i.burstCount ?? 20;
    for (let o = 0; o < r; o++)
      this.spawnParticle(i);
  }
  triggerAllBursts() {
    for (const e of this.emitters.values())
      e.burstOnBeat && e.enabled && this.triggerBurst(e.id);
  }
  // ============================================================================
  // Particle Connections - Spatial Grid
  // ============================================================================
  buildSpatialGrid() {
    var i;
    const e = ((i = this.renderOptions.connections) == null ? void 0 : i.maxDistance) || 100, n = /* @__PURE__ */ new Map();
    for (const r of this.particles) {
      const o = Math.floor(r.x * 1e3 / e), a = Math.floor(r.y * 1e3 / e), l = `${o},${a}`;
      n.has(l) || n.set(l, []), n.get(l).push(r);
    }
    return { cellSize: e, cells: n };
  }
  getNeighborParticles(e, n) {
    const i = Math.floor(e.x * 1e3 / n.cellSize), r = Math.floor(e.y * 1e3 / n.cellSize), o = [];
    for (let a = -1; a <= 1; a++)
      for (let l = -1; l <= 1; l++) {
        const c = `${i + a},${r + l}`, u = n.cells.get(c);
        u && o.push(...u);
      }
    return o;
  }
  renderConnections(e, n, i) {
    const r = this.renderOptions.connections;
    if (!(r != null && r.enabled) || this.particles.length < 2) return;
    const o = this.buildSpatialGrid(), a = r.maxDistance / 1e3, l = a * a;
    e.lineWidth = r.lineWidth;
    for (const c of this.particles) {
      const u = this.getNeighborParticles(c, o);
      let d = 0;
      for (const h of u) {
        if (h.id <= c.id) continue;
        if (d >= r.maxConnections) break;
        const m = h.x - c.x, p = h.y - c.y, y = m * m + p * p;
        if (y < l) {
          const _ = Math.sqrt(y);
          let v = r.lineOpacity;
          r.fadeByDistance && (v *= 1 - _ / a);
          const g = Math.round((c.color[0] + h.color[0]) / 2), S = Math.round((c.color[1] + h.color[1]) / 2), w = Math.round((c.color[2] + h.color[2]) / 2);
          e.strokeStyle = `rgba(${g},${S},${w},${v})`, e.beginPath(), e.moveTo(c.x * n, c.y * i), e.lineTo(h.x * n, h.y * i), e.stroke(), d++;
        }
      }
    }
  }
  reset() {
    this.particles = [], this.frameCount = 0, this.trailHistory.clear(), this.emissionAccumulators.forEach((e, n) => {
      this.emissionAccumulators.set(n, 0);
    }), this.nextParticleId = 0;
  }
  warmup() {
    for (let e = 0; e < this.config.warmupPeriod; e++)
      this.step(1);
  }
  getParticles() {
    return this.particles;
  }
  getParticleCount() {
    return this.particles.length;
  }
  getConfig() {
    return { ...this.config };
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  // ============================================================================
  // Rendering
  // ============================================================================
  renderToCanvas(e, n, i, r = qv()) {
    switch (this.renderOptions = r, e.save(), r.blendMode) {
      case "additive":
        e.globalCompositeOperation = "lighter";
        break;
      case "multiply":
        e.globalCompositeOperation = "multiply";
        break;
      case "screen":
        e.globalCompositeOperation = "screen";
        break;
      default:
        e.globalCompositeOperation = "source-over";
    }
    this.renderConnections(e, n, i);
    for (const o of this.particles) {
      const a = o.x * n, l = o.y * i, c = o.size;
      if (r.renderTrails) {
        const u = this.trailHistory.get(o.id);
        if (u && u.length > 1) {
          e.beginPath(), e.moveTo(a, l);
          const d = Math.min(u.length, r.trailLength);
          for (let h = 0; h < d; h++) {
            const m = u[h], p = o.color[3] * Math.pow(r.trailOpacityFalloff, h + 1);
            e.strokeStyle = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${p / 255})`, e.lineWidth = c * Math.pow(r.trailOpacityFalloff, h), e.lineTo(m.x * n, m.y * i);
          }
          e.stroke();
        }
      }
      r.glowEnabled ? (e.shadowBlur = r.glowRadius, e.shadowColor = `rgba(${o.color[0]}, ${o.color[1]}, ${o.color[2]}, ${r.glowIntensity})`) : e.shadowBlur = 0, r.motionBlur && (o.vx !== 0 || o.vy !== 0) ? this.renderParticleWithMotionBlur(e, o, a, l, c, n, i, r) : this.renderParticleShape(e, a, l, c, o.color, r.particleShape);
    }
    e.restore();
  }
  /**
   * Render a single particle with motion blur effect
   */
  renderParticleWithMotionBlur(e, n, i, r, o, a, l, c) {
    const u = Math.sqrt(n.vx * n.vx + n.vy * n.vy);
    if (u < 1e-4) {
      this.renderParticleShape(e, i, r, o, n.color, c.particleShape);
      return;
    }
    const d = c.motionBlurStrength * u * 500, h = Math.min(c.motionBlurSamples, 16), m = n.vx / u, p = n.vy / u, y = Math.min(d * o, o * 10);
    for (let _ = 0; _ < h; _++) {
      const v = _ / (h - 1), g = (1 - v * 0.8) / h, S = i - m * y * v, w = r - p * y * v, x = o * (1 - v * 0.3), C = n.color[3] / 255 * g * h;
      e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${Math.min(1, C)})`, this.renderParticleShape(e, S, w, x, null, c.particleShape);
    }
    e.fillStyle = `rgba(${n.color[0]}, ${n.color[1]}, ${n.color[2]}, ${n.color[3] / 255})`, this.renderParticleShape(e, i, r, o, n.color, c.particleShape);
  }
  /**
   * Render a particle shape at given position
   */
  renderParticleShape(e, n, i, r, o, a) {
    switch (o && (e.fillStyle = `rgba(${o[0]}, ${o[1]}, ${o[2]}, ${o[3] / 255})`), a) {
      case "circle":
        e.beginPath(), e.arc(n, i, r / 2, 0, Math.PI * 2), e.fill();
        break;
      case "square":
        e.fillRect(n - r / 2, i - r / 2, r, r);
        break;
      case "triangle":
        e.beginPath(), e.moveTo(n, i - r / 2), e.lineTo(n - r / 2, i + r / 2), e.lineTo(n + r / 2, i + r / 2), e.closePath(), e.fill();
        break;
      case "star":
        this.drawStar(e, n, i, 5, r / 2, r / 4), e.fill();
        break;
    }
  }
  drawStar(e, n, i, r, o, a) {
    e.beginPath();
    let l = -Math.PI / 2;
    for (let c = 0; c < r; c++) {
      const u = n + Math.cos(l) * o, d = i + Math.sin(l) * o;
      c === 0 ? e.moveTo(u, d) : e.lineTo(u, d), l += Math.PI / r;
      const h = n + Math.cos(l) * a, m = i + Math.sin(l) * a;
      e.lineTo(h, m), l += Math.PI / r;
    }
    e.closePath();
  }
  renderToMask(e, n) {
    const r = new OffscreenCanvas(e, n).getContext("2d");
    r.fillStyle = "#FFFFFF", r.fillRect(0, 0, e, n);
    const o = this.renderOptions.connections;
    o != null && o.enabled && this.particles.length >= 2 && (r.strokeStyle = "#000000", r.lineWidth = o.lineWidth * 2, this.renderConnections(r, e, n)), r.fillStyle = "#000000";
    for (const a of this.particles) {
      const l = a.x * e, c = a.y * n, u = a.size * 1.5;
      r.beginPath(), r.arc(l, c, u / 2, 0, Math.PI * 2), r.fill();
    }
    return r.getImageData(0, 0, e, n);
  }
  // ============================================================================
  // Serialization
  // ============================================================================
  serialize() {
    return {
      config: this.config,
      emitters: Array.from(this.emitters.values()),
      gravityWells: Array.from(this.gravityWells.values()),
      vortices: Array.from(this.vortices.values()),
      modulations: this.modulations,
      frameCount: this.frameCount
    };
  }
  static deserialize(e) {
    const n = new Gf(e.config);
    if (e.emitters)
      for (const i of e.emitters)
        n.addEmitter(i);
    if (e.gravityWells)
      for (const i of e.gravityWells)
        n.addGravityWell(i);
    if (e.vortices)
      for (const i of e.vortices)
        n.addVortex(i);
    if (e.modulations)
      for (const i of e.modulations)
        n.addModulation(i);
    return n;
  }
}
class VB {
  constructor() {
    pe(this, "offscreenCanvas", null);
    pe(this, "ctx", null);
    pe(this, "particleSystems", /* @__PURE__ */ new Map());
  }
  /**
   * Validate dimensions for Wan model requirements
   * Dimensions must be divisible by 8
   */
  validateDimensions(e, n) {
    const i = Math.round(e / 8) * 8, r = Math.round(n / 8) * 8, o = Math.max(256, i), a = Math.max(256, r), l = e === o && n === a;
    return {
      valid: l,
      correctedWidth: o,
      correctedHeight: a,
      message: l ? void 0 : `Adjusted to ${o}x${a} (divisible by 8)`
    };
  }
  /**
   * Get standard resolution presets with 8-divisible dimensions
   */
  getResolutionPresets() {
    return [
      { label: "480p (848x480)", width: 848, height: 480 },
      { label: "720p (1280x720)", width: 1280, height: 720 },
      { label: "1080p (1920x1080)", width: 1920, height: 1080 }
    ];
  }
  /**
   * Generate matte sequence for all frames
   *
   * Wan mask format:
   * - White (255) = Keep original / generate content
   * - Black (0) = Exclude from generation
   *
   * For text exclusion: Text regions are BLACK, everything else WHITE
   */
  async generateMatteSequence(e, n, i) {
    const { frameCount: r } = e.composition, { width: o, height: a } = n;
    this.offscreenCanvas = new OffscreenCanvas(o, a), this.ctx = this.offscreenCanvas.getContext("2d"), this.initializeParticleSystems(e);
    const l = [];
    for (let c = 0; c < r; c++) {
      i && i({
        frame: c,
        total: r,
        percent: Math.round(c / r * 100)
      }), this.stepParticleSystemsToFrame(e, c);
      const u = await this.generateFrame(e, c, n);
      l.push(u);
    }
    return this.particleSystems.clear(), i && i({
      frame: r,
      total: r,
      percent: 100
    }), l;
  }
  /**
   * Generate a single matte frame
   */
  async generateFrame(e, n, i) {
    const r = this.ctx, { width: o, height: a } = i;
    if (r.fillStyle = "#FFFFFF", r.fillRect(0, 0, o, a), i.matteMode === "include_all")
      return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
    r.fillStyle = "#000000";
    const l = o / e.composition.width, c = a / e.composition.height, u = e.layers.filter(
      (h) => h.type === "text" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of u)
      await this.renderTextLayerToMatte(r, h, e, n, l, c);
    const d = e.layers.filter(
      (h) => h.type === "particles" && h.visible && n >= h.inPoint && n <= h.outPoint
    );
    for (const h of d)
      this.renderParticleLayerToMatte(r, h, o, a);
    return await this.offscreenCanvas.convertToBlob({ type: "image/png" });
  }
  /**
   * Generate a preview frame (for UI display)
   */
  async generatePreviewFrame(e, n, i) {
    (!this.offscreenCanvas || this.offscreenCanvas.width !== i.width || this.offscreenCanvas.height !== i.height) && (this.offscreenCanvas = new OffscreenCanvas(i.width, i.height), this.ctx = this.offscreenCanvas.getContext("2d"));
    const r = await this.generateFrame(e, n, i);
    return URL.createObjectURL(r);
  }
  /**
   * Render text layer as black region on matte
   */
  async renderTextLayerToMatte(e, n, i, r, o, a) {
    const l = n.data;
    if (!l) return;
    const c = n.properties.find((h) => h.name === "fontSize"), d = (c ? on(c, r) : l.fontSize) * Math.min(o, a);
    e.font = `${l.fontWeight} ${d}px "${l.fontFamily}"`, l.pathLayerId ? await this.renderTextOnPathToMatte(e, n, l, i, r, d, o, a) : this.renderTextBlockToMatte(e, n, l, r, d, o, a);
  }
  /**
   * Render text that follows a spline path
   * Per-character rectangles following path
   */
  async renderTextOnPathToMatte(e, n, i, r, o, a, l, c) {
    const u = r.layers.find((w) => w.id === i.pathLayerId);
    if (!u || u.type !== "spline") return;
    const d = u.data;
    if (!(d != null && d.controlPoints) || d.controlPoints.length < 2) return;
    const h = this.buildPathCommands(d);
    if (!h || h.length < 2) return;
    const m = FB(h);
    if (!m) return;
    const p = new LB(m), y = n.properties.find((w) => w.name === "pathOffset"), _ = y ? on(y, o) : i.pathOffset, v = p.totalLength;
    let g = _ * v;
    const S = 4 * Math.min(l, c);
    for (const w of i.text) {
      if (w === " ") {
        const L = e.measureText(" ").width;
        g += L + i.letterSpacing;
        continue;
      }
      const x = e.measureText(w).width, C = Math.max(0, Math.min(g, v)), { point: E, tangent: P } = p.getPointAtDistance(C), T = Math.atan2(P.y, P.x), b = E.x * l, M = E.y * c;
      e.save(), e.translate(b, M), e.rotate(T), e.fillRect(
        -S,
        -a - S,
        x + S * 2,
        a + S * 2
      ), e.restore(), g += x + i.letterSpacing;
    }
  }
  /**
   * Build path commands from spline control points
   */
  buildPathCommands(e) {
    const n = e.controlPoints;
    if (!n || n.length < 2) return null;
    const i = [];
    i.push(["M", n[0].x, n[0].y]);
    for (let r = 0; r < n.length - 1; r++) {
      const o = n[r], a = n[r + 1], l = o.handleOut || { x: o.x, y: o.y }, c = a.handleIn || { x: a.x, y: a.y };
      i.push([
        "C",
        l.x,
        l.y,
        c.x,
        c.y,
        a.x,
        a.y
      ]);
    }
    return i;
  }
  /**
   * Render regular text block (not on path)
   * Standard text bounding box
   */
  renderTextBlockToMatte(e, n, i, r, o, a, l) {
    const c = n.transform.position, u = on(c, r), d = n.transform.rotation, h = on(d, r), m = n.transform.scale, p = on(m, r);
    e.save(), e.translate(u.x * a, u.y * l), e.rotate(h * Math.PI / 180), e.scale(p.x, p.y);
    const _ = e.measureText(i.text).width, v = o, g = 4;
    e.fillRect(
      -g,
      -v - g,
      _ + g * 2,
      v + g * 2
    ), e.restore();
  }
  /**
   * Download frames as ZIP
   */
  async downloadAsZip(e, n = "matte_sequence", i) {
    const r = (await Promise.resolve().then(() => mG)).default, o = new r();
    e.forEach((u, d) => {
      const h = `${n}_${String(d).padStart(4, "0")}.png`;
      o.file(h, u);
    });
    const a = await o.generateAsync(
      { type: "blob" },
      (u) => {
        i && i(Math.round(u.percent));
      }
    ), l = URL.createObjectURL(a), c = document.createElement("a");
    c.href = l, c.download = `${n}.zip`, document.body.appendChild(c), c.click(), document.body.removeChild(c), URL.revokeObjectURL(l);
  }
  /**
   * Initialize particle systems for all particle layers
   */
  initializeParticleSystems(e) {
    this.particleSystems.clear();
    const n = e.layers.filter(
      (i) => i.type === "particles"
    );
    for (const i of n) {
      const r = i.data;
      if (!r) continue;
      const o = new Gf(r.systemConfig);
      for (const l of r.emitters)
        o.addEmitter(l);
      for (const l of r.gravityWells)
        o.addGravityWell(l);
      for (const l of r.vortices)
        o.addVortex(l);
      for (const l of r.modulations)
        o.addModulation(l);
      const a = r.systemConfig.warmupPeriod || 0;
      for (let l = 0; l < a; l++)
        o.step();
      this.particleSystems.set(i.id, o);
    }
  }
  /**
   * Step particle systems to the current frame
   * For sequential export, we step from frame 0 through each frame
   */
  stepParticleSystemsToFrame(e, n) {
    if (n !== 0)
      for (const i of e.layers) {
        if (i.type !== "particles") continue;
        const r = this.particleSystems.get(i.id);
        r && i.visible && n >= i.inPoint && n <= i.outPoint && r.step();
      }
  }
  /**
   * Render particle layer as black regions on matte
   */
  renderParticleLayerToMatte(e, n, i, r) {
    const o = this.particleSystems.get(n.id);
    if (!o) return;
    const a = o.renderToMask(i, r), l = new OffscreenCanvas(i, r);
    l.getContext("2d").putImageData(a, 0, 0), e.globalCompositeOperation = "multiply", e.drawImage(l, 0, 0), e.globalCompositeOperation = "source-over";
  }
  /**
   * Clean up resources
   */
  dispose() {
    this.offscreenCanvas = null, this.ctx = null, this.particleSystems.clear();
  }
}
const _r = new VB(), GB = { class: "export-dialog" }, HB = { class: "dialog-header" }, WB = { class: "dialog-content" }, $B = { class: "form-group" }, XB = { class: "resolution-presets" }, jB = ["onClick"], YB = { class: "custom-resolution" }, qB = { class: "dimension-input" }, ZB = { class: "dimension-input" }, KB = {
  key: 0,
  class: "dimension-warning"
}, JB = { class: "form-group" }, QB = { class: "matte-mode-options" }, eV = { class: "form-group" }, tV = { class: "preview-container" }, nV = ["src"], iV = {
  key: 1,
  class: "preview-placeholder"
}, sV = {
  key: 0,
  class: "progress-section"
}, rV = { class: "progress-bar" }, oV = { class: "progress-text" }, aV = { class: "dialog-footer" }, lV = { class: "export-info" }, cV = ["disabled"], uV = ["disabled"], dV = /* @__PURE__ */ Ut({
  __name: "ExportDialog",
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = e, i = nn(), r = _r.getResolutionPresets(), o = Se("720p (1280x720)"), a = Se(1280), l = Se(720), c = Se(), u = Se("exclude_text"), d = Se(null), h = Se(!1), m = Se(0), p = Se(""), y = Oe(() => a.value), _ = Oe(() => l.value);
    function v(x) {
      o.value = x.label, a.value = x.width, l.value = x.height, c.value = void 0;
    }
    function g() {
      const x = _r.validateDimensions(a.value, l.value);
      if (!x.valid)
        a.value = x.correctedWidth, l.value = x.correctedHeight, c.value = x.message, o.value = "";
      else {
        c.value = void 0;
        const C = r.find(
          (E) => E.width === a.value && E.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "";
      }
    }
    async function S() {
      if (!i.hasProject) return;
      d.value && (URL.revokeObjectURL(d.value), d.value = null);
      const x = {
        width: y.value,
        height: _.value,
        matteMode: u.value
      };
      d.value = await _r.generatePreviewFrame(
        i.project,
        0,
        x
      );
    }
    async function w() {
      if (h.value || !i.hasProject) return;
      h.value = !0, m.value = 0, p.value = "Generating frames...";
      const x = {
        width: y.value,
        height: _.value,
        matteMode: u.value
      };
      try {
        const C = await _r.generateMatteSequence(
          i.project,
          x,
          (E) => {
            m.value = E.percent, p.value = `Generating frame ${E.frame + 1} of ${E.total}...`;
          }
        );
        p.value = "Creating ZIP archive...", await _r.downloadAsZip(
          C,
          `matte_${Date.now()}`,
          (E) => {
            p.value = `Compressing... ${E}%`;
          }
        ), p.value = "Export complete!", n("exported"), setTimeout(() => {
          n("close");
        }, 1e3);
      } catch (C) {
        console.error("[ExportDialog] Export failed:", C), p.value = `Export failed: ${C instanceof Error ? C.message : "Unknown error"}`;
      } finally {
        h.value = !1;
      }
    }
    return Ft(
      [y, _, u],
      () => {
        S();
      },
      { immediate: !1 }
    ), _n(() => {
      if (i.hasProject) {
        const x = _r.validateDimensions(i.width, i.height);
        a.value = x.correctedWidth, l.value = x.correctedHeight;
        const C = r.find(
          (E) => E.width === a.value && E.height === l.value
        );
        o.value = (C == null ? void 0 : C.label) || "", x.valid || (c.value = x.message);
      }
      S();
    }), jn(() => {
      d.value && URL.revokeObjectURL(d.value), _r.dispose();
    }), (x, C) => (re(), ae("div", {
      class: "export-dialog-overlay",
      onClick: C[6] || (C[6] = wt((E) => n("close"), ["self"]))
    }, [
      f("div", GB, [
        f("div", HB, [
          C[8] || (C[8] = f("h3", null, "Export Matte Sequence", -1)),
          f("button", {
            class: "close-btn",
            onClick: C[0] || (C[0] = (E) => n("close"))
          }, [...C[7] || (C[7] = [
            f("i", { class: "pi pi-times" }, null, -1)
          ])])
        ]),
        f("div", WB, [
          f("div", $B, [
            C[13] || (C[13] = f("label", null, "Resolution", -1)),
            f("div", XB, [
              (re(!0), ae(Ze, null, at(Ge(r), (E) => (re(), ae("button", {
                key: E.label,
                class: Ue(["preset-btn", { active: o.value === E.label }]),
                onClick: (P) => v(E)
              }, be(E.label), 11, jB))), 128))
            ]),
            f("div", YB, [
              f("div", qB, [
                C[9] || (C[9] = f("label", null, "Width", -1)),
                ct(f("input", {
                  "onUpdate:modelValue": C[1] || (C[1] = (E) => a.value = E),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: g
                }, null, 544), [
                  [
                    $t,
                    a.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ]),
              C[11] || (C[11] = f("span", { class: "dimension-x" }, "", -1)),
              f("div", ZB, [
                C[10] || (C[10] = f("label", null, "Height", -1)),
                ct(f("input", {
                  "onUpdate:modelValue": C[2] || (C[2] = (E) => l.value = E),
                  type: "number",
                  min: "256",
                  step: "8",
                  onChange: g
                }, null, 544), [
                  [
                    $t,
                    l.value,
                    void 0,
                    { number: !0 }
                  ]
                ])
              ])
            ]),
            c.value ? (re(), ae("p", KB, [
              C[12] || (C[12] = f("i", { class: "pi pi-info-circle" }, null, -1)),
              ft(" " + be(c.value), 1)
            ])) : Pe("", !0)
          ]),
          f("div", JB, [
            C[16] || (C[16] = f("label", null, "Matte Mode", -1)),
            f("div", QB, [
              f("button", {
                class: Ue(["mode-btn", { active: u.value === "exclude_text" }]),
                onClick: C[3] || (C[3] = (E) => u.value = "exclude_text")
              }, [...C[14] || (C[14] = [
                f("i", { class: "pi pi-ban" }, null, -1),
                f("span", null, "Exclude Text", -1),
                f("small", null, "Text regions are BLACK (excluded from generation)", -1)
              ])], 2),
              f("button", {
                class: Ue(["mode-btn", { active: u.value === "include_all" }]),
                onClick: C[4] || (C[4] = (E) => u.value = "include_all")
              }, [...C[15] || (C[15] = [
                f("i", { class: "pi pi-check-circle" }, null, -1),
                f("span", null, "Include All", -1),
                f("small", null, "Entire frame is WHITE (generate everything)", -1)
              ])], 2)
            ])
          ]),
          f("div", eV, [
            C[18] || (C[18] = f("label", null, "Preview (Frame 0)", -1)),
            f("div", tV, [
              d.value ? (re(), ae("img", {
                key: 0,
                src: d.value,
                alt: "Matte preview",
                class: "preview-image"
              }, null, 8, nV)) : (re(), ae("div", iV, [...C[17] || (C[17] = [
                f("i", { class: "pi pi-image" }, null, -1),
                f("span", null, "Generating preview...", -1)
              ])]))
            ]),
            C[19] || (C[19] = f("p", { class: "preview-info" }, [
              ft(" White = Keep original / generate content"),
              f("br"),
              ft(" Black = Exclude from generation ")
            ], -1))
          ]),
          h.value ? (re(), ae("div", sV, [
            f("div", rV, [
              f("div", {
                class: "progress-fill",
                style: bt({ width: `${m.value}%` })
              }, null, 4)
            ]),
            f("p", oV, be(p.value), 1)
          ])) : Pe("", !0)
        ]),
        f("div", aV, [
          f("div", lV, [
            f("span", null, be(Ge(i).frameCount) + " frames @ " + be(y.value) + "" + be(_.value), 1)
          ]),
          f("button", {
            class: "cancel-btn",
            onClick: C[5] || (C[5] = (E) => n("close")),
            disabled: h.value
          }, " Cancel ", 8, cV),
          f("button", {
            class: "export-btn",
            onClick: w,
            disabled: h.value || !Ge(i).hasProject
          }, [
            C[20] || (C[20] = f("i", { class: "pi pi-download" }, null, -1)),
            ft(" " + be(h.value ? "Exporting..." : "Export ZIP"), 1)
          ], 8, uV)
        ])
      ])
    ]));
  }
}), hV = /* @__PURE__ */ Bt(dV, [["__scopeId", "data-v-34eee532"]]), fV = {
  "wan22-i2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-t2v": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !1,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-fun-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  "wan22-first-last": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "uni3c-camera": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "uni3c-motion": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  motionctrl: {
    width: 576,
    height: 320,
    frameCount: 16,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "motionctrl-svd": {
    width: 1024,
    height: 576,
    frameCount: 25,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 3
  },
  cogvideox: {
    width: 720,
    height: 480,
    frameCount: 49,
    fps: 16,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 50,
    cfgScale: 6
  },
  "controlnet-depth": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "midas",
    controlType: "depth",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-canny": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "canny",
    steps: 20,
    cfgScale: 7.5
  },
  "controlnet-lineart": {
    width: 1024,
    height: 1024,
    frameCount: 1,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !0,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    controlType: "lineart",
    steps: 20,
    cfgScale: 7.5
  },
  "animatediff-cameractrl": {
    width: 512,
    height: 512,
    frameCount: 16,
    fps: 8,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 25,
    cfgScale: 7.5
  },
  "custom-workflow": {
    width: 1024,
    height: 1024,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 7
  },
  // New model targets (Dec 2025)
  "light-x": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !0,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    depthFormat: "normalized",
    steps: 30,
    cfgScale: 5
  },
  "wan-move": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ati: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  },
  ttm: {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !1,
    exportReferenceFrame: !0,
    exportLastFrame: !0,
    steps: 30,
    cfgScale: 5
  },
  "camera-comfyui": {
    width: 832,
    height: 480,
    frameCount: 81,
    fps: 24,
    exportDepthMap: !1,
    exportControlImages: !1,
    exportCameraData: !0,
    exportReferenceFrame: !0,
    exportLastFrame: !1,
    steps: 30,
    cfgScale: 5
  }
}, pV = {
  midas: {
    format: "midas",
    bitDepth: 8,
    invert: !0,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  zoe: {
    format: "zoe",
    bitDepth: 16,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  },
  "depth-pro": {
    format: "depth-pro",
    bitDepth: 16,
    invert: !1,
    normalize: !1,
    colormap: "grayscale",
    nearClip: 0.01,
    farClip: 100
  },
  normalized: {
    format: "normalized",
    bitDepth: 8,
    invert: !1,
    normalize: !0,
    colormap: "grayscale",
    nearClip: 0.1,
    farClip: 1e3
  }
}, mV = [
  {
    name: "832x480 (Wan 2.2)",
    width: 832,
    height: 480,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "uni3c-camera"]
  },
  {
    name: "1280x720 (HD)",
    width: 1280,
    height: 720,
    aspectRatio: "16:9",
    recommended: ["wan22-i2v", "wan22-t2v"]
  },
  {
    name: "1024x576 (SVD)",
    width: 1024,
    height: 576,
    aspectRatio: "16:9",
    recommended: ["motionctrl-svd"]
  },
  {
    name: "576x320 (MotionCtrl)",
    width: 576,
    height: 320,
    aspectRatio: "16:9",
    recommended: ["motionctrl"]
  },
  {
    name: "720x480 (CogVideoX)",
    width: 720,
    height: 480,
    aspectRatio: "3:2",
    recommended: ["cogvideox"]
  },
  {
    name: "512x512 (Square)",
    width: 512,
    height: 512,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny", "animatediff-cameractrl"]
  },
  {
    name: "1024x1024 (Square HD)",
    width: 1024,
    height: 1024,
    aspectRatio: "1:1",
    recommended: ["controlnet-depth", "controlnet-canny"]
  }
], vV = [
  {
    name: "16 frames (~0.7s)",
    frameCount: 16,
    duration: "0.67s",
    fps: 24,
    recommended: ["motionctrl", "animatediff-cameractrl"]
  },
  {
    name: "25 frames (~1s)",
    frameCount: 25,
    duration: "1.04s",
    fps: 24,
    recommended: ["motionctrl-svd"]
  },
  {
    name: "49 frames (~3s)",
    frameCount: 49,
    duration: "3.06s",
    fps: 16,
    recommended: ["cogvideox"]
  },
  {
    name: "81 frames (~3.4s)",
    frameCount: 81,
    duration: "3.38s",
    fps: 24,
    recommended: ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "uni3c-camera"]
  },
  {
    name: "121 frames (~5s)",
    frameCount: 121,
    duration: "5.04s",
    fps: 24,
    recommended: ["wan22-i2v"]
  }
], Zv = {
  "wan22-i2v": {
    name: "Wan 2.2 Image-to-Video",
    description: "Generate video from a reference image with text prompt",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanImageToVideo", "WanModel", "WanVAE"]
  },
  "wan22-t2v": {
    name: "Wan 2.2 Text-to-Video",
    description: "Generate video from text prompt only",
    requiredInputs: ["prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanTextToVideo", "WanModel", "WanVAE"]
  },
  "wan22-fun-camera": {
    name: "Wan 2.2 Fun Camera",
    description: "Generate video with camera motion presets",
    requiredInputs: ["reference_image", "prompt", "camera_motion"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFunCameraToVideo", "WanModel", "WanVAE"]
  },
  "wan22-first-last": {
    name: "Wan 2.2 First+Last Frame",
    description: "Generate video interpolating between first and last frames",
    requiredInputs: ["first_frame", "last_frame", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanFirstLastFrameToVideo", "WanModel", "WanVAE"]
  },
  "uni3c-camera": {
    name: "Uni3C Camera Control",
    description: "Generate video with precise 3D camera trajectory control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CCameraControl"]
  },
  "uni3c-motion": {
    name: "Uni3C Human Motion + Camera",
    description: "Generate video with human motion and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "motion_data"],
    optionalInputs: ["depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["Uni3CLoader", "Uni3CMotionControl"]
  },
  motionctrl: {
    name: "MotionCtrl",
    description: "Camera-controlled video generation using pose matrices",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["prompt"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlLoader", "MotionCtrlSample"]
  },
  "motionctrl-svd": {
    name: "MotionCtrl SVD",
    description: "MotionCtrl for Stable Video Diffusion",
    requiredInputs: ["reference_image", "camera_poses"],
    optionalInputs: ["motion_preset"],
    outputTypes: ["video"],
    comfyNodes: ["MotionCtrlSVDLoader", "MotionCtrlSVDSample"]
  },
  cogvideox: {
    name: "CogVideoX",
    description: "High-quality video generation from CogVideo team",
    requiredInputs: ["reference_image", "prompt"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["CogVideoXLoader", "CogVideoXSampler"]
  },
  "controlnet-depth": {
    name: "ControlNet Depth",
    description: "Depth-guided image generation",
    requiredInputs: ["depth_map", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply"]
  },
  "controlnet-canny": {
    name: "ControlNet Canny",
    description: "Edge-guided image generation",
    requiredInputs: ["canny_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "CannyEdgePreprocessor"]
  },
  "controlnet-lineart": {
    name: "ControlNet LineArt",
    description: "Line art guided image generation",
    requiredInputs: ["lineart_image", "prompt"],
    optionalInputs: ["reference_image", "negative_prompt"],
    outputTypes: ["image"],
    comfyNodes: ["ControlNetLoader", "ControlNetApply", "LineArtPreprocessor"]
  },
  "animatediff-cameractrl": {
    name: "AnimateDiff CameraCtrl",
    description: "AnimateDiff with camera control extension",
    requiredInputs: ["reference_image", "camera_poses", "prompt"],
    optionalInputs: ["negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["AnimateDiffLoader", "CameraCtrlPoses"]
  },
  "custom-workflow": {
    name: "Custom Workflow",
    description: "Use your own ComfyUI workflow template",
    requiredInputs: ["workflow_template"],
    optionalInputs: [],
    outputTypes: ["video", "image"],
    comfyNodes: []
  },
  // New model targets (Dec 2025)
  "light-x": {
    name: "Light-X Relighting",
    description: "Video generation with relighting and camera control",
    requiredInputs: ["reference_image", "prompt", "camera_trajectory", "lighting_data"],
    optionalInputs: ["depth_map", "negative_prompt"],
    outputTypes: ["video"],
    comfyNodes: ["LightXLoader", "LightXSampler"]
  },
  "wan-move": {
    name: "Wan-Move Point Trajectories",
    description: "Video generation with user-defined point trajectories",
    requiredInputs: ["reference_image", "prompt", "point_trajectories"],
    optionalInputs: ["negative_prompt", "seed"],
    outputTypes: ["video"],
    comfyNodes: ["WanMoveLoader", "WanMovePointTrajectory"]
  },
  ati: {
    name: "ATI Any Trajectory",
    description: "Any Trajectory Instruction - flexible camera/object motion",
    requiredInputs: ["reference_image", "prompt", "trajectory_instruction"],
    optionalInputs: ["negative_prompt", "camera_poses"],
    outputTypes: ["video"],
    comfyNodes: ["ATILoader", "ATISampler"]
  },
  ttm: {
    name: "TTM Time-to-Move",
    description: "Cut-and-drag video editing with temporal control",
    requiredInputs: ["reference_image", "last_frame", "drag_points"],
    optionalInputs: ["prompt", "mask"],
    outputTypes: ["video"],
    comfyNodes: ["TTMLoader", "TTMDragEditor"]
  },
  "camera-comfyui": {
    name: "Camera-ComfyUI 4x4 Matrices",
    description: "Generic camera control via 4x4 transformation matrices",
    requiredInputs: ["reference_image", "camera_matrices"],
    optionalInputs: ["prompt", "depth_map"],
    outputTypes: ["video"],
    comfyNodes: ["CameraMatrixLoader", "CameraMatrixApply"]
  }
};
function gV(s) {
  const { width: e, height: n, nearClip: i, farClip: r, camera: o, layers: a, frame: l } = s, c = new Float32Array(e * n);
  c.fill(r);
  let u = r, d = i;
  const h = [...a].filter((m) => m.visible).sort((m, p) => {
    const y = zd(m, l), _ = zd(p, l);
    return y - _;
  });
  for (const m of h) {
    const p = zd(m, l), y = yV(m, l);
    if (y < 0.01) continue;
    const _ = _V(m, l, o, e, n);
    if (!_) continue;
    const v = o.position.z, g = Math.abs(p - v), S = Math.max(i, Math.min(r, g));
    u = Math.min(u, S), d = Math.max(d, S), m.type === "depthflow" && xV(m) ? bV(c, m, _, e, n, i, r) : wV(c, _, S, y, e, n);
  }
  return {
    depthBuffer: c,
    width: e,
    height: n,
    minDepth: u,
    maxDepth: d
  };
}
function zd(s, e) {
  var i;
  const n = (i = s.transform) == null ? void 0 : i.position;
  if (!n) return 0;
  if (n.keyframes && n.keyframes.length > 0)
    return Ry(n.keyframes, e, 2) || 0;
  if (n.value) {
    const r = n.value;
    if (typeof r == "object" && "z" in r)
      return r.z ?? 0;
  }
  return 0;
}
function yV(s, e) {
  var n;
  return s.opacity && "keyframes" in s.opacity && ((n = s.opacity.keyframes) == null ? void 0 : n.length) > 0 ? (Ry(s.opacity.keyframes, e) || 100) / 100 : s.opacity && "value" in s.opacity ? (s.opacity.value || 100) / 100 : 1;
}
function _V(s, e, n, i, r) {
  var T, b, M;
  let o = 0, a = 0;
  const l = (T = s.transform) == null ? void 0 : T.position;
  if (l && "value" in l) {
    const L = l.value;
    Array.isArray(L) && (o = L[0] || 0, a = L[1] || 0);
  }
  const c = s.width || i, u = s.height || r;
  let d = 1, h = 1;
  const m = (b = s.transform) == null ? void 0 : b.scale;
  if (m && "value" in m) {
    const L = m.value;
    Array.isArray(L) && (d = (L[0] || 100) / 100, h = (L[1] || 100) / 100);
  }
  const p = c * d, y = u * h;
  let _ = 0.5, v = 0.5;
  const g = (M = s.transform) == null ? void 0 : M.anchorPoint;
  if (g && "value" in g) {
    const L = g.value;
    Array.isArray(L) && (_ = (L[0] || 0) / c + 0.5, v = (L[1] || 0) / u + 0.5);
  }
  const S = o - p * _ + i / 2, w = a - y * v + r / 2, x = Math.max(0, Math.min(i, S)), C = Math.max(0, Math.min(r, w)), E = Math.max(0, Math.min(i - x, p - (x - S))), P = Math.max(0, Math.min(r - C, y - (C - w)));
  return E <= 0 || P <= 0 ? null : {
    x,
    y: C,
    width: E,
    height: P
  };
}
function xV(s) {
  return s.type === "depthflow" && !!s.depthMapData;
}
function bV(s, e, n, i, r, o, a) {
  const l = e.depthMapData, c = e.depthWidth || n.width, u = e.depthHeight || n.height;
  for (let d = 0; d < n.height; d++)
    for (let h = 0; h < n.width; h++) {
      const m = Math.floor(n.x + h), p = Math.floor(n.y + d);
      if (m < 0 || m >= i || p < 0 || p >= r) continue;
      const y = Math.floor(h / n.width * c), v = Math.floor(d / n.height * u) * c + y;
      let g;
      l instanceof Float32Array ? g = l[v] : g = l[v] / 255;
      const S = o + g * (a - o), w = p * i + m;
      S < s[w] && (s[w] = S);
    }
}
function wV(s, e, n, i, r, o) {
  const a = Math.floor(e.x), l = Math.floor(e.y), c = Math.min(r, Math.ceil(e.x + e.width)), u = Math.min(o, Math.ceil(e.y + e.height));
  for (let d = l; d < u; d++)
    for (let h = a; h < c; h++) {
      const m = d * r + h;
      i > 0.5 && n < s[m] && (s[m] = n);
    }
}
function Ry(s, e, n) {
  if (!s || s.length === 0) return null;
  let i = s[0], r = s[s.length - 1];
  for (let c = 0; c < s.length; c++)
    if (s[c].frame <= e && (i = s[c]), s[c].frame >= e && c < s.length) {
      r = s[c];
      break;
    }
  if (i.frame === r.frame) {
    const c = i.value;
    return n !== void 0 && Array.isArray(c) ? c[n] : c;
  }
  const o = (e - i.frame) / (r.frame - i.frame), a = n !== void 0 && Array.isArray(i.value) ? i.value[n] : i.value, l = n !== void 0 && Array.isArray(r.value) ? r.value[n] : r.value;
  return a + (l - a) * o;
}
function SV(s, e) {
  const n = pV[e], { depthBuffer: i, width: r, height: o, minDepth: a, maxDepth: l } = s, c = r * o;
  if (n.bitDepth === 16) {
    const u = new Uint16Array(c);
    for (let d = 0; d < c; d++) {
      let h;
      n.normalize ? h = (i[d] - a) / (l - a) : h = i[d] / n.farClip, n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(65535, Math.round(h * 65535)));
    }
    return u;
  } else {
    const u = new Uint8Array(c);
    for (let d = 0; d < c; d++) {
      let h = (i[d] - a) / (l - a);
      n.invert && (h = 1 - h), u[d] = Math.max(0, Math.min(255, Math.round(h * 255)));
    }
    return u;
  }
}
function MV(s, e, n) {
  const i = new ImageData(e, n), r = s instanceof Uint16Array;
  for (let o = 0; o < e * n; o++) {
    const a = r ? Math.floor(s[o] / 256) : s[o], l = o * 4;
    i.data[l] = a, i.data[l + 1] = a, i.data[l + 2] = a, i.data[l + 3] = 255;
  }
  return i;
}
class CV {
  constructor(e) {
    pe(this, "serverAddress");
    pe(this, "clientId");
    pe(this, "ws", null);
    pe(this, "messageHandlers", /* @__PURE__ */ new Map());
    this.serverAddress = e.serverAddress.replace(/\/$/, ""), this.clientId = e.clientId || this.generateClientId();
  }
  generateClientId() {
    return "weyl_" + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
  }
  // ============================================================================
  // HTTP Endpoints
  // ============================================================================
  /**
   * Check server connectivity
   */
  async checkConnection() {
    try {
      return (await fetch(`http://${this.serverAddress}/system_stats`, {
        method: "GET",
        signal: AbortSignal.timeout(5e3)
      })).ok;
    } catch {
      return !1;
    }
  }
  /**
   * Get system stats (GPU, memory, etc.)
   */
  async getSystemStats() {
    try {
      const e = await fetch(`http://${this.serverAddress}/system_stats`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Get queue status
   */
  async getQueueStatus() {
    try {
      const e = await fetch(`http://${this.serverAddress}/prompt`);
      return e.ok ? e.json() : null;
    } catch {
      return null;
    }
  }
  /**
   * Upload image to ComfyUI input folder
   */
  async uploadImage(e, n, i = "input", r, o = !0) {
    const a = new FormData();
    a.append("image", e, n), a.append("type", i), a.append("overwrite", o.toString()), r && a.append("subfolder", r);
    const l = await fetch(`http://${this.serverAddress}/upload/image`, {
      method: "POST",
      body: a
    });
    if (!l.ok) {
      const c = await l.text();
      throw new Error(`Failed to upload image: ${c}`);
    }
    return l.json();
  }
  /**
   * Upload mask image
   */
  async uploadMask(e, n, i) {
    const r = new FormData();
    r.append("image", e, n), r.append("original_ref", JSON.stringify(i)), r.append("type", "input");
    const o = await fetch(`http://${this.serverAddress}/upload/mask`, {
      method: "POST",
      body: r
    });
    if (!o.ok)
      throw new Error(`Failed to upload mask: ${await o.text()}`);
    return o.json();
  }
  /**
   * Queue a workflow for execution
   */
  async queuePrompt(e, n) {
    const i = {
      prompt: e,
      client_id: this.clientId,
      extra_data: n
    }, r = await fetch(`http://${this.serverAddress}/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(i)
    });
    if (!r.ok) {
      const o = await r.text();
      throw new Error(`Failed to queue prompt: ${o}`);
    }
    return r.json();
  }
  /**
   * Get execution history for a prompt
   */
  async getHistory(e) {
    const n = e ? `http://${this.serverAddress}/history/${e}` : `http://${this.serverAddress}/history`, i = await fetch(n);
    if (!i.ok)
      throw new Error(`Failed to get history: ${await i.text()}`);
    return i.json();
  }
  /**
   * Get a specific output image/video
   */
  async getOutput(e, n = "", i = "output") {
    const r = new URLSearchParams({
      filename: e,
      subfolder: n,
      type: i
    }), o = await fetch(`http://${this.serverAddress}/view?${r}`);
    if (!o.ok)
      throw new Error(`Failed to get output: ${await o.text()}`);
    return o.blob();
  }
  /**
   * Get output as data URL
   */
  async getOutputAsDataURL(e, n = "", i = "output") {
    const r = await this.getOutput(e, n, i);
    return new Promise((o, a) => {
      const l = new FileReader();
      l.onloadend = () => o(l.result), l.onerror = a, l.readAsDataURL(r);
    });
  }
  /**
   * Cancel current execution
   */
  async interrupt() {
    const e = await fetch(`http://${this.serverAddress}/interrupt`, {
      method: "POST"
    });
    if (!e.ok)
      throw new Error(`Failed to interrupt: ${await e.text()}`);
  }
  /**
   * Clear queue
   */
  async clearQueue() {
    const e = await fetch(`http://${this.serverAddress}/queue`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ clear: !0 })
    });
    if (!e.ok)
      throw new Error(`Failed to clear queue: ${await e.text()}`);
  }
  /**
   * Delete item from queue
   */
  async deleteFromQueue(e, n) {
    const i = await fetch(`http://${this.serverAddress}/${e}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delete: n })
    });
    if (!i.ok)
      throw new Error(`Failed to delete from ${e}: ${await i.text()}`);
  }
  /**
   * Get available models
   */
  async getModels(e) {
    const n = {
      checkpoints: "checkpoints",
      loras: "loras",
      vae: "vae",
      controlnet: "controlnet"
    }, i = await fetch(
      `http://${this.serverAddress}/models/${n[e]}`
    );
    return i.ok ? i.json() : [];
  }
  /**
   * Get available ControlNet models
   */
  async getControlNetModels() {
    return this.getModels("controlnet");
  }
  // ============================================================================
  // WebSocket Connection
  // ============================================================================
  /**
   * Connect WebSocket for real-time progress updates
   */
  connectWebSocket() {
    return new Promise((e, n) => {
      const i = `ws://${this.serverAddress}/ws?clientId=${this.clientId}`;
      this.ws = new WebSocket(i), this.ws.onopen = () => {
        console.log("[ComfyUI] WebSocket connected"), e();
      }, this.ws.onerror = (r) => {
        console.error("[ComfyUI] WebSocket error:", r), n(new Error("WebSocket connection failed"));
      }, this.ws.onclose = () => {
        console.log("[ComfyUI] WebSocket disconnected"), this.ws = null;
      }, this.ws.onmessage = (r) => {
        try {
          const o = JSON.parse(r.data);
          this.handleWebSocketMessage(o);
        } catch (o) {
          console.error("[ComfyUI] Failed to parse WebSocket message:", o);
        }
      };
    });
  }
  /**
   * Disconnect WebSocket
   */
  disconnectWebSocket() {
    this.ws && (this.ws.close(), this.ws = null), this.messageHandlers.clear();
  }
  /**
   * Check if WebSocket is connected
   */
  isWebSocketConnected() {
    return this.ws !== null && this.ws.readyState === WebSocket.OPEN;
  }
  /**
   * Register a message handler for a specific message type
   */
  onMessage(e, n) {
    this.messageHandlers.set(e, n);
  }
  /**
   * Remove a message handler
   */
  offMessage(e) {
    this.messageHandlers.delete(e);
  }
  handleWebSocketMessage(e) {
    const { type: n } = e, i = this.messageHandlers.get(n);
    i && i(e);
    const r = this.messageHandlers.get("all");
    r && r(e);
  }
  // ============================================================================
  // Convenience Methods
  // ============================================================================
  /**
   * Upload an ImageData object as PNG
   */
  async uploadImageData(e, n, i) {
    const r = new OffscreenCanvas(e.width, e.height);
    r.getContext("2d").putImageData(e, 0, 0);
    const a = await r.convertToBlob({ type: "image/png" });
    return this.uploadImage(a, n, "input", i);
  }
  /**
   * Upload a canvas as PNG
   */
  async uploadCanvas(e, n, i) {
    let r;
    return e instanceof OffscreenCanvas ? r = await e.convertToBlob({ type: "image/png" }) : r = await new Promise((o, a) => {
      e.toBlob((l) => {
        l ? o(l) : a(new Error("Failed to convert canvas to blob"));
      }, "image/png");
    }), this.uploadImage(r, n, "input", i);
  }
  /**
   * Wait for a prompt to complete
   */
  async waitForPrompt(e, n, i = 3e5) {
    const r = Date.now();
    return this.isWebSocketConnected() || await this.connectWebSocket(), new Promise((o, a) => {
      let l = !1;
      const c = () => {
        this.offMessage("progress"), this.offMessage("executing"), this.offMessage("executed"), this.offMessage("execution_error");
      }, u = () => {
        Date.now() - r > i && (c(), a(new Error("Prompt execution timed out")));
      };
      this.onMessage("progress", (d) => {
        u(), n == null || n({
          status: "executing",
          currentStep: d.data.value,
          totalSteps: d.data.max,
          percentage: d.data.value / d.data.max * 100
        });
      }), this.onMessage("executing", (d) => {
        u(), d.data.prompt_id === e && (n == null || n({
          status: "executing",
          currentNode: d.data.node,
          percentage: 10
          // Approximate
        }));
      }), this.onMessage("executed", async (d) => {
        if (d.data.prompt_id === e && !l) {
          l = !0, c(), n == null || n({
            status: "completed",
            percentage: 100
          });
          const h = await this.getHistory(e);
          o(h[e]);
        }
      }), this.onMessage("execution_error", (d) => {
        d.data.prompt_id === e && (c(), n == null || n({
          status: "error",
          percentage: 0
        }), a(new Error(d.data.exception_message || "Execution failed")));
      });
    });
  }
  /**
   * Execute a workflow and wait for completion
   */
  async executeWorkflow(e, n) {
    const { prompt_id: i } = await this.queuePrompt(e);
    n == null || n({
      status: "queued",
      percentage: 0
    });
    const r = await this.waitForPrompt(i, n), o = [];
    for (const a of Object.values(r.outputs))
      a.images && o.push(...a.images), a.gifs && o.push(...a.gifs);
    return {
      promptId: i,
      history: r,
      outputs: o
    };
  }
  // ============================================================================
  // Getters
  // ============================================================================
  get server() {
    return this.serverAddress;
  }
  get id() {
    return this.clientId;
  }
}
let pc = null;
function vo(s) {
  return (!pc || s && s !== pc.server) && (pc = new CV({
    serverAddress: s || "127.0.0.1:8188"
  })), pc;
}
let Iy = 1;
function Rs() {
  Iy = 1;
}
function vt() {
  return String(Iy++);
}
function ht(s, e, n) {
  const i = {
    class_type: s,
    inputs: e
  };
  return n && (i._meta = { title: n }), i;
}
function $e(s, e = 0) {
  return [s, e];
}
function Hf(s, e) {
  const n = vt();
  return s[n] = ht("CheckpointLoaderSimple", {
    ckpt_name: e
  }, "Load Checkpoint"), n;
}
function Bo(s, e, n, i) {
  const r = vt();
  return s[r] = ht("CLIPTextEncode", {
    clip: e,
    text: n
  }, i), r;
}
function tr(s, e, n) {
  const i = vt();
  return s[i] = ht("LoadImage", {
    image: e
  }, n || "Load Image"), i;
}
function nr(s, e, n, i) {
  const r = vt();
  return s[r] = ht("ImageResize", {
    image: e,
    width: n,
    height: i,
    interpolation: "lanczos",
    method: "fill / crop",
    condition: "always",
    multiple_of: 8
  }, "Resize Image"), r;
}
function EV(s, e, n) {
  const i = vt();
  return s[i] = ht("VAEEncode", {
    pixels: e,
    vae: n
  }, "VAE Encode"), i;
}
function yl(s, e, n) {
  const i = vt();
  return s[i] = ht("VAEDecode", {
    samples: e,
    vae: n
  }, "VAE Decode"), i;
}
function _l(s, e, n, i, r, o) {
  const a = vt();
  return s[a] = ht("KSampler", {
    model: e,
    positive: n,
    negative: i,
    latent_image: r,
    seed: o.seed ?? Math.floor(Math.random() * 2147483647),
    steps: o.steps ?? 20,
    cfg: o.cfg ?? 7,
    sampler_name: "euler",
    scheduler: "normal",
    denoise: o.denoise ?? 1
  }, "KSampler"), a;
}
function Is(s, e, n) {
  const i = vt();
  return s[i] = ht("VHS_VideoCombine", {
    images: e,
    frame_rate: n.fps,
    loop_count: 0,
    filename_prefix: n.filename || "weyl_output",
    format: n.format || "video/h264-mp4",
    pingpong: !1,
    save_output: !0,
    audio: null,
    meta_batch: null
  }, "Video Output"), i;
}
function Kv(s) {
  Rs();
  const e = {}, n = s.width > 640 || s.height > 640, i = s.wanModel || (n ? "i2v_720p" : "i2v_480p"), r = vt();
  e[r] = ht("DownloadAndLoadWan2_1Model", {
    model: `wan2.1_${i}_bf16.safetensors`,
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Model");
  const o = vt();
  e[o] = ht("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const a = vt();
  e[a] = ht("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const l = tr(e, s.referenceImage || "input.png", "Reference Image"), c = nr(e, $e(l), s.width, s.height), u = vt();
  e[u] = ht("WanTextEncode", {
    text_encoder: $e(a),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = vt();
  e[d] = ht("WanImageToVideo", {
    wan_model: $e(r),
    positive: $e(u),
    image: $e(c),
    vae: $e(o),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE",
    denoise_strength: s.denoise || 1
  }, "I2V Generation");
  const h = vt();
  return e[h] = ht("WanVAEDecode", {
    vae: $e(o),
    samples: $e(d),
    enable_vae_tiling: !0,
    tile_sample_min_height: 240,
    tile_sample_min_width: 240,
    tile_overlap_factor_height: 0.2,
    tile_overlap_factor_width: 0.2
  }, "VAE Decode"), Is(e, $e(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_i2v"
  }), e;
}
function TV(s) {
  Rs();
  const e = {}, n = vt();
  e[n] = ht("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_fun_camera_control_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan Fun Camera");
  const i = vt();
  e[i] = ht("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load Wan VAE");
  const r = vt();
  e[r] = ht("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = tr(e, s.referenceImage || "input.png", "Reference Image"), a = nr(e, $e(o), s.width, s.height), l = vt();
  e[l] = ht("WanTextEncode", {
    text_encoder: $e(r),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const c = vt();
  e[c] = ht("WanFunCameraMotion", {
    motion_type: s.cameraMotion || "Static",
    length: s.frameCount
  }, "Camera Motion");
  const u = vt();
  e[u] = ht("WanFunCameraI2V", {
    wan_model: $e(n),
    positive: $e(l),
    image: $e(a),
    camera_motion: $e(c),
    vae: $e(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "Fun Camera I2V");
  const d = vt();
  return e[d] = ht("WanVAEDecode", {
    vae: $e(i),
    samples: $e(u),
    enable_vae_tiling: !0
  }, "VAE Decode"), Is(e, $e(d), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_fun_camera"
  }), e;
}
function AV(s) {
  Rs();
  const e = {}, n = vt();
  e[n] = ht("DownloadAndLoadWan2_1Model", {
    model: "wan2.1_flf2v_720p_bf16.safetensors",
    base_precision: "bf16",
    quantization: "disabled"
  }, "Load Wan FLF2V");
  const i = vt();
  e[i] = ht("DownloadAndLoadWanVAE", {
    vae: "wan_2.1_vae.safetensors",
    precision: "bf16"
  }, "Load VAE");
  const r = vt();
  e[r] = ht("DownloadAndLoadWanTextEncoder", {
    text_encoder: "umt5-xxl-enc-bf16.safetensors",
    precision: "bf16"
  }, "Load Text Encoder");
  const o = tr(e, s.referenceImage || "first.png", "First Frame"), a = tr(e, s.lastFrameImage || "last.png", "Last Frame"), l = nr(e, $e(o), s.width, s.height), c = nr(e, $e(a), s.width, s.height), u = vt();
  e[u] = ht("WanTextEncode", {
    text_encoder: $e(r),
    prompt: s.prompt,
    force_offload: !0
  }, "Positive Prompt");
  const d = vt();
  e[d] = ht("WanFirstLastFrameToVideo", {
    wan_model: $e(n),
    positive: $e(u),
    first_frame: $e(l),
    last_frame: $e(c),
    vae: $e(i),
    width: s.width,
    height: s.height,
    length: s.frameCount,
    steps: s.steps || 30,
    cfg: s.cfgScale || 5,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "DPM++ 2M SDE"
  }, "First+Last I2V");
  const h = vt();
  return e[h] = ht("WanVAEDecode", {
    vae: $e(i),
    samples: $e(d),
    enable_vae_tiling: !0
  }, "VAE Decode"), Is(e, $e(h), {
    fps: s.fps,
    filename: s.outputFilename || "wan22_flf"
  }), e;
}
function PV(s) {
  var h;
  Rs();
  const e = {}, n = vt();
  e[n] = ht("DownloadAndLoadUni3CModel", {
    model: "uni3c_camera_control.safetensors",
    precision: "bf16"
  }, "Load Uni3C");
  const i = vt();
  e[i] = ht("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const r = tr(e, s.referenceImage || "input.png", "Reference Image"), o = nr(e, $e(r), s.width, s.height), a = vt();
  s.trajType === "custom" && ((h = s.cameraData) != null && h.trajectory) ? e[a] = ht("Uni3CCustomTrajectory", {
    trajectory_data: JSON.stringify(s.cameraData.trajectory),
    length: s.frameCount
  }, "Custom Trajectory") : e[a] = ht("Uni3CPresetTrajectory", {
    traj_type: s.trajType || "orbit",
    length: s.frameCount
  }, "Preset Trajectory");
  const l = vt();
  e[l] = ht("ApplyUni3CCameraControl", {
    model: $e(i),
    uni3c: $e(n),
    trajectory: $e(a),
    image: $e(o),
    control_strength: 1
  }, "Apply Camera Control");
  const c = vt();
  e[c] = ht("SVDEncode", {
    model: $e(l),
    image: $e(o),
    vae: $e(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = _l(
    e,
    $e(l),
    $e(c, 1),
    $e(c, 2),
    $e(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5, denoise: 1 }
  ), d = yl(e, $e(u), $e(i, 2));
  return Is(e, $e(d), {
    fps: s.fps,
    filename: s.outputFilename || "uni3c_output"
  }), e;
}
function DV(s) {
  Rs();
  const e = {}, n = vt();
  e[n] = ht("LoadMotionCtrl", {
    model: "motionctrl.pth"
  }, "Load MotionCtrl");
  const i = vt();
  e[i] = ht("ImageOnlyCheckpointLoader", {
    ckpt_name: s.checkpoint || "svd_xt_1_1.safetensors"
  }, "Load Base Model");
  const r = tr(e, s.referenceImage || "input.png", "Reference Image"), o = nr(e, $e(r), s.width, s.height), a = vt();
  s.cameraPoses ? e[a] = ht("MotionCtrlCameraPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[a] = ht("MotionCtrlPresetPoses", {
    preset: s.motionPreset || "static",
    length: s.frameCount
  }, "Preset Poses");
  const l = vt();
  e[l] = ht("ApplyMotionCtrl", {
    model: $e(i),
    motion_ctrl: $e(n),
    camera_poses: $e(a),
    control_strength: 1
  }, "Apply MotionCtrl");
  const c = vt();
  e[c] = ht("SVDEncode", {
    model: $e(l),
    image: $e(o),
    vae: $e(i, 2),
    width: s.width,
    height: s.height,
    video_frames: s.frameCount,
    motion_bucket_id: 127,
    fps: s.fps,
    augmentation_level: 0
  }, "SVD Encode");
  const u = _l(
    e,
    $e(l),
    $e(c, 1),
    $e(c, 2),
    $e(c),
    { seed: s.seed, steps: s.steps || 25, cfg: s.cfgScale || 2.5 }
  ), d = yl(e, $e(u), $e(i, 2));
  return Is(e, $e(d), {
    fps: s.fps,
    filename: s.outputFilename || "motionctrl_output"
  }), e;
}
function RV(s) {
  Rs();
  const e = {}, n = Hf(e, s.checkpoint || "sd_xl_base_1.0.safetensors"), i = vt();
  e[i] = ht("ControlNetLoader", {
    control_net_name: s.controlnetModel || "control_v11f1p_sd15_depth.pth"
  }, "Load ControlNet Depth");
  const r = vt();
  e[r] = ht("VHS_LoadImages", {
    directory: "depth_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Depth Sequence");
  const o = tr(e, s.referenceImage || "reference.png", "Reference Image"), a = nr(e, $e(o), s.width, s.height), l = Bo(e, $e(n, 1), s.prompt, "Positive"), c = Bo(e, $e(n, 1), s.negativePrompt, "Negative"), u = vt();
  e[u] = ht("ControlNetApply", {
    conditioning: $e(l),
    control_net: $e(i),
    image: $e(r),
    strength: 1
  }, "Apply ControlNet");
  const d = EV(e, $e(a), $e(n, 2)), h = _l(
    e,
    $e(n),
    $e(u),
    $e(c),
    $e(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7, denoise: s.denoise || 0.75 }
  ), m = yl(e, $e(h), $e(n, 2));
  return Is(e, $e(m), {
    fps: s.fps,
    filename: s.outputFilename || "controlnet_depth"
  }), e;
}
function IV(s) {
  Rs();
  const e = {}, n = Hf(e, s.checkpoint || "dreamshaper_8.safetensors"), i = vt();
  e[i] = ht("ADE_LoadAnimateDiffModel", {
    model_name: "mm_sd_v15_v2.ckpt"
  }, "Load AnimateDiff");
  const r = vt();
  e[r] = ht("ADE_LoadCameraCtrlModel", {
    model_name: "cameractrl_v10.ckpt"
  }, "Load CameraCtrl");
  const o = vt();
  s.cameraPoses ? e[o] = ht("ADE_CameraCtrlPoses", {
    poses: JSON.stringify(s.cameraPoses)
  }, "Camera Poses") : e[o] = ht("ADE_CameraCtrlPreset", {
    motion_type: s.cameraMotion || "Static",
    speed: 1,
    frame_length: s.frameCount
  }, "Camera Preset");
  const a = vt();
  e[a] = ht("ADE_ApplyAnimateDiffModel", {
    model: $e(n),
    motion_model: $e(i)
  }, "Apply AnimateDiff");
  const l = vt();
  e[l] = ht("ADE_ApplyCameraCtrl", {
    model: $e(a),
    cameractrl: $e(r),
    poses: $e(o)
  }, "Apply CameraCtrl");
  const c = Bo(e, $e(n, 1), s.prompt, "Positive"), u = Bo(e, $e(n, 1), s.negativePrompt, "Negative"), d = vt();
  e[d] = ht("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = _l(
    e,
    $e(l),
    $e(c),
    $e(u),
    $e(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), m = yl(e, $e(h), $e(n, 2));
  return Is(e, $e(m), {
    fps: s.fps,
    filename: s.outputFilename || "animatediff_cameractrl"
  }), e;
}
function kV(s) {
  Rs();
  const e = {}, n = vt();
  e[n] = ht("DownloadAndLoadCogVideoModel", {
    model: "CogVideoX-5b-I2V",
    precision: "bf16"
  }, "Load CogVideoX");
  const i = vt();
  e[i] = ht("DownloadAndLoadCogVideoTextEncoder", {
    model: "t5-v1_1-xxl-encoder-bf16",
    precision: "bf16"
  }, "Load T5 Encoder");
  const r = vt();
  e[r] = ht("DownloadAndLoadCogVideoVAE", {
    model: "cogvideox_vae",
    precision: "bf16"
  }, "Load CogVideo VAE");
  const o = tr(e, s.referenceImage || "input.png", "Reference Image"), a = nr(e, $e(o), s.width, s.height), l = vt();
  e[l] = ht("CogVideoTextEncode", {
    text_encoder: $e(i),
    prompt: s.prompt,
    force_offload: !0
  }, "Encode Prompt");
  const c = vt();
  e[c] = ht("CogVideoImageToVideo", {
    model: $e(n),
    positive: $e(l),
    image: $e(a),
    vae: $e(r),
    width: s.width,
    height: s.height,
    num_frames: s.frameCount,
    steps: s.steps || 50,
    cfg: s.cfgScale || 6,
    seed: s.seed ?? Math.floor(Math.random() * 2147483647),
    scheduler: "CogVideoX DDIM"
  }, "CogVideoX I2V");
  const u = vt();
  return e[u] = ht("CogVideoDecode", {
    vae: $e(r),
    samples: $e(c),
    enable_vae_tiling: !0
  }, "Decode Video"), Is(e, $e(u), {
    fps: s.fps,
    filename: s.outputFilename || "cogvideox_output"
  }), e;
}
function Jv(s, e) {
  Rs();
  const n = {}, i = {
    canny: "control_v11p_sd15_canny.pth",
    lineart: "control_v11p_sd15_lineart.pth",
    softedge: "control_v11p_sd15_softedge.pth",
    normal: "control_v11p_sd15_normalbae.pth",
    seg: "control_v11p_sd15_seg.pth"
  }, r = Hf(n, s.checkpoint || "v1-5-pruned-emaonly.safetensors"), o = vt();
  n[o] = ht("ControlNetLoader", {
    control_net_name: s.controlnetModel || i[e]
  }, `Load ControlNet ${e}`);
  const a = vt();
  n[a] = ht("VHS_LoadImages", {
    directory: "control_sequence",
    image_load_cap: s.frameCount,
    skip_first_images: 0,
    select_every_nth: 1
  }, "Load Control Sequence");
  const l = Bo(n, $e(r, 1), s.prompt, "Positive"), c = Bo(n, $e(r, 1), s.negativePrompt, "Negative"), u = vt();
  n[u] = ht("ControlNetApply", {
    conditioning: $e(l),
    control_net: $e(o),
    image: $e(a),
    strength: 1
  }, "Apply ControlNet");
  const d = vt();
  n[d] = ht("EmptyLatentImage", {
    width: s.width,
    height: s.height,
    batch_size: s.frameCount
  }, "Empty Latent");
  const h = _l(
    n,
    $e(r),
    $e(u),
    $e(c),
    $e(d),
    { seed: s.seed, steps: s.steps || 20, cfg: s.cfgScale || 7 }
  ), m = yl(n, $e(h), $e(r, 2));
  return Is(n, $e(m), {
    fps: s.fps,
    filename: s.outputFilename || `controlnet_${e}`
  }), n;
}
function LV(s, e) {
  switch (s) {
    case "wan22-i2v":
      return Kv(e);
    case "wan22-t2v":
      return Kv({ ...e, referenceImage: void 0 });
    case "wan22-fun-camera":
      return TV(e);
    case "wan22-first-last":
      return AV(e);
    case "uni3c-camera":
    case "uni3c-motion":
      return PV(e);
    case "motionctrl":
    case "motionctrl-svd":
      return DV(e);
    case "cogvideox":
      return kV(e);
    case "controlnet-depth":
      return RV(e);
    case "controlnet-canny":
      return Jv(e, "canny");
    case "controlnet-lineart":
      return Jv(e, "lineart");
    case "animatediff-cameractrl":
      return IV(e);
    case "custom-workflow":
      return {};
    default:
      throw new Error(`Unknown export target: ${s}`);
  }
}
function FV(s) {
  const e = [], n = [], i = Object.keys(s);
  for (const [o, a] of Object.entries(s)) {
    a.class_type || e.push(`Node ${o}: missing class_type`);
    for (const [l, c] of Object.entries(a.inputs))
      if (Array.isArray(c) && c.length === 2) {
        const [u] = c;
        typeof u == "string" && !i.includes(u) && e.push(`Node ${o}.${l}: references non-existent node ${u}`);
      }
  }
  return Object.values(s).some(
    (o) => o.class_type.includes("Save") || o.class_type.includes("Output") || o.class_type.includes("Preview")
  ) || n.push("Workflow has no output/save nodes"), {
    valid: e.length === 0,
    errors: e,
    warnings: n
  };
}
class UV {
  constructor(e) {
    pe(this, "layers");
    pe(this, "cameraKeyframes");
    pe(this, "config");
    pe(this, "onProgress");
    pe(this, "abortSignal");
    pe(this, "aborted", !1);
    this.layers = e.layers, this.cameraKeyframes = e.cameraKeyframes, this.config = e.config, this.onProgress = e.onProgress || (() => {
    }), this.abortSignal = e.abortSignal, this.abortSignal && this.abortSignal.addEventListener("abort", () => {
      this.aborted = !0;
    });
  }
  checkAborted() {
    if (this.aborted)
      throw new Error("Export aborted");
  }
  updateProgress(e) {
    this.onProgress({
      stage: "preparing",
      stageProgress: 0,
      overallProgress: 0,
      message: "",
      ...e
    });
  }
  // ============================================================================
  // Main Export Method
  // ============================================================================
  async execute() {
    const e = Date.now(), n = {
      success: !1,
      outputFiles: {},
      errors: [],
      warnings: [],
      duration: 0
    };
    try {
      this.updateProgress({
        stage: "preparing",
        stageProgress: 0,
        overallProgress: 0,
        message: "Preparing export..."
      });
      const i = this.validateConfig();
      if (i.length > 0)
        return n.errors = i, n;
      this.config.exportReferenceFrame && (this.checkAborted(), await this.renderReferenceFrame(n)), this.config.exportLastFrame && (this.checkAborted(), await this.renderLastFrame(n)), this.config.exportDepthMap && (this.checkAborted(), await this.renderDepthSequence(n)), this.config.exportControlImages && (this.checkAborted(), await this.renderControlSequence(n)), this.config.exportCameraData && (this.checkAborted(), await this.exportCameraData(n)), this.checkAborted(), await this.generateWorkflow(n), this.config.autoQueueWorkflow && this.config.comfyuiServer && (this.checkAborted(), await this.queueWorkflow(n)), n.success = n.errors.length === 0;
    } catch (i) {
      i instanceof Error && i.message === "Export aborted" ? n.errors.push("Export was cancelled") : n.errors.push(i instanceof Error ? i.message : "Unknown error");
    }
    return n.duration = Date.now() - e, n;
  }
  // ============================================================================
  // Validation
  // ============================================================================
  validateConfig() {
    const e = [];
    return (this.config.width < 64 || this.config.width > 4096) && e.push("Width must be between 64 and 4096"), (this.config.height < 64 || this.config.height > 4096) && e.push("Height must be between 64 and 4096"), (this.config.frameCount < 1 || this.config.frameCount > 1e3) && e.push("Frame count must be between 1 and 1000"), (this.config.fps < 1 || this.config.fps > 120) && e.push("FPS must be between 1 and 120"), (this.config.startFrame < 0 || this.config.startFrame >= this.config.frameCount) && e.push("Invalid start frame"), (this.config.endFrame <= this.config.startFrame || this.config.endFrame > this.config.frameCount) && e.push("Invalid end frame"), !this.config.prompt && this.needsPrompt() && e.push("Prompt is required for this export target"), e;
  }
  needsPrompt() {
    return !["controlnet-depth", "controlnet-canny", "controlnet-lineart"].includes(this.config.target);
  }
  // ============================================================================
  // Frame Rendering
  // ============================================================================
  async renderReferenceFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 5,
      message: "Rendering reference frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.startFrame);
    const r = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_reference.png`;
    if (this.config.comfyuiServer) {
      const l = await vo(this.config.comfyuiServer).uploadImage(r, o);
      e.outputFiles.referenceImage = l.name;
    } else
      e.outputFiles.referenceImage = await this.saveBlobLocally(r, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 10,
      message: "Reference frame complete"
    });
  }
  async renderLastFrame(e) {
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 0,
      overallProgress: 12,
      message: "Rendering last frame..."
    });
    const n = new OffscreenCanvas(this.config.width, this.config.height), i = n.getContext("2d");
    await this.renderFrameToCanvas(i, this.config.endFrame - 1);
    const r = await n.convertToBlob({ type: "image/png" }), o = `${this.config.filenamePrefix}_last.png`;
    if (this.config.comfyuiServer) {
      const l = await vo(this.config.comfyuiServer).uploadImage(r, o);
      e.outputFiles.lastImage = l.name;
    } else
      e.outputFiles.lastImage = await this.saveBlobLocally(r, o);
    this.updateProgress({
      stage: "rendering_frames",
      stageProgress: 100,
      overallProgress: 15,
      message: "Last frame complete"
    });
  }
  async renderFrameToCanvas(e, n) {
    e.clearRect(0, 0, e.canvas.width, e.canvas.height);
    const i = [...this.layers].filter((r) => r.visible).sort((r, o) => {
      var c, u, d, h, m, p;
      const a = ((d = (u = (c = r.transform) == null ? void 0 : c.position) == null ? void 0 : u.value) == null ? void 0 : d.z) ?? 0, l = ((p = (m = (h = o.transform) == null ? void 0 : h.position) == null ? void 0 : m.value) == null ? void 0 : p.z) ?? 0;
      return a - l;
    });
    for (const r of i)
      await this.renderLayerToCanvas(e, r, n);
  }
  async renderLayerToCanvas(e, n, i) {
    var u, d, h, m, p, y, _;
    const r = ((d = (u = n.transform) == null ? void 0 : u.position) == null ? void 0 : d.value) ?? { x: 0, y: 0 }, o = ((m = (h = n.transform) == null ? void 0 : h.scale) == null ? void 0 : m.value) ?? { x: 100, y: 100 }, a = ((y = (p = n.transform) == null ? void 0 : p.rotation) == null ? void 0 : y.value) ?? 0, l = typeof ((_ = n.opacity) == null ? void 0 : _.value) == "number" ? n.opacity.value : 100;
    e.save(), e.globalAlpha = l / 100, e.translate(r.x, r.y), e.rotate(a * Math.PI / 180), e.scale(o.x / 100, o.y / 100);
    const c = n.data;
    if (n.type === "image" && (c != null && c.src)) {
      const v = await this.loadImage(c.src);
      e.drawImage(v, -v.width / 2, -v.height / 2);
    } else if (n.type === "solid" && (c != null && c.color)) {
      e.fillStyle = c.color || "#000000";
      const v = c.width ?? 100, g = c.height ?? 100;
      e.fillRect(-v / 2, -g / 2, v, g);
    }
    e.restore();
  }
  loadImage(e) {
    return new Promise((n, i) => {
      const r = new Image();
      r.onload = () => n(r), r.onerror = i, r.src = e;
    });
  }
  // ============================================================================
  // Depth Sequence Rendering
  // ============================================================================
  async renderDepthSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let r = 0; r < n; r++) {
      this.checkAborted();
      const o = this.config.startFrame + r, a = r / n * 100;
      this.updateProgress({
        stage: "rendering_depth",
        stageProgress: a,
        overallProgress: 15 + a * 0.25,
        currentFrame: r + 1,
        totalFrames: n,
        message: `Rendering depth frame ${r + 1}/${n}`
      });
      const l = {
        id: "default",
        name: "Default Camera",
        type: "one-node",
        position: { x: 0, y: 0, z: 1e3 },
        pointOfInterest: { x: 0, y: 0, z: 0 },
        orientation: { x: 0, y: 0, z: 0 },
        xRotation: 0,
        yRotation: 0,
        zRotation: 0,
        zoom: 1,
        focalLength: 50,
        angleOfView: 60,
        filmSize: 36,
        measureFilmSize: "horizontal",
        nearClip: 0.1,
        farClip: 100,
        depthOfField: {
          enabled: !1,
          focusDistance: 100,
          aperture: 1.2,
          fStop: 2.8,
          blurLevel: 1,
          lockToZoom: !1
        },
        iris: {
          shape: 7,
          rotation: 0,
          roundness: 0,
          aspectRatio: 1,
          diffractionFringe: 0
        },
        highlight: {
          gain: 0,
          threshold: 1,
          saturation: 1
        },
        autoOrient: "off"
      }, c = gV({
        width: this.config.width,
        height: this.config.height,
        nearClip: 0.1,
        farClip: 100,
        camera: l,
        layers: this.layers,
        frame: o
      }), u = SV(
        c,
        this.config.depthFormat
      ), d = MV(
        u,
        this.config.width,
        this.config.height
      ), h = new OffscreenCanvas(this.config.width, this.config.height);
      h.getContext("2d").putImageData(d, 0, 0);
      const p = await h.convertToBlob({ type: "image/png" }), y = `${this.config.filenamePrefix}_depth_${String(r).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const v = await vo(this.config.comfyuiServer).uploadImage(p, y, "input", "depth_sequence");
        i.push(v.name);
      } else
        i.push(await this.saveBlobLocally(p, y));
    }
    e.outputFiles.depthSequence = i, this.updateProgress({
      stage: "rendering_depth",
      stageProgress: 100,
      overallProgress: 40,
      message: "Depth sequence complete"
    });
  }
  // ============================================================================
  // Control Image Rendering
  // ============================================================================
  async renderControlSequence(e) {
    const n = this.config.endFrame - this.config.startFrame, i = [];
    for (let r = 0; r < n; r++) {
      this.checkAborted();
      const o = this.config.startFrame + r, a = r / n * 100;
      this.updateProgress({
        stage: "rendering_control",
        stageProgress: a,
        overallProgress: 40 + a * 0.2,
        currentFrame: r + 1,
        totalFrames: n,
        message: `Rendering control frame ${r + 1}/${n}`
      });
      const l = new OffscreenCanvas(this.config.width, this.config.height), c = l.getContext("2d");
      await this.renderFrameToCanvas(c, o);
      const d = await (await this.applyControlPreprocessing(l, this.config.controlType || "depth")).convertToBlob({ type: "image/png" }), h = `${this.config.filenamePrefix}_control_${String(r).padStart(5, "0")}.png`;
      if (this.config.comfyuiServer) {
        const p = await vo(this.config.comfyuiServer).uploadImage(d, h, "input", "control_sequence");
        i.push(p.name);
      } else
        i.push(await this.saveBlobLocally(d, h));
    }
    e.outputFiles.controlSequence = i, this.updateProgress({
      stage: "rendering_control",
      stageProgress: 100,
      overallProgress: 60,
      message: "Control sequence complete"
    });
  }
  async applyControlPreprocessing(e, n) {
    const i = new OffscreenCanvas(e.width, e.height), r = i.getContext("2d"), a = e.getContext("2d").getImageData(0, 0, e.width, e.height), l = a.data;
    switch (n) {
      case "canny":
        this.applyEdgeDetection(l, e.width, e.height);
        break;
      case "lineart":
        this.applyLineart(l);
        break;
      case "softedge":
        this.applySoftEdge(l, e.width, e.height);
        break;
    }
    return r.putImageData(a, 0, 0), i;
  }
  applyEdgeDetection(e, n, i) {
    const r = new Float32Array(n * i);
    for (let a = 0; a < n * i; a++) {
      const l = a * 4;
      r[a] = (e[l] * 0.299 + e[l + 1] * 0.587 + e[l + 2] * 0.114) / 255;
    }
    const o = new Float32Array(n * i);
    for (let a = 1; a < i - 1; a++)
      for (let l = 1; l < n - 1; l++) {
        const c = a * n + l, u = -r[c - n - 1] + r[c - n + 1] + -2 * r[c - 1] + 2 * r[c + 1] + -r[c + n - 1] + r[c + n + 1], d = -r[c - n - 1] - 2 * r[c - n] - r[c - n + 1] + r[c + n - 1] + 2 * r[c + n] + r[c + n + 1];
        o[c] = Math.min(1, Math.sqrt(u * u + d * d) * 2);
      }
    for (let a = 0; a < n * i; a++) {
      const l = a * 4, c = Math.floor(o[a] * 255);
      e[l] = c, e[l + 1] = c, e[l + 2] = c;
    }
  }
  applyLineart(e) {
    for (let n = 0; n < e.length; n += 4) {
      const r = e[n] * 0.299 + e[n + 1] * 0.587 + e[n + 2] * 0.114 > 128 ? 255 : 0;
      e[n] = r, e[n + 1] = r, e[n + 2] = r;
    }
  }
  applySoftEdge(e, n, i) {
    this.applyEdgeDetection(e, n, i);
    const r = new Uint8ClampedArray(e), o = 2;
    for (let a = o; a < i - o; a++)
      for (let l = o; l < n - o; l++) {
        let c = 0, u = 0;
        for (let m = -o; m <= o; m++)
          for (let p = -o; p <= o; p++) {
            const y = ((a + m) * n + (l + p)) * 4;
            c += r[y], u++;
          }
        const d = (a * n + l) * 4, h = Math.floor(c / u);
        e[d] = h, e[d + 1] = h, e[d + 2] = h;
      }
  }
  // ============================================================================
  // Camera Data Export
  // ============================================================================
  async exportCameraData(e) {
    this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 0,
      overallProgress: 60,
      message: "Exporting camera data..."
    });
    const n = {
      type: "one-node",
      position: { x: 0, y: 0, z: 1e3 },
      orientation: { x: 0, y: 0, z: 0 },
      zoom: 1,
      focalLength: 50,
      filmSize: 36,
      depthOfField: {
        enabled: !1,
        focusDistance: 100,
        aperture: 1.2,
        fStop: 2.8,
        blurLevel: 1,
        lockToZoom: !1
      }
    }, i = W2(
      this.config.target,
      n,
      this.cameraKeyframes,
      this.config.endFrame - this.config.startFrame,
      this.config.width,
      this.config.height,
      this.config.fps
    ), r = `${this.config.filenamePrefix}_camera.json`, o = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    this.config.comfyuiServer ? e.outputFiles.cameraData = r : e.outputFiles.cameraData = await this.saveBlobLocally(o, r), this.updateProgress({
      stage: "exporting_camera",
      stageProgress: 100,
      overallProgress: 65,
      message: "Camera data exported"
    });
  }
  // ============================================================================
  // Workflow Generation
  // ============================================================================
  async generateWorkflow(e) {
    this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 0,
      overallProgress: 65,
      message: "Generating workflow..."
    });
    const n = {
      referenceImage: e.outputFiles.referenceImage,
      lastFrameImage: e.outputFiles.lastImage,
      depthSequence: e.outputFiles.depthSequence,
      controlImages: e.outputFiles.controlSequence,
      prompt: this.config.prompt,
      negativePrompt: this.config.negativePrompt,
      width: this.config.width,
      height: this.config.height,
      frameCount: this.config.endFrame - this.config.startFrame,
      fps: this.config.fps,
      seed: this.config.seed,
      steps: this.config.steps,
      cfgScale: this.config.cfgScale,
      outputFilename: this.config.filenamePrefix
    };
    e.outputFiles.cameraData && (n.cameraData = e.outputFiles.cameraData);
    const i = LV(this.config.target, n), r = FV(i);
    r.valid || e.errors.push(...r.errors), e.warnings.push(...r.warnings);
    const o = `${this.config.filenamePrefix}_workflow.json`, a = new Blob([JSON.stringify(i, null, 2)], { type: "application/json" });
    e.outputFiles.workflowJson = await this.saveBlobLocally(a, o), this.updateProgress({
      stage: "generating_workflow",
      stageProgress: 100,
      overallProgress: 70,
      message: "Workflow generated"
    });
  }
  // ============================================================================
  // ComfyUI Queue
  // ============================================================================
  async queueWorkflow(e) {
    if (!this.config.comfyuiServer || !e.outputFiles.workflowJson)
      return;
    this.updateProgress({
      stage: "queuing",
      stageProgress: 0,
      overallProgress: 70,
      message: "Connecting to ComfyUI..."
    });
    const n = vo(this.config.comfyuiServer);
    if (!await n.checkConnection()) {
      e.errors.push("Could not connect to ComfyUI server");
      return;
    }
    const o = await (await fetch(e.outputFiles.workflowJson)).json();
    this.updateProgress({
      stage: "queuing",
      stageProgress: 50,
      overallProgress: 75,
      message: "Queueing workflow..."
    });
    const a = await n.queuePrompt(o);
    if (e.outputFiles.promptId = a.prompt_id, a.node_errors && Object.keys(a.node_errors).length > 0) {
      e.errors.push("Workflow has node errors: " + JSON.stringify(a.node_errors));
      return;
    }
    this.updateProgress({
      stage: "generating",
      stageProgress: 0,
      overallProgress: 80,
      message: "Generating video..."
    });
    try {
      await n.waitForPrompt(a.prompt_id, (l) => {
        this.updateProgress({
          stage: "generating",
          stageProgress: l.percentage,
          overallProgress: 80 + l.percentage * 0.15,
          message: `Generating: ${l.percentage.toFixed(0)}%`,
          preview: l.preview
        });
      }), this.updateProgress({
        stage: "complete",
        stageProgress: 100,
        overallProgress: 100,
        message: "Export complete!"
      });
    } catch (l) {
      e.errors.push(l instanceof Error ? l.message : "Generation failed");
    }
  }
  // ============================================================================
  // Utilities
  // ============================================================================
  async saveBlobLocally(e, n) {
    const i = URL.createObjectURL(e), r = document.createElement("a");
    return r.href = i, r.download = n, document.body.appendChild(r), r.click(), document.body.removeChild(r), i;
  }
}
async function OV(s, e, n, i) {
  return new UV({
    layers: s,
    cameraKeyframes: e,
    config: n,
    onProgress: i
  }).execute();
}
const zV = { class: "export-dialog" }, NV = { class: "dialog-tabs" }, BV = { class: "dialog-content" }, VV = {
  key: 0,
  class: "tab-content"
}, GV = { class: "target-grid" }, HV = { class: "target-buttons" }, WV = ["onClick"], $V = {
  key: 0,
  class: "target-info"
}, XV = { class: "info-row" }, jV = { class: "info-row" }, YV = { class: "info-row" }, qV = {
  key: 1,
  class: "tab-content"
}, ZV = { class: "settings-section" }, KV = { class: "preset-buttons" }, JV = ["onClick"], QV = { class: "input-row" }, e7 = { class: "settings-section" }, t7 = { class: "preset-buttons" }, n7 = ["onClick"], i7 = { class: "input-row" }, s7 = { class: "input-row" }, r7 = { class: "settings-section" }, o7 = { class: "checkbox-grid" }, a7 = {
  key: 0,
  class: "settings-section"
}, l7 = ["value"], c7 = {
  key: 1,
  class: "settings-section"
}, u7 = ["value"], d7 = {
  key: 2,
  class: "tab-content"
}, h7 = { class: "settings-section" }, f7 = { class: "settings-section" }, p7 = { class: "settings-section" }, m7 = { class: "input-row" }, v7 = { class: "input-row seed-row" }, g7 = {
  key: 3,
  class: "tab-content"
}, y7 = { class: "settings-section" }, _7 = { class: "server-row" }, x7 = { key: 0 }, b7 = { key: 1 }, w7 = { key: 2 }, S7 = { key: 3 }, M7 = { class: "settings-section" }, C7 = { class: "checkbox-large" }, E7 = {
  key: 0,
  class: "export-progress"
}, T7 = { class: "progress-header" }, A7 = { class: "progress-bar" }, P7 = {
  key: 0,
  class: "progress-details"
}, D7 = {
  key: 1,
  class: "export-error"
}, R7 = { class: "dialog-footer" }, I7 = ["disabled"], k7 = /* @__PURE__ */ Ut({
  __name: "ComfyUIExportDialog",
  props: {
    layers: {},
    cameraKeyframes: {},
    currentFrame: {},
    totalFrames: {}
  },
  emits: ["close", "exported"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = Se("target"), o = Se("wan22-i2v"), a = Se(832), l = Se(480), c = Se(81), u = Se(24), d = Se(0), h = Se(81), m = Se(!0), p = Se(!1), y = Se(!0), _ = Se(!0), v = Se(!1), g = Se("midas"), S = Se("depth"), w = Se(""), x = Se("blurry, low quality, distorted"), C = Se(void 0), E = Se(30), P = Se(5), T = Se("127.0.0.1:8188"), b = Se(!1), M = Se("disconnected"), L = Se(!1), N = Se(null), D = Se(null), O = Se(null), A = Oe(() => Zv[o.value]), G = Oe(() => ({
      "Wan 2.2": ["wan22-i2v", "wan22-t2v", "wan22-fun-camera", "wan22-first-last", "wan-move"],
      Uni3C: ["uni3c-camera", "uni3c-motion"],
      MotionCtrl: ["motionctrl", "motionctrl-svd"],
      Camera: ["animatediff-cameractrl", "camera-comfyui", "ati"],
      Advanced: ["light-x", "ttm", "cogvideox"],
      ControlNet: ["controlnet-depth", "controlnet-canny", "controlnet-lineart"],
      Custom: ["custom-workflow"]
    })), he = Oe(() => ({
      "wan22-i2v": "Image to Video",
      "wan22-t2v": "Text to Video",
      "wan22-fun-camera": "Fun Camera",
      "wan22-first-last": "First + Last Frame",
      "wan-move": "Point Trajectories",
      "uni3c-camera": "Camera Control",
      "uni3c-motion": "Motion + Camera",
      motionctrl: "MotionCtrl",
      "motionctrl-svd": "MotionCtrl SVD",
      cogvideox: "CogVideoX I2V",
      "animatediff-cameractrl": "CameraCtrl",
      "camera-comfyui": "4x4 Matrices",
      ati: "Any Trajectory",
      "light-x": "Relighting",
      ttm: "Cut & Drag",
      "controlnet-depth": "Depth",
      "controlnet-canny": "Canny Edge",
      "controlnet-lineart": "Line Art",
      "custom-workflow": "Custom Workflow"
    })), ee = [
      { value: "midas", label: "MiDaS (8-bit inverted)" },
      { value: "zoe", label: "Zoe (16-bit linear)" },
      { value: "depth-pro", label: "Depth-Pro (metric)" },
      { value: "normalized", label: "Normalized (0-1)" }
    ], le = [
      { value: "depth", label: "Depth" },
      { value: "canny", label: "Canny Edge" },
      { value: "lineart", label: "Line Art" },
      { value: "softedge", label: "Soft Edge" },
      { value: "normal", label: "Normal Map" }
    ];
    function oe(X) {
      o.value = X;
      const V = fV[X];
      V && (a.value = V.width ?? 832, l.value = V.height ?? 480, c.value = V.frameCount ?? 81, u.value = V.fps ?? 24, h.value = c.value);
      const I = Zv[X];
      I && (m.value = I.requiredInputs.includes("depth_sequence") || I.requiredInputs.includes("depth_map"), y.value = I.requiredInputs.includes("camera_data") || I.requiredInputs.includes("camera_trajectory") || I.requiredInputs.includes("camera_poses"), _.value = I.requiredInputs.includes("reference_image") || I.requiredInputs.includes("first_frame"), v.value = I.requiredInputs.includes("last_frame"), p.value = X.startsWith("controlnet-"));
    }
    async function Y() {
      M.value = "connecting";
      try {
        const V = await vo(T.value).checkConnection();
        M.value = V ? "connected" : "error";
      } catch {
        M.value = "error";
      }
    }
    function j(X) {
      a.value = X.width, l.value = X.height;
    }
    function q(X) {
      c.value = X, h.value = Math.min(h.value, X);
    }
    function te() {
      C.value = Math.floor(Math.random() * 2147483647);
    }
    async function ne() {
      L.value = !0, D.value = null, O.value = new AbortController();
      const X = {
        target: o.value,
        width: a.value,
        height: l.value,
        frameCount: c.value,
        fps: u.value,
        startFrame: d.value,
        endFrame: h.value,
        outputDir: "",
        filenamePrefix: `weyl_${o.value}_${Date.now()}`,
        exportDepthMap: m.value,
        exportControlImages: p.value,
        exportCameraData: y.value,
        exportReferenceFrame: _.value,
        exportLastFrame: v.value,
        depthFormat: g.value,
        controlType: S.value,
        prompt: w.value,
        negativePrompt: x.value,
        seed: C.value,
        steps: E.value,
        cfgScale: P.value,
        comfyuiServer: T.value,
        autoQueueWorkflow: b.value
      };
      try {
        const V = await OV(
          n.layers,
          n.cameraKeyframes,
          X,
          (I) => {
            N.value = I;
          }
        );
        V.success ? i("exported", V) : D.value = V.errors.join(`
`);
      } catch (V) {
        D.value = V instanceof Error ? V.message : "Export failed";
      } finally {
        L.value = !1, O.value = null;
      }
    }
    function de() {
      O.value && O.value.abort();
    }
    function H() {
      L.value && de(), i("close");
    }
    return _n(() => {
      h.value = Math.min(c.value, n.totalFrames), Y();
    }), Ft(o, () => {
      oe(o.value);
    }), (X, V) => {
      var I, F, k;
      return re(), ae("div", {
        class: "export-dialog-overlay",
        onClick: wt(H, ["self"])
      }, [
        f("div", zV, [
          f("header", { class: "dialog-header" }, [
            V[24] || (V[24] = f("h2", null, "Export to ComfyUI", -1)),
            f("button", {
              class: "close-btn",
              onClick: H
            }, "")
          ]),
          f("nav", NV, [
            f("button", {
              class: Ue({ active: r.value === "target" }),
              onClick: V[0] || (V[0] = (Q) => r.value = "target")
            }, " Target ", 2),
            f("button", {
              class: Ue({ active: r.value === "output" }),
              onClick: V[1] || (V[1] = (Q) => r.value = "output")
            }, " Output ", 2),
            f("button", {
              class: Ue({ active: r.value === "generation" }),
              onClick: V[2] || (V[2] = (Q) => r.value = "generation")
            }, " Generation ", 2),
            f("button", {
              class: Ue({ active: r.value === "comfyui" }),
              onClick: V[3] || (V[3] = (Q) => r.value = "comfyui")
            }, " ComfyUI ", 2)
          ]),
          f("div", BV, [
            r.value === "target" ? (re(), ae("div", VV, [
              f("div", GV, [
                (re(!0), ae(Ze, null, at(G.value, (Q, Z) => (re(), ae("div", {
                  key: Z,
                  class: "target-category"
                }, [
                  f("h3", null, be(Z), 1),
                  f("div", HV, [
                    (re(!0), ae(Ze, null, at(Q, (R) => (re(), ae("button", {
                      key: R,
                      class: Ue({ selected: o.value === R }),
                      onClick: (ie) => oe(R)
                    }, be(he.value[R]), 11, WV))), 128))
                  ])
                ]))), 128))
              ]),
              A.value ? (re(), ae("div", $V, [
                f("h4", null, be(he.value[o.value]), 1),
                f("div", XV, [
                  V[25] || (V[25] = f("span", { class: "label" }, "Required:", -1)),
                  f("span", null, be(A.value.requiredInputs.join(", ") || "None"), 1)
                ]),
                f("div", jV, [
                  V[26] || (V[26] = f("span", { class: "label" }, "Optional:", -1)),
                  f("span", null, be(A.value.optionalInputs.join(", ") || "None"), 1)
                ]),
                f("div", YV, [
                  V[27] || (V[27] = f("span", { class: "label" }, "Outputs:", -1)),
                  f("span", null, be(A.value.outputTypes.join(", ")), 1)
                ])
              ])) : Pe("", !0)
            ])) : Pe("", !0),
            r.value === "output" ? (re(), ae("div", qV, [
              f("div", ZV, [
                V[28] || (V[28] = f("h3", null, "Resolution", -1)),
                f("div", KV, [
                  (re(!0), ae(Ze, null, at(Ge(mV), (Q) => (re(), ae("button", {
                    key: Q.name,
                    onClick: (Z) => j(Q)
                  }, be(Q.name), 9, JV))), 128))
                ]),
                f("div", QV, [
                  Ne(et, {
                    modelValue: a.value,
                    "onUpdate:modelValue": V[4] || (V[4] = (Q) => a.value = Q),
                    label: "Width",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"]),
                  Ne(et, {
                    modelValue: l.value,
                    "onUpdate:modelValue": V[5] || (V[5] = (Q) => l.value = Q),
                    label: "Height",
                    min: 64,
                    max: 4096,
                    step: 8
                  }, null, 8, ["modelValue"])
                ])
              ]),
              f("div", e7, [
                V[29] || (V[29] = f("h3", null, "Frames", -1)),
                f("div", t7, [
                  (re(!0), ae(Ze, null, at(Ge(vV), (Q) => (re(), ae("button", {
                    key: Q.name,
                    onClick: (Z) => q(Q.frameCount)
                  }, be(Q.name), 9, n7))), 128))
                ]),
                f("div", i7, [
                  Ne(et, {
                    modelValue: c.value,
                    "onUpdate:modelValue": V[6] || (V[6] = (Q) => c.value = Q),
                    label: "Total Frames",
                    min: 1,
                    max: 1e3
                  }, null, 8, ["modelValue"]),
                  Ne(et, {
                    modelValue: u.value,
                    "onUpdate:modelValue": V[7] || (V[7] = (Q) => u.value = Q),
                    label: "FPS",
                    min: 1,
                    max: 120
                  }, null, 8, ["modelValue"])
                ]),
                f("div", s7, [
                  Ne(et, {
                    modelValue: d.value,
                    "onUpdate:modelValue": V[8] || (V[8] = (Q) => d.value = Q),
                    label: "Start",
                    min: 0,
                    max: h.value - 1
                  }, null, 8, ["modelValue", "max"]),
                  Ne(et, {
                    modelValue: h.value,
                    "onUpdate:modelValue": V[9] || (V[9] = (Q) => h.value = Q),
                    label: "End",
                    min: d.value + 1,
                    max: c.value
                  }, null, 8, ["modelValue", "min", "max"])
                ])
              ]),
              f("div", r7, [
                V[35] || (V[35] = f("h3", null, "Export Options", -1)),
                f("div", o7, [
                  f("label", null, [
                    ct(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": V[10] || (V[10] = (Q) => _.value = Q)
                    }, null, 512), [
                      [Ci, _.value]
                    ]),
                    V[30] || (V[30] = ft(" Reference Frame ", -1))
                  ]),
                  f("label", null, [
                    ct(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": V[11] || (V[11] = (Q) => v.value = Q)
                    }, null, 512), [
                      [Ci, v.value]
                    ]),
                    V[31] || (V[31] = ft(" Last Frame ", -1))
                  ]),
                  f("label", null, [
                    ct(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": V[12] || (V[12] = (Q) => m.value = Q)
                    }, null, 512), [
                      [Ci, m.value]
                    ]),
                    V[32] || (V[32] = ft(" Depth Maps ", -1))
                  ]),
                  f("label", null, [
                    ct(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": V[13] || (V[13] = (Q) => p.value = Q)
                    }, null, 512), [
                      [Ci, p.value]
                    ]),
                    V[33] || (V[33] = ft(" Control Images ", -1))
                  ]),
                  f("label", null, [
                    ct(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": V[14] || (V[14] = (Q) => y.value = Q)
                    }, null, 512), [
                      [Ci, y.value]
                    ]),
                    V[34] || (V[34] = ft(" Camera Data ", -1))
                  ])
                ])
              ]),
              m.value ? (re(), ae("div", a7, [
                V[36] || (V[36] = f("h3", null, "Depth Format", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": V[15] || (V[15] = (Q) => g.value = Q)
                }, [
                  (re(), ae(Ze, null, at(ee, (Q) => f("option", {
                    key: Q.value,
                    value: Q.value
                  }, be(Q.label), 9, l7)), 64))
                ], 512), [
                  [ti, g.value]
                ])
              ])) : Pe("", !0),
              p.value ? (re(), ae("div", c7, [
                V[37] || (V[37] = f("h3", null, "Control Type", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": V[16] || (V[16] = (Q) => S.value = Q)
                }, [
                  (re(), ae(Ze, null, at(le, (Q) => f("option", {
                    key: Q.value,
                    value: Q.value
                  }, be(Q.label), 9, u7)), 64))
                ], 512), [
                  [ti, S.value]
                ])
              ])) : Pe("", !0)
            ])) : Pe("", !0),
            r.value === "generation" ? (re(), ae("div", d7, [
              f("div", h7, [
                V[38] || (V[38] = f("h3", null, "Prompt", -1)),
                ct(f("textarea", {
                  "onUpdate:modelValue": V[17] || (V[17] = (Q) => w.value = Q),
                  placeholder: "Describe the video you want to generate...",
                  rows: "4"
                }, null, 512), [
                  [$t, w.value]
                ])
              ]),
              f("div", f7, [
                V[39] || (V[39] = f("h3", null, "Negative Prompt", -1)),
                ct(f("textarea", {
                  "onUpdate:modelValue": V[18] || (V[18] = (Q) => x.value = Q),
                  placeholder: "What to avoid...",
                  rows: "2"
                }, null, 512), [
                  [$t, x.value]
                ])
              ]),
              f("div", p7, [
                V[40] || (V[40] = f("h3", null, "Parameters", -1)),
                f("div", m7, [
                  Ne(et, {
                    modelValue: E.value,
                    "onUpdate:modelValue": V[19] || (V[19] = (Q) => E.value = Q),
                    label: "Steps",
                    min: 1,
                    max: 100
                  }, null, 8, ["modelValue"]),
                  Ne(et, {
                    modelValue: P.value,
                    "onUpdate:modelValue": V[20] || (V[20] = (Q) => P.value = Q),
                    label: "CFG Scale",
                    min: 1,
                    max: 20,
                    step: 0.5
                  }, null, 8, ["modelValue"])
                ]),
                f("div", v7, [
                  Ne(et, {
                    modelValue: C.value ?? 0,
                    "onUpdate:modelValue": V[21] || (V[21] = (Q) => C.value = Q),
                    label: "Seed",
                    min: 0,
                    max: 2147483647
                  }, null, 8, ["modelValue"]),
                  f("button", {
                    class: "randomize-btn",
                    onClick: te
                  }, "Random")
                ])
              ])
            ])) : Pe("", !0),
            r.value === "comfyui" ? (re(), ae("div", g7, [
              f("div", y7, [
                V[41] || (V[41] = f("h3", null, "Server", -1)),
                f("div", _7, [
                  ct(f("input", {
                    type: "text",
                    "onUpdate:modelValue": V[22] || (V[22] = (Q) => T.value = Q),
                    placeholder: "127.0.0.1:8188"
                  }, null, 512), [
                    [$t, T.value]
                  ]),
                  f("button", { onClick: Y }, be(M.value === "connecting" ? "Connecting..." : "Test"), 1)
                ]),
                f("div", {
                  class: Ue(["connection-status", M.value])
                }, [
                  M.value === "connected" ? (re(), ae("span", x7, "Connected")) : M.value === "error" ? (re(), ae("span", b7, "Connection failed")) : M.value === "connecting" ? (re(), ae("span", w7, "Connecting...")) : (re(), ae("span", S7, "Not connected"))
                ], 2)
              ]),
              f("div", M7, [
                V[43] || (V[43] = f("h3", null, "Workflow", -1)),
                f("label", C7, [
                  ct(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": V[23] || (V[23] = (Q) => b.value = Q)
                  }, null, 512), [
                    [Ci, b.value]
                  ]),
                  V[42] || (V[42] = f("span", null, [
                    f("strong", null, "Auto-queue workflow"),
                    f("small", null, "Automatically send workflow to ComfyUI after export")
                  ], -1))
                ])
              ])
            ])) : Pe("", !0)
          ]),
          L.value ? (re(), ae("div", E7, [
            f("div", T7, [
              f("span", null, be(((I = N.value) == null ? void 0 : I.message) || "Exporting..."), 1),
              f("button", { onClick: de }, "Cancel")
            ]),
            f("div", A7, [
              f("div", {
                class: "progress-fill",
                style: bt({ width: `${((F = N.value) == null ? void 0 : F.overallProgress) || 0}%` })
              }, null, 4)
            ]),
            (k = N.value) != null && k.currentFrame ? (re(), ae("div", P7, " Frame " + be(N.value.currentFrame) + " / " + be(N.value.totalFrames), 1)) : Pe("", !0)
          ])) : Pe("", !0),
          D.value ? (re(), ae("div", D7, be(D.value), 1)) : Pe("", !0),
          f("footer", R7, [
            f("button", {
              class: "secondary",
              onClick: H
            }, "Cancel"),
            f("button", {
              class: "primary",
              disabled: L.value,
              onClick: ne
            }, be(L.value ? "Exporting..." : "Export"), 9, I7)
          ])
        ])
      ]);
    };
  }
}), L7 = /* @__PURE__ */ Bt(k7, [["__scopeId", "data-v-784836ff"]]), F7 = { class: "dialog-container" }, U7 = { class: "dialog-content" }, O7 = { class: "form-row" }, z7 = { class: "tabs" }, N7 = {
  key: 0,
  class: "tab-content"
}, B7 = { class: "form-row" }, V7 = { class: "form-row dimensions-row" }, G7 = { class: "dimension-group" }, H7 = { class: "dimension-group" }, W7 = { class: "form-row" }, $7 = { class: "aspect-info" }, X7 = { class: "form-row" }, j7 = { class: "form-row" }, Y7 = { class: "resolution-info" }, q7 = { class: "form-row" }, Z7 = { class: "duration-inputs" }, K7 = { class: "duration-helper" }, J7 = { class: "form-row" }, Q7 = { class: "color-picker-row" }, e9 = { class: "color-label" }, t9 = {
  key: 1,
  class: "tab-content"
}, n9 = { class: "form-row" }, i9 = { class: "form-row" }, s9 = { class: "form-row" }, r9 = { class: "motion-blur-settings" }, o9 = {
  key: 0,
  class: "motion-blur-params"
}, a9 = { class: "param-row" }, l9 = { class: "param-row" }, c9 = { class: "dialog-footer" }, u9 = { class: "preview-toggle" }, d9 = /* @__PURE__ */ Ut({
  __name: "CompositionSettingsDialog",
  props: {
    visible: { type: Boolean }
  },
  emits: ["close", "confirm"],
  setup(s, { emit: e }) {
    const n = s, i = e, r = nn(), o = Se("basic"), a = Se("custom"), l = Se(!1), c = Se(16 / 9), u = Se(!1), d = Se({
      name: "Main Comp",
      width: 1920,
      height: 1080,
      pixelAspectRatio: 1,
      fps: 30,
      frameCount: 300,
      resolution: "full",
      backgroundColor: "#000000",
      autoResizeToContent: !0,
      startTimecode: "00:00:00:00",
      motionBlurEnabled: !1,
      shutterAngle: 180,
      shutterPhase: -90
    }), h = Oe(() => {
      const b = d.value.width / d.value.height * d.value.pixelAspectRatio;
      return Math.abs(b - 16 / 9) < 0.01 ? "16:9 (1.78)" : Math.abs(b - 4 / 3) < 0.01 ? "4:3 (1.33)" : Math.abs(b - 1) < 0.01 ? "1:1 (1.0)" : Math.abs(b - 9 / 16) < 0.01 ? "9:16 (0.56)" : Math.abs(b - 21 / 9) < 0.01 ? "21:9 (2.33)" : `${b.toFixed(2)}`;
    }), m = Oe(() => d.value.frameCount / d.value.fps), p = Se("00:00:10:00"), y = Oe(() => {
      const M = { full: 1, half: 2, third: 3, quarter: 4 }[d.value.resolution], L = Math.floor(d.value.width / M), N = Math.floor(d.value.height / M), D = (L * N * 4 / (1024 * 1024)).toFixed(1);
      return `${L} x ${N}, ${D} MB per 8bpc frame`;
    }), _ = {
      "1080p30": { width: 1920, height: 1080, fps: 30 },
      "1080p60": { width: 1920, height: 1080, fps: 60 },
      "720p30": { width: 1280, height: 720, fps: 30 },
      "4k30": { width: 3840, height: 2160, fps: 30 },
      instagram_square: { width: 1080, height: 1080, fps: 30 },
      instagram_story: { width: 1080, height: 1920, fps: 30 },
      tiktok: { width: 1080, height: 1920, fps: 30 },
      youtube_short: { width: 1080, height: 1920, fps: 60 },
      sd15_512: { width: 512, height: 512, fps: 8 },
      sd15_768: { width: 768, height: 512, fps: 8 },
      sdxl_1024: { width: 1024, height: 1024, fps: 8 },
      wan_480p: { width: 832, height: 480, fps: 16 },
      wan_720p: { width: 1280, height: 720, fps: 16 }
    };
    function v() {
      const b = _[a.value];
      b && (b.width && (d.value.width = b.width), b.height && (d.value.height = b.height), b.fps && (d.value.fps = b.fps), c.value = d.value.width / d.value.height, w());
    }
    function g(b) {
      d.value.width = Math.round(d.value.width / 8) * 8, d.value.height = Math.round(d.value.height / 8) * 8, l.value ? b === "width" ? d.value.height = Math.round(d.value.width / c.value / 8) * 8 : d.value.width = Math.round(d.value.height * c.value / 8) * 8 : c.value = d.value.width / d.value.height, a.value = "custom";
    }
    function S() {
      const b = p.value.split(":").map((M) => parseInt(M) || 0);
      if (b.length === 4) {
        const [M, L, N, D] = b, O = M * 3600 + L * 60 + N;
        d.value.frameCount = Math.round(O * d.value.fps) + D;
      } else b.length === 1 && (d.value.frameCount = b[0]);
    }
    function w() {
      const b = d.value.frameCount, M = d.value.fps, L = Math.floor(b / M), N = b % Math.round(M), D = Math.floor(L / 3600), O = Math.floor(L % 3600 / 60), A = L % 60;
      p.value = `${x(D)}:${x(O)}:${x(A)}:${x(N)}`;
    }
    function x(b) {
      return b.toString().padStart(2, "0");
    }
    function C() {
      var b, M, L, N, D, O;
      d.value = {
        name: ((M = (b = r.project) == null ? void 0 : b.meta) == null ? void 0 : M.name) || "Main Comp",
        width: r.width,
        height: r.height,
        pixelAspectRatio: 1,
        fps: r.fps,
        frameCount: r.frameCount,
        resolution: "full",
        backgroundColor: ((N = (L = r.project) == null ? void 0 : L.composition) == null ? void 0 : N.backgroundColor) || "#000000",
        autoResizeToContent: ((O = (D = r.project) == null ? void 0 : D.composition) == null ? void 0 : O.autoResizeToContent) ?? !0,
        startTimecode: "00:00:00:00",
        motionBlurEnabled: !1,
        shutterAngle: 180,
        shutterPhase: -90
      }, c.value = d.value.width / d.value.height, w();
    }
    function E() {
      i("close");
    }
    function P() {
      i("confirm", { ...d.value }), i("close");
    }
    function T(b) {
      b.key === "Escape" ? E() : b.key === "Enter" && !b.shiftKey && P();
    }
    return Ft(() => n.visible, (b) => {
      b && C();
    }), Ft(d, () => {
      u.value && n.visible && r.resizeComposition(d.value.width, d.value.height, d.value.frameCount);
    }, { deep: !0 }), _n(() => {
      window.addEventListener("keydown", T);
    }), jn(() => {
      window.removeEventListener("keydown", T);
    }), (b, M) => (re(), St(Po, { to: "body" }, [
      s.visible ? (re(), ae("div", {
        key: 0,
        class: "dialog-overlay",
        onClick: wt(E, ["self"])
      }, [
        f("div", F7, [
          f("div", { class: "dialog-header" }, [
            M[20] || (M[20] = f("span", { class: "dialog-title" }, "Composition Settings", -1)),
            f("button", {
              class: "close-btn",
              onClick: E
            }, "")
          ]),
          f("div", U7, [
            f("div", O7, [
              M[21] || (M[21] = f("label", null, "Composition Name:", -1)),
              ct(f("input", {
                type: "text",
                "onUpdate:modelValue": M[0] || (M[0] = (L) => d.value.name = L),
                class: "text-input full-width"
              }, null, 512), [
                [$t, d.value.name]
              ])
            ]),
            f("div", z7, [
              f("button", {
                class: Ue({ active: o.value === "basic" }),
                onClick: M[1] || (M[1] = (L) => o.value = "basic")
              }, "Basic", 2),
              f("button", {
                class: Ue({ active: o.value === "advanced" }),
                onClick: M[2] || (M[2] = (L) => o.value = "advanced")
              }, "Advanced", 2)
            ]),
            o.value === "basic" ? (re(), ae("div", N7, [
              f("div", B7, [
                M[23] || (M[23] = f("label", null, "Preset:", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": M[3] || (M[3] = (L) => a.value = L),
                  onChange: v,
                  class: "select-input"
                }, [...M[22] || (M[22] = [
                  f("option", { value: "custom" }, "Custom", -1),
                  f("optgroup", { label: "Video" }, [
                    f("option", { value: "1080p30" }, "HD 1080p 30fps (1920x1080)"),
                    f("option", { value: "1080p60" }, "HD 1080p 60fps (1920x1080)"),
                    f("option", { value: "720p30" }, "HD 720p 30fps (1280x720)"),
                    f("option", { value: "4k30" }, "4K UHD 30fps (3840x2160)")
                  ], -1),
                  f("optgroup", { label: "Social Media" }, [
                    f("option", { value: "instagram_square" }, "Instagram Square (1080x1080)"),
                    f("option", { value: "instagram_story" }, "Instagram Story (1080x1920)"),
                    f("option", { value: "tiktok" }, "TikTok/Reels (1080x1920)"),
                    f("option", { value: "youtube_short" }, "YouTube Short (1080x1920)")
                  ], -1),
                  f("optgroup", { label: "AI Video (ComfyUI)" }, [
                    f("option", { value: "sd15_512" }, "SD 1.5 (512x512)"),
                    f("option", { value: "sd15_768" }, "SD 1.5 (768x512)"),
                    f("option", { value: "sdxl_1024" }, "SDXL (1024x1024)"),
                    f("option", { value: "wan_480p" }, "Wan 2.1 480p (832x480)"),
                    f("option", { value: "wan_720p" }, "Wan 2.1 720p (1280x720)")
                  ], -1)
                ])], 544), [
                  [ti, a.value]
                ])
              ]),
              f("div", V7, [
                f("div", G7, [
                  M[24] || (M[24] = f("label", null, "Width:", -1)),
                  ct(f("input", {
                    type: "number",
                    "onUpdate:modelValue": M[4] || (M[4] = (L) => d.value.width = L),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: M[5] || (M[5] = (L) => g("width"))
                  }, null, 544), [
                    [
                      $t,
                      d.value.width,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  M[25] || (M[25] = f("span", { class: "unit" }, "px", -1))
                ]),
                f("button", {
                  class: Ue(["lock-btn", { locked: l.value }]),
                  onClick: M[6] || (M[6] = (L) => l.value = !l.value),
                  title: "Lock Aspect Ratio"
                }, be(l.value ? "" : ""), 3),
                f("div", H7, [
                  M[26] || (M[26] = f("label", null, "Height:", -1)),
                  ct(f("input", {
                    type: "number",
                    "onUpdate:modelValue": M[7] || (M[7] = (L) => d.value.height = L),
                    step: 8,
                    min: "64",
                    max: "8192",
                    class: "number-input",
                    onChange: M[8] || (M[8] = (L) => g("height"))
                  }, null, 544), [
                    [
                      $t,
                      d.value.height,
                      void 0,
                      { number: !0 }
                    ]
                  ]),
                  M[27] || (M[27] = f("span", { class: "unit" }, "px", -1))
                ])
              ]),
              f("div", W7, [
                M[29] || (M[29] = f("label", null, "Pixel Aspect Ratio:", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": M[9] || (M[9] = (L) => d.value.pixelAspectRatio = L),
                  class: "select-input"
                }, [...M[28] || (M[28] = [
                  f("option", { value: "1" }, "Square Pixels (1.0)", -1),
                  f("option", { value: "1.067" }, "D1/DV NTSC (0.9)", -1),
                  f("option", { value: "1.422" }, "D1/DV PAL (1.067)", -1),
                  f("option", { value: "1.333" }, "Anamorphic 2:1 (2.0)", -1)
                ])], 512), [
                  [ti, d.value.pixelAspectRatio]
                ]),
                f("span", $7, "Frame Aspect Ratio: " + be(h.value), 1)
              ]),
              f("div", X7, [
                M[31] || (M[31] = f("label", null, "Frame Rate:", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": M[10] || (M[10] = (L) => d.value.fps = L),
                  class: "select-input short"
                }, [...M[30] || (M[30] = [
                  f("option", { value: 8 }, "8", -1),
                  f("option", { value: 12 }, "12", -1),
                  f("option", { value: 15 }, "15", -1),
                  f("option", { value: 16 }, "16", -1),
                  f("option", { value: 23.976 }, "23.976", -1),
                  f("option", { value: 24 }, "24", -1),
                  f("option", { value: 25 }, "25", -1),
                  f("option", { value: 29.97 }, "29.97", -1),
                  f("option", { value: 30 }, "30", -1),
                  f("option", { value: 50 }, "50", -1),
                  f("option", { value: 59.94 }, "59.94", -1),
                  f("option", { value: 60 }, "60", -1)
                ])], 512), [
                  [
                    ti,
                    d.value.fps,
                    void 0,
                    { number: !0 }
                  ]
                ]),
                M[32] || (M[32] = f("span", { class: "unit" }, "frames per second", -1))
              ]),
              f("div", j7, [
                M[34] || (M[34] = f("label", null, "Resolution:", -1)),
                ct(f("select", {
                  "onUpdate:modelValue": M[11] || (M[11] = (L) => d.value.resolution = L),
                  class: "select-input short"
                }, [...M[33] || (M[33] = [
                  f("option", { value: "full" }, "Full", -1),
                  f("option", { value: "half" }, "Half", -1),
                  f("option", { value: "third" }, "Third", -1),
                  f("option", { value: "quarter" }, "Quarter", -1)
                ])], 512), [
                  [ti, d.value.resolution]
                ]),
                f("span", Y7, be(y.value), 1)
              ]),
              f("div", q7, [
                M[35] || (M[35] = f("label", null, "Duration:", -1)),
                f("div", Z7, [
                  ct(f("input", {
                    type: "text",
                    "onUpdate:modelValue": M[12] || (M[12] = (L) => p.value = L),
                    class: "timecode-input",
                    placeholder: "00:00:00:00",
                    onBlur: S
                  }, null, 544), [
                    [$t, p.value]
                  ]),
                  f("span", K7, be(d.value.frameCount) + " frames = " + be(m.value.toFixed(2)) + "s ", 1)
                ])
              ]),
              f("div", J7, [
                M[36] || (M[36] = f("label", null, "Background Color:", -1)),
                f("div", Q7, [
                  ct(f("input", {
                    type: "color",
                    "onUpdate:modelValue": M[13] || (M[13] = (L) => d.value.backgroundColor = L),
                    class: "color-input"
                  }, null, 512), [
                    [$t, d.value.backgroundColor]
                  ]),
                  f("span", e9, be(d.value.backgroundColor), 1)
                ])
              ])
            ])) : Pe("", !0),
            o.value === "advanced" ? (re(), ae("div", t9, [
              f("div", n9, [
                f("label", null, [
                  ct(f("input", {
                    type: "checkbox",
                    "onUpdate:modelValue": M[14] || (M[14] = (L) => d.value.autoResizeToContent = L)
                  }, null, 512), [
                    [Ci, d.value.autoResizeToContent]
                  ]),
                  M[37] || (M[37] = ft(" Auto-resize composition when importing video ", -1))
                ])
              ]),
              f("div", i9, [
                M[38] || (M[38] = f("label", null, "Start Timecode:", -1)),
                ct(f("input", {
                  type: "text",
                  "onUpdate:modelValue": M[15] || (M[15] = (L) => d.value.startTimecode = L),
                  class: "timecode-input",
                  placeholder: "00:00:00:00"
                }, null, 512), [
                  [$t, d.value.startTimecode]
                ])
              ]),
              f("div", s9, [
                M[44] || (M[44] = f("label", null, "Motion Blur:", -1)),
                f("div", r9, [
                  f("label", null, [
                    ct(f("input", {
                      type: "checkbox",
                      "onUpdate:modelValue": M[16] || (M[16] = (L) => d.value.motionBlurEnabled = L)
                    }, null, 512), [
                      [Ci, d.value.motionBlurEnabled]
                    ]),
                    M[39] || (M[39] = ft(" Enable Motion Blur ", -1))
                  ]),
                  d.value.motionBlurEnabled ? (re(), ae("div", o9, [
                    f("div", a9, [
                      M[40] || (M[40] = f("label", null, "Shutter Angle:", -1)),
                      ct(f("input", {
                        type: "number",
                        "onUpdate:modelValue": M[17] || (M[17] = (L) => d.value.shutterAngle = L),
                        min: "0",
                        max: "720",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          $t,
                          d.value.shutterAngle,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      M[41] || (M[41] = f("span", { class: "unit" }, "", -1))
                    ]),
                    f("div", l9, [
                      M[42] || (M[42] = f("label", null, "Shutter Phase:", -1)),
                      ct(f("input", {
                        type: "number",
                        "onUpdate:modelValue": M[18] || (M[18] = (L) => d.value.shutterPhase = L),
                        min: "-360",
                        max: "360",
                        class: "number-input short"
                      }, null, 512), [
                        [
                          $t,
                          d.value.shutterPhase,
                          void 0,
                          { number: !0 }
                        ]
                      ]),
                      M[43] || (M[43] = f("span", { class: "unit" }, "", -1))
                    ])
                  ])) : Pe("", !0)
                ])
              ])
            ])) : Pe("", !0)
          ]),
          f("div", c9, [
            f("div", u9, [
              f("label", null, [
                ct(f("input", {
                  type: "checkbox",
                  "onUpdate:modelValue": M[19] || (M[19] = (L) => u.value = L)
                }, null, 512), [
                  [Ci, u.value]
                ]),
                M[45] || (M[45] = ft(" Preview ", -1))
              ])
            ]),
            f("div", { class: "dialog-actions" }, [
              f("button", {
                class: "btn btn-secondary",
                onClick: E
              }, "Cancel"),
              f("button", {
                class: "btn btn-primary",
                onClick: P
              }, "OK")
            ])
          ])
        ])
      ])) : Pe("", !0)
    ]));
  }
}), h9 = /* @__PURE__ */ Bt(d9, [["__scopeId", "data-v-76356b13"]]), f9 = { class: "workspace-layout" }, p9 = { class: "toolbar" }, m9 = { class: "tool-group" }, v9 = { class: "tool-group" }, g9 = ["title"], y9 = { class: "icon" }, _9 = { class: "timecode-display" }, x9 = { class: "tool-group" }, b9 = { class: "tool-group" }, w9 = ["disabled"], S9 = ["disabled"], M9 = { class: "workspace-content" }, C9 = { class: "panel left-panel" }, E9 = { class: "panel-tabs" }, T9 = { class: "panel-content" }, A9 = { class: "panel viewport-panel" }, P9 = { class: "viewport-header" }, D9 = { class: "viewport-tabs" }, R9 = { class: "viewport-controls" }, I9 = { class: "viewport-content" }, k9 = { class: "panel timeline-panel" }, L9 = { class: "panel graph-editor-panel" }, F9 = {
  key: 1,
  class: "panel timeline-panel"
}, U9 = { class: "panel right-panel" }, O9 = { class: "panel-tabs" }, z9 = { class: "panel-content" }, N9 = { class: "status-bar" }, B9 = { class: "status-left" }, V9 = { class: "status-item" }, G9 = { class: "status-item" }, H9 = { class: "status-center" }, W9 = {
  key: 0,
  class: "render-progress"
}, $9 = { class: "status-right" }, X9 = { class: "status-item" }, j9 = { class: "status-item" }, Y9 = /* @__PURE__ */ Ut({
  __name: "WorkspaceLayout",
  setup(s) {
    const e = nn(), n = Oe({
      get: () => e.currentTool,
      set: (I) => e.setTool(I)
    }), i = Se("standard"), r = Se("project"), o = Se("properties"), a = Se("composition"), l = Se("fit"), c = Se(!1), u = Se(!0), d = Se(!1), h = Se(!1), m = Se(!1), p = Se(!1), y = Se(!1), _ = Se("cpu"), v = Se(null), g = Oe(() => {
      const I = e.getActiveCameraAtFrame();
      return I || uy("default", x.value, C.value);
    }), S = Se(dy()), w = Se({
      showGrid: !0,
      showAxes: !0,
      showCameraFrustum: !0,
      showCompositionBounds: !0,
      showFocalPlane: !1,
      showLayerOutlines: !0,
      gridSize: 100,
      gridDivisions: 10
    }), x = Oe(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.composition) == null ? void 0 : F.width) || 1920;
    }), C = Oe(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.composition) == null ? void 0 : F.height) || 1080;
    }), E = Se(60), P = Se("0 MB"), T = Se(0), b = Oe(() => {
      var ie, J;
      const I = e.currentFrame, F = ((J = (ie = e.project) == null ? void 0 : ie.composition) == null ? void 0 : J.fps) || 30, k = I / F, Q = Math.floor(k / 60), Z = Math.floor(k % 60), R = I % F;
      return `${String(Q).padStart(2, "0")}:${String(Z).padStart(2, "0")}:${String(R).padStart(2, "0")}`;
    }), M = Oe(() => {
      var I, F;
      return ((F = (I = e.project) == null ? void 0 : I.meta) == null ? void 0 : F.name) || "Untitled Project";
    }), L = Oe(() => {
      var F;
      const I = (F = e.project) == null ? void 0 : F.composition;
      return I ? `${I.width}${I.height} @ ${I.fps}fps` : "No Composition";
    }), N = Oe(() => e.canUndo), D = Oe(() => e.canRedo);
    function O() {
      y.value = !y.value, y.value ? e.play() : e.pause();
    }
    function A() {
      e.goToStart();
    }
    function G() {
      e.goToEnd();
    }
    function he() {
      e.setFrame(e.currentFrame + 1);
    }
    function ee() {
      e.setFrame(Math.max(0, e.currentFrame - 1));
    }
    function le() {
      e.undo();
    }
    function oe() {
      e.redo();
    }
    function Y(I) {
      e.activeCameraId && e.updateCamera(I.id, I);
    }
    function j() {
      console.log("[Weyl] Matte export completed");
    }
    function q(I) {
      console.log("[Weyl] ComfyUI export completed", I), m.value = !1;
    }
    function te(I) {
      console.log("[Weyl] Composition settings updated:", I), e.updateCompositionSettings(e.activeCompositionId, {
        width: I.width,
        height: I.height,
        fps: I.fps,
        frameCount: I.frameCount,
        backgroundColor: I.backgroundColor,
        autoResizeToContent: I.autoResizeToContent
      }), e.renameComposition(e.activeCompositionId, I.name), p.value = !1;
    }
    const ne = Oe(() => {
      const I = e.getActiveCameraAtFrame();
      return I ? e.getCameraKeyframes(I.id) : [];
    });
    function de() {
      console.log("[WorkspaceLayout] Zoom changed to:", l.value);
    }
    function H(I) {
      var F, k;
      if (!(((F = document.activeElement) == null ? void 0 : F.tagName) === "INPUT" || ((k = document.activeElement) == null ? void 0 : k.tagName) === "TEXTAREA"))
        switch (I.key.toLowerCase()) {
          case " ":
            I.preventDefault(), O();
            break;
          case "v":
            n.value = "select";
            break;
          case "p":
            n.value = "pen";
            break;
          case "t":
            n.value = "text";
            break;
          case "h":
            n.value = "hand";
            break;
          case "z":
            I.ctrlKey || I.metaKey ? (I.preventDefault(), I.shiftKey ? oe() : le()) : n.value = "zoom";
            break;
          case "home":
            I.preventDefault(), A();
            break;
          case "end":
            I.preventDefault(), G();
            break;
          case "arrowleft":
            I.preventDefault(), ee();
            break;
          case "arrowright":
            I.preventDefault(), he();
            break;
          case "g":
            I.shiftKey && (d.value = !d.value);
            break;
          case "k":
            (I.ctrlKey || I.metaKey) && (I.preventDefault(), p.value = !0);
            break;
        }
    }
    let X;
    function V() {
      if ("memory" in performance) {
        const I = performance.memory, F = Math.round(I.usedJSHeapSize / 1024 / 1024);
        P.value = `${F} MB`;
      }
    }
    return _n(async () => {
      const I = await pT();
      _.value = I.tier, window.addEventListener("keydown", H), X = window.setInterval(V, 1e3);
    }), jn(() => {
      window.removeEventListener("keydown", H), clearInterval(X);
    }), (I, F) => (re(), ae("div", f9, [
      f("div", p9, [
        f("div", m9, [
          f("button", {
            class: Ue({ active: n.value === "select" }),
            onClick: F[0] || (F[0] = (k) => n.value = "select"),
            title: "Select (V)"
          }, [...F[27] || (F[27] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Ue({ active: n.value === "pen" }),
            onClick: F[1] || (F[1] = (k) => n.value = "pen"),
            title: "Pen Tool (P)"
          }, [...F[28] || (F[28] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Ue({ active: n.value === "text" }),
            onClick: F[2] || (F[2] = (k) => n.value = "text"),
            title: "Text Tool (T)"
          }, [...F[29] || (F[29] = [
            f("span", { class: "icon" }, "T", -1)
          ])], 2),
          f("button", {
            class: Ue({ active: n.value === "hand" }),
            onClick: F[3] || (F[3] = (k) => n.value = "hand"),
            title: "Hand Tool (H)"
          }, [...F[30] || (F[30] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2),
          f("button", {
            class: Ue({ active: n.value === "zoom" }),
            onClick: F[4] || (F[4] = (k) => n.value = "zoom"),
            title: "Zoom Tool (Z)"
          }, [...F[31] || (F[31] = [
            f("span", { class: "icon" }, "", -1)
          ])], 2)
        ]),
        F[41] || (F[41] = f("div", { class: "divider" }, null, -1)),
        f("div", v9, [
          f("button", {
            onClick: A,
            title: "Go to Start (Home)"
          }, [...F[32] || (F[32] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: ee,
            title: "Step Backward"
          }, [...F[33] || (F[33] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: O,
            title: y.value ? "Pause (Space)" : "Play (Space)"
          }, [
            f("span", y9, be(y.value ? "" : ""), 1)
          ], 8, g9),
          f("button", {
            onClick: he,
            title: "Step Forward"
          }, [...F[34] || (F[34] = [
            f("span", { class: "icon" }, "", -1)
          ])]),
          f("button", {
            onClick: G,
            title: "Go to End (End)"
          }, [...F[35] || (F[35] = [
            f("span", { class: "icon" }, "", -1)
          ])])
        ]),
        f("div", _9, be(b.value), 1),
        F[42] || (F[42] = f("div", { class: "divider" }, null, -1)),
        f("div", x9, [
          ct(f("select", {
            "onUpdate:modelValue": F[5] || (F[5] = (k) => i.value = k),
            class: "workspace-selector"
          }, [...F[36] || (F[36] = [
            f("option", { value: "standard" }, "Standard", -1),
            f("option", { value: "animation" }, "Animation", -1),
            f("option", { value: "effects" }, "Effects", -1),
            f("option", { value: "minimal" }, "Minimal", -1)
          ])], 512), [
            [ti, i.value]
          ])
        ]),
        F[43] || (F[43] = f("div", { class: "spacer" }, null, -1)),
        f("div", b9, [
          f("span", {
            class: Ue(["gpu-badge", _.value])
          }, be(_.value.toUpperCase()), 3),
          f("button", {
            onClick: le,
            disabled: !N.value,
            title: "Undo (Ctrl+Z)"
          }, [...F[37] || (F[37] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, w9),
          f("button", {
            onClick: oe,
            disabled: !D.value,
            title: "Redo (Ctrl+Shift+Z)"
          }, [...F[38] || (F[38] = [
            f("span", { class: "icon" }, "", -1)
          ])], 8, S9),
          f("button", {
            onClick: F[6] || (F[6] = (k) => h.value = !0),
            title: "Export Matte"
          }, [...F[39] || (F[39] = [
            f("span", { class: "icon" }, "", -1),
            ft(" Matte ", -1)
          ])]),
          f("button", {
            onClick: F[7] || (F[7] = (k) => m.value = !0),
            title: "Export to ComfyUI"
          }, [...F[40] || (F[40] = [
            f("span", { class: "icon" }, "", -1),
            ft(" ComfyUI ", -1)
          ])])
        ])
      ]),
      f("div", M9, [
        Ne(Ge(Hu), { class: "default-theme horizontal-split" }, {
          default: Fi(() => [
            Ne(Ge(cr), {
              size: 12,
              "min-size": 8,
              "max-size": 20
            }, {
              default: Fi(() => [
                f("div", C9, [
                  f("div", E9, [
                    f("button", {
                      class: Ue({ active: r.value === "project" }),
                      onClick: F[8] || (F[8] = (k) => r.value = "project")
                    }, " Project ", 2),
                    f("button", {
                      class: Ue({ active: r.value === "effects" }),
                      onClick: F[9] || (F[9] = (k) => r.value = "effects")
                    }, " Effects ", 2)
                  ]),
                  f("div", T9, [
                    r.value === "project" ? (re(), St(GT, {
                      key: 0,
                      onOpenCompositionSettings: F[10] || (F[10] = (k) => p.value = !0)
                    })) : r.value === "effects" ? (re(), St(bA, { key: 1 })) : Pe("", !0)
                  ])
                ])
              ]),
              _: 1
            }),
            Ne(Ge(cr), {
              size: 70,
              "min-size": 40
            }, {
              default: Fi(() => [
                Ne(Ge(Hu), {
                  horizontal: "",
                  class: "default-theme"
                }, {
                  default: Fi(() => [
                    Ne(Ge(cr), {
                      size: 65,
                      "min-size": 20
                    }, {
                      default: Fi(() => [
                        f("div", A9, [
                          f("div", P9, [
                            f("div", D9, [
                              f("button", {
                                class: Ue({ active: a.value === "composition" }),
                                onClick: F[11] || (F[11] = (k) => a.value = "composition")
                              }, " Composition ", 2),
                              f("button", {
                                class: Ue({ active: a.value === "layer" }),
                                onClick: F[12] || (F[12] = (k) => a.value = "layer")
                              }, " Layer ", 2),
                              f("button", {
                                class: Ue({ active: a.value === "footage" }),
                                onClick: F[13] || (F[13] = (k) => a.value = "footage")
                              }, " Footage ", 2)
                            ]),
                            f("div", R9, [
                              ct(f("select", {
                                "onUpdate:modelValue": F[14] || (F[14] = (k) => l.value = k),
                                onChange: de,
                                class: "zoom-select"
                              }, [...F[44] || (F[44] = [
                                f("option", { value: "fit" }, "Fit", -1),
                                f("option", { value: "25" }, "25%", -1),
                                f("option", { value: "50" }, "50%", -1),
                                f("option", { value: "75" }, "75%", -1),
                                f("option", { value: "100" }, "100%", -1),
                                f("option", { value: "150" }, "150%", -1),
                                f("option", { value: "200" }, "200%", -1)
                              ])], 544), [
                                [ti, l.value]
                              ]),
                              f("button", {
                                class: Ue({ active: c.value }),
                                onClick: F[15] || (F[15] = (k) => c.value = !c.value),
                                title: "Toggle Guides"
                              }, [...F[45] || (F[45] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2),
                              f("button", {
                                class: Ue({ active: u.value }),
                                onClick: F[16] || (F[16] = (k) => u.value = !u.value),
                                title: "Toggle Grid"
                              }, [...F[46] || (F[46] = [
                                f("span", { class: "icon" }, "", -1)
                              ])], 2)
                            ])
                          ]),
                          f("div", I9, [
                            a.value === "composition" ? (re(), St(UN, {
                              key: 0,
                              ref_key: "threeCanvasRef",
                              ref: v
                            }, null, 512)) : (re(), St(Fz, {
                              key: 1,
                              camera: g.value,
                              viewportState: S.value,
                              viewOptions: w.value,
                              compWidth: x.value,
                              compHeight: C.value
                            }, null, 8, ["camera", "viewportState", "viewOptions", "compWidth", "compHeight"]))
                          ])
                        ])
                      ]),
                      _: 1
                    }),
                    Ne(Ge(cr), {
                      size: 35,
                      "min-size": 15
                    }, {
                      default: Fi(() => [
                        d.value ? (re(), St(Ge(Hu), {
                          key: 0,
                          horizontal: "",
                          class: "default-theme"
                        }, {
                          default: Fi(() => [
                            Ne(Ge(cr), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: Fi(() => [
                                f("div", k9, [
                                  Ne(Hv, {
                                    onOpenCompositionSettings: F[17] || (F[17] = (k) => p.value = !0)
                                  })
                                ])
                              ]),
                              _: 1
                            }),
                            Ne(Ge(cr), {
                              size: 50,
                              "min-size": 20
                            }, {
                              default: Fi(() => [
                                f("div", L9, [
                                  Ne(CB, {
                                    onClose: F[18] || (F[18] = (k) => d.value = !1)
                                  })
                                ])
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        })) : (re(), ae("div", F9, [
                          Ne(Hv, {
                            onOpenCompositionSettings: F[19] || (F[19] = (k) => p.value = !0)
                          })
                        ]))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            Ne(Ge(cr), {
              size: 18,
              "min-size": 12,
              "max-size": 25
            }, {
              default: Fi(() => [
                f("div", U9, [
                  f("div", O9, [
                    f("button", {
                      class: Ue({ active: o.value === "effects" }),
                      onClick: F[20] || (F[20] = (k) => o.value = "effects")
                    }, " Effects ", 2),
                    f("button", {
                      class: Ue({ active: o.value === "properties" }),
                      onClick: F[21] || (F[21] = (k) => o.value = "properties")
                    }, " Props ", 2),
                    f("button", {
                      class: Ue({ active: o.value === "camera" }),
                      onClick: F[22] || (F[22] = (k) => o.value = "camera")
                    }, " Cam ", 2),
                    f("button", {
                      class: Ue({ active: o.value === "audio" }),
                      onClick: F[23] || (F[23] = (k) => o.value = "audio")
                    }, " Audio ", 2)
                  ]),
                  f("div", z9, [
                    o.value === "effects" ? (re(), St(W3, { key: 0 })) : o.value === "properties" ? (re(), St(WF, { key: 1 })) : o.value === "camera" ? (re(), St(nO, {
                      key: 2,
                      camera: g.value,
                      "onUpdate:camera": Y
                    }, null, 8, ["camera"])) : o.value === "audio" ? (re(), St(fz, { key: 3 })) : Pe("", !0)
                  ])
                ])
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      f("div", N9, [
        f("div", B9, [
          f("span", V9, be(M.value), 1),
          F[47] || (F[47] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", G9, be(L.value), 1)
        ]),
        f("div", H9, [
          T.value > 0 ? (re(), ae("span", W9, " Rendering: " + be(Math.round(T.value * 100)) + "% ", 1)) : Pe("", !0)
        ]),
        f("div", $9, [
          f("span", X9, be(P.value), 1),
          F[48] || (F[48] = f("span", { class: "status-divider" }, "|", -1)),
          f("span", j9, be(E.value) + " fps", 1)
        ])
      ]),
      h.value ? (re(), St(hV, {
        key: 0,
        onClose: F[24] || (F[24] = (k) => h.value = !1),
        onExported: j
      })) : Pe("", !0),
      m.value ? (re(), St(L7, {
        key: 1,
        layers: Ge(e).layers,
        "camera-keyframes": ne.value,
        "current-frame": Ge(e).currentFrame,
        "total-frames": Ge(e).frameCount,
        onClose: F[25] || (F[25] = (k) => m.value = !1),
        onExported: q
      }, null, 8, ["layers", "camera-keyframes", "current-frame", "total-frames"])) : Pe("", !0),
      Ne(h9, {
        visible: p.value,
        onClose: F[26] || (F[26] = (k) => p.value = !1),
        onConfirm: te
      }, null, 8, ["visible"])
    ]));
  }
}), q9 = /* @__PURE__ */ Bt(Y9, [["__scopeId", "data-v-7dd8f679"]]), Z9 = /* @__PURE__ */ Ut({
  __name: "App",
  setup(s) {
    return (e, n) => (re(), St(q9));
  }
}), ky = [
  512,
  512,
  456,
  512,
  328,
  456,
  335,
  512,
  405,
  328,
  271,
  456,
  388,
  335,
  292,
  512,
  454,
  405,
  364,
  328,
  298,
  271,
  496,
  456,
  420,
  388,
  360,
  335,
  312,
  292,
  273,
  512,
  482,
  454,
  428,
  405,
  383,
  364,
  345,
  328,
  312,
  298,
  284,
  271,
  259,
  496,
  475,
  456,
  437,
  420,
  404,
  388,
  374,
  360,
  347,
  335,
  323,
  312,
  302,
  292,
  282,
  273,
  265,
  512,
  497,
  482,
  468,
  454,
  441,
  428,
  417,
  405,
  394,
  383,
  373,
  364,
  354,
  345,
  337,
  328,
  320,
  312,
  305,
  298,
  291,
  284,
  278,
  271,
  265,
  259,
  507,
  496,
  485,
  475,
  465,
  456,
  446,
  437,
  428,
  420,
  412,
  404,
  396,
  388,
  381,
  374,
  367,
  360,
  354,
  347,
  341,
  335,
  329,
  323,
  318,
  312,
  307,
  302,
  297,
  292,
  287,
  282,
  278,
  273,
  269,
  265,
  261,
  512,
  505,
  497,
  489,
  482,
  475,
  468,
  461,
  454,
  447,
  441,
  435,
  428,
  422,
  417,
  411,
  405,
  399,
  394,
  389,
  383,
  378,
  373,
  368,
  364,
  359,
  354,
  350,
  345,
  341,
  337,
  332,
  328,
  324,
  320,
  316,
  312,
  309,
  305,
  301,
  298,
  294,
  291,
  287,
  284,
  281,
  278,
  274,
  271,
  268,
  265,
  262,
  259,
  257,
  507,
  501,
  496,
  491,
  485,
  480,
  475,
  470,
  465,
  460,
  456,
  451,
  446,
  442,
  437,
  433,
  428,
  424,
  420,
  416,
  412,
  408,
  404,
  400,
  396,
  392,
  388,
  385,
  381,
  377,
  374,
  370,
  367,
  363,
  360,
  357,
  354,
  350,
  347,
  344,
  341,
  338,
  335,
  332,
  329,
  326,
  323,
  320,
  318,
  315,
  312,
  310,
  307,
  304,
  302,
  299,
  297,
  294,
  292,
  289,
  287,
  285,
  282,
  280,
  278,
  275,
  273,
  271,
  269,
  267,
  265,
  263,
  261,
  259
], Ly = [
  9,
  11,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  15,
  15,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  21,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  22,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  23,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24,
  24
];
function Fy(s) {
  const e = { r: 0, g: 0, b: 0, a: 0, next: null };
  let n = e;
  for (let i = 1; i < s; i++)
    n.next = { r: 0, g: 0, b: 0, a: 0, next: null }, n = n.next;
  return n.next = e, e;
}
function K9(s, e, n) {
  const i = s.data, r = s.width, o = s.height;
  e = Math.max(0, Math.min(255, Math.round(e))), n = Math.max(0, Math.min(255, Math.round(n))), !(e === 0 && n === 0) && (e > 0 && J9(i, r, o, e), n > 0 && Q9(i, r, o, n));
}
function J9(s, e, n, i) {
  const r = i + i + 1, o = e - 1, a = ky[i], l = Ly[i], c = Fy(r);
  for (let u = 0; u < n; u++) {
    let d = 0, h = 0, m = 0, p = 0, y = 0, _ = 0, v = 0, g = 0, S = 0, w = 0, x = 0, C = 0;
    const E = u * e;
    let P = c, T = c;
    const b = s[E * 4], M = s[E * 4 + 1], L = s[E * 4 + 2], N = s[E * 4 + 3];
    for (let O = 0; O <= i; O++) {
      P.r = b, P.g = M, P.b = L, P.a = N;
      const A = i + 1 - O;
      S += b * A, w += M * A, x += L * A, C += N * A, O > 0 ? (d += b, h += M, m += L, p += N) : (y += b, _ += M, v += L, g += N), P = P.next;
    }
    for (let O = 1; O <= i; O++) {
      const A = Math.min(O, o), G = (E + A) * 4, he = s[G], ee = s[G + 1], le = s[G + 2], oe = s[G + 3];
      P.r = he, P.g = ee, P.b = le, P.a = oe;
      const Y = i + 1 - O;
      S += he * Y, w += ee * Y, x += le * Y, C += oe * Y, d += he, h += ee, m += le, p += oe, P = P.next;
    }
    let D = c;
    for (let O = 0; O < i; O++)
      D = D.next;
    T = D.next;
    for (let O = 0; O < e; O++) {
      const A = (E + O) * 4;
      s[A] = S * a >>> l, s[A + 1] = w * a >>> l, s[A + 2] = x * a >>> l, s[A + 3] = C * a >>> l, S -= y, w -= _, x -= v, C -= g, y -= D.r, _ -= D.g, v -= D.b, g -= D.a;
      const G = Math.min(O + i + 1, o), he = (E + G) * 4;
      D.r = s[he], D.g = s[he + 1], D.b = s[he + 2], D.a = s[he + 3], d += D.r, h += D.g, m += D.b, p += D.a, S += d, w += h, x += m, C += p, D = D.next, y += T.r, _ += T.g, v += T.b, g += T.a, d -= T.r, h -= T.g, m -= T.b, p -= T.a, T = T.next;
    }
  }
}
function Q9(s, e, n, i) {
  const r = i + i + 1, o = n - 1, a = ky[i], l = Ly[i], c = Fy(r);
  for (let u = 0; u < e; u++) {
    let d = 0, h = 0, m = 0, p = 0, y = 0, _ = 0, v = 0, g = 0, S = 0, w = 0, x = 0, C = 0, E = c, P = c;
    const T = s[u * 4], b = s[u * 4 + 1], M = s[u * 4 + 2], L = s[u * 4 + 3];
    for (let D = 0; D <= i; D++) {
      E.r = T, E.g = b, E.b = M, E.a = L;
      const O = i + 1 - D;
      S += T * O, w += b * O, x += M * O, C += L * O, D > 0 ? (d += T, h += b, m += M, p += L) : (y += T, _ += b, v += M, g += L), E = E.next;
    }
    for (let D = 1; D <= i; D++) {
      const A = (Math.min(D, o) * e + u) * 4, G = s[A], he = s[A + 1], ee = s[A + 2], le = s[A + 3];
      E.r = G, E.g = he, E.b = ee, E.a = le;
      const oe = i + 1 - D;
      S += G * oe, w += he * oe, x += ee * oe, C += le * oe, d += G, h += he, m += ee, p += le, E = E.next;
    }
    let N = c;
    for (let D = 0; D < i; D++)
      N = N.next;
    P = N.next;
    for (let D = 0; D < n; D++) {
      const O = (D * e + u) * 4;
      s[O] = S * a >>> l, s[O + 1] = w * a >>> l, s[O + 2] = x * a >>> l, s[O + 3] = C * a >>> l, S -= y, w -= _, x -= v, C -= g, y -= N.r, _ -= N.g, v -= N.b, g -= N.a;
      const G = (Math.min(D + i + 1, o) * e + u) * 4;
      N.r = s[G], N.g = s[G + 1], N.b = s[G + 2], N.a = s[G + 3], d += N.r, h += N.g, m += N.b, p += N.a, S += d, w += h, x += m, C += p, N = N.next, y += P.r, _ += P.g, v += P.b, g += P.a, d -= P.r, h -= P.g, m -= P.b, p -= P.a, P = P.next;
    }
  }
}
function eG(s, e) {
  const n = e.blurriness ?? 10, i = e.blur_dimensions ?? "both";
  if (n <= 0)
    return s;
  const r = $o(s.canvas), o = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height);
  let a = 0, l = 0;
  switch (i) {
    case "horizontal":
      a = n;
      break;
    case "vertical":
      l = n;
      break;
    case "both":
    default:
      a = n, l = n;
      break;
  }
  return K9(o, a, l), r.ctx.putImageData(o, 0, 0), r;
}
function tG() {
  mo("gaussian-blur", eG);
}
function nG(s, e) {
  const n = (e.brightness ?? 0) / 100, i = (e.contrast ?? 0) / 100, r = e.use_legacy ?? !1;
  if (n === 0 && i === 0)
    return s;
  const o = $o(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = a.data, c = r ? 1 + i : 259 * (i * 255 + 255) / (255 * (259 - i * 255));
  for (let u = 0; u < l.length; u += 4) {
    let d = l[u], h = l[u + 1], m = l[u + 2];
    d += n * 255, h += n * 255, m += n * 255, d = c * (d - 128) + 128, h = c * (h - 128) + 128, m = c * (m - 128) + 128, l[u] = Math.max(0, Math.min(255, d)), l[u + 1] = Math.max(0, Math.min(255, h)), l[u + 2] = Math.max(0, Math.min(255, m));
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function iG(s, e, n) {
  s /= 255, e /= 255, n /= 255;
  const i = Math.max(s, e, n), r = Math.min(s, e, n), o = (i + r) / 2;
  let a = 0, l = 0;
  if (i !== r) {
    const c = i - r;
    switch (l = o > 0.5 ? c / (2 - i - r) : c / (i + r), i) {
      case s:
        a = ((e - n) / c + (e < n ? 6 : 0)) / 6;
        break;
      case e:
        a = ((n - s) / c + 2) / 6;
        break;
      case n:
        a = ((s - e) / c + 4) / 6;
        break;
    }
  }
  return [a, l, o];
}
function sG(s, e, n) {
  let i, r, o;
  if (e === 0)
    i = r = o = n;
  else {
    const a = (u, d, h) => (h < 0 && (h += 1), h > 1 && (h -= 1), h < 0.16666666666666666 ? u + (d - u) * 6 * h : h < 0.5 ? d : h < 0.6666666666666666 ? u + (d - u) * (0.6666666666666666 - h) * 6 : u), l = n < 0.5 ? n * (1 + e) : n + e - n * e, c = 2 * n - l;
    i = a(c, l, s + 1 / 3), r = a(c, l, s), o = a(c, l, s - 1 / 3);
  }
  return [Math.round(i * 255), Math.round(r * 255), Math.round(o * 255)];
}
function rG(s, e) {
  const n = (e.master_hue ?? 0) / 360, i = (e.master_saturation ?? 0) / 100, r = (e.master_lightness ?? 0) / 100, o = e.colorize ?? !1;
  if (n === 0 && i === 0 && r === 0 && !o)
    return s;
  const a = $o(s.canvas), l = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), c = l.data;
  for (let u = 0; u < c.length; u += 4) {
    const d = c[u], h = c[u + 1], m = c[u + 2];
    let [p, y, _] = iG(d, h, m);
    o ? (p = n, y = Math.abs(i) + 0.25) : (p = (p + n) % 1, p < 0 && (p += 1), y = y + y * i), _ = _ + _ * r, y = Math.max(0, Math.min(1, y)), _ = Math.max(0, Math.min(1, _));
    const [v, g, S] = sG(p, y, _);
    c[u] = v, c[u + 1] = g, c[u + 2] = S;
  }
  return a.ctx.putImageData(l, 0, 0), a;
}
function oG(s, e) {
  const n = e.input_black ?? 0, i = e.input_white ?? 255, r = e.gamma ?? 1, o = e.output_black ?? 0, a = e.output_white ?? 255;
  if (n === 0 && i === 255 && r === 1 && o === 0 && a === 255)
    return s;
  const l = $o(s.canvas), c = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), u = c.data, d = new Uint8Array(256), h = i - n, m = a - o;
  for (let p = 0; p < 256; p++) {
    let y = (p - n) / h;
    y = Math.max(0, Math.min(1, y)), y = Math.pow(y, 1 / r), y = o + y * m, y = Math.max(0, Math.min(255, y)), d[p] = Math.round(y);
  }
  for (let p = 0; p < u.length; p += 4)
    u[p] = d[u[p]], u[p + 1] = d[u[p + 1]], u[p + 2] = d[u[p + 2]];
  return l.ctx.putImageData(c, 0, 0), l;
}
function aG(s, e) {
  const n = e.map_black_to ?? { r: 0, g: 0, b: 0 }, i = e.map_white_to ?? { r: 255, g: 255, b: 255 }, r = (e.amount_to_tint ?? 100) / 100;
  if (r === 0)
    return s;
  const o = $o(s.canvas), a = s.ctx.getImageData(0, 0, s.canvas.width, s.canvas.height), l = a.data;
  for (let c = 0; c < l.length; c += 4) {
    const u = l[c], d = l[c + 1], h = l[c + 2], m = (u * 0.299 + d * 0.587 + h * 0.114) / 255, p = n.r + (i.r - n.r) * m, y = n.g + (i.g - n.g) * m, _ = n.b + (i.b - n.b) * m;
    l[c] = Math.round(u + (p - u) * r), l[c + 1] = Math.round(d + (y - d) * r), l[c + 2] = Math.round(h + (_ - h) * r);
  }
  return o.ctx.putImageData(a, 0, 0), o;
}
function lG(s, e) {
  const n = e.shadow_color ?? { r: 0, g: 0, b: 0 }, i = (e.opacity ?? 50) / 100, r = (e.direction ?? 135) * Math.PI / 180, o = e.distance ?? 5, a = e.softness ?? 5, l = e.shadow_only ?? !1, c = $o(s.canvas), { width: u, height: d } = s.canvas, h = Math.cos(r) * o, m = Math.sin(r) * o;
  return c.ctx.shadowColor = `rgba(${n.r}, ${n.g}, ${n.b}, ${i})`, c.ctx.shadowBlur = a, c.ctx.shadowOffsetX = h, c.ctx.shadowOffsetY = m, c.ctx.drawImage(s.canvas, 0, 0), c.ctx.shadowColor = "transparent", c.ctx.shadowBlur = 0, c.ctx.shadowOffsetX = 0, c.ctx.shadowOffsetY = 0, l || c.ctx.drawImage(s.canvas, 0, 0), c;
}
function cG() {
  mo("brightness-contrast", nG), mo("hue-saturation", rG), mo("levels", oG), mo("tint", aG), mo("drop-shadow", lG);
}
function uG() {
  tG(), cG();
}
let Uy = null;
function Qv(s) {
  let e = null;
  if (typeof s == "string" ? e = document.getElementById(s) || document.querySelector(s) : s instanceof HTMLElement ? e = s : e = document.getElementById("weyl-compositor-root") || document.getElementById("app"), !e) return null;
  uG();
  const n = dx(Z9);
  return n.use(px()), n.mount(e), Uy = n, dG(), n;
}
function dG() {
  window.addEventListener("weyl:inputs-ready", (s) => {
    window.dispatchEvent(new CustomEvent("weyl:load-project-inputs", { detail: s.detail }));
  });
}
async function gG(s, e) {
  var n, i;
  return ((i = (n = window.WeylCompositor) == null ? void 0 : n.sendOutput) == null ? void 0 : i.call(n, s, e)) ?? !1;
}
document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => Qv()) : setTimeout(() => {
  Uy || Qv();
}, 0);
var mc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hG(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function vc(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Oy = { exports: {} };
(function(s, e) {
  var n = { env: {} };
  /*!
  
  	JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  	<http://stuartk.com/jszip>
  
  	(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  	Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  	JSZip uses the library pako released under the MIT license :
  	https://github.com/nodeca/pako/blob/main/LICENSE
  	*/
  (function(i) {
    s.exports = i();
  })(function() {
    return function i(r, o, a) {
      function l(d, h) {
        if (!o[d]) {
          if (!r[d]) {
            var m = typeof vc == "function" && vc;
            if (!h && m) return m(d, !0);
            if (c) return c(d, !0);
            var p = new Error("Cannot find module '" + d + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var y = o[d] = { exports: {} };
          r[d][0].call(y.exports, function(_) {
            var v = r[d][1][_];
            return l(v || _);
          }, y, y.exports, i, r, o, a);
        }
        return o[d].exports;
      }
      for (var c = typeof vc == "function" && vc, u = 0; u < a.length; u++) l(a[u]);
      return l;
    }({ 1: [function(i, r, o) {
      var a = i("./utils"), l = i("./support"), c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      o.encode = function(u) {
        for (var d, h, m, p, y, _, v, g = [], S = 0, w = u.length, x = w, C = a.getTypeOf(u) !== "string"; S < u.length; ) x = w - S, m = C ? (d = u[S++], h = S < w ? u[S++] : 0, S < w ? u[S++] : 0) : (d = u.charCodeAt(S++), h = S < w ? u.charCodeAt(S++) : 0, S < w ? u.charCodeAt(S++) : 0), p = d >> 2, y = (3 & d) << 4 | h >> 4, _ = 1 < x ? (15 & h) << 2 | m >> 6 : 64, v = 2 < x ? 63 & m : 64, g.push(c.charAt(p) + c.charAt(y) + c.charAt(_) + c.charAt(v));
        return g.join("");
      }, o.decode = function(u) {
        var d, h, m, p, y, _, v = 0, g = 0, S = "data:";
        if (u.substr(0, S.length) === S) throw new Error("Invalid base64 input, it looks like a data url.");
        var w, x = 3 * (u = u.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (u.charAt(u.length - 1) === c.charAt(64) && x--, u.charAt(u.length - 2) === c.charAt(64) && x--, x % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
        for (w = l.uint8array ? new Uint8Array(0 | x) : new Array(0 | x); v < u.length; ) d = c.indexOf(u.charAt(v++)) << 2 | (p = c.indexOf(u.charAt(v++))) >> 4, h = (15 & p) << 4 | (y = c.indexOf(u.charAt(v++))) >> 2, m = (3 & y) << 6 | (_ = c.indexOf(u.charAt(v++))), w[g++] = d, y !== 64 && (w[g++] = h), _ !== 64 && (w[g++] = m);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(i, r, o) {
      var a = i("./external"), l = i("./stream/DataWorker"), c = i("./stream/Crc32Probe"), u = i("./stream/DataLengthProbe");
      function d(h, m, p, y, _) {
        this.compressedSize = h, this.uncompressedSize = m, this.crc32 = p, this.compression = y, this.compressedContent = _;
      }
      d.prototype = { getContentWorker: function() {
        var h = new l(a.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new u("data_length")), m = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== m.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new l(a.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, d.createWorkerFrom = function(h, m, p) {
        return h.pipe(new c()).pipe(new u("uncompressedSize")).pipe(m.compressWorker(p)).pipe(new u("compressedSize")).withStreamInfo("compression", m);
      }, r.exports = d;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(i, r, o) {
      var a = i("./stream/GenericWorker");
      o.STORE = { magic: "\0\0", compressWorker: function() {
        return new a("STORE compression");
      }, uncompressWorker: function() {
        return new a("STORE decompression");
      } }, o.DEFLATE = i("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(i, r, o) {
      var a = i("./utils"), l = function() {
        for (var c, u = [], d = 0; d < 256; d++) {
          c = d;
          for (var h = 0; h < 8; h++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
          u[d] = c;
        }
        return u;
      }();
      r.exports = function(c, u) {
        return c !== void 0 && c.length ? a.getTypeOf(c) !== "string" ? function(d, h, m, p) {
          var y = l, _ = p + m;
          d ^= -1;
          for (var v = p; v < _; v++) d = d >>> 8 ^ y[255 & (d ^ h[v])];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : function(d, h, m, p) {
          var y = l, _ = p + m;
          d ^= -1;
          for (var v = p; v < _; v++) d = d >>> 8 ^ y[255 & (d ^ h.charCodeAt(v))];
          return -1 ^ d;
        }(0 | u, c, c.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(i, r, o) {
      o.base64 = !1, o.binary = !1, o.dir = !1, o.createFolders = !0, o.date = null, o.compression = null, o.compressionOptions = null, o.comment = null, o.unixPermissions = null, o.dosPermissions = null;
    }, {}], 6: [function(i, r, o) {
      var a = null;
      a = typeof Promise < "u" ? Promise : i("lie"), r.exports = { Promise: a };
    }, { lie: 37 }], 7: [function(i, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", l = i("pako"), c = i("./utils"), u = i("./stream/GenericWorker"), d = a ? "uint8array" : "array";
      function h(m, p) {
        u.call(this, "FlateWorker/" + m), this._pako = null, this._pakoAction = m, this._pakoOptions = p, this.meta = {};
      }
      o.magic = "\b\0", c.inherits(h, u), h.prototype.processChunk = function(m) {
        this.meta = m.meta, this._pako === null && this._createPako(), this._pako.push(c.transformTo(d, m.data), !1);
      }, h.prototype.flush = function() {
        u.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        u.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new l[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var m = this;
        this._pako.onData = function(p) {
          m.push({ data: p, meta: m.meta });
        };
      }, o.compressWorker = function(m) {
        return new h("Deflate", m);
      }, o.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(i, r, o) {
      function a(y, _) {
        var v, g = "";
        for (v = 0; v < _; v++) g += String.fromCharCode(255 & y), y >>>= 8;
        return g;
      }
      function l(y, _, v, g, S, w) {
        var x, C, E = y.file, P = y.compression, T = w !== d.utf8encode, b = c.transformTo("string", w(E.name)), M = c.transformTo("string", d.utf8encode(E.name)), L = E.comment, N = c.transformTo("string", w(L)), D = c.transformTo("string", d.utf8encode(L)), O = M.length !== E.name.length, A = D.length !== L.length, G = "", he = "", ee = "", le = E.dir, oe = E.date, Y = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        _ && !v || (Y.crc32 = y.crc32, Y.compressedSize = y.compressedSize, Y.uncompressedSize = y.uncompressedSize);
        var j = 0;
        _ && (j |= 8), T || !O && !A || (j |= 2048);
        var q = 0, te = 0;
        le && (q |= 16), S === "UNIX" ? (te = 798, q |= function(de, H) {
          var X = de;
          return de || (X = H ? 16893 : 33204), (65535 & X) << 16;
        }(E.unixPermissions, le)) : (te = 20, q |= function(de) {
          return 63 & (de || 0);
        }(E.dosPermissions)), x = oe.getUTCHours(), x <<= 6, x |= oe.getUTCMinutes(), x <<= 5, x |= oe.getUTCSeconds() / 2, C = oe.getUTCFullYear() - 1980, C <<= 4, C |= oe.getUTCMonth() + 1, C <<= 5, C |= oe.getUTCDate(), O && (he = a(1, 1) + a(h(b), 4) + M, G += "up" + a(he.length, 2) + he), A && (ee = a(1, 1) + a(h(N), 4) + D, G += "uc" + a(ee.length, 2) + ee);
        var ne = "";
        return ne += `
\0`, ne += a(j, 2), ne += P.magic, ne += a(x, 2), ne += a(C, 2), ne += a(Y.crc32, 4), ne += a(Y.compressedSize, 4), ne += a(Y.uncompressedSize, 4), ne += a(b.length, 2), ne += a(G.length, 2), { fileRecord: m.LOCAL_FILE_HEADER + ne + b + G, dirRecord: m.CENTRAL_FILE_HEADER + a(te, 2) + ne + a(N.length, 2) + "\0\0\0\0" + a(q, 4) + a(g, 4) + b + G + N };
      }
      var c = i("../utils"), u = i("../stream/GenericWorker"), d = i("../utf8"), h = i("../crc32"), m = i("../signature");
      function p(y, _, v, g) {
        u.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = _, this.zipPlatform = v, this.encodeFileName = g, this.streamFiles = y, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      c.inherits(p, u), p.prototype.push = function(y) {
        var _ = y.meta.percent || 0, v = this.entriesCount, g = this._sources.length;
        this.accumulate ? this.contentBuffer.push(y) : (this.bytesWritten += y.data.length, u.prototype.push.call(this, { data: y.data, meta: { currentFile: this.currentFile, percent: v ? (_ + 100 * (v - g - 1)) / v : 100 } }));
      }, p.prototype.openedSource = function(y) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = y.file.name;
        var _ = this.streamFiles && !y.file.dir;
        if (_) {
          var v = l(y, _, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: v.fileRecord, meta: { percent: 0 } });
        } else this.accumulate = !0;
      }, p.prototype.closedSource = function(y) {
        this.accumulate = !1;
        var _ = this.streamFiles && !y.file.dir, v = l(y, _, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(v.dirRecord), _) this.push({ data: function(g) {
          return m.DATA_DESCRIPTOR + a(g.crc32, 4) + a(g.compressedSize, 4) + a(g.uncompressedSize, 4);
        }(y), meta: { percent: 100 } });
        else for (this.push({ data: v.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var y = this.bytesWritten, _ = 0; _ < this.dirRecords.length; _++) this.push({ data: this.dirRecords[_], meta: { percent: 100 } });
        var v = this.bytesWritten - y, g = function(S, w, x, C, E) {
          var P = c.transformTo("string", E(C));
          return m.CENTRAL_DIRECTORY_END + "\0\0\0\0" + a(S, 2) + a(S, 2) + a(w, 4) + a(x, 4) + a(P.length, 2) + P;
        }(this.dirRecords.length, v, y, this.zipComment, this.encodeFileName);
        this.push({ data: g, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(y) {
        this._sources.push(y);
        var _ = this;
        return y.on("data", function(v) {
          _.processChunk(v);
        }), y.on("end", function() {
          _.closedSource(_.previous.streamInfo), _._sources.length ? _.prepareNextSource() : _.end();
        }), y.on("error", function(v) {
          _.error(v);
        }), this;
      }, p.prototype.resume = function() {
        return !!u.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(y) {
        var _ = this._sources;
        if (!u.prototype.error.call(this, y)) return !1;
        for (var v = 0; v < _.length; v++) try {
          _[v].error(y);
        } catch {
        }
        return !0;
      }, p.prototype.lock = function() {
        u.prototype.lock.call(this);
        for (var y = this._sources, _ = 0; _ < y.length; _++) y[_].lock();
      }, r.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(i, r, o) {
      var a = i("../compressions"), l = i("./ZipFileWorker");
      o.generateWorker = function(c, u, d) {
        var h = new l(u.streamFiles, d, u.platform, u.encodeFileName), m = 0;
        try {
          c.forEach(function(p, y) {
            m++;
            var _ = function(w, x) {
              var C = w || x, E = a[C];
              if (!E) throw new Error(C + " is not a valid compression method !");
              return E;
            }(y.options.compression, u.compression), v = y.options.compressionOptions || u.compressionOptions || {}, g = y.dir, S = y.date;
            y._compressWorker(_, v).withStreamInfo("file", { name: p, dir: g, date: S, comment: y.comment || "", unixPermissions: y.unixPermissions, dosPermissions: y.dosPermissions }).pipe(h);
          }), h.entriesCount = m;
        } catch (p) {
          h.error(p);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(i, r, o) {
      function a() {
        if (!(this instanceof a)) return new a();
        if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var l = new a();
          for (var c in this) typeof this[c] != "function" && (l[c] = this[c]);
          return l;
        };
      }
      (a.prototype = i("./object")).loadAsync = i("./load"), a.support = i("./support"), a.defaults = i("./defaults"), a.version = "3.10.1", a.loadAsync = function(l, c) {
        return new a().loadAsync(l, c);
      }, a.external = i("./external"), r.exports = a;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(i, r, o) {
      var a = i("./utils"), l = i("./external"), c = i("./utf8"), u = i("./zipEntries"), d = i("./stream/Crc32Probe"), h = i("./nodejsUtils");
      function m(p) {
        return new l.Promise(function(y, _) {
          var v = p.decompressed.getContentWorker().pipe(new d());
          v.on("error", function(g) {
            _(g);
          }).on("end", function() {
            v.streamInfo.crc32 !== p.decompressed.crc32 ? _(new Error("Corrupted zip : CRC32 mismatch")) : y();
          }).resume();
        });
      }
      r.exports = function(p, y) {
        var _ = this;
        return y = a.extend(y || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: c.utf8decode }), h.isNode && h.isStream(p) ? l.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : a.prepareContent("the loaded zip file", p, !0, y.optimizedBinaryString, y.base64).then(function(v) {
          var g = new u(y);
          return g.load(v), g;
        }).then(function(v) {
          var g = [l.Promise.resolve(v)], S = v.files;
          if (y.checkCRC32) for (var w = 0; w < S.length; w++) g.push(m(S[w]));
          return l.Promise.all(g);
        }).then(function(v) {
          for (var g = v.shift(), S = g.files, w = 0; w < S.length; w++) {
            var x = S[w], C = x.fileNameStr, E = a.resolve(x.fileNameStr);
            _.file(E, x.decompressed, { binary: !0, optimizedBinaryString: !0, date: x.date, dir: x.dir, comment: x.fileCommentStr.length ? x.fileCommentStr : null, unixPermissions: x.unixPermissions, dosPermissions: x.dosPermissions, createFolders: y.createFolders }), x.dir || (_.file(E).unsafeOriginalName = C);
          }
          return g.zipComment.length && (_.comment = g.zipComment), _;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(i, r, o) {
      var a = i("../utils"), l = i("../stream/GenericWorker");
      function c(u, d) {
        l.call(this, "Nodejs stream input adapter for " + u), this._upstreamEnded = !1, this._bindStream(d);
      }
      a.inherits(c, l), c.prototype._bindStream = function(u) {
        var d = this;
        (this._stream = u).pause(), u.on("data", function(h) {
          d.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          d.isPaused ? this.generatedError = h : d.error(h);
        }).on("end", function() {
          d.isPaused ? d._upstreamEnded = !0 : d.end();
        });
      }, c.prototype.pause = function() {
        return !!l.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, r.exports = c;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(i, r, o) {
      var a = i("readable-stream").Readable;
      function l(c, u, d) {
        a.call(this, u), this._helper = c;
        var h = this;
        c.on("data", function(m, p) {
          h.push(m) || h._helper.pause(), d && d(p);
        }).on("error", function(m) {
          h.emit("error", m);
        }).on("end", function() {
          h.push(null);
        });
      }
      i("../utils").inherits(l, a), l.prototype._read = function() {
        this._helper.resume();
      }, r.exports = l;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(i, r, o) {
      r.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(a, l) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(a, l);
        if (typeof a == "number") throw new Error('The "data" argument must not be a number');
        return new Buffer(a, l);
      }, allocBuffer: function(a) {
        if (Buffer.alloc) return Buffer.alloc(a);
        var l = new Buffer(a);
        return l.fill(0), l;
      }, isBuffer: function(a) {
        return Buffer.isBuffer(a);
      }, isStream: function(a) {
        return a && typeof a.on == "function" && typeof a.pause == "function" && typeof a.resume == "function";
      } };
    }, {}], 15: [function(i, r, o) {
      function a(E, P, T) {
        var b, M = c.getTypeOf(P), L = c.extend(T || {}, h);
        L.date = L.date || /* @__PURE__ */ new Date(), L.compression !== null && (L.compression = L.compression.toUpperCase()), typeof L.unixPermissions == "string" && (L.unixPermissions = parseInt(L.unixPermissions, 8)), L.unixPermissions && 16384 & L.unixPermissions && (L.dir = !0), L.dosPermissions && 16 & L.dosPermissions && (L.dir = !0), L.dir && (E = S(E)), L.createFolders && (b = g(E)) && w.call(this, b, !0);
        var N = M === "string" && L.binary === !1 && L.base64 === !1;
        T && T.binary !== void 0 || (L.binary = !N), (P instanceof m && P.uncompressedSize === 0 || L.dir || !P || P.length === 0) && (L.base64 = !1, L.binary = !0, P = "", L.compression = "STORE", M = "string");
        var D = null;
        D = P instanceof m || P instanceof u ? P : _.isNode && _.isStream(P) ? new v(E, P) : c.prepareContent(E, P, L.binary, L.optimizedBinaryString, L.base64);
        var O = new p(E, D, L);
        this.files[E] = O;
      }
      var l = i("./utf8"), c = i("./utils"), u = i("./stream/GenericWorker"), d = i("./stream/StreamHelper"), h = i("./defaults"), m = i("./compressedObject"), p = i("./zipObject"), y = i("./generate"), _ = i("./nodejsUtils"), v = i("./nodejs/NodejsStreamInputAdapter"), g = function(E) {
        E.slice(-1) === "/" && (E = E.substring(0, E.length - 1));
        var P = E.lastIndexOf("/");
        return 0 < P ? E.substring(0, P) : "";
      }, S = function(E) {
        return E.slice(-1) !== "/" && (E += "/"), E;
      }, w = function(E, P) {
        return P = P !== void 0 ? P : h.createFolders, E = S(E), this.files[E] || a.call(this, E, null, { dir: !0, createFolders: P }), this.files[E];
      };
      function x(E) {
        return Object.prototype.toString.call(E) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(E) {
        var P, T, b;
        for (P in this.files) b = this.files[P], (T = P.slice(this.root.length, P.length)) && P.slice(0, this.root.length) === this.root && E(T, b);
      }, filter: function(E) {
        var P = [];
        return this.forEach(function(T, b) {
          E(T, b) && P.push(b);
        }), P;
      }, file: function(E, P, T) {
        if (arguments.length !== 1) return E = this.root + E, a.call(this, E, P, T), this;
        if (x(E)) {
          var b = E;
          return this.filter(function(L, N) {
            return !N.dir && b.test(L);
          });
        }
        var M = this.files[this.root + E];
        return M && !M.dir ? M : null;
      }, folder: function(E) {
        if (!E) return this;
        if (x(E)) return this.filter(function(M, L) {
          return L.dir && E.test(M);
        });
        var P = this.root + E, T = w.call(this, P), b = this.clone();
        return b.root = T.name, b;
      }, remove: function(E) {
        E = this.root + E;
        var P = this.files[E];
        if (P || (E.slice(-1) !== "/" && (E += "/"), P = this.files[E]), P && !P.dir) delete this.files[E];
        else for (var T = this.filter(function(M, L) {
          return L.name.slice(0, E.length) === E;
        }), b = 0; b < T.length; b++) delete this.files[T[b].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(E) {
        var P, T = {};
        try {
          if ((T = c.extend(E || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: l.utf8encode })).type = T.type.toLowerCase(), T.compression = T.compression.toUpperCase(), T.type === "binarystring" && (T.type = "string"), !T.type) throw new Error("No output type specified.");
          c.checkSupport(T.type), T.platform !== "darwin" && T.platform !== "freebsd" && T.platform !== "linux" && T.platform !== "sunos" || (T.platform = "UNIX"), T.platform === "win32" && (T.platform = "DOS");
          var b = T.comment || this.comment || "";
          P = y.generateWorker(this, T, b);
        } catch (M) {
          (P = new u("error")).error(M);
        }
        return new d(P, T.type || "string", T.mimeType);
      }, generateAsync: function(E, P) {
        return this.generateInternalStream(E).accumulate(P);
      }, generateNodeStream: function(E, P) {
        return (E = E || {}).type || (E.type = "nodebuffer"), this.generateInternalStream(E).toNodejsStream(P);
      } };
      r.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(i, r, o) {
      r.exports = i("stream");
    }, { stream: void 0 }], 17: [function(i, r, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
        for (var u = 0; u < this.data.length; u++) c[u] = 255 & c[u];
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data[this.zero + c];
      }, l.prototype.lastIndexOfSignature = function(c) {
        for (var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), m = c.charCodeAt(3), p = this.length - 4; 0 <= p; --p) if (this.data[p] === u && this.data[p + 1] === d && this.data[p + 2] === h && this.data[p + 3] === m) return p - this.zero;
        return -1;
      }, l.prototype.readAndCheckSignature = function(c) {
        var u = c.charCodeAt(0), d = c.charCodeAt(1), h = c.charCodeAt(2), m = c.charCodeAt(3), p = this.readData(4);
        return u === p[0] && d === p[1] && h === p[2] && m === p[3];
      }, l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return [];
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(i, r, o) {
      var a = i("../utils");
      function l(c) {
        this.data = c, this.length = c.length, this.index = 0, this.zero = 0;
      }
      l.prototype = { checkOffset: function(c) {
        this.checkIndex(this.index + c);
      }, checkIndex: function(c) {
        if (this.length < this.zero + c || c < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + c + "). Corrupted zip ?");
      }, setIndex: function(c) {
        this.checkIndex(c), this.index = c;
      }, skip: function(c) {
        this.setIndex(this.index + c);
      }, byteAt: function() {
      }, readInt: function(c) {
        var u, d = 0;
        for (this.checkOffset(c), u = this.index + c - 1; u >= this.index; u--) d = (d << 8) + this.byteAt(u);
        return this.index += c, d;
      }, readString: function(c) {
        return a.transformTo("string", this.readData(c));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var c = this.readInt(4);
        return new Date(Date.UTC(1980 + (c >> 25 & 127), (c >> 21 & 15) - 1, c >> 16 & 31, c >> 11 & 31, c >> 5 & 63, (31 & c) << 1));
      } }, r.exports = l;
    }, { "../utils": 32 }], 19: [function(i, r, o) {
      var a = i("./Uint8ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(i, r, o) {
      var a = i("./DataReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.byteAt = function(c) {
        return this.data.charCodeAt(this.zero + c);
      }, l.prototype.lastIndexOfSignature = function(c) {
        return this.data.lastIndexOf(c) - this.zero;
      }, l.prototype.readAndCheckSignature = function(c) {
        return c === this.readData(4);
      }, l.prototype.readData = function(c) {
        this.checkOffset(c);
        var u = this.data.slice(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(i, r, o) {
      var a = i("./ArrayReader");
      function l(c) {
        a.call(this, c);
      }
      i("../utils").inherits(l, a), l.prototype.readData = function(c) {
        if (this.checkOffset(c), c === 0) return new Uint8Array(0);
        var u = this.data.subarray(this.zero + this.index, this.zero + this.index + c);
        return this.index += c, u;
      }, r.exports = l;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(i, r, o) {
      var a = i("../utils"), l = i("../support"), c = i("./ArrayReader"), u = i("./StringReader"), d = i("./NodeBufferReader"), h = i("./Uint8ArrayReader");
      r.exports = function(m) {
        var p = a.getTypeOf(m);
        return a.checkSupport(p), p !== "string" || l.uint8array ? p === "nodebuffer" ? new d(m) : l.uint8array ? new h(a.transformTo("uint8array", m)) : new c(a.transformTo("array", m)) : new u(m);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(i, r, o) {
      o.LOCAL_FILE_HEADER = "PK", o.CENTRAL_FILE_HEADER = "PK", o.CENTRAL_DIRECTORY_END = "PK", o.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", o.ZIP64_CENTRAL_DIRECTORY_END = "PK", o.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(i, r, o) {
      var a = i("./GenericWorker"), l = i("../utils");
      function c(u) {
        a.call(this, "ConvertWorker to " + u), this.destType = u;
      }
      l.inherits(c, a), c.prototype.processChunk = function(u) {
        this.push({ data: l.transformTo(this.destType, u.data), meta: u.meta });
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(i, r, o) {
      var a = i("./GenericWorker"), l = i("../crc32");
      function c() {
        a.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      i("../utils").inherits(c, a), c.prototype.processChunk = function(u) {
        this.streamInfo.crc32 = l(u.data, this.streamInfo.crc32 || 0), this.push(u);
      }, r.exports = c;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(i, r, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataLengthProbe for " + u), this.propName = u, this.withStreamInfo(u, 0);
      }
      a.inherits(c, l), c.prototype.processChunk = function(u) {
        if (u) {
          var d = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = d + u.data.length;
        }
        l.prototype.processChunk.call(this, u);
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(i, r, o) {
      var a = i("../utils"), l = i("./GenericWorker");
      function c(u) {
        l.call(this, "DataWorker");
        var d = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, u.then(function(h) {
          d.dataIsReady = !0, d.data = h, d.max = h && h.length || 0, d.type = a.getTypeOf(h), d.isPaused || d._tickAndRepeat();
        }, function(h) {
          d.error(h);
        });
      }
      a.inherits(c, l), c.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this.data = null;
      }, c.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, a.delay(this._tickAndRepeat, [], this)), !0);
      }, c.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (a.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, c.prototype._tick = function() {
        if (this.isPaused || this.isFinished) return !1;
        var u = null, d = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max) return this.end();
        switch (this.type) {
          case "string":
            u = this.data.substring(this.index, d);
            break;
          case "uint8array":
            u = this.data.subarray(this.index, d);
            break;
          case "array":
          case "nodebuffer":
            u = this.data.slice(this.index, d);
        }
        return this.index = d, this.push({ data: u, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, r.exports = c;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(i, r, o) {
      function a(l) {
        this.name = l || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      a.prototype = { push: function(l) {
        this.emit("data", l);
      }, end: function() {
        if (this.isFinished) return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (l) {
          this.emit("error", l);
        }
        return !0;
      }, error: function(l) {
        return !this.isFinished && (this.isPaused ? this.generatedError = l : (this.isFinished = !0, this.emit("error", l), this.previous && this.previous.error(l), this.cleanUp()), !0);
      }, on: function(l, c) {
        return this._listeners[l].push(c), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(l, c) {
        if (this._listeners[l]) for (var u = 0; u < this._listeners[l].length; u++) this._listeners[l][u].call(this, c);
      }, pipe: function(l) {
        return l.registerPrevious(this);
      }, registerPrevious: function(l) {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = l.streamInfo, this.mergeStreamInfo(), this.previous = l;
        var c = this;
        return l.on("data", function(u) {
          c.processChunk(u);
        }), l.on("end", function() {
          c.end();
        }), l.on("error", function(u) {
          c.error(u);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished) return !1;
        var l = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), l = !0), this.previous && this.previous.resume(), !l;
      }, flush: function() {
      }, processChunk: function(l) {
        this.push(l);
      }, withStreamInfo: function(l, c) {
        return this.extraStreamInfo[l] = c, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var l in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, l) && (this.streamInfo[l] = this.extraStreamInfo[l]);
      }, lock: function() {
        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var l = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + l : l;
      } }, r.exports = a;
    }, {}], 29: [function(i, r, o) {
      var a = i("../utils"), l = i("./ConvertWorker"), c = i("./GenericWorker"), u = i("../base64"), d = i("../support"), h = i("../external"), m = null;
      if (d.nodestream) try {
        m = i("../nodejs/NodejsStreamOutputAdapter");
      } catch {
      }
      function p(_, v) {
        return new h.Promise(function(g, S) {
          var w = [], x = _._internalType, C = _._outputType, E = _._mimeType;
          _.on("data", function(P, T) {
            w.push(P), v && v(T);
          }).on("error", function(P) {
            w = [], S(P);
          }).on("end", function() {
            try {
              var P = function(T, b, M) {
                switch (T) {
                  case "blob":
                    return a.newBlob(a.transformTo("arraybuffer", b), M);
                  case "base64":
                    return u.encode(b);
                  default:
                    return a.transformTo(T, b);
                }
              }(C, function(T, b) {
                var M, L = 0, N = null, D = 0;
                for (M = 0; M < b.length; M++) D += b[M].length;
                switch (T) {
                  case "string":
                    return b.join("");
                  case "array":
                    return Array.prototype.concat.apply([], b);
                  case "uint8array":
                    for (N = new Uint8Array(D), M = 0; M < b.length; M++) N.set(b[M], L), L += b[M].length;
                    return N;
                  case "nodebuffer":
                    return Buffer.concat(b);
                  default:
                    throw new Error("concat : unsupported type '" + T + "'");
                }
              }(x, w), E);
              g(P);
            } catch (T) {
              S(T);
            }
            w = [];
          }).resume();
        });
      }
      function y(_, v, g) {
        var S = v;
        switch (v) {
          case "blob":
          case "arraybuffer":
            S = "uint8array";
            break;
          case "base64":
            S = "string";
        }
        try {
          this._internalType = S, this._outputType = v, this._mimeType = g, a.checkSupport(S), this._worker = _.pipe(new l(S)), _.lock();
        } catch (w) {
          this._worker = new c("error"), this._worker.error(w);
        }
      }
      y.prototype = { accumulate: function(_) {
        return p(this, _);
      }, on: function(_, v) {
        var g = this;
        return _ === "data" ? this._worker.on(_, function(S) {
          v.call(g, S.data, S.meta);
        }) : this._worker.on(_, function() {
          a.delay(v, arguments, g);
        }), this;
      }, resume: function() {
        return a.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(_) {
        if (a.checkSupport("nodestream"), this._outputType !== "nodebuffer") throw new Error(this._outputType + " is not supported by this method");
        return new m(this, { objectMode: this._outputType !== "nodebuffer" }, _);
      } }, r.exports = y;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(i, r, o) {
      if (o.base64 = !0, o.array = !0, o.string = !0, o.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", o.nodebuffer = typeof Buffer < "u", o.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u") o.blob = !1;
      else {
        var a = new ArrayBuffer(0);
        try {
          o.blob = new Blob([a], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var l = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            l.append(a), o.blob = l.getBlob("application/zip").size === 0;
          } catch {
            o.blob = !1;
          }
        }
      }
      try {
        o.nodestream = !!i("readable-stream").Readable;
      } catch {
        o.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(i, r, o) {
      for (var a = i("./utils"), l = i("./support"), c = i("./nodejsUtils"), u = i("./stream/GenericWorker"), d = new Array(256), h = 0; h < 256; h++) d[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      d[254] = d[254] = 1;
      function m() {
        u.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        u.call(this, "utf-8 encode");
      }
      o.utf8encode = function(y) {
        return l.nodebuffer ? c.newBufferFrom(y, "utf-8") : function(_) {
          var v, g, S, w, x, C = _.length, E = 0;
          for (w = 0; w < C; w++) (64512 & (g = _.charCodeAt(w))) == 55296 && w + 1 < C && (64512 & (S = _.charCodeAt(w + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (S - 56320), w++), E += g < 128 ? 1 : g < 2048 ? 2 : g < 65536 ? 3 : 4;
          for (v = l.uint8array ? new Uint8Array(E) : new Array(E), w = x = 0; x < E; w++) (64512 & (g = _.charCodeAt(w))) == 55296 && w + 1 < C && (64512 & (S = _.charCodeAt(w + 1))) == 56320 && (g = 65536 + (g - 55296 << 10) + (S - 56320), w++), g < 128 ? v[x++] = g : (g < 2048 ? v[x++] = 192 | g >>> 6 : (g < 65536 ? v[x++] = 224 | g >>> 12 : (v[x++] = 240 | g >>> 18, v[x++] = 128 | g >>> 12 & 63), v[x++] = 128 | g >>> 6 & 63), v[x++] = 128 | 63 & g);
          return v;
        }(y);
      }, o.utf8decode = function(y) {
        return l.nodebuffer ? a.transformTo("nodebuffer", y).toString("utf-8") : function(_) {
          var v, g, S, w, x = _.length, C = new Array(2 * x);
          for (v = g = 0; v < x; ) if ((S = _[v++]) < 128) C[g++] = S;
          else if (4 < (w = d[S])) C[g++] = 65533, v += w - 1;
          else {
            for (S &= w === 2 ? 31 : w === 3 ? 15 : 7; 1 < w && v < x; ) S = S << 6 | 63 & _[v++], w--;
            1 < w ? C[g++] = 65533 : S < 65536 ? C[g++] = S : (S -= 65536, C[g++] = 55296 | S >> 10 & 1023, C[g++] = 56320 | 1023 & S);
          }
          return C.length !== g && (C.subarray ? C = C.subarray(0, g) : C.length = g), a.applyFromCharCode(C);
        }(y = a.transformTo(l.uint8array ? "uint8array" : "array", y));
      }, a.inherits(m, u), m.prototype.processChunk = function(y) {
        var _ = a.transformTo(l.uint8array ? "uint8array" : "array", y.data);
        if (this.leftOver && this.leftOver.length) {
          if (l.uint8array) {
            var v = _;
            (_ = new Uint8Array(v.length + this.leftOver.length)).set(this.leftOver, 0), _.set(v, this.leftOver.length);
          } else _ = this.leftOver.concat(_);
          this.leftOver = null;
        }
        var g = function(w, x) {
          var C;
          for ((x = x || w.length) > w.length && (x = w.length), C = x - 1; 0 <= C && (192 & w[C]) == 128; ) C--;
          return C < 0 || C === 0 ? x : C + d[w[C]] > x ? C : x;
        }(_), S = _;
        g !== _.length && (l.uint8array ? (S = _.subarray(0, g), this.leftOver = _.subarray(g, _.length)) : (S = _.slice(0, g), this.leftOver = _.slice(g, _.length))), this.push({ data: o.utf8decode(S), meta: y.meta });
      }, m.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: o.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, o.Utf8DecodeWorker = m, a.inherits(p, u), p.prototype.processChunk = function(y) {
        this.push({ data: o.utf8encode(y.data), meta: y.meta });
      }, o.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(i, r, o) {
      var a = i("./support"), l = i("./base64"), c = i("./nodejsUtils"), u = i("./external");
      function d(v) {
        return v;
      }
      function h(v, g) {
        for (var S = 0; S < v.length; ++S) g[S] = 255 & v.charCodeAt(S);
        return g;
      }
      i("setimmediate"), o.newBlob = function(v, g) {
        o.checkSupport("blob");
        try {
          return new Blob([v], { type: g });
        } catch {
          try {
            var S = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return S.append(v), S.getBlob(g);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var m = { stringifyByChunk: function(v, g, S) {
        var w = [], x = 0, C = v.length;
        if (C <= S) return String.fromCharCode.apply(null, v);
        for (; x < C; ) g === "array" || g === "nodebuffer" ? w.push(String.fromCharCode.apply(null, v.slice(x, Math.min(x + S, C)))) : w.push(String.fromCharCode.apply(null, v.subarray(x, Math.min(x + S, C)))), x += S;
        return w.join("");
      }, stringifyByChar: function(v) {
        for (var g = "", S = 0; S < v.length; S++) g += String.fromCharCode(v[S]);
        return g;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return a.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return a.nodebuffer && String.fromCharCode.apply(null, c.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(v) {
        var g = 65536, S = o.getTypeOf(v), w = !0;
        if (S === "uint8array" ? w = m.applyCanBeUsed.uint8array : S === "nodebuffer" && (w = m.applyCanBeUsed.nodebuffer), w) for (; 1 < g; ) try {
          return m.stringifyByChunk(v, S, g);
        } catch {
          g = Math.floor(g / 2);
        }
        return m.stringifyByChar(v);
      }
      function y(v, g) {
        for (var S = 0; S < v.length; S++) g[S] = v[S];
        return g;
      }
      o.applyFromCharCode = p;
      var _ = {};
      _.string = { string: d, array: function(v) {
        return h(v, new Array(v.length));
      }, arraybuffer: function(v) {
        return _.string.uint8array(v).buffer;
      }, uint8array: function(v) {
        return h(v, new Uint8Array(v.length));
      }, nodebuffer: function(v) {
        return h(v, c.allocBuffer(v.length));
      } }, _.array = { string: p, array: d, arraybuffer: function(v) {
        return new Uint8Array(v).buffer;
      }, uint8array: function(v) {
        return new Uint8Array(v);
      }, nodebuffer: function(v) {
        return c.newBufferFrom(v);
      } }, _.arraybuffer = { string: function(v) {
        return p(new Uint8Array(v));
      }, array: function(v) {
        return y(new Uint8Array(v), new Array(v.byteLength));
      }, arraybuffer: d, uint8array: function(v) {
        return new Uint8Array(v);
      }, nodebuffer: function(v) {
        return c.newBufferFrom(new Uint8Array(v));
      } }, _.uint8array = { string: p, array: function(v) {
        return y(v, new Array(v.length));
      }, arraybuffer: function(v) {
        return v.buffer;
      }, uint8array: d, nodebuffer: function(v) {
        return c.newBufferFrom(v);
      } }, _.nodebuffer = { string: p, array: function(v) {
        return y(v, new Array(v.length));
      }, arraybuffer: function(v) {
        return _.nodebuffer.uint8array(v).buffer;
      }, uint8array: function(v) {
        return y(v, new Uint8Array(v.length));
      }, nodebuffer: d }, o.transformTo = function(v, g) {
        if (g = g || "", !v) return g;
        o.checkSupport(v);
        var S = o.getTypeOf(g);
        return _[S][v](g);
      }, o.resolve = function(v) {
        for (var g = v.split("/"), S = [], w = 0; w < g.length; w++) {
          var x = g[w];
          x === "." || x === "" && w !== 0 && w !== g.length - 1 || (x === ".." ? S.pop() : S.push(x));
        }
        return S.join("/");
      }, o.getTypeOf = function(v) {
        return typeof v == "string" ? "string" : Object.prototype.toString.call(v) === "[object Array]" ? "array" : a.nodebuffer && c.isBuffer(v) ? "nodebuffer" : a.uint8array && v instanceof Uint8Array ? "uint8array" : a.arraybuffer && v instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, o.checkSupport = function(v) {
        if (!a[v.toLowerCase()]) throw new Error(v + " is not supported by this platform");
      }, o.MAX_VALUE_16BITS = 65535, o.MAX_VALUE_32BITS = -1, o.pretty = function(v) {
        var g, S, w = "";
        for (S = 0; S < (v || "").length; S++) w += "\\x" + ((g = v.charCodeAt(S)) < 16 ? "0" : "") + g.toString(16).toUpperCase();
        return w;
      }, o.delay = function(v, g, S) {
        setImmediate(function() {
          v.apply(S || null, g || []);
        });
      }, o.inherits = function(v, g) {
        function S() {
        }
        S.prototype = g.prototype, v.prototype = new S();
      }, o.extend = function() {
        var v, g, S = {};
        for (v = 0; v < arguments.length; v++) for (g in arguments[v]) Object.prototype.hasOwnProperty.call(arguments[v], g) && S[g] === void 0 && (S[g] = arguments[v][g]);
        return S;
      }, o.prepareContent = function(v, g, S, w, x) {
        return u.Promise.resolve(g).then(function(C) {
          return a.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new u.Promise(function(E, P) {
            var T = new FileReader();
            T.onload = function(b) {
              E(b.target.result);
            }, T.onerror = function(b) {
              P(b.target.error);
            }, T.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var E = o.getTypeOf(C);
          return E ? (E === "arraybuffer" ? C = o.transformTo("uint8array", C) : E === "string" && (x ? C = l.decode(C) : S && w !== !0 && (C = function(P) {
            return h(P, a.uint8array ? new Uint8Array(P.length) : new Array(P.length));
          }(C))), C) : u.Promise.reject(new Error("Can't read the data of '" + v + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(i, r, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./signature"), u = i("./zipEntry"), d = i("./support");
      function h(m) {
        this.files = [], this.loadOptions = m;
      }
      h.prototype = { checkSignature: function(m) {
        if (!this.reader.readAndCheckSignature(m)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + l.pretty(p) + ", expected " + l.pretty(m) + ")");
        }
      }, isSignature: function(m, p) {
        var y = this.reader.index;
        this.reader.setIndex(m);
        var _ = this.reader.readString(4) === p;
        return this.reader.setIndex(y), _;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var m = this.reader.readData(this.zipCommentLength), p = d.uint8array ? "uint8array" : "array", y = l.transformTo(p, m);
        this.zipComment = this.loadOptions.decodeFileName(y);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var m, p, y, _ = this.zip64EndOfCentralSize - 44; 0 < _; ) m = this.reader.readInt(2), p = this.reader.readInt(4), y = this.reader.readData(p), this.zip64ExtensibleData[m] = { id: m, length: p, value: y };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var m, p;
        for (m = 0; m < this.files.length; m++) p = this.files[m], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(c.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var m;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(c.CENTRAL_FILE_HEADER); ) (m = new u({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(m);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var m = this.reader.lastIndexOfSignature(c.CENTRAL_DIRECTORY_END);
        if (m < 0) throw this.isSignature(0, c.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(m);
        var p = m;
        if (this.checkSignature(c.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === l.MAX_VALUE_16BITS || this.diskWithCentralDirStart === l.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === l.MAX_VALUE_16BITS || this.centralDirRecords === l.MAX_VALUE_16BITS || this.centralDirSize === l.MAX_VALUE_32BITS || this.centralDirOffset === l.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (m = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(m), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, c.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(c.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var y = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (y += 20, y += 12 + this.zip64EndOfCentralSize);
        var _ = p - y;
        if (0 < _) this.isSignature(p, c.CENTRAL_FILE_HEADER) || (this.reader.zero = _);
        else if (_ < 0) throw new Error("Corrupted zip: missing " + Math.abs(_) + " bytes.");
      }, prepareReader: function(m) {
        this.reader = a(m);
      }, load: function(m) {
        this.prepareReader(m), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, r.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(i, r, o) {
      var a = i("./reader/readerFor"), l = i("./utils"), c = i("./compressedObject"), u = i("./crc32"), d = i("./utf8"), h = i("./compressions"), m = i("./support");
      function p(y, _) {
        this.options = y, this.loadOptions = _;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(y) {
        var _, v;
        if (y.skip(22), this.fileNameLength = y.readInt(2), v = y.readInt(2), this.fileName = y.readData(this.fileNameLength), y.skip(v), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((_ = function(g) {
          for (var S in h) if (Object.prototype.hasOwnProperty.call(h, S) && h[S].magic === g) return h[S];
          return null;
        }(this.compressionMethod)) === null) throw new Error("Corrupted zip : compression " + l.pretty(this.compressionMethod) + " unknown (inner file : " + l.transformTo("string", this.fileName) + ")");
        this.decompressed = new c(this.compressedSize, this.uncompressedSize, this.crc32, _, y.readData(this.compressedSize));
      }, readCentralPart: function(y) {
        this.versionMadeBy = y.readInt(2), y.skip(2), this.bitFlag = y.readInt(2), this.compressionMethod = y.readString(2), this.date = y.readDate(), this.crc32 = y.readInt(4), this.compressedSize = y.readInt(4), this.uncompressedSize = y.readInt(4);
        var _ = y.readInt(2);
        if (this.extraFieldsLength = y.readInt(2), this.fileCommentLength = y.readInt(2), this.diskNumberStart = y.readInt(2), this.internalFileAttributes = y.readInt(2), this.externalFileAttributes = y.readInt(4), this.localHeaderOffset = y.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
        y.skip(_), this.readExtraFields(y), this.parseZIP64ExtraField(y), this.fileComment = y.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var y = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), y == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), y == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var y = a(this.extraFields[1].value);
          this.uncompressedSize === l.MAX_VALUE_32BITS && (this.uncompressedSize = y.readInt(8)), this.compressedSize === l.MAX_VALUE_32BITS && (this.compressedSize = y.readInt(8)), this.localHeaderOffset === l.MAX_VALUE_32BITS && (this.localHeaderOffset = y.readInt(8)), this.diskNumberStart === l.MAX_VALUE_32BITS && (this.diskNumberStart = y.readInt(4));
        }
      }, readExtraFields: function(y) {
        var _, v, g, S = y.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); y.index + 4 < S; ) _ = y.readInt(2), v = y.readInt(2), g = y.readData(v), this.extraFields[_] = { id: _, length: v, value: g };
        y.setIndex(S);
      }, handleUTF8: function() {
        var y = m.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) this.fileNameStr = d.utf8decode(this.fileName), this.fileCommentStr = d.utf8decode(this.fileComment);
        else {
          var _ = this.findExtraFieldUnicodePath();
          if (_ !== null) this.fileNameStr = _;
          else {
            var v = l.transformTo(y, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(v);
          }
          var g = this.findExtraFieldUnicodeComment();
          if (g !== null) this.fileCommentStr = g;
          else {
            var S = l.transformTo(y, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(S);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var y = this.extraFields[28789];
        if (y) {
          var _ = a(y.value);
          return _.readInt(1) !== 1 || u(this.fileName) !== _.readInt(4) ? null : d.utf8decode(_.readData(y.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var y = this.extraFields[25461];
        if (y) {
          var _ = a(y.value);
          return _.readInt(1) !== 1 || u(this.fileComment) !== _.readInt(4) ? null : d.utf8decode(_.readData(y.length - 5));
        }
        return null;
      } }, r.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(i, r, o) {
      function a(_, v, g) {
        this.name = _, this.dir = g.dir, this.date = g.date, this.comment = g.comment, this.unixPermissions = g.unixPermissions, this.dosPermissions = g.dosPermissions, this._data = v, this._dataBinary = g.binary, this.options = { compression: g.compression, compressionOptions: g.compressionOptions };
      }
      var l = i("./stream/StreamHelper"), c = i("./stream/DataWorker"), u = i("./utf8"), d = i("./compressedObject"), h = i("./stream/GenericWorker");
      a.prototype = { internalStream: function(_) {
        var v = null, g = "string";
        try {
          if (!_) throw new Error("No output type specified.");
          var S = (g = _.toLowerCase()) === "string" || g === "text";
          g !== "binarystring" && g !== "text" || (g = "string"), v = this._decompressWorker();
          var w = !this._dataBinary;
          w && !S && (v = v.pipe(new u.Utf8EncodeWorker())), !w && S && (v = v.pipe(new u.Utf8DecodeWorker()));
        } catch (x) {
          (v = new h("error")).error(x);
        }
        return new l(v, g, "");
      }, async: function(_, v) {
        return this.internalStream(_).accumulate(v);
      }, nodeStream: function(_, v) {
        return this.internalStream(_ || "nodebuffer").toNodejsStream(v);
      }, _compressWorker: function(_, v) {
        if (this._data instanceof d && this._data.compression.magic === _.magic) return this._data.getCompressedWorker();
        var g = this._decompressWorker();
        return this._dataBinary || (g = g.pipe(new u.Utf8EncodeWorker())), d.createWorkerFrom(g, _, v);
      }, _decompressWorker: function() {
        return this._data instanceof d ? this._data.getContentWorker() : this._data instanceof h ? this._data : new c(this._data);
      } };
      for (var m = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, y = 0; y < m.length; y++) a.prototype[m[y]] = p;
      r.exports = a;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(i, r, o) {
      (function(a) {
        var l, c, u = a.MutationObserver || a.WebKitMutationObserver;
        if (u) {
          var d = 0, h = new u(_), m = a.document.createTextNode("");
          h.observe(m, { characterData: !0 }), l = function() {
            m.data = d = ++d % 2;
          };
        } else if (a.setImmediate || a.MessageChannel === void 0) l = "document" in a && "onreadystatechange" in a.document.createElement("script") ? function() {
          var v = a.document.createElement("script");
          v.onreadystatechange = function() {
            _(), v.onreadystatechange = null, v.parentNode.removeChild(v), v = null;
          }, a.document.documentElement.appendChild(v);
        } : function() {
          setTimeout(_, 0);
        };
        else {
          var p = new a.MessageChannel();
          p.port1.onmessage = _, l = function() {
            p.port2.postMessage(0);
          };
        }
        var y = [];
        function _() {
          var v, g;
          c = !0;
          for (var S = y.length; S; ) {
            for (g = y, y = [], v = -1; ++v < S; ) g[v]();
            S = y.length;
          }
          c = !1;
        }
        r.exports = function(v) {
          y.push(v) !== 1 || c || l();
        };
      }).call(this, typeof mc < "u" ? mc : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(i, r, o) {
      var a = i("immediate");
      function l() {
      }
      var c = {}, u = ["REJECTED"], d = ["FULFILLED"], h = ["PENDING"];
      function m(S) {
        if (typeof S != "function") throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, S !== l && v(this, S);
      }
      function p(S, w, x) {
        this.promise = S, typeof w == "function" && (this.onFulfilled = w, this.callFulfilled = this.otherCallFulfilled), typeof x == "function" && (this.onRejected = x, this.callRejected = this.otherCallRejected);
      }
      function y(S, w, x) {
        a(function() {
          var C;
          try {
            C = w(x);
          } catch (E) {
            return c.reject(S, E);
          }
          C === S ? c.reject(S, new TypeError("Cannot resolve promise with itself")) : c.resolve(S, C);
        });
      }
      function _(S) {
        var w = S && S.then;
        if (S && (typeof S == "object" || typeof S == "function") && typeof w == "function") return function() {
          w.apply(S, arguments);
        };
      }
      function v(S, w) {
        var x = !1;
        function C(T) {
          x || (x = !0, c.reject(S, T));
        }
        function E(T) {
          x || (x = !0, c.resolve(S, T));
        }
        var P = g(function() {
          w(E, C);
        });
        P.status === "error" && C(P.value);
      }
      function g(S, w) {
        var x = {};
        try {
          x.value = S(w), x.status = "success";
        } catch (C) {
          x.status = "error", x.value = C;
        }
        return x;
      }
      (r.exports = m).prototype.finally = function(S) {
        if (typeof S != "function") return this;
        var w = this.constructor;
        return this.then(function(x) {
          return w.resolve(S()).then(function() {
            return x;
          });
        }, function(x) {
          return w.resolve(S()).then(function() {
            throw x;
          });
        });
      }, m.prototype.catch = function(S) {
        return this.then(null, S);
      }, m.prototype.then = function(S, w) {
        if (typeof S != "function" && this.state === d || typeof w != "function" && this.state === u) return this;
        var x = new this.constructor(l);
        return this.state !== h ? y(x, this.state === d ? S : w, this.outcome) : this.queue.push(new p(x, S, w)), x;
      }, p.prototype.callFulfilled = function(S) {
        c.resolve(this.promise, S);
      }, p.prototype.otherCallFulfilled = function(S) {
        y(this.promise, this.onFulfilled, S);
      }, p.prototype.callRejected = function(S) {
        c.reject(this.promise, S);
      }, p.prototype.otherCallRejected = function(S) {
        y(this.promise, this.onRejected, S);
      }, c.resolve = function(S, w) {
        var x = g(_, w);
        if (x.status === "error") return c.reject(S, x.value);
        var C = x.value;
        if (C) v(S, C);
        else {
          S.state = d, S.outcome = w;
          for (var E = -1, P = S.queue.length; ++E < P; ) S.queue[E].callFulfilled(w);
        }
        return S;
      }, c.reject = function(S, w) {
        S.state = u, S.outcome = w;
        for (var x = -1, C = S.queue.length; ++x < C; ) S.queue[x].callRejected(w);
        return S;
      }, m.resolve = function(S) {
        return S instanceof this ? S : c.resolve(new this(l), S);
      }, m.reject = function(S) {
        var w = new this(l);
        return c.reject(w, S);
      }, m.all = function(S) {
        var w = this;
        if (Object.prototype.toString.call(S) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = S.length, C = !1;
        if (!x) return this.resolve([]);
        for (var E = new Array(x), P = 0, T = -1, b = new this(l); ++T < x; ) M(S[T], T);
        return b;
        function M(L, N) {
          w.resolve(L).then(function(D) {
            E[N] = D, ++P !== x || C || (C = !0, c.resolve(b, E));
          }, function(D) {
            C || (C = !0, c.reject(b, D));
          });
        }
      }, m.race = function(S) {
        var w = this;
        if (Object.prototype.toString.call(S) !== "[object Array]") return this.reject(new TypeError("must be an array"));
        var x = S.length, C = !1;
        if (!x) return this.resolve([]);
        for (var E = -1, P = new this(l); ++E < x; ) T = S[E], w.resolve(T).then(function(b) {
          C || (C = !0, c.resolve(P, b));
        }, function(b) {
          C || (C = !0, c.reject(P, b));
        });
        var T;
        return P;
      };
    }, { immediate: 36 }], 38: [function(i, r, o) {
      var a = {};
      (0, i("./lib/utils/common").assign)(a, i("./lib/deflate"), i("./lib/inflate"), i("./lib/zlib/constants")), r.exports = a;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(i, r, o) {
      var a = i("./zlib/deflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/messages"), d = i("./zlib/zstream"), h = Object.prototype.toString, m = 0, p = -1, y = 0, _ = 8;
      function v(S) {
        if (!(this instanceof v)) return new v(S);
        this.options = l.assign({ level: p, method: _, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: y, to: "" }, S || {});
        var w = this.options;
        w.raw && 0 < w.windowBits ? w.windowBits = -w.windowBits : w.gzip && 0 < w.windowBits && w.windowBits < 16 && (w.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var x = a.deflateInit2(this.strm, w.level, w.method, w.windowBits, w.memLevel, w.strategy);
        if (x !== m) throw new Error(u[x]);
        if (w.header && a.deflateSetHeader(this.strm, w.header), w.dictionary) {
          var C;
          if (C = typeof w.dictionary == "string" ? c.string2buf(w.dictionary) : h.call(w.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(w.dictionary) : w.dictionary, (x = a.deflateSetDictionary(this.strm, C)) !== m) throw new Error(u[x]);
          this._dict_set = !0;
        }
      }
      function g(S, w) {
        var x = new v(w);
        if (x.push(S, !0), x.err) throw x.msg || u[x.err];
        return x.result;
      }
      v.prototype.push = function(S, w) {
        var x, C, E = this.strm, P = this.options.chunkSize;
        if (this.ended) return !1;
        C = w === ~~w ? w : w === !0 ? 4 : 0, typeof S == "string" ? E.input = c.string2buf(S) : h.call(S) === "[object ArrayBuffer]" ? E.input = new Uint8Array(S) : E.input = S, E.next_in = 0, E.avail_in = E.input.length;
        do {
          if (E.avail_out === 0 && (E.output = new l.Buf8(P), E.next_out = 0, E.avail_out = P), (x = a.deflate(E, C)) !== 1 && x !== m) return this.onEnd(x), !(this.ended = !0);
          E.avail_out !== 0 && (E.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(c.buf2binstring(l.shrinkBuf(E.output, E.next_out))) : this.onData(l.shrinkBuf(E.output, E.next_out)));
        } while ((0 < E.avail_in || E.avail_out === 0) && x !== 1);
        return C === 4 ? (x = a.deflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === m) : C !== 2 || (this.onEnd(m), !(E.avail_out = 0));
      }, v.prototype.onData = function(S) {
        this.chunks.push(S);
      }, v.prototype.onEnd = function(S) {
        S === m && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = S, this.msg = this.strm.msg;
      }, o.Deflate = v, o.deflate = g, o.deflateRaw = function(S, w) {
        return (w = w || {}).raw = !0, g(S, w);
      }, o.gzip = function(S, w) {
        return (w = w || {}).gzip = !0, g(S, w);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(i, r, o) {
      var a = i("./zlib/inflate"), l = i("./utils/common"), c = i("./utils/strings"), u = i("./zlib/constants"), d = i("./zlib/messages"), h = i("./zlib/zstream"), m = i("./zlib/gzheader"), p = Object.prototype.toString;
      function y(v) {
        if (!(this instanceof y)) return new y(v);
        this.options = l.assign({ chunkSize: 16384, windowBits: 0, to: "" }, v || {});
        var g = this.options;
        g.raw && 0 <= g.windowBits && g.windowBits < 16 && (g.windowBits = -g.windowBits, g.windowBits === 0 && (g.windowBits = -15)), !(0 <= g.windowBits && g.windowBits < 16) || v && v.windowBits || (g.windowBits += 32), 15 < g.windowBits && g.windowBits < 48 && !(15 & g.windowBits) && (g.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var S = a.inflateInit2(this.strm, g.windowBits);
        if (S !== u.Z_OK) throw new Error(d[S]);
        this.header = new m(), a.inflateGetHeader(this.strm, this.header);
      }
      function _(v, g) {
        var S = new y(g);
        if (S.push(v, !0), S.err) throw S.msg || d[S.err];
        return S.result;
      }
      y.prototype.push = function(v, g) {
        var S, w, x, C, E, P, T = this.strm, b = this.options.chunkSize, M = this.options.dictionary, L = !1;
        if (this.ended) return !1;
        w = g === ~~g ? g : g === !0 ? u.Z_FINISH : u.Z_NO_FLUSH, typeof v == "string" ? T.input = c.binstring2buf(v) : p.call(v) === "[object ArrayBuffer]" ? T.input = new Uint8Array(v) : T.input = v, T.next_in = 0, T.avail_in = T.input.length;
        do {
          if (T.avail_out === 0 && (T.output = new l.Buf8(b), T.next_out = 0, T.avail_out = b), (S = a.inflate(T, u.Z_NO_FLUSH)) === u.Z_NEED_DICT && M && (P = typeof M == "string" ? c.string2buf(M) : p.call(M) === "[object ArrayBuffer]" ? new Uint8Array(M) : M, S = a.inflateSetDictionary(this.strm, P)), S === u.Z_BUF_ERROR && L === !0 && (S = u.Z_OK, L = !1), S !== u.Z_STREAM_END && S !== u.Z_OK) return this.onEnd(S), !(this.ended = !0);
          T.next_out && (T.avail_out !== 0 && S !== u.Z_STREAM_END && (T.avail_in !== 0 || w !== u.Z_FINISH && w !== u.Z_SYNC_FLUSH) || (this.options.to === "string" ? (x = c.utf8border(T.output, T.next_out), C = T.next_out - x, E = c.buf2string(T.output, x), T.next_out = C, T.avail_out = b - C, C && l.arraySet(T.output, T.output, x, C, 0), this.onData(E)) : this.onData(l.shrinkBuf(T.output, T.next_out)))), T.avail_in === 0 && T.avail_out === 0 && (L = !0);
        } while ((0 < T.avail_in || T.avail_out === 0) && S !== u.Z_STREAM_END);
        return S === u.Z_STREAM_END && (w = u.Z_FINISH), w === u.Z_FINISH ? (S = a.inflateEnd(this.strm), this.onEnd(S), this.ended = !0, S === u.Z_OK) : w !== u.Z_SYNC_FLUSH || (this.onEnd(u.Z_OK), !(T.avail_out = 0));
      }, y.prototype.onData = function(v) {
        this.chunks.push(v);
      }, y.prototype.onEnd = function(v) {
        v === u.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = l.flattenChunks(this.chunks)), this.chunks = [], this.err = v, this.msg = this.strm.msg;
      }, o.Inflate = y, o.inflate = _, o.inflateRaw = function(v, g) {
        return (g = g || {}).raw = !0, _(v, g);
      }, o.ungzip = _;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(i, r, o) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      o.assign = function(u) {
        for (var d = Array.prototype.slice.call(arguments, 1); d.length; ) {
          var h = d.shift();
          if (h) {
            if (typeof h != "object") throw new TypeError(h + "must be non-object");
            for (var m in h) h.hasOwnProperty(m) && (u[m] = h[m]);
          }
        }
        return u;
      }, o.shrinkBuf = function(u, d) {
        return u.length === d ? u : u.subarray ? u.subarray(0, d) : (u.length = d, u);
      };
      var l = { arraySet: function(u, d, h, m, p) {
        if (d.subarray && u.subarray) u.set(d.subarray(h, h + m), p);
        else for (var y = 0; y < m; y++) u[p + y] = d[h + y];
      }, flattenChunks: function(u) {
        var d, h, m, p, y, _;
        for (d = m = 0, h = u.length; d < h; d++) m += u[d].length;
        for (_ = new Uint8Array(m), d = p = 0, h = u.length; d < h; d++) y = u[d], _.set(y, p), p += y.length;
        return _;
      } }, c = { arraySet: function(u, d, h, m, p) {
        for (var y = 0; y < m; y++) u[p + y] = d[h + y];
      }, flattenChunks: function(u) {
        return [].concat.apply([], u);
      } };
      o.setTyped = function(u) {
        u ? (o.Buf8 = Uint8Array, o.Buf16 = Uint16Array, o.Buf32 = Int32Array, o.assign(o, l)) : (o.Buf8 = Array, o.Buf16 = Array, o.Buf32 = Array, o.assign(o, c));
      }, o.setTyped(a);
    }, {}], 42: [function(i, r, o) {
      var a = i("./common"), l = !0, c = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        l = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        c = !1;
      }
      for (var u = new a.Buf8(256), d = 0; d < 256; d++) u[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      function h(m, p) {
        if (p < 65537 && (m.subarray && c || !m.subarray && l)) return String.fromCharCode.apply(null, a.shrinkBuf(m, p));
        for (var y = "", _ = 0; _ < p; _++) y += String.fromCharCode(m[_]);
        return y;
      }
      u[254] = u[254] = 1, o.string2buf = function(m) {
        var p, y, _, v, g, S = m.length, w = 0;
        for (v = 0; v < S; v++) (64512 & (y = m.charCodeAt(v))) == 55296 && v + 1 < S && (64512 & (_ = m.charCodeAt(v + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (_ - 56320), v++), w += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
        for (p = new a.Buf8(w), v = g = 0; g < w; v++) (64512 & (y = m.charCodeAt(v))) == 55296 && v + 1 < S && (64512 & (_ = m.charCodeAt(v + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (_ - 56320), v++), y < 128 ? p[g++] = y : (y < 2048 ? p[g++] = 192 | y >>> 6 : (y < 65536 ? p[g++] = 224 | y >>> 12 : (p[g++] = 240 | y >>> 18, p[g++] = 128 | y >>> 12 & 63), p[g++] = 128 | y >>> 6 & 63), p[g++] = 128 | 63 & y);
        return p;
      }, o.buf2binstring = function(m) {
        return h(m, m.length);
      }, o.binstring2buf = function(m) {
        for (var p = new a.Buf8(m.length), y = 0, _ = p.length; y < _; y++) p[y] = m.charCodeAt(y);
        return p;
      }, o.buf2string = function(m, p) {
        var y, _, v, g, S = p || m.length, w = new Array(2 * S);
        for (y = _ = 0; y < S; ) if ((v = m[y++]) < 128) w[_++] = v;
        else if (4 < (g = u[v])) w[_++] = 65533, y += g - 1;
        else {
          for (v &= g === 2 ? 31 : g === 3 ? 15 : 7; 1 < g && y < S; ) v = v << 6 | 63 & m[y++], g--;
          1 < g ? w[_++] = 65533 : v < 65536 ? w[_++] = v : (v -= 65536, w[_++] = 55296 | v >> 10 & 1023, w[_++] = 56320 | 1023 & v);
        }
        return h(w, _);
      }, o.utf8border = function(m, p) {
        var y;
        for ((p = p || m.length) > m.length && (p = m.length), y = p - 1; 0 <= y && (192 & m[y]) == 128; ) y--;
        return y < 0 || y === 0 ? p : y + u[m[y]] > p ? y : p;
      };
    }, { "./common": 41 }], 43: [function(i, r, o) {
      r.exports = function(a, l, c, u) {
        for (var d = 65535 & a | 0, h = a >>> 16 & 65535 | 0, m = 0; c !== 0; ) {
          for (c -= m = 2e3 < c ? 2e3 : c; h = h + (d = d + l[u++] | 0) | 0, --m; ) ;
          d %= 65521, h %= 65521;
        }
        return d | h << 16 | 0;
      };
    }, {}], 44: [function(i, r, o) {
      r.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(i, r, o) {
      var a = function() {
        for (var l, c = [], u = 0; u < 256; u++) {
          l = u;
          for (var d = 0; d < 8; d++) l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          c[u] = l;
        }
        return c;
      }();
      r.exports = function(l, c, u, d) {
        var h = a, m = d + u;
        l ^= -1;
        for (var p = d; p < m; p++) l = l >>> 8 ^ h[255 & (l ^ c[p])];
        return -1 ^ l;
      };
    }, {}], 46: [function(i, r, o) {
      var a, l = i("../utils/common"), c = i("./trees"), u = i("./adler32"), d = i("./crc32"), h = i("./messages"), m = 0, p = 4, y = 0, _ = -2, v = -1, g = 4, S = 2, w = 8, x = 9, C = 286, E = 30, P = 19, T = 2 * C + 1, b = 15, M = 3, L = 258, N = L + M + 1, D = 42, O = 113, A = 1, G = 2, he = 3, ee = 4;
      function le(R, ie) {
        return R.msg = h[ie], ie;
      }
      function oe(R) {
        return (R << 1) - (4 < R ? 9 : 0);
      }
      function Y(R) {
        for (var ie = R.length; 0 <= --ie; ) R[ie] = 0;
      }
      function j(R) {
        var ie = R.state, J = ie.pending;
        J > R.avail_out && (J = R.avail_out), J !== 0 && (l.arraySet(R.output, ie.pending_buf, ie.pending_out, J, R.next_out), R.next_out += J, ie.pending_out += J, R.total_out += J, R.avail_out -= J, ie.pending -= J, ie.pending === 0 && (ie.pending_out = 0));
      }
      function q(R, ie) {
        c._tr_flush_block(R, 0 <= R.block_start ? R.block_start : -1, R.strstart - R.block_start, ie), R.block_start = R.strstart, j(R.strm);
      }
      function te(R, ie) {
        R.pending_buf[R.pending++] = ie;
      }
      function ne(R, ie) {
        R.pending_buf[R.pending++] = ie >>> 8 & 255, R.pending_buf[R.pending++] = 255 & ie;
      }
      function de(R, ie) {
        var J, B, $ = R.max_chain_length, se = R.strstart, U = R.prev_length, z = R.nice_match, K = R.strstart > R.w_size - N ? R.strstart - (R.w_size - N) : 0, ue = R.window, me = R.w_mask, ge = R.prev, Me = R.strstart + L, Te = ue[se + U - 1], Ae = ue[se + U];
        R.prev_length >= R.good_match && ($ >>= 2), z > R.lookahead && (z = R.lookahead);
        do
          if (ue[(J = ie) + U] === Ae && ue[J + U - 1] === Te && ue[J] === ue[se] && ue[++J] === ue[se + 1]) {
            se += 2, J++;
            do
              ;
            while (ue[++se] === ue[++J] && ue[++se] === ue[++J] && ue[++se] === ue[++J] && ue[++se] === ue[++J] && ue[++se] === ue[++J] && ue[++se] === ue[++J] && ue[++se] === ue[++J] && ue[++se] === ue[++J] && se < Me);
            if (B = L - (Me - se), se = Me - L, U < B) {
              if (R.match_start = ie, z <= (U = B)) break;
              Te = ue[se + U - 1], Ae = ue[se + U];
            }
          }
        while ((ie = ge[ie & me]) > K && --$ != 0);
        return U <= R.lookahead ? U : R.lookahead;
      }
      function H(R) {
        var ie, J, B, $, se, U, z, K, ue, me, ge = R.w_size;
        do {
          if ($ = R.window_size - R.lookahead - R.strstart, R.strstart >= ge + (ge - N)) {
            for (l.arraySet(R.window, R.window, ge, ge, 0), R.match_start -= ge, R.strstart -= ge, R.block_start -= ge, ie = J = R.hash_size; B = R.head[--ie], R.head[ie] = ge <= B ? B - ge : 0, --J; ) ;
            for (ie = J = ge; B = R.prev[--ie], R.prev[ie] = ge <= B ? B - ge : 0, --J; ) ;
            $ += ge;
          }
          if (R.strm.avail_in === 0) break;
          if (U = R.strm, z = R.window, K = R.strstart + R.lookahead, ue = $, me = void 0, me = U.avail_in, ue < me && (me = ue), J = me === 0 ? 0 : (U.avail_in -= me, l.arraySet(z, U.input, U.next_in, me, K), U.state.wrap === 1 ? U.adler = u(U.adler, z, me, K) : U.state.wrap === 2 && (U.adler = d(U.adler, z, me, K)), U.next_in += me, U.total_in += me, me), R.lookahead += J, R.lookahead + R.insert >= M) for (se = R.strstart - R.insert, R.ins_h = R.window[se], R.ins_h = (R.ins_h << R.hash_shift ^ R.window[se + 1]) & R.hash_mask; R.insert && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[se + M - 1]) & R.hash_mask, R.prev[se & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = se, se++, R.insert--, !(R.lookahead + R.insert < M)); ) ;
        } while (R.lookahead < N && R.strm.avail_in !== 0);
      }
      function X(R, ie) {
        for (var J, B; ; ) {
          if (R.lookahead < N) {
            if (H(R), R.lookahead < N && ie === m) return A;
            if (R.lookahead === 0) break;
          }
          if (J = 0, R.lookahead >= M && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + M - 1]) & R.hash_mask, J = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart), J !== 0 && R.strstart - J <= R.w_size - N && (R.match_length = de(R, J)), R.match_length >= M) if (B = c._tr_tally(R, R.strstart - R.match_start, R.match_length - M), R.lookahead -= R.match_length, R.match_length <= R.max_lazy_match && R.lookahead >= M) {
            for (R.match_length--; R.strstart++, R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + M - 1]) & R.hash_mask, J = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart, --R.match_length != 0; ) ;
            R.strstart++;
          } else R.strstart += R.match_length, R.match_length = 0, R.ins_h = R.window[R.strstart], R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + 1]) & R.hash_mask;
          else B = c._tr_tally(R, 0, R.window[R.strstart]), R.lookahead--, R.strstart++;
          if (B && (q(R, !1), R.strm.avail_out === 0)) return A;
        }
        return R.insert = R.strstart < M - 1 ? R.strstart : M - 1, ie === p ? (q(R, !0), R.strm.avail_out === 0 ? he : ee) : R.last_lit && (q(R, !1), R.strm.avail_out === 0) ? A : G;
      }
      function V(R, ie) {
        for (var J, B, $; ; ) {
          if (R.lookahead < N) {
            if (H(R), R.lookahead < N && ie === m) return A;
            if (R.lookahead === 0) break;
          }
          if (J = 0, R.lookahead >= M && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + M - 1]) & R.hash_mask, J = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart), R.prev_length = R.match_length, R.prev_match = R.match_start, R.match_length = M - 1, J !== 0 && R.prev_length < R.max_lazy_match && R.strstart - J <= R.w_size - N && (R.match_length = de(R, J), R.match_length <= 5 && (R.strategy === 1 || R.match_length === M && 4096 < R.strstart - R.match_start) && (R.match_length = M - 1)), R.prev_length >= M && R.match_length <= R.prev_length) {
            for ($ = R.strstart + R.lookahead - M, B = c._tr_tally(R, R.strstart - 1 - R.prev_match, R.prev_length - M), R.lookahead -= R.prev_length - 1, R.prev_length -= 2; ++R.strstart <= $ && (R.ins_h = (R.ins_h << R.hash_shift ^ R.window[R.strstart + M - 1]) & R.hash_mask, J = R.prev[R.strstart & R.w_mask] = R.head[R.ins_h], R.head[R.ins_h] = R.strstart), --R.prev_length != 0; ) ;
            if (R.match_available = 0, R.match_length = M - 1, R.strstart++, B && (q(R, !1), R.strm.avail_out === 0)) return A;
          } else if (R.match_available) {
            if ((B = c._tr_tally(R, 0, R.window[R.strstart - 1])) && q(R, !1), R.strstart++, R.lookahead--, R.strm.avail_out === 0) return A;
          } else R.match_available = 1, R.strstart++, R.lookahead--;
        }
        return R.match_available && (B = c._tr_tally(R, 0, R.window[R.strstart - 1]), R.match_available = 0), R.insert = R.strstart < M - 1 ? R.strstart : M - 1, ie === p ? (q(R, !0), R.strm.avail_out === 0 ? he : ee) : R.last_lit && (q(R, !1), R.strm.avail_out === 0) ? A : G;
      }
      function I(R, ie, J, B, $) {
        this.good_length = R, this.max_lazy = ie, this.nice_length = J, this.max_chain = B, this.func = $;
      }
      function F() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = w, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new l.Buf16(2 * T), this.dyn_dtree = new l.Buf16(2 * (2 * E + 1)), this.bl_tree = new l.Buf16(2 * (2 * P + 1)), Y(this.dyn_ltree), Y(this.dyn_dtree), Y(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new l.Buf16(b + 1), this.heap = new l.Buf16(2 * C + 1), Y(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new l.Buf16(2 * C + 1), Y(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function k(R) {
        var ie;
        return R && R.state ? (R.total_in = R.total_out = 0, R.data_type = S, (ie = R.state).pending = 0, ie.pending_out = 0, ie.wrap < 0 && (ie.wrap = -ie.wrap), ie.status = ie.wrap ? D : O, R.adler = ie.wrap === 2 ? 0 : 1, ie.last_flush = m, c._tr_init(ie), y) : le(R, _);
      }
      function Q(R) {
        var ie = k(R);
        return ie === y && function(J) {
          J.window_size = 2 * J.w_size, Y(J.head), J.max_lazy_match = a[J.level].max_lazy, J.good_match = a[J.level].good_length, J.nice_match = a[J.level].nice_length, J.max_chain_length = a[J.level].max_chain, J.strstart = 0, J.block_start = 0, J.lookahead = 0, J.insert = 0, J.match_length = J.prev_length = M - 1, J.match_available = 0, J.ins_h = 0;
        }(R.state), ie;
      }
      function Z(R, ie, J, B, $, se) {
        if (!R) return _;
        var U = 1;
        if (ie === v && (ie = 6), B < 0 ? (U = 0, B = -B) : 15 < B && (U = 2, B -= 16), $ < 1 || x < $ || J !== w || B < 8 || 15 < B || ie < 0 || 9 < ie || se < 0 || g < se) return le(R, _);
        B === 8 && (B = 9);
        var z = new F();
        return (R.state = z).strm = R, z.wrap = U, z.gzhead = null, z.w_bits = B, z.w_size = 1 << z.w_bits, z.w_mask = z.w_size - 1, z.hash_bits = $ + 7, z.hash_size = 1 << z.hash_bits, z.hash_mask = z.hash_size - 1, z.hash_shift = ~~((z.hash_bits + M - 1) / M), z.window = new l.Buf8(2 * z.w_size), z.head = new l.Buf16(z.hash_size), z.prev = new l.Buf16(z.w_size), z.lit_bufsize = 1 << $ + 6, z.pending_buf_size = 4 * z.lit_bufsize, z.pending_buf = new l.Buf8(z.pending_buf_size), z.d_buf = 1 * z.lit_bufsize, z.l_buf = 3 * z.lit_bufsize, z.level = ie, z.strategy = se, z.method = J, Q(R);
      }
      a = [new I(0, 0, 0, 0, function(R, ie) {
        var J = 65535;
        for (J > R.pending_buf_size - 5 && (J = R.pending_buf_size - 5); ; ) {
          if (R.lookahead <= 1) {
            if (H(R), R.lookahead === 0 && ie === m) return A;
            if (R.lookahead === 0) break;
          }
          R.strstart += R.lookahead, R.lookahead = 0;
          var B = R.block_start + J;
          if ((R.strstart === 0 || R.strstart >= B) && (R.lookahead = R.strstart - B, R.strstart = B, q(R, !1), R.strm.avail_out === 0) || R.strstart - R.block_start >= R.w_size - N && (q(R, !1), R.strm.avail_out === 0)) return A;
        }
        return R.insert = 0, ie === p ? (q(R, !0), R.strm.avail_out === 0 ? he : ee) : (R.strstart > R.block_start && (q(R, !1), R.strm.avail_out), A);
      }), new I(4, 4, 8, 4, X), new I(4, 5, 16, 8, X), new I(4, 6, 32, 32, X), new I(4, 4, 16, 16, V), new I(8, 16, 32, 32, V), new I(8, 16, 128, 128, V), new I(8, 32, 128, 256, V), new I(32, 128, 258, 1024, V), new I(32, 258, 258, 4096, V)], o.deflateInit = function(R, ie) {
        return Z(R, ie, w, 15, 8, 0);
      }, o.deflateInit2 = Z, o.deflateReset = Q, o.deflateResetKeep = k, o.deflateSetHeader = function(R, ie) {
        return R && R.state ? R.state.wrap !== 2 ? _ : (R.state.gzhead = ie, y) : _;
      }, o.deflate = function(R, ie) {
        var J, B, $, se;
        if (!R || !R.state || 5 < ie || ie < 0) return R ? le(R, _) : _;
        if (B = R.state, !R.output || !R.input && R.avail_in !== 0 || B.status === 666 && ie !== p) return le(R, R.avail_out === 0 ? -5 : _);
        if (B.strm = R, J = B.last_flush, B.last_flush = ie, B.status === D) if (B.wrap === 2) R.adler = 0, te(B, 31), te(B, 139), te(B, 8), B.gzhead ? (te(B, (B.gzhead.text ? 1 : 0) + (B.gzhead.hcrc ? 2 : 0) + (B.gzhead.extra ? 4 : 0) + (B.gzhead.name ? 8 : 0) + (B.gzhead.comment ? 16 : 0)), te(B, 255 & B.gzhead.time), te(B, B.gzhead.time >> 8 & 255), te(B, B.gzhead.time >> 16 & 255), te(B, B.gzhead.time >> 24 & 255), te(B, B.level === 9 ? 2 : 2 <= B.strategy || B.level < 2 ? 4 : 0), te(B, 255 & B.gzhead.os), B.gzhead.extra && B.gzhead.extra.length && (te(B, 255 & B.gzhead.extra.length), te(B, B.gzhead.extra.length >> 8 & 255)), B.gzhead.hcrc && (R.adler = d(R.adler, B.pending_buf, B.pending, 0)), B.gzindex = 0, B.status = 69) : (te(B, 0), te(B, 0), te(B, 0), te(B, 0), te(B, 0), te(B, B.level === 9 ? 2 : 2 <= B.strategy || B.level < 2 ? 4 : 0), te(B, 3), B.status = O);
        else {
          var U = w + (B.w_bits - 8 << 4) << 8;
          U |= (2 <= B.strategy || B.level < 2 ? 0 : B.level < 6 ? 1 : B.level === 6 ? 2 : 3) << 6, B.strstart !== 0 && (U |= 32), U += 31 - U % 31, B.status = O, ne(B, U), B.strstart !== 0 && (ne(B, R.adler >>> 16), ne(B, 65535 & R.adler)), R.adler = 1;
        }
        if (B.status === 69) if (B.gzhead.extra) {
          for ($ = B.pending; B.gzindex < (65535 & B.gzhead.extra.length) && (B.pending !== B.pending_buf_size || (B.gzhead.hcrc && B.pending > $ && (R.adler = d(R.adler, B.pending_buf, B.pending - $, $)), j(R), $ = B.pending, B.pending !== B.pending_buf_size)); ) te(B, 255 & B.gzhead.extra[B.gzindex]), B.gzindex++;
          B.gzhead.hcrc && B.pending > $ && (R.adler = d(R.adler, B.pending_buf, B.pending - $, $)), B.gzindex === B.gzhead.extra.length && (B.gzindex = 0, B.status = 73);
        } else B.status = 73;
        if (B.status === 73) if (B.gzhead.name) {
          $ = B.pending;
          do {
            if (B.pending === B.pending_buf_size && (B.gzhead.hcrc && B.pending > $ && (R.adler = d(R.adler, B.pending_buf, B.pending - $, $)), j(R), $ = B.pending, B.pending === B.pending_buf_size)) {
              se = 1;
              break;
            }
            se = B.gzindex < B.gzhead.name.length ? 255 & B.gzhead.name.charCodeAt(B.gzindex++) : 0, te(B, se);
          } while (se !== 0);
          B.gzhead.hcrc && B.pending > $ && (R.adler = d(R.adler, B.pending_buf, B.pending - $, $)), se === 0 && (B.gzindex = 0, B.status = 91);
        } else B.status = 91;
        if (B.status === 91) if (B.gzhead.comment) {
          $ = B.pending;
          do {
            if (B.pending === B.pending_buf_size && (B.gzhead.hcrc && B.pending > $ && (R.adler = d(R.adler, B.pending_buf, B.pending - $, $)), j(R), $ = B.pending, B.pending === B.pending_buf_size)) {
              se = 1;
              break;
            }
            se = B.gzindex < B.gzhead.comment.length ? 255 & B.gzhead.comment.charCodeAt(B.gzindex++) : 0, te(B, se);
          } while (se !== 0);
          B.gzhead.hcrc && B.pending > $ && (R.adler = d(R.adler, B.pending_buf, B.pending - $, $)), se === 0 && (B.status = 103);
        } else B.status = 103;
        if (B.status === 103 && (B.gzhead.hcrc ? (B.pending + 2 > B.pending_buf_size && j(R), B.pending + 2 <= B.pending_buf_size && (te(B, 255 & R.adler), te(B, R.adler >> 8 & 255), R.adler = 0, B.status = O)) : B.status = O), B.pending !== 0) {
          if (j(R), R.avail_out === 0) return B.last_flush = -1, y;
        } else if (R.avail_in === 0 && oe(ie) <= oe(J) && ie !== p) return le(R, -5);
        if (B.status === 666 && R.avail_in !== 0) return le(R, -5);
        if (R.avail_in !== 0 || B.lookahead !== 0 || ie !== m && B.status !== 666) {
          var z = B.strategy === 2 ? function(K, ue) {
            for (var me; ; ) {
              if (K.lookahead === 0 && (H(K), K.lookahead === 0)) {
                if (ue === m) return A;
                break;
              }
              if (K.match_length = 0, me = c._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++, me && (q(K, !1), K.strm.avail_out === 0)) return A;
            }
            return K.insert = 0, ue === p ? (q(K, !0), K.strm.avail_out === 0 ? he : ee) : K.last_lit && (q(K, !1), K.strm.avail_out === 0) ? A : G;
          }(B, ie) : B.strategy === 3 ? function(K, ue) {
            for (var me, ge, Me, Te, Ae = K.window; ; ) {
              if (K.lookahead <= L) {
                if (H(K), K.lookahead <= L && ue === m) return A;
                if (K.lookahead === 0) break;
              }
              if (K.match_length = 0, K.lookahead >= M && 0 < K.strstart && (ge = Ae[Me = K.strstart - 1]) === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me]) {
                Te = K.strstart + L;
                do
                  ;
                while (ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && ge === Ae[++Me] && Me < Te);
                K.match_length = L - (Te - Me), K.match_length > K.lookahead && (K.match_length = K.lookahead);
              }
              if (K.match_length >= M ? (me = c._tr_tally(K, 1, K.match_length - M), K.lookahead -= K.match_length, K.strstart += K.match_length, K.match_length = 0) : (me = c._tr_tally(K, 0, K.window[K.strstart]), K.lookahead--, K.strstart++), me && (q(K, !1), K.strm.avail_out === 0)) return A;
            }
            return K.insert = 0, ue === p ? (q(K, !0), K.strm.avail_out === 0 ? he : ee) : K.last_lit && (q(K, !1), K.strm.avail_out === 0) ? A : G;
          }(B, ie) : a[B.level].func(B, ie);
          if (z !== he && z !== ee || (B.status = 666), z === A || z === he) return R.avail_out === 0 && (B.last_flush = -1), y;
          if (z === G && (ie === 1 ? c._tr_align(B) : ie !== 5 && (c._tr_stored_block(B, 0, 0, !1), ie === 3 && (Y(B.head), B.lookahead === 0 && (B.strstart = 0, B.block_start = 0, B.insert = 0))), j(R), R.avail_out === 0)) return B.last_flush = -1, y;
        }
        return ie !== p ? y : B.wrap <= 0 ? 1 : (B.wrap === 2 ? (te(B, 255 & R.adler), te(B, R.adler >> 8 & 255), te(B, R.adler >> 16 & 255), te(B, R.adler >> 24 & 255), te(B, 255 & R.total_in), te(B, R.total_in >> 8 & 255), te(B, R.total_in >> 16 & 255), te(B, R.total_in >> 24 & 255)) : (ne(B, R.adler >>> 16), ne(B, 65535 & R.adler)), j(R), 0 < B.wrap && (B.wrap = -B.wrap), B.pending !== 0 ? y : 1);
      }, o.deflateEnd = function(R) {
        var ie;
        return R && R.state ? (ie = R.state.status) !== D && ie !== 69 && ie !== 73 && ie !== 91 && ie !== 103 && ie !== O && ie !== 666 ? le(R, _) : (R.state = null, ie === O ? le(R, -3) : y) : _;
      }, o.deflateSetDictionary = function(R, ie) {
        var J, B, $, se, U, z, K, ue, me = ie.length;
        if (!R || !R.state || (se = (J = R.state).wrap) === 2 || se === 1 && J.status !== D || J.lookahead) return _;
        for (se === 1 && (R.adler = u(R.adler, ie, me, 0)), J.wrap = 0, me >= J.w_size && (se === 0 && (Y(J.head), J.strstart = 0, J.block_start = 0, J.insert = 0), ue = new l.Buf8(J.w_size), l.arraySet(ue, ie, me - J.w_size, J.w_size, 0), ie = ue, me = J.w_size), U = R.avail_in, z = R.next_in, K = R.input, R.avail_in = me, R.next_in = 0, R.input = ie, H(J); J.lookahead >= M; ) {
          for (B = J.strstart, $ = J.lookahead - (M - 1); J.ins_h = (J.ins_h << J.hash_shift ^ J.window[B + M - 1]) & J.hash_mask, J.prev[B & J.w_mask] = J.head[J.ins_h], J.head[J.ins_h] = B, B++, --$; ) ;
          J.strstart = B, J.lookahead = M - 1, H(J);
        }
        return J.strstart += J.lookahead, J.block_start = J.strstart, J.insert = J.lookahead, J.lookahead = 0, J.match_length = J.prev_length = M - 1, J.match_available = 0, R.next_in = z, R.input = K, R.avail_in = U, J.wrap = se, y;
      }, o.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(i, r, o) {
      r.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(i, r, o) {
      r.exports = function(a, l) {
        var c, u, d, h, m, p, y, _, v, g, S, w, x, C, E, P, T, b, M, L, N, D, O, A, G;
        c = a.state, u = a.next_in, A = a.input, d = u + (a.avail_in - 5), h = a.next_out, G = a.output, m = h - (l - a.avail_out), p = h + (a.avail_out - 257), y = c.dmax, _ = c.wsize, v = c.whave, g = c.wnext, S = c.window, w = c.hold, x = c.bits, C = c.lencode, E = c.distcode, P = (1 << c.lenbits) - 1, T = (1 << c.distbits) - 1;
        e: do {
          x < 15 && (w += A[u++] << x, x += 8, w += A[u++] << x, x += 8), b = C[w & P];
          t: for (; ; ) {
            if (w >>>= M = b >>> 24, x -= M, (M = b >>> 16 & 255) === 0) G[h++] = 65535 & b;
            else {
              if (!(16 & M)) {
                if (!(64 & M)) {
                  b = C[(65535 & b) + (w & (1 << M) - 1)];
                  continue t;
                }
                if (32 & M) {
                  c.mode = 12;
                  break e;
                }
                a.msg = "invalid literal/length code", c.mode = 30;
                break e;
              }
              L = 65535 & b, (M &= 15) && (x < M && (w += A[u++] << x, x += 8), L += w & (1 << M) - 1, w >>>= M, x -= M), x < 15 && (w += A[u++] << x, x += 8, w += A[u++] << x, x += 8), b = E[w & T];
              n: for (; ; ) {
                if (w >>>= M = b >>> 24, x -= M, !(16 & (M = b >>> 16 & 255))) {
                  if (!(64 & M)) {
                    b = E[(65535 & b) + (w & (1 << M) - 1)];
                    continue n;
                  }
                  a.msg = "invalid distance code", c.mode = 30;
                  break e;
                }
                if (N = 65535 & b, x < (M &= 15) && (w += A[u++] << x, (x += 8) < M && (w += A[u++] << x, x += 8)), y < (N += w & (1 << M) - 1)) {
                  a.msg = "invalid distance too far back", c.mode = 30;
                  break e;
                }
                if (w >>>= M, x -= M, (M = h - m) < N) {
                  if (v < (M = N - M) && c.sane) {
                    a.msg = "invalid distance too far back", c.mode = 30;
                    break e;
                  }
                  if (O = S, (D = 0) === g) {
                    if (D += _ - M, M < L) {
                      for (L -= M; G[h++] = S[D++], --M; ) ;
                      D = h - N, O = G;
                    }
                  } else if (g < M) {
                    if (D += _ + g - M, (M -= g) < L) {
                      for (L -= M; G[h++] = S[D++], --M; ) ;
                      if (D = 0, g < L) {
                        for (L -= M = g; G[h++] = S[D++], --M; ) ;
                        D = h - N, O = G;
                      }
                    }
                  } else if (D += g - M, M < L) {
                    for (L -= M; G[h++] = S[D++], --M; ) ;
                    D = h - N, O = G;
                  }
                  for (; 2 < L; ) G[h++] = O[D++], G[h++] = O[D++], G[h++] = O[D++], L -= 3;
                  L && (G[h++] = O[D++], 1 < L && (G[h++] = O[D++]));
                } else {
                  for (D = h - N; G[h++] = G[D++], G[h++] = G[D++], G[h++] = G[D++], 2 < (L -= 3); ) ;
                  L && (G[h++] = G[D++], 1 < L && (G[h++] = G[D++]));
                }
                break;
              }
            }
            break;
          }
        } while (u < d && h < p);
        u -= L = x >> 3, w &= (1 << (x -= L << 3)) - 1, a.next_in = u, a.next_out = h, a.avail_in = u < d ? d - u + 5 : 5 - (u - d), a.avail_out = h < p ? p - h + 257 : 257 - (h - p), c.hold = w, c.bits = x;
      };
    }, {}], 49: [function(i, r, o) {
      var a = i("../utils/common"), l = i("./adler32"), c = i("./crc32"), u = i("./inffast"), d = i("./inftrees"), h = 1, m = 2, p = 0, y = -2, _ = 1, v = 852, g = 592;
      function S(D) {
        return (D >>> 24 & 255) + (D >>> 8 & 65280) + ((65280 & D) << 8) + ((255 & D) << 24);
      }
      function w() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function x(D) {
        var O;
        return D && D.state ? (O = D.state, D.total_in = D.total_out = O.total = 0, D.msg = "", O.wrap && (D.adler = 1 & O.wrap), O.mode = _, O.last = 0, O.havedict = 0, O.dmax = 32768, O.head = null, O.hold = 0, O.bits = 0, O.lencode = O.lendyn = new a.Buf32(v), O.distcode = O.distdyn = new a.Buf32(g), O.sane = 1, O.back = -1, p) : y;
      }
      function C(D) {
        var O;
        return D && D.state ? ((O = D.state).wsize = 0, O.whave = 0, O.wnext = 0, x(D)) : y;
      }
      function E(D, O) {
        var A, G;
        return D && D.state ? (G = D.state, O < 0 ? (A = 0, O = -O) : (A = 1 + (O >> 4), O < 48 && (O &= 15)), O && (O < 8 || 15 < O) ? y : (G.window !== null && G.wbits !== O && (G.window = null), G.wrap = A, G.wbits = O, C(D))) : y;
      }
      function P(D, O) {
        var A, G;
        return D ? (G = new w(), (D.state = G).window = null, (A = E(D, O)) !== p && (D.state = null), A) : y;
      }
      var T, b, M = !0;
      function L(D) {
        if (M) {
          var O;
          for (T = new a.Buf32(512), b = new a.Buf32(32), O = 0; O < 144; ) D.lens[O++] = 8;
          for (; O < 256; ) D.lens[O++] = 9;
          for (; O < 280; ) D.lens[O++] = 7;
          for (; O < 288; ) D.lens[O++] = 8;
          for (d(h, D.lens, 0, 288, T, 0, D.work, { bits: 9 }), O = 0; O < 32; ) D.lens[O++] = 5;
          d(m, D.lens, 0, 32, b, 0, D.work, { bits: 5 }), M = !1;
        }
        D.lencode = T, D.lenbits = 9, D.distcode = b, D.distbits = 5;
      }
      function N(D, O, A, G) {
        var he, ee = D.state;
        return ee.window === null && (ee.wsize = 1 << ee.wbits, ee.wnext = 0, ee.whave = 0, ee.window = new a.Buf8(ee.wsize)), G >= ee.wsize ? (a.arraySet(ee.window, O, A - ee.wsize, ee.wsize, 0), ee.wnext = 0, ee.whave = ee.wsize) : (G < (he = ee.wsize - ee.wnext) && (he = G), a.arraySet(ee.window, O, A - G, he, ee.wnext), (G -= he) ? (a.arraySet(ee.window, O, A - G, G, 0), ee.wnext = G, ee.whave = ee.wsize) : (ee.wnext += he, ee.wnext === ee.wsize && (ee.wnext = 0), ee.whave < ee.wsize && (ee.whave += he))), 0;
      }
      o.inflateReset = C, o.inflateReset2 = E, o.inflateResetKeep = x, o.inflateInit = function(D) {
        return P(D, 15);
      }, o.inflateInit2 = P, o.inflate = function(D, O) {
        var A, G, he, ee, le, oe, Y, j, q, te, ne, de, H, X, V, I, F, k, Q, Z, R, ie, J, B, $ = 0, se = new a.Buf8(4), U = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!D || !D.state || !D.output || !D.input && D.avail_in !== 0) return y;
        (A = D.state).mode === 12 && (A.mode = 13), le = D.next_out, he = D.output, Y = D.avail_out, ee = D.next_in, G = D.input, oe = D.avail_in, j = A.hold, q = A.bits, te = oe, ne = Y, ie = p;
        e: for (; ; ) switch (A.mode) {
          case _:
            if (A.wrap === 0) {
              A.mode = 13;
              break;
            }
            for (; q < 16; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            if (2 & A.wrap && j === 35615) {
              se[A.check = 0] = 255 & j, se[1] = j >>> 8 & 255, A.check = c(A.check, se, 2, 0), q = j = 0, A.mode = 2;
              break;
            }
            if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & j) << 8) + (j >> 8)) % 31) {
              D.msg = "incorrect header check", A.mode = 30;
              break;
            }
            if ((15 & j) != 8) {
              D.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (q -= 4, R = 8 + (15 & (j >>>= 4)), A.wbits === 0) A.wbits = R;
            else if (R > A.wbits) {
              D.msg = "invalid window size", A.mode = 30;
              break;
            }
            A.dmax = 1 << R, D.adler = A.check = 1, A.mode = 512 & j ? 10 : 12, q = j = 0;
            break;
          case 2:
            for (; q < 16; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            if (A.flags = j, (255 & A.flags) != 8) {
              D.msg = "unknown compression method", A.mode = 30;
              break;
            }
            if (57344 & A.flags) {
              D.msg = "unknown header flags set", A.mode = 30;
              break;
            }
            A.head && (A.head.text = j >> 8 & 1), 512 & A.flags && (se[0] = 255 & j, se[1] = j >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = j = 0, A.mode = 3;
          case 3:
            for (; q < 32; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            A.head && (A.head.time = j), 512 & A.flags && (se[0] = 255 & j, se[1] = j >>> 8 & 255, se[2] = j >>> 16 & 255, se[3] = j >>> 24 & 255, A.check = c(A.check, se, 4, 0)), q = j = 0, A.mode = 4;
          case 4:
            for (; q < 16; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            A.head && (A.head.xflags = 255 & j, A.head.os = j >> 8), 512 & A.flags && (se[0] = 255 & j, se[1] = j >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = j = 0, A.mode = 5;
          case 5:
            if (1024 & A.flags) {
              for (; q < 16; ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              A.length = j, A.head && (A.head.extra_len = j), 512 & A.flags && (se[0] = 255 & j, se[1] = j >>> 8 & 255, A.check = c(A.check, se, 2, 0)), q = j = 0;
            } else A.head && (A.head.extra = null);
            A.mode = 6;
          case 6:
            if (1024 & A.flags && (oe < (de = A.length) && (de = oe), de && (A.head && (R = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), a.arraySet(A.head.extra, G, ee, de, R)), 512 & A.flags && (A.check = c(A.check, G, de, ee)), oe -= de, ee += de, A.length -= de), A.length)) break e;
            A.length = 0, A.mode = 7;
          case 7:
            if (2048 & A.flags) {
              if (oe === 0) break e;
              for (de = 0; R = G[ee + de++], A.head && R && A.length < 65536 && (A.head.name += String.fromCharCode(R)), R && de < oe; ) ;
              if (512 & A.flags && (A.check = c(A.check, G, de, ee)), oe -= de, ee += de, R) break e;
            } else A.head && (A.head.name = null);
            A.length = 0, A.mode = 8;
          case 8:
            if (4096 & A.flags) {
              if (oe === 0) break e;
              for (de = 0; R = G[ee + de++], A.head && R && A.length < 65536 && (A.head.comment += String.fromCharCode(R)), R && de < oe; ) ;
              if (512 & A.flags && (A.check = c(A.check, G, de, ee)), oe -= de, ee += de, R) break e;
            } else A.head && (A.head.comment = null);
            A.mode = 9;
          case 9:
            if (512 & A.flags) {
              for (; q < 16; ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              if (j !== (65535 & A.check)) {
                D.msg = "header crc mismatch", A.mode = 30;
                break;
              }
              q = j = 0;
            }
            A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), D.adler = A.check = 0, A.mode = 12;
            break;
          case 10:
            for (; q < 32; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            D.adler = A.check = S(j), q = j = 0, A.mode = 11;
          case 11:
            if (A.havedict === 0) return D.next_out = le, D.avail_out = Y, D.next_in = ee, D.avail_in = oe, A.hold = j, A.bits = q, 2;
            D.adler = A.check = 1, A.mode = 12;
          case 12:
            if (O === 5 || O === 6) break e;
          case 13:
            if (A.last) {
              j >>>= 7 & q, q -= 7 & q, A.mode = 27;
              break;
            }
            for (; q < 3; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            switch (A.last = 1 & j, q -= 1, 3 & (j >>>= 1)) {
              case 0:
                A.mode = 14;
                break;
              case 1:
                if (L(A), A.mode = 20, O !== 6) break;
                j >>>= 2, q -= 2;
                break e;
              case 2:
                A.mode = 17;
                break;
              case 3:
                D.msg = "invalid block type", A.mode = 30;
            }
            j >>>= 2, q -= 2;
            break;
          case 14:
            for (j >>>= 7 & q, q -= 7 & q; q < 32; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            if ((65535 & j) != (j >>> 16 ^ 65535)) {
              D.msg = "invalid stored block lengths", A.mode = 30;
              break;
            }
            if (A.length = 65535 & j, q = j = 0, A.mode = 15, O === 6) break e;
          case 15:
            A.mode = 16;
          case 16:
            if (de = A.length) {
              if (oe < de && (de = oe), Y < de && (de = Y), de === 0) break e;
              a.arraySet(he, G, ee, de, le), oe -= de, ee += de, Y -= de, le += de, A.length -= de;
              break;
            }
            A.mode = 12;
            break;
          case 17:
            for (; q < 14; ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            if (A.nlen = 257 + (31 & j), j >>>= 5, q -= 5, A.ndist = 1 + (31 & j), j >>>= 5, q -= 5, A.ncode = 4 + (15 & j), j >>>= 4, q -= 4, 286 < A.nlen || 30 < A.ndist) {
              D.msg = "too many length or distance symbols", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 18;
          case 18:
            for (; A.have < A.ncode; ) {
              for (; q < 3; ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              A.lens[U[A.have++]] = 7 & j, j >>>= 3, q -= 3;
            }
            for (; A.have < 19; ) A.lens[U[A.have++]] = 0;
            if (A.lencode = A.lendyn, A.lenbits = 7, J = { bits: A.lenbits }, ie = d(0, A.lens, 0, 19, A.lencode, 0, A.work, J), A.lenbits = J.bits, ie) {
              D.msg = "invalid code lengths set", A.mode = 30;
              break;
            }
            A.have = 0, A.mode = 19;
          case 19:
            for (; A.have < A.nlen + A.ndist; ) {
              for (; I = ($ = A.lencode[j & (1 << A.lenbits) - 1]) >>> 16 & 255, F = 65535 & $, !((V = $ >>> 24) <= q); ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              if (F < 16) j >>>= V, q -= V, A.lens[A.have++] = F;
              else {
                if (F === 16) {
                  for (B = V + 2; q < B; ) {
                    if (oe === 0) break e;
                    oe--, j += G[ee++] << q, q += 8;
                  }
                  if (j >>>= V, q -= V, A.have === 0) {
                    D.msg = "invalid bit length repeat", A.mode = 30;
                    break;
                  }
                  R = A.lens[A.have - 1], de = 3 + (3 & j), j >>>= 2, q -= 2;
                } else if (F === 17) {
                  for (B = V + 3; q < B; ) {
                    if (oe === 0) break e;
                    oe--, j += G[ee++] << q, q += 8;
                  }
                  q -= V, R = 0, de = 3 + (7 & (j >>>= V)), j >>>= 3, q -= 3;
                } else {
                  for (B = V + 7; q < B; ) {
                    if (oe === 0) break e;
                    oe--, j += G[ee++] << q, q += 8;
                  }
                  q -= V, R = 0, de = 11 + (127 & (j >>>= V)), j >>>= 7, q -= 7;
                }
                if (A.have + de > A.nlen + A.ndist) {
                  D.msg = "invalid bit length repeat", A.mode = 30;
                  break;
                }
                for (; de--; ) A.lens[A.have++] = R;
              }
            }
            if (A.mode === 30) break;
            if (A.lens[256] === 0) {
              D.msg = "invalid code -- missing end-of-block", A.mode = 30;
              break;
            }
            if (A.lenbits = 9, J = { bits: A.lenbits }, ie = d(h, A.lens, 0, A.nlen, A.lencode, 0, A.work, J), A.lenbits = J.bits, ie) {
              D.msg = "invalid literal/lengths set", A.mode = 30;
              break;
            }
            if (A.distbits = 6, A.distcode = A.distdyn, J = { bits: A.distbits }, ie = d(m, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, J), A.distbits = J.bits, ie) {
              D.msg = "invalid distances set", A.mode = 30;
              break;
            }
            if (A.mode = 20, O === 6) break e;
          case 20:
            A.mode = 21;
          case 21:
            if (6 <= oe && 258 <= Y) {
              D.next_out = le, D.avail_out = Y, D.next_in = ee, D.avail_in = oe, A.hold = j, A.bits = q, u(D, ne), le = D.next_out, he = D.output, Y = D.avail_out, ee = D.next_in, G = D.input, oe = D.avail_in, j = A.hold, q = A.bits, A.mode === 12 && (A.back = -1);
              break;
            }
            for (A.back = 0; I = ($ = A.lencode[j & (1 << A.lenbits) - 1]) >>> 16 & 255, F = 65535 & $, !((V = $ >>> 24) <= q); ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            if (I && !(240 & I)) {
              for (k = V, Q = I, Z = F; I = ($ = A.lencode[Z + ((j & (1 << k + Q) - 1) >> k)]) >>> 16 & 255, F = 65535 & $, !(k + (V = $ >>> 24) <= q); ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              j >>>= k, q -= k, A.back += k;
            }
            if (j >>>= V, q -= V, A.back += V, A.length = F, I === 0) {
              A.mode = 26;
              break;
            }
            if (32 & I) {
              A.back = -1, A.mode = 12;
              break;
            }
            if (64 & I) {
              D.msg = "invalid literal/length code", A.mode = 30;
              break;
            }
            A.extra = 15 & I, A.mode = 22;
          case 22:
            if (A.extra) {
              for (B = A.extra; q < B; ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              A.length += j & (1 << A.extra) - 1, j >>>= A.extra, q -= A.extra, A.back += A.extra;
            }
            A.was = A.length, A.mode = 23;
          case 23:
            for (; I = ($ = A.distcode[j & (1 << A.distbits) - 1]) >>> 16 & 255, F = 65535 & $, !((V = $ >>> 24) <= q); ) {
              if (oe === 0) break e;
              oe--, j += G[ee++] << q, q += 8;
            }
            if (!(240 & I)) {
              for (k = V, Q = I, Z = F; I = ($ = A.distcode[Z + ((j & (1 << k + Q) - 1) >> k)]) >>> 16 & 255, F = 65535 & $, !(k + (V = $ >>> 24) <= q); ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              j >>>= k, q -= k, A.back += k;
            }
            if (j >>>= V, q -= V, A.back += V, 64 & I) {
              D.msg = "invalid distance code", A.mode = 30;
              break;
            }
            A.offset = F, A.extra = 15 & I, A.mode = 24;
          case 24:
            if (A.extra) {
              for (B = A.extra; q < B; ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              A.offset += j & (1 << A.extra) - 1, j >>>= A.extra, q -= A.extra, A.back += A.extra;
            }
            if (A.offset > A.dmax) {
              D.msg = "invalid distance too far back", A.mode = 30;
              break;
            }
            A.mode = 25;
          case 25:
            if (Y === 0) break e;
            if (de = ne - Y, A.offset > de) {
              if ((de = A.offset - de) > A.whave && A.sane) {
                D.msg = "invalid distance too far back", A.mode = 30;
                break;
              }
              H = de > A.wnext ? (de -= A.wnext, A.wsize - de) : A.wnext - de, de > A.length && (de = A.length), X = A.window;
            } else X = he, H = le - A.offset, de = A.length;
            for (Y < de && (de = Y), Y -= de, A.length -= de; he[le++] = X[H++], --de; ) ;
            A.length === 0 && (A.mode = 21);
            break;
          case 26:
            if (Y === 0) break e;
            he[le++] = A.length, Y--, A.mode = 21;
            break;
          case 27:
            if (A.wrap) {
              for (; q < 32; ) {
                if (oe === 0) break e;
                oe--, j |= G[ee++] << q, q += 8;
              }
              if (ne -= Y, D.total_out += ne, A.total += ne, ne && (D.adler = A.check = A.flags ? c(A.check, he, ne, le - ne) : l(A.check, he, ne, le - ne)), ne = Y, (A.flags ? j : S(j)) !== A.check) {
                D.msg = "incorrect data check", A.mode = 30;
                break;
              }
              q = j = 0;
            }
            A.mode = 28;
          case 28:
            if (A.wrap && A.flags) {
              for (; q < 32; ) {
                if (oe === 0) break e;
                oe--, j += G[ee++] << q, q += 8;
              }
              if (j !== (4294967295 & A.total)) {
                D.msg = "incorrect length check", A.mode = 30;
                break;
              }
              q = j = 0;
            }
            A.mode = 29;
          case 29:
            ie = 1;
            break e;
          case 30:
            ie = -3;
            break e;
          case 31:
            return -4;
          case 32:
          default:
            return y;
        }
        return D.next_out = le, D.avail_out = Y, D.next_in = ee, D.avail_in = oe, A.hold = j, A.bits = q, (A.wsize || ne !== D.avail_out && A.mode < 30 && (A.mode < 27 || O !== 4)) && N(D, D.output, D.next_out, ne - D.avail_out) ? (A.mode = 31, -4) : (te -= D.avail_in, ne -= D.avail_out, D.total_in += te, D.total_out += ne, A.total += ne, A.wrap && ne && (D.adler = A.check = A.flags ? c(A.check, he, ne, D.next_out - ne) : l(A.check, he, ne, D.next_out - ne)), D.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (te == 0 && ne === 0 || O === 4) && ie === p && (ie = -5), ie);
      }, o.inflateEnd = function(D) {
        if (!D || !D.state) return y;
        var O = D.state;
        return O.window && (O.window = null), D.state = null, p;
      }, o.inflateGetHeader = function(D, O) {
        var A;
        return D && D.state && 2 & (A = D.state).wrap ? ((A.head = O).done = !1, p) : y;
      }, o.inflateSetDictionary = function(D, O) {
        var A, G = O.length;
        return D && D.state ? (A = D.state).wrap !== 0 && A.mode !== 11 ? y : A.mode === 11 && l(1, O, G, 0) !== A.check ? -3 : N(D, O, G, G) ? (A.mode = 31, -4) : (A.havedict = 1, p) : y;
      }, o.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(i, r, o) {
      var a = i("../utils/common"), l = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], c = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], u = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], d = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      r.exports = function(h, m, p, y, _, v, g, S) {
        var w, x, C, E, P, T, b, M, L, N = S.bits, D = 0, O = 0, A = 0, G = 0, he = 0, ee = 0, le = 0, oe = 0, Y = 0, j = 0, q = null, te = 0, ne = new a.Buf16(16), de = new a.Buf16(16), H = null, X = 0;
        for (D = 0; D <= 15; D++) ne[D] = 0;
        for (O = 0; O < y; O++) ne[m[p + O]]++;
        for (he = N, G = 15; 1 <= G && ne[G] === 0; G--) ;
        if (G < he && (he = G), G === 0) return _[v++] = 20971520, _[v++] = 20971520, S.bits = 1, 0;
        for (A = 1; A < G && ne[A] === 0; A++) ;
        for (he < A && (he = A), D = oe = 1; D <= 15; D++) if (oe <<= 1, (oe -= ne[D]) < 0) return -1;
        if (0 < oe && (h === 0 || G !== 1)) return -1;
        for (de[1] = 0, D = 1; D < 15; D++) de[D + 1] = de[D] + ne[D];
        for (O = 0; O < y; O++) m[p + O] !== 0 && (g[de[m[p + O]]++] = O);
        if (T = h === 0 ? (q = H = g, 19) : h === 1 ? (q = l, te -= 257, H = c, X -= 257, 256) : (q = u, H = d, -1), D = A, P = v, le = O = j = 0, C = -1, E = (Y = 1 << (ee = he)) - 1, h === 1 && 852 < Y || h === 2 && 592 < Y) return 1;
        for (; ; ) {
          for (b = D - le, L = g[O] < T ? (M = 0, g[O]) : g[O] > T ? (M = H[X + g[O]], q[te + g[O]]) : (M = 96, 0), w = 1 << D - le, A = x = 1 << ee; _[P + (j >> le) + (x -= w)] = b << 24 | M << 16 | L | 0, x !== 0; ) ;
          for (w = 1 << D - 1; j & w; ) w >>= 1;
          if (w !== 0 ? (j &= w - 1, j += w) : j = 0, O++, --ne[D] == 0) {
            if (D === G) break;
            D = m[p + g[O]];
          }
          if (he < D && (j & E) !== C) {
            for (le === 0 && (le = he), P += A, oe = 1 << (ee = D - le); ee + le < G && !((oe -= ne[ee + le]) <= 0); ) ee++, oe <<= 1;
            if (Y += 1 << ee, h === 1 && 852 < Y || h === 2 && 592 < Y) return 1;
            _[C = j & E] = he << 24 | ee << 16 | P - v | 0;
          }
        }
        return j !== 0 && (_[P + j] = D - le << 24 | 64 << 16 | 0), S.bits = he, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(i, r, o) {
      r.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(i, r, o) {
      var a = i("../utils/common"), l = 0, c = 1;
      function u($) {
        for (var se = $.length; 0 <= --se; ) $[se] = 0;
      }
      var d = 0, h = 29, m = 256, p = m + 1 + h, y = 30, _ = 19, v = 2 * p + 1, g = 15, S = 16, w = 7, x = 256, C = 16, E = 17, P = 18, T = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], b = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], M = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], L = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], N = new Array(2 * (p + 2));
      u(N);
      var D = new Array(2 * y);
      u(D);
      var O = new Array(512);
      u(O);
      var A = new Array(256);
      u(A);
      var G = new Array(h);
      u(G);
      var he, ee, le, oe = new Array(y);
      function Y($, se, U, z, K) {
        this.static_tree = $, this.extra_bits = se, this.extra_base = U, this.elems = z, this.max_length = K, this.has_stree = $ && $.length;
      }
      function j($, se) {
        this.dyn_tree = $, this.max_code = 0, this.stat_desc = se;
      }
      function q($) {
        return $ < 256 ? O[$] : O[256 + ($ >>> 7)];
      }
      function te($, se) {
        $.pending_buf[$.pending++] = 255 & se, $.pending_buf[$.pending++] = se >>> 8 & 255;
      }
      function ne($, se, U) {
        $.bi_valid > S - U ? ($.bi_buf |= se << $.bi_valid & 65535, te($, $.bi_buf), $.bi_buf = se >> S - $.bi_valid, $.bi_valid += U - S) : ($.bi_buf |= se << $.bi_valid & 65535, $.bi_valid += U);
      }
      function de($, se, U) {
        ne($, U[2 * se], U[2 * se + 1]);
      }
      function H($, se) {
        for (var U = 0; U |= 1 & $, $ >>>= 1, U <<= 1, 0 < --se; ) ;
        return U >>> 1;
      }
      function X($, se, U) {
        var z, K, ue = new Array(g + 1), me = 0;
        for (z = 1; z <= g; z++) ue[z] = me = me + U[z - 1] << 1;
        for (K = 0; K <= se; K++) {
          var ge = $[2 * K + 1];
          ge !== 0 && ($[2 * K] = H(ue[ge]++, ge));
        }
      }
      function V($) {
        var se;
        for (se = 0; se < p; se++) $.dyn_ltree[2 * se] = 0;
        for (se = 0; se < y; se++) $.dyn_dtree[2 * se] = 0;
        for (se = 0; se < _; se++) $.bl_tree[2 * se] = 0;
        $.dyn_ltree[2 * x] = 1, $.opt_len = $.static_len = 0, $.last_lit = $.matches = 0;
      }
      function I($) {
        8 < $.bi_valid ? te($, $.bi_buf) : 0 < $.bi_valid && ($.pending_buf[$.pending++] = $.bi_buf), $.bi_buf = 0, $.bi_valid = 0;
      }
      function F($, se, U, z) {
        var K = 2 * se, ue = 2 * U;
        return $[K] < $[ue] || $[K] === $[ue] && z[se] <= z[U];
      }
      function k($, se, U) {
        for (var z = $.heap[U], K = U << 1; K <= $.heap_len && (K < $.heap_len && F(se, $.heap[K + 1], $.heap[K], $.depth) && K++, !F(se, z, $.heap[K], $.depth)); ) $.heap[U] = $.heap[K], U = K, K <<= 1;
        $.heap[U] = z;
      }
      function Q($, se, U) {
        var z, K, ue, me, ge = 0;
        if ($.last_lit !== 0) for (; z = $.pending_buf[$.d_buf + 2 * ge] << 8 | $.pending_buf[$.d_buf + 2 * ge + 1], K = $.pending_buf[$.l_buf + ge], ge++, z === 0 ? de($, K, se) : (de($, (ue = A[K]) + m + 1, se), (me = T[ue]) !== 0 && ne($, K -= G[ue], me), de($, ue = q(--z), U), (me = b[ue]) !== 0 && ne($, z -= oe[ue], me)), ge < $.last_lit; ) ;
        de($, x, se);
      }
      function Z($, se) {
        var U, z, K, ue = se.dyn_tree, me = se.stat_desc.static_tree, ge = se.stat_desc.has_stree, Me = se.stat_desc.elems, Te = -1;
        for ($.heap_len = 0, $.heap_max = v, U = 0; U < Me; U++) ue[2 * U] !== 0 ? ($.heap[++$.heap_len] = Te = U, $.depth[U] = 0) : ue[2 * U + 1] = 0;
        for (; $.heap_len < 2; ) ue[2 * (K = $.heap[++$.heap_len] = Te < 2 ? ++Te : 0)] = 1, $.depth[K] = 0, $.opt_len--, ge && ($.static_len -= me[2 * K + 1]);
        for (se.max_code = Te, U = $.heap_len >> 1; 1 <= U; U--) k($, ue, U);
        for (K = Me; U = $.heap[1], $.heap[1] = $.heap[$.heap_len--], k($, ue, 1), z = $.heap[1], $.heap[--$.heap_max] = U, $.heap[--$.heap_max] = z, ue[2 * K] = ue[2 * U] + ue[2 * z], $.depth[K] = ($.depth[U] >= $.depth[z] ? $.depth[U] : $.depth[z]) + 1, ue[2 * U + 1] = ue[2 * z + 1] = K, $.heap[1] = K++, k($, ue, 1), 2 <= $.heap_len; ) ;
        $.heap[--$.heap_max] = $.heap[1], function(Ae, Xe) {
          var Fe, He, Ye, We, ke, nt, Je = Xe.dyn_tree, _t = Xe.max_code, we = Xe.stat_desc.static_tree, ze = Xe.stat_desc.has_stree, De = Xe.stat_desc.extra_bits, Be = Xe.stat_desc.extra_base, je = Xe.stat_desc.max_length, Ve = 0;
          for (We = 0; We <= g; We++) Ae.bl_count[We] = 0;
          for (Je[2 * Ae.heap[Ae.heap_max] + 1] = 0, Fe = Ae.heap_max + 1; Fe < v; Fe++) je < (We = Je[2 * Je[2 * (He = Ae.heap[Fe]) + 1] + 1] + 1) && (We = je, Ve++), Je[2 * He + 1] = We, _t < He || (Ae.bl_count[We]++, ke = 0, Be <= He && (ke = De[He - Be]), nt = Je[2 * He], Ae.opt_len += nt * (We + ke), ze && (Ae.static_len += nt * (we[2 * He + 1] + ke)));
          if (Ve !== 0) {
            do {
              for (We = je - 1; Ae.bl_count[We] === 0; ) We--;
              Ae.bl_count[We]--, Ae.bl_count[We + 1] += 2, Ae.bl_count[je]--, Ve -= 2;
            } while (0 < Ve);
            for (We = je; We !== 0; We--) for (He = Ae.bl_count[We]; He !== 0; ) _t < (Ye = Ae.heap[--Fe]) || (Je[2 * Ye + 1] !== We && (Ae.opt_len += (We - Je[2 * Ye + 1]) * Je[2 * Ye], Je[2 * Ye + 1] = We), He--);
          }
        }($, se), X(ue, Te, $.bl_count);
      }
      function R($, se, U) {
        var z, K, ue = -1, me = se[1], ge = 0, Me = 7, Te = 4;
        for (me === 0 && (Me = 138, Te = 3), se[2 * (U + 1) + 1] = 65535, z = 0; z <= U; z++) K = me, me = se[2 * (z + 1) + 1], ++ge < Me && K === me || (ge < Te ? $.bl_tree[2 * K] += ge : K !== 0 ? (K !== ue && $.bl_tree[2 * K]++, $.bl_tree[2 * C]++) : ge <= 10 ? $.bl_tree[2 * E]++ : $.bl_tree[2 * P]++, ue = K, Te = (ge = 0) === me ? (Me = 138, 3) : K === me ? (Me = 6, 3) : (Me = 7, 4));
      }
      function ie($, se, U) {
        var z, K, ue = -1, me = se[1], ge = 0, Me = 7, Te = 4;
        for (me === 0 && (Me = 138, Te = 3), z = 0; z <= U; z++) if (K = me, me = se[2 * (z + 1) + 1], !(++ge < Me && K === me)) {
          if (ge < Te) for (; de($, K, $.bl_tree), --ge != 0; ) ;
          else K !== 0 ? (K !== ue && (de($, K, $.bl_tree), ge--), de($, C, $.bl_tree), ne($, ge - 3, 2)) : ge <= 10 ? (de($, E, $.bl_tree), ne($, ge - 3, 3)) : (de($, P, $.bl_tree), ne($, ge - 11, 7));
          ue = K, Te = (ge = 0) === me ? (Me = 138, 3) : K === me ? (Me = 6, 3) : (Me = 7, 4);
        }
      }
      u(oe);
      var J = !1;
      function B($, se, U, z) {
        ne($, (d << 1) + (z ? 1 : 0), 3), function(K, ue, me, ge) {
          I(K), te(K, me), te(K, ~me), a.arraySet(K.pending_buf, K.window, ue, me, K.pending), K.pending += me;
        }($, se, U);
      }
      o._tr_init = function($) {
        J || (function() {
          var se, U, z, K, ue, me = new Array(g + 1);
          for (K = z = 0; K < h - 1; K++) for (G[K] = z, se = 0; se < 1 << T[K]; se++) A[z++] = K;
          for (A[z - 1] = K, K = ue = 0; K < 16; K++) for (oe[K] = ue, se = 0; se < 1 << b[K]; se++) O[ue++] = K;
          for (ue >>= 7; K < y; K++) for (oe[K] = ue << 7, se = 0; se < 1 << b[K] - 7; se++) O[256 + ue++] = K;
          for (U = 0; U <= g; U++) me[U] = 0;
          for (se = 0; se <= 143; ) N[2 * se + 1] = 8, se++, me[8]++;
          for (; se <= 255; ) N[2 * se + 1] = 9, se++, me[9]++;
          for (; se <= 279; ) N[2 * se + 1] = 7, se++, me[7]++;
          for (; se <= 287; ) N[2 * se + 1] = 8, se++, me[8]++;
          for (X(N, p + 1, me), se = 0; se < y; se++) D[2 * se + 1] = 5, D[2 * se] = H(se, 5);
          he = new Y(N, T, m + 1, p, g), ee = new Y(D, b, 0, y, g), le = new Y(new Array(0), M, 0, _, w);
        }(), J = !0), $.l_desc = new j($.dyn_ltree, he), $.d_desc = new j($.dyn_dtree, ee), $.bl_desc = new j($.bl_tree, le), $.bi_buf = 0, $.bi_valid = 0, V($);
      }, o._tr_stored_block = B, o._tr_flush_block = function($, se, U, z) {
        var K, ue, me = 0;
        0 < $.level ? ($.strm.data_type === 2 && ($.strm.data_type = function(ge) {
          var Me, Te = 4093624447;
          for (Me = 0; Me <= 31; Me++, Te >>>= 1) if (1 & Te && ge.dyn_ltree[2 * Me] !== 0) return l;
          if (ge.dyn_ltree[18] !== 0 || ge.dyn_ltree[20] !== 0 || ge.dyn_ltree[26] !== 0) return c;
          for (Me = 32; Me < m; Me++) if (ge.dyn_ltree[2 * Me] !== 0) return c;
          return l;
        }($)), Z($, $.l_desc), Z($, $.d_desc), me = function(ge) {
          var Me;
          for (R(ge, ge.dyn_ltree, ge.l_desc.max_code), R(ge, ge.dyn_dtree, ge.d_desc.max_code), Z(ge, ge.bl_desc), Me = _ - 1; 3 <= Me && ge.bl_tree[2 * L[Me] + 1] === 0; Me--) ;
          return ge.opt_len += 3 * (Me + 1) + 5 + 5 + 4, Me;
        }($), K = $.opt_len + 3 + 7 >>> 3, (ue = $.static_len + 3 + 7 >>> 3) <= K && (K = ue)) : K = ue = U + 5, U + 4 <= K && se !== -1 ? B($, se, U, z) : $.strategy === 4 || ue === K ? (ne($, 2 + (z ? 1 : 0), 3), Q($, N, D)) : (ne($, 4 + (z ? 1 : 0), 3), function(ge, Me, Te, Ae) {
          var Xe;
          for (ne(ge, Me - 257, 5), ne(ge, Te - 1, 5), ne(ge, Ae - 4, 4), Xe = 0; Xe < Ae; Xe++) ne(ge, ge.bl_tree[2 * L[Xe] + 1], 3);
          ie(ge, ge.dyn_ltree, Me - 1), ie(ge, ge.dyn_dtree, Te - 1);
        }($, $.l_desc.max_code + 1, $.d_desc.max_code + 1, me + 1), Q($, $.dyn_ltree, $.dyn_dtree)), V($), z && I($);
      }, o._tr_tally = function($, se, U) {
        return $.pending_buf[$.d_buf + 2 * $.last_lit] = se >>> 8 & 255, $.pending_buf[$.d_buf + 2 * $.last_lit + 1] = 255 & se, $.pending_buf[$.l_buf + $.last_lit] = 255 & U, $.last_lit++, se === 0 ? $.dyn_ltree[2 * U]++ : ($.matches++, se--, $.dyn_ltree[2 * (A[U] + m + 1)]++, $.dyn_dtree[2 * q(se)]++), $.last_lit === $.lit_bufsize - 1;
      }, o._tr_align = function($) {
        ne($, 2, 3), de($, x, N), function(se) {
          se.bi_valid === 16 ? (te(se, se.bi_buf), se.bi_buf = 0, se.bi_valid = 0) : 8 <= se.bi_valid && (se.pending_buf[se.pending++] = 255 & se.bi_buf, se.bi_buf >>= 8, se.bi_valid -= 8);
        }($);
      };
    }, { "../utils/common": 41 }], 53: [function(i, r, o) {
      r.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(i, r, o) {
      (function(a) {
        (function(l, c) {
          if (!l.setImmediate) {
            var u, d, h, m, p = 1, y = {}, _ = !1, v = l.document, g = Object.getPrototypeOf && Object.getPrototypeOf(l);
            g = g && g.setTimeout ? g : l, u = {}.toString.call(l.process) === "[object process]" ? function(C) {
              n.nextTick(function() {
                w(C);
              });
            } : function() {
              if (l.postMessage && !l.importScripts) {
                var C = !0, E = l.onmessage;
                return l.onmessage = function() {
                  C = !1;
                }, l.postMessage("", "*"), l.onmessage = E, C;
              }
            }() ? (m = "setImmediate$" + Math.random() + "$", l.addEventListener ? l.addEventListener("message", x, !1) : l.attachEvent("onmessage", x), function(C) {
              l.postMessage(m + C, "*");
            }) : l.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(C) {
              w(C.data);
            }, function(C) {
              h.port2.postMessage(C);
            }) : v && "onreadystatechange" in v.createElement("script") ? (d = v.documentElement, function(C) {
              var E = v.createElement("script");
              E.onreadystatechange = function() {
                w(C), E.onreadystatechange = null, d.removeChild(E), E = null;
              }, d.appendChild(E);
            }) : function(C) {
              setTimeout(w, 0, C);
            }, g.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var E = new Array(arguments.length - 1), P = 0; P < E.length; P++) E[P] = arguments[P + 1];
              var T = { callback: C, args: E };
              return y[p] = T, u(p), p++;
            }, g.clearImmediate = S;
          }
          function S(C) {
            delete y[C];
          }
          function w(C) {
            if (_) setTimeout(w, 0, C);
            else {
              var E = y[C];
              if (E) {
                _ = !0;
                try {
                  (function(P) {
                    var T = P.callback, b = P.args;
                    switch (b.length) {
                      case 0:
                        T();
                        break;
                      case 1:
                        T(b[0]);
                        break;
                      case 2:
                        T(b[0], b[1]);
                        break;
                      case 3:
                        T(b[0], b[1], b[2]);
                        break;
                      default:
                        T.apply(c, b);
                    }
                  })(E);
                } finally {
                  S(C), _ = !1;
                }
              }
            }
          }
          function x(C) {
            C.source === l && typeof C.data == "string" && C.data.indexOf(m) === 0 && w(+C.data.slice(m.length));
          }
        })(typeof self > "u" ? a === void 0 ? this : a : self);
      }).call(this, typeof mc < "u" ? mc : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(Oy);
var fG = Oy.exports;
const pG = /* @__PURE__ */ hG(fG), mG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: pG
}, Symbol.toStringTag, { value: "Module" }));
export {
  Qv as mountApp,
  gG as sendToComfyUI
};
